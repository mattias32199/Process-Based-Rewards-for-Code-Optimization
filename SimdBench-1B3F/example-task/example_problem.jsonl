{"task_id": "SimdBench_0_AVX", "prompt": "#include <immintrin.h>\n#include <x86intrin.h>\n\n/*\nThe inputs to this function are: pointers to:\n- A non-empty source array of 64-bit integers (src);\n- A non-empty destination array of 64-bit integers (dst);\n- A non-empty mask array of boolean values (mask);\n- Their common length (length).\n\nYour goal is to conditionally copy elements from src to dst where the corresponding mask value is true.\nThe requirement is to implement the function with AVX/AVX2 (Advanced Vector Extensions) intrinsics for parallelism.\n*/\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n}", "solution_scalar": "void conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) dst[i] = src[i];\n    }\n}", "test_correctness": "bool correctness_check(int iterations) {\n    Random rng;\n    for (int  i = 0; i < iterations; i++){\n        /* one check */\n        size_t length = Small_Arg_1D;\n        std::vector<int64_t> src(length); rng.initialize_vector_with_random_values(src);\n        std::vector<int64_t> dst(length); rng.initialize_vector_with_random_values(dst);\n        std::vector<int64_t> dst_simd(dst); \n        std::vector<uint8_t> mask(length); rng.initialize_vector_with_random_values(mask, true);\n\n        conditional_move(src.data(), dst.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        conditional_move_simd(src.data(), dst_simd.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        \n        if(!allclose(dst, dst_simd)){\n            if(ERROR_PRINT) std::cerr << \"Correctness check failed!\" << std::endl;\n            return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    bool pass = correctness_check(ITERATIONS);\n    printf(\"{ \\\"correctness\\\": %s }\\n\", pass ? \"1\" : \"0\");\n    return 0;\n}", "test_performance": "template<void (*Func)(const int64_t *, int64_t *, const bool *, size_t)>\nstatic void BM(benchmark::State& state) {\n    const size_t length = state.range(0);\n    Random rng;\n    std::vector<int64_t> src(length); rng.initialize_vector_with_random_values(src);\n    std::vector<int64_t> dst(length); rng.initialize_vector_with_random_values(dst);\n    std::vector<uint8_t> mask(length); rng.initialize_vector_with_random_values(mask, true);\n    \n    for (auto _ : state) {\n        Func(src.data(), dst.data(), reinterpret_cast<const bool*>(mask.data()), length);\n        benchmark::DoNotOptimize(dst.data()); // Prevent optimization of the result\n    }\n}\n\nBENCHMARK_TEMPLATE(BM, conditional_move)->Name(\"Scalar\")->Large_Args_1D;\nBENCHMARK_TEMPLATE(BM, conditional_move_simd)->Name(\"SIMD\")->Large_Args_1D;\n\nBENCHMARK_MAIN();", "intrinsic": "AVX", "task": "generation", "type": "1", "subtype": "1-1", "entrypoint_scalar": "conditional_move", "entrypoint_simd": "conditional_move_simd"}

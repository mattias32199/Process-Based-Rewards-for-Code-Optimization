{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n        \n        // Load mask values and convert to integer mask\n        uint64x2_t mask_vec = {mask[i], mask[i+1]};\n        uint64x2_t mask_int = vcgtq_u64(mask_vec, vdupq_n_u64(0));\n        \n        // Load destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        \n        // Conditionally select values using bitwise AND with mask\n        int64x2_t result = vbslq_s64(mask_int, src_vec, dst_vec);\n        \n        // Store result back to destination\n        vst1q_s64(dst + i, result);\n    }\n    \n    // Handle remaining single element if length is odd\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n        \n        // Load mask values and convert to integer mask\n        uint64x2_t mask_vec = {mask[i], mask[i+1]};\n        uint64x2_t mask_int = vreinterpretq_u64_u8(vcreate_u8(mask_vec[0] | (mask_vec[1] << 1)));\n        \n        // Load destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        \n        // Conditionally select values based on mask\n        int64x2_t result = vbslq_s64(mask_int, src_vec, dst_vec);\n        \n        // Store result back to destination\n        vst1q_s64(dst + i, result);\n    }\n    \n    // Handle remaining single element if length is odd\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n        \n        // Load mask values and convert to integer mask\n        uint64x2_t mask_vec = {mask[i], mask[i+1]};\n        uint64x2_t mask_int = vcgtq_u64(mask_vec, vdupq_n_u64(0));\n        \n        // Load destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        \n        // Conditionally select values using bitwise AND with mask\n        int64x2_t result = vbslq_s64(mask_int, src_vec, dst_vec);\n        \n        // Store result back to destination\n        vst1q_s64(dst + i, result);\n    }\n    \n    // Handle remaining single element if length is odd\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load source values\n        int64x2_t src_vec = vld1q_s64(src + i);\n        \n        // Load mask values and convert to integer mask\n        uint64x2_t mask_vec = {mask[i], mask[i+1]};\n        uint64x2_t mask_int = vreinterpretq_u64_u8(vcgtq_u8(vreinterpretq_u8_u64(mask_vec), vdupq_n_u8(0)));\n        \n        // Load destination values\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        \n        // Conditionally select values using bitwise AND with mask\n        int64x2_t result = vbslq_s64(mask_int, src_vec, dst_vec);\n        \n        // Store result back to destination\n        vst1q_s64(dst + i, result);\n    }\n    \n    // Handle remaining single element if length is odd\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 source elements\n        int64x2_t src_vec = vld1q_s64(src + i);\n        \n        // Load 2 mask elements and convert to integer mask\n        uint64x2_t mask_vec = {mask[i], mask[i+1]};\n        uint64x2_t mask_int = vreinterpretq_u64_u8(vcreate_u8(mask_vec[0] | (mask_vec[1] << 1)));\n        \n        // Load current destination elements\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        \n        // Conditionally select elements using mask\n        int64x2_t result = vbslq_s64(mask_int, src_vec, dst_vec);\n        \n        // Store result back to destination\n        vst1q_s64(dst + i, result);\n    }\n    \n    // Handle remaining single element if length is odd\n    if (i < length) {\n        dst[i] = mask[i] ? src[i] : dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = length - (length % 4);\n    \n    // Broadcast scale to all lanes of a vector register\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < vector_length; i += 4) {\n        // Load 4 integers from source\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Multiply source vector with scale\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        \n        // Right shift by 3 bits\n        int32x4_t tmp1_vec = vshrq_n_s32(scaled_vec, 3);\n        \n        // Left shift by 3 bits\n        int32x4_t tmp2_vec = vshlq_n_s32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        int32x4_t tmp_mul_vec = vmulq_s32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        int32x4_t result_vec = vaddq_s32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        int32x4_t div_vec = vdivq_s32(result_vec, vdupq_n_s32(7));\n        \n        // Store result in destination\n        vst1q_s32(dst + i, div_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = length - (length % 4);\n    \n    // Broadcast scale to all lanes of a vector register\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < vector_length; i += 4) {\n        // Load 4 source elements\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Multiply source with scale\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        \n        // Right shift by 3 bits\n        int32x4_t tmp1_vec = vshrq_n_s32(scaled_vec, 3);\n        \n        // Left shift by 3 bits\n        int32x4_t tmp2_vec = vshlq_n_s32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        int32x4_t tmp_mul_vec = vmulq_s32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        int32x4_t result_vec = vaddq_s32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        int32x4_t div_vec = vdivq_s32(result_vec, vdupq_n_s32(7));\n        \n        // Store results\n        vst1q_s32(dst + i, div_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = length - (length % 4);\n    \n    // Broadcast scale to all lanes of a vector register\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < vector_length; i += 4) {\n        // Load 4 integers from source\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Multiply source vector with scale\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        \n        // Right shift by 3\n        int32x4_t tmp1 = vshrq_n_s32(scaled_vec, 3);\n        \n        // Left shift by 3\n        int32x4_t tmp2 = vshlq_n_s32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        int32x4_t tmp_mul = vmulq_s32(tmp1, tmp2);\n        \n        // Add scaled_vec and tmp_mul\n        int32x4_t result = vaddq_s32(scaled_vec, tmp_mul);\n        \n        // Divide by 7\n        int32x4_t div_result = vdivq_s32(result, vdupq_n_s32(7));\n        \n        // Store result in destination\n        vst1q_s32(dst + i, div_result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = length - (length % 4);\n    \n    // Broadcast scale to all lanes of a vector register\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < vector_length; i += 4) {\n        // Load 4 integers from source\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Multiply source vector with scale\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        \n        // Right shift by 3\n        int32x4_t tmp1_vec = vshrq_n_s32(scaled_vec, 3);\n        \n        // Left shift by 3\n        int32x4_t tmp2_vec = vshlq_n_s32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        int32x4_t tmp_mul_vec = vmulq_s32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        int32x4_t result_vec = vaddq_s32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        int32x4_t div_vec = vdivq_s32(result_vec, vdupq_n_s32(7));\n        \n        // Store result\n        vst1q_s32(dst + i, div_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = length - (length % 4);\n    \n    // Broadcast scale to all lanes of a vector register\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < vector_length; i += 4) {\n        // Load 4 source elements\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Multiply source with scale\n        int32x4_t scaled_vec = vmulq_s32(src_vec, scale_vec);\n        \n        // Right shift by 3\n        int32x4_t tmp1_vec = vshrq_n_s32(scaled_vec, 3);\n        \n        // Left shift by 3\n        int32x4_t tmp2_vec = vshlq_n_s32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        int32x4_t tmp_mul_vec = vmulq_s32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        int32x4_t result_vec = vaddq_s32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        int32x4_t div_vec = vdivq_s32(result_vec, vdupq_n_s32(7));\n        \n        // Store results\n        vst1q_s32(dst + i, div_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < rows; i += 2) {\n        float64x2_t vec1 = vld1q_f64(src + (i * cols + stride));\n        float64x2_t vec2 = vld1q_f64(src + ((i + 1) * cols + stride));\n        \n        vst1q_f64(dst + i, vec1);\n        vst1q_f64(dst + i + 1, vec2);\n    }\n    \n    // Handle remaining rows\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Process 2 doubles at a time using 128-bit Neon registers\n    size_t vector_width = 2;\n    size_t i = 0;\n\n    // Process rows in vector chunks\n    for (; i + vector_width <= rows; i += vector_width) {\n        // Calculate source indices with stride\n        size_t src_index1 = (i * cols + stride);\n        size_t src_index2 = ((i + 1) * cols + stride);\n\n        // Load 2 doubles using Neon intrinsics\n        float64x2_t vec_load = vld1q_f64(src + src_index1);\n\n        // Store 2 doubles using Neon intrinsics\n        vst1q_f64(dst + i, vec_load);\n    }\n\n    // Handle remaining rows sequentially\n    for (; i < rows; i++) {\n        size_t src_index = (i * cols + stride);\n        dst[i] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < rows; i += 2) {\n        float64x2_t vec1 = vld1q_f64(src + (i * cols + stride));\n        float64x2_t vec2 = vld1q_f64(src + ((i + 1) * cols + stride));\n        \n        vst1q_f64(dst + i, vec1);\n        vst1q_f64(dst + i + 1, vec2);\n    }\n    \n    // Handle remaining rows if rows is odd\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Process 2 doubles at a time using 128-bit Neon registers\n    size_t vector_width = 2;\n    size_t i = 0;\n\n    // Process rows in vector chunks\n    for (; i + vector_width <= rows; i += vector_width) {\n        // Calculate source indices with stride\n        size_t src_index1 = (i * cols) + stride;\n        size_t src_index2 = ((i + 1) * cols) + stride;\n\n        // Load 2 doubles using Neon intrinsics\n        float64x2_t vec_load = vld1q_f64(src + src_index1);\n        \n        // Store 2 doubles using Neon intrinsics\n        vst1q_f64(dst + i, vec_load);\n    }\n\n    // Handle remaining rows sequentially\n    for (; i < rows; i++) {\n        size_t src_index = (i * cols) + stride;\n        dst[i] = src[src_index];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < rows; i += 2) {\n        float64x2_t vec1 = vld1q_f64(src + (i * cols + stride));\n        float64x2_t vec2 = vld1q_f64(src + ((i + 1) * cols + stride));\n        \n        vst1q_f64(dst + i, vec1);\n        vst1q_f64(dst + i + 1, vec2);\n    }\n    \n    // Handle remaining rows if rows is odd\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        \n        // Gather operation: Load values from source using indices\n        float32x4_t gathered_values = {\n            src[vgetq_lane_s32(idx_vec, 0)],\n            src[vgetq_lane_s32(idx_vec, 1)],\n            src[vgetq_lane_s32(idx_vec, 2)],\n            src[vgetq_lane_s32(idx_vec, 3)]\n        };\n        \n        // Store gathered values to destination\n        vst1q_f32(dst + i, gathered_values);\n        \n        // Scatter operation: Store values to source indices\n        dst[vgetq_lane_s32(idx_vec, 0)] = src[i];\n        dst[vgetq_lane_s32(idx_vec, 1)] = src[i + 1];\n        dst[vgetq_lane_s32(idx_vec, 2)] = src[i + 2];\n        dst[vgetq_lane_s32(idx_vec, 3)] = src[i + 3];\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        \n        // Gather operation: Load values from source using indices\n        float32x4_t gathered_values = {\n            src[vgetq_lane_s32(idx_vec, 0)],\n            src[vgetq_lane_s32(idx_vec, 1)],\n            src[vgetq_lane_s32(idx_vec, 2)],\n            src[vgetq_lane_s32(idx_vec, 3)]\n        };\n        \n        // Store gathered values to destination\n        vst1q_f32(dst + i, gathered_values);\n        \n        // Scatter operation: Store source values at indexed locations\n        dst[indices[i]] = src[i];\n        dst[indices[i+1]] = src[i+1];\n        dst[indices[i+2]] = src[i+2];\n        dst[indices[i+3]] = src[i+3];\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        int32x4_t index_vec = vld1q_s32(indices + i);\n        \n        // Gather: Load values from source using indices\n        float32x4_t gathered_values = {\n            src[vgetq_lane_s32(index_vec, 0)],\n            src[vgetq_lane_s32(index_vec, 1)],\n            src[vgetq_lane_s32(index_vec, 2)],\n            src[vgetq_lane_s32(index_vec, 3)]\n        };\n        \n        // Store gathered values to destination\n        vst1q_f32(dst + i, gathered_values);\n        \n        // Scatter: Store values to source array at indexed locations\n        dst[indices[i]] = src[i];\n        dst[indices[i+1]] = src[i+1];\n        dst[indices[i+2]] = src[i+2];\n        dst[indices[i+3]] = src[i+3];\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        int32x4_t index_vec = vld1q_s32(indices + i);\n        \n        // Gather operation: Load values from source using indices\n        float32x4_t gathered_values = {\n            src[vgetq_lane_s32(index_vec, 0)],\n            src[vgetq_lane_s32(index_vec, 1)],\n            src[vgetq_lane_s32(index_vec, 2)],\n            src[vgetq_lane_s32(index_vec, 3)]\n        };\n        \n        // Scatter operation: Store gathered values to destination using indices\n        dst[vgetq_lane_s32(index_vec, 0)] = vgetq_lane_f32(gathered_values, 0);\n        dst[vgetq_lane_s32(index_vec, 1)] = vgetq_lane_f32(gathered_values, 1);\n        dst[vgetq_lane_s32(index_vec, 2)] = vgetq_lane_f32(gathered_values, 2);\n        dst[vgetq_lane_s32(index_vec, 3)] = vgetq_lane_f32(gathered_values, 3);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        \n        // Gather operation: Load values from source using indices\n        float32x4_t gathered_values = {\n            src[vgetq_lane_s32(idx_vec, 0)],\n            src[vgetq_lane_s32(idx_vec, 1)],\n            src[vgetq_lane_s32(idx_vec, 2)],\n            src[vgetq_lane_s32(idx_vec, 3)]\n        };\n        \n        // Store gathered values to destination\n        vst1q_f32(dst + i, gathered_values);\n        \n        // Scatter operation: Store source values at indexed locations\n        dst[indices[i]] = src[i];\n        dst[indices[i+1]] = src[i+1];\n        dst[indices[i+2]] = src[i+2];\n        dst[indices[i+3]] = src[i+3];\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the length of the range to reverse\n    uint64_t range_length = end - start + 1;\n    \n    // Process 8 elements at a time using Neon 128-bit registers\n    uint64_t vector_length = range_length & ~7;\n    for (uint64_t i = 0; i < vector_length; i += 8) {\n        int16x8_t left = vld1q_s16(arr + start + i);\n        int16x8_t right = vld1q_s16(arr + end - i - 7);\n        \n        // Reverse the vector\n        int16x8_t reversed_left = vrev64q_s16(left);\n        int16x8_t reversed_right = vrev64q_s16(right);\n        \n        // Swap the halves to complete the reversal\n        int16x8_t swapped_left = vextq_s16(reversed_left, reversed_left, 4);\n        int16x8_t swapped_right = vextq_s16(reversed_right, reversed_right, 4);\n        \n        // Store the reversed vectors back\n        vst1q_s16(arr + start + i, swapped_right);\n        vst1q_s16(arr + end - i - 7, swapped_left);\n    }\n    \n    // Handle any remaining elements\n    for (uint64_t i = vector_length; i < range_length; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t len = end - start + 1;\n    \n    // Process 8 elements at a time using Neon\n    uint64_t vector_len = len & ~7;  // Round down to multiple of 8\n    \n    for (uint64_t i = 0; i < vector_len; i += 8) {\n        // Load 8 elements from the start and end of the range\n        int16x8_t start_vec = vld1q_s16(arr + start + i);\n        int16x8_t end_vec = vld1q_s16(arr + end - i - 7);\n        \n        // Reverse the vectors\n        start_vec = vrev64q_s16(start_vec);\n        end_vec = vrev64q_s16(end_vec);\n        \n        // Swap the halves to complete the reversal\n        start_vec = vextq_s16(start_vec, start_vec, 4);\n        end_vec = vextq_s16(end_vec, end_vec, 4);\n        \n        // Store the reversed vectors back\n        vst1q_s16(arr + start + i, end_vec);\n        vst1q_s16(arr + end - i - 7, start_vec);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = vector_len; i < len; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t len = end - start + 1;\n    \n    // Process 8 elements at a time using Neon\n    uint64_t vector_len = len & ~7;  // Align to multiple of 8\n    \n    for (uint64_t i = 0; i < vector_len; i += 8) {\n        // Load 8 elements from start+i and end-i\n        int16x8_t left = vld1q_s16(arr + start + i);\n        int16x8_t right = vld1q_s16(arr + end - i - 7);\n        \n        // Reverse the vectors\n        int16x8_t left_rev = vrev64q_s16(left);\n        int16x8_t right_rev = vrev64q_s16(right);\n        \n        // Swap the halves to complete the full reverse\n        left_rev = vextq_s16(left_rev, left_rev, 4);\n        right_rev = vextq_s16(right_rev, right_rev, 4);\n        \n        // Store the reversed vectors\n        vst1q_s16(arr + start + i, right_rev);\n        vst1q_s16(arr + end - i - 7, left_rev);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = vector_len; i < len; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t length = end - start + 1;\n    \n    // Process 8 elements at a time using Neon\n    uint64_t vector_length = length - (length % 8);\n    \n    for (uint64_t i = 0; i < vector_length; i += 8) {\n        // Load 8 elements from the start and end of the range\n        int16x8_t start_vec = vld1q_s16(arr + start + i);\n        int16x8_t end_vec = vld1q_s16(arr + end - i - 7);\n        \n        // Reverse the order of elements in each vector\n        int16x8_t start_reversed = vrev64q_s16(start_vec);\n        int16x8_t end_reversed = vrev64q_s16(end_vec);\n        \n        // Swap the halves of the reversed vectors\n        start_reversed = vextq_s16(start_reversed, start_reversed, 4);\n        end_reversed = vextq_s16(end_reversed, end_reversed, 4);\n        \n        // Store the reversed vectors back to the original positions\n        vst1q_s16(arr + start + i, end_reversed);\n        vst1q_s16(arr + end - i - 7, start_reversed);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = vector_length; i < length; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t len = end - start + 1;\n    \n    // Process 8 elements at a time using Neon\n    uint64_t vector_len = len & ~7;  // Align to multiple of 8\n    \n    for (uint64_t i = 0; i < vector_len; i += 8) {\n        // Load 8 elements from start+i and end-i\n        int16x8_t left = vld1q_s16(arr + start + i);\n        int16x8_t right = vld1q_s16(arr + end - i - 7);\n        \n        // Reverse the vectors\n        int16x8_t left_rev = vrev64q_s16(left);\n        int16x8_t right_rev = vrev64q_s16(right);\n        \n        // Swap the halves to complete the full reverse\n        left_rev = vextq_s16(left_rev, left_rev, 4);\n        right_rev = vextq_s16(right_rev, right_rev, 4);\n        \n        // Store back in swapped positions\n        vst1q_s16(arr + start + i, right_rev);\n        vst1q_s16(arr + end - i - 7, left_rev);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = vector_len; i < len; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Process 16 bytes at a time using Neon SIMD\n    size_t vector_width = 16;\n    size_t total_slice_elements = dim1 * dim2;\n    size_t simd_iterations = total_slice_elements / vector_width;\n    size_t remaining_elements = total_slice_elements % vector_width;\n\n    // SIMD processing\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        uint8x16_t vector_data = vld1q_u8(slice_start + i * vector_width);\n        vst1q_u8(slice + i * vector_width, vector_data);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * vector_width; i < total_slice_elements; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Process 16 bytes at a time using Neon SIMD\n    size_t vector_width = 16;\n    size_t total_elements = dim1 * dim2;\n    size_t simd_iterations = total_elements / vector_width;\n    size_t remainder = total_elements % vector_width;\n\n    // SIMD processing\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        uint8x16_t data = vld1q_u8(slice_start + i * vector_width);\n        vst1q_u8(slice + i * vector_width, data);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * vector_width; i < total_elements; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Process 16 bytes at a time using Neon SIMD\n    size_t vector_width = 16;\n    size_t total_slice_elements = dim1 * dim2;\n    size_t vector_iterations = total_slice_elements / vector_width;\n    size_t remaining_elements = total_slice_elements % vector_width;\n\n    // SIMD processing for most elements\n    for (size_t i = 0; i < vector_iterations; ++i) {\n        uint8x16_t data = vld1q_u8(slice_start + i * vector_width);\n        vst1q_u8(slice + i * vector_width, data);\n    }\n\n    // Handle remaining elements with scalar processing\n    for (size_t i = vector_iterations * vector_width; i < total_slice_elements; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Process 16 bytes at a time using Neon SIMD\n    size_t vector_width = 16;\n    size_t total_slice_elements = dim1 * dim2;\n    size_t vector_iterations = total_slice_elements / vector_width;\n    size_t remaining_elements = total_slice_elements % vector_width;\n\n    // SIMD processing of slice\n    for (size_t i = 0; i < vector_iterations; ++i) {\n        uint8x16_t data = vld1q_u8(slice_start + i * vector_width);\n        vst1q_u8(slice + i * vector_width, data);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_iterations * vector_width; i < total_slice_elements; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset for the specific slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Process 16 bytes at a time using Neon SIMD\n    size_t vector_width = 16;\n    size_t total_slice_elements = dim1 * dim2;\n    size_t vectorized_elements = total_slice_elements - (total_slice_elements % vector_width);\n\n    for (size_t i = 0; i < vectorized_elements; i += vector_width) {\n        uint8x16_t data = vld1q_u8(slice_start + i);\n        vst1q_u8(slice + i, data);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_elements; i < total_slice_elements; i++) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                for (size_t c = block_col; c < std::min(block_col + block_size, cols); c += 8) {\n                    // Use Neon 128-bit registers to load and store 8 elements at a time\n                    int16x8_t src_vec = vld1q_s16(src + r * cols + c);\n                    vst1q_s16(dst + c * rows + r, src_vec);\n                }\n                \n                // Handle remaining elements in the block that don't fit in 8-wide vector\n                for (size_t c = block_col + ((cols - block_col) / 8) * 8; c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                for (size_t c = block_col; c < std::min(block_col + block_size, cols); c += 8) {\n                    // Use Neon 128-bit registers to load and store 8 elements at a time\n                    int16x8_t src_vec = vld1q_s16(src + r * cols + c);\n                    vst1q_s16(dst + c * rows + r, src_vec);\n                }\n                \n                // Handle remaining elements in the block if cols is not divisible by 8\n                for (size_t c = block_col + ((cols - block_col) / 8) * 8; c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                for (size_t c = block_col; c < std::min(block_col + block_size, cols); c += 8) {\n                    // Use Neon 128-bit registers to load and store 8 elements at a time\n                    int16x8_t src_vec = vld1q_s16(src + r * cols + c);\n                    vst1q_s16(dst + c * rows + r, src_vec);\n                }\n                \n                // Handle remaining elements in the row if cols is not divisible by 8\n                for (size_t c = std::min(block_col + block_size, cols) - (std::min(block_col + block_size, cols) % 8); \n                     c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                for (size_t c = block_col; c < std::min(block_col + block_size, cols); c += 8) {\n                    // Use Neon 128-bit registers to load and store 8 elements at a time\n                    int16x8_t src_vec = vld1q_s16(src + r * cols + c);\n                    vst1q_s16(dst + c * rows + r, src_vec);\n                }\n                \n                // Handle remaining elements in the block that don't fit in 8-wide vector\n                for (size_t c = block_col + ((cols - block_col) / 8) * 8; c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t i = block_row; i < std::min(block_row + block_size, rows); i += 8) {\n                for (size_t j = block_col; j < std::min(block_col + block_size, cols); j += 8) {\n                    // Load 8x8 block using Neon intrinsics\n                    int16x8_t row0 = vld1q_s16(src + i * cols + j);\n                    int16x8_t row1 = vld1q_s16(src + (i + 1) * cols + j);\n                    int16x8_t row2 = vld1q_s16(src + (i + 2) * cols + j);\n                    int16x8_t row3 = vld1q_s16(src + (i + 3) * cols + j);\n                    int16x8_t row4 = vld1q_s16(src + (i + 4) * cols + j);\n                    int16x8_t row5 = vld1q_s16(src + (i + 5) * cols + j);\n                    int16x8_t row6 = vld1q_s16(src + (i + 6) * cols + j);\n                    int16x8_t row7 = vld1q_s16(src + (i + 7) * cols + j);\n\n                    // Transpose 8x8 block using Neon intrinsics\n                    int16x8x2_t tr0 = vtrnq_s16(row0, row1);\n                    int16x8x2_t tr1 = vtrnq_s16(row2, row3);\n                    int16x8x2_t tr2 = vtrnq_s16(row4, row5);\n                    int16x8x2_t tr3 = vtrnq_s16(row6, row7);\n\n                    int32x4x2_t tr4 = vtrnq_s32(vreinterpretq_s32_s16(tr0.val[0]), vreinterpretq_s32_s16(tr1.val[0]));\n                    int32x4x2_t tr5 = vtrnq_s32(vreinterpretq_s32_s16(tr0.val[1]), vreinterpretq_s32_s16(tr1.val[1]));\n                    int32x4x2_t tr6 = vtrnq_s32(vreinterpretq_s32_s16(tr2.val[0]), vreinterpretq_s32_s16(tr3.val[0]));\n                    int32x4x2_t tr7 = vtrnq_s32(vreinterpretq_s32_s16(tr2.val[1]), vreinterpretq_s32_s16(tr3.val[1]));\n\n                    int16x8_t trans0 = vreinterpretq_s16_s32(tr4.val[0]);\n                    int16x8_t trans1 = vreinterpretq_s16_s32(tr4.val[1]);\n                    int16x8_t trans2 = vreinterpretq_s16_s32(tr5.val[0]);\n                    int16x8_t trans3 = vreinterpretq_s16_s32(tr5.val[1]);\n                    int16x8_t trans4 = vreinterpretq_s16_s32(tr6.val[0]);\n                    int16x8_t trans5 = vreinterpretq_s16_s32(tr6.val[1]);\n                    int16x8_t trans6 = vreinterpretq_s16_s32(tr7.val[0]);\n                    int16x8_t trans7 = vreinterpretq_s16_s32(tr7.val[1]);\n\n                    // Store transposed block\n                    vst1q_s16(dst + j * rows + i, trans0);\n                    vst1q_s16(dst + j * rows + i + 1, trans1);\n                    vst1q_s16(dst + j * rows + i + 2, trans2);\n                    vst1q_s16(dst + j * rows + i + 3, trans3);\n                    vst1q_s16(dst + j * rows + i + 4, trans4);\n                    vst1q_s16(dst + j * rows + i + 5, trans5);\n                    vst1q_s16(dst + j * rows + i + 6, trans6);\n                    vst1q_s16(dst + j * rows + i + 7, trans7);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    // Process 4 diagonal elements at a time\n    for (size_t i = 0; i < dim; i += 4) {\n        size_t remaining = dim - i;\n        size_t vec_count = (remaining < 4) ? remaining : 4;\n        \n        float32x4_t diagonal_vec = vdupq_n_f32(0.0f);\n        \n        for (size_t j = 0; j < vec_count; ++j) {\n            size_t index = i * dim * dim + i * dim + i + j;\n            diagonal_vec = vsetq_lane_f32(array[index], diagonal_vec, j);\n        }\n        \n        sum_vec = vaddq_f32(sum_vec, diagonal_vec);\n    }\n    \n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    // Process 4 diagonal elements at a time\n    for (size_t i = 0; i < dim; i += 4) {\n        // Compute the indices for diagonal elements\n        size_t idx1 = i * dim + i;\n        size_t idx2 = (i + 1) * dim + (i + 1);\n        size_t idx3 = (i + 2) * dim + (i + 2);\n        size_t idx4 = (i + 3) * dim + (i + 3);\n        \n        // Load diagonal elements\n        float32x4_t diag_vec = {\n            array[idx1],\n            array[idx2],\n            array[idx3],\n            array[idx4]\n        };\n        \n        // Accumulate sum\n        sum_vec = vaddq_f32(sum_vec, diag_vec);\n    }\n    \n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float total_sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n    \n    // Handle remaining diagonal elements if dim is not multiple of 4\n    for (size_t i = (dim / 4) * 4; i < dim; ++i) {\n        total_sum += array[i * dim + i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    // Process 4 diagonal elements at a time\n    for (size_t i = 0; i < dim; i += 4) {\n        size_t remaining = dim - i;\n        size_t vec_count = (remaining < 4) ? remaining : 4;\n        \n        float32x4_t diagonal_vec = vdupq_n_f32(0.0f);\n        \n        for (size_t j = 0; j < vec_count; ++j) {\n            size_t index = i * dim * dim + i * dim + i + j;\n            diagonal_vec = vsetq_lane_f32(array[index], diagonal_vec, j);\n        }\n        \n        sum_vec = vaddq_f32(sum_vec, diagonal_vec);\n    }\n    \n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    // Process 4 diagonal elements at a time\n    for (size_t i = 0; i < dim; i += 4) {\n        // Calculate the index for diagonal elements\n        size_t index = i * dim + i * dim * dim + i;\n        \n        // Check if we have at least 4 elements left\n        if (i + 4 <= dim) {\n            float32x4_t diag_vec = vld1q_f32(&array[index]);\n            sum_vec = vaddq_f32(sum_vec, diag_vec);\n        } else {\n            // Handle remaining elements\n            for (size_t j = i; j < dim; ++j) {\n                size_t single_index = j * dim + j * dim * dim + j;\n                sum_vec = vsetq_lane_f32(sum_vec[0] + array[single_index], sum_vec, 0);\n            }\n            break;\n        }\n    }\n    \n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float total_sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    // Process 4 diagonal elements at a time\n    for (size_t i = 0; i < dim; i += 4) {\n        size_t remaining = dim - i;\n        size_t vec_count = (remaining < 4) ? remaining : 4;\n        \n        float32x4_t diagonal_vec = vdupq_n_f32(0.0f);\n        \n        for (size_t j = 0; j < vec_count; ++j) {\n            size_t index = i * dim * dim + i * dim + i + j;\n            diagonal_vec = vsetq_lane_f32(array[index], diagonal_vec, j);\n        }\n        \n        sum_vec = vaddq_f32(sum_vec, diagonal_vec);\n    }\n    \n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // Neon SIMD implementation for double precision\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; c + 1 < cols; c += 2) {\n            float64x2_t src_vec = vld1q_f64(src + r * cols + c);\n            float64x2_t threshold_vec = vdupq_n_f64(threshold);\n            float64x2_t scale_vec = vdupq_n_f64(scale);\n            \n            // Compare values greater than threshold\n            uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n            \n            // Conditional scaling using bitwise select\n            float64x2_t scaled_vec = vbslq_f64(mask, \n                                               vmulq_f64(src_vec, scale_vec), \n                                               src_vec);\n            \n            // Store result\n            vst1q_f64(dst + r * cols + c, scaled_vec);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            double val = src[r * cols + c];\n            dst[r * cols + c] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // Neon SIMD implementation for 64-bit floating point\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; c + 1 < cols; c += 2) {\n            float64x2_t src_vec = vld1q_f64(src + r * cols + c);\n            float64x2_t threshold_vec = vdupq_n_f64(threshold);\n            float64x2_t scale_vec = vdupq_n_f64(scale);\n            \n            // Compare if values are greater than threshold\n            uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n            \n            // Conditionally scale values\n            float64x2_t scaled_vec = vbslq_f64(mask, \n                                               vmulq_f64(src_vec, scale_vec), \n                                               src_vec);\n            \n            // Store result\n            vst1q_f64(dst + r * cols + c, scaled_vec);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            double val = src[r * cols + c];\n            dst[r * cols + c] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // Neon SIMD implementation for 64-bit floating point (double) processing\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; c + 1 < cols; c += 2) {\n            float64x2_t src_vec = vld1q_f64(src + r * cols + c);\n            float64x2_t threshold_vec = vdupq_n_f64(threshold);\n            float64x2_t scale_vec = vdupq_n_f64(scale);\n            \n            // Compare if values are greater than threshold\n            uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n            \n            // Conditionally scale values\n            float64x2_t scaled_vec = vbslq_f64(mask, \n                                               vmulq_f64(src_vec, scale_vec), \n                                               src_vec);\n            \n            // Store result\n            vst1q_f64(dst + r * cols + c, scaled_vec);\n        }\n        \n        // Handle remaining single element if cols is odd\n        for (; c < cols; c++) {\n            double val = src[r * cols + c];\n            dst[r * cols + c] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // Neon supports 2 doubles per vector register\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process 2 doubles at a time using Neon 128-bit vector registers\n        for (; c + 1 < cols; c += 2) {\n            float64x2_t src_vec = vld1q_f64(src + r * cols + c);\n            float64x2_t threshold_vec = vdupq_n_f64(threshold);\n            float64x2_t scale_vec = vdupq_n_f64(scale);\n            \n            // Compare if values are greater than threshold\n            uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n            \n            // Conditional scaling using vector blend\n            float64x2_t scaled_vec = vbslq_f64(mask, \n                                               vmulq_f64(src_vec, scale_vec), \n                                               src_vec);\n            \n            // Store result\n            vst1q_f64(dst + r * cols + c, scaled_vec);\n        }\n        \n        // Handle remaining single element if cols is odd\n        for (; c < cols; c++) {\n            double val = src[r * cols + c];\n            dst[r * cols + c] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // Neon SIMD implementation for 64-bit floating point (double) conditional scaling\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; c + 1 < cols; c += 2) {\n            float64x2_t src_vec = vld1q_f64(src + r * cols + c);\n            float64x2_t threshold_vec = vdupq_n_f64(threshold);\n            float64x2_t scale_vec = vdupq_n_f64(scale);\n            \n            // Compare if values are greater than threshold\n            uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n            \n            // Conditionally scale values\n            float64x2_t scaled_vec = vbslq_f64(mask, \n                                               vmulq_f64(src_vec, scale_vec), \n                                               src_vec);\n            \n            // Store result\n            vst1q_f64(dst + r * cols + c, scaled_vec);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            double val = src[r * cols + c];\n            dst[r * cols + c] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Number of doubles that can be processed in a single Neon vector\n    const size_t vector_width = 2; // 128-bit Neon vector can hold 2 doubles\n\n    // Process rows in parallel using Neon intrinsics\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row_ptr = src + (src_row_index * cols);\n        double *dst_row_ptr = dst + (i * cols);\n\n        // Process columns in vector chunks\n        size_t j;\n        for (j = 0; j + vector_width <= cols; j += vector_width) {\n            float64x2_t vec_data = vld1q_f64(src_row_ptr + j);\n            vst1q_f64(dst_row_ptr + j, vec_data);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        const double *src_row_ptr = src + src_row_idx * cols;\n        double *dst_row_ptr = dst + i * cols;\n\n        // Process 2 doubles per iteration using 128-bit Neon load/store\n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row_ptr + j);\n            vst1q_f64(dst_row_ptr + j, vec);\n        }\n\n        // Handle remaining single elements if cols is odd\n        for (; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Number of doubles that can be processed in a single Neon vector\n    const size_t neon_vector_size = 2; // 128-bit Neon vector can hold 2 doubles\n    \n    // Process rows in parallel using Neon intrinsics\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row_ptr = src + src_row_index * cols;\n        double *dst_row_ptr = dst + i * cols;\n        \n        // Process columns in Neon vector chunks\n        size_t j;\n        for (j = 0; j + neon_vector_size <= cols; j += neon_vector_size) {\n            float64x2_t vec = vld1q_f64(src_row_ptr + j);\n            vst1q_f64(dst_row_ptr + j, vec);\n        }\n        \n        // Handle remaining elements that don't fit in a full vector\n        for (; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        const double *src_row_ptr = src + src_row_idx * cols;\n        double *dst_row_ptr = dst + i * cols;\n\n        // Process 2 doubles per iteration using 128-bit Neon load/store\n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row_ptr + j);\n            vst1q_f64(dst_row_ptr + j, vec);\n        }\n\n        // Handle remaining single elements if cols is odd\n        for (; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Number of doubles that can be processed in a single Neon vector\n    const size_t vector_width = 2; // 128-bit Neon vector can hold 2 doubles\n\n    // Process rows in parallel using Neon intrinsics\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row_ptr = src + src_row_index * cols;\n        double *dst_row_ptr = dst + i * cols;\n\n        // Process columns in vector chunks\n        size_t j;\n        for (j = 0; j + vector_width <= cols; j += vector_width) {\n            float64x2_t vec_data = vld1q_f64(src_row_ptr + j);\n            vst1q_f64(dst_row_ptr + j, vec_data);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from src1 and src2\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        \n        // Add the two vectors\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        \n        // Add scalar to each element\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        sum = vaddq_s64(sum, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum = vshrq_n_s64(sum, 1);\n        \n        // Store result in destination array\n        vst1q_s64(dst + i, sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from src1 and src2\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        \n        // Add the two vectors\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        \n        // Add scalar to each element\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        sum = vaddq_s64(sum, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum = vshrq_n_s64(sum, 1);\n        \n        // Store result in destination array\n        vst1q_s64(dst + i, sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from src1 and src2\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        \n        // Add the two vectors\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        \n        // Add scalar to each element\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        sum = vaddq_s64(sum, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum = vshrq_n_s64(sum, 1);\n        \n        // Store result in destination array\n        vst1q_s64(dst + i, sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from src1 and src2\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        \n        // Add the two vectors\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        \n        // Add scalar to each element\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        sum = vaddq_s64(sum, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum = vshrq_n_s64(sum, 1);\n        \n        // Store result in destination array\n        vst1q_s64(dst + i, sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from src1 and src2\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        \n        // Add the two vectors\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        \n        // Add scalar to each element\n        int64x2_t scalar_vec = vdupq_n_s64(scalar);\n        sum = vaddq_s64(sum, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum = vshrq_n_s64(sum, 1);\n        \n        // Store result in destination array\n        vst1q_s64(dst + i, sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t mask = {0, 1, 0, 1};\n        vec = vbslq_s32(vcltq_s32(mask, vdupq_n_s32(0)), vec, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, vec);\n    }\n\n    // Horizontal min\n    int32x2_t min_low = vmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int result = vget_lane_s32(min_low, 0);\n    result = vget_lane_s32(min_low, 1) < result ? vget_lane_s32(min_low, 1) : result;\n\n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] < result) result = src[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t mask = vcgeq_s32(vec, vdupq_n_s32(0));\n        int32x4_t even_mask = vbicq_u32(mask, vcreate_u32(0x1));\n        int32x4_t even_vec = vandq_s32(vec, even_mask);\n        min_vec = vminq_s32(min_vec, even_vec);\n    }\n\n    // Horizontal min\n    int32x2_t min_low = vmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int32_t min_val = vmin_s32(min_low, vrev64_s32(min_low))[0];\n\n    // Process remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] % 2 == 0 && src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val == INT_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t mask = {0, 1, 0, 1};\n        int32x4_t even_vec = vbslq_s32(vcltq_s32(mask, vdupq_n_s32(2)), vec, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, even_vec);\n    }\n\n    // Horizontal min\n    int32x2_t min_low = vmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int result = vget_lane_s32(min_low, 0);\n    result = vget_lane_s32(min_low, 1) < result ? vget_lane_s32(min_low, 1) : result;\n\n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] < result) result = src[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t mask = {0, 1, 0, 1};\n        vec = vbslq_s32(vcgeq_s32(mask, vdupq_n_s32(0)), vec, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, vec);\n    }\n\n    // Horizontal min of SIMD vector\n    int32x2_t min_low = vmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int result = vget_lane_s32(min_low, 0);\n    result = vget_lane_s32(min_low, 1) < result ? vget_lane_s32(min_low, 1) : result;\n\n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] < result) {\n            result = src[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t mask = {0, 1, 0, 1};\n        int32x4_t even_vec = vbslq_s32(vcltq_s32(mask, vdupq_n_s32(2)), vec, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, even_vec);\n    }\n\n    // Horizontal min\n    int32x2_t min_low = vmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    int32_t min_val = vmin_s32(min_low, vrev64_s32(min_low))[0];\n\n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source integers\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned and perform logical right shift\n        uint32x4_t unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logical_shift = vshrq_n_u32(unsigned_vec, shift);\n        \n        // Convert logical shift back to signed\n        int32x4_t logical_signed = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        int32x4_t result = vaddq_s32(arith_shift, logical_signed);\n        \n        // Store result in destination array\n        vst1q_s32(dst + i, result);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int unsigned_val = (unsigned int)src[i];\n        int logical_shift = (int)(unsigned_val >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source integers\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned and perform logical right shift\n        uint32x4_t unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logical_shift = vshrq_n_u32(unsigned_vec, shift);\n        \n        // Convert logical shift back to signed\n        int32x4_t logical_shift_signed = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        int32x4_t result = vaddq_s32(arith_shift, logical_shift_signed);\n        \n        // Store result in destination array\n        vst1q_s32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int unsigned_val = (unsigned int)src[i];\n        int logical_shift = (int)(unsigned_val >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source integers\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned and perform logical right shift\n        uint32x4_t unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logical_shift = vshrq_n_u32(unsigned_vec, shift);\n        \n        // Convert logical shift back to signed\n        int32x4_t logical_shift_signed = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        int32x4_t result = vaddq_s32(arith_shift, logical_shift_signed);\n        \n        // Store result in destination array\n        vst1q_s32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int unsigned_val = (unsigned int)src[i];\n        int logical_shift = (int)(unsigned_val >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source integers\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift_vec = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned and perform logical right shift\n        uint32x4_t unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logical_shift_vec = vshrq_n_u32(unsigned_vec, shift);\n        int32x4_t logical_shift_int_vec = vreinterpretq_s32_u32(logical_shift_vec);\n        \n        // Add arithmetic and logical shifts\n        int32x4_t result_vec = vaddq_s32(arith_shift_vec, logical_shift_int_vec);\n        \n        // Store result in destination array\n        vst1q_s32(dst + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int unsigned_val = (unsigned int)src[i];\n        int logical_shift = (int)(unsigned_val >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source integers\n        int32x4_t src_vec = vld1q_s32(src + i);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(src_vec, shift);\n        \n        // Convert to unsigned and perform logical right shift\n        uint32x4_t unsigned_vec = vreinterpretq_u32_s32(src_vec);\n        uint32x4_t logical_shift = vshrq_n_u32(unsigned_vec, shift);\n        \n        // Convert logical shift back to signed\n        int32x4_t logical_shift_signed = vreinterpretq_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        int32x4_t result = vaddq_s32(arith_shift, logical_shift_signed);\n        \n        // Store result in destination array\n        vst1q_s32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int unsigned_val = (unsigned int)src[i];\n        int logical_shift = (int)(unsigned_val >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_length = total_elements - (total_elements % 4);\n\n    // Initialize a 64-bit vector to accumulate sums\n    int64x2_t sum_vector = vdupq_n_s64(0);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < vector_length; i += 4) {\n        int32x4_t matrix_vector = vld1q_s32(matrix + i);\n        int64x2_t lower_sum = vpaddlq_s32(matrix_vector);\n        int64x2_t upper_sum = vpaddlq_s32(vshrq_n_s32(matrix_vector, 32));\n        sum_vector = vaddq_s64(sum_vector, lower_sum);\n        sum_vector = vaddq_s64(sum_vector, upper_sum);\n    }\n\n    // Horizontal sum of the vector\n    total_sum = vgetq_lane_s64(sum_vector, 0) + vgetq_lane_s64(sum_vector, 1);\n\n    // Handle remaining elements\n    for (size_t i = vector_length; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_length = total_elements - (total_elements % 4);\n\n    // Initialize sum vector to zero\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    // Process 4 elements at a time using Neon\n    for (size_t i = 0; i < vector_length; i += 4) {\n        int32x4_t current_vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s32(sum_vec, current_vec);\n    }\n\n    // Horizontal sum of vector elements\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    int32x2_t sum_combined = vadd_s32(sum_low, sum_high);\n    int64_t vector_sum = vget_lane_s32(sum_combined, 0) + vget_lane_s32(sum_combined, 1);\n\n    // Add remaining elements\n    for (size_t i = vector_length; i < total_elements; i++) {\n        vector_sum += matrix[i];\n    }\n\n    return vector_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_length = total_elements - (total_elements % 4);\n\n    // Initialize sum vector to zero\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    // Process 4 elements at a time using SIMD\n    for (size_t i = 0; i < vector_length; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Horizontal sum of vector elements\n    int32_t lane_sums[4];\n    vst1q_s32(lane_sums, sum_vec);\n    total_sum = lane_sums[0] + lane_sums[1] + lane_sums[2] + lane_sums[3];\n\n    // Handle remaining elements\n    for (size_t i = vector_length; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vec_size = total_elements - (total_elements % 4);\n\n    // Initialize vector to accumulate sums\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    // Process 4 elements at a time using SIMD\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    int32x2_t sum_combined = vadd_s32(sum_low, sum_high);\n    int32_t lane_sum = vget_lane_s32(sum_combined, 0) + vget_lane_s32(sum_combined, 1);\n\n    // Add remaining elements\n    for (size_t i = vec_size; i < total_elements; i++) {\n        lane_sum += matrix[i];\n    }\n\n    total_sum = lane_sum;\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_length = total_elements - (total_elements % 4);\n\n    // Initialize a 64-bit accumulator vector to zero\n    int64x2_t sum_vector = vdupq_n_s64(0);\n\n    // Process 4 integers at a time using Neon SIMD\n    for (size_t i = 0; i < vector_length; i += 4) {\n        int32x4_t current_vector = vld1q_s32(matrix + i);\n        int64x2_t lower_half = vmovl_s32(vget_low_s32(current_vector));\n        int64x2_t upper_half = vmovl_high_s32(current_vector);\n        sum_vector = vaddq_s64(sum_vector, lower_half);\n        sum_vector = vaddq_s64(sum_vector, upper_half);\n    }\n\n    // Horizontal sum of the SIMD vector\n    total_sum = vgetq_lane_s64(sum_vector, 0) + vgetq_lane_s64(sum_vector, 1);\n\n    // Handle remaining elements\n    for (size_t i = vector_length; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using Neon\n    size_t vector_len = length - (length % 16);\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    int8x16_t index_vec = vdupq_n_s8(0);\n    int8x16_t current_index_vec = vseq_s8();\n\n    for (size_t i = 0; i < vector_len; i += 16) {\n        int8x16_t current_vec = vld1q_s8(src + i);\n        int8x16_t comparison = vcgtq_s8(current_vec, max_vec);\n        max_vec = vbslq_s8(comparison, current_vec, max_vec);\n        index_vec = vbslq_s8(comparison, current_index_vec, index_vec);\n        current_index_vec = vaddq_s8(current_index_vec, vdupq_n_s8(16));\n    }\n\n    // Horizontal max within the vector\n    int8_t temp_max[16];\n    int8_t temp_index[16];\n    vst1q_s8(temp_max, max_vec);\n    vst1q_s8(temp_index, index_vec);\n\n    for (int j = 0; j < 16; j++) {\n        if (temp_max[j] > max_val) {\n            max_val = temp_max[j];\n            max_index = temp_index[j];\n        }\n    }\n\n    // Process remaining elements\n    for (size_t i = vector_len; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using Neon\n    size_t vector_len = length - (length % 16);\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    int8x16_t max_idx_vec = vdupq_n_s8(0);\n\n    for (size_t i = 0; i < vector_len; i += 16) {\n        int8x16_t current_vec = vld1q_s8(src + i);\n        int8x16_t idx_vec = vdupq_n_s8(i);\n\n        // Compare current values with max values\n        uint8x16_t mask = vcgtq_s8(current_vec, max_vec);\n        max_vec = vbslq_s8(mask, current_vec, max_vec);\n        max_idx_vec = vbslq_s8(mask, idx_vec, max_idx_vec);\n    }\n\n    // Horizontal max reduction\n    int8_t lane_max[16];\n    size_t lane_indices[16];\n    vst1q_s8(lane_max, max_vec);\n    vst1q_s8((int8_t*)lane_indices, max_idx_vec);\n\n    for (int j = 0; j < 16; j++) {\n        if (lane_max[j] > max_val) {\n            max_val = lane_max[j];\n            max_index = lane_indices[j];\n        }\n    }\n\n    // Process remaining elements\n    for (size_t i = vector_len; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using Neon\n    size_t vector_len = length - (length % 16);\n    int8x16_t max_vec = vld1q_s8(src);\n    uint8x16_t max_idx_vec = vdupq_n_u8(0);\n\n    for (size_t i = 0; i < vector_len; i += 16) {\n        int8x16_t current_vec = vld1q_s8(src + i);\n        uint8x16_t current_idx_vec = vdupq_n_u8(i);\n\n        // Compare current vector with max vector\n        uint8x16_t mask = vcgtq_s8(current_vec, max_vec);\n        max_vec = vmaxq_s8(current_vec, max_vec);\n        max_idx_vec = vbslq_u8(mask, current_idx_vec, max_idx_vec);\n    }\n\n    // Horizontal max within the vector\n    int8_t lane_max[16];\n    uint8_t lane_idx[16];\n    vst1q_s8(lane_max, max_vec);\n    vst1q_u8(lane_idx, max_idx_vec);\n\n    for (int j = 0; j < 16; j++) {\n        if (lane_max[j] > max_val) {\n            max_val = lane_max[j];\n            max_index = lane_idx[j];\n        }\n    }\n\n    // Process remaining elements\n    for (size_t i = vector_len; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using Neon\n    size_t vector_len = length - (length % 16);\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    int8x16_t index_vec = vdupq_n_s8(0);\n    int8x16_t current_index_vec = vseq_s8();\n\n    for (size_t i = 0; i < vector_len; i += 16) {\n        int8x16_t current_vec = vld1q_s8(src + i);\n        int8x16_t comparison = vcgtq_s8(current_vec, max_vec);\n        max_vec = vbslq_s8(comparison, current_vec, max_vec);\n        index_vec = vbslq_s8(comparison, current_index_vec, index_vec);\n        current_index_vec = vaddq_s8(current_index_vec, vdupq_n_s8(16));\n    }\n\n    // Horizontal max within the vector\n    int8_t lane_max[16];\n    int8_t lane_indices[16];\n    vst1q_s8(lane_max, max_vec);\n    vst1q_s8(lane_indices, index_vec);\n\n    for (int j = 0; j < 16; j++) {\n        if (lane_max[j] > max_val) {\n            max_val = lane_max[j];\n            max_index = lane_indices[j];\n        }\n    }\n\n    // Process remaining elements\n    for (size_t i = vector_len; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using Neon\n    size_t vector_len = length - (length % 16);\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    int8x16_t index_vec = vdupq_n_s8(0);\n    int8x16_t current_index_vec = vseq_s8();\n\n    for (size_t i = 0; i < vector_len; i += 16) {\n        int8x16_t current_vec = vld1q_s8(src + i);\n        int8x16_t comparison = vcgtq_s8(current_vec, max_vec);\n        max_vec = vbslq_s8(comparison, current_vec, max_vec);\n        index_vec = vbslq_s8(comparison, current_index_vec, index_vec);\n        current_index_vec = vaddq_s8(current_index_vec, vdupq_n_s8(16));\n    }\n\n    // Horizontal max within the vector\n    int8_t lane_max[16];\n    int8_t lane_indices[16];\n    vst1q_s8(lane_max, max_vec);\n    vst1q_s8(lane_indices, index_vec);\n\n    for (int j = 0; j < 16; j++) {\n        if (lane_max[j] > max_val) {\n            max_val = lane_max[j];\n            max_index = lane_indices[j];\n        }\n    }\n\n    // Process remaining elements\n    for (size_t i = vector_len; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Create a vector of indices\n        uint16x8_t indices = {0, 1, 2, 3, 4, 5, 6, 7};\n        indices = vaddq_u16(indices, vdupq_n_u16(i));\n        \n        // Perform bitwise AND with mask for each index\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_mask = vandq_u16(indices, mask_vec);\n        \n        // Create a comparison mask where non-zero indices select src1\n        uint16x8_t cmp_mask = vceqq_u16(index_mask, vdupq_n_u16(0));\n        \n        // Blend the vectors using the comparison mask\n        uint16x8_t result = vbslq_u16(cmp_mask, vec2, vec1);\n        \n        // Store the result in destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Create a vector of indices\n        uint16x8_t indices = {0, 1, 2, 3, 4, 5, 6, 7};\n        indices = vaddq_u16(indices, vdupq_n_u16(i));\n        \n        // Perform bitwise AND with mask for each index\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_mask = vandq_u16(indices, mask_vec);\n        \n        // Compare mask result to zero\n        uint16x8_t zero = vdupq_n_u16(0);\n        uint16x8_t compare = vceqq_u16(index_mask, zero);\n        \n        // Blend vectors using bitwise select\n        uint16x8_t result = vbslq_u16(compare, vec2, vec1);\n        \n        // Store result in destination\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Create a vector of indices\n        uint16x8_t indices = vcombine_u16(\n            vcreate_u16(i),\n            vcreate_u16(i + 4)\n        );\n        \n        // Perform bitwise AND with mask for each index\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_mask_result = vandq_u16(indices, mask_vec);\n        \n        // Compare mask result to zero\n        uint16x8_t zero_vec = vdupq_n_u16(0);\n        uint16x8_t mask_compare = vceqq_u16(index_mask_result, zero_vec);\n        \n        // Blend vectors based on mask comparison\n        uint16x8_t result = vbslq_u16(mask_compare, vec2, vec1);\n        \n        // Store result in destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Create a vector of indices\n        uint16x8_t indices = vcombine_u16(\n            vcreate_u16(i),\n            vcreate_u16(i + 4)\n        );\n        \n        // Perform bitwise AND with mask for each index\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_mask_result = vandq_u16(indices, mask_vec);\n        \n        // Compare mask result to zero\n        uint16x8_t zero_vec = vdupq_n_u16(0);\n        uint16x8_t blend_mask = vceqq_u16(index_mask_result, zero_vec);\n        \n        // Blend the vectors using the mask\n        uint16x8_t result = vbslq_u16(blend_mask, vec2, vec1);\n        \n        // Store the result in destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Create a vector of indices\n        uint16x8_t indices = vcombine_u16(\n            vcreate_u16(i),\n            vcreate_u16(i + 4)\n        );\n        \n        // Perform bitwise AND with mask for each index\n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t index_mask_result = vandq_u16(indices, mask_vec);\n        \n        // Compare mask result to zero\n        uint16x8_t zero_vec = vdupq_n_u16(0);\n        uint16x8_t blend_mask = vceqq_u16(index_mask_result, zero_vec);\n        \n        // Blend the vectors using the mask\n        uint16x8_t result = vbslq_u16(blend_mask, vec2, vec1);\n        \n        // Store the result in destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t input = vld1q_u32(src + i);\n        \n        // Perform population count for each 32-bit element\n        uint32x4_t result = vcntq_u32(input);\n        \n        // Store the result in destination array\n        vst1q_u32(dst + i, result);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t input = vld1q_u32(src + i);\n        \n        // Initialize accumulator for population count\n        uint32x4_t popcount = vdupq_n_u32(0);\n        \n        // Bit manipulation to count set bits\n        for (int j = 0; j < 32; j++) {\n            // Shift and mask to isolate each bit\n            uint32x4_t bit = vshrq_n_u32(input, j);\n            bit = vandq_u32(bit, vdupq_n_u32(1));\n            \n            // Accumulate set bits\n            popcount = vaddq_u32(popcount, bit);\n        }\n        \n        // Store results in destination array\n        vst1q_u32(dst + i, popcount);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        uint32_t count = 0;\n        while (x) {\n            count += x & 1;\n            x >>= 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t input = vld1q_u32(src + i);\n        \n        // Initialize accumulator for population count\n        uint32x4_t popcount = vdupq_n_u32(0);\n        \n        // Count bits using bit manipulation instructions\n        for (int bit = 0; bit < 32; bit++) {\n            // Shift and mask to isolate each bit\n            uint32x4_t bitMask = vshrq_n_u32(input, bit);\n            bitMask = vandq_u32(bitMask, vdupq_n_u32(1));\n            \n            // Accumulate bit counts\n            popcount = vaddq_u32(popcount, bitMask);\n        }\n        \n        // Store results in destination array\n        vst1q_u32(dst + i, popcount);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < length; i++) {\n        uint32_t value = src[i];\n        uint32_t count = 0;\n        \n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        \n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t input = vld1q_u32(src + i);\n        \n        // Perform population count using Neon intrinsics\n        uint32x4_t result = vcntq_u32(input);\n        \n        // Store the result in destination array\n        vst1q_u32(dst + i, result);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t input = vld1q_u32(src + i);\n        \n        // Perform population count for each 32-bit element\n        uint32x4_t result = vcntq_u32(input);\n        \n        // Store the results\n        vst1q_u32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using 128-bit Neon registers\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit unsigned integers from each source array\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Perform saturating addition\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        \n        // Store the result in the destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint16_t sum = src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using 128-bit Neon registers\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from each source array\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Perform saturating addition\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        \n        // Store the result in the destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using 128-bit Neon registers\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from each source array\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Perform saturating addition\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        \n        // Store the result in the destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon 128-bit vectors\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit unsigned integers from each source array\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Perform saturating addition\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        \n        // Store the result in the destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using 128-bit Neon registers\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from each source array\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        \n        // Perform saturating addition\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        \n        // Store the result in the destination array\n        vst1q_u16(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint16_t sum = src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Iterate through rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate through columns of B\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            // Process 2 elements at a time using Neon\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                // Load A and B values\n                float64x2_t a_vec = vld1q_f64(&A[i*n + k]);\n                float64x2_f64_t b_vec = vld1q_f64(&B[k*p + j]);\n                \n                // Check range condition\n                uint64x2_t mask_a = vcleq_f64(a_vec, vdupq_n_f64(100.0));\n                mask_a = vandq_u64(mask_a, vcgeq_f64(a_vec, vdupq_n_f64(-100.0)));\n                \n                uint64x2_t mask_b = vcleq_f64(b_vec, vdupq_n_f64(100.0));\n                mask_b = vandq_u64(mask_b, vcgeq_f64(b_vec, vdupq_n_f64(-100.0)));\n                \n                // Multiply and accumulate if in range\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                mul_vec = vbslq_f64(vandq_u64(mask_a, mask_b), mul_vec, vdupq_n_f64(0.0));\n                sum_vec = vaddq_f64(sum_vec, mul_vec);\n            }\n            \n            // Horizontal sum\n            double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                double a_val = A[i*n + k];\n                double b_val = B[k*p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i*p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(&A[i * n + k]);\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n                \n                // Check range condition\n                uint64x2_t mask_a = vandq_u64(\n                    vcleq_f64(a_vec, vdupq_n_f64(100.0)), \n                    vcgeq_f64(a_vec, vdupq_n_f64(-100.0))\n                );\n                uint64x2_t mask_b = vandq_u64(\n                    vcleq_f64(b_vec, vdupq_n_f64(100.0)), \n                    vcgeq_f64(b_vec, vdupq_n_f64(-100.0))\n                );\n                \n                // Multiply and accumulate if in range\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                mul_vec = vbslq_f64(vandq_u64(mask_a, mask_b), mul_vec, vdupq_n_f64(0.0));\n                sum_vec = vaddq_f64(sum_vec, mul_vec);\n            }\n            \n            // Horizontal sum\n            double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n            \n            // Handle remaining elements if n is odd\n            for (size_t k = n - (n % 2); k < n; k++) {\n                if (A[i * n + k] >= -100.0 && A[i * n + k] <= 100.0 && \n                    B[k * p + j] >= -100.0 && B[k * p + j] <= 100.0) {\n                    sum += A[i * n + k] * B[k * p + j];\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Iterate through rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate through columns of B\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            // Process 2 elements at a time using SIMD\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                // Load A and B values\n                float64x2_t a_vec = vld1q_f64(&A[i*n + k]);\n                float64x2_f64_t b_vec = vld1q_f64(&B[k*p + j]);\n                \n                // Check range condition\n                uint64x2_t mask_a = vcleq_f64(a_vec, vdupq_n_f64(100.0));\n                mask_a = vandq_u64(mask_a, vcgeq_f64(a_vec, vdupq_n_f64(-100.0)));\n                \n                uint64x2_t mask_b = vcleq_f64(b_vec, vdupq_n_f64(100.0));\n                mask_b = vandq_u64(mask_b, vcgeq_f64(b_vec, vdupq_n_f64(-100.0)));\n                \n                // Multiply and accumulate if in range\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                mul_vec = vbslq_f64(vandq_u64(mask_a, mask_b), mul_vec, vdupq_n_f64(0.0));\n                sum_vec = vaddq_f64(sum_vec, mul_vec);\n            }\n            \n            // Horizontal sum\n            double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                double a_val = A[i*n + k];\n                double b_val = B[k*p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i*p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Iterate through rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate through columns of B\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            // Process 2 elements at a time using Neon\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                // Load A and B values\n                float64x2_t a_vec = vld1q_f64(&A[i*n + k]);\n                float64x2_f64_t b_vec = vld1q_f64(&B[k*p + j]);\n                \n                // Check range condition\n                uint64x2_t mask_a = vcleq_f64(a_vec, vdupq_n_f64(100.0));\n                mask_a = vandq_u64(mask_a, vcgeq_f64(a_vec, vdupq_n_f64(-100.0)));\n                \n                uint64x2_t mask_b = vcleq_f64(b_vec, vdupq_n_f64(100.0));\n                mask_b = vandq_u64(mask_b, vcgeq_f64(b_vec, vdupq_n_f64(-100.0)));\n                \n                // Multiply and accumulate if in range\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                mul_vec = vbslq_f64(vandq_u64(mask_a, mask_b), mul_vec, vdupq_n_f64(0.0));\n                sum_vec = vaddq_f64(sum_vec, mul_vec);\n            }\n            \n            // Horizontal sum\n            double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                double a_val = A[i*n + k];\n                double b_val = B[k*p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i*p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Iterate through rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate through columns of B\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            // Process 2 elements at a time using Neon\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                // Load A and B values\n                float64x2_t a_vec = vld1q_f64(&A[i*n + k]);\n                float64x2_f64_t b_vec = vld1q_f64(&B[k*p + j]);\n                \n                // Check range condition\n                uint64x2_t mask_a = vcleq_f64(a_vec, vdupq_n_f64(100.0));\n                mask_a = vandq_u64(mask_a, vcgeq_f64(a_vec, vdupq_n_f64(-100.0)));\n                \n                uint64x2_t mask_b = vcleq_f64(b_vec, vdupq_n_f64(100.0));\n                mask_b = vandq_u64(mask_b, vcgeq_f64(b_vec, vdupq_n_f64(-100.0)));\n                \n                // Multiply and accumulate if in range\n                float64x2_t mul_vec = vmulq_f64(a_vec, b_vec);\n                mul_vec = vbslq_f64(vandq_u64(mask_a, mask_b), mul_vec, vdupq_n_f64(0.0));\n                sum_vec = vaddq_f64(sum_vec, mul_vec);\n            }\n            \n            // Horizontal sum\n            double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                double a_val = A[i*n + k];\n                double b_val = B[k*p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i*p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process 2 elements at a time using 128-bit Neon registers\n            size_t k = 0;\n            for (; k + 1 < dim3; k += 2) {\n                int64x2_t va = vld1q_s64(A + base_idx + k);\n                int64x2_t vb = vld1q_s64(B + base_idx + k);\n                int64x2_t vc = vaddq_s64(va, vb);\n                vst1q_s64(C + base_idx + k, vc);\n            }\n            \n            // Handle remaining elements\n            for (; k < dim3; ++k) {\n                C[base_idx + k] = A[base_idx + k] + B[base_idx + k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process 2 elements at a time using 128-bit Neon registers\n            size_t k = 0;\n            for (; k + 1 < dim3; k += 2) {\n                int64x2_t va = vld1q_s64(A + base_idx + k);\n                int64x2_t vb = vld1q_s64(B + base_idx + k);\n                int64x2_t vc = vaddq_s64(va, vb);\n                vst1q_s64(C + base_idx + k, vc);\n            }\n            \n            // Handle remaining elements\n            for (; k < dim3; ++k) {\n                C[base_idx + k] = A[base_idx + k] + B[base_idx + k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process 2 elements at a time using 128-bit Neon registers\n            size_t k = 0;\n            for (; k + 1 < dim3; k += 2) {\n                // Load 2 elements from A and B\n                int64x2_t a_vec = vld1q_s64(A + base_idx + k);\n                int64x2_t b_vec = vld1q_s64(B + base_idx + k);\n                \n                // Add the vectors\n                int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n                \n                // Store the result in C\n                vst1q_s64(C + base_idx + k, c_vec);\n            }\n            \n            // Handle remaining elements if dim3 is odd\n            for (; k < dim3; ++k) {\n                C[base_idx + k] = A[base_idx + k] + B[base_idx + k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process 2 elements at a time using 128-bit Neon registers\n            size_t k = 0;\n            for (; k + 1 < dim3; k += 2) {\n                // Load 2 elements from A and B\n                int64x2_t a_vec = vld1q_s64(A + base_idx + k);\n                int64x2_t b_vec = vld1q_s64(B + base_idx + k);\n                \n                // Add the vectors\n                int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n                \n                // Store the result in C\n                vst1q_s64(C + base_idx + k, c_vec);\n            }\n            \n            // Handle remaining elements if dim3 is odd\n            for (; k < dim3; ++k) {\n                C[base_idx + k] = A[base_idx + k] + B[base_idx + k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process 2 elements at a time using 128-bit Neon registers\n            size_t k = 0;\n            for (; k + 1 < dim3; k += 2) {\n                // Load 2 elements from A and B\n                int64x2_t a_vec = vld1q_s64(A + base_idx + k);\n                int64x2_t b_vec = vld1q_s64(B + base_idx + k);\n                \n                // Add the vectors\n                int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n                \n                // Store the result in C\n                vst1q_s64(C + base_idx + k, c_vec);\n            }\n            \n            // Handle remaining elements if dim3 is odd\n            for (; k < dim3; ++k) {\n                C[base_idx + k] = A[base_idx + k] + B[base_idx + k];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 float elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Add the two vectors\n        float32x4_t sum_vec = vaddq_f32(vec1, vec2);\n        \n        // Round to nearest integer\n        float32x4_t rounded_vec = vrndnq_f32(sum_vec);\n        \n        // Store the result in destination array\n        vst1q_f32(dst + i, rounded_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 float values from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Add the two vectors\n        float32x4_t sum_vec = vaddq_f32(vec1, vec2);\n        \n        // Round to nearest integer\n        float32x4_t rounded_vec = vrndnq_f32(sum_vec);\n        \n        // Store the result in dst\n        vst1q_f32(dst + i, rounded_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 float values from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Add the two vectors\n        float32x4_t sum_vec = vaddq_f32(vec1, vec2);\n        \n        // Round to nearest integer\n        float32x4_t rounded_vec = vrndnq_f32(sum_vec);\n        \n        // Store the result in destination array\n        vst1q_f32(dst + i, rounded_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 float elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Add the two vectors\n        float32x4_t sum_vec = vaddq_f32(vec1, vec2);\n        \n        // Round to nearest integer using Neon intrinsics\n        float32x4_t rounded_vec = vrndnq_f32(sum_vec);\n        \n        // Store the result in destination array\n        vst1q_f32(dst + i, rounded_vec);\n    }\n    \n    // Handle remaining elements if length is not multiple of 4\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 float elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Add the two vectors\n        float32x4_t sum_vec = vaddq_f32(vec1, vec2);\n        \n        // Round to nearest integer\n        float32x4_t rounded_vec = vrndnq_f32(sum_vec);\n        \n        // Store the result in destination array\n        vst1q_f32(dst + i, rounded_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n\n        // Create mask for index multiple of 2 and abs difference <= 50\n        uint32x4_t index_mask = vcgeq_u32(vdupq_n_u32(i), vsetq_lane_u32(0, vdupq_n_u32(0), 0));\n        float32x4_t diff = vabsq_f32(vsubq_f32(vec1, vec2));\n        uint32x4_t diff_mask = vcleq_f32(diff, vdupq_n_f32(50.0f));\n        uint32x4_t combined_mask = vandq_u32(index_mask, diff_mask);\n\n        // Multiply and round up where mask is true\n        float32x4_t mul_result = vmulq_f32(vec1, vec2);\n        float32x4_t rounded_result = vrintrq_f32(mul_result);\n        float32x4_t final_result = vbslq_f32(combined_mask, rounded_result, vdupq_n_f32(-1.0f));\n\n        // Store result\n        vst1q_f32(dst + i, final_result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        float diff = fabsf(src1[i] - src2[i]);\n        dst[i] = (i % 2 == 0 && diff <= 50.0f) ? ceilf(src1[i] * src2[i]) : -1.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 3 < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vabdq_f32(vec1, vec2);\n        \n        // Check if absolute difference is within 50\n        uint32x4_t mask_diff = vcleq_f32(diff, vdupq_n_f32(50.0f));\n        \n        // Check if index is multiple of 2\n        uint32x4_t mask_index = vcgeq_u32(vdupq_n_u32(i), \n            vsetq_lane_u32(0, vsetq_lane_u32(1, vdupq_n_u32(0), 1), 0));\n        \n        // Combine masks\n        uint32x4_t mask = vandq_u32(mask_diff, mask_index);\n        \n        // Multiply elements where conditions are met\n        float32x4_t mul_result = vmulq_f32(vec1, vec2);\n        \n        // Round up toward positive infinity\n        float32x4_t rounded = vrndpq_f32(mul_result);\n        \n        // Select between rounded result and -1\n        float32x4_t result = vbslq_f32(mask, rounded, vdupq_n_f32(-1.0f));\n        \n        // Store result in destination array\n        vst1q_f32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff <= 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 3 < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vabdq_f32(vec1, vec2);\n        \n        // Create mask for elements within 50 and index multiple of 2\n        uint32x4_t mask1 = vcltq_f32(diff, vdupq_n_f32(50.0f));\n        uint32x4_t mask2 = vceqq_u32(vandq_u32(vdupq_n_u32(i), vdupq_n_u32(1)), vdupq_n_u32(0));\n        uint32x4_t mask = vandq_u32(mask1, mask2);\n        \n        // Multiply and round up where conditions are met\n        float32x4_t mul_result = vmulq_f32(vec1, vec2);\n        float32x4_t rounded = vrintrq_f32(mul_result);\n        \n        // Select result based on mask\n        float32x4_t result = vbslq_f32(mask, rounded, vdupq_n_f32(-1.0f));\n        \n        // Store result in destination\n        vst1q_f32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff < 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 3 < length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vabdq_f32(vec1, vec2);\n        \n        // Create mask for elements within 50 and index multiple of 2\n        uint32x4_t mask1 = vcleq_f32(diff, vdupq_n_f32(50.0f));\n        uint32x4_t mask2 = vceqq_u32(vandq_u32(vdupq_n_u32(i), vdupq_n_u32(1)), vdupq_n_u32(0));\n        uint32x4_t mask = vandq_u32(mask1, mask2);\n        \n        // Multiply and round up where conditions are met\n        float32x4_t result = vbslq_f32(mask, \n            vrintp_f32(vmulq_f32(vec1, vec2)), \n            vdupq_n_f32(-1.0f)\n        );\n        \n        // Store result\n        vst1q_f32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff <= 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from src1 and src2\n        float32x4_t vec1 = vld1q_f32(src1 + i);\n        float32x4_t vec2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vabdq_f32(vec1, vec2);\n        \n        // Create mask for elements within 50 and index multiple of 2\n        uint32x4_t mask1 = vcleq_f32(diff, vdupq_n_f32(50.0f));\n        uint32x4_t mask2 = vceqq_u32(vandq_u32(vdupq_n_u32(i), vdupq_n_u32(1)), vdupq_n_u32(0));\n        uint32x4_t mask = vandq_u32(mask1, mask2);\n        \n        // Multiply and round up where conditions are met\n        float32x4_t result = vbslq_f32(mask, \n            vceilq_f32(vmulq_f32(vec1, vec2)), \n            vdupq_n_f32(-1.0f)\n        );\n        \n        // Store result\n        vst1q_f32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff <= 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Broadcast scalar to all lanes of a vector register\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    // Process 2 doubles at a time using Neon SIMD\n    size_t vector_size = n - (n % 2);\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < vector_size; j += 2) {\n            // Load 2 doubles from source matrix\n            float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n            \n            // Multiply matrix values with scalar\n            float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n            \n            // Store result back to destination matrix\n            vst1q_f64(dst + i * n + j, result_vec);\n        }\n    }\n\n    // Handle remaining elements if n is odd\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = vector_size; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Broadcast scalar to a Neon vector\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    // Process 2 doubles at a time using Neon\n    size_t vector_length = n - (n % 2);\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < vector_length; j += 2) {\n            // Load 2 doubles from source matrix\n            float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n            \n            // Multiply with scalar vector\n            float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n            \n            // Store result back to destination matrix\n            vst1q_f64(dst + i * n + j, result_vec);\n        }\n    }\n\n    // Handle remaining elements if n is odd\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = vector_length; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Broadcast scalar to a Neon vector\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    // Process 2 doubles at a time using Neon\n    size_t vector_length = n - (n % 2);\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < vector_length; j += 2) {\n            // Load 2 doubles from source matrix\n            float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n            \n            // Multiply with scalar vector\n            float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n            \n            // Store result in destination matrix\n            vst1q_f64(dst + i * n + j, result_vec);\n        }\n    }\n\n    // Handle remaining elements if n is odd\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = vector_length; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Broadcast scalar to a Neon vector\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    // Process 2 doubles at a time using Neon\n    size_t vec_len = (n / 2) * 2;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < vec_len; j += 2) {\n            // Load 2 doubles from source matrix\n            float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n            \n            // Multiply with scalar vector\n            float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n            \n            // Store result in destination matrix\n            vst1q_f64(dst + i * n + j, result_vec);\n        }\n\n        // Handle remaining elements if n is odd\n        for (size_t j = vec_len; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Broadcast scalar to a Neon vector\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    // Process 2 doubles at a time using Neon\n    size_t vector_length = n - (n % 2);\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < vector_length; j += 2) {\n            // Load 2 doubles from source matrix\n            float64x2_t mat_vec = vld1q_f64(mat + i * n + j);\n            \n            // Multiply with scalar vector\n            float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n            \n            // Store result in destination matrix\n            vst1q_f64(dst + i * n + j, result_vec);\n        }\n    }\n\n    // Handle remaining elements if n is odd\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = vector_length; j < n; j++) {\n            dst[i * n + j] = mat[i * n + j] * scalar;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_vec = vfmaq_f32(sum_vec, vec, vec);\n        }\n        \n        // Horizontal sum of squares\n        float32x2_t sum_low = vget_low_f32(sum_vec);\n        float32x2_t sum_high = vget_high_f32(sum_vec);\n        sum_low = vadd_f32(sum_low, sum_high);\n        sum_low = vpadd_f32(sum_low, sum_low);\n        \n        // Handle remaining elements\n        float sum = vget_lane_f32(sum_low, 0);\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        float norm = sqrtf(sum);\n        \n        // Normalize row using NEON\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            vec = vdivq_f32(vec, vdupq_n_f32(norm));\n            vst1q_f32(row + j, vec);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t squared_vec = vmulq_f32(vec, vec);\n            sum_vec = vaddq_f32(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum\n        float32x2_t sum_low = vget_low_f32(sum_vec);\n        float32x2_t sum_high = vget_high_f32(sum_vec);\n        sum_low = vadd_f32(sum_low, sum_high);\n        sum_low = vpadd_f32(sum_low, sum_low);\n        float sum = vget_lane_f32(sum_low, 0);\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        float norm = sqrtf(sum);\n        \n        // Normalize row using NEON\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized_vec = vmulq_n_f32(vec, 1.0f / norm);\n            vst1q_f32(row + j, normalized_vec);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared sum using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t squared_vec = vmulq_f32(vec, vec);\n            sum_vec = vaddq_f32(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of vector\n        float32x2_t sum_low = vget_low_f32(sum_vec);\n        float32x2_t sum_high = vget_high_f32(sum_vec);\n        sum_low = vadd_f32(sum_low, sum_high);\n        float32x2_t sum_final = vpadd_f32(sum_low, sum_low);\n        float sum = vget_lane_f32(sum_final, 0);\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Compute normalization factor\n        float norm_factor = 1.0f / sqrtf(sum);\n        \n        // Normalize row using NEON\n        float32x4_t norm_vec = vdupq_n_f32(norm_factor);\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized_vec = vmulq_f32(vec, norm_vec);\n            vst1q_f32(row + j, normalized_vec);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            row[j] *= norm_factor;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared sum using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t squared_vec = vmulq_f32(vec, vec);\n            sum_vec = vaddq_f32(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        float32x2_t sum_low = vget_low_f32(sum_vec);\n        float32x2_t sum_high = vget_high_f32(sum_vec);\n        sum_low = vadd_f32(sum_low, sum_high);\n        float32_t sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Compute L2 norm\n        float norm = sqrtf(sum);\n        \n        // Normalize row using NEON\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized_vec = vdivq_f32(vec, vdupq_n_f32(norm));\n            vst1q_f32(row + j, normalized_vec);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared sum using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t squared_vec = vmulq_f32(vec, vec);\n            sum_vec = vaddq_f32(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of vector\n        float32x2_t sum_low = vget_low_f32(sum_vec);\n        float32x2_t sum_high = vget_high_f32(sum_vec);\n        sum_low = vadd_f32(sum_low, sum_high);\n        float32_t sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Compute L2 norm\n        float norm = sqrtf(sum);\n        \n        // Normalize row using NEON\n        for (size_t j = 0; j + 4 <= n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            float32x4_t normalized_vec = vdivq_f32(vec, vdupq_n_f32(norm));\n            vst1q_f32(row + j, normalized_vec);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = (n / 4) * 4; j < n; j++) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k++) {\n                float64x2_t mat1_vec = vdupq_n_f64(mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n                \n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n            \n            float64x2_t rounded_vec = vcvtq_f64_u64(vcvtmq_u64_f64(sum_vec));\n            vst1q_f64(&dst[i * p + j], rounded_vec);\n        }\n        \n        // Handle remaining columns if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k++) {\n                float64x2_t mat1_vec = vdupq_n_f64(mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n                \n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n            \n            float64x2_t rounded_vec = vcvtq_f64_u64(vcvtaq_u64_f64(sum_vec));\n            vst1q_f64(&dst[i * p + j], rounded_vec);\n        }\n        \n        // Handle remaining columns if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k++) {\n                float64x2_t mat1_vec = vdupq_n_f64(mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n                \n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n            \n            float64x2_t rounded_vec = vcvtq_f64_u64(vcvtaq_u64_f64(sum_vec));\n            vst1q_f64(&dst[i * p + j], rounded_vec);\n        }\n        \n        // Handle remaining columns if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k++) {\n                float64x2_t mat1_vec = vdupq_n_f64(mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n                \n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n            \n            float64x2_t rounded_vec = vcvtq_f64_u64(vcvtaq_u64_f64(sum_vec));\n            vst1q_f64(&dst[i * p + j], rounded_vec);\n        }\n        \n        // Handle remaining column if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k++) {\n                float64x2_t mat1_vec = vdupq_n_f64(mat1[i * n + k]);\n                float64x2_t mat2_vec = vld1q_f64(&mat2[k * p + j]);\n                \n                sum_vec = vfmaq_f64(sum_vec, mat1_vec, mat2_vec);\n            }\n            \n            float64x2_t rounded_vec = vcvtq_f64_u64(vcvtaq_u64_f64(sum_vec));\n            vst1q_f64(&dst[i * p + j], rounded_vec);\n        }\n        \n        // Handle remaining column if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Process 4 rows at a time using Neon SIMD\n    for (size_t j = 0; j < cols; j += 4) {\n        for (size_t i = 0; i < rows; i += 4) {\n            // Load 4x4 block of source matrix\n            float32x4_t row0 = vld1q_f32(src + i * cols + j);\n            float32x4_t row1 = vld1q_f32(src + (i + 1) * cols + j);\n            float32x4_t row2 = vld1q_f32(src + (i + 2) * cols + j);\n            float32x4_t row3 = vld1q_f32(src + (i + 3) * cols + j);\n\n            // Round to nearest quarter\n            row0 = vmulq_f32(vrndq_f32(vmulq_f32(row0, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n            row1 = vmulq_f32(vrndq_f32(vmulq_f32(row1, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n            row2 = vmulq_f32(vrndq_f32(vmulq_f32(row2, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n            row3 = vmulq_f32(vrndq_f32(vmulq_f32(row3, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n\n            // Transpose\n            float32x4x2_t tr0_1 = vtrnq_f32(row0, row1);\n            float32x4x2_t tr2_3 = vtrnq_f32(row2, row3);\n\n            float32x4_t tr0 = tr0_1.val[0];\n            float32x4_t tr1 = tr0_1.val[1];\n            float32x4_t tr2 = tr2_3.val[0];\n            float32x4_t tr3 = tr2_3.val[1];\n\n            // Store transposed and rounded values\n            vst1q_f32(dst + j * rows + i, tr0);\n            vst1q_f32(dst + j * rows + i + 1, tr2);\n            vst1q_f32(dst + (j + 1) * rows + i, tr1);\n            vst1q_f32(dst + (j + 1) * rows + i + 1, tr3);\n        }\n    }\n\n    // Handle remaining rows and columns if not divisible by 4\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i++) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) * 0.25f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t j = 0; j < cols; j += 4) {\n        for (size_t i = 0; i < rows; i += 4) {\n            // Load 4x4 block of source matrix\n            float32x4_t row0 = vld1q_f32(src + i * cols + j);\n            float32x4_t row1 = vld1q_f32(src + (i + 1) * cols + j);\n            float32x4_t row2 = vld1q_f32(src + (i + 2) * cols + j);\n            float32x4_t row3 = vld1q_f32(src + (i + 3) * cols + j);\n\n            // Round to nearest quarter\n            row0 = vmulq_f32(vrndq_f32(vmulq_f32(row0, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n            row1 = vmulq_f32(vrndq_f32(vmulq_f32(row1, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n            row2 = vmulq_f32(vrndq_f32(vmulq_f32(row2, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n            row3 = vmulq_f32(vrndq_f32(vmulq_f32(row3, vdupq_n_f32(4.0f))), vdupq_n_f32(0.25f));\n\n            // Transpose\n            float32x4x2_t tr0_1 = vtrnq_f32(row0, row1);\n            float32x4x2_t tr2_3 = vtrnq_f32(row2, row3);\n\n            float32x4_t tr_row0 = tr0_1.val[0];\n            float32x4_t tr_row1 = tr0_1.val[1];\n            float32x4_t tr_row2 = tr2_3.val[0];\n            float32x4_t tr_row3 = tr2_3.val[1];\n\n            // Store transposed and rounded values\n            vst1q_f32(dst + j * rows + i, tr_row0);\n            vst1q_f32(dst + j * rows + i + 1, tr_row1);\n            vst1q_f32(dst + j * rows + i + 2, tr_row2);\n            vst1q_f32(dst + j * rows + i + 3, tr_row3);\n        }\n    }\n\n    // Handle remaining rows and columns if not divisible by 4\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i++) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) * 0.25f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t j = 0; j < cols; j += 4) {\n        for (size_t i = 0; i < rows; i += 4) {\n            // Load 4x4 block of source matrix\n            float32x4_t row0 = vld1q_f32(src + i * cols + j);\n            float32x4_t row1 = vld1q_f32(src + (i + 1) * cols + j);\n            float32x4_t row2 = vld1q_f32(src + (i + 2) * cols + j);\n            float32x4_t row3 = vld1q_f32(src + (i + 3) * cols + j);\n\n            // Transpose 4x4 block\n            float32x4x2_t t0 = vtrnq_f32(row0, row1);\n            float32x4x2_t t1 = vtrnq_f32(row2, row3);\n\n            float32x4_t tr0 = vcombine_f32(vget_low_f32(t0.val[0]), vget_low_f32(t1.val[0]));\n            float32x4_t tr1 = vcombine_f32(vget_high_f32(t0.val[0]), vget_high_f32(t1.val[0]));\n            float32x4_t tr2 = vcombine_f32(vget_low_f32(t0.val[1]), vget_low_f32(t1.val[1]));\n            float32x4_t tr3 = vcombine_f32(vget_high_f32(t0.val[1]), vget_high_f32(t1.val[1]));\n\n            // Round to nearest quarter\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            tr0 = vmulq_f32(vrndq_f32(vmulq_f32(tr0, vrecpeq_f32(quarter))), quarter);\n            tr1 = vmulq_f32(vrndq_f32(vmulq_f32(tr1, vrecpeq_f32(quarter))), quarter);\n            tr2 = vmulq_f32(vrndq_f32(vmulq_f32(tr2, vrecpeq_f32(quarter))), quarter);\n            tr3 = vmulq_f32(vrndq_f32(vmulq_f32(tr3, vrecpeq_f32(quarter))), quarter);\n\n            // Store transposed and rounded block\n            vst1q_f32(dst + j * rows + i, tr0);\n            vst1q_f32(dst + j * rows + i + 1, tr1);\n            vst1q_f32(dst + j * rows + i + 2, tr2);\n            vst1q_f32(dst + j * rows + i + 3, tr3);\n        }\n    }\n\n    // Handle remaining rows and columns\n    for (size_t j = cols - (cols % 4); j < cols; j++) {\n        for (size_t i = 0; i < rows; i++) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) / 4.0f;\n        }\n    }\n\n    for (size_t i = rows - (rows % 4); i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t j = 0; j < cols; j += 4) {\n        for (size_t i = 0; i < rows; i += 4) {\n            // Load 4x4 block of source matrix\n            float32x4_t row0 = vld1q_f32(src + i * cols + j);\n            float32x4_t row1 = vld1q_f32(src + (i + 1) * cols + j);\n            float32x4_t row2 = vld1q_f32(src + (i + 2) * cols + j);\n            float32x4_t row3 = vld1q_f32(src + (i + 3) * cols + j);\n\n            // Transpose 4x4 block\n            float32x4x2_t tr0 = vtrnq_f32(row0, row1);\n            float32x4x2_t tr1 = vtrnq_f32(row2, row3);\n\n            float32x4_t tr_row0 = tr0.val[0];\n            float32x4_t tr_row1 = tr0.val[1];\n            float32x4_t tr_row2 = tr1.val[0];\n            float32x4_t tr_row3 = tr1.val[1];\n\n            // Round to nearest quarter\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            tr_row0 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row0, vrecpeq_f32(quarter))), quarter);\n            tr_row1 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row1, vrecpeq_f32(quarter))), quarter);\n            tr_row2 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row2, vrecpeq_f32(quarter))), quarter);\n            tr_row3 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row3, vrecpeq_f32(quarter))), quarter);\n\n            // Store transposed and rounded block\n            vst1q_f32(dst + j * rows + i, tr_row0);\n            vst1q_f32(dst + j * rows + i + 1, tr_row1);\n            vst1q_f32(dst + j * rows + i + 2, tr_row2);\n            vst1q_f32(dst + j * rows + i + 3, tr_row3);\n        }\n    }\n\n    // Handle remaining rows and columns if not divisible by 4\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i++) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val / 0.25f) * 0.25f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t j = 0; j < cols; j += 4) {\n        for (size_t i = 0; i < rows; i += 4) {\n            // Load 4x4 block of source matrix\n            float32x4_t row0 = vld1q_f32(src + i * cols + j);\n            float32x4_t row1 = vld1q_f32(src + (i + 1) * cols + j);\n            float32x4_t row2 = vld1q_f32(src + (i + 2) * cols + j);\n            float32x4_t row3 = vld1q_f32(src + (i + 3) * cols + j);\n\n            // Transpose 4x4 block\n            float32x4x2_t tr0 = vtrnq_f32(row0, row1);\n            float32x4x2_t tr1 = vtrnq_f32(row2, row3);\n\n            float32x4_t tr_row0 = tr0.val[0];\n            float32x4_t tr_row1 = tr0.val[1];\n            float32x4_t tr_row2 = tr1.val[0];\n            float32x4_t tr_row3 = tr1.val[1];\n\n            // Round to nearest quarter\n            float32x4_t quarter = vdupq_n_f32(0.25f);\n            tr_row0 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row0, vrecpeq_f32(quarter))), quarter);\n            tr_row1 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row1, vrecpeq_f32(quarter))), quarter);\n            tr_row2 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row2, vrecpeq_f32(quarter))), quarter);\n            tr_row3 = vmulq_f32(vrndq_f32(vmulq_f32(tr_row3, vrecpeq_f32(quarter))), quarter);\n\n            // Store transposed and rounded block\n            vst1q_f32(dst + j * rows + i, tr_row0);\n            vst1q_f32(dst + j * rows + i + 1, tr_row1);\n            vst1q_f32(dst + j * rows + i + 2, tr_row2);\n            vst1q_f32(dst + j * rows + i + 3, tr_row3);\n        }\n    }\n\n    // Handle remaining rows and columns\n    for (size_t j = cols - (cols % 4); j < cols; j++) {\n        for (size_t i = 0; i < rows; i++) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n    \n    for (size_t i = rows - (rows % 4); i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n        \n        // Subtract vectors\n        float32x4_t result_vec = vsubq_f32(vec1, vec2);\n        \n        // Round towards zero using vcvtzq_f32_s32\n        int32x4_t rounded_vec = vcvtzq_s32_f32(result_vec);\n        float32x4_t final_vec = vcvtq_f32_s32(rounded_vec);\n        \n        // Store result\n        vst1q_f32(dst + i, final_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        dst[i] = (int)(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n        \n        // Subtract vectors\n        float32x4_t result_vec = vsubq_f32(vec1, vec2);\n        \n        // Round towards zero\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(zero_vec, result_vec);\n        float32x4_t rounded_vec = vbslq_f32(mask, \n            vfmaq_f32(result_vec, result_vec, -1.0f), \n            vfmaq_f32(result_vec, result_vec, 1.0f)\n        );\n        \n        // Store result\n        vst1q_f32(dst + i, rounded_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        float result = tensor1[i] - tensor2[i];\n        dst[i] = result > 0 ? floorf(result) : ceilf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n        \n        // Subtract vectors\n        float32x4_t result_vec = vsubq_f32(vec1, vec2);\n        \n        // Round towards zero using Neon intrinsics\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t rounded_vec = vbslq_f32(vcgtq_f32(result_vec, zero_vec), \n                                             vfloq_f32(result_vec), \n                                             vcvtq_f32_s32(vcvtq_s32_f32(result_vec)));\n        \n        // Store result\n        vst1q_f32(dst + i, rounded_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        dst[i] = (float)((int)((tensor1[i] - tensor2[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n        \n        // Subtract vectors\n        float32x4_t result_vec = vsubq_f32(vec1, vec2);\n        \n        // Round towards zero\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t rounded_vec = vbslq_f32(\n            vcgtq_f32(result_vec, zero_vec),  // Positive values\n            vfmaq_n_f32(zero_vec, vcvtq_f32_s32(vcvtq_s32_f32(result_vec)), 1.0f),  // Floor\n            vfmaq_n_f32(zero_vec, vcvtq_f32_s32(vcvtq_s32_f32(result_vec)), -1.0f)  // Ceiling\n        );\n        \n        // Store result\n        vst1q_f32(dst + i, rounded_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        dst[i] = floorf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n        \n        // Subtract vectors\n        float32x4_t result_vec = vsubq_f32(vec1, vec2);\n        \n        // Round towards zero using Neon intrinsics\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n        float32x4_t rounded_vec = vbslq_f32(\n            vcgtq_f32(result_vec, zero_vec),  // Positive values\n            vfmaq_n_f32(zero_vec, vcvtq_f32_s32(vcvtq_s32_f32(result_vec)), 1.0f),\n            vfmaq_n_f32(zero_vec, vcvtq_f32_s32(vcvtq_s32_f32(result_vec)), -1.0f)\n        );\n        \n        // Store result\n        vst1q_f32(dst + i, rounded_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        dst[i] = floorf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (size_t i = 0; i < m; i++) {\n        size_t j;\n        for (j = 0; j + 1 < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(mat1 + i * n + j);\n            float64x2_t vec2 = vld1q_f64(mat2 + i * n + j);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(dst + i * n + j, result);\n        }\n        \n        // Handle any remaining single element\n        if (j < n) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; j + 1 < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(mat1 + i * n + j);\n            float64x2_t vec2 = vld1q_f64(mat2 + i * n + j);\n            \n            float64x2_t result = vmulq_f64(vec1, vec2);\n            \n            vst1q_f64(dst + i * n + j, result);\n        }\n        \n        // Handle any remaining elements\n        for (; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; j + 1 < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(mat1 + i * n + j);\n            float64x2_t vec2 = vld1q_f64(mat2 + i * n + j);\n            \n            float64x2_t result = vmulq_f64(vec1, vec2);\n            \n            vst1q_f64(dst + i * n + j, result);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        \n        // Process 2 doubles at a time using 128-bit Neon registers\n        for (; j + 1 < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(mat1 + i * n + j);\n            float64x2_t vec2 = vld1q_f64(mat2 + i * n + j);\n            \n            float64x2_t result = vmulq_f64(vec1, vec2);\n            \n            vst1q_f64(dst + i * n + j, result);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (size_t i = 0; i < m; i++) {\n        size_t j;\n        for (j = 0; j + 1 < n; j += 2) {\n            float64x2_t vec1 = vld1q_f64(mat1 + i * n + j);\n            float64x2_t vec2 = vld1q_f64(mat2 + i * n + j);\n            float64x2_t result = vmulq_f64(vec1, vec2);\n            vst1q_f64(dst + i * n + j, result);\n        }\n        \n        // Handle remaining single element if n is odd\n        if (j < n) {\n            dst[i * n + j] = mat1[i * n + j] * mat2[i * n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vfmaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vfmaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vfmaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vfmaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vfmaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    // Use 2 doubles per vector register\n    size_t vec_size = 2;\n    size_t vec_count = total_elements / vec_size;\n    size_t remainder = total_elements % vec_size;\n    \n    // Initialize sum vector\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process vector-sized chunks\n    for (size_t i = 0; i < vec_count * vec_size; i += vec_size) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    \n    // Horizontal sum of vector\n    float64_t lane_sum[2];\n    vst1q_f64(lane_sum, sum_vec);\n    sum = lane_sum[0] + lane_sum[1];\n    \n    // Process remaining elements\n    for (size_t i = vec_count * vec_size; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process 2 doubles at a time using Neon\n    size_t i = 0;\n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t current_vec = vld1q_f64(mat + i);\n        sum_vec = vaddq_f64(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum of vector\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Handle any remaining elements\n    for (; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    // Process 2 doubles at a time using Neon\n    size_t vec_len = total_elements - (total_elements % 2);\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vec_len; i += 2) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    \n    // Horizontal sum of vector\n    sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Process remaining elements\n    for (size_t i = vec_len; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    // Process 2 doubles at a time using Neon 128-bit registers\n    size_t vector_length = total_elements - (total_elements % 2);\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vector_length; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    \n    // Horizontal sum of vector\n    float64_t lane_sum[2];\n    vst1q_f64(lane_sum, sum_vec);\n    sum = lane_sum[0] + lane_sum[1];\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    // Use 2 doubles per vector register\n    size_t vec_size = 2;\n    size_t vec_count = total_elements / vec_size;\n    \n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process vector-sized chunks\n    for (size_t i = 0; i < vec_count * vec_size; i += vec_size) {\n        float64x2_t vec = vld1q_f64(mat + i);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    \n    // Horizontal sum of vector\n    float64_t lane_sum[2];\n    vst1q_f64(lane_sum, sum_vec);\n    sum = lane_sum[0] + lane_sum[1];\n    \n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* current_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        // Process 4 elements at a time using Neon\n        size_t vector_length = cols - (cols % 4);\n        for (size_t col = 0; col < vector_length; col += 4) {\n            int32x4_t current_vec = vld1q_s32(current_row + col);\n            int32x4_t next_vec = vld1q_s32(current_row + col + 4);\n            \n            uint32x4_t comparison;\n            if (ascending) {\n                // Check if current vector is less than or equal to next vector\n                comparison = vcleq_s32(current_vec, next_vec);\n            } else {\n                // Check if current vector is greater than or equal to next vector\n                comparison = vcgeq_s32(current_vec, next_vec);\n            }\n            \n            // If any comparison fails, return false\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = vector_length; col < cols - 1; col++) {\n            if (ascending) {\n                if (current_row[col] > current_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (current_row[col] < current_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* current_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        // Process 4 elements at a time using Neon\n        size_t vector_length = cols - (cols % 4);\n        for (size_t col = 0; col < vector_length; col += 4) {\n            int32x4_t current_vec = vld1q_s32(current_row + col);\n            int32x4_t next_vec = vld1q_s32(current_row + col + 4);\n            \n            if (ascending) {\n                // Check ascending order\n                uint32x4_t compare_result = vcgeq_s32(current_vec, next_vec);\n                if (vmaxvq_u32(compare_result) != 0) {\n                    return false;\n                }\n            } else {\n                // Check descending order\n                uint32x4_t compare_result = vcleq_s32(current_vec, next_vec);\n                if (vmaxvq_u32(compare_result) != 0) {\n                    return false;\n                }\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = vector_length; col < cols - 1; col++) {\n            if (ascending) {\n                if (current_row[col] > current_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (current_row[col] < current_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* current_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        // Process 4 elements at a time using Neon\n        size_t vector_cols = cols - (cols % 4);\n        for (size_t col = 0; col < vector_cols; col += 4) {\n            int32x4_t current_vec = vld1q_s32(current_row + col);\n            int32x4_t next_vec = vld1q_s32(current_row + col + 4);\n            \n            uint32x4_t comparison;\n            if (ascending) {\n                // Check if current vector is less than or equal to next vector\n                comparison = vcleq_s32(current_vec, next_vec);\n            } else {\n                // Check if current vector is greater than or equal to next vector\n                comparison = vcgeq_s32(current_vec, next_vec);\n            }\n            \n            // If any comparison fails, return false\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = vector_cols; col < cols - 1; col++) {\n            if (ascending) {\n                if (current_row[col] > current_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (current_row[col] < current_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* current_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        // Process 4 elements at a time using Neon\n        size_t vec_cols = cols - (cols % 4);\n        for (size_t col = 0; col < vec_cols; col += 4) {\n            int32x4_t current_vec = vld1q_s32(current_row + col);\n            int32x4_t next_vec = vld1q_s32(current_row + col + 4);\n            \n            uint32x4_t comparison;\n            if (ascending) {\n                // Check if current vector is less than or equal to next vector\n                comparison = vcleq_s32(current_vec, next_vec);\n            } else {\n                // Check if current vector is greater than or equal to next vector\n                comparison = vcgeq_s32(current_vec, next_vec);\n            }\n            \n            // If any comparison fails, return false\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = vec_cols; col < cols - 1; col++) {\n            if (ascending) {\n                if (current_row[col] > current_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (current_row[col] < current_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* current_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        // Process 4 elements at a time using Neon\n        size_t vector_length = cols - (cols % 4);\n        for (size_t col = 0; col < vector_length; col += 4) {\n            int32x4_t current_vec = vld1q_s32(current_row + col);\n            int32x4_t next_vec = vld1q_s32(current_row + col + 4);\n            \n            uint32x4_t comparison;\n            if (ascending) {\n                // Check if current vector is less than or equal to next vector\n                comparison = vcleq_s32(current_vec, next_vec);\n            } else {\n                // Check if current vector is greater than or equal to next vector\n                comparison = vcgeq_s32(current_vec, next_vec);\n            }\n            \n            // If any comparison fails, return false\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = vector_length; col < cols - 1; col++) {\n            if (ascending) {\n                if (current_row[col] > current_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (current_row[col] < current_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 source elements\n        int16x8_t src_vec = vld1q_s16(src + i);\n        \n        // Broadcast base to all lanes of a vector\n        int16x8_t base_vec = vdupq_n_s16(base);\n        \n        // Divide each source element by base and round down\n        int16x8_t div_vec = vqdivq_s16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        int16x8_t multiple_vec = vmulq_s16(div_vec, base_vec);\n        \n        // Store result in destination\n        vst1q_s16(dst + i, multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    // Broadcast base to all lanes of a vector\n    int16x8_t base_vec = vdupq_n_s16(base);\n\n    // Process 8 elements at a time\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        // Load 8 source elements\n        int16x8_t src_vec = vld1q_s16(src + i);\n\n        // Divide source by base and multiply back to get nearest multiple\n        int16x8_t div_vec = vqdivq_s16(src_vec, base_vec);\n        int16x8_t result_vec = vmulq_s16(div_vec, base_vec);\n\n        // Store result\n        vst1q_s16(dst + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 7 < length; i += 8) {\n        // Load 8 source elements\n        int16x8_t src_vec = vld1q_s16(src + i);\n        \n        // Broadcast base to all elements of a vector\n        int16x8_t base_vec = vdupq_n_s16(base);\n        \n        // Divide each source element by base and floor\n        int16x8_t div_vec = vqdivq_s16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        int16x8_t multiple_vec = vmulq_s16(div_vec, base_vec);\n        \n        // Store result in destination\n        vst1q_s16(dst + i, multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 7 < length; i += 8) {\n        // Load 8 source elements\n        int16x8_t src_vec = vld1q_s16(src + i);\n        \n        // Broadcast base to all elements of a vector\n        int16x8_t base_vec = vdupq_n_s16(base);\n        \n        // Divide each element by base and round down\n        int16x8_t div_vec = vqdivq_s16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        int16x8_t multiple_vec = vmulq_s16(div_vec, base_vec);\n        \n        // Store result in destination\n        vst1q_s16(dst + i, multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 7 < length; i += 8) {\n        // Load 8 source elements\n        int16x8_t src_vec = vld1q_s16(src + i);\n        \n        // Broadcast base to all elements of a vector\n        int16x8_t base_vec = vdupq_n_s16(base);\n        \n        // Divide source elements by base and round down\n        int16x8_t div_vec = vqdivq_s16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        int16x8_t multiple_vec = vmulq_s16(div_vec, base_vec);\n        \n        // Store result in destination\n        vst1q_s16(dst + i, multiple_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single Neon vector\n    const int vector_width = 2;\n\n    for (size_t r = 0; r < rows; r++) {\n        // Load vector into Neon register\n        float64x2_t vec_target = vld1q_f64(vector);\n\n        // Assume row match until proven otherwise\n        bool row_match = true;\n\n        // Process 2 doubles at a time using Neon\n        for (size_t c = 0; c < cols; c += vector_width) {\n            // Load matrix row segment\n            float64x2_t vec_matrix = vld1q_f64(matrix + r * cols + c);\n\n            // Compare matrix row segment with target vector\n            uint64x2_t comparison = vceqq_f64(vec_matrix, vec_target);\n\n            // Check if all elements match\n            if (!(vgetq_lane_u64(comparison, 0) && vgetq_lane_u64(comparison, 1))) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // Handle any remaining columns not divisible by vector width\n        if (row_match && cols % vector_width != 0) {\n            for (size_t c = cols - (cols % vector_width); c < cols; c++) {\n                if (matrix[r * cols + c] != vector[c]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        // If row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single Neon vector\n    const int NEON_VECTOR_WIDTH = 2;\n\n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        // Process vectors in pairs\n        size_t vec_cols = cols - (cols % NEON_VECTOR_WIDTH);\n        for (size_t c = 0; c < vec_cols; c += NEON_VECTOR_WIDTH) {\n            float64x2_t matrix_vec = vld1q_f64(&matrix[r * cols + c]);\n            float64x2_t input_vec = vld1q_f64(&vector[c]);\n            \n            // Compare vectors\n            uint64x2_t comparison = vceqq_f64(matrix_vec, input_vec);\n            \n            // Check if all elements match\n            if (!(vgetq_lane_u64(comparison, 0) && vgetq_lane_u64(comparison, 1))) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements if cols is not divisible by NEON_VECTOR_WIDTH\n        if (row_match && vec_cols < cols) {\n            for (size_t c = vec_cols; c < cols; c++) {\n                if (matrix[r * cols + c] != vector[c]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        // If entire row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single Neon vector\n    const size_t vector_width = 2;\n\n    for (size_t row = 0; row < rows; row++) {\n        bool row_match = true;\n        \n        // Process vector elements in pairs using Neon\n        size_t i;\n        for (i = 0; i + vector_width <= cols; i += vector_width) {\n            float64x2_t matrix_vec = vld1q_f64(matrix + row * cols + i);\n            float64x2_t vector_vec = vld1q_f64(vector + i);\n            \n            // Compare matrix row vector with input vector\n            uint64x2_t comparison = vceqq_f64(matrix_vec, vector_vec);\n            \n            // Check if all elements match\n            if (vgetq_lane_u64(comparison, 0) == 0 || vgetq_lane_u64(comparison, 1) == 0) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements if cols is not divisible by vector_width\n        if (row_match && i < cols) {\n            for (; i < cols; i++) {\n                if (matrix[row * cols + i] != vector[i]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n\n        // If entire row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single Neon vector\n    const size_t vector_width = 2; \n\n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        // Process vector elements in pairs using Neon\n        size_t c = 0;\n        for (; c + vector_width <= cols; c += vector_width) {\n            float64x2_t matrix_vec = vld1q_f64(&matrix[r * cols + c]);\n            float64x2_t vec_vec = vld1q_f64(&vector[c]);\n            \n            // Compare matrix row vector with input vector\n            uint64x2_t comparison = vceqq_f64(matrix_vec, vec_vec);\n            \n            // Check if all elements match\n            if (!(vgetq_lane_u64(comparison, 0) && vgetq_lane_u64(comparison, 1))) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements if cols is not divisible by vector_width\n        for (; c < cols; c++) {\n            if (matrix[r * cols + c] != vector[c]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // If entire row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single Neon vector\n    const int vector_width = 2;\n    \n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        // Process vectors in parallel\n        for (size_t c = 0; c + vector_width <= cols; c += vector_width) {\n            float64x2_t matrix_vec = vld1q_f64(matrix + r * cols + c);\n            float64x2_t vector_vec = vld1q_f64(vector + c);\n            \n            // Compare vectors\n            uint64x2_t comparison = vceqq_f64(matrix_vec, vector_vec);\n            \n            // Check if all elements match\n            if (!(vgetq_lane_u64(comparison, 0) && vgetq_lane_u64(comparison, 1))) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = cols - (cols % vector_width); c < cols; c++) {\n            if (matrix[r * cols + c] != vector[c]) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    size_t vector_size = 16;\n    size_t i = 0;\n    \n    for (; i + vector_size <= total_elements; i += vector_size) {\n        uint8x16_t vec_a = vld1q_u8(A + i);\n        uint8x16_t vec_b = vld1q_u8(B + i);\n        \n        // Compare vectors for equality\n        uint8x16_t equal_mask = vceqq_u8(vec_a, vec_b);\n        \n        // Count the number of equal elements in the vector\n        uint8x16_t count_mask = vcntq_u8(equal_mask);\n        uint64x2_t count_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(count_mask)));\n        \n        equal_count += vgetq_lane_u64(count_vec, 0) + vgetq_lane_u64(count_vec, 1);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    size_t vector_size = 16;\n    size_t i = 0;\n    \n    for (; i + vector_size <= total_elements; i += vector_size) {\n        uint8x16_t vec_a = vld1q_u8(A + i);\n        uint8x16_t vec_b = vld1q_u8(B + i);\n        \n        // Compare vectors for equality\n        uint8x16_t equal_mask = vceqq_u8(vec_a, vec_b);\n        \n        // Count the number of equal elements in the vector\n        uint8x16_t count_vec = vcntq_u8(equal_mask);\n        uint64x2_t count_wide = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(count_vec)));\n        \n        equal_count += vgetq_lane_u64(count_wide, 0) + vgetq_lane_u64(count_wide, 1);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    size_t vec_size = 16;\n    size_t vec_count = total_elements / vec_size;\n    size_t remainder = total_elements % vec_size;\n    \n    for (size_t i = 0; i < vec_count; ++i) {\n        uint8x16_t vec_a = vld1q_u8(A + i * vec_size);\n        uint8x16_t vec_b = vld1q_u8(B + i * vec_size);\n        \n        // Compare vectors for equality\n        uint8x16_t equal_mask = vceqq_u8(vec_a, vec_b);\n        \n        // Count equal elements\n        uint8x16_t count_vec = vcntq_u8(equal_mask);\n        uint64x2_t count_wide = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(count_vec)));\n        \n        equal_count += vgetq_lane_u64(count_wide, 0) + vgetq_lane_u64(count_wide, 1);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    size_t vector_size = 16;\n    size_t i = 0;\n    \n    for (; i + vector_size <= total_elements; i += vector_size) {\n        uint8x16_t vec_a = vld1q_u8(A + i);\n        uint8x16_t vec_b = vld1q_u8(B + i);\n        \n        // Compare vectors for equality\n        uint8x16_t equal_mask = vceqq_u8(vec_a, vec_b);\n        \n        // Count the number of equal elements\n        uint8x16_t count_mask = vcntq_u8(equal_mask);\n        uint64x2_t count_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(count_mask)));\n        \n        equal_count += vgetq_lane_u64(count_vec, 0) + vgetq_lane_u64(count_vec, 1);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    size_t vec_size = 16;\n    size_t vec_count = total_elements / vec_size;\n    size_t remainder = total_elements % vec_size;\n    \n    for (size_t i = 0; i < vec_count; ++i) {\n        uint8x16_t vec_a = vld1q_u8(A + i * vec_size);\n        uint8x16_t vec_b = vld1q_u8(B + i * vec_size);\n        \n        // Compare vectors for equality\n        uint8x16_t equal_mask = vceqq_u8(vec_a, vec_b);\n        \n        // Count equal elements in the vector\n        uint8x16_t count_vec = vcntq_u8(equal_mask);\n        uint64x2_t count_wide = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(count_vec)));\n        \n        equal_count += vgetq_lane_u64(count_wide, 0) + vgetq_lane_u64(count_wide, 1);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from x vector\n        int64x2_t x_vec = vld1q_s64(x + i);\n        \n        // Multiply scalar a with vector x\n        int64x2_t ax_vec = vmulq_n_s64(x_vec, a);\n        \n        // Compute absolute value\n        int64x2_t abs_vec = vabsq_s64(ax_vec);\n        \n        // Store result to y vector\n        vst1q_s64(y + i, abs_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from x vector\n        int64x2_t x_vec = vld1q_s64(x + i);\n        \n        // Multiply each element by scalar a\n        int64x2_t ax_vec = vmulq_n_s64(x_vec, a);\n        \n        // Compute absolute value\n        int64x2_t abs_vec = vabsq_s64(ax_vec);\n        \n        // Store result to y vector\n        vst1q_s64(y + i, abs_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from x vector\n        int64x2_t x_vec = vld1q_s64(x + i);\n        \n        // Multiply scalar a with vector x\n        int64x2_t ax_vec = vmulq_n_s64(x_vec, a);\n        \n        // Compute absolute value\n        int64x2_t abs_vec = vabsq_s64(ax_vec);\n        \n        // Store results to y vector\n        vst1q_s64(y + i, abs_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from x vector\n        int64x2_t x_vec = vld1q_s64(x + i);\n        \n        // Multiply each element by scalar a\n        int64x2_t ax_vec = vmulq_n_s64(x_vec, a);\n        \n        // Compute absolute value\n        int64x2_t abs_vec = vabsq_s64(ax_vec);\n        \n        // Store result to y vector\n        vst1q_s64(y + i, abs_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 elements from x vector\n        int64x2_t x_vec = vld1q_s64(x + i);\n        \n        // Multiply scalar a with vector x\n        int64x2_t ax_vec = vmulq_n_s64(x_vec, a);\n        \n        // Compute absolute value\n        int64x2_t abs_vec = vabsq_s64(ax_vec);\n        \n        // Store result to y vector\n        vst1q_s64(y + i, abs_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using Neon\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        int16x8_t current_vec = vld1q_s16(vec + i);\n        \n        // Find min and max within the current vector\n        int16x8_t min_vec = current_vec;\n        int16x8_t max_vec = current_vec;\n        \n        // Pairwise min and max\n        min_vec = vminq_s16(min_vec, vrev64q_s16(min_vec));\n        max_vec = vmaxq_s16(max_vec, vrev64q_s16(max_vec));\n        \n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 2));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 2));\n        \n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 1));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 1));\n        \n        // Extract min and max values\n        int16_t current_min = vgetq_lane_s16(min_vec, 0);\n        int16_t current_max = vgetq_lane_s16(max_vec, 0);\n        \n        result.min_num = (current_min < result.min_num) ? current_min : result.min_num;\n        result.max_num = (current_max > result.max_num) ? current_max : result.max_num;\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using Neon\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        int16x8_t current_vec = vld1q_s16(vec + i);\n        \n        // Find min and max within the vector\n        int16x8_t min_vec = current_vec;\n        int16x8_t max_vec = current_vec;\n        \n        // Pairwise min and max\n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 4));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 4));\n        \n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 2));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 2));\n        \n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 1));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 1));\n        \n        // Update global min and max\n        result.min_num = vminvq_s16(result.min_num, vminq_s16(vdupq_n_s16(result.min_num), min_vec));\n        result.max_num = vmaxvq_s16(result.max_num, vmaxq_s16(vdupq_n_s16(result.max_num), max_vec));\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using Neon\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        int16x8_t current_vec = vld1q_s16(vec + i);\n        \n        // Find min and max within the current vector\n        int16x8_t min_vec = current_vec;\n        int16x8_t max_vec = current_vec;\n        \n        min_vec = vminq_s16(min_vec, vextq_s16(current_vec, current_vec, 4));\n        min_vec = vminq_s16(min_vec, vextq_s16(current_vec, current_vec, 2));\n        min_vec = vminq_s16(min_vec, vextq_s16(current_vec, current_vec, 1));\n        \n        max_vec = vmaxq_s16(max_vec, vextq_s16(current_vec, current_vec, 4));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(current_vec, current_vec, 2));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(current_vec, current_vec, 1));\n        \n        // Reduce to scalar min and max\n        int16_t current_min = vminvq_s16(min_vec);\n        int16_t current_max = vmaxvq_s16(max_vec);\n        \n        result.min_num = (current_min < result.min_num) ? current_min : result.min_num;\n        result.max_num = (current_max > result.max_num) ? current_max : result.max_num;\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using Neon\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        int16x8_t current_vec = vld1q_s16(vec + i);\n        \n        // Find min and max within the current vector\n        int16x8_t min_vec = current_vec;\n        int16x8_t max_vec = current_vec;\n        \n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 4));\n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 2));\n        min_vec = vminq_s16(min_vec, vextq_s16(min_vec, min_vec, 1));\n        \n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 4));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 2));\n        max_vec = vmaxq_s16(max_vec, vextq_s16(max_vec, max_vec, 1));\n        \n        // Update global min and max\n        result.min_num = vminvq_s16(min_vec);\n        result.max_num = vmaxvq_s16(max_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process vectors in groups of 8 elements\n    size_t vector_length = length - (length % 8);\n    \n    // Initialize NEON vectors with initial min and max values\n    int16x8_t min_vec = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_vec = vdupq_n_s16(INT16_MIN);\n    \n    // Process 8 elements at a time\n    for (size_t i = 0; i < vector_length; i += 8) {\n        int16x8_t current_vec = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, current_vec);\n        max_vec = vmaxq_s16(max_vec, current_vec);\n    }\n    \n    // Reduce NEON vectors to find overall min and max\n    int16_t min_array[8], max_array[8];\n    vst1q_s16(min_array, min_vec);\n    vst1q_s16(max_array, max_vec);\n    \n    for (int j = 0; j < 8; j++) {\n        result.min_num = (min_array[j] < result.min_num) ? min_array[j] : result.min_num;\n        result.max_num = (max_array[j] > result.max_num) ? max_array[j] : result.max_num;\n    }\n    \n    // Process remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using Neon\n        size_t i = 0;\n        for (; i + 4 <= cols; i += 4) {\n            int32x4_t current = vld1q_s32(row + i);\n            int32x4_t next = vld1q_s32(row + i + 1);\n            \n            // Check if each element is strictly less than the next\n            uint32x4_t comparison = vcltq_s32(current, next);\n            \n            // If any comparison fails, return false\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (; i < cols - 1; i++) {\n            if (row[i] >= row[i + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using Neon\n        size_t vec_cols = cols - (cols % 4);\n        for (size_t c = 0; c < vec_cols; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 4);\n            \n            // Compare each element with its next element\n            uint32x4_t comparison = vcgtq_s32(current, vextq_s32(current, next, 3));\n            \n            // If any element is not strictly greater than previous, return false\n            if (vaddvq_u32(comparison) != 0) return false;\n        }\n        \n        // Handle remaining elements\n        for (size_t c = vec_cols; c < cols - 1; c++) {\n            if (row[c] >= row[c + 1]) return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using Neon\n        size_t i = 0;\n        for (; i + 4 <= cols - 1; i += 4) {\n            int32x4_t current = vld1q_s32(row + i);\n            int32x4_t next = vld1q_s32(row + i + 1);\n            \n            // Check if each element is strictly less than the next\n            uint32x4_t comparison = vcltq_s32(current, next);\n            \n            // If any comparison fails, return false\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (; i < cols - 1; i++) {\n            if (row[i] >= row[i + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using Neon\n        size_t vec_cols = cols - (cols % 4);\n        for (size_t c = 0; c < vec_cols; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 4);\n            \n            // Compare if each element is less than the next\n            uint32x4_t comparison = vcltq_s32(current, next);\n            \n            // Check if all comparisons are true\n            if (vminvq_u32(comparison) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = vec_cols; c < cols - 1; c++) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using Neon\n        size_t vec_cols = cols - (cols % 4);\n        for (size_t c = 0; c < vec_cols; c += 4) {\n            int32x4_t current = vld1q_s32(row + c);\n            int32x4_t next = vld1q_s32(row + c + 4);\n            \n            // Compare each element with its next element\n            uint32x4_t comparison = vcgtq_s32(current, next);\n            \n            // If any element is greater or equal to its next element, return false\n            if (vmaxvq_u32(comparison) > 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = vec_cols; c < cols - 1; c++) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Process 4 elements at a time using Neon\n    for (size_t block_r = 0; block_r < block_rows; ++block_r) {\n        for (size_t block_c = 0; block_c < block_cols; ++block_c) {\n            if (block_r == 0 && block_c == 0) continue; // Skip first block\n\n            const int* current_block = matrix + (block_r * block_cols + block_c) * block_size * block_size;\n\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; c += 4) {\n                    // Load 4 elements from first block and current block\n                    int32x4_t first_vec = vld1q_s32(first_block + (r * block_size + c));\n                    int32x4_t current_vec = vld1q_s32(current_block + (r * block_size + c));\n\n                    // Compare vectors\n                    uint32x4_t compare_result = vceqq_s32(first_vec, current_vec);\n\n                    // Check if all elements are equal\n                    if (vminvq_u32(compare_result) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for invalid block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Process blocks using NEON\n    for (size_t block_r = 1; block_r < block_rows; ++block_r) {\n        for (size_t block_c = 0; block_c < block_cols; ++block_c) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_r * block_cols + block_c) * block_size * block_size;\n\n            // Compare blocks using NEON 128-bit vector comparisons\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    // Load 4 integers from first block and current block\n                    int32x4_t first_vec = vld1q_s32(first_block + i * block_size + j);\n                    int32x4_t current_vec = vld1q_s32(current_block + i * block_size + j);\n\n                    // Compare vectors\n                    uint32x4_t compare_result = vceqq_s32(first_vec, current_vec);\n\n                    // Check if all elements are equal\n                    if (vminvq_u32(compare_result) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 0; block_row < block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < block_cols; ++block_col) {\n            // Skip first block\n            if (block_row == 0 && block_col == 0) continue;\n\n            // Current block start\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Compare blocks using Neon SIMD\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    // Load 4 integers from first block and current block\n                    int32x4_t first_vec = vld1q_s32(first_block + i * block_size + j);\n                    int32x4_t current_vec = vld1q_s32(current_block + i * block_size + j);\n\n                    // Compare vectors\n                    uint32x4_t compare_result = vceqq_s32(first_vec, current_vec);\n\n                    // Check if all elements are equal\n                    if (vminvq_u32(compare_result) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for invalid block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Reference block (first block)\n    const int* ref_block = matrix;\n\n    // Process blocks using NEON\n    for (size_t block_row = 1; block_row < block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Compare blocks using NEON 128-bit vector comparisons\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    // Load 4 integers from reference block and current block\n                    float32x4_t ref_vec = vld1q_f32((const float32_t*)(ref_block + i * block_size + j));\n                    float32x4_t curr_vec = vld1q_f32((const float32_t*)(current_block + i * block_size + j));\n\n                    // Compare vectors\n                    uint32x4_t compare_result = vceqq_f32(ref_vec, curr_vec);\n\n                    // Check if all elements are equal\n                    if (vminvq_u32(compare_result) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 1; block_row < block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Compare blocks using NEON SIMD\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    // Load 4 integers from first block and current block\n                    float32x4_t first_vec = vld1q_f32((const float32_t*)(first_block + i * block_size + j));\n                    float32x4_t current_vec = vld1q_f32((const float32_t*)(current_block + i * block_size + j));\n\n                    // Compare vectors\n                    uint32x4_t compare_result = vceqq_f32(first_vec, current_vec);\n\n                    // Check if all elements are equal\n                    if (vminvq_u32(compare_result) == 0) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into SIMD registers\n    float64x2_t first_block_low = vld1q_f64(vec);\n    float64x2_t first_block_high = vld1q_f64(vec + 2);\n    float64x2_t tolerance_vec_low = vdupq_n_f64(tolerance);\n    float64x2_t tolerance_vec_high = vdupq_n_f64(tolerance);\n\n    // Compare subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block = vec + block * block_size;\n\n        // Load current block\n        float64x2_t current_block_low = vld1q_f64(current_block);\n        float64x2_t current_block_high = vld1q_f64(current_block + 2);\n\n        // Compare low part\n        float64x2_t diff_low = vabdq_f64(first_block_low, current_block_low);\n        uint64x2_t compare_low = vcleq_f64(diff_low, tolerance_vec_low);\n\n        // Compare high part\n        float64x2_t diff_high = vabdq_f64(first_block_high, current_block_high);\n        uint64x2_t compare_high = vcleq_f64(diff_high, tolerance_vec_high);\n\n        // Check if all elements are within tolerance\n        if (!(vminvq_u64(compare_low) && vminvq_u64(compare_high))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block as reference\n    float64x2_t ref_block0 = vld1q_f64(vec);\n    float64x2_t ref_block1 = vld1q_f64(vec + 2);\n    \n    // Broadcast tolerance to vector\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n\n    // Iterate through blocks starting from second block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block = vec + block * block_size;\n        \n        // Load current block\n        float64x2_t curr_block0 = vld1q_f64(current_block);\n        float64x2_t curr_block1 = vld1q_f64(current_block + 2);\n        \n        // Compare first two elements of block\n        float64x2_t diff0 = vabdq_f64(ref_block0, curr_block0);\n        float64x2_t diff1 = vabdq_f64(ref_block1, curr_block1);\n        \n        // Check if differences are within tolerance\n        uint64x2_t mask0 = vcleq_f64(diff0, tol_vec);\n        uint64x2_t mask1 = vcleq_f64(diff1, tol_vec);\n        \n        // If any element exceeds tolerance, return false\n        if (!vminvq_u64(mask0) || !vminvq_u64(mask1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into NEON registers\n    float64x2_t first_block_low = vld1q_f64(vec);\n    float64x2_t first_block_high = vld1q_f64(vec + 2);\n    float64x2_t tolerance_vec_low = vdupq_n_f64(tolerance);\n    float64x2_t tolerance_vec_high = vdupq_n_f64(tolerance);\n\n    // Compare subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block = vec + block * block_size;\n\n        // Load current block\n        float64x2_t current_block_low = vld1q_f64(current_block);\n        float64x2_t current_block_high = vld1q_f64(current_block + 2);\n\n        // Compute absolute differences\n        float64x2_t diff_low = vabdq_f64(first_block_low, current_block_low);\n        float64x2_t diff_high = vabdq_f64(first_block_high, current_block_high);\n\n        // Check if differences are within tolerance\n        uint64x2_t mask_low = vcleq_f64(diff_low, tolerance_vec_low);\n        uint64x2_t mask_high = vcleq_f64(diff_high, tolerance_vec_high);\n\n        // If any element exceeds tolerance, return false\n        if (!(vgetq_lane_u64(mask_low, 0) && vgetq_lane_u64(mask_low, 1) &&\n              vgetq_lane_u64(mask_high, 0) && vgetq_lane_u64(mask_high, 1))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into NEON registers\n    float64x2_t first_block_low = vld1q_f64(vec);\n    float64x2_t first_block_high = vld1q_f64(vec + 2);\n    float64x2_t tolerance_vec_low = vdupq_n_f64(tolerance);\n    float64x2_t tolerance_vec_high = vdupq_n_f64(tolerance);\n\n    // Compare each subsequent block with first block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block = vec + block * block_size;\n\n        // Load current block\n        float64x2_t current_block_low = vld1q_f64(current_block);\n        float64x2_t current_block_high = vld1q_f64(current_block + 2);\n\n        // Compute absolute differences\n        float64x2_t diff_low = vabdq_f64(first_block_low, current_block_low);\n        float64x2_t diff_high = vabdq_f64(first_block_high, current_block_high);\n\n        // Check if differences are within tolerance\n        uint64x2_t mask_low = vcleq_f64(diff_low, tolerance_vec_low);\n        uint64x2_t mask_high = vcleq_f64(diff_high, tolerance_vec_high);\n\n        // If any element exceeds tolerance, return false\n        if (!(vgetq_lane_u64(mask_low, 0) && vgetq_lane_u64(mask_low, 1) &&\n              vgetq_lane_u64(mask_high, 0) && vgetq_lane_u64(mask_high, 1))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into NEON registers\n    float64x2_t first_block_low = vld1q_f64(vec);\n    float64x2_t first_block_high = vld1q_f64(vec + 2);\n    float64x2_t tolerance_vec_low = vdupq_n_f64(tolerance);\n    float64x2_t tolerance_vec_high = vdupq_n_f64(tolerance);\n\n    // Compare subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block = vec + block * block_size;\n\n        // Load current block\n        float64x2_t current_block_low = vld1q_f64(current_block);\n        float64x2_t current_block_high = vld1q_f64(current_block + 2);\n\n        // Compare low part\n        float64x2_t diff_low = vabdq_f64(first_block_low, current_block_low);\n        uint64x2_t compare_low = vcleq_f64(diff_low, tolerance_vec_low);\n        if (vgetq_lane_u64(compare_low, 0) == 0 || vgetq_lane_u64(compare_low, 1) == 0) {\n            return false;\n        }\n\n        // Compare high part\n        float64x2_t diff_high = vabdq_f64(first_block_high, current_block_high);\n        uint64x2_t compare_high = vcleq_f64(diff_high, tolerance_vec_high);\n        if (vgetq_lane_u64(compare_high, 0) == 0 || vgetq_lane_u64(compare_high, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        \n        // Process 2 elements at a time using SIMD\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared_vec = vmulq_f64(row_vec, row_vec);\n            sum_vec = vaddq_f64(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of vector\n        float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        \n        // Handle remaining elements if cols is odd\n        for (; j < cols; j++) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        \n        // Process 2 elements at a time\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared_vec = vmulq_f64(row_vec, row_vec);\n            sum_vec = vaddq_f64(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of vector\n        float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        \n        // Handle remaining elements if cols is odd\n        for (; j < cols; j++) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        \n        // Process 2 elements at a time using SIMD\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared_vec = vmulq_f64(row_vec, row_vec);\n            sum_vec = vaddq_f64(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of vector\n        float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        \n        // Handle remaining elements if cols is odd\n        for (; j < cols; j++) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        \n        // Process 2 elements at a time using SIMD\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared_vec = vmulq_f64(row_vec, row_vec);\n            sum_vec = vaddq_f64(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        \n        // Handle remaining elements if cols is odd\n        for (; j < cols; j++) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        \n        // Process 2 elements at a time using SIMD\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared_vec = vmulq_f64(row_vec, row_vec);\n            sum_vec = vaddq_f64(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n        \n        // Handle remaining elements if cols is odd\n        for (; j < cols; j++) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit registers\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B into Neon registers\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t b_vec = vld1q_u32(B + i);\n        \n        // Perform bitwise OR operation\n        uint32x4_t result_vec = vorrq_u32(a_vec, b_vec);\n        \n        // Store the result back to C\n        vst1q_u32(C + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit registers\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B\n        uint32x4_t va = vld1q_u32(A + i);\n        uint32x4_t vb = vld1q_u32(B + i);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vc = vorrq_u32(va, vb);\n        \n        // Store result in C\n        vst1q_u32(C + i, vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit registers\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B\n        uint32x4_t va = vld1q_u32(A + i);\n        uint32x4_t vb = vld1q_u32(B + i);\n        \n        // Perform bitwise OR\n        uint32x4_t vc = vorrq_u32(va, vb);\n        \n        // Store result in C\n        vst1q_u32(C + i, vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using 128-bit Neon registers\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B\n        uint32x4_t va = vld1q_u32(A + i);\n        uint32x4_t vb = vld1q_u32(B + i);\n        \n        // Perform bitwise OR operation\n        uint32x4_t vc = vorrq_u32(va, vb);\n        \n        // Store result in C\n        vst1q_u32(C + i, vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using 128-bit Neon registers\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 elements from A and B\n        uint32x4_t va = vld1q_u32(A + i);\n        uint32x4_t vb = vld1q_u32(B + i);\n        \n        // Perform bitwise OR\n        uint32x4_t vc = vorrq_u32(va, vb);\n        \n        // Store result in C\n        vst1q_u32(C + i, vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t vector_length = length - (length % 16);\n    \n    int8x16_t a_vec, b_vec;\n    int16x8_t squares_low, squares_high;\n    int16x8_t products_low, products_high;\n    \n    for (size_t i = 0; i < vector_length; i += 16) {\n        a_vec = vld1q_s8(A + i);\n        b_vec = vld1q_s8(B + i);\n        \n        squares_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(a_vec));\n        squares_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(a_vec));\n        \n        products_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(b_vec));\n        products_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(b_vec));\n        \n        sum_squares += vaddvq_s16(squares_low) + vaddvq_s16(squares_high);\n        sum_products += vaddvq_s16(products_low) + vaddvq_s16(products_high);\n    }\n    \n    for (size_t i = vector_length; i < length; i++) {\n        sum_squares += A[i] * A[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t vector_length = length - (length % 16);\n    \n    int8x16_t a_vec, b_vec;\n    int16x8_t squares_low, squares_high;\n    int16x8_t products_low, products_high;\n    \n    for (size_t i = 0; i < vector_length; i += 16) {\n        a_vec = vld1q_s8(A + i);\n        b_vec = vld1q_s8(B + i);\n        \n        squares_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(a_vec));\n        squares_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(a_vec));\n        \n        products_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(b_vec));\n        products_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(b_vec));\n        \n        sum_squares += vaddlv_s16(vget_low_s16(squares_low)) + \n                       vaddlv_s16(vget_high_s16(squares_low)) + \n                       vaddlv_s16(vget_low_s16(squares_high)) + \n                       vaddlv_s16(vget_high_s16(squares_high));\n        \n        sum_products += vaddlv_s16(vget_low_s16(products_low)) + \n                        vaddlv_s16(vget_high_s16(products_low)) + \n                        vaddlv_s16(vget_low_s16(products_high)) + \n                        vaddlv_s16(vget_high_s16(products_high));\n    }\n    \n    for (size_t i = vector_length; i < length; ++i) {\n        sum_squares += A[i] * A[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    // Process 16 elements at a time using Neon\n    size_t vector_length = length - (length % 16);\n    \n    int8x16_t a_vec, b_vec;\n    int16x8_t squares_low, squares_high;\n    int16x8_t products_low, products_high;\n    int32x4_t sum_squares_vec = vdupq_n_s32(0);\n    int32x4_t sum_products_vec = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vector_length; i += 16) {\n        // Load 16 elements from A and B\n        a_vec = vld1q_s8(A + i);\n        b_vec = vld1q_s8(B + i);\n        \n        // Square elements\n        squares_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(a_vec));\n        squares_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(a_vec));\n        sum_squares_vec = vpadalq_s16(sum_squares_vec, squares_low);\n        sum_squares_vec = vpadalq_s16(sum_squares_vec, squares_high);\n        \n        // Multiply elements\n        products_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(b_vec));\n        products_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(b_vec));\n        sum_products_vec = vpadalq_s16(sum_products_vec, products_low);\n        sum_products_vec = vpadalq_s16(sum_products_vec, products_high);\n    }\n    \n    // Horizontal sum of squares and products\n    int64_t squares_sum = vaddvq_s32(sum_squares_vec);\n    int64_t products_sum = vaddvq_s32(sum_products_vec);\n    \n    // Process remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        squares_sum += A[i] * A[i];\n        products_sum += A[i] * B[i];\n    }\n    \n    return squares_sum - 2 * products_sum;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t vector_length = length - (length % 16);\n    \n    int8x16_t a_vec, b_vec;\n    int16x8_t squares_low, squares_high;\n    int16x8_t products_low, products_high;\n    \n    for (size_t i = 0; i < vector_length; i += 16) {\n        a_vec = vld1q_s8(A + i);\n        b_vec = vld1q_s8(B + i);\n        \n        squares_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(a_vec));\n        squares_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(a_vec));\n        \n        products_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(b_vec));\n        products_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(b_vec));\n        \n        sum_squares += vaddlv_s16(vget_low_s16(squares_low)) + \n                       vaddlv_s16(vget_high_s16(squares_low)) + \n                       vaddlv_s16(vget_low_s16(squares_high)) + \n                       vaddlv_s16(vget_high_s16(squares_high));\n        \n        sum_products += vaddlv_s16(vget_low_s16(products_low)) + \n                        vaddlv_s16(vget_high_s16(products_low)) + \n                        vaddlv_s16(vget_low_s16(products_high)) + \n                        vaddlv_s16(vget_high_s16(products_high));\n    }\n    \n    for (size_t i = vector_length; i < length; i++) {\n        sum_squares += A[i] * A[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    // Process 16 elements at a time using Neon\n    size_t vector_length = length - (length % 16);\n    \n    int8x16_t a_vec, b_vec;\n    int16x8_t squares_low, squares_high;\n    int16x8_t products_low, products_high;\n    int32x4_t sum_squares_vec = vdupq_n_s32(0);\n    int32x4_t sum_products_vec = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vector_length; i += 16) {\n        a_vec = vld1q_s8(A + i);\n        b_vec = vld1q_s8(B + i);\n        \n        // Square calculation\n        squares_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(a_vec));\n        squares_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(a_vec));\n        sum_squares_vec = vaddq_s32(sum_squares_vec, vpaddlq_s16(squares_low));\n        sum_squares_vec = vaddq_s32(sum_squares_vec, vpaddlq_s16(squares_high));\n        \n        // Product calculation\n        products_low = vmull_s8(vget_low_s8(a_vec), vget_low_s8(b_vec));\n        products_high = vmull_s8(vget_high_s8(a_vec), vget_high_s8(b_vec));\n        sum_products_vec = vaddq_s32(sum_products_vec, vpaddlq_s16(products_low));\n        sum_products_vec = vaddq_s32(sum_products_vec, vpaddlq_s16(products_high));\n    }\n    \n    // Horizontal sum for squares\n    int64x2_t sum_squares_64 = vpaddlq_s32(sum_squares_vec);\n    sum_squares = vgetq_lane_s64(sum_squares_64, 0) + vgetq_lane_s64(sum_squares_64, 1);\n    \n    // Horizontal sum for products\n    int64x2_t sum_products_64 = vpaddlq_s32(sum_products_vec);\n    sum_products = vgetq_lane_s64(sum_products_64, 0) + vgetq_lane_s64(sum_products_64, 1);\n    \n    // Process remaining elements\n    for (size_t i = vector_length; i < length; ++i) {\n        sum_squares += A[i] * A[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t va = vld1q_u64(A + i);\n        uint64x2_t vb = vld1q_u64(B + i);\n        \n        // Bitwise NOT of B followed by bitwise AND with A\n        uint64x2_t result = vandq_u64(va, vmvnq_u64(vb));\n        \n        vst1q_u64(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t va = vld1q_u64(A + i);\n        uint64x2_t vb = vld1q_u64(B + i);\n        \n        // Bitwise NOT of B and bitwise AND with A\n        uint64x2_t vc = vandq_u64(va, vmvnq_u64(vb));\n        \n        vst1q_u64(C + i, vc);\n    }\n    \n    // Handle any remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 uint64_t elements from A and B\n        uint64x2_t va = vld1q_u64(A + i);\n        uint64x2_t vb = vld1q_u64(B + i);\n        \n        // Bitwise NOT of B\n        uint64x2_t vb_not = vmvnq_u64(vb);\n        \n        // Bitwise AND between A and NOT(B)\n        uint64x2_t vc = vandq_u64(va, vb_not);\n        \n        // Store result in C\n        vst1q_u64(C + i, vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t va = vld1q_u64(A + i);\n        uint64x2_t vb = vld1q_u64(B + i);\n        \n        // Bitwise NOT of B followed by bitwise AND with A\n        uint64x2_t result = vandq_u64(va, vmvnq_u64(vb));\n        \n        vst1q_u64(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using 128-bit Neon registers\n    for (; i + 1 < length; i += 2) {\n        // Load 2 uint64_t elements from A and B\n        uint64x2_t va = vld1q_u64(A + i);\n        uint64x2_t vb = vld1q_u64(B + i);\n        \n        // Bitwise NOT of B\n        uint64x2_t vb_not = vmvnq_u64(vb);\n        \n        // Bitwise AND between A and NOT(B)\n        uint64x2_t vc = vandq_u64(va, vb_not);\n        \n        // Store result in C\n        vst1q_u64(C + i, vc);\n    }\n    \n    // Handle remaining elements if length is odd\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n        \n        // Create masks for positive and negative elements\n        uint8x16_t positive_a = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t positive_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t negative_a = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t negative_b = vcltq_s8(vb, vdupq_n_s8(0));\n        \n        // Compute result vector\n        int8x16_t result = vdupq_n_s8(0);\n        \n        // Set to 1 where both are positive\n        result = vbslq_s8(vandq_u8(positive_a, positive_b), vdupq_n_s8(1), result);\n        \n        // Set to -1 where both are negative\n        result = vbslq_s8(vandq_u8(negative_a, negative_b), vdupq_n_s8(-1), result);\n        \n        // Store result\n        vst1q_s8(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n        \n        // Create masks for positive and negative values\n        uint8x16_t positive_a = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t positive_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t negative_a = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t negative_b = vcltq_s8(vb, vdupq_n_s8(0));\n        \n        // Compute result based on conditions\n        uint8x16_t both_positive = vandq_u8(positive_a, positive_b);\n        uint8x16_t both_negative = vandq_u8(negative_a, negative_b);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_positive, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_negative, vdupq_n_s8(-1), result);\n        \n        // Store result\n        vst1q_s8(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n        \n        // Create masks for positive and negative elements\n        uint8x16_t positive_a = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t positive_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t negative_a = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t negative_b = vcltq_s8(vb, vdupq_n_s8(0));\n        \n        // Compute result based on conditions\n        uint8x16_t both_positive = vandq_u8(positive_a, positive_b);\n        uint8x16_t both_negative = vandq_u8(negative_a, negative_b);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_positive, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_negative, vdupq_n_s8(-1), result);\n        \n        // Store result\n        vst1q_s8(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n        \n        // Create masks for positive and negative elements\n        uint8x16_t positive_a = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t positive_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t negative_a = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t negative_b = vcltq_s8(vb, vdupq_n_s8(0));\n        \n        // Compute result based on conditions\n        uint8x16_t both_positive = vandq_u8(positive_a, positive_b);\n        uint8x16_t both_negative = vandq_u8(negative_a, negative_b);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_positive, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_negative, vdupq_n_s8(-1), result);\n        \n        // Store the result\n        vst1q_s8(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 16 elements at a time using Neon 128-bit vectors\n    for (; i + 15 < length; i += 16) {\n        // Load 16 elements from A and B\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n        \n        // Create masks for positive and negative values\n        uint8x16_t positive_a = vcgtq_s8(va, vdupq_n_s8(0));\n        uint8x16_t positive_b = vcgtq_s8(vb, vdupq_n_s8(0));\n        uint8x16_t negative_a = vcltq_s8(va, vdupq_n_s8(0));\n        uint8x16_t negative_b = vcltq_s8(vb, vdupq_n_s8(0));\n        \n        // Compute result based on conditions\n        uint8x16_t both_positive = vandq_u8(positive_a, positive_b);\n        uint8x16_t both_negative = vandq_u8(negative_a, negative_b);\n        \n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_positive, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_negative, vdupq_n_s8(-1), result);\n        \n        // Store result\n        vst1q_s8(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = length - (length % 8);\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = 0; i < vector_length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        \n        if (i < midpoint) {\n            // XOR for first half before midpoint\n            uint16x8_t xor_vec = veorq_u16(a_vec, b_vec);\n            vst1q_u16(C + i, xor_vec);\n        } else if (i == midpoint) {\n            // Keep A values at midpoint\n            vst1q_u16(C + i, a_vec);\n        } else {\n            // AND for second half after midpoint\n            uint16x8_t and_vec = vandq_u16(a_vec, b_vec);\n            vst1q_u16(C + i, and_vec);\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == midpoint) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = length - (length % 8);\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = 0; i < midpoint; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        \n        // Bitwise XOR for elements before midpoint\n        uint16x8_t vxor = veorq_u16(va, vb);\n        vst1q_u16(C + i, vxor);\n    }\n    \n    // Process midpoint element\n    if (midpoint % 8 == 0) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process vectors of 8 elements after midpoint\n    for (size_t i = midpoint + 1; i < vector_length; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        \n        // Bitwise AND for elements after midpoint\n        uint16x8_t vand = vandq_u16(va, vb);\n        vst1q_u16(C + i, vand);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        } else {\n            C[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = length - (length % 8);\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = 0; i < midpoint; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        \n        // Bitwise XOR for elements before midpoint\n        uint16x8_t xor_result = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, xor_result);\n    }\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = midpoint; i < vector_length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        \n        // Bitwise AND for elements after midpoint\n        uint16x8_t and_result = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, and_result);\n    }\n    \n    // Handle midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = length - (length % 8);\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = 0; i < midpoint; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        \n        // Bitwise XOR for elements before midpoint\n        uint16x8_t xor_result = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, xor_result);\n    }\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = midpoint + 1; i < vector_length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        \n        // Bitwise AND for elements after midpoint\n        uint16x8_t and_result = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, and_result);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; ++i) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i > midpoint) {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vector_length = length - (length % 8);\n    \n    // Process vectors of 8 elements at a time\n    for (size_t i = 0; i < vector_length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        \n        if (i < midpoint) {\n            // XOR for first half\n            uint16x8_t xor_vec = veorq_u16(a_vec, b_vec);\n            vst1q_u16(C + i, xor_vec);\n        } else if (i == midpoint) {\n            // Keep A values at midpoint\n            vst1q_u16(C + i, a_vec);\n        } else {\n            // AND for second half\n            uint16x8_t and_vec = vandq_u16(a_vec, b_vec);\n            vst1q_u16(C + i, and_vec);\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_length; i < length; i++) {\n        if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else if (i == midpoint) {\n            C[i] = A[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        // Load condition vectors\n        uint32x4_t cond1_vec = vcvtq_u32_u8(vreinterpret_u8_u32(vld1q_u32(reinterpret_cast<const uint32_t*>(cond1 + i))));\n        uint32x4_t cond2_vec = vcvtq_u32_u8(vreinterpret_u8_u32(vld1q_u32(reinterpret_cast<const uint32_t*>(cond2 + i))));\n\n        // Load input vectors\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t c_vec = vld1q_f32(C + i);\n        float32x4_t d_vec = vld1q_f32(D + i);\n\n        // Combine conditions\n        uint32x4_t cond_combined = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t not_cond1 = vmvnq_u32(cond1_vec);\n        uint32x4_t not_cond2 = vmvnq_u32(cond2_vec);\n\n        // Select based on conditions\n        float32x4_t result_vec = vbslq_f32(cond_combined, a_vec,\n                                   vbslq_f32(vandq_u32(cond1_vec, not_cond2), b_vec,\n                                   vbslq_f32(vandq_u32(not_cond1, cond2_vec), c_vec, d_vec)));\n\n        // Store result\n        vst1q_f32(out + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < vector_count; ++i) {\n        // Load condition vectors\n        uint32x4_t cond1_vec = vreinterpret_u32_u8(vdup_n_u8(0));\n        uint32x4_t cond2_vec = vreinterpret_u32_u8(vdup_n_u8(0));\n        \n        for (size_t j = 0; j < vector_size; ++j) {\n            cond1_vec = vsetq_lane_u32(cond1[i * vector_size + j] ? 0xFFFFFFFF : 0, cond1_vec, j);\n            cond2_vec = vsetq_lane_u32(cond2[i * vector_size + j] ? 0xFFFFFFFF : 0, cond2_vec, j);\n        }\n\n        // Load input vectors\n        float32x4_t a_vec = vld1q_f32(A + i * vector_size);\n        float32x4_t b_vec = vld1q_f32(B + i * vector_size);\n        float32x4_t c_vec = vld1q_f32(C + i * vector_size);\n        float32x4_t d_vec = vld1q_f32(D + i * vector_size);\n\n        // Combine conditions\n        uint32x4_t cond_combined = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t cond_combined_inv1 = vbicq_u32(cond1_vec, cond2_vec);\n        uint32x4_t cond_combined_inv2 = vbicq_u32(cond2_vec, cond1_vec);\n        uint32x4_t cond_combined_false = vbicq_u32(vmvnq_u32(cond1_vec), vmvnq_u32(cond2_vec));\n\n        // Select values based on conditions\n        float32x4_t result_vec = vbslq_f32(cond_combined, a_vec,\n                                  vbslq_f32(cond_combined_inv1, b_vec,\n                                  vbslq_f32(cond_combined_inv2, c_vec,\n                                            d_vec)));\n\n        // Store result\n        vst1q_f32(out + i * vector_size, result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vector_elements = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < vector_elements; i += vector_size) {\n        // Load condition vectors\n        uint32x4_t cond1_vec = vcvtq_u32_u8(vreinterpret_u8_u32(vld1q_u32(reinterpret_cast<const uint32_t*>(cond1 + i))));\n        uint32x4_t cond2_vec = vcvtq_u32_u8(vreinterpret_u8_u32(vld1q_u32(reinterpret_cast<const uint32_t*>(cond2 + i))));\n\n        // Load input vectors\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t c_vec = vld1q_f32(C + i);\n        float32x4_t d_vec = vld1q_f32(D + i);\n\n        // Combine conditions\n        uint32x4_t cond_combined = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t not_cond1 = vmvnq_u32(cond1_vec);\n        uint32x4_t not_cond2 = vmvnq_u32(cond2_vec);\n\n        // Select based on conditions\n        float32x4_t result1 = vbslq_f32(cond_combined, a_vec, b_vec);\n        float32x4_t result2 = vbslq_f32(vandq_u32(not_cond1, cond2_vec), c_vec, d_vec);\n        float32x4_t final_result = vbslq_f32(cond1_vec, result1, result2);\n\n        // Store result\n        vst1q_f32(out + i, final_result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_elements; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            \n            // Process 4 elements at a time using Neon SIMD\n            for (; k + 4 <= dim3; k += 4) {\n                // Load 4 elements from each input tensor\n                float32x4_t a_vec = vld1q_f32(A + (i * dim2 * dim3) + (j * dim3) + k);\n                float32x4_t b_vec = vld1q_f32(B + (i * dim2 * dim3) + (j * dim3) + k);\n                float32x4_t c_vec = vld1q_f32(C + (i * dim2 * dim3) + (j * dim3) + k);\n                float32x4_t d_vec = vld1q_f32(D + (i * dim2 * dim3) + (j * dim3) + k);\n                \n                // Load condition vectors\n                uint32x4_t cond1_vec = vreinterpretq_u32_u8(vld1q_u8((const uint8_t*)(cond1 + (i * dim2 * dim3) + (j * dim3) + k)));\n                uint32x4_t cond2_vec = vreinterpretq_u32_u8(vld1q_u8((const uint8_t*)(cond2 + (i * dim2 * dim3) + (j * dim3) + k)));\n                \n                // Combine conditions\n                uint32x4_t cond_and = vandq_u32(cond1_vec, cond2_vec);\n                uint32x4_t cond_not_and1 = vandq_u32(cond1_vec, vmvnq_u32(cond2_vec));\n                uint32x4_t cond_not_and2 = vandq_u32(vmvnq_u32(cond1_vec), cond2_vec);\n                uint32x4_t cond_not_not_and = vandq_u32(vmvnq_u32(cond1_vec), vmvnq_u32(cond2_vec));\n                \n                // Select values based on conditions\n                float32x4_t result_vec = vbslq_f32(cond_and, a_vec,\n                                        vbslq_f32(cond_not_and1, b_vec,\n                                        vbslq_f32(cond_not_and2, c_vec,\n                                        vbslq_f32(cond_not_not_and, d_vec, d_vec))));\n                \n                // Store result\n                vst1q_f32(out + (i * dim2 * dim3) + (j * dim3) + k, result_vec);\n            }\n            \n            // Handle remaining elements\n            for (; k < dim3; ++k) {\n                size_t idx = (i * dim2 * dim3) + (j * dim3) + k;\n                if (cond1[idx] && cond2[idx]) {\n                    out[idx] = A[idx];\n                } else if (cond1[idx] && !cond2[idx]) {\n                    out[idx] = B[idx];\n                } else if (!cond1[idx] && cond2[idx]) {\n                    out[idx] = C[idx];\n                } else {\n                    out[idx] = D[idx];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 floats per Neon vector\n    size_t vectorized_length = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < vectorized_length; i += vector_size) {\n        // Load condition vectors\n        uint32x4_t cond1_vec = vcvtq_u32_u8(vdup_n_u8(cond1[i/4]));\n        uint32x4_t cond2_vec = vcvtq_u32_u8(vdup_n_u8(cond2[i/4]));\n\n        // Load input vectors\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t c_vec = vld1q_f32(C + i);\n        float32x4_t d_vec = vld1q_f32(D + i);\n\n        // Combine conditions\n        uint32x4_t cond_combined = vandq_u32(cond1_vec, cond2_vec);\n        uint32x4_t cond_not_combined = vbicq_u32(cond1_vec, cond2_vec);\n        uint32x4_t cond_not_cond1 = vmvnq_u32(cond1_vec);\n        uint32x4_t cond_not_cond2 = vmvnq_u32(cond2_vec);\n\n        // Select values based on conditions\n        float32x4_t result1 = vbslq_f32(cond_combined, a_vec, b_vec);\n        float32x4_t result2 = vbslq_f32(cond_not_combined, c_vec, d_vec);\n\n        // Final selection\n        float32x4_t final_result = vbslq_f32(cond1_vec, result1, result2);\n\n        // Store result\n        vst1q_f32(out + i, final_result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 16 / sizeof(uint32_t);  // 4 uint32_t elements per vector\n    size_t i = 0;\n\n    // Process 4 elements at a time using Neon intrinsics\n    for (; i + vector_size <= total_elements; i += vector_size) {\n        uint32x4_t input_vec = vld1q_u32(A + i);\n        \n        // Count bits set to 1 for each 32-bit element\n        uint32x4_t bit_count_vec = vdupq_n_u32(0);\n        \n        // Popcount for each 32-bit element\n        for (int j = 0; j < 32; j++) {\n            uint32x4_t shifted = vshrq_n_u32(input_vec, j);\n            uint32x4_t masked = vandq_u32(shifted, vdupq_n_u32(1));\n            bit_count_vec = vaddq_u32(bit_count_vec, masked);\n        }\n        \n        // Store results\n        uint8x8_t bit_count_narrow = vmovn_u16(vreinterpret_u16_u32(bit_count_vec));\n        vst1_u8(out + i, bit_count_narrow);\n    }\n\n    // Handle remaining elements sequentially\n    for (; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 16 / sizeof(uint32_t);  // Number of uint32_t elements processed in one vector\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < vector_count; ++i) {\n        uint32x4_t input_vector = vld1q_u32(A + i * vector_size);\n        \n        // Popcount for each 32-bit element\n        uint32x4_t popcount_vector = vdupq_n_u32(0);\n        \n        // Bit counting using bit manipulation\n        for (int j = 0; j < 32; ++j) {\n            uint32x4_t bit_mask = vdupq_n_u32(1 << j);\n            uint32x4_t bit_set = vandq_u32(input_vector, bit_mask);\n            popcount_vector = vaddq_u32(popcount_vector, vshrq_n_u32(bit_set, j));\n        }\n        \n        // Convert to 8-bit and store\n        uint8x8_t popcount_8bit = vmovn_u16(vmovn_u32(popcount_vector));\n        vst1_u8(out + i * vector_size, popcount_8bit);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        out[i] = __builtin_popcount(value);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 16 / sizeof(uint32_t);  // 4 uint32_t elements per vector\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // Process elements in 128-bit vectors\n    for (size_t i = 0; i < vector_count; ++i) {\n        uint32x4_t input_vec = vld1q_u32(A + i * vector_size);\n        \n        // Count bits using population count\n        uint32x4_t bit_count_vec = vdupq_n_u32(0);\n        for (int j = 0; j < 32; ++j) {\n            uint32x4_t shifted_vec = vshrq_n_u32(input_vec, j);\n            uint32x4_t masked_vec = vandq_u32(shifted_vec, vdupq_n_u32(1));\n            bit_count_vec = vaddq_u32(bit_count_vec, masked_vec);\n        }\n\n        // Store results\n        uint8x16_t result_vec = vmovn_u16(vmovn_u32(bit_count_vec));\n        vst1q_u8(out + i * vector_size, result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t bit_count = __builtin_popcount(value);\n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 16 / sizeof(uint32_t);  // Number of uint32_t elements in a Neon vector\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < vector_count; ++i) {\n        uint32x4_t input_vec = vld1q_u32(A + i * vector_size);\n        \n        // Popcount for each 32-bit element\n        uint32x4_t bit_count_vec = vdupq_n_u32(0);\n        \n        // Bit counting using population count\n        for (int j = 0; j < 32; ++j) {\n            uint32x4_t shifted_vec = vshrq_n_u32(input_vec, j);\n            uint32x4_t masked_vec = vandq_u32(shifted_vec, vdupq_n_u32(1));\n            bit_count_vec = vaddq_u32(bit_count_vec, masked_vec);\n        }\n        \n        // Store results\n        uint8x8_t bit_count_narrow = vmovn_u16(vreinterpret_u16_u32(bit_count_vec));\n        vst1_u8(out + i * vector_size, bit_count_narrow);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        out[i] = __builtin_popcount(value);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 16 / sizeof(uint32_t);  // 4 uint32_t elements per NEON vector\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < vector_count; ++i) {\n        uint32x4_t input_vec = vld1q_u32(A + i * vector_size);\n        \n        // Popcount for each 32-bit element\n        uint32x4_t bit_counts = vcntq_u32(input_vec);\n        \n        // Store results\n        vst1q_u8(out + i * vector_size, vreinterpret_u8_u32(bit_counts));\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        out[i] = __builtin_popcount(value);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using Neon SIMD\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 consecutive integers from input matrix A\n            int32x4_t vec_a = vld1q_s32(A + i * cols + j);\n            \n            // Create vector of divisors (3)\n            int32x4_t vec_divisor = vdupq_n_s32(3);\n            \n            // Compute remainder using vector division\n            int32x4_t vec_remainder = vandq_s32(vec_a, vsubq_s32(vec_divisor, vdupq_n_s32(1)));\n            \n            // Compare remainder to zero (divisibility check)\n            uint32x4_t vec_mask = vceqzq_s32(vec_remainder);\n            \n            // Compute absolute values\n            int32x4_t vec_abs = vabsq_s32(vec_a);\n            \n            // Blend original values and absolute values based on mask\n            int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n            \n            // Store result back to destination matrix B\n            vst1q_s32(B + i * cols + j, vec_result);\n        }\n        \n        // Handle remaining elements sequentially\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using Neon SIMD\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 consecutive integers from input matrix A\n            int32x4_t vec_a = vld1q_s32(A + i * cols + j);\n            \n            // Create vector of divisors (3)\n            int32x4_t vec_divisor = vdupq_n_s32(3);\n            \n            // Compute remainder using vector division\n            int32x4_t vec_remainder = vandq_s32(vec_a, vsubq_s32(vec_divisor, vmovq_n_s32(1)));\n            \n            // Compare remainder to zero (divisibility check)\n            uint32x4_t vec_mask = vceqzq_s32(vec_remainder);\n            \n            // Take absolute value of elements where condition is true\n            int32x4_t vec_abs = vabsq_s32(vec_a);\n            \n            // Blend original and absolute values based on mask\n            int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n            \n            // Store result back to destination matrix B\n            vst1q_s32(B + i * cols + j, vec_result);\n        }\n        \n        // Handle remaining elements sequentially\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using Neon SIMD\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 consecutive integers from input matrix A\n            int32x4_t vec_a = vld1q_s32(A + i * cols + j);\n            \n            // Create vector of divisors (3)\n            int32x4_t vec_divisor = vdupq_n_s32(3);\n            \n            // Compute remainder using vector division\n            int32x4_t vec_remainder = vandq_s32(vec_a, vsubq_s32(vec_divisor, vmovq_n_s32(1)));\n            \n            // Compare remainder to zero\n            uint32x4_t vec_mask = vceqzq_s32(vec_remainder);\n            \n            // Take absolute value of elements divisible by 3\n            int32x4_t vec_abs = vabsq_s32(vec_a);\n            \n            // Blend original values and absolute values based on mask\n            int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n            \n            // Store result back to destination matrix B\n            vst1q_s32(B + i * cols + j, vec_result);\n        }\n        \n        // Handle remaining elements sequentially\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using Neon SIMD\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 consecutive integers from input matrix A\n            int32x4_t vec_a = vld1q_s32(A + i * cols + j);\n            \n            // Create vector of divisors (3)\n            int32x4_t vec_divisor = vdupq_n_s32(3);\n            \n            // Compute remainder using vector division\n            int32x4_t vec_remainder = vandq_s32(vec_a, vsubq_s32(vec_divisor, vdupq_n_s32(1)));\n            \n            // Compare remainder to zero (divisibility check)\n            uint32x4_t vec_mask = vceqzq_s32(vec_remainder);\n            \n            // Take absolute value of elements where divisible by 3\n            int32x4_t vec_abs = vabsq_s32(vec_a);\n            \n            // Blend original and absolute values based on mask\n            int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n            \n            // Store result back to destination matrix B\n            vst1q_s32(B + i * cols + j, vec_result);\n        }\n        \n        // Handle remaining elements sequentially\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using Neon SIMD\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 integers from input matrix A\n            int32x4_t vec_a = vld1q_s32(A + i * cols + j);\n            \n            // Create vector of divisors (3)\n            int32x4_t vec_divisor = vdupq_n_s32(3);\n            \n            // Compute remainder using vector division\n            int32x4_t vec_remainder = vandq_s32(vec_a, vsubq_s32(vec_divisor, vdupq_n_s32(1)));\n            \n            // Compare remainder to zero (divisibility check)\n            uint32x4_t vec_mask = vceqzq_s32(vec_remainder);\n            \n            // Compute absolute values\n            int32x4_t vec_abs = vabsq_s32(vec_a);\n            \n            // Blend original values and absolute values based on mask\n            int32x4_t vec_result = vbslq_s32(vec_mask, vec_abs, vec_a);\n            \n            // Store result in destination matrix B\n            vst1q_s32(B + i * cols + j, vec_result);\n        }\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Create mask for low 4 bits being all 1\n        uint32x4_t mask_vec = vdupq_n_u32(0xF);\n        uint32x4_t ones_vec = vdupq_n_u32(0xF);\n        uint32x4_t condition_vec = vceqq_u32(vandq_u32(src_vec, mask_vec), ones_vec);\n        \n        // Rotate elements where condition is true\n        uint32x4_t rotated_vec = vshlq_u32(src_vec, vdupq_n_s32(rotate_bits));\n        rotated_vec = vsriq_n_u32(rotated_vec, src_vec, 32 - rotate_bits);\n        \n        // Bitwise negate elements where condition is false\n        uint32x4_t negated_vec = vmvnq_u32(src_vec);\n        \n        // Blend results based on condition\n        uint32x4_t result_vec = vbslq_u32(condition_vec, rotated_vec, negated_vec);\n        \n        // Store result\n        vst1q_u32(dst + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            // Rotate bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negate\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Create mask for low 4 bits being all 1\n        uint32x4_t mask_vec = vdupq_n_u32(0xF);\n        uint32x4_t low_bits_mask = vceqq_u32(vandq_u32(src_vec, mask_vec), mask_vec);\n        \n        // Rotate elements where low 4 bits are all 1\n        uint32x4_t rotated_vec = vshlq_u32(src_vec, vdupq_n_s32(rotate_bits));\n        rotated_vec = vsriq_n_u32(rotated_vec, src_vec, 32 - rotate_bits);\n        \n        // Bitwise negate elements where low 4 bits are not all 1\n        uint32x4_t negated_vec = vmvnq_u32(src_vec);\n        \n        // Select between rotated and negated based on condition\n        uint32x4_t result_vec = vbslq_u32(low_bits_mask, rotated_vec, negated_vec);\n        \n        // Store result\n        vst1q_u32(dst + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            // Rotate bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negate\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Create mask for checking low 4 bits\n        uint32x4_t mask = vdupq_n_u32(0xF);\n        uint32x4_t all_ones = vdupq_n_u32(0xF);\n        \n        // Check if low 4 bits are all 1\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t condition = vceqq_u32(low_bits, all_ones);\n        \n        // Rotate elements\n        uint32x4_t rotated_vec;\n        if (rotate_bits == 1) {\n            rotated_vec = vshlq_n_u32(src_vec, 1);\n        } else {\n            rotated_vec = vshlq_n_u32(src_vec, rotate_bits);\n        }\n        \n        // Bitwise negate elements\n        uint32x4_t negated_vec = vmvnq_u32(src_vec);\n        \n        // Select between rotated and negated based on condition\n        uint32x4_t result = vbslq_u32(condition, rotated_vec, negated_vec);\n        \n        // Store result\n        vst1q_u32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Create mask for low 4 bits\n        uint32x4_t mask = vdupq_n_u32(0xF);\n        \n        // Check if low 4 bits are all 1\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t compare_mask = vceqq_u32(low_bits, mask);\n        \n        // Rotate elements where condition is true\n        uint32x4_t rotated_vec = vshlq_u32(src_vec, vdupq_n_s32(rotate_bits));\n        rotated_vec = vsriq_n_u32(rotated_vec, src_vec, 32 - rotate_bits);\n        \n        // Bitwise negate elements where condition is false\n        uint32x4_t negated_vec = vmvnq_u32(src_vec);\n        \n        // Blend results based on condition\n        uint32x4_t result_vec = vbslq_u32(compare_mask, rotated_vec, negated_vec);\n        \n        // Store result\n        vst1q_u32(dst + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            // Rotate bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negate\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Create mask for low 4 bits\n        uint32x4_t mask = vdupq_n_u32(0xF);\n        \n        // Check if low 4 bits are all 1\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t compare_mask = vceqq_u32(low_bits, mask);\n        \n        // Rotate elements where condition is true\n        uint32x4_t rotated_vec = vshlq_u32(src_vec, vdupq_n_s32(rotate_bits));\n        rotated_vec = vsriq_n_u32(rotated_vec, src_vec, 32 - rotate_bits);\n        \n        // Bitwise negate elements where condition is false\n        uint32x4_t negated_vec = vmvnq_u32(src_vec);\n        \n        // Blend results based on condition\n        uint32x4_t result_vec = vbslq_u32(compare_mask, rotated_vec, negated_vec);\n        \n        // Store result\n        vst1q_u32(dst + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            // Rotate\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negate\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n\n    // Process 16 elements at a time (4 NEON vectors)\n    for (; i + 16 <= length; i += 16) {\n        float32x4_t a_vec1 = vld1q_f32(A + i);\n        float32x4_t a_vec2 = vld1q_f32(A + i + 4);\n        float32x4_t a_vec3 = vld1q_f32(A + i + 8);\n        float32x4_t a_vec4 = vld1q_f32(A + i + 12);\n\n        float32x4_t b_vec1 = vld1q_f32(B + i);\n        float32x4_t b_vec2 = vld1q_f32(B + i + 4);\n        float32x4_t b_vec3 = vld1q_f32(B + i + 8);\n        float32x4_t b_vec4 = vld1q_f32(B + i + 12);\n\n        float32x4_t diff_vec1 = vsubq_f32(a_vec1, b_vec1);\n        float32x4_t diff_vec2 = vsubq_f32(a_vec2, b_vec2);\n        float32x4_t diff_vec3 = vsubq_f32(a_vec3, b_vec3);\n        float32x4_t diff_vec4 = vsubq_f32(a_vec4, b_vec4);\n\n        uint32x4_t gt_vec1 = vcgtq_f32(diff_vec1, epsilon_vec);\n        uint32x4_t gt_vec2 = vcgtq_f32(diff_vec2, epsilon_vec);\n        uint32x4_t gt_vec3 = vcgtq_f32(diff_vec3, epsilon_vec);\n        uint32x4_t gt_vec4 = vcgtq_f32(diff_vec4, epsilon_vec);\n\n        uint32x4_t lt_vec1 = vcltq_f32(diff_vec1, neg_epsilon_vec);\n        uint32x4_t lt_vec2 = vcltq_f32(diff_vec2, neg_epsilon_vec);\n        uint32x4_t lt_vec3 = vcltq_f32(diff_vec3, neg_epsilon_vec);\n        uint32x4_t lt_vec4 = vcltq_f32(diff_vec4, neg_epsilon_vec);\n\n        int8x16_t result_vec;\n        result_vec = vreinterpretq_s8_u32(vorrq_u32(vandq_u32(gt_vec1, vdupq_n_u32(1)), \n                                           vshlq_n_u32(vandq_u32(lt_vec1, vdupq_n_u32(1)), 1)));\n        result_vec = vreinterpretq_s8_u32(vorrq_u32(result_vec, \n                                           vreinterpretq_u32_s8(vreinterpretq_s8_u32(vorrq_u32(vreinterpretq_u32_s8(result_vec), \n                                           vorrq_u32(vandq_u32(gt_vec2, vdupq_n_u32(1)), \n                                           vshlq_n_u32(vandq_u32(lt_vec2, vdupq_n_u32(1)), 1)))))));\n        result_vec = vreinterpretq_s8_u32(vorrq_u32(result_vec, \n                                           vreinterpretq_u32_s8(vreinterpretq_s8_u32(vorrq_u32(vreinterpretq_u32_s8(result_vec), \n                                           vorrq_u32(vandq_u32(gt_vec3, vdupq_n_u32(1)), \n                                           vshlq_n_u32(vandq_u32(lt_vec3, vdupq_n_u32(1)), 1)))))));\n        result_vec = vreinterpretq_s8_u32(vorrq_u32(result_vec, \n                                           vreinterpretq_u32_s8(vreinterpretq_s8_u32(vorrq_u32(vreinterpretq_u32_s8(result_vec), \n                                           vorrq_u32(vandq_u32(gt_vec4, vdupq_n_u32(1)), \n                                           vshlq_n_u32(vandq_u32(lt_vec4, vdupq_n_u32(1)), 1)))))));\n\n        vst1q_s8(out + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vector_len = length - (length % 16);\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n\n    for (size_t i = 0; i < vector_len; i += 16) {\n        float32x4_t a_vec1 = vld1q_f32(A + i);\n        float32x4_t a_vec2 = vld1q_f32(A + i + 4);\n        float32x4_t a_vec3 = vld1q_f32(A + i + 8);\n        float32x4_t a_vec4 = vld1q_f32(A + i + 12);\n\n        float32x4_t b_vec1 = vld1q_f32(B + i);\n        float32x4_t b_vec2 = vld1q_f32(B + i + 4);\n        float32x4_t b_vec3 = vld1q_f32(B + i + 8);\n        float32x4_t b_vec4 = vld1q_f32(B + i + 12);\n\n        float32x4_t diff_vec1 = vsubq_f32(a_vec1, b_vec1);\n        float32x4_t diff_vec2 = vsubq_f32(a_vec2, b_vec2);\n        float32x4_t diff_vec3 = vsubq_f32(a_vec3, b_vec3);\n        float32x4_t diff_vec4 = vsubq_f32(a_vec4, b_vec4);\n\n        uint32x4_t gt_epsilon1 = vcgtq_f32(diff_vec1, epsilon_vec);\n        uint32x4_t gt_epsilon2 = vcgtq_f32(diff_vec2, epsilon_vec);\n        uint32x4_t gt_epsilon3 = vcgtq_f32(diff_vec3, epsilon_vec);\n        uint32x4_t gt_epsilon4 = vcgtq_f32(diff_vec4, epsilon_vec);\n\n        uint32x4_t lt_neg_epsilon1 = vcltq_f32(diff_vec1, neg_epsilon_vec);\n        uint32x4_t lt_neg_epsilon2 = vcltq_f32(diff_vec2, neg_epsilon_vec);\n        uint32x4_t lt_neg_epsilon3 = vcltq_f32(diff_vec3, neg_epsilon_vec);\n        uint32x4_t lt_neg_epsilon4 = vcltq_f32(diff_vec4, neg_epsilon_vec);\n\n        int8x16_t result_vec = vdupq_n_s8(0);\n        result_vec = vsetq_lane_s8(vgetq_lane_u32(gt_epsilon1, 0) ? 1 : \n                                   (vgetq_lane_u32(lt_neg_epsilon1, 0) ? -1 : 0), result_vec, 0);\n        result_vec = vsetq_lane_s8(vgetq_lane_u32(gt_epsilon1, 1) ? 1 : \n                                   (vgetq_lane_u32(lt_neg_epsilon1, 1) ? -1 : 0), result_vec, 1);\n        result_vec = vsetq_lane_s8(vgetq_lane_u32(gt_epsilon1, 2) ? 1 : \n                                   (vgetq_lane_u32(lt_neg_epsilon1, 2) ? -1 : 0), result_vec, 2);\n        result_vec = vsetq_lane_s8(vgetq_lane_u32(gt_epsilon1, 3) ? 1 : \n                                   (vgetq_lane_u32(lt_neg_epsilon1, 3) ? -1 : 0), result_vec, 3);\n\n        // Similar lane setting for other vectors...\n\n        vst1q_s8(out + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_len; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n\n    // Process 16 elements at a time (4 vectors of 4 floats)\n    for (; i + 16 <= length; i += 16) {\n        float32x4_t a0 = vld1q_f32(A + i);\n        float32x4_t a1 = vld1q_f32(A + i + 4);\n        float32x4_t a2 = vld1q_f32(A + i + 8);\n        float32x4_t a3 = vld1q_f32(A + i + 12);\n\n        float32x4_t b0 = vld1q_f32(B + i);\n        float32x4_t b1 = vld1q_f32(B + i + 4);\n        float32x4_t b2 = vld1q_f32(B + i + 8);\n        float32x4_t b3 = vld1q_f32(B + i + 12);\n\n        float32x4_t diff0 = vsubq_f32(a0, b0);\n        float32x4_t diff1 = vsubq_f32(a1, b1);\n        float32x4_t diff2 = vsubq_f32(a2, b2);\n        float32x4_t diff3 = vsubq_f32(a3, b3);\n\n        uint32x4_t gt0 = vcgtq_f32(diff0, epsilon_vec);\n        uint32x4_t gt1 = vcgtq_f32(diff1, epsilon_vec);\n        uint32x4_t gt2 = vcgtq_f32(diff2, epsilon_vec);\n        uint32x4_t gt3 = vcgtq_f32(diff3, epsilon_vec);\n\n        uint32x4_t lt0 = vcltq_f32(diff0, neg_epsilon_vec);\n        uint32x4_t lt1 = vcltq_f32(diff1, neg_epsilon_vec);\n        uint32x4_t lt2 = vcltq_f32(diff2, neg_epsilon_vec);\n        uint32x4_t lt3 = vcltq_f32(diff3, neg_epsilon_vec);\n\n        int8x16_t result = {\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 12) ? -1 : 0),\n\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 12) ? -1 : 0),\n\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 12) ? -1 : 0),\n\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 12) ? -1 : 0)\n        };\n\n        vst1q_s8(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        out[i] = (diff > epsilon) ? 1 : ((diff < -epsilon) ? -1 : 0);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n\n    // Process 16 elements at a time (4 vectors of 4 floats)\n    for (; i + 16 <= length; i += 16) {\n        float32x4_t a0 = vld1q_f32(A + i);\n        float32x4_t a1 = vld1q_f32(A + i + 4);\n        float32x4_t a2 = vld1q_f32(A + i + 8);\n        float32x4_t a3 = vld1q_f32(A + i + 12);\n\n        float32x4_t b0 = vld1q_f32(B + i);\n        float32x4_t b1 = vld1q_f32(B + i + 4);\n        float32x4_t b2 = vld1q_f32(B + i + 8);\n        float32x4_t b3 = vld1q_f32(B + i + 12);\n\n        float32x4_t diff0 = vsubq_f32(a0, b0);\n        float32x4_t diff1 = vsubq_f32(a1, b1);\n        float32x4_t diff2 = vsubq_f32(a2, b2);\n        float32x4_t diff3 = vsubq_f32(a3, b3);\n\n        uint32x4_t gt0 = vcgtq_f32(diff0, epsilon_vec);\n        uint32x4_t gt1 = vcgtq_f32(diff1, epsilon_vec);\n        uint32x4_t gt2 = vcgtq_f32(diff2, epsilon_vec);\n        uint32x4_t gt3 = vcgtq_f32(diff3, epsilon_vec);\n\n        uint32x4_t lt0 = vcltq_f32(diff0, neg_epsilon_vec);\n        uint32x4_t lt1 = vcltq_f32(diff1, neg_epsilon_vec);\n        uint32x4_t lt2 = vcltq_f32(diff2, neg_epsilon_vec);\n        uint32x4_t lt3 = vcltq_f32(diff3, neg_epsilon_vec);\n\n        int8x16_t result = {\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 12) ? -1 : 0),\n\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 12) ? -1 : 0),\n\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 12) ? -1 : 0),\n\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 12) ? -1 : 0)\n        };\n\n        vst1q_s8(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        out[i] = (diff > epsilon) ? 1 : ((diff < -epsilon) ? -1 : 0);\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vnegq_f32(epsilon_vec);\n\n    // Process 16 elements at a time (4 vectors of 4 floats)\n    for (; i + 16 <= length; i += 16) {\n        float32x4_t a0 = vld1q_f32(A + i);\n        float32x4_t a1 = vld1q_f32(A + i + 4);\n        float32x4_t a2 = vld1q_f32(A + i + 8);\n        float32x4_t a3 = vld1q_f32(A + i + 12);\n\n        float32x4_t b0 = vld1q_f32(B + i);\n        float32x4_t b1 = vld1q_f32(B + i + 4);\n        float32x4_t b2 = vld1q_f32(B + i + 8);\n        float32x4_t b3 = vld1q_f32(B + i + 12);\n\n        float32x4_t diff0 = vsubq_f32(a0, b0);\n        float32x4_t diff1 = vsubq_f32(a1, b1);\n        float32x4_t diff2 = vsubq_f32(a2, b2);\n        float32x4_t diff3 = vsubq_f32(a3, b3);\n\n        uint32x4_t gt0 = vcgtq_f32(diff0, epsilon_vec);\n        uint32x4_t gt1 = vcgtq_f32(diff1, epsilon_vec);\n        uint32x4_t gt2 = vcgtq_f32(diff2, epsilon_vec);\n        uint32x4_t gt3 = vcgtq_f32(diff3, epsilon_vec);\n\n        uint32x4_t lt0 = vcltq_f32(diff0, neg_epsilon_vec);\n        uint32x4_t lt1 = vcltq_f32(diff1, neg_epsilon_vec);\n        uint32x4_t lt2 = vcltq_f32(diff2, neg_epsilon_vec);\n        uint32x4_t lt3 = vcltq_f32(diff3, neg_epsilon_vec);\n\n        int8x16_t result = {\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt0), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt0), 12) ? -1 : 0),\n            \n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt1), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt1), 12) ? -1 : 0),\n            \n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt2), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt2), 12) ? -1 : 0),\n            \n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 0) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 0) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 4) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 4) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 8) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 8) ? -1 : 0),\n            vgetq_lane_u8(vreinterpretq_u8_u32(gt3), 12) ? 1 : \n            (vgetq_lane_u8(vreinterpretq_u8_u32(lt3), 12) ? -1 : 0)\n        };\n\n        vst1q_s8(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        out[i] = (diff > epsilon) ? 1 : ((diff < -epsilon) ? -1 : 0);\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        float32x4_t float_vec = vld1q_f32(A + i);\n        \n        // Convert float to int32 with saturation\n        int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n        \n        // Store the converted values\n        vst1q_s32(B + i, int_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        float32x4_t float_vec = vld1q_f32(A + i);\n        \n        // Convert float to int32 with saturation\n        int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n        \n        // Store the converted values\n        vst1q_s32(B + i, int_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        float32x4_t float_vec = vld1q_f32(A + i);\n        \n        // Convert float to int32 with saturation\n        int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n        \n        // Store the converted values\n        vst1q_s32(B + i, int_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        float32x4_t float_vec = vld1q_f32(A + i);\n        \n        // Convert float to int32 with saturation\n        int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n        \n        // Saturate values\n        int_vec = vminq_s32(int_vec, vdupq_n_s32(INT32_MAX));\n        int_vec = vmaxq_s32(int_vec, vdupq_n_s32(INT32_MIN));\n        \n        // Store 4 int32 values\n        vst1q_s32(B + i, int_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        float32x4_t float_vec = vld1q_f32(A + i);\n        \n        // Convert float to int32 with saturation\n        int32x4_t int_vec = vcvtq_s32_f32(float_vec);\n        \n        // Store the converted values\n        vst1q_s32(B + i, int_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Create a vector with the scale factor replicated\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    \n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values\n        int32x4_t int_vec = vld1q_s32(A + i);\n        \n        // Convert int32 to float\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        \n        // Scale the float values\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        \n        // Store the result\n        vst1q_f32(B + i, scaled_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Create a vector with the scale factor replicated\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n\n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values\n        int32x4_t int_vec = vld1q_s32(A + i);\n\n        // Convert int32 to float\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Create a vector with the scale factor replicated\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n\n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values\n        int32x4_t int_vec = vld1q_s32(A + i);\n        \n        // Convert int32 to float\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        \n        // Scale the float values\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        \n        // Store the result\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Broadcast the scale factor to all lanes of a vector\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n\n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values\n        int32x4_t int_vec = vld1q_s32(A + i);\n\n        // Convert int32 to float\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n\n        // Scale the float values\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n\n        // Store the result\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Broadcast the scale factor to all lanes of a vector\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n\n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 int32_t values\n        int32x4_t int_vec = vld1q_s32(A + i);\n        \n        // Convert int32 to float\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        \n        // Scale the float values\n        float32x4_t scaled_vec = vmulq_f32(float_vec, scale_vec);\n        \n        // Store the result\n        vst1q_f32(B + i, scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values from A and B\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer\n        int32x4_t vround = vcvtnq_s32_f32(vdiv);\n        \n        // Store result in C\n        vst1q_s32(C + i, vround);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = static_cast<int32_t>(std::round(A[i] / B[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values from A and B\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer\n        int32x4_t vround = vcvtnq_s32_f32(vdiv);\n        \n        // Store result in C\n        vst1q_s32(C + i, vround);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values from A and B\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer\n        int32x4_t vround = vcvtnq_s32_f32(vdiv);\n        \n        // Store result in C\n        vst1q_s32(C + i, vround);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values from A and B\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer\n        int32x4_t vround = vcvtnq_s32_f32(vdiv);\n        \n        // Store the result in C\n        vst1q_s32(C + i, vround);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values from A and B\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        \n        // Perform element-wise division\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        \n        // Round to nearest integer\n        int32x4_t vround = vcvtnq_s32_f32(vdiv);\n        \n        // Store result in C\n        vst1q_s32(C + i, vround);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < size; i += 2) {\n        // Load 2 doubles\n        float64x2_t doubles_vec = vld1q_f64(A + i);\n        \n        // Convert doubles to floats with saturation\n        float32x2_t floats_vec = vqmovn_f64(doubles_vec);\n        \n        // Store 2 floats\n        vst1_f32(B + i, floats_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < size; i += 2) {\n        // Load 2 doubles\n        float64x2_t doubles_vec = vld1q_f64(A + i);\n        \n        // Convert doubles to floats with saturation\n        float32x2_t floats_vec = vcvt_f32_f64(doubles_vec);\n        \n        // Store 2 floats\n        vst1_f32(B + i, floats_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < size; i += 2) {\n        // Load 2 doubles\n        float64x2_t doubles_vec = vld1q_f64(A + i);\n        \n        // Convert doubles to floats with saturation\n        float32x2_t floats_vec = vqmovn_f64(doubles_vec);\n        \n        // Store the converted floats\n        vst1_f32(B + i, floats_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < size; i += 2) {\n        // Load 2 doubles\n        float64x2_t doubles_vec = vld1q_f64(A + i);\n        \n        // Convert doubles to floats with saturation\n        float32x2_t floats_vec = vqmovn_f64(doubles_vec);\n        \n        // Store 2 floats\n        vst1_f32(B + i, floats_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (; i + 1 < size; i += 2) {\n        // Load 2 doubles\n        float64x2_t doubles_vec = vld1q_f64(A + i);\n        \n        // Convert doubles to floats with saturation\n        float32x2_t floats_vec = vqmovn_f64(doubles_vec);\n        \n        // Store 2 floats\n        vst1_f32(B + i, floats_vec);\n    }\n    \n    // Handle remaining single element if size is odd\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon 128-bit vectors\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t input_vec = vld1q_s16(A + i);\n        \n        // Split the 16-bit vector into two 64-bit vectors\n        int16x4_t low_half = vget_low_s16(input_vec);\n        int16x4_t high_half = vget_high_s16(input_vec);\n        \n        // Convert 16-bit to 32-bit vectors\n        int32x4_t result_low = vmovl_s16(low_half);\n        int32x4_t result_high = vmovl_s16(high_half);\n        \n        // Store the converted vectors\n        vst1q_s32(B + i, result_low);\n        vst1q_s32(B + i + 4, result_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t input_vec = vld1q_s16(A + i);\n        \n        // Split the 16-bit vector into two 64-bit vectors\n        int16x4_t low_half = vget_low_s16(input_vec);\n        int16x4_t high_half = vget_high_s16(input_vec);\n        \n        // Convert 16-bit to 32-bit\n        int32x4_t result_low = vmovl_s16(low_half);\n        int32x4_t result_high = vmovl_s16(high_half);\n        \n        // Store the converted values\n        vst1q_s32(B + i, result_low);\n        vst1q_s32(B + i + 4, result_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon 128-bit vectors\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values from source array\n        int16x8_t input_vec = vld1q_s16(A + i);\n        \n        // Convert lower 4 int16_t to int32_t\n        int32x4_t low_result = vmovl_s16(vget_low_s16(input_vec));\n        \n        // Convert upper 4 int16_t to int32_t\n        int32x4_t high_result = vmovl_s16(vget_high_s16(input_vec));\n        \n        // Store results in destination array\n        vst1q_s32(B + i, low_result);\n        vst1q_s32(B + i + 4, high_result);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t input_vec = vld1q_s16(A + i);\n        \n        // Split the 16-bit vector into two 64-bit vectors\n        int16x4_t low_half = vget_low_s16(input_vec);\n        int16x4_t high_half = vget_high_s16(input_vec);\n        \n        // Convert 16-bit to 32-bit\n        int32x4_t result_low = vmovl_s16(low_half);\n        int32x4_t result_high = vmovl_s16(high_half);\n        \n        // Store the converted values\n        vst1q_s32(B + i, result_low);\n        vst1q_s32(B + i + 4, result_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t input_vec = vld1q_s16(A + i);\n        \n        // Split the 16-bit vector into two 64-bit vectors\n        int16x4_t low_half = vget_low_s16(input_vec);\n        int16x4_t high_half = vget_high_s16(input_vec);\n        \n        // Convert 16-bit to 32-bit\n        int32x4_t result_low = vmovl_s16(low_half);\n        int32x4_t result_high = vmovl_s16(high_half);\n        \n        // Store the converted values\n        vst1q_s32(B + i, result_low);\n        vst1q_s32(B + i + 4, result_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    float32x4_t range_vec = vsubq_f32(max_vec, min_vec);\n\n    // Process 4 elements at a time\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t control_vec = vld1q_s32(control + i);\n\n        // Check control values\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        // Normalize where control > 0\n        float32x4_t normalized_vec = vdivq_f32(vsubq_f32(a_vec, min_vec), range_vec);\n        normalized_vec = vmaxq_f32(zero_vec, normalized_vec);\n        normalized_vec = vminq_f32(one_vec, normalized_vec);\n\n        // Blend normalized and original values based on control\n        float32x4_t result_vec = vbslq_f32(mask, normalized_vec, a_vec);\n\n        // Store result\n        vst1q_f32(B + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized < 0.0f ? 0.0f : (normalized > 1.0f ? 1.0f : normalized);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Precompute normalization constants\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n\n    // Process 4 elements at a time\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load source arrays\n        float32x4_t va = vld1q_f32(A + i);\n        int32x4_t vcontrol = vld1q_s32(control + i);\n\n        // Compute normalization mask\n        uint32x4_t vmask = vcgtq_s32(vcontrol, vdupq_n_s32(0));\n\n        // Normalize values where control > 0\n        float32x4_t vnorm = vsubq_f32(va, vmin);\n        vnorm = vdivq_f32(vnorm, vrange);\n        vnorm = vmaxq_f32(vzero, vnorm);\n        vnorm = vminq_f32(vone, vnorm);\n\n        // Select between original or normalized values\n        float32x4_t vresult = vbslq_f32(vmask, vnorm, va);\n\n        // Store result\n        vst1q_f32(B + i, vresult);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = fmaxf(0.0f, fminf(1.0f, val));\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Prepare SIMD vectors for min_val and max_val\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    float32x4_t range_vec = vsubq_f32(max_vec, min_vec);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control arrays\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t control_vec = vld1q_s32(control + i);\n\n        // Check control values\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        // Subtract min_val from A values\n        float32x4_t sub_vec = vsubq_f32(a_vec, min_vec);\n\n        // Divide by range\n        float32x4_t norm_vec = vdivq_f32(sub_vec, range_vec);\n\n        // Clamp between 0 and 1\n        norm_vec = vminq_f32(vmaxq_f32(norm_vec, zero_vec), one_vec);\n\n        // Blend normalized or original values based on control\n        float32x4_t result_vec = vbslq_f32(mask, norm_vec, a_vec);\n\n        // Store result\n        vst1q_f32(B + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : (val > 1.0f) ? 1.0f : val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    // Prepare SIMD vectors for min_val and max_val\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    float32x4_t range_vec = vsubq_f32(max_vec, min_vec);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 elements from A, control arrays\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t control_vec = vld1q_s32(control + i);\n\n        // Check control values\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        // Normalize where control > 0\n        float32x4_t normalized_vec = vsubq_f32(a_vec, min_vec);\n        normalized_vec = vdivq_f32(normalized_vec, range_vec);\n        normalized_vec = vmaxq_f32(normalized_vec, zero_vec);\n        normalized_vec = vminq_f32(normalized_vec, one_vec);\n\n        // Select between original or normalized values based on control\n        float32x4_t result_vec = vbslq_f32(mask, normalized_vec, a_vec);\n\n        // Store result\n        vst1q_f32(B + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : (val > 1.0f) ? 1.0f : val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t i = 0;\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t max_vec = vdupq_n_f32(max_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    float32x4_t range_vec = vsubq_f32(max_vec, min_vec);\n\n    // Process 4 elements at a time\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t control_vec = vld1q_s32(control + i);\n\n        // Check control values\n        uint32x4_t mask = vcgtq_s32(control_vec, vdupq_n_s32(0));\n\n        // Normalize where control > 0\n        float32x4_t normalized_vec = vdivq_f32(vsubq_f32(a_vec, min_vec), range_vec);\n        normalized_vec = vminq_f32(vmaxq_f32(normalized_vec, zero_vec), one_vec);\n\n        // Select between original or normalized values based on control\n        float32x4_t result_vec = vbslq_f32(mask, normalized_vec, a_vec);\n\n        // Store result\n        vst1q_f32(B + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = fmaxf(0.0f, fminf(normalized, 1.0f));\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t input_vec = vld1q_u32(A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        uint32x4_t shifted_vec = vshrq_n_u32(input_vec, 16);\n        \n        // Convert uint32 to float\n        float32x4_t float_vec = vcvtq_f32_u32(shifted_vec);\n        \n        // Compute square root\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        \n        // Store results in destination array\n        vst1q_f32(B + i, sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t input_vec = vld1q_u32(A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        uint32x4_t shifted_vec = vshrq_n_u32(input_vec, 16);\n        \n        // Convert uint32 to float\n        float32x4_t float_vec = vcvtq_f32_u32(shifted_vec);\n        \n        // Compute square root\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        \n        // Store results\n        vst1q_f32(B + i, sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t input_vec = vld1q_u32(A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        uint32x4_t shifted_vec = vshrq_n_u32(input_vec, 16);\n        \n        // Convert uint32 to float\n        float32x4_t float_vec = vcvtq_f32_u32(shifted_vec);\n        \n        // Compute square root\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        \n        // Store results in destination array\n        vst1q_f32(B + i, sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t input_vec = vld1q_u32(A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        uint32x4_t shifted_vec = vshrq_n_u32(input_vec, 16);\n        \n        // Convert uint32 to float\n        float32x4_t float_vec = vcvtq_f32_u32(shifted_vec);\n        \n        // Compute square root\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        \n        // Store results\n        vst1q_f32(B + i, sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t input_vec = vld1q_u32(A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        uint32x4_t shifted_vec = vshrq_n_u32(input_vec, 16);\n        \n        // Convert uint32 to float\n        float32x4_t float_vec = vcvtq_f32_u32(shifted_vec);\n        \n        // Calculate square root\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        \n        // Store results in destination array\n        vst1q_f32(B + i, sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit registers\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        \n        // Reinterpret the bits directly as float using vreinterpretq\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the result in destination array\n        vst1q_f32(B + i, float_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < size; i++) {\n        B[i] = *((float*)(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit registers\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        \n        // Reinterpret the bits directly as float using vreinterpretq\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the reinterpreted float values to destination array\n        vst1q_f32(B + i, float_vec);\n    }\n    \n    // Handle remaining elements that don't fit in 4-element vector\n    for (; i < size; i++) {\n        B[i] = *((float*)(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit registers\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values into a Neon register\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        \n        // Reinterpret the bits directly as float using vreinterpretq\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the result in the destination array\n        vst1q_f32(B + i, float_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < size; i++) {\n        B[i] = *((float*)(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        \n        // Reinterpret the bits directly as float using vreinterpretq\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the resulting float values to destination array\n        vst1q_f32(B + i, float_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < size; i++) {\n        B[i] = *((float*)(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon 128-bit vectors\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        \n        // Reinterpret the bits directly as float using vreinterpretq\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        \n        // Store the reinterpreted float values to destination array\n        vst1q_f32(B + i, float_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < size; i++) {\n        B[i] = *((float*)(&A[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using Neon\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 integers from A\n        int32x4_t a_vec = vld1q_s32(A + i);\n        int32x4_t a_prev_vec = vld1q_s32(A + i - 1);\n\n        // Load 4 condition values\n        uint32x4_t cond_vec = vcreate_u32(*(uint64_t*)(cond + i));\n        cond_vec = vcombine_u32(cond_vec, vcreate_u32(*(uint64_t*)(cond + i + 2)));\n\n        // Compute differences\n        int32x4_t diff_vec = vsubq_s32(a_vec, a_prev_vec);\n\n        // Convert to float\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_vec);\n\n        // Zero out differences where condition is false\n        diff_float_vec = vbslq_f32(cond_vec, diff_float_vec, vdupq_n_f32(0.0f));\n\n        // Store results\n        vst1q_f32(diff + i, diff_float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using Neon\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 integers from source array\n        int32x4_t a_vec = vld1q_s32(A + i);\n        int32x4_t a_prev_vec = vld1q_s32(A + i - 1);\n\n        // Load 4 condition values\n        uint32x4_t cond_vec = vcreate_u32(*(uint64_t*)(cond + i));\n        cond_vec = vcombine_u32(cond_vec, vcreate_u32(*(uint64_t*)(cond + i + 2)));\n\n        // Compute differences\n        int32x4_t diff_vec = vsubq_s32(a_vec, a_prev_vec);\n\n        // Convert to float\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_vec);\n\n        // Zero out differences where condition is false\n        diff_float_vec = vbslq_f32(cond_vec, diff_float_vec, vdupq_n_f32(0.0f));\n\n        // Store results\n        vst1q_f32(diff + i, diff_float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using Neon\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 integers from source array\n        int32x4_t a_vec = vld1q_s32(A + i);\n        int32x4_t a_prev_vec = vld1q_s32(A + i - 1);\n\n        // Load 4 condition values\n        uint32x4_t cond_vec = vcreate_u32(*(uint64_t*)(cond + i));\n        cond_vec = vcombine_u32(cond_vec, vcreate_u32(*(uint64_t*)(cond + i + 2)));\n\n        // Compute differences\n        int32x4_t diff_vec = vsubq_s32(a_vec, a_prev_vec);\n\n        // Convert to float\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_vec);\n\n        // Conditionally zero out differences\n        diff_float_vec = vbslq_f32(cond_vec, diff_float_vec, vdupq_n_f32(0.0f));\n\n        // Store results\n        vst1q_f32(diff + i, diff_float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0\n    diff[0] = 0.0f;\n\n    // Process 16 elements at a time using Neon\n    size_t vec_size = size - (size % 16);\n    for (size_t i = 1; i < vec_size; i += 16) {\n        // Load 16 integers from source array\n        int32x4_t a0 = vld1q_s32(A + i);\n        int32x4_t a1 = vld1q_s32(A + i + 4);\n        int32x4_t a2 = vld1q_s32(A + i + 8);\n        int32x4_t a3 = vld1q_s32(A + i + 12);\n\n        // Load previous 16 integers from source array\n        int32x4_t prev0 = vld1q_s32(A + i - 1);\n        int32x4_t prev1 = vld1q_s32(A + i + 3);\n        int32x4_t prev2 = vld1q_s32(A + i + 7);\n        int32x4_t prev3 = vld1q_s32(A + i + 11);\n\n        // Load 16 condition values\n        uint32x4_t cond0 = vcreate_u32(*(uint64_t*)(cond + i));\n        uint32x4_t cond1 = vcreate_u32(*(uint64_t*)(cond + i + 4));\n        uint32x4_t cond2 = vcreate_u32(*(uint64_t*)(cond + i + 8));\n        uint32x4_t cond3 = vcreate_u32(*(uint64_t*)(cond + i + 12));\n\n        // Compute differences\n        int32x4_t diff0 = vsubq_s32(a0, prev0);\n        int32x4_t diff1 = vsubq_s32(a1, prev1);\n        int32x4_t diff2 = vsubq_s32(a2, prev2);\n        int32x4_t diff3 = vsubq_s32(a3, prev3);\n\n        // Convert to float\n        float32x4_t float_diff0 = vcvtq_f32_s32(diff0);\n        float32x4_t float_diff1 = vcvtq_f32_s32(diff1);\n        float32x4_t float_diff2 = vcvtq_f32_s32(diff2);\n        float32x4_t float_diff3 = vcvtq_f32_s32(diff3);\n\n        // Zero out values where condition is false\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float_diff0 = vbslq_f32(cond0, float_diff0, zero);\n        float_diff1 = vbslq_f32(cond1, float_diff1, zero);\n        float_diff2 = vbslq_f32(cond2, float_diff2, zero);\n        float_diff3 = vbslq_f32(cond3, float_diff3, zero);\n\n        // Store results\n        vst1q_f32(diff + i, float_diff0);\n        vst1q_f32(diff + i + 4, float_diff1);\n        vst1q_f32(diff + i + 8, float_diff2);\n        vst1q_f32(diff + i + 12, float_diff3);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using Neon\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 integers from source array\n        int32x4_t a_vec = vld1q_s32(A + i);\n        \n        // Load previous 4 integers \n        int32x4_t a_prev_vec = vld1q_s32(A + i - 1);\n        \n        // Load 4 condition values\n        uint32x4_t cond_vec = vcreate_u32(\n            (uint64_t)cond[i] | \n            ((uint64_t)cond[i+1] << 32) | \n            (uint64_t)cond[i+2] | \n            ((uint64_t)cond[i+3] << 32)\n        );\n        \n        // Compute differences\n        int32x4_t diff_vec = vsubq_s32(a_vec, a_prev_vec);\n        \n        // Convert to float\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_vec);\n        \n        // Zero out where condition is false\n        diff_float_vec = vbslq_f32(cond_vec, diff_float_vec, vdupq_n_f32(0.0f));\n        \n        // Store results\n        vst1q_f32(diff + i, diff_float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t elements from source\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Convert 4 uint32_t to 4 uint64_t with high 32 bits set to 1\n        uint64x2_t dst_vec_low = vreinterpretq_u64_u32(vmovl_u32(vget_low_u32(src_vec)));\n        uint64x2_t dst_vec_high = vreinterpretq_u64_u32(vmovl_u32(vget_high_u32(src_vec)));\n        \n        // Set high 32 bits to 1\n        dst_vec_low = vorrq_u64(dst_vec_low, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        dst_vec_high = vorrq_u64(dst_vec_high, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        \n        // Store results in destination\n        vst1q_u64(dst + i, dst_vec_low);\n        vst1q_u64(dst + i + 2, dst_vec_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from source\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Convert 4 uint32_t to 4 uint64_t with high bits set to 1\n        uint64x2_t dst_vec_low = vreinterpretq_u64_u32(vmovl_u32(vget_low_u32(src_vec)));\n        uint64x2_t dst_vec_high = vreinterpretq_u64_u32(vmovl_high_u32(src_vec));\n        \n        // Set high 32 bits to 1\n        dst_vec_low = vorrq_u64(dst_vec_low, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        dst_vec_high = vorrq_u64(dst_vec_high, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        \n        // Store results in destination\n        vst1q_u64(dst + i, dst_vec_low);\n        vst1q_u64(dst + i + 2, dst_vec_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Convert to uint64x2_t with zero extension\n        uint64x2_t dst_vec_low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t dst_vec_high = vmovl_high_u32(src_vec);\n        \n        // Set high 32 bits to 1\n        dst_vec_low = vorrq_u64(dst_vec_low, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        dst_vec_high = vorrq_u64(dst_vec_high, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        \n        // Store results\n        vst1q_u64(dst + i, dst_vec_low);\n        vst1q_u64(dst + i + 2, dst_vec_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values from source\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Convert to uint64x2_t, processing two elements at a time\n        uint64x2_t dst_vec_low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t dst_vec_high = vmovl_high_u32(src_vec);\n        \n        // Set high 32 bits to 1 using bitwise OR with 0xFFFFFFFF00000000\n        uint64x2_t mask_low = vorrq_u64(dst_vec_low, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        uint64x2_t mask_high = vorrq_u64(dst_vec_high, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        \n        // Store results\n        vst1q_u64(dst + i, mask_low);\n        vst1q_u64(dst + i + 2, mask_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 uint32_t values\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        \n        // Convert to uint64x2_t with zero extension\n        uint64x2_t dst_vec_low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t dst_vec_high = vmovl_high_u32(src_vec);\n        \n        // Set high 32 bits to 1\n        uint64x2_t mask = vdupq_n_u64(0xFFFFFFFF00000000ULL);\n        dst_vec_low = vorrq_u64(dst_vec_low, mask);\n        dst_vec_high = vorrq_u64(dst_vec_high, mask);\n        \n        // Store results\n        vst1q_u64(dst + i, dst_vec_low);\n        vst1q_u64(dst + i + 2, dst_vec_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process 4 indices at a time\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        // Load 4 indices\n        int16x4_t indices_vec = vld1_s16(index + i);\n        \n        // Convert indices to 32-bit integers\n        int32x4_t indices_32 = vmovl_s16(indices_vec);\n        \n        // Load corresponding doubles using indices\n        float64x2_t vec1 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 0));\n        float64x2_t vec2 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 1));\n        float64x2_t vec3 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 2));\n        float64x2_t vec4 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 3));\n        \n        // Accumulate sums\n        sum_vec = vaddq_f64(sum_vec, vec1);\n        sum_vec = vaddq_f64(sum_vec, vec2);\n        sum_vec = vaddq_f64(sum_vec, vec3);\n        sum_vec = vaddq_f64(sum_vec, vec4);\n    }\n    \n    // Handle remaining elements\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process 4 indices at a time\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        // Load 4 indices\n        int16x4_t indices = vld1_s16(index + i);\n        \n        // Convert indices to 32-bit integers\n        int32x4_t indices_32 = vmovl_s16(indices);\n        \n        // Load corresponding doubles using indices\n        float64x2_t vec1 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 0));\n        float64x2_t vec2 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 1));\n        float64x2_t vec3 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 2));\n        float64x2_t vec4 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 3));\n        \n        // Sum the vectors\n        sum_vec = vaddq_f64(sum_vec, vec1);\n        sum_vec = vaddq_f64(sum_vec, vec2);\n        sum_vec = vaddq_f64(sum_vec, vec3);\n        sum_vec = vaddq_f64(sum_vec, vec4);\n    }\n    \n    // Handle remaining elements\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process 4 indices at a time\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        // Load 4 indices\n        int16x4_t index_vec = vld1_s16(index + i);\n        \n        // Convert indices to 32-bit integers\n        int32x4_t index_vec_32 = vmovl_s16(index_vec);\n        \n        // Load corresponding doubles using indices\n        float64x2_t vec1 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 0)]);\n        float64x2_t vec2 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 1)]);\n        float64x2_t vec3 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 2)]);\n        float64x2_t vec4 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 3)]);\n        \n        // Accumulate sums\n        sum_vec = vaddq_f64(sum_vec, vec1);\n        sum_vec = vaddq_f64(sum_vec, vec2);\n        sum_vec = vaddq_f64(sum_vec, vec3);\n        sum_vec = vaddq_f64(sum_vec, vec4);\n    }\n    \n    // Handle remaining elements\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process 4 indices at a time\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        // Load 4 indices\n        int16x4_t indices_vec = vld1_s16(index + i);\n        \n        // Convert indices to 32-bit integers\n        int32x4_t indices_32 = vmovl_s16(indices_vec);\n        \n        // Load corresponding double values\n        float64x2_t val1 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 0));\n        float64x2_t val2 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 1));\n        float64x2_t val3 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 2));\n        float64x2_t val4 = vld1q_f64(vec + vgetq_lane_s32(indices_32, 3));\n        \n        // Accumulate sums\n        sum_vec = vaddq_f64(sum_vec, val1);\n        sum_vec = vaddq_f64(sum_vec, val2);\n        sum_vec = vaddq_f64(sum_vec, val3);\n        sum_vec = vaddq_f64(sum_vec, val4);\n    }\n    \n    // Handle remaining elements\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    for (; i < length; i++) {\n        sum += vec[index[i]];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    \n    // Process 4 indices at a time\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        // Load 4 indices\n        int16x4_t index_vec = vld1_s16(index + i);\n        \n        // Convert indices to 32-bit integers\n        int32x4_t index_vec_32 = vmovl_s16(index_vec);\n        \n        // Load corresponding doubles using indices\n        float64x2_t vec1 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 0)]);\n        float64x2_t vec2 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 1)]);\n        float64x2_t vec3 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 2)]);\n        float64x2_t vec4 = vdupq_n_f64(vec[vgetq_lane_s32(index_vec_32, 3)]);\n        \n        // Accumulate sums\n        sum_vec = vaddq_f64(sum_vec, vec1);\n        sum_vec = vaddq_f64(sum_vec, vec2);\n        sum_vec = vaddq_f64(sum_vec, vec3);\n        sum_vec = vaddq_f64(sum_vec, vec4);\n    }\n    \n    // Handle remaining elements\n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    float64x2_t input_vec = vld1q_f64(&input[(i + ki) * input_size + (j + kj)]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    sum_vec = vfmaq_f64(sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Horizontal sum\n            float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n\n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    // Load input and kernel values\n                    float64_t input_val = input[(i + ki) * input_size + (j + kj)];\n                    float64_t kernel_val = kernel[ki * kernel_size + kj];\n                    \n                    // Multiply and accumulate using NEON intrinsics\n                    float64x2_t input_vec = vdupq_n_f64(input_val);\n                    float64x2_t kernel_vec = vdupq_n_f64(kernel_val);\n                    sum_vec = vfmaq_f64(sum_vec, input_vec, kernel_vec);\n                }\n            }\n            \n            // Horizontal sum of vector\n            float64_t sum = vaddvq_f64(sum_vec);\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    float64x2_t input_vec = vld1q_f64(&input[(i + ki) * input_size + j + kj]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    \n                    sum_vec = vfmaq_f64(sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Horizontal sum\n            float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    float64x2_t input_vec = vld1q_f64(&input[(i + ki) * input_size + j + kj]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    sum_vec = vfmaq_f64(sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            double sum = vaddvq_f64(sum_vec);\n            output[i * output_size + j] = sum > 0 ? sum : 0.0;  // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            float64x2_t sum_vec = vdupq_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    float64x2_t input_vec = vld1q_f64(&input[(i + ki) * input_size + j + kj]);\n                    float64x2_t kernel_vec = vld1q_f64(&kernel[ki * kernel_size + kj]);\n                    sum_vec = vfmaq_f64(sum_vec, input_vec, kernel_vec);\n                }\n            }\n\n            // Horizontal sum\n            float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n\n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using Neon\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t current = vld1q_f64(&numbers[i]);\n        \n        for (int j = i + 2; j < n; j += 2) {\n            float64x2_t compare = vld1q_f64(&numbers[j]);\n            \n            // Compute absolute differences\n            float64x2_t diff = vabdq_f64(current, compare);\n            \n            // Check if any difference is less than threshold\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            \n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n        }\n        \n        // Handle last element if odd number of elements\n        if (i + 1 < n) {\n            double current_last = numbers[i + 1];\n            \n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_last - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using 128-bit Neon registers\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t current = vld1q_f64(&numbers[i]);\n        \n        for (int j = i + 2; j < n; j += 2) {\n            float64x2_t compare = vld1q_f64(&numbers[j]);\n            \n            // Compute absolute difference\n            float64x2_t diff = vabdq_f64(current, compare);\n            \n            // Check if any difference is less than threshold\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            \n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n        }\n        \n        // Handle last element if odd number of elements\n        if (i + 1 < n) {\n            double current_val = numbers[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_val - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using Neon 128-bit registers\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t current = vld1q_f64(&numbers[i]);\n        \n        for (int j = i + 2; j < n; j += 2) {\n            float64x2_t compare = vld1q_f64(&numbers[j]);\n            \n            // Compute absolute difference\n            float64x2_t diff = vabdq_f64(current, compare);\n            \n            // Check if any difference is less than threshold\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            \n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n        }\n        \n        // Handle last element if odd number of elements\n        if (i + 1 < n) {\n            double current_last = numbers[i + 1];\n            \n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_last - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using Neon\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t current = vld1q_f64(&numbers[i]);\n        \n        for (int j = i + 2; j < n; j += 2) {\n            float64x2_t compare = vld1q_f64(&numbers[j]);\n            \n            // Compute absolute difference\n            float64x2_t diff = vabdq_f64(current, compare);\n            \n            // Check if any difference is less than threshold\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            \n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n        }\n        \n        // Handle last element if odd number of elements\n        if (i + 1 < n) {\n            double current_last = numbers[i + 1];\n            \n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_last - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using Neon\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t current = vld1q_f64(&numbers[i]);\n        \n        for (int j = i + 2; j < n; j += 2) {\n            float64x2_t compare = vld1q_f64(&numbers[j]);\n            \n            // Compute absolute differences\n            float64x2_t diff = vabdq_f64(current, compare);\n            \n            // Check if any difference is less than threshold\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            \n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n        }\n        \n        // Handle last unpaired element if odd length\n        if (i + 1 < n) {\n            double current_last = numbers[i + 1];\n            \n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_last - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int vector_size = 4; // Number of elements processed in parallel with Neon\n    \n    // Process 4 elements at a time using Neon\n    int32x4_t running_balance = vdupq_n_s32(0);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < n; i += vector_size) {\n        // Load 4 operations at a time\n        int32x4_t ops_vec = vld1q_s32(&operations[i]);\n        \n        // Update running balance\n        running_balance = vaddq_s32(running_balance, ops_vec);\n        \n        // Check if any lane is negative\n        uint32x4_t negative_mask = vcltq_s32(running_balance, zero_vec);\n        if (vaddvq_u32(negative_mask) > 0) {\n            return true;\n        }\n    }\n    \n    // Handle remaining elements\n    int running_sum = 0;\n    for (int i = (n / vector_size) * vector_size; i < n; ++i) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int vec_size = 4;\n    int num_vectors = n / vec_size;\n    int remainder = n % vec_size;\n\n    // Initialize running balance\n    int32x4_t running_balance = vdupq_n_s32(0);\n    int current_balance = 0;\n\n    // Process vectors of 4 elements\n    for (int i = 0; i < num_vectors; i++) {\n        int32x4_t vec = vld1q_s32(&operations[i * vec_size]);\n        running_balance = vaddq_s32(running_balance, vec);\n        \n        // Check if any lane goes negative\n        uint32x4_t negative_mask = vcltq_s32(running_balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(negative_mask) != 0) {\n            return true;\n        }\n    }\n\n    // Process remaining elements\n    for (int i = num_vectors * vec_size; i < n; i++) {\n        current_balance += operations[i];\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int vec_size = 4;\n    int num_vectors = n / vec_size;\n    int remainder = n % vec_size;\n\n    // Initialize running balance\n    int32x4_t running_balance = vdupq_n_s32(0);\n    int current_balance = 0;\n\n    // Process vectors in parallel\n    for (int i = 0; i < num_vectors; i++) {\n        int32x4_t vec_ops = vld1q_s32(&operations[i * vec_size]);\n        running_balance = vaddq_s32(running_balance, vec_ops);\n\n        // Check if any lane goes negative\n        uint32x4_t negative_mask = vcltq_s32(running_balance, vdupq_n_s32(0));\n        if (vmovemaskq_u32(negative_mask) != 0) {\n            return true;\n        }\n    }\n\n    // Process remaining elements\n    for (int i = num_vectors * vec_size; i < n; i++) {\n        current_balance += operations[i];\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int vector_size = 4; // Neon processes 4 integers at a time\n    \n    // Process vectors of 4 integers\n    for (int i = 0; i <= n - vector_size; i += vector_size) {\n        int32x4_t current_balance = {0, 0, 0, 0};\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        \n        current_balance = vaddq_s32(current_balance, ops);\n        \n        // Check if any lane is negative\n        uint32x4_t negative_mask = vcltq_s32(current_balance, vdupq_n_s32(0));\n        if (vmaxvq_u32(negative_mask) > 0) {\n            return true;\n        }\n    }\n    \n    // Process remaining elements\n    int running_balance = 0;\n    for (int i = (n / vector_size) * vector_size; i < n; ++i) {\n        running_balance += operations[i];\n        if (running_balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int vec_size = 4;\n    int num_vectors = n / vec_size;\n    int remainder = n % vec_size;\n\n    // Initialize running balance\n    int32x4_t running_balance = vdupq_n_s32(0);\n    int current_balance = 0;\n\n    // Process vectors of 4 elements\n    for (int i = 0; i < num_vectors; i++) {\n        int32x4_t vec_ops = vld1q_s32(&operations[i * vec_size]);\n        running_balance = vaddq_s32(running_balance, vec_ops);\n\n        // Check if any lane goes negative\n        uint32x4_t negative_mask = vcltq_s32(running_balance, vdupq_n_s32(0));\n        if (vmovemaskq_u32(negative_mask) != 0) {\n            return true;\n        }\n    }\n\n    // Process remaining elements\n    for (int i = num_vectors * vec_size; i < n; i++) {\n        current_balance += operations[i];\n        if (current_balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Handle remaining elements\n    for (int i = n - (n % 2); i < n; i++) {\n        sum += numbers[i];\n    }\n    \n    double mean = sum / n;\n\n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff);\n    }\n\n    // Handle remaining elements\n    double mad_sum = vgetq_lane_f64(mad_sum_vec, 0) + vgetq_lane_f64(mad_sum_vec, 1);\n    for (int i = n - (n % 2); i < n; i++) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Handle remaining elements\n    for (int i = n - (n % 2); i < n; i++) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff);\n    }\n    \n    // Handle remaining elements\n    double mad_sum = vgetq_lane_f64(mad_sum_vec, 0) + vgetq_lane_f64(mad_sum_vec, 1);\n    for (int i = n - (n % 2); i < n; i++) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Handle remaining elements if n is odd\n    for (int i = n - (n % 2); i < n; ++i) {\n        sum += numbers[i];\n    }\n    \n    double mean = sum / n;\n\n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff);\n    }\n\n    // Handle remaining elements if n is odd\n    double mad_sum = vgetq_lane_f64(mad_sum_vec, 0) + vgetq_lane_f64(mad_sum_vec, 1);\n    for (int i = n - (n % 2); i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Handle remaining elements\n    for (int i = n - (n % 2); i < n; ++i) {\n        sum += numbers[i];\n    }\n    \n    double mean = sum / n;\n\n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff);\n    }\n\n    // Handle remaining elements\n    double mad_sum = vgetq_lane_f64(mad_sum_vec, 0) + vgetq_lane_f64(mad_sum_vec, 1);\n    for (int i = n - (n % 2); i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, vec);\n    }\n    float64_t sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    // Handle remaining elements\n    for (int i = n - (n % 2); i < n; ++i) {\n        sum += numbers[i];\n    }\n    \n    double mean = sum / n;\n\n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t mad_sum_vec = vdupq_n_f64(0.0);\n    \n    for (int i = 0; i < n; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t abs_diff = vabdq_f64(vec, mean_vec);\n        mad_sum_vec = vaddq_f64(mad_sum_vec, abs_diff);\n    }\n    \n    // Handle remaining elements\n    double mad_sum = vgetq_lane_f64(mad_sum_vec, 0) + vgetq_lane_f64(mad_sum_vec, 1);\n    for (int i = n - (n % 2); i < n; ++i) {\n        mad_sum += std::abs(numbers[i] - mean);\n    }\n\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    // Process 4 elements at a time using Neon SIMD\n    int i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        // Load 4 consecutive elements\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n\n        // Interleave with delimiter\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n        int32x2_t vec_low = vget_low_s32(vec);\n        int32x2_t vec_high = vget_high_s32(vec);\n\n        result.push_back(vgetq_lane_s32(vec, 0));\n        result.push_back(delimeter);\n        result.push_back(vgetq_lane_s32(vec, 1));\n        result.push_back(delimeter);\n        result.push_back(vgetq_lane_s32(vec, 2));\n        result.push_back(delimeter);\n        result.push_back(vgetq_lane_s32(vec, 3));\n    }\n\n    // Process remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    // Process 4 elements at a time using NEON\n    int i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        // Load 4 elements\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        \n        // Interleave with delimiter\n        int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n        \n        // Store first element\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+1]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+2]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+3]);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    int size = numbers.size();\n    if (size <= 1) return numbers;\n\n    std::vector<int> result(size * 2 - 1);\n    int* input = numbers.data();\n    int* output = result.data();\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(input + i);\n        int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n\n        // Store first 4 elements with delimiters\n        vst1q_s32(output + 2*i, vec);\n        vst1q_s32(output + 2*i + 1, delimiter_vec);\n    }\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        result[2*i] = input[i];\n        if (i < size - 1) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    int size = numbers.size();\n    if (size <= 1) return numbers;\n\n    std::vector<int> result(size * 2 - 1);\n    int* input = numbers.data();\n    int* output = result.data();\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(input + i);\n        int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n\n        // Store original elements and delimiters alternately\n        vst1q_s32(output + 2*i, vec);\n        vst1q_s32(output + 2*i + 1, delimiter_vec);\n    }\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        result[2*i] = input[i];\n        if (i < size - 1) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        // Load 4 consecutive elements\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        \n        // Interleave with delimiter\n        int32x4_t delimiter_vec = vdupq_n_s32(delimeter);\n        \n        // Store first element\n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+1]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+2]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+3]);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    // If vector is empty, return default values\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    // Process 8 elements at a time using Neon\n    int i = 0;\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t product_vec = vdupq_n_s16(1);\n\n    // Process 8 elements at a time\n    for (; i + 7 < numbers.size(); i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, vec);\n        product_vec = vmulq_s16(product_vec, vec);\n    }\n\n    // Horizontal sum of vector\n    int16x4_t sum_low = vget_low_s16(sum_vec);\n    int16x4_t sum_high = vget_high_s16(sum_vec);\n    int16x4_t sum_total = vadd_s16(sum_low, sum_high);\n    sum_total = vpadd_s16(sum_total, sum_total);\n    sum_total = vpadd_s16(sum_total, sum_total);\n    sum = vget_lane_s16(sum_total, 0);\n\n    // Horizontal product of vector\n    int16x4_t prod_low = vget_low_s16(product_vec);\n    int16x4_t prod_high = vget_high_s16(product_vec);\n    int16x4_t prod_total = vmul_s16(prod_low, prod_high);\n    prod_total = vpmul_s16(prod_total, prod_total);\n    product = vget_lane_s16(prod_total, 0);\n\n    // Process remaining elements\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vector_size = numbers.size();\n    size_t simd_size = vector_size - (vector_size % 8);\n    \n    // SIMD processing for sum\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    for (size_t i = 0; i < simd_size; i += 8) {\n        int16x8_t current_vec = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, current_vec);\n    }\n    \n    int16_t sum_array[8];\n    vst1q_s16(sum_array, sum_vec);\n    for (int j = 0; j < 8; j++) {\n        sum += sum_array[j];\n    }\n    \n    // Remaining elements for sum\n    for (size_t i = simd_size; i < vector_size; i++) {\n        sum += numbers[i];\n    }\n    \n    // SIMD processing for product\n    int16x8_t product_vec = vdupq_n_s16(1);\n    for (size_t i = 0; i < simd_size; i += 8) {\n        int16x8_t current_vec = vld1q_s16(&numbers[i]);\n        product_vec = vmulq_s16(product_vec, current_vec);\n    }\n    \n    int16_t product_array[8];\n    vst1q_s16(product_array, product_vec);\n    for (int j = 0; j < 8; j++) {\n        product *= product_array[j];\n    }\n    \n    // Remaining elements for product\n    for (size_t i = simd_size; i < vector_size; i++) {\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vector_size = numbers.size();\n    size_t i = 0;\n    \n    // Process 8 elements at a time using Neon SIMD\n    for (; i + 8 <= vector_size; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        \n        // Sum calculation\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int64x2_t sum_wide = vpaddlq_s32(sum_low);\n        sum += vgetq_lane_s64(sum_wide, 0) + vgetq_lane_s64(sum_wide, 1);\n        \n        // Product calculation\n        int16x8_t product_vec = vec;\n        int16x8_t product_vec_shifted = vextq_s16(product_vec, product_vec, 4);\n        product_vec = vmulq_s16(product_vec, product_vec_shifted);\n        product_vec_shifted = vextq_s16(product_vec, product_vec, 2);\n        product_vec = vmulq_s16(product_vec, product_vec_shifted);\n        product_vec_shifted = vextq_s16(product_vec, product_vec, 1);\n        product_vec = vmulq_s16(product_vec, product_vec_shifted);\n        \n        product *= vgetq_lane_s16(product_vec, 0);\n    }\n    \n    // Process remaining elements\n    for (; i < vector_size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vector_size = numbers.size();\n    size_t simd_size = vector_size - (vector_size % 8);\n    \n    // SIMD processing for sum and product\n    if (simd_size > 0) {\n        int16x8_t sum_vec = vdupq_n_s16(0);\n        int16x8_t product_vec = vdupq_n_s16(1);\n        \n        for (size_t i = 0; i < simd_size; i += 8) {\n            int16x8_t current_vec = vld1q_s16(&numbers[i]);\n            sum_vec = vaddq_s16(sum_vec, current_vec);\n            product_vec = vmulq_s16(product_vec, current_vec);\n        }\n        \n        // Horizontal sum and product\n        int16_t sum_array[8];\n        int16_t product_array[8];\n        vst1q_s16(sum_array, sum_vec);\n        vst1q_s16(product_array, product_vec);\n        \n        for (int j = 0; j < 8; j++) {\n            sum += sum_array[j];\n            product *= product_array[j];\n        }\n    }\n    \n    // Process remaining elements\n    for (size_t i = simd_size; i < vector_size; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vector_size = numbers.size();\n    size_t simd_size = vector_size - (vector_size % 8);\n    \n    // SIMD processing for sum\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    for (size_t i = 0; i < simd_size; i += 8) {\n        int16x8_t current_vec = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, current_vec);\n    }\n    \n    int16_t sum_array[8];\n    vst1q_s16(sum_array, sum_vec);\n    \n    for (int i = 0; i < 8; i++) {\n        sum += sum_array[i];\n    }\n    \n    // Process remaining elements for sum\n    for (size_t i = simd_size; i < vector_size; i++) {\n        sum += numbers[i];\n    }\n    \n    // SIMD processing for product\n    int16x8_t product_vec = vdupq_n_s16(1);\n    for (size_t i = 0; i < simd_size; i += 8) {\n        int16x8_t current_vec = vld1q_s16(&numbers[i]);\n        product_vec = vmulq_s16(product_vec, current_vec);\n    }\n    \n    int16_t product_array[8];\n    vst1q_s16(product_array, product_vec);\n    \n    for (int i = 0; i < 8; i++) {\n        product *= product_array[i];\n    }\n    \n    // Process remaining elements for product\n    for (size_t i = simd_size; i < vector_size; i++) {\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    if (n == 0) return result;\n    \n    // Process first element\n    result[0] = numbers[0];\n    \n    // Process remaining elements in 4-element chunks\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load current max and current chunk\n        int32x4_t current_max = vld1q_s32(&result[i]);\n        int32x4_t current_chunk = vld1q_s32(&numbers[i]);\n        \n        // Compute max between current max and current chunk\n        int32x4_t max_vector = vmaxq_s32(current_max, current_chunk);\n        \n        // Store results\n        vst1q_s32(&result[i], max_vector);\n    }\n    \n    // Process remaining elements sequentially\n    int current_max = result[0];\n    for (; i < n; ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Handle empty vector case\n    if (n == 0) return result;\n    \n    // First element is always the max at the start\n    result[0] = numbers[0];\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 current elements\n        int32x4_t current = vld1q_s32(&numbers[i]);\n        \n        // Load previous max values\n        int32x4_t prev_max;\n        if (i == 0) {\n            prev_max = vdupq_n_s32(numbers[0]);\n        } else {\n            prev_max = vld1q_s32(&result[i-4]);\n        }\n        \n        // Compute rolling max\n        int32x4_t rolling_max = vmaxq_s32(current, prev_max);\n        \n        // Store result\n        vst1q_s32(&result[i], rolling_max);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = std::max(numbers[i], (i > 0 ? result[i-1] : numbers[0]));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Handle empty vector case\n    if (n == 0) return result;\n    \n    // First element is always the max at the start\n    result[0] = numbers[0];\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 current numbers\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        \n        // Load previous max values\n        int32x4_t prev_max_vec;\n        if (i == 0) {\n            // First iteration: use first element\n            prev_max_vec = vdupq_n_s32(numbers[0]);\n        } else {\n            prev_max_vec = vld1q_s32(&result[i-4]);\n        }\n        \n        // Compute rolling max using pairwise max\n        int32x4_t max_vec = vmaxq_s32(current_vec, prev_max_vec);\n        \n        // Store results\n        vst1q_s32(&result[i], max_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    int current_max = result[i-4];\n    for (; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Process first element\n    result[0] = numbers[0];\n    \n    // Process remaining elements using NEON\n    for (int i = 0; i < n; i += 4) {\n        int remaining = std::min(4, n - i);\n        \n        // Load current and previous max vectors\n        int32x4_t current_vec = vld1q_s32(&numbers[i]);\n        int32x4_t prev_max_vec = vld1q_s32(&result[std::max(0, i-4)]);\n        \n        // Compute rolling max\n        int32x4_t rolling_max_vec = vmaxq_s32(current_vec, prev_max_vec);\n        \n        // Store results\n        vst1q_s32(&result[i], rolling_max_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Handle empty vector case\n    if (n == 0) return result;\n    \n    // First element is always the max initially\n    result[0] = numbers[0];\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 input elements\n        int32x4_t input_vec = vld1q_s32(&numbers[i]);\n        \n        // Load previous max vector\n        int32x4_t max_vec;\n        if (i == 0) {\n            max_vec = vdupq_n_s32(numbers[0]);\n        } else {\n            max_vec = vld1q_s32(&result[i-4]);\n        }\n        \n        // Compute rolling max\n        max_vec = vmaxq_s32(input_vec, max_vec);\n        \n        // Store result\n        vst1q_s32(&result[i], max_vec);\n    }\n    \n    // Handle remaining elements\n    int current_max = result[i-4];\n    for (; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure inputs are of equal length\n    if (a.length() != b.length()) {\n        return \"\";\n    }\n\n    std::string result(a.length(), '0');\n    size_t len = a.length();\n    \n    // Process 128 bits (16 bytes) at a time\n    size_t vec_len = len / 16 * 16;\n    size_t i;\n\n    for (i = 0; i < vec_len; i += 16) {\n        // Load 16 bytes from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        // Perform bitwise XOR\n        uint8x16_t vxor = veorq_u8(va, vb);\n\n        // Store result back\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining elements\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure inputs are of equal length\n    if (a.length() != b.length()) {\n        return \"\";\n    }\n\n    std::string result(a.length(), '0');\n    size_t len = a.length();\n    \n    // Process 128 bits (16 bytes) at a time\n    size_t vec_len = len - (len % 16);\n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        \n        // Perform bitwise XOR\n        uint8x16_t vxor = veorq_u8(va, vb);\n        \n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_len; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len = std::min(a.length(), b.length());\n    std::string result(len, '0');\n\n    // Process 16 bits at a time using Neon\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        // Convert characters to binary values\n        uint8x16_t mask = vmovq_n_u8('0');\n        va = veorq_u8(va, mask);\n        vb = veorq_u8(vb, mask);\n\n        // Perform XOR\n        uint8x16_t vxor = veorq_u8(va, vb);\n\n        // Convert back to characters\n        vxor = veorq_u8(vxor, mask);\n\n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining bits\n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    int len = std::min(a.length(), b.length());\n    std::string result(len, '0');\n\n    // Process 16 bits at a time using Neon\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        // Convert ASCII '0' and '1' to actual binary values\n        va = vsubq_u8(va, vdupq_n_u8('0'));\n        vb = vsubq_u8(vb, vdupq_n_u8('0'));\n\n        // Perform bitwise XOR\n        uint8x16_t vxor = veorq_u8(va, vb);\n\n        // Convert back to ASCII '0' and '1'\n        vxor = vaddq_u8(vxor, vdupq_n_u8('0'));\n\n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure inputs are of equal length\n    if (a.length() != b.length()) {\n        return \"\";\n    }\n\n    std::string result(a.length(), '0');\n    int n = a.length();\n    \n    // Process 128 bits (16 bytes) at a time\n    int vectorized_length = n - (n % 16);\n    \n    for (int i = 0; i < vectorized_length; i += 16) {\n        // Load 16 characters from each string\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        \n        // Perform bitwise XOR\n        uint8x16_t vxor = veorq_u8(va, vb);\n        \n        // Store result back\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorized_length; i < n; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    std::vector<size_t> lengths(n);\n    \n    // Load string lengths in parallel\n    for (size_t i = 0; i < n; i += 4) {\n        size_t remaining = std::min(size_t(4), n - i);\n        uint32x4_t length_vec = vdupq_n_u32(0);\n        \n        for (size_t j = 0; j < remaining; ++j) {\n            vsetq_lane_u32(strings[i + j].length(), length_vec, j);\n        }\n        \n        vst1q_u32(&lengths[i], length_vec);\n    }\n\n    // Find max length index using NEON\n    uint32x4_t max_length_vec = vdupq_n_u32(0);\n    uint32x4_t max_index_vec = vdupq_n_u32(0);\n    \n    for (size_t i = 0; i < n; i += 4) {\n        uint32x4_t current_length_vec = vld1q_u32(&lengths[i]);\n        uint32x4_t current_index_vec = {i, i+1, i+2, i+3};\n        \n        uint32x4_t compare_mask = vcgtq_u32(current_length_vec, max_length_vec);\n        max_length_vec = vbslq_u32(compare_mask, current_length_vec, max_length_vec);\n        max_index_vec = vbslq_u32(compare_mask, current_index_vec, max_index_vec);\n    }\n\n    // Reduce to find the overall max\n    uint32_t max_length = vmaxvq_u32(max_length_vec);\n    uint32_t max_index = 0;\n    \n    for (size_t i = 0; i < n; ++i) {\n        if (lengths[i] == max_length) {\n            max_index = i;\n            break;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    std::string longest_str = strings[0];\n    size_t max_length = longest_str.length();\n\n    // Process 4 strings at a time using Neon\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load string lengths into Neon registers\n        uint32x4_t lengths = {\n            strings[i].length(),\n            strings[i+1].length(),\n            strings[i+2].length(),\n            strings[i+3].length()\n        };\n\n        // Find max length among these 4 strings\n        uint32x4_t max_lengths = vmaxq_u32(lengths, vdupq_n_u32(max_length));\n        \n        // Update longest string if needed\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(max_lengths, j) > max_length) {\n                max_length = strings[i+j].length();\n                longest_str = strings[i+j];\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (; i < n; i++) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            longest_str = strings[i];\n        }\n    }\n\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    // Process 4 strings at a time using NEON\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load string lengths into NEON registers\n        uint32x4_t lengths = {\n            strings[i].length(),\n            strings[i+1].length(),\n            strings[i+2].length(),\n            strings[i+3].length()\n        };\n\n        // Find max length among these 4 strings\n        uint32x4_t max_lengths = vmaxq_u32(lengths, __builtin_neon_vdup_lane_v(lengths, 0, 2));\n        max_lengths = vmaxq_u32(max_lengths, __builtin_neon_vdup_lane_v(max_lengths, 1, 2));\n\n        // Update longest string if needed\n        for (int j = 0; j < 4; j++) {\n            if (strings[i+j].length() > max_length) {\n                longest = strings[i+j];\n                max_length = strings[i+j].length();\n            }\n        }\n    }\n\n    // Process remaining strings sequentially\n    for (; i < n; i++) {\n        if (strings[i].length() > max_length) {\n            longest = strings[i];\n            max_length = strings[i].length();\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    // Process 4 strings at a time using NEON\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load string lengths into NEON registers\n        uint32x4_t lengths = {\n            strings[i].length(),\n            strings[i+1].length(),\n            strings[i+2].length(),\n            strings[i+3].length()\n        };\n\n        // Find max length among these 4 strings\n        uint32x4_t max_lengths = vmaxq_u32(lengths, vdupq_n_u32(max_length));\n        \n        // Update longest string if a longer one is found\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(max_lengths, j) > max_length) {\n                max_length = strings[i+j].length();\n                longest = strings[i+j];\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (; i < n; i++) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            longest = strings[i];\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    size_t max_index = 0;\n    size_t n = strings.size();\n\n    // Process 4 strings at a time using NEON\n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        uint32x4_t length_vec = {\n            strings[i].length(),\n            strings[i+1].length(),\n            strings[i+2].length(),\n            strings[i+3].length()\n        };\n\n        uint32x4_t index_vec = {i, i+1, i+2, i+3};\n\n        // Find max length and corresponding index\n        uint32x2_t max_length_low = vmax_u32(vget_low_u32(length_vec), vget_high_u32(length_vec));\n        uint32x2_t max_length_final = vpmax_u32(max_length_low, max_length_low);\n        uint32_t current_max_length = vget_lane_u32(max_length_final, 0);\n\n        uint32x2_t max_index_low = vmax_u32(vget_low_u32(index_vec), vget_high_u32(index_vec));\n        uint32x2_t max_index_final = vpmax_u32(max_index_low, max_index_low);\n        uint32_t current_max_index = vget_lane_u32(max_index_final, 0);\n\n        if (current_max_length > max_length) {\n            max_length = current_max_length;\n            max_index = current_max_index;\n        }\n    }\n\n    // Process remaining strings\n    for (; i < n; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Neon doesn't provide direct GCD instructions, so we'll use scalar Euclidean algorithm\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Neon doesn't provide direct GCD instructions, so we'll use scalar Euclidean algorithm\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Neon doesn't provide direct GCD instructions, so we'll use scalar Euclidean algorithm\n    // SIMD is not particularly beneficial for GCD due to its sequential nature\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Neon doesn't provide direct GCD instructions, so we'll use scalar Euclidean algorithm\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    // Neon doesn't provide direct GCD instructions, so we'll use scalar Euclidean algorithm\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```\n\nNote: While the problem asks for a SIMD implementation, the Euclidean algorithm for GCD is inherently sequential and doesn't naturally parallelize. The Neon intrinsics are most effective for data-parallel operations, which this algorithm does not support. The implementation above is a standard scalar approach."}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 4; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            float32x4_t diff_vec = vabdq_f32(current_vec, vdupq_n_f32(numbers[j]));\n            float32x4_t min_diff_vec = vminq_f32(diff_vec, vdupq_n_f32(min_diff));\n            \n            // Horizontal min to find smallest difference\n            float32x2_t min_diff_low = vmin_f32(vget_low_f32(min_diff_vec), vget_high_f32(min_diff_vec));\n            min_diff_low = vpmin_f32(min_diff_low, min_diff_low);\n            float current_min_diff = vget_lane_f32(min_diff_low, 0);\n            \n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                closest_a = numbers[i + vminvq_f32(diff_vec)];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - 4; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 4; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            float32x4_t diff_vec = vabdq_f32(current_vec, vdupq_n_f32(numbers[j]));\n            float32x2_t diff_low = vget_low_f32(diff_vec);\n            float32x2_t diff_high = vget_high_f32(diff_vec);\n            \n            float min_diff_vec = vminv_f32(diff_low);\n            float min_diff_vec_high = vminv_f32(diff_high);\n            \n            if (min_diff_vec < min_diff) {\n                min_diff = min_diff_vec;\n                closest_a = numbers[i + vminvq_index_f32(diff_low)];\n                closest_b = numbers[j];\n            }\n            \n            if (min_diff_vec_high < min_diff) {\n                min_diff = min_diff_vec_high;\n                closest_a = numbers[i + 2 + vminvq_index_f32(diff_high)];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    return {std::min(closest_a, closest_b), std::max(closest_a, closest_b)};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 4; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            float32x4_t diff_vec = vabdq_f32(current_vec, vdupq_n_f32(numbers[j]));\n            \n            // Horizontal min to find smallest difference\n            float32x2_t diff_low = vget_low_f32(diff_vec);\n            float32x2_t diff_high = vget_high_f32(diff_vec);\n            float32x2_t min_diff_vec = vpmin_f32(diff_low, diff_high);\n            float min_local_diff = vget_lane_f32(min_diff_vec, 0);\n            \n            if (min_local_diff < min_diff) {\n                min_diff = min_local_diff;\n                closest_a = numbers[i + vminv_f32(diff_vec)];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0], second = numbers[1];\n\n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 4; i += 4) {\n        float32x4_t vec1 = vld1q_f32(&numbers[i]);\n        float32x4_t vec2 = vld1q_f32(&numbers[i+1]);\n\n        // Compute absolute differences between adjacent elements\n        float32x4_t diff_vec = vabdq_f32(vec1, vec2);\n\n        // Find minimum difference using horizontal min\n        float32x2_t diff_low = vget_low_f32(diff_vec);\n        float32x2_t diff_high = vget_high_f32(diff_vec);\n        float32x2_t min_diff_vec = vpmin_f32(diff_low, diff_high);\n        float min_local_diff = vget_lane_f32(min_diff_vec, 0);\n\n        // Update global minimum if needed\n        if (min_local_diff < min_diff) {\n            min_diff = min_local_diff;\n            first = numbers[i + vminv_f32(diff_vec)];\n            second = numbers[i + vminv_f32(diff_vec) + 1];\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - 4; i < n - 1; i++) {\n        float diff = std::abs(numbers[i] - numbers[i+1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = std::min(numbers[i], numbers[i+1]);\n            second = std::max(numbers[i], numbers[i+1]);\n        }\n    }\n\n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 4; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            float32x4_t diff_vec = vabdq_f32(current_vec, vdupq_n_f32(numbers[j]));\n            \n            // Horizontal min across the vector\n            float32x2_t diff_low = vget_low_f32(diff_vec);\n            float32x2_t diff_high = vget_high_f32(diff_vec);\n            float32x2_t min_diff_vec = vpmin_f32(diff_low, diff_high);\n            float min_local = vget_lane_f32(min_diff_vec, 0);\n            \n            if (min_local < min_diff) {\n                min_diff = min_local;\n                closest_a = (min_local == std::abs(current_vec[0] - numbers[j])) ? current_vec[0] : \n                            (min_local == std::abs(current_vec[1] - numbers[j])) ? current_vec[1] : \n                            (min_local == std::abs(current_vec[2] - numbers[j])) ? current_vec[2] : current_vec[3];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using NEON\n    float32x4_t min_vec = vld1q_f32(numbers.data());\n    float32x4_t max_vec = min_vec;\n    \n    for (size_t i = 4; i < numbers.size(); i += 4) {\n        float32x4_t current_vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, current_vec);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    // Handle remaining elements\n    float global_min = vminvq_f32(min_vec);\n    float global_max = vmaxvq_f32(max_vec);\n    \n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        global_min = std::min(global_min, numbers[i]);\n        global_max = std::max(global_max, numbers[i]);\n    }\n\n    // Compute scaling factor\n    float32x4_t min_broadcast = vdupq_n_f32(global_min);\n    float32x4_t scale_broadcast = vdupq_n_f32(global_max - global_min);\n\n    std::vector<float> result(numbers.size());\n    \n    // Vectorized rescaling\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t current_vec = vld1q_f32(&numbers[i]);\n        float32x4_t scaled_vec = vdivq_f32(vsubq_f32(current_vec, min_broadcast), scale_broadcast);\n        vst1q_f32(&result[i], scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - global_min) / (global_max - global_min);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using NEON\n    float32x4_t min_vec = vld1q_f32(numbers.data());\n    float32x4_t max_vec = min_vec;\n    \n    for (size_t i = 4; i < numbers.size(); i += 4) {\n        float32x4_t curr_vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, curr_vec);\n        max_vec = vmaxq_f32(max_vec, curr_vec);\n    }\n\n    // Handle remaining elements\n    float global_min = vminvq_f32(min_vec);\n    float global_max = vmaxvq_f32(max_vec);\n    \n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        global_min = std::min(global_min, numbers[i]);\n        global_max = std::max(global_max, numbers[i]);\n    }\n\n    // Compute scaling factor\n    float32x4_t min_broadcast = vdupq_n_f32(global_min);\n    float32x4_t scale_factor = vdupq_n_f32(global_max - global_min != 0 ? 1.0f / (global_max - global_min) : 0.0f);\n\n    // Rescale vector\n    std::vector<float> result(numbers.size());\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t curr_vec = vld1q_f32(&numbers[i]);\n        float32x4_t scaled_vec = vmulq_f32(vsubq_f32(curr_vec, min_broadcast), scale_factor);\n        vst1q_f32(&result[i], scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - global_min) / (global_max - global_min);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using NEON\n    float32x4_t min_vec = vld1q_f32(numbers.data());\n    float32x4_t max_vec = min_vec;\n    \n    for (size_t i = 4; i < numbers.size(); i += 4) {\n        float32x4_t curr_vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, curr_vec);\n        max_vec = vmaxq_f32(max_vec, curr_vec);\n    }\n\n    // Handle remaining elements\n    float global_min = vminvq_f32(min_vec);\n    float global_max = vmaxvq_f32(max_vec);\n    \n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        global_min = std::min(global_min, numbers[i]);\n        global_max = std::max(global_max, numbers[i]);\n    }\n\n    // Compute scaling factor\n    float32x4_t min_val = vdupq_n_f32(global_min);\n    float32x4_t max_val = vdupq_n_f32(global_max);\n    float32x4_t range_val = vsubq_f32(max_val, min_val);\n\n    std::vector<float> result(numbers.size());\n\n    // Vectorized rescaling\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t curr_vec = vld1q_f32(&numbers[i]);\n        float32x4_t scaled_vec = vdivq_f32(vsubq_f32(curr_vec, min_val), range_val);\n        vst1q_f32(&result[i], scaled_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - global_min) / (global_max - global_min);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using NEON\n    float32x4_t min_vec = vld1q_f32(numbers.data());\n    float32x4_t max_vec = min_vec;\n    \n    for (size_t i = 4; i < numbers.size(); i += 4) {\n        float32x4_t curr_vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, curr_vec);\n        max_vec = vmaxq_f32(max_vec, curr_vec);\n    }\n\n    // Handle remaining elements\n    float global_min = vminvq_f32(min_vec);\n    float global_max = vmaxvq_f32(max_vec);\n    \n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        global_min = std::min(global_min, numbers[i]);\n        global_max = std::max(global_max, numbers[i]);\n    }\n\n    // Compute scaling factor\n    float32x4_t min_broadcast = vdupq_n_f32(global_min);\n    float32x4_t scale_broadcast = vdupq_n_f32(global_max - global_min);\n\n    // Rescale vector\n    std::vector<float> result(numbers.size());\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t curr_vec = vld1q_f32(&numbers[i]);\n        float32x4_t scaled_vec = vdivq_f32(vsubq_f32(curr_vec, min_broadcast), scale_broadcast);\n        vst1q_f32(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using NEON\n    float32x4_t min_vec = vld1q_f32(numbers.data());\n    float32x4_t max_vec = min_vec;\n    \n    for (size_t i = 4; i < numbers.size(); i += 4) {\n        float32x4_t current = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, current);\n        max_vec = vmaxq_f32(max_vec, current);\n    }\n\n    // Handle remaining elements\n    float global_min = vminvq_f32(min_vec);\n    float global_max = vmaxvq_f32(max_vec);\n    \n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        global_min = std::min(global_min, numbers[i]);\n        global_max = std::max(global_max, numbers[i]);\n    }\n\n    // Compute scale factor\n    float scale = (global_max == global_min) ? 0.0f : 1.0f / (global_max - global_min);\n    float32x4_t scale_vec = vdupq_n_f32(scale);\n    float32x4_t min_vec_broadcast = vdupq_n_f32(global_min);\n\n    // Rescale vector\n    std::vector<float> result(numbers.size());\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        float32x4_t current = vld1q_f32(&numbers[i]);\n        float32x4_t scaled = vmulq_f32(vsubq_f32(current, min_vec_broadcast), scale_vec);\n        vst1q_f32(&result[i], scaled);\n    }\n\n    // Handle remaining elements\n    for (size_t i = numbers.size() - (numbers.size() % 4); i < numbers.size(); ++i) {\n        result[i] = (numbers[i] - global_min) * scale;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Use NEON vector processing for parallel divisor search\n    uint64x2_t candidates_vec = {n/2, n/2};\n    uint64x2_t one_vec = {1, 1};\n    uint64x2_t n_vec = {n, n};\n\n    // Parallel search for divisors\n    for (int i = 0; i < 2; i++) {\n        uint64x2_t current_vec = vshrq_n_u64(n_vec, 1);\n        uint64x2_t remainder_vec = vdivq_u64(n_vec, current_vec);\n        uint64x2_t is_divisor_vec = vceqq_u64(vmulq_u64(remainder_vec, current_vec), n_vec);\n\n        if (vgetq_lane_u64(is_divisor_vec, 0)) {\n            return vgetq_lane_u64(current_vec, 0);\n        }\n        if (vgetq_lane_u64(is_divisor_vec, 1)) {\n            return vgetq_lane_u64(current_vec, 1);\n        }\n\n        candidates_vec = vshrq_n_u64(candidates_vec, 1);\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Use NEON vector processing for divisor search\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_candidates = {n/2, n/2};\n    uint64x2_t vec_zero = vdupq_n_u64(0);\n\n    // Parallel divisibility checks\n    for (int i = 0; i < 2; i++) {\n        uint64x2_t vec_remainder = vdupq_n_u64(0);\n        \n        // Compute remainder using vector division\n        vec_remainder = vdivq_u64(vec_n, vec_candidates);\n        vec_remainder = vmulq_u64(vec_remainder, vec_candidates);\n        vec_remainder = vsubq_u64(vec_n, vec_remainder);\n\n        // Check if remainder is zero\n        uint64x2_t vec_mask = vceqzq_u64(vec_remainder);\n        \n        // If divisible, return the candidate\n        if (vgetq_lane_u64(vec_mask, 0) || vgetq_lane_u64(vec_mask, 1)) {\n            return vgetq_lane_u64(vec_candidates, i);\n        }\n\n        // Reduce candidates\n        vec_candidates = vsubq_u64(vec_candidates, vdupq_n_u64(1));\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // If n is 1, return 1\n    if (n <= 1) return 1;\n\n    // Use NEON vector operations to find divisors in parallel\n    uint64x2_t divisor_vec = vdupq_n_u64(1);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t max_divisor_vec = vdupq_n_u64(1);\n\n    // Unroll loop to process multiple potential divisors simultaneously\n    for (uint64_t i = 2; i * i <= n; i += 2) {\n        uint64x2_t current_divisors = {i, i+1};\n        uint64x2_t mod_results = {n % i, n % (i+1)};\n\n        // Check divisibility using vector comparison\n        uint64x2_t is_divisible = vceqzq_u64(mod_results);\n        uint64x2_t valid_divisors = vandq_u64(current_divisors, is_divisible);\n\n        // Update max divisor\n        max_divisor_vec = vmaxq_u64(max_divisor_vec, valid_divisors);\n    }\n\n    // Reduce vector to find max divisor\n    uint64_t max_divisor = vmaxvq_u64(max_divisor_vec);\n\n    // Fallback for remaining cases\n    if (max_divisor == 1) {\n        for (uint64_t i = n/2; i >= 1; i--) {\n            if (n % i == 0) return i;\n        }\n    }\n\n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Use NEON vector to check multiple divisors in parallel\n    uint64x2_t divisors = vdupq_n_u64(1);\n    uint64x2_t max_divisors = vdupq_n_u64(0);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n\n    // Check divisors from 2 to sqrt(n) in parallel\n    for (uint64_t i = 2; i * i <= n; i += 2) {\n        // Load potential divisors\n        divisors = vsetq_lane_u64(i, divisors, 0);\n        divisors = vsetq_lane_u64(i + 1, divisors, 1);\n\n        // Check if divisors divide n evenly\n        uint64x2_t remainder_check = vdupq_n_u64(0);\n        remainder_check = vceqq_u64(vmovq_n_u64(0), vremq_u64(n_vec, divisors));\n\n        // Update max divisors if condition is met\n        max_divisors = vbslq_u64(remainder_check, divisors, max_divisors);\n    }\n\n    // Find the maximum of the two parallel results\n    uint64_t result1 = vgetq_lane_u64(max_divisors, 0);\n    uint64_t result2 = vgetq_lane_u64(max_divisors, 1);\n    return result1 > result2 ? result1 : result2;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Use Neon vector to check multiple divisors in parallel\n    uint64x2_t candidates = {n/2, n/2 + 1};\n    uint64x2_t result = {0, 0};\n    uint64x2_t input = {n, n};\n\n    // Vectorized divisibility check\n    for (uint64_t i = n/2; i > 0; i -= 2) {\n        uint64x2_t divisors = {i, i-1};\n        uint64x2_t mod_result = {n % i, n % (i-1)};\n        \n        // Create mask for zero modulo results\n        uint64x2_t zero_mask = vceqzq_u64(mod_result);\n        \n        // Update result using mask\n        result = vbslq_u64(zero_mask, divisors, result);\n    }\n\n    // Return the maximum of the two parallel results\n    return vmaxvq_u64(result);\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use Neon vector to parallelize factor finding\n    int32x4_t divisors = vdupq_n_s32(2);\n    \n    while (n > 1) {\n        // Parallel division checks\n        int32x4_t candidates = {2, 3, 5, 7};\n        uint32x4_t mask = vcgeq_s32(vdupq_n_s32(n), candidates);\n        \n        for (int i = 0; i < 4; i++) {\n            if (vgetq_lane_u32(mask, i)) {\n                int divisor = vgetq_lane_s32(candidates, i);\n                while (n % divisor == 0) {\n                    factors.push_back(divisor);\n                    n /= divisor;\n                }\n            }\n        }\n        \n        // If no small factors found, increment search range\n        if (factors.size() == 0) {\n            for (int i = 11; i * i <= n; i += 2) {\n                while (n % i == 0) {\n                    factors.push_back(i);\n                    n /= i;\n                }\n            }\n        }\n        \n        // Handle prime number case\n        if (n > 1) {\n            factors.push_back(n);\n            break;\n        }\n    }\n    \n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use Neon SIMD for parallel factorization\n    int32x4_t divisors = vdupq_n_s32(2);\n    int current = n;\n    \n    // Vectorized division loop\n    for (int i = 0; i < 4; ++i) {\n        int32x4_t div_results = vdupq_n_s32(0);\n        \n        // Parallel division checks\n        while (current % vgetq_lane_s32(divisors, i) == 0) {\n            current /= vgetq_lane_s32(divisors, i);\n            factors.push_back(vgetq_lane_s32(divisors, i));\n        }\n        \n        // Increment divisors in parallel\n        divisors = vaddq_s32(divisors, vdupq_n_s32(1));\n    }\n    \n    // Handle remaining factors sequentially\n    for (int div = 7; div * div <= current; div += 2) {\n        while (current % div == 0) {\n            factors.push_back(div);\n            current /= div;\n        }\n    }\n    \n    // Add final prime factor if greater than 1\n    if (current > 1) {\n        factors.push_back(current);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use Neon vector registers for parallel factorization\n    int32x4_t divisors = vdupq_n_s32(2);\n    int32x4_t current = vdupq_n_s32(n);\n    \n    // Parallel factorization using Neon intrinsics\n    for (int i = 0; i < 4; i++) {\n        int32_t divisor = vgetq_lane_s32(divisors, i);\n        \n        while (vgetq_lane_s32(current, i) % divisor == 0) {\n            factors.push_back(divisor);\n            current = vsetq_lane_s32(vgetq_lane_s32(current, i) / divisor, current, i);\n        }\n        \n        // Increment divisors in parallel\n        divisors = vaddq_s32(divisors, vdupq_n_s32(1));\n    }\n    \n    // Handle remaining factors sequentially\n    int remaining = vgetq_lane_s32(current, 0);\n    for (int div = 5; div * div <= remaining; div += 2) {\n        while (remaining % div == 0) {\n            factors.push_back(div);\n            remaining /= div;\n        }\n    }\n    \n    if (remaining > 1) {\n        factors.push_back(remaining);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use Neon SIMD for parallel factorization\n    int32x4_t divisors = vdupq_n_s32(2);\n    int current = n;\n    \n    // Parallel division using Neon vector operations\n    for (int i = 0; i < 4; i++) {\n        int32x4_t div_vector = divisors;\n        \n        while (current > 1) {\n            int32x4_t compare = vcleq_s32(div_vector, vdupq_n_s32(sqrt(current)));\n            \n            uint32x4_t mask = vandq_u32(compare, vcezq_s32(vdupq_n_s32(current % vgetq_lane_s32(div_vector, 0))));\n            \n            if (vgetq_lane_u32(mask, 0)) {\n                while (current % vgetq_lane_s32(div_vector, 0) == 0) {\n                    factors.push_back(vgetq_lane_s32(div_vector, 0));\n                    current /= vgetq_lane_s32(div_vector, 0);\n                }\n            }\n            \n            div_vector = vaddq_s32(div_vector, vdupq_n_s32(1));\n        }\n    }\n    \n    // Sort factors\n    std::sort(factors.begin(), factors.end());\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use Neon vector registers for parallel factorization\n    int32x4_t divisors = vdupq_n_s32(2);  // Initialize divisors vector with 2\n    int32x4_t current = vdupq_n_s32(n);   // Current number to factorize\n    \n    // Parallel factorization using vector operations\n    for (int div = 0; div < 4; ++div) {\n        int32_t divisor = vgetq_lane_s32(divisors, div);\n        \n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        \n        // Update divisors vector if needed\n        if (div < 3) {\n            int32_t next_divisor = (div == 0) ? 3 : divisor + 2;\n            divisors = vsetq_lane_s32(next_divisor, divisors, div + 1);\n        }\n        \n        if (n == 1) break;\n    }\n    \n    // Handle remaining prime factors sequentially\n    for (int divisor = 5; divisor * divisor <= n; divisor += 2) {\n        while (n % divisor == 0) {\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n    }\n    \n    // Add final prime factor if greater than 1\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Process 4 elements at a time using Neon SIMD\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        float32x4_t positive = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n        \n        float temp[4];\n        vst1q_f32(temp, positive);\n        \n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Process 4 elements at a time using Neon SIMD\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        float32x4_t positive = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n        \n        float temp[4];\n        vst1q_f32(temp, positive);\n        \n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Process 4 elements at a time using Neon SIMD\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        float32x4_t positive = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n        \n        float temp[4];\n        vst1q_f32(temp, positive);\n        \n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Process 4 elements at a time using Neon SIMD\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        float32x4_t positive = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n        \n        float temp[4];\n        vst1q_f32(temp, positive);\n        \n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Process 4 elements at a time using Neon SIMD\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0));\n        float32x4_t positive = vbslq_f32(mask, vec, vdupq_n_f32(0));\n        \n        float temp[4];\n        vst1q_f32(temp, positive);\n        \n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    int64_t limit = sqrt_n + 1;\n\n    // Process 4 divisors at a time using NEON\n    int64x2_t divisors_vec1 = {5, 7};\n    int64x2_t divisors_vec2 = {11, 13};\n    int64x2_t step_vec = {6, 6};\n\n    for (int64_t i = 0; i < limit; i += 12) {\n        // Check first vector of divisors\n        int64x2_t current_divisors1 = vaddq_s64(divisors_vec1, vmovq_n_s64(i));\n        int64x2_t mod_results1 = {n % current_divisors1[0], n % current_divisors1[1]};\n        \n        // Check second vector of divisors\n        int64x2_t current_divisors2 = vaddq_s64(divisors_vec2, vmovq_n_s64(i));\n        int64x2_t mod_results2 = {n % current_divisors2[0], n % current_divisors2[1]};\n\n        // If any divisor divides n without remainder, it's not prime\n        if (mod_results1[0] == 0 || mod_results1[1] == 0 || \n            mod_results2[0] == 0 || mod_results2[1] == 0) {\n            return false;\n        }\n\n        // Update divisors\n        divisors_vec1 = vaddq_s64(divisors_vec1, step_vec);\n        divisors_vec2 = vaddq_s64(divisors_vec2, step_vec);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    \n    // Process 4 potential divisors at a time\n    for (int64_t i = 5; i <= sqrt_n; i += 12) {\n        // Load 4 potential divisors\n        int64x2_t divisors1 = {i, i+2};\n        int64x2_t divisors2 = {i+4, i+6};\n        \n        // Compute modulo operations in parallel\n        int64x2_t mod1 = {n % i, n % (i+2)};\n        int64x2_t mod2 = {n % (i+4), n % (i+6)};\n        \n        // Check if any of these are zero\n        uint64x2_t zero_check1 = vceqzq_u64(vreinterpretq_u64_s64(mod1));\n        uint64x2_t zero_check2 = vceqzq_u64(vreinterpretq_u64_s64(mod2));\n        \n        // If any modulo is zero, n is not prime\n        if (vgetq_lane_u64(zero_check1, 0) || vgetq_lane_u64(zero_check1, 1) ||\n            vgetq_lane_u64(zero_check2, 0) || vgetq_lane_u64(zero_check2, 1)) {\n            return false;\n        }\n    }\n    \n    // Check remaining potential divisors\n    for (int64_t i = sqrt_n - (sqrt_n % 12) + 12; i <= sqrt_n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    \n    // Process 4 potential divisors in parallel\n    for (int64_t i = 5; i <= sqrt_n; i += 4) {\n        int64x2_t divisors = {i, i+2};\n        int64x2_t next_divisors = {i+1, i+3};\n        \n        uint64x2_t mod_divisors = {static_cast<uint64_t>(n % divisors[0]), \n                                   static_cast<uint64_t>(n % divisors[1])};\n        uint64x2_t mod_next_divisors = {static_cast<uint64_t>(n % next_divisors[0]), \n                                        static_cast<uint64_t>(n % next_divisors[1])};\n        \n        if (mod_divisors[0] == 0 || mod_divisors[1] == 0 || \n            mod_next_divisors[0] == 0 || mod_next_divisors[1] == 0) {\n            return false;\n        }\n    }\n    \n    // Check remaining potential divisors\n    for (int64_t i = (sqrt_n / 4) * 4 + 5; i <= sqrt_n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    int64_t step = 6;\n\n    // Use Neon to check divisibility in parallel\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_step = vdupq_n_s64(step);\n\n    for (int64_t i = 5; i <= sqrt_n; i += step) {\n        int64x2_t vec_i = {i, i + 1};\n        \n        // Check divisibility of n by i and i+1\n        int64x2_t vec_mod_1 = vmodq_s64(vec_n, vec_i);\n        int64x2_t vec_mod_2 = vmodq_s64(vec_n, vaddq_s64(vec_i, vec_step));\n\n        // If any modulo is zero, n is not prime\n        if (vgetq_lane_s64(vec_mod_1, 0) == 0 || \n            vgetq_lane_s64(vec_mod_1, 1) == 0 || \n            vgetq_lane_s64(vec_mod_2, 0) == 0 || \n            vgetq_lane_s64(vec_mod_2, 1) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    int64_t vec_size = (sqrt_n / 2 + 3) & ~3;  // Round up to multiple of 4\n\n    int64x2_t n_vec = vdupq_n_s64(n);\n    int64x2_t two_vec = vdupq_n_s64(2);\n    int64x2_t zero_vec = vdupq_n_s64(0);\n\n    for (int64_t i = 3; i <= sqrt_n; i += 8) {\n        int64x2_t i_vec1 = {i, i+2};\n        int64x2_t i_vec2 = {i+4, i+6};\n\n        uint64x2_t mod_result1 = vreinterpretq_u64_s64(vmodq_s64(n_vec, i_vec1));\n        uint64x2_t mod_result2 = vreinterpretq_u64_s64(vmodq_s64(n_vec, i_vec2));\n\n        uint64x2_t zero_check1 = vceqq_u64(mod_result1, zero_vec);\n        uint64x2_t zero_check2 = vceqq_u64(mod_result2, zero_vec);\n\n        if (vgetq_lane_u64(zero_check1, 0) || vgetq_lane_u64(zero_check1, 1) ||\n            vgetq_lane_u64(zero_check2, 0) || vgetq_lane_u64(zero_check2, 1)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Check if string contains no letters\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n    \n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string using Neon SIMD\n    size_t vectorLen = len - (len % 16);\n    \n    for (size_t i = 0; i < vectorLen; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Check for uppercase letters\n        uint8x16_t upperMask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t upperCheckMask = vcleq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t isUpperMask = vandq_u8(upperMask, upperCheckMask);\n        \n        // Check for lowercase letters\n        uint8x16_t lowerMask = vcgeq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t lowerCheckMask = vcleq_u8(chars, vdupq_n_u8('z'));\n        uint8x16_t isLowerMask = vandq_u8(lowerMask, lowerCheckMask);\n        \n        // Swap case for letters\n        uint8x16_t upperToLower = vsubq_u8(chars, vdupq_n_u8(32));\n        uint8x16_t lowerToUpper = vaddq_u8(chars, vdupq_n_u8(32));\n        \n        uint8x16_t swappedChars = vbslq_u8(isUpperMask, upperToLower, \n                                   vbslq_u8(isLowerMask, lowerToUpper, chars));\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), swappedChars);\n    }\n    \n    // Process remaining characters\n    for (size_t i = vectorLen; i < len; ++i) {\n        if (std::islower(s[i])) {\n            result[i] = std::toupper(s[i]);\n        } else if (std::isupper(s[i])) {\n            result[i] = std::tolower(s[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n    \n    std::string result = s;\n    size_t len = s.length();\n    \n    // Check if any letter exists\n    bool has_letter = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    // If no letters, simply reverse the string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string using Neon SIMD\n    size_t vector_len = len - (len % 16);\n    \n    for (size_t i = 0; i < vector_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Lowercase to uppercase\n        uint8x16_t lower_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgtq_u8(chars, vdupq_n_u8('z'));\n        uint8x16_t lowercase_range_mask = vandq_u8(vmvnq_u8(lower_mask), vmvnq_u8(upper_mask));\n        \n        uint8x16_t uppercase_chars = vsubq_u8(chars, vdupq_n_u8(32));\n        uint8x16_t lowercase_chars = vaddq_u8(chars, vdupq_n_u8(32));\n        \n        uint8x16_t case_swapped = vbslq_u8(lowercase_range_mask, \n            vbslq_u8(vcltq_u8(chars, vdupq_n_u8('a')), uppercase_chars, lowercase_chars), \n            chars);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), case_swapped);\n    }\n    \n    // Process remaining characters\n    for (size_t i = vector_len; i < len; ++i) {\n        if (std::islower(result[i])) {\n            result[i] = std::toupper(result[i]);\n        } else if (std::isupper(result[i])) {\n            result[i] = std::tolower(result[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    bool has_letter = false;\n\n    // Check if string contains letters\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    // If no letters, reverse the entire string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Process string in 16-byte chunks using Neon\n    size_t vector_len = len - (len % 16);\n    for (size_t i = 0; i < vector_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Detect uppercase letters\n        uint8x16_t uppercase_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t uppercase_max_mask = vcleq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t is_uppercase = vandq_u8(uppercase_mask, uppercase_max_mask);\n\n        // Detect lowercase letters\n        uint8x16_t lowercase_mask = vcgeq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t lowercase_max_mask = vcleq_u8(chars, vdupq_n_u8('z'));\n        uint8x16_t is_lowercase = vandq_u8(lowercase_mask, lowercase_max_mask);\n\n        // Swap case for letters\n        uint8x16_t case_swap_mask = veorq_u8(is_uppercase, is_lowercase);\n        uint8x16_t case_swap_val = vbslq_u8(is_uppercase, vdupq_n_u8(32), vdupq_n_u8(-32));\n        uint8x16_t swapped_chars = vaddq_u8(chars, vbslq_u8(case_swap_mask, case_swap_val, vdupq_n_u8(0)));\n\n        // Store result back\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), swapped_chars);\n    }\n\n    // Process remaining characters sequentially\n    for (size_t i = vector_len; i < len; ++i) {\n        if (std::islower(s[i])) {\n            result[i] = std::toupper(s[i]);\n        } else if (std::isupper(s[i])) {\n            result[i] = std::tolower(s[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t len = s.length();\n    size_t vec_size = len - (len % 16);\n\n    // Process 16 characters at a time using Neon\n    for (size_t i = 0; i < vec_size; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for lowercase letters (a-z)\n        uint8x16_t is_lower = vandq_u8(vcgeq_u8(chars, vdupq_n_u8('a')), vcleq_u8(chars, vdupq_n_u8('z')));\n        \n        // Check for uppercase letters (A-Z)\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(chars, vdupq_n_u8('A')), vcleq_u8(chars, vdupq_n_u8('Z')));\n        \n        // Swap case for lowercase letters\n        uint8x16_t lower_swap = vsubq_u8(chars, vdupq_n_u8(32));\n        lower_swap = vandq_u8(lower_swap, is_lower);\n        \n        // Swap case for uppercase letters\n        uint8x16_t upper_swap = vaddq_u8(chars, vdupq_n_u8(32));\n        upper_swap = vandq_u8(upper_swap, is_upper);\n        \n        // Combine swapped cases\n        uint8x16_t swapped_chars = vorrq_u8(lower_swap, upper_swap);\n        swapped_chars = vorrq_u8(swapped_chars, vandq_u8(chars, veorq_u8(is_lower, is_upper)));\n        \n        // Store back to result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), swapped_chars);\n    }\n\n    // Process remaining characters\n    for (size_t i = vec_size; i < len; ++i) {\n        if (islower(result[i])) {\n            result[i] = toupper(result[i]);\n        } else if (isupper(result[i])) {\n            result[i] = tolower(result[i]);\n        }\n    }\n\n    // If no letters found, reverse the string\n    bool has_letters = false;\n    for (char c : result) {\n        if (isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n    \n    std::string result = s;\n    size_t len = s.length();\n    \n    // Check if any letters exist\n    bool has_letters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n    \n    // If no letters, reverse the entire string\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string using Neon SIMD\n    size_t vector_len = len - (len % 16);\n    \n    for (size_t i = 0; i < vector_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&result[i]));\n        \n        // Uppercase check: between 'a' and 'z'\n        uint8x16_t is_lower = vandq_u8(vcgeq_u8(chars, vdupq_n_u8('a')), \n                                       vcleq_u8(chars, vdupq_n_u8('z')));\n        \n        // Lowercase check: between 'A' and 'Z'\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(chars, vdupq_n_u8('A')), \n                                       vcleq_u8(chars, vdupq_n_u8('Z')));\n        \n        // Toggle case using XOR with 32\n        uint8x16_t toggled_chars = veorq_u8(chars, vandq_u8(is_lower, vdupq_n_u8(32)));\n        toggled_chars = veorq_u8(toggled_chars, vandq_u8(is_upper, vdupq_n_u8(32)));\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), toggled_chars);\n    }\n    \n    // Process remaining characters\n    for (size_t i = vector_len; i < len; ++i) {\n        if (std::islower(result[i])) {\n            result[i] = std::toupper(result[i]);\n        } else if (std::isupper(result[i])) {\n            result[i] = std::tolower(result[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    // Create a copy of the input vector\n    std::vector<int> result = l;\n\n    // Extract elements divisible by 3\n    std::vector<int> third_elements;\n    for (int i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements using NEON\n    int sorted_size = third_elements.size();\n    for (int i = 0; i < sorted_size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&third_elements[i]);\n        vec = vrev64q_s32(vec);\n        vec = vcombine_s32(vget_high_s32(vec), vget_low_s32(vec));\n        vec = vqsortq_s32(vec);\n        vst1q_s32(&third_elements[i], vec);\n    }\n\n    // Handle remaining elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Reconstruct the result vector\n    int third_idx = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = third_elements[third_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 3) {\n        std::sort(l.begin(), l.end());\n        return l;\n    }\n\n    std::vector<int> result(n);\n    int third_count = n / 3;\n    std::vector<int> third_indices;\n\n    // Collect indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        third_indices.push_back(i);\n    }\n\n    // Extract values at indices divisible by 3\n    std::vector<int> third_values;\n    for (int idx : third_indices) {\n        third_values.push_back(l[idx]);\n    }\n\n    // Sort third values using SIMD\n    int sorted_count = third_values.size();\n    for (int i = 0; i < sorted_count - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&third_values[i]);\n        vec = vrev64q_s32(vec);\n        vec = vcombine_s32(vget_high_s32(vec), vget_low_s32(vec));\n        vec = vqsortq_s32(vec);\n        vst1q_s32(&third_values[i], vec);\n    }\n\n    // Handle remaining elements\n    std::sort(third_values.begin(), third_values.end());\n\n    // Reconstruct result vector\n    for (int i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = third_values[i / 3];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    // Create a copy of the input vector\n    std::vector<int> result = l;\n\n    // Extract elements divisible by 3\n    std::vector<int> third_elements;\n    for (int i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements using NEON\n    int sorted_size = third_elements.size();\n    for (int i = 0; i < sorted_size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&third_elements[i]);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 3), vec, 0);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 2), vec, 1);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 1), vec, 2);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 0), vec, 3);\n        \n        int32x4_t sorted = vrev64q_s32(vec);\n        vst1q_s32(&third_elements[i], sorted);\n    }\n\n    // Handle remaining elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Reconstruct the result vector\n    int third_idx = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = third_elements[third_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    // Create a copy of the input vector\n    std::vector<int> result = l;\n\n    // Extract elements divisible by 3\n    std::vector<int> third_elements;\n    for (int i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements using NEON\n    int sorted_size = third_elements.size();\n    for (int i = 0; i < sorted_size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&third_elements[i]);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 3), vec, 0);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 2), vec, 1);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 1), vec, 2);\n        vec = vsetq_lane_s32(vgetq_lane_s32(vec, 0), vec, 3);\n        \n        int32x4_t sorted = vqsortq_s32(vec);\n        vst1q_s32(&third_elements[i], sorted);\n    }\n\n    // Handle remaining elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Replace elements divisible by 3 in the result\n    int sorted_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = third_elements[sorted_index++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    // Create a copy of the input vector\n    std::vector<int> result = l;\n\n    // Extract elements divisible by 3\n    std::vector<int> third_elements;\n    for (int i = 0; i < n; i += 3) {\n        third_elements.push_back(l[i]);\n    }\n\n    // Sort the extracted elements using NEON\n    int sorted_size = third_elements.size();\n    for (int i = 0; i < sorted_size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&third_elements[i]);\n        vec = vrev64q_s32(vec);\n        vec = vcombine_s32(vget_high_s32(vec), vget_low_s32(vec));\n        vec = vqsortq_s32(vec);\n        vst1q_s32(&third_elements[i], vec);\n    }\n\n    // Handle remaining elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Put sorted elements back into original positions\n    int third_idx = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = third_elements[third_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n\n    // Process 4 elements at a time using Neon\n    int vector_length = n - (n % 4);\n    float32x4_t max_vec = vld1q_f32(&l[0]);\n\n    for (int i = 4; i < vector_length; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    // Horizontal max within the vector\n    float32x2_t max_low = vget_low_f32(max_vec);\n    float32x2_t max_high = vget_high_f32(max_vec);\n    max_low = vmax_f32(max_low, max_high);\n    max_val = vmax_f32(max_low, vrev64_f32(max_low))[0];\n\n    // Process remaining elements\n    for (int i = vector_length; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n\n    // Process 4 elements at a time using Neon\n    int simd_width = 4;\n    int vectorized_length = n - (n % simd_width);\n\n    float32x4_t max_vec = vld1q_f32(&l[0]);\n\n    for (int i = simd_width; i < vectorized_length; i += simd_width) {\n        float32x4_t current_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    // Horizontal max within the SIMD vector\n    float32x2_t max_low = vget_low_f32(max_vec);\n    float32x2_t max_high = vget_high_f32(max_vec);\n    max_low = vmax_f32(max_low, max_high);\n    max_val = vmax_f32(max_low, vrev64_f32(max_low))[0];\n\n    // Handle remaining elements\n    for (int i = vectorized_length; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n\n    // Process 4 elements at a time using Neon\n    int vec_size = n - (n % 4);\n    float32x4_t max_vec = vld1q_f32(&l[0]);\n\n    for (int i = 4; i < vec_size; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    // Horizontal max within the vector\n    float32x2_t max_low = vmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    max_val = vmax_f32(max_low, vrev64_f32(max_low))[0];\n\n    // Handle remaining elements\n    for (int i = vec_size; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n\n    // Process 4 elements at a time using Neon\n    int vector_size = n - (n % 4);\n    float32x4_t max_vec = vld1q_f32(&l[0]);\n\n    for (int i = 4; i < vector_size; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    // Horizontal max within the vector\n    float32x2_t max_low = vget_low_f32(max_vec);\n    float32x2_t max_high = vget_high_f32(max_vec);\n    max_low = vmax_f32(max_low, max_high);\n    max_val = vmax_f32(max_low, vrev64_f32(max_low))[0];\n\n    // Process remaining elements\n    for (int i = vector_size; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n\n    // Process 4 elements at a time using Neon\n    int vec_size = n - (n % 4);\n    float32x4_t max_vec = vld1q_f32(&l[0]);\n\n    for (int i = 4; i < vec_size; i += 4) {\n        float32x4_t current_vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, current_vec);\n    }\n\n    // Horizontal max within the vector\n    float32x2_t max_low = vmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    max_val = vmax_f32(max_low, vdup_n_f32(max_val))[0];\n\n    // Process remaining elements\n    for (int i = vec_size; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    const int vector_width = 4;\n    \n    // Process in vectors of 4 integers\n    for (int i = 0; i < n; i += vector_width) {\n        // Create vector of current indices\n        int32x4_t indices = {i, i+1, i+2, i+3};\n        \n        // Check divisibility by 11 or 13\n        uint32x4_t div_11 = vcezq_u32(vmovq_n_u32(0), vmodq_u32(indices, vmovq_n_u32(11)));\n        uint32x4_t div_13 = vcezq_u32(vmovq_n_u32(0), vmodq_u32(indices, vmovq_n_u32(13)));\n        uint32x4_t divisible = vorrq_u32(div_11, div_13);\n        \n        // Check for digit 7\n        uint32x4_t has_seven = {\n            (i % 10 == 7) || ((i / 10) % 10 == 7) || (i >= 70 && i < 80),\n            ((i+1) % 10 == 7) || (((i+1) / 10) % 10 == 7) || (i+1 >= 70 && i+1 < 80),\n            ((i+2) % 10 == 7) || (((i+2) / 10) % 10 == 7) || (i+2 >= 70 && i+2 < 80),\n            ((i+3) % 10 == 7) || (((i+3) / 10) % 10 == 7) || (i+3 >= 70 && i+3 < 80)\n        };\n        \n        // Combine conditions\n        uint32x4_t result = vandq_u32(divisible, has_seven);\n        \n        // Sum results\n        count += vaddvq_u32(result);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    const int vector_width = 4;\n    \n    // Process in vectors of 4 integers\n    for (int i = 0; i < n; i += vector_width) {\n        int32x4_t numbers = {i, i+1, i+2, i+3};\n        int32x4_t divisible_by_11 = vceqzq_s32(vandq_s32(numbers, vdupq_n_s32(11 - 1)));\n        int32x4_t divisible_by_13 = vceqzq_s32(vandq_s32(numbers, vdupq_n_s32(13 - 1)));\n        \n        int32x4_t divisible = vorrq_s32(divisible_by_11, divisible_by_13);\n        \n        for (int j = 0; j < vector_width; j++) {\n            if (vgetq_lane_s32(divisible, j) && \n                (strchr(std::to_string(i+j).c_str(), '7') != nullptr)) {\n                count++;\n            }\n        }\n    }\n    \n    // Handle remaining numbers\n    for (int i = (n / vector_width) * vector_width; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && \n            (strchr(std::to_string(i).c_str(), '7') != nullptr)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 4 integers at a time using NEON SIMD\n    for (int i = 0; i < n; i += 4) {\n        // Create NEON vectors for current 4 integers\n        int32x4_t nums = {i, i+1, i+2, i+3};\n        \n        // Check divisibility by 11 or 13\n        int32x4_t div11 = vdupq_n_s32(0);\n        int32x4_t div13 = vdupq_n_s32(0);\n        \n        div11 = vceqq_s32(vmulq_n_s32(nums, 1), vdupq_n_s32(0));\n        div13 = vceqq_s32(vmulq_n_s32(nums, 1), vdupq_n_s32(0));\n        \n        // Combine divisibility conditions\n        uint32x4_t divisible = vorrq_u32(div11, div13);\n        \n        // Count 7s in divisible numbers\n        for (int j = 0; j < 4; j++) {\n            if (divisible[j] && (i+j < n)) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        count++;\n                    }\n                    num /= 10;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 16 numbers at a time using Neon SIMD\n    for (int i = 0; i < n; i += 16) {\n        // Create vectors of integers\n        int32x4_t vec1 = {i, i+1, i+2, i+3};\n        int32x4_t vec2 = {i+4, i+5, i+6, i+7};\n        int32x4_t vec3 = {i+8, i+9, i+10, i+11};\n        int32x4_t vec4 = {i+12, i+13, i+14, i+15};\n        \n        // Check divisibility by 11 or 13\n        uint32x4_t div11_1 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec1));\n        uint32x4_t div13_1 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec1));\n        uint32x4_t div_1 = vorrq_u32(div11_1, div13_1);\n        \n        uint32x4_t div11_2 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec2));\n        uint32x4_t div13_2 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec2));\n        uint32x4_t div_2 = vorrq_u32(div11_2, div13_2);\n        \n        uint32x4_t div11_3 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec3));\n        uint32x4_t div13_3 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec3));\n        uint32x4_t div_3 = vorrq_u32(div11_3, div13_3);\n        \n        uint32x4_t div11_4 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec4));\n        uint32x4_t div13_4 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec4));\n        uint32x4_t div_4 = vorrq_u32(div11_4, div13_4);\n        \n        // Count 7s in divisible numbers\n        for (int j = 0; j < 4; j++) {\n            if (div_1[j] && strchr(std::to_string(i+j).c_str(), '7')) count++;\n            if (div_2[j] && strchr(std::to_string(i+j+4).c_str(), '7')) count++;\n            if (div_3[j] && strchr(std::to_string(i+j+8).c_str(), '7')) count++;\n            if (div_4[j] && strchr(std::to_string(i+j+12).c_str(), '7')) count++;\n        }\n    }\n    \n    // Handle remaining numbers\n    for (int i = (n/16)*16; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && strchr(std::to_string(i).c_str(), '7')) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 16 numbers at a time using Neon SIMD\n    for (int i = 0; i < n; i += 16) {\n        // Create vectors of integers\n        int32x4_t vec1 = {i, i+1, i+2, i+3};\n        int32x4_t vec2 = {i+4, i+5, i+6, i+7};\n        int32x4_t vec3 = {i+8, i+9, i+10, i+11};\n        int32x4_t vec4 = {i+12, i+13, i+14, i+15};\n        \n        // Check divisibility by 11 or 13\n        uint32x4_t div11_1 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec1));\n        uint32x4_t div13_1 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec1));\n        uint32x4_t div_1 = vorrq_u32(div11_1, div13_1);\n        \n        uint32x4_t div11_2 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec2));\n        uint32x4_t div13_2 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec2));\n        uint32x4_t div_2 = vorrq_u32(div11_2, div13_2);\n        \n        uint32x4_t div11_3 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec3));\n        uint32x4_t div13_3 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec3));\n        uint32x4_t div_3 = vorrq_u32(div11_3, div13_3);\n        \n        uint32x4_t div11_4 = vceqzq_u32(vandq_u32(vmovq_n_u32(11), vec4));\n        uint32x4_t div13_4 = vceqzq_u32(vandq_u32(vmovq_n_u32(13), vec4));\n        uint32x4_t div_4 = vorrq_u32(div11_4, div13_4);\n        \n        // Count 7s in divisible numbers\n        for (int j = 0; j < 4; j++) {\n            if (div_1[j] && strchr(std::to_string(i+j).c_str(), '7')) count++;\n            if (div_2[j] && strchr(std::to_string(i+j+4).c_str(), '7')) count++;\n            if (div_3[j] && strchr(std::to_string(i+j+8).c_str(), '7')) count++;\n            if (div_4[j] && strchr(std::to_string(i+j+12).c_str(), '7')) count++;\n        }\n    }\n    \n    // Handle remaining numbers\n    for (int i = (n/16)*16; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && strchr(std::to_string(i).c_str(), '7')) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    std::vector<float> result(n);\n    \n    // Process 4 elements at a time\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 elements\n        float32x4_t vec = vld1q_f32(&l[i]);\n        \n        // Extract even indices\n        float32x4_t even_vec = {vec[0], vec[2], vec[1], vec[3]};\n        \n        // Sort even indices using bitonic sort\n        float32x4_t sorted_even = vminq_f32(even_vec, vrev64q_f32(even_vec));\n        sorted_even = vmaxq_f32(sorted_even, vrev64q_f32(sorted_even));\n        \n        // Reconstruct result vector\n        result[i] = sorted_even[0];\n        result[i+1] = vec[1];\n        result[i+2] = sorted_even[2];\n        result[i+3] = vec[3];\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = l[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    // Prepare result vector\n    std::vector<float> result(l);\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - (n % 4); i += 4) {\n        // Load 4 even indices\n        float32x4_t even_vec = vld1q_f32(&l[i]);\n\n        // Sort even indices using Neon bitonic sort\n        float32x4_t sorted_even = vminq_f32(even_vec, vrev64q_f32(even_vec));\n        sorted_even = vminq_f32(sorted_even, vcombine_f32(\n            vget_high_f32(sorted_even), \n            vget_low_f32(sorted_even)\n        ));\n\n        // Store sorted even indices back to result\n        vst1q_f32(&result[i], sorted_even);\n    }\n\n    // Handle remaining elements if vector size is not multiple of 4\n    for (int i = n - (n % 4); i < n; i += 2) {\n        if (i + 1 < n && l[i] > l[i+1]) {\n            std::swap(result[i], result[i+1]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    std::vector<float> result(n);\n    \n    // Process 4 elements at a time\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 elements\n        float32x4_t vec = vld1q_f32(&l[i]);\n        \n        // Extract even indices\n        float32x4_t even_vec = {l[i], l[i+2], 0, 0};\n        \n        // Sort even indices\n        float32x2_t even_low = vld1_f32(&even_vec[0]);\n        float32x2_t sorted_even = vSort_f32(even_low);\n        \n        // Reconstruct vector with sorted even indices\n        float32x4_t sorted_vec = {\n            sorted_even[0], \n            vec[1], \n            sorted_even[1], \n            vec[3]\n        };\n        \n        // Store result\n        vst1q_f32(&result[i], sorted_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = l[i];\n    }\n    \n    return result;\n}\n\n// Custom sorting function for 2 elements using Neon\nfloat32x2_t vSort_f32(float32x2_t vec) {\n    float32x2_t sorted = vpmin_f32(vec, vec);\n    sorted = vpmax_f32(sorted, sorted);\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    std::vector<float> result(n);\n    \n    // Process 4 elements at a time\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        // Load 4 elements\n        float32x4_t vec = vld1q_f32(&l[i]);\n        \n        // Extract even indices\n        float32x4_t even_vec = {vec[0], vec[2], vec[1], vec[3]};\n        \n        // Sort the even indices\n        float32x4_t sorted_even = vminq_f32(even_vec, vrev64q_f32(even_vec));\n        sorted_even = vmaxq_f32(sorted_even, vrev64q_f32(sorted_even));\n        \n        // Reconstruct the result vector\n        float32x4_t result_vec = {sorted_even[0], vec[1], sorted_even[1], vec[3]};\n        \n        // Store the result\n        vst1q_f32(&result[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = l[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 2) return l;\n\n    // Prepare result vector\n    std::vector<float> result(l);\n\n    // Process 4 elements at a time\n    for (int i = 0; i < n - (n % 4); i += 4) {\n        // Load 4 elements\n        float32x4_t vec = vld1q_f32(&l[i]);\n\n        // Extract even indices\n        float32x4_t even_vec = vcombine_f32(\n            vget_low_f32(vec),\n            vget_high_f32(vec)\n        );\n        float32x2_t even_low = vget_low_f32(even_vec);\n        float32x2_t even_high = vget_high_f32(even_vec);\n\n        // Sort even indices\n        float32x2_t sorted_even = vmin_f32(even_low, even_high);\n        float32x2_t max_even = vmax_f32(even_low, even_high);\n\n        // Reconstruct vector with sorted even indices\n        float32x4_t sorted_vec = vcombine_f32(sorted_even, max_even);\n\n        // Blend sorted even indices with original odd indices\n        float32x4_t blend_mask = {0, 1, 0, 1};\n        float32x4_t result_vec = vbslq_f32(vcltq_f32(blend_mask, vdupq_n_f32(1.0f)), sorted_vec, vec);\n\n        // Store result\n        vst1q_f32(&result[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i += 2) {\n        if (i + 1 < n && l[i] > l[i+1]) {\n            std::swap(result[i], result[i+1]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first for efficient searching\n    std::sort(l.begin(), l.end());\n\n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 2; i++) {\n        int32x4_t vi = vdupq_n_s32(l[i]);\n        \n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n            \n            // Parallel search for third element\n            for (int k = j + 1; k < n; k += 4) {\n                int32x4_t vk = {\n                    k < n ? l[k] : 0,\n                    k+1 < n ? l[k+1] : 0,\n                    k+2 < n ? l[k+2] : 0,\n                    k+3 < n ? l[k+3] : 0\n                };\n                \n                int32x4_t sum = vaddq_s32(vaddq_s32(vi, vj), vk);\n                uint32x4_t zero_mask = vceqq_s32(sum, vdupq_n_s32(0));\n                \n                if (vgetq_lane_u32(zero_mask, 0) || \n                    vgetq_lane_u32(zero_mask, 1) || \n                    vgetq_lane_u32(zero_mask, 2) || \n                    vgetq_lane_u32(zero_mask, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::sort(l.begin(), l.end());\n\n    // Use Neon SIMD for parallel processing\n    for (int i = 0; i < n - 2; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&l[i]);\n\n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t b_vec = vdupq_n_s32(l[j]);\n\n            for (int k = j + 1; k < n; k += 4) {\n                int32x4_t c_vec = vld1q_s32(&l[k]);\n\n                // Compute sum of a + b + c\n                int32x4_t sum_vec = vaddq_s32(vaddq_s32(a_vec, b_vec), c_vec);\n\n                // Check if any element in sum_vec is zero\n                uint32x4_t zero_check = vceqzq_s32(sum_vec);\n                if (vgetq_lane_u32(zero_check, 0) || \n                    vgetq_lane_u32(zero_check, 1) || \n                    vgetq_lane_u32(zero_check, 2) || \n                    vgetq_lane_u32(zero_check, 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first for efficient processing\n    std::sort(l.begin(), l.end());\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int32x4_t sum_vec = vdupq_n_s32(l[i]);\n            sum_vec = vaddq_s32(sum_vec, vdupq_n_s32(l[left]));\n            sum_vec = vaddq_s32(sum_vec, vdupq_n_s32(l[right]));\n\n            // Horizontal sum using Neon intrinsics\n            int32x2_t sum_low = vget_low_s32(sum_vec);\n            int32x2_t sum_high = vget_high_s32(sum_vec);\n            int32x2_t sum_pairwise = vpadd_s32(sum_low, sum_high);\n            int total_sum = vget_lane_s32(sum_pairwise, 0);\n\n            if (total_sum == 0) return true;\n\n            if (l[i] + l[left] + l[right] < 0)\n                left++;\n            else if (l[i] + l[left] + l[right] > 0)\n                right--;\n            else\n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::sort(l.begin(), l.end());\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        // Use Neon for parallel comparisons\n        int32x4_t target_vec = vdupq_n_s32(-l[i]);\n        \n        while (left < right) {\n            int32x4_t left_vec = vdupq_n_s32(l[left]);\n            int32x4_t right_vec = vdupq_n_s32(l[right]);\n            \n            int32x4_t sum_vec = vaddq_s32(left_vec, right_vec);\n            \n            // Compare sum with target in parallel\n            uint32x4_t compare_vec = vceqq_s32(sum_vec, target_vec);\n            \n            if (vgetq_lane_u32(compare_vec, 0) || \n                vgetq_lane_u32(compare_vec, 1) || \n                vgetq_lane_u32(compare_vec, 2) || \n                vgetq_lane_u32(compare_vec, 3)) {\n                return true;\n            }\n\n            if (l[left] + l[right] < -l[i]) \n                left++;\n            else if (l[left] + l[right] > -l[i]) \n                right--;\n            else \n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::sort(l.begin(), l.end());\n\n    // Use NEON for parallel processing\n    for (int i = 0; i < n - 2; i += 4) {\n        int32x4_t vi = vld1q_s32(&l[i]);\n\n        for (int j = i + 1; j < n - 1; j++) {\n            int32x4_t vj = vdupq_n_s32(l[j]);\n\n            for (int k = j + 1; k < n; k += 4) {\n                int32x4_t vk = vld1q_s32(&l[k]);\n\n                // Compute sum of vi, vj, vk\n                int32x4_t sum = vaddq_s32(vi, vaddq_s32(vj, vk));\n\n                // Check if any element is zero\n                uint32x4_t zero_mask = vceqzq_s32(sum);\n                if (vmaxvq_u32(zero_mask)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);  // Load 4 consecutive integers\n        int32x4_t incremented = vaddq_s32(vec, vdupq_n_s32(1));  // Add 1 to each element\n        vst1q_s32(&l[i], incremented);  // Store back to original vector\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < n; i++) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);  // Load 4 consecutive integers\n        int32x4_t incremented = vaddq_s32(vec, vdupq_n_s32(1));  // Add 1 to each element\n        vst1q_s32(&l[i], incremented);  // Store back to original vector\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < n; ++i) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vec_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);  // Load 4 consecutive integers\n        int32x4_t incremented = vaddq_s32(vec, vdupq_n_s32(1));  // Add 1 to each element\n        vst1q_s32(&l[i], incremented);  // Store back to original vector\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < n; ++i) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int vector_size = size - (size % 4);\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);  // Load 4 consecutive integers\n        int32x4_t incremented = vaddq_s32(vec, vdupq_n_s32(1));  // Add 1 to each element\n        vst1q_s32(&l[i], incremented);  // Store back to original vector\n    }\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vector_size = 4; // Number of int elements processed in parallel with Neon\n    \n    // Process elements in parallel using Neon\n    for (size_t i = 0; i < n; i += vector_size) {\n        size_t remaining = std::min(vector_size, n - i);\n        \n        // Load vector of 4 integers\n        int32x4_t vec = vld1q_s32(&l[i]);\n        \n        // Add 1 to each element using Neon intrinsic\n        int32x4_t incremented = vaddq_s32(vec, vdupq_n_s32(1));\n        \n        // Store back to original vector\n        vst1q_s32(&l[i], incremented);\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector is too small, return false\n    if (n < 2) return false;\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            // Broadcast the target value across vector\n            int32x4_t target_vec = vdupq_n_s32(-l[j]);\n            \n            // Compare if any element matches the target\n            uint32x4_t comparison = vceqq_s32(current_vec, target_vec);\n            \n            // Check if any comparison is true\n            if (vgetq_lane_u32(comparison, 0) || \n                vgetq_lane_u32(comparison, 1) || \n                vgetq_lane_u32(comparison, 2) || \n                vgetq_lane_u32(comparison, 3)) {\n                return true;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector is too small, return false\n    if (n < 2) return false;\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            int32x4_t target_vec = vdupq_n_s32(-l[j]);\n            uint32x4_t comparison = vceqq_s32(current_vec, target_vec);\n            \n            // Check if any element matches\n            if (vgetq_lane_u32(comparison, 0) || \n                vgetq_lane_u32(comparison, 1) || \n                vgetq_lane_u32(comparison, 2) || \n                vgetq_lane_u32(comparison, 3)) {\n                return true;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = max(0, n - 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector is too small, return false\n    if (n < 2) return false;\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            int32x4_t target_vec = vdupq_n_s32(-l[j]);\n            uint32x4_t compare_vec = vceqq_s32(current_vec, target_vec);\n            \n            // If any element matches, return true\n            if (vgetq_lane_u32(compare_vec, 0) || \n                vgetq_lane_u32(compare_vec, 1) || \n                vgetq_lane_u32(compare_vec, 2) || \n                vgetq_lane_u32(compare_vec, 3)) {\n                return true;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = max(0, n - 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            int32x4_t target_vec = vdupq_n_s32(-l[j]);\n            uint32x4_t comparison = vceqq_s32(current_vec, target_vec);\n            \n            if (vgetq_lane_u32(comparison, 0) || \n                vgetq_lane_u32(comparison, 1) || \n                vgetq_lane_u32(comparison, 2) || \n                vgetq_lane_u32(comparison, 3)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - 4; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            int32x4_t target_vec = vdupq_n_s32(-l[j]);\n            uint32x4_t comparison = vceqq_s32(current_vec, target_vec);\n            \n            if (vgetq_lane_u32(comparison, 0) || \n                vgetq_lane_u32(comparison, 1) || \n                vgetq_lane_u32(comparison, 2) || \n                vgetq_lane_u32(comparison, 3)) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    // Use a buffer to store digits in reverse order\n    char buffer[64];\n    int index = 0;\n    \n    // Handle zero as a special case\n    if (x == 0) return \"0\";\n    \n    // Use Neon registers for parallel processing\n    int64x2_t x_vec = vdupq_n_s64(x);\n    int64x2_t base_vec = vdupq_n_s64(base);\n    \n    // Process digits in parallel\n    while (x > 0) {\n        // Use vector division and modulo\n        int64x2_t div_result = vdivq_s64(x_vec, base_vec);\n        int64x2_t mod_result = vmodq_s64(x_vec, base_vec);\n        \n        // Convert remainder to character\n        buffer[index++] = '0' + mod_result[0];\n        \n        // Update x for next iteration\n        x_vec = div_result;\n        x = div_result[0];\n    }\n    \n    // Reverse the string\n    std::string result;\n    for (int i = index - 1; i >= 0; i--) {\n        result += buffer[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Temporary buffer to store digits\n    uint8_t digits[64];\n    int digit_count = 0;\n    \n    // Convert to base using SIMD-like approach\n    while (x > 0) {\n        digits[digit_count++] = x % base;\n        x /= base;\n    }\n    \n    // Reverse digits using NEON intrinsics\n    uint8x16_t rev_vec = vdupq_n_u8(0);\n    for (int i = 0; i < digit_count; i += 16) {\n        int chunk_size = std::min(16, digit_count - i);\n        uint8x16_t chunk_vec = vld1q_u8(digits + i);\n        \n        // Reverse within chunk\n        uint8x16_t rev_chunk = vrev64q_u8(chunk_vec);\n        \n        // Store back\n        vst1q_u8(digits + i, rev_chunk);\n    }\n    \n    // Convert digits to string\n    std::string result;\n    for (int i = 0; i < digit_count; i++) {\n        result += std::to_string(digits[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    // Use a buffer to store digits in reverse order\n    char buffer[64];\n    int index = 0;\n    \n    // Handle zero as a special case\n    if (x == 0) return \"0\";\n    \n    // Use Neon registers to process multiple digits\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t base_vec = vdupq_n_u64(base);\n    \n    // Process digits in parallel\n    while (x > 0) {\n        // Perform division using Neon intrinsics\n        uint64x2_t quotient = vdivq_u64(x_vec, base_vec);\n        uint64x2_t remainder = vmodq_u64(x_vec, base_vec);\n        \n        // Store the remainder as a digit\n        buffer[index++] = '0' + (remainder[0] % base);\n        \n        // Update x for next iteration\n        x_vec = quotient;\n        x = x_vec[0];\n    }\n    \n    // Reverse the string\n    std::string result;\n    for (int i = index - 1; i >= 0; i--) {\n        result += buffer[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Temporary buffer to store digits\n    uint8_t digits[64];\n    int digit_count = 0;\n    \n    // Convert to base using division\n    while (x > 0) {\n        digits[digit_count++] = x % base;\n        x /= base;\n    }\n    \n    // Use Neon to reverse digits in parallel\n    int vector_size = digit_count / 16 * 16;\n    uint8x16_t reversed_vec;\n    \n    for (int i = 0; i < vector_size; i += 16) {\n        uint8x16_t current_vec = vld1q_u8(digits + i);\n        reversed_vec = vrev64q_u8(current_vec);\n        vst1q_u8(digits + i, reversed_vec);\n    }\n    \n    // Handle remaining digits\n    for (int i = vector_size; i < digit_count; i++) {\n        int opposite = digit_count - 1 - i;\n        if (i < opposite) {\n            std::swap(digits[i], digits[opposite]);\n        }\n    }\n    \n    // Convert digits to string\n    std::string result;\n    for (int i = 0; i < digit_count; i++) {\n        result += std::to_string(digits[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    // Allocate buffer for maximum 64-bit number conversion\n    char buffer[65] = {0};\n    int index = 64;\n    \n    // Handle zero case\n    if (x == 0) return \"0\";\n    \n    // Handle negative numbers\n    bool is_negative = x < 0;\n    if (is_negative) x = -x;\n    \n    // Use NEON registers for parallel conversion\n    uint64x2_t dividend_vec = vdupq_n_u64(x);\n    uint64x2_t base_vec = vdupq_n_u64(base);\n    \n    while (x > 0) {\n        // Parallel division using NEON\n        uint64x2_t quotient_vec = vdivq_u64(dividend_vec, base_vec);\n        uint64x2_t remainder_vec = vmodq_u64(dividend_vec, base_vec);\n        \n        // Convert remainder to character\n        char digit = remainder_vec[0] + '0';\n        buffer[--index] = digit;\n        \n        // Update dividend for next iteration\n        dividend_vec = quotient_vec;\n        x = quotient_vec[0];\n    }\n    \n    // Add negative sign if needed\n    if (is_negative) buffer[--index] = '-';\n    \n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_size = 16;  // Neon vector size (128-bit)\n    int processed_len = (len / vec_size) * vec_size;\n\n    for (int i = 0; i < processed_len; i += vec_size) {\n        uint8x16_t left = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t right = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + len - i - vec_size));\n        \n        uint8x16_t reversed = vrev64q_u8(left);\n        reversed = vextq_u8(reversed, reversed, 8);\n\n        uint8x16_t cmp = vceqq_u8(reversed, right);\n        if (vminvq_u8(cmp) == 0) return false;\n    }\n\n    // Handle remaining characters\n    for (int i = processed_len; i < len / 2; ++i) {\n        if (text[i] != text[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_len = len / 16 * 16;\n    int remaining = len % 16;\n\n    // Load first half and last half in parallel\n    for (int i = 0; i < vec_len; i += 16) {\n        uint8x16_t first_half = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t last_half = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + len - 16 - i));\n        \n        // Reverse last half\n        uint8x16_t reversed_last_half = vrev64q_u8(last_half);\n        reversed_last_half = vextq_u8(reversed_last_half, reversed_last_half, 8);\n\n        // Compare first and last halves\n        uint8x16_t comparison = vceqq_u8(first_half, reversed_last_half);\n        if (vminvq_u8(comparison) == 0) return false;\n    }\n\n    // Handle remaining characters\n    for (int i = 0; i < remaining; i++) {\n        if (text[i] != text[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_size = 16;  // 16-byte vector for Neon\n    int processed_len = (len / vec_size) * vec_size;\n\n    for (int i = 0; i < processed_len / 2; i += vec_size) {\n        uint8x16_t left = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t right = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + len - vec_size - i));\n        \n        uint8x16_t reversed_right = vrev64q_u8(right);\n        reversed_right = vcombine_u8(vget_high_u8(reversed_right), vget_low_u8(reversed_right));\n\n        uint8x16_t cmp = vceqq_u8(left, reversed_right);\n        if (vminvq_u8(cmp) == 0) return false;\n    }\n\n    // Handle remaining characters\n    for (int i = processed_len / 2; i < (len + 1) / 2; i++) {\n        if (text[i] != text[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_len = len / 16 * 16;\n    int remaining = len % 16;\n\n    // Load first half and last half of the string\n    for (int i = 0; i < vec_len; i += 16) {\n        uint8x16_t first_half = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t last_half = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + len - 16 - i));\n        \n        // Reverse last half\n        uint8x16_t reversed_last_half = vrev64q_u8(last_half);\n        reversed_last_half = vextq_u8(reversed_last_half, reversed_last_half, 8);\n\n        // Compare first and last halves\n        uint8x16_t cmp = vceqq_u8(first_half, reversed_last_half);\n        if (vminvq_u8(cmp) == 0) return false;\n    }\n\n    // Handle remaining elements\n    for (int i = 0; i < remaining; i++) {\n        if (text[i] != text[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_size = 16;  // 16-byte vector for Neon\n    int processed_len = len - (len % vec_size);\n\n    // Process in 16-byte chunks\n    for (int i = 0; i < processed_len; i += vec_size) {\n        uint8x16_t left = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t right = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + len - i - vec_size));\n        \n        uint8x16_t reversed = vrev64q_u8(left);\n        reversed = vextq_u8(reversed, reversed, 8);\n        \n        uint8x16_t cmp = vceqq_u8(reversed, right);\n        if (vminvq_u8(cmp) == 0) return false;\n    }\n\n    // Check remaining characters\n    for (int i = processed_len; i < len / 2; ++i) {\n        if (text[i] != text[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    for (int i = 0; i < vector_len; i += 16) {\n        // Load 16 characters into Neon register\n        uint8x16_t chars = vld1q_u8((const uint8_t*)(s.data() + i));\n        \n        // Subtract 5 from each character\n        uint8x16_t shifted = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Adjust characters that wrap around\n        uint8x16_t wrap_mask = vcltq_u8(chars, vdupq_n_u8('a' + 5));\n        uint8x16_t wrapped = vaddq_u8(shifted, vmulq_u8(wrap_mask, vdupq_n_u8(26)));\n        \n        // Store back to output string\n        vst1q_u8((uint8_t*)(out.data() + i), wrapped);\n    }\n    \n    // Handle remaining characters sequentially\n    for (int i = vector_len; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    for (int i = 0; i < vector_len; i += 16) {\n        // Load 16 characters into Neon register\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t shifted = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Adjust characters that wrap around\n        uint8x16_t wrap_mask = vcltq_u8(chars, vdupq_n_u8('a' + 5));\n        uint8x16_t wrapped = vaddq_u8(shifted, vmulq_u8(wrap_mask, vdupq_n_u8(26)));\n        \n        // Store back to output string\n        vst1q_u8((uint8_t*)&out[i], wrapped);\n    }\n    \n    // Process remaining characters sequentially\n    for (int i = vector_len; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    for (int i = 0; i < vector_len; i += 16) {\n        // Load 16 characters into Neon register\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t shifted = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Adjust characters that go below 'a'\n        uint8x16_t below_a = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t correction = vandq_u8(below_a, vdupq_n_u8(26));\n        shifted = vaddq_u8(shifted, correction);\n        \n        // Store back to output string\n        vst1q_u8((uint8_t*)&out[i], shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (int i = vector_len; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    for (int i = 0; i < vector_len; i += 16) {\n        // Load 16 characters into Neon register\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t shifted = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Wrap around if character goes below 'a'\n        uint8x16_t wrapped = vaddq_u8(shifted, vdupq_n_u8(26));\n        \n        // Store back to output string\n        vst1q_u8((uint8_t*)&out[i], wrapped);\n    }\n    \n    // Handle remaining characters sequentially\n    for (int i = vector_len; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    for (int i = 0; i < vector_len; i += 16) {\n        // Load 16 characters into Neon vector\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t shifted = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Handle wrap-around for characters below 'a'\n        uint8x16_t wrap_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t wrapped = vaddq_u8(shifted, vmulq_u8(wrap_mask, vdupq_n_u8(26)));\n        \n        // Store back to output string\n        vst1q_u8((uint8_t*)&out[i], wrapped);\n    }\n    \n    // Handle remaining characters sequentially\n    for (int i = vector_len; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int vector_size = 4; // Number of integers processed in parallel with Neon\n    \n    // Process vectors of 4 integers at a time\n    for (int i = 0; i < n - (n % vector_size); i += vector_size) {\n        int32x4_t vec = vld1q_s32(&l[i]);           // Load 4 integers\n        int32x4_t threshold_vec = vdupq_n_s32(t);   // Broadcast threshold to vector\n        \n        // Compare if all elements are less than threshold\n        uint32x4_t comparison = vcltq_s32(vec, threshold_vec);\n        \n        // Check if all comparisons are true\n        if (vminvq_u32(comparison) == 0) {\n            return false;\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = n - (n % vector_size); i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int vec_size = 4;\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n - vec_size + 1; i += vec_size) {\n        int32x4_t vec = vld1q_s32(&l[i]);  // Load 4 integers\n        int32x4_t threshold_vec = vdupq_n_s32(t);  // Broadcast threshold\n        \n        // Compare if any element is greater than threshold\n        uint32x4_t comparison = vcgtq_s32(vec, threshold_vec);\n        \n        // If any element is greater, return false\n        if (vmaxvq_u32(comparison) > 0) {\n            return false;\n        }\n    }\n    \n    // Process remaining elements\n    for (int i = n - (n % vec_size); i < n; i++) {\n        if (l[i] > t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int vec_size = 4;  // Number of integers processed in parallel with Neon\n    \n    // Process vectors of 4 integers at a time\n    for (int i = 0; i <= n - vec_size; i += vec_size) {\n        int32x4_t vec = vld1q_s32(&l[i]);  // Load 4 integers\n        int32x4_t threshold_vec = vdupq_n_s32(t);  // Replicate threshold\n        \n        // Compare each element with threshold\n        uint32x4_t comparison = vcltq_s32(vec, threshold_vec);\n        \n        // Check if all elements are below threshold\n        if (vminvq_u32(comparison) == 0) {\n            return false;\n        }\n    }\n    \n    // Process remaining elements\n    for (int i = n - (n % vec_size); i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    \n    // Process 4 integers at a time using Neon\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t threshold_vec = vdupq_n_s32(t);\n        \n        // Compare each element with threshold\n        uint32x4_t comparison = vcltq_s32(vec, threshold_vec);\n        \n        // Check if all elements are below threshold\n        if (vminvq_u32(comparison) == 0) {\n            return false;\n        }\n    }\n    \n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int vector_size = 4;  // Number of integers processed in parallel with Neon\n    \n    // Process vectors in chunks of 4\n    for (int i = 0; i < n - (n % vector_size); i += vector_size) {\n        int32x4_t vec = vld1q_s32(&l[i]);          // Load 4 integers\n        int32x4_t threshold_vec = vdupq_n_s32(t);  // Broadcast threshold to vector\n        \n        // Compare each element with threshold\n        uint32x4_t comparison = vcltq_s32(vec, threshold_vec);\n        \n        // Check if all elements are below threshold\n        if (vminvq_u32(comparison) == 0) {\n            return false;\n        }\n    }\n    \n    // Process remaining elements sequentially\n    for (int i = n - (n % vector_size); i < n; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n\n    // Process 16 characters at a time using Neon\n    int vector_len = len - (len % 16);\n    int32x4_t count_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_len; i += 16) {\n        int8x16_t bracket_vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        // Create masks for '<' and '>'\n        uint8x16_t lt_mask = vceqq_s8(bracket_vec, vdupq_n_s8('<'));\n        uint8x16_t gt_mask = vceqq_s8(bracket_vec, vdupq_n_s8('>'));\n\n        // Accumulate counts\n        int32x4_t lt_count = vpaddlq_s16(vpaddlq_s8(vreinterpretq_s8_u8(lt_mask)));\n        int32x4_t gt_count = vpaddlq_s16(vpaddlq_s8(vreinterpretq_s8_u8(gt_mask)));\n\n        count_vec = vsubq_s32(count_vec, vreinterpretq_s32_u32(vaddq_u32(vreinterpretq_u32_s32(lt_count), vreinterpretq_u32_s32(gt_count))));\n    }\n\n    // Horizontal sum of count vector\n    int32x2_t sum_vec = vadd_s32(vget_low_s32(count_vec), vget_high_s32(count_vec));\n    sum_vec = vpadd_s32(sum_vec, sum_vec);\n    int total_count = vget_lane_s32(sum_vec, 0);\n\n    // Process remaining characters\n    for (int i = vector_len; i < len; i++) {\n        total_count += (brackets[i] == '<') ? 1 : -1;\n    }\n\n    return total_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    \n    // Process 16 characters at a time using Neon\n    int vector_len = len - (len % 16);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_len; i += 16) {\n        int8x16_t bracket_vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        // Compare '<' and '>'\n        int8x16_t lt_mask = vceqq_s8(bracket_vec, vdupq_n_s8('<'));\n        int8x16_t gt_mask = vceqq_s8(bracket_vec, vdupq_n_s8('>'));\n        \n        // Accumulate counts\n        int32x4_t lt_count = vpaddlq_s16(vpaddlq_s8(lt_mask));\n        int32x4_t gt_count = vpaddlq_s16(vpaddlq_s8(gt_mask));\n        \n        count_vec = vsubq_s32(count_vec, vsubq_s32(lt_count, gt_count));\n    }\n    \n    // Horizontal sum of count vector\n    int32x2_t sum_vec = vadd_s32(vget_low_s32(count_vec), vget_high_s32(count_vec));\n    int total_count = vget_lane_s32(sum_vec, 0) + vget_lane_s32(sum_vec, 1);\n    \n    // Process remaining characters\n    for (int i = vector_len; i < len; i++) {\n        total_count += (brackets[i] == '<') ? 1 : -1;\n    }\n    \n    return total_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n\n    // Process 16 characters at a time using Neon\n    int vector_len = len - (len % 16);\n    int32x4_t count_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_len; i += 16) {\n        int8x16_t bracket_vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        int8x16_t open_mask = vceqq_s8(bracket_vec, vdupq_n_s8('<'));\n        int8x16_t close_mask = vceqq_s8(bracket_vec, vdupq_n_s8('>'));\n        \n        int32x4_t open_count = vpaddlq_s16(vpaddlq_s8(open_mask));\n        int32x4_t close_count = vpaddlq_s16(vpaddlq_s8(close_mask));\n        \n        count_vec = vsubq_s32(count_vec, vreinterpretq_s32_s8(open_mask));\n        count_vec = vaddq_s32(count_vec, vreinterpretq_s32_s8(close_mask));\n    }\n\n    // Horizontal sum of count_vec\n    int32x2_t sum_low = vget_low_s32(count_vec);\n    int32x2_t sum_high = vget_high_s32(count_vec);\n    int32x2_t sum = vadd_s32(sum_low, sum_high);\n    sum = vpadd_s32(sum, sum);\n    int total_count = vget_lane_s32(sum, 0);\n\n    // Process remaining characters\n    for (int i = vector_len; i < len; i++) {\n        total_count += (brackets[i] == '<') ? -1 : 1;\n    }\n\n    return total_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    \n    // If empty string, return false\n    if (len == 0) return false;\n    \n    // Process 16 characters at a time using Neon\n    int16x8_t count_vec = vdupq_n_s16(0);\n    int current_count = 0;\n    \n    // Process 16 characters at a time\n    for (int i = 0; i + 15 < len; i += 16) {\n        int16x8_t vec1 = vdupq_n_s16(0);\n        int16x8_t vec2 = vdupq_n_s16(0);\n        \n        // Load 16 characters\n        for (int j = 0; j < 8; j++) {\n            int16_t val1 = (brackets[i+j] == '<') ? 1 : ((brackets[i+j] == '>') ? -1 : 0);\n            int16_t val2 = (brackets[i+j+8] == '<') ? 1 : ((brackets[i+j+8] == '>') ? -1 : 0);\n            \n            vec1 = vsetq_lane_s16(val1, vec1, j);\n            vec2 = vsetq_lane_s16(val2, vec2, j);\n        }\n        \n        // Accumulate counts\n        count_vec = vaddq_s16(count_vec, vec1);\n        count_vec = vaddq_s16(count_vec, vec2);\n    }\n    \n    // Horizontal sum of count_vec\n    int16x4_t sum_low = vget_low_s16(count_vec);\n    int16x4_t sum_high = vget_high_s16(count_vec);\n    int16x4_t sum = vadd_s16(sum_low, sum_high);\n    sum = vpadd_s16(sum, sum);\n    sum = vpadd_s16(sum, sum);\n    current_count = vget_lane_s16(sum, 0);\n    \n    // Process remaining characters\n    for (int i = (len / 16) * 16; i < len; i++) {\n        current_count += (brackets[i] == '<') ? 1 : ((brackets[i] == '>') ? -1 : 0);\n    }\n    \n    return current_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n\n    // Process 16 characters at a time using Neon\n    int vector_len = len - (len % 16);\n    int32x4_t count_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_len; i += 16) {\n        int8x16_t bracket_vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        int8x16_t lt_mask = vceqq_s8(bracket_vec, vdupq_n_s8('<'));\n        int8x16_t gt_mask = vceqq_s8(bracket_vec, vdupq_n_s8('>'));\n        \n        int32x4_t lt_count = vpaddlq_s16(vpaddlq_s8(lt_mask));\n        int32x4_t gt_count = vpaddlq_s16(vpaddlq_s8(gt_mask));\n        \n        count_vec = vsubq_s32(count_vec, vreinterpretq_s32_s8(lt_mask));\n        count_vec = vaddq_s32(count_vec, vreinterpretq_s32_s8(gt_mask));\n    }\n\n    // Horizontal sum of count vector\n    int32x2_t sum_low = vget_low_s32(count_vec);\n    int32x2_t sum_high = vget_high_s32(count_vec);\n    int32x2_t sum = vadd_s32(sum_low, sum_high);\n    sum = vpadd_s32(sum, sum);\n    int total_count = vget_lane_s32(sum, 0);\n\n    // Process remaining characters\n    for (int i = vector_len; i < len; i++) {\n        total_count += (brackets[i] == '<') ? -1 : 1;\n    }\n\n    return total_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using Neon\n    int vector_len = 16;\n    int processed_len = (n / vector_len) * vector_len;\n    \n    int balance = 0;\n    \n    // Process 16-byte chunks using Neon\n    for (int i = 0; i < processed_len; i += vector_len) {\n        // Load 16 characters\n        uint8x16_t vec_brackets = vld1q_u8((const uint8_t*)&brackets[i]);\n        \n        // Compare with '('\n        uint8x16_t is_open = vceqq_u8(vec_brackets, vdupq_n_u8('('));\n        \n        // Compare with ')'\n        uint8x16_t is_close = vceqq_u8(vec_brackets, vdupq_n_u8(')'));\n        \n        // Horizontal sum of open brackets\n        int16x8_t open_low = vpaddlq_u8(is_open);\n        int16x4_t open_sum = vadd_s16(vget_low_s16(open_low), vget_high_s16(open_low));\n        open_sum = vpadd_s16(open_sum, open_sum);\n        int open_count = vget_lane_s16(open_sum, 0);\n        \n        // Horizontal sum of close brackets\n        int16x8_t close_low = vpaddlq_u8(is_close);\n        int16x4_t close_sum = vadd_s16(vget_low_s16(close_low), vget_high_s16(close_low));\n        close_sum = vpadd_s16(close_sum, close_sum);\n        int close_count = vget_lane_s16(close_sum, 0);\n        \n        balance += open_count - close_count;\n        \n        // Early exit if balance becomes negative\n        if (balance < 0) return false;\n    }\n    \n    // Process remaining characters sequentially\n    for (int i = processed_len; i < n; i++) {\n        if (brackets[i] == '(') balance++;\n        else balance--;\n        \n        if (balance < 0) return false;\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using Neon\n    int vector_len = 16;\n    int processed_len = (n / vector_len) * vector_len;\n    \n    int32x4_t balance_vec = vdupq_n_s32(0);\n    int current_balance = 0;\n    \n    // Process 16-byte chunks using SIMD\n    for (int i = 0; i < processed_len; i += vector_len) {\n        int8x16_t bracket_vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        // Create mask for '(' (true) and ')' (false)\n        uint8x16_t is_open_mask = vceqq_s8(bracket_vec, vdupq_n_s8('('));\n        \n        // Convert mask to signed integers: '(' = 1, ')' = -1\n        int8x16_t bracket_signs = vbslq_s8(is_open_mask, \n                                           vdupq_n_s8(1), \n                                           vdupq_n_s8(-1));\n        \n        // Horizontal sum of signs\n        int32x4_t signs_sum = vpaddlq_s16(vpaddlq_s8(bracket_signs));\n        balance_vec = vaddq_s32(balance_vec, signs_sum);\n    }\n    \n    // Horizontal sum of balance vector\n    int32_t balance_array[4];\n    vst1q_s32(balance_array, balance_vec);\n    current_balance = balance_array[0] + balance_array[1] + balance_array[2] + balance_array[3];\n    \n    // Process remaining characters sequentially\n    for (int i = processed_len; i < n; i++) {\n        current_balance += (brackets[i] == '(') ? 1 : -1;\n    }\n    \n    // Final check: balance must be zero and never go negative\n    if (current_balance != 0) return false;\n    \n    current_balance = 0;\n    for (char c : brackets) {\n        current_balance += (c == '(') ? 1 : -1;\n        if (current_balance < 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using Neon\n    int vector_len = 16;\n    int processed_len = (n / vector_len) * vector_len;\n    \n    int32x4_t balance_vec = vdupq_n_s32(0);\n    int current_balance = 0;\n    \n    // Process 16-byte chunks\n    for (int i = 0; i < processed_len; i += vector_len) {\n        int8x16_t bracket_vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        // Create masks for '(' and ')' \n        uint8x16_t open_mask = vceqq_s8(bracket_vec, vdupq_n_s8('('));\n        uint8x16_t close_mask = vceqq_s8(bracket_vec, vdupq_n_s8(')'));\n        \n        // Count open and close brackets\n        int16x8_t open_count_low = vpaddlq_u8(vmovn_u16(open_mask));\n        int16x8_t close_count_low = vpaddlq_u8(vmovn_u16(close_mask));\n        \n        int32x4_t open_count = vpaddlq_s16(open_count_low);\n        int32x4_t close_count = vpaddlq_s16(close_count_low);\n        \n        // Update balance\n        balance_vec = vaddq_s32(balance_vec, vsubq_s32(open_count, close_count));\n    }\n    \n    // Horizontal sum of balance vector\n    int32x2_t sum_vec = vadd_s32(vget_low_s32(balance_vec), vget_high_s32(balance_vec));\n    current_balance += vget_lane_s32(sum_vec, 0) + vget_lane_s32(sum_vec, 1);\n    \n    // Process remaining characters sequentially\n    for (int i = processed_len; i < n; i++) {\n        current_balance += (brackets[i] == '(') ? 1 : -1;\n    }\n    \n    // Check final balance\n    return current_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using Neon\n    int vector_size = 16;\n    int processed_length = (n / vector_size) * vector_size;\n    \n    int balance = 0;\n    \n    // Process 16-byte vectors\n    for (int i = 0; i < processed_length; i += vector_size) {\n        // Load 16 characters into Neon vector\n        int8x16_t vec = vld1q_s8(reinterpret_cast<const int8_t*>(&brackets[i]));\n        \n        // Compare with '('\n        int8x16_t open_mask = vceqq_s8(vec, vdupq_n_s8('('));\n        \n        // Compare with ')'\n        int8x16_t close_mask = vceqq_s8(vec, vdupq_n_s8(')'));\n        \n        // Count open and close brackets\n        int16x8_t open_counts = vpaddlq_s8(open_mask);\n        int16x8_t close_counts = vpaddlq_s8(close_mask);\n        \n        int32x4_t open_sum = vpaddlq_s16(open_counts);\n        int32x4_t close_sum = vpaddlq_s16(close_counts);\n        \n        int64x2_t open_total = vpaddlq_s32(open_sum);\n        int64x2_t close_total = vpaddlq_s32(close_sum);\n        \n        balance += vgetq_lane_s64(open_total, 0) - vgetq_lane_s64(close_total, 0);\n        \n        // Early exit if balance becomes negative\n        if (balance < 0) return false;\n    }\n    \n    // Process remaining characters sequentially\n    for (int i = processed_length; i < n; i++) {\n        if (brackets[i] == '(') balance++;\n        else balance--;\n        \n        if (balance < 0) return false;\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using Neon\n    int vector_size = 16;\n    int processed_length = (n / vector_size) * vector_size;\n    \n    int balance = 0;\n    \n    // Process 16-byte chunks using Neon\n    for (int i = 0; i < processed_length; i += vector_size) {\n        // Load 16 characters\n        uint8x16_t bracket_vec = vld1q_u8((const uint8_t*)&brackets[i]);\n        \n        // Compare with '('\n        uint8x16_t open_mask = vceqq_u8(bracket_vec, vdupq_n_u8('('));\n        \n        // Compare with ')'\n        uint8x16_t close_mask = vceqq_u8(bracket_vec, vdupq_n_u8(')'));\n        \n        // Count open and close brackets\n        int16x8_t open_count_low = vpaddlq_u8(open_mask);\n        int16x8_t close_count_low = vpaddlq_u8(close_mask);\n        \n        int16x4_t open_count_high = vadd_s16(vget_low_s16(open_count_low), vget_high_s16(open_count_low));\n        int16x4_t close_count_high = vadd_s16(vget_low_s16(close_count_low), vget_high_s16(close_count_low));\n        \n        int32x2_t open_count_final = vpaddl_s16(open_count_high);\n        int32x2_t close_count_final = vpaddl_s16(close_count_high);\n        \n        balance += vget_lane_s32(open_count_final, 0) - vget_lane_s32(close_count_final, 0);\n        \n        // If balance becomes negative, return false\n        if (balance < 0) return false;\n    }\n    \n    // Process remaining characters sequentially\n    for (int i = processed_length; i < n; i++) {\n        if (brackets[i] == '(') balance++;\n        else balance--;\n        \n        if (balance < 0) return false;\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t i = 0;\n\n    // Process 4 elements at a time using NEON\n    for (; i + 4 <= xs.size() - 1; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i+1]);\n        float32x4_t multipliers = vld1q_f32(&std::vector<float>{1, 2, 3, 4}[0]);\n        float32x4_t derivatives = vmulq_f32(coeffs, multipliers);\n        vst1q_f32(&result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; ++i) {\n        result[i] = xs[i+1] * (i+1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    int simd_width = 4;\n\n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 0; i + simd_width <= n - 1; i += simd_width) {\n        float32x4_t coeffs = vld1q_f32(&xs[i+1]);\n        float32x4_t multipliers = vld1q_f32((float[]){1, 2, 3, 4});\n        float32x4_t derivatives = vmulq_f32(coeffs, multipliers);\n        vst1q_f32(&result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        result[i] = xs[i+1] * (i+1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    int simd_width = 4;\n\n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 0; i + simd_width <= n - 1; i += simd_width) {\n        float32x4_t coeffs = vld1q_f32(&xs[i+1]);\n        float32x4_t multipliers = vld1q_f32((float[]){1, 2, 3, 4});\n        float32x4_t derivatives = vmulq_f32(coeffs, multipliers);\n        vst1q_f32(&result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i+1] * (i+1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n    \n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    \n    // Process 4 elements at a time using Neon\n    int vectorized_length = (n - 1) / 4 * 4;\n    \n    for (int i = 0; i < vectorized_length; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i+1]);\n        float32x4_t multipliers = vld1q_f32((float[]){1, 2, 3, 4});\n        float32x4_t derivatives = vmulq_f32(coeffs, multipliers);\n        \n        vst1q_f32(&result[i], derivatives);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorized_length; i < n - 1; i++) {\n        result[i] = xs[i+1] * (i+1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t vec_size = result.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // Process 4 elements at a time using NEON\n    for (size_t i = 0; i < simd_size; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i+1]);\n        float32x4_t multipliers = vld1q_f32(&std::vector<float>{1, 2, 3, 4}[0]);\n        float32x4_t derivatives = vmulq_f32(coeffs, multipliers);\n        vst1q_f32(&result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        result[i] = xs[i+1] * (i+1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    \n    // Prepare vowel comparison vectors\n    uint8x16_t vowels_lower = vcombine_u8(\n        vcreate_u8(0x6165696F7579ULL),  // 'a', 'e', 'i', 'o', 'u', 'y'\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    uint8x16_t vowels_upper = vcombine_u8(\n        vcreate_u8(0x4145494F5959ULL),  // 'A', 'E', 'I', 'O', 'U', 'Y'\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    // Process 16 characters at a time\n    for (int i = 0; i < vector_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        \n        // Check for lowercase vowels\n        uint8x16_t is_lower_vowel = vceqq_u8(chars, vowels_lower);\n        \n        // Check for uppercase vowels\n        uint8x16_t is_upper_vowel = vceqq_u8(chars, vowels_upper);\n        \n        // Combine lowercase and uppercase vowel checks\n        uint8x16_t is_vowel = vorrq_u8(is_lower_vowel, is_upper_vowel);\n        \n        // Special handling for 'y' at the end of the word\n        if (i + 15 == len - 1) {\n            uint8x16_t is_y_end = vceqq_u8(chars, vcombine_u8(vcreate_u8(0x7900000000000000ULL), vcreate_u8(0x0000000000000000ULL)));\n            uint8x16_t is_Y_end = vceqq_u8(chars, vcombine_u8(vcreate_u8(0x5900000000000000ULL), vcreate_u8(0x0000000000000000ULL)));\n            is_vowel = vorrq_u8(is_vowel, vorrq_u8(is_y_end, is_Y_end));\n        }\n        \n        // Count vowels\n        uint8x16_t count_vec = vpaddlq_u8(is_vowel);\n        uint16x8_t count_vec_16 = vpaddlq_u16(count_vec);\n        uint32x4_t count_vec_32 = vpaddlq_u32(count_vec_16);\n        \n        vowel_count += vgetq_lane_u32(count_vec_32, 0) + vgetq_lane_u32(count_vec_32, 1) +\n                       vgetq_lane_u32(count_vec_32, 2) + vgetq_lane_u32(count_vec_32, 3);\n    }\n    \n    // Process remaining characters\n    for (int i = vector_len; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            (c == 'y' && i == len - 1) || (c == 'Y' && i == len - 1)) {\n            vowel_count++;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t vec_len = len - (len % 16);\n    \n    // Prepare vowel comparison vectors\n    uint8x16_t vowels_lower = vcombine_u8(\n        vcreate_u8(0x6169656F7500ULL),  // 'a', 'i', 'e', 'o', 'u', null\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    uint8x16_t vowels_upper = vcombine_u8(\n        vcreate_u8(0x4149454F5500ULL),  // 'A', 'I', 'E', 'O', 'U', null\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    // Process 16 characters at a time\n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        \n        // Compare with lowercase vowels\n        uint8x16_t lower_match = vceqq_u8(chars, vowels_lower);\n        \n        // Compare with uppercase vowels\n        uint8x16_t upper_match = vceqq_u8(chars, vowels_upper);\n        \n        // Combine matches\n        uint8x16_t vowel_match = vorrq_u8(lower_match, upper_match);\n        \n        // Special handling for 'y' at the end of the word\n        if (i + 15 == len - 1) {\n            uint8x16_t y_lower = vdupq_n_u8('y');\n            uint8x16_t y_upper = vdupq_n_u8('Y');\n            uint8x16_t y_match = vorrq_u8(vceqq_u8(chars, y_lower), vceqq_u8(chars, y_upper));\n            vowel_match = vorrq_u8(vowel_match, y_match);\n        }\n        \n        // Count vowels in this chunk\n        uint8x16_t zero = vdupq_n_u8(0);\n        uint8x16_t popcount = vcntq_u8(vowel_match);\n        uint16x8_t sum_16 = vpaddlq_u8(popcount);\n        uint32x4_t sum_32 = vpaddlq_u16(sum_16);\n        uint64x2_t sum_64 = vpaddlq_u32(sum_32);\n        \n        vowel_count += vgetq_lane_u64(sum_64, 0) + vgetq_lane_u64(sum_64, 1);\n    }\n    \n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            (c == 'y' && i == len - 1) || (c == 'Y' && i == len - 1)) {\n            vowel_count++;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Process 16 characters at a time using Neon SIMD\n    int vector_len = len - (len % 16);\n    \n    // Neon vector for lowercase vowels\n    uint8x16_t vowels_lower = vcombine_u8(\n        vcreate_u8(0x6169656F7575LL),  // 'a', 'i', 'e', 'o', 'u'\n        vcreate_u8(0x0000000000LL)\n    );\n    \n    // Neon vector for uppercase vowels\n    uint8x16_t vowels_upper = vcombine_u8(\n        vcreate_u8(0x4149454F5555LL),  // 'A', 'I', 'E', 'O', 'U'\n        vcreate_u8(0x0000000000LL)\n    );\n    \n    // Process 16 characters at a time\n    for (int i = 0; i < vector_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        \n        // Check for lowercase vowels\n        uint8x16_t is_lower_vowel = vceqq_u8(chars, vowels_lower);\n        \n        // Check for uppercase vowels\n        uint8x16_t is_upper_vowel = vceqq_u8(chars, vowels_upper);\n        \n        // Combine lowercase and uppercase vowel checks\n        uint8x16_t is_vowel = vorrq_u8(is_lower_vowel, is_upper_vowel);\n        \n        // Special check for 'y' at the end of the word\n        if (i + 15 == len - 1) {\n            uint8x16_t is_y_lower = vceqq_u8(chars, vcombine_u8(vcreate_u8(0x79LL), vcreate_u8(0x00LL)));\n            uint8x16_t is_y_upper = vceqq_u8(chars, vcombine_u8(vcreate_u8(0x59LL), vcreate_u8(0x00LL)));\n            is_vowel = vorrq_u8(is_vowel, vorrq_u8(is_y_lower, is_y_upper));\n        }\n        \n        // Count vowels in the current vector\n        uint8x16_t vowel_mask = vpaddlq_u8(is_vowel);\n        vowel_count += vaddvq_u16(vowel_mask);\n    }\n    \n    // Process remaining characters\n    for (int i = vector_len; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            (i == len - 1 && (c == 'y' || c == 'Y'))) {\n            ++vowel_count;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t vec_len = len - (len % 16);\n    \n    // Prepare vowel lookup vectors\n    uint8x16_t vowels_lower = vcombine_u8(\n        vcreate_u8(0x6169656F7500ULL),  // 'a', 'i', 'e', 'o', 'u', null\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    uint8x16_t vowels_upper = vcombine_u8(\n        vcreate_u8(0x4149454F5500ULL),  // 'A', 'I', 'E', 'O', 'U', null\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    // Process 16 characters at a time\n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for lowercase vowels\n        uint8x16_t is_lower_vowel = vceqq_u8(chars, vowels_lower);\n        \n        // Check for uppercase vowels\n        uint8x16_t is_upper_vowel = vceqq_u8(chars, vowels_upper);\n        \n        // Combine lowercase and uppercase vowel checks\n        uint8x16_t is_vowel = vorrq_u8(is_lower_vowel, is_upper_vowel);\n        \n        // Special handling for 'y' at the end of the word\n        if (i + 16 == len && s[len - 1] == 'y') {\n            is_vowel = vsetq_lane_u8(0xFF, is_vowel, 15);\n        }\n        \n        // Count vowels in this chunk\n        uint8x16_t zero = vdupq_n_u8(0);\n        uint16x8_t vowel_counts_low = vpaddlq_u8(vcgtq_u8(is_vowel, zero));\n        uint32x4_t vowel_counts_high = vpaddlq_u16(vowel_counts_low);\n        uint64x2_t total_counts = vpaddlq_u32(vowel_counts_high);\n        \n        vowel_count += vgetq_lane_u64(total_counts, 0);\n        vowel_count += vgetq_lane_u64(total_counts, 1);\n    }\n    \n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||\n            (c == 'y' && i == len - 1)) {\n            vowel_count++;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t vec_len = len - (len % 16);\n    \n    // Prepare vowel comparison vectors\n    uint8x16_t vowels_lower = vcombine_u8(\n        vcreate_u8(0x6165696F7575000ULL),  // 'a', 'e', 'i', 'o', 'u'\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    uint8x16_t vowels_upper = vcombine_u8(\n        vcreate_u8(0x4145494F5555000ULL),  // 'A', 'E', 'I', 'O', 'U'\n        vcreate_u8(0x0000000000000000ULL)\n    );\n    \n    // Special handling for 'y' at the end\n    bool y_is_vowel = (s[len-1] == 'y' || s[len-1] == 'Y');\n    \n    // Process 16-byte chunks\n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        \n        // Compare with lowercase vowels\n        uint8x16_t is_lower_vowel = vcleqq_u8(chars, vowels_lower);\n        \n        // Compare with uppercase vowels\n        uint8x16_t is_upper_vowel = vcleqq_u8(chars, vowels_upper);\n        \n        // Combine results\n        uint8x16_t is_vowel = vorrq_u8(is_lower_vowel, is_upper_vowel);\n        \n        // Count vowels in this chunk\n        uint8x16_t zero = vdupq_n_u8(0);\n        uint8x16_t popcount = vcntq_u8(is_vowel);\n        vowel_count += vaddvq_u8(popcount);\n    }\n    \n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            vowel_count++;\n        }\n    }\n    \n    // Check for 'y' at the end\n    if (y_is_vowel) {\n        vowel_count++;\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    size_t vec_len = len - (len % 16);\n    uint8x16_t upper_mask = vdupq_n_u8(0x20);  // Mask to check uppercase\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check which characters are uppercase\n        uint8x16_t is_upper = veorq_u8(chars, upper_mask);\n        is_upper = vcgeq_u8(chars, vdupq_n_u8('A'));\n        is_upper = vandq_u8(is_upper, vcleq_u8(chars, vdupq_n_u8('Z')));\n        \n        // Mask uppercase characters\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        \n        // Convert to 32-bit integers and sum\n        int16x8_t upper_chars_lo = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(upper_chars)));\n        int16x8_t upper_chars_hi = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(upper_chars)));\n        \n        int32x4_t sum_lo = vpaddlq_s16(upper_chars_lo);\n        int32x4_t sum_hi = vpaddlq_s16(upper_chars_hi);\n        \n        sum_vec = vaddq_s32(sum_vec, sum_lo);\n        sum_vec = vaddq_s32(sum_vec, sum_hi);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_pair = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    result = vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n    \n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for uppercase characters\n        uint8x16_t uppercase_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        uint8x16_t uppercase_upper_mask = vcleq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t is_uppercase = vandq_u8(uppercase_mask, uppercase_upper_mask);\n        \n        // Zero out non-uppercase characters\n        uint8x16_t masked_chars = vandq_u8(chars, is_uppercase);\n        \n        // Sum the ASCII values of uppercase characters\n        uint16x8_t sum_low = vpaddlq_u8(vget_low_u8(masked_chars));\n        uint16x8_t sum_high = vpaddlq_u8(vget_high_u8(masked_chars));\n        uint32x4_t sum_32 = vpaddlq_u16(sum_low);\n        sum_32 = vpadalq_u16(sum_32, sum_high);\n        uint64x2_t sum_64 = vpaddlq_u32(sum_32);\n        \n        sum += vgetq_lane_u64(sum_64, 0) + vgetq_lane_u64(sum_64, 1);\n    }\n    \n    // Process remaining characters sequentially\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    size_t vectorLen = len - (len % 16);\n    \n    // Initialize vector to accumulate results\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vectorLen; i += 16) {\n        // Load 16 characters\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Compare characters with uppercase range (A-Z)\n        uint8x16_t is_upper_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('A')), \n            vcleq_u8(chars, vdupq_n_u8('Z'))\n        );\n        \n        // Mask out non-uppercase characters\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper_mask);\n        \n        // Convert to 16-bit integers\n        uint16x8_t upper_chars_lo = vmovl_u8(vget_low_u8(upper_chars));\n        uint16x8_t upper_chars_hi = vmovl_u8(vget_high_u8(upper_chars));\n        \n        // Convert to 32-bit integers\n        int32x4_t upper_chars_lo_lo = vmovl_s16(vget_low_s16(vreinterpretq_s16_u16(upper_chars_lo)));\n        int32x4_t upper_chars_lo_hi = vmovl_s16(vget_high_s16(vreinterpretq_s16_u16(upper_chars_lo)));\n        int32x4_t upper_chars_hi_lo = vmovl_s16(vget_low_s16(vreinterpretq_s16_u16(upper_chars_hi)));\n        int32x4_t upper_chars_hi_hi = vmovl_s16(vget_high_s16(vreinterpretq_s16_u16(upper_chars_hi)));\n        \n        // Accumulate sums\n        sum_vec = vaddq_s32(sum_vec, upper_chars_lo_lo);\n        sum_vec = vaddq_s32(sum_vec, upper_chars_lo_hi);\n        sum_vec = vaddq_s32(sum_vec, upper_chars_hi_lo);\n        sum_vec = vaddq_s32(sum_vec, upper_chars_hi_hi);\n    }\n    \n    // Horizontal sum of vector\n    int32_t lane_sum[4];\n    vst1q_s32(lane_sum, sum_vec);\n    result = lane_sum[0] + lane_sum[1] + lane_sum[2] + lane_sum[3];\n    \n    // Process remaining characters\n    for (size_t i = vectorLen; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    size_t vec_len = len - (len % 16);\n    uint8x16_t upper_mask = vdupq_n_u8(0x20);  // Mask to check uppercase\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check which characters are uppercase\n        uint8x16_t is_upper = veorq_u8(chars, upper_mask);\n        is_upper = vcgeq_u8(is_upper, chars);\n        \n        // Mask to keep only uppercase characters\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        \n        // Convert to 16-bit integers\n        int16x8_t upper_chars_lo = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(upper_chars)));\n        int16x8_t upper_chars_hi = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(upper_chars)));\n        \n        // Sum the ASCII values\n        int32x4_t sum_lo = vpaddlq_s16(upper_chars_lo);\n        int32x4_t sum_hi = vpaddlq_s16(upper_chars_hi);\n        \n        sum_vec = vaddq_s32(sum_vec, sum_lo);\n        sum_vec = vaddq_s32(sum_vec, sum_hi);\n    }\n    \n    // Horizontal sum of vector\n    int32_t lane_sum[4];\n    vst1q_s32(lane_sum, sum_vec);\n    result = lane_sum[0] + lane_sum[1] + lane_sum[2] + lane_sum[3];\n    \n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        if (isupper(s[i])) {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    size_t vec_len = len - (len % 16);\n    uint8x16_t upper_mask = vdupq_n_u8(0x20);  // Mask to check uppercase\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vec_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check which characters are uppercase\n        uint8x16_t is_upper = vceqq_u8(vandq_u8(chars, upper_mask), vdupq_n_u8(0));\n        \n        // Mask uppercase characters\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        \n        // Convert to 16-bit integers\n        int16x8_t upper_chars_low = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(upper_chars)));\n        int16x8_t upper_chars_high = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(upper_chars)));\n        \n        // Sum the ASCII values\n        int32x4_t sum_low = vpaddlq_s16(upper_chars_low);\n        int32x4_t sum_high = vpaddlq_s16(upper_chars_high);\n        \n        sum_vec = vaddq_s32(sum_vec, sum_low);\n        sum_vec = vaddq_s32(sum_vec, sum_high);\n    }\n    \n    // Horizontal sum of vector\n    int32_t lane_sum[4];\n    vst1q_s32(lane_sum, sum_vec);\n    result += lane_sum[0] + lane_sum[1] + lane_sum[2] + lane_sum[3];\n    \n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        if (isupper(s[i])) {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    int min_even_val = INT_MAX;\n    int min_even_idx = -1;\n\n    // Process 4 elements at a time using Neon SIMD\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even numbers\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)));\n        \n        // Zero out odd numbers\n        int32x4_t even_vec = vbslq_s32(even_mask, vec, vdupq_n_s32(INT_MAX));\n        \n        // Find minimum even value and its index\n        int32x4_t min_vec = even_vec;\n        min_vec = vminq_s32(min_vec, vextq_s32(min_vec, min_vec, 2));\n        min_vec = vminq_s32(min_vec, vextq_s32(min_vec, min_vec, 1));\n        \n        int lane_min = vgetq_lane_s32(min_vec, 0);\n        \n        for (int j = 0; j < 4; j++) {\n            int curr_val = vgetq_lane_s32(even_vec, j);\n            if (curr_val < min_even_val) {\n                min_even_val = curr_val;\n                min_even_idx = i + j;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even_val) {\n            min_even_val = arr[i];\n            min_even_idx = i;\n        }\n    }\n\n    if (min_even_idx == -1) return {};\n    return {min_even_val, min_even_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    int min_even_val = INT_MAX;\n    int min_even_idx = -1;\n\n    // Process 4 elements at a time using Neon\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even values\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)));\n        \n        // Zero out odd values\n        int32x4_t even_vec = vbslq_s32(even_mask, vec, vdupq_n_s32(INT_MAX));\n        \n        // Find minimum even value and its index\n        int32x4_t min_vec = even_vec;\n        min_vec = vminq_s32(min_vec, vextq_s32(min_vec, min_vec, 2));\n        min_vec = vminq_s32(min_vec, vextq_s32(min_vec, min_vec, 1));\n        \n        int lane_min = vgetq_lane_s32(min_vec, 0);\n        \n        for (int j = 0; j < 4; j++) {\n            int curr_val = vgetq_lane_s32(even_vec, j);\n            if (curr_val < min_even_val || (curr_val == min_even_val && i + j < min_even_idx)) {\n                min_even_val = curr_val;\n                min_even_idx = i + j;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && (arr[i] < min_even_val || (arr[i] == min_even_val && i < min_even_idx))) {\n            min_even_val = arr[i];\n            min_even_idx = i;\n        }\n    }\n\n    if (min_even_idx == -1) return {};\n    return {min_even_val, min_even_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    int min_even_val = INT_MAX;\n    int min_even_idx = -1;\n\n    // Process 4 elements at a time using Neon\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even values\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)));\n        \n        // Zero out odd values\n        int32x4_t even_vec = vbslq_s32(even_mask, vec, vdupq_n_s32(INT_MAX));\n        \n        // Find minimum even value\n        int32x4_t min_vec = vpminq_s32(even_vec, even_vec);\n        int32_t lane_min = vgetq_lane_s32(min_vec, 0);\n        \n        // Check if this lane's minimum is smaller than current\n        for (int j = 0; j < 4; j++) {\n            int curr_val = vgetq_lane_s32(even_vec, j);\n            if (curr_val < min_even_val) {\n                min_even_val = curr_val;\n                min_even_idx = i + j;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even_val) {\n            min_even_val = arr[i];\n            min_even_idx = i;\n        }\n    }\n\n    // Return result\n    return (min_even_idx != -1) ? std::vector<int>{min_even_val, min_even_idx} : std::vector<int>{};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    int min_even_val = INT_MAX;\n    int min_even_idx = -1;\n\n    // Process 4 elements at a time using Neon SIMD\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        // Load 4 integers into Neon vector\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        // Create mask for even numbers\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)));\n\n        // Check if any elements are even\n        if (vgetq_lane_u32(even_mask, 0) || \n            vgetq_lane_u32(even_mask, 1) || \n            vgetq_lane_u32(even_mask, 2) || \n            vgetq_lane_u32(even_mask, 3)) {\n            \n            for (int j = 0; j < 4; j++) {\n                if ((arr[i+j] % 2 == 0) && (arr[i+j] < min_even_val || \n                    (arr[i+j] == min_even_val && i+j < min_even_idx))) {\n                    min_even_val = arr[i+j];\n                    min_even_idx = i+j;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if ((arr[i] % 2 == 0) && (arr[i] < min_even_val || \n            (arr[i] == min_even_val && i < min_even_idx))) {\n            min_even_val = arr[i];\n            min_even_idx = i;\n        }\n    }\n\n    // Return result\n    return (min_even_idx != -1) ? std::vector<int>{min_even_val, min_even_idx} : std::vector<int>{};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    int n = arr.size();\n    int min_even_val = INT_MAX;\n    int min_even_idx = -1;\n\n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even values\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)));\n        \n        // Mask out odd values\n        int32x4_t even_vec = vbslq_s32(even_mask, vec, vdupq_n_s32(INT_MAX));\n        \n        // Find minimum even value and its index\n        int32x4_t min_vec = even_vec;\n        min_vec = vminq_s32(min_vec, vextq_s32(min_vec, min_vec, 2));\n        min_vec = vminq_s32(min_vec, vextq_s32(min_vec, min_vec, 1));\n        \n        int lane_min = vgetq_lane_s32(min_vec, 0);\n        \n        // Check if this lane's min is smaller than current min\n        for (int j = 0; j < 4; j++) {\n            int curr_val = vgetq_lane_s32(even_vec, j);\n            if (curr_val < min_even_val) {\n                min_even_val = curr_val;\n                min_even_idx = i + j;\n            }\n        }\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even_val) {\n            min_even_val = arr[i];\n            min_even_idx = i;\n        }\n    }\n    \n    if (min_even_idx == -1) return {};\n    return {min_even_val, min_even_idx};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find max element to determine frequency array size\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Use NEON to count frequencies\n    int vec_size = n - (n % 4);\n    for (int i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Increment frequency for each element\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size; i < n; i++) {\n        if (lst[i] > 0 && lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n\n    // Find max value satisfying condition\n    for (int i = max_val; i > 0; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Count frequencies using Neon\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Process 4 elements at a time\n    int i = 0;\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    for (; i + 3 < n; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Increment frequency for each element\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (lst[i] > 0 && lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n\n    // Find the result\n    for (int k = max_val; k > 0; k--) {\n        if (freq[k] >= k) {\n            return k;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    \n    // Count frequencies using Neon\n    int32_t max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Increment frequency for each element\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        if (lst[i] > 0 && lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n    \n    // Find the result\n    for (int val = max_val; val > 0; val--) {\n        if (freq[val] >= val) {\n            return val;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find max element to determine frequency array size\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Use Neon to count frequencies\n    int vec_size = n - (n % 4);\n    for (int i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Increment frequency for each element\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size; i < n; i++) {\n        if (lst[i] > 0 && lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n\n    // Find max value satisfying condition\n    for (int i = max_val; i > 0; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find max element to determine frequency array size\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Use NEON to count frequencies\n    int vec_size = n - (n % 4);\n    for (int i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Increment frequency for each element\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size; i < n; i++) {\n        if (lst[i] > 0 && lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n\n    // Find max value satisfying condition\n    for (int i = max_val; i > 0; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check total weight first\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for (int i = 0; i < n; i += 4) {\n        int remaining = n - i;\n        int load_count = (remaining < 4) ? remaining : 4;\n        \n        int32x4_t current_vec;\n        switch(load_count) {\n            case 4:\n                current_vec = vld1q_s32(&q[i]);\n                break;\n            case 3:\n                current_vec = vcombine_s32(\n                    vld1_s32(&q[i]), \n                    vcreate_s32(0)\n                );\n                break;\n            case 2:\n                current_vec = vdup_n_s32(0);\n                current_vec = vset_lane_s32(q[i], current_vec, 0);\n                current_vec = vset_lane_s32(q[i+1], current_vec, 1);\n                current_vec = vcombine_s32(current_vec, vcreate_s32(0));\n                break;\n            case 1:\n                current_vec = vdupq_n_s32(q[i]);\n                break;\n        }\n        \n        sum_vec = vaddq_s32(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    int total_sum = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Check weight constraint\n    if (total_sum > w) return false;\n    \n    // Check palindrome\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check total weight\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for (int i = 0; i < n; i += 4) {\n        int remaining = std::min(4, n - i);\n        int32x4_t chunk;\n        \n        switch(remaining) {\n            case 4:\n                chunk = vld1q_s32(&q[i]);\n                break;\n            case 3:\n                chunk = vcombine_s32(vld1_s32(&q[i]), vcreate_s32(0));\n                break;\n            case 2:\n                chunk = vcombine_s32(vld1_s32(&q[i]), vcreate_s32(0));\n                break;\n            case 1:\n                chunk = vsetq_lane_s32(q[i], vdupq_n_s32(0), 0);\n                break;\n        }\n        \n        sum_vec = vaddq_s32(sum_vec, chunk);\n    }\n    \n    int total_sum = vaddvq_s32(sum_vec);\n    \n    if (total_sum > w) return false;\n    \n    // Check balance (palindrome)\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check total weight\n    int32x4_t sum_vector = vdupq_n_s32(0);\n    for (int i = 0; i < n; i += 4) {\n        int remaining = std::min(4, n - i);\n        int32x4_t chunk;\n        \n        switch(remaining) {\n            case 4:\n                chunk = vld1q_s32(&q[i]);\n                break;\n            case 3:\n                chunk = vcombine_s32(vld1_s32(&q[i]), vcreate_s32(0));\n                break;\n            case 2:\n                chunk = vcombine_s32(vdup_n_s32(q[i]), vdup_n_s32(q[i+1]));\n                break;\n            case 1:\n                chunk = vdupq_n_s32(q[i]);\n                break;\n        }\n        \n        sum_vector = vaddq_s32(sum_vector, chunk);\n    }\n    \n    // Horizontal sum\n    int32x2_t sum_low = vget_low_s32(sum_vector);\n    int32x2_t sum_high = vget_high_s32(sum_vector);\n    int32x2_t sum_combined = vadd_s32(sum_low, sum_high);\n    int total_sum = vget_lane_s32(sum_combined, 0) + vget_lane_s32(sum_combined, 1);\n    \n    // Check weight constraint\n    if (total_sum > w) return false;\n    \n    // Check palindrome\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check total weight first\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for (int i = 0; i < n; i += 4) {\n        int remaining = n - i;\n        int load_count = (remaining < 4) ? remaining : 4;\n        \n        int32x4_t current_vec;\n        switch(load_count) {\n            case 4:\n                current_vec = vld1q_s32(&q[i]);\n                break;\n            case 3:\n                current_vec = vcombine_s32(\n                    vld1_s32(&q[i]), \n                    vcreate_s32(0)\n                );\n                break;\n            case 2:\n                current_vec = vdup_n_s32(0);\n                current_vec = vset_lane_s32(q[i], current_vec, 0);\n                current_vec = vset_lane_s32(q[i+1], current_vec, 1);\n                current_vec = vcombine_s32(current_vec, vcreate_s32(0));\n                break;\n            case 1:\n                current_vec = vdupq_n_s32(q[i]);\n                break;\n        }\n        \n        sum_vec = vaddq_s32(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    int total_sum = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Check weight constraint\n    if (total_sum > w) return false;\n    \n    // Check palindrome\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if sum of elements exceeds max weight\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, chunk);\n    }\n    \n    int32_t total_sum = vaddvq_s32(sum_vec);\n    for (int i = (n / 4) * 4; i < n; i++) {\n        total_sum += q[i];\n    }\n    \n    if (total_sum > w) {\n        return false;\n    }\n    \n    // Check if vector is balanced (palindromic)\n    for (int i = 0; i < n / 2; i += 4) {\n        int32x4_t left = vld1q_s32(&q[i]);\n        int32x4_t right = vld1q_s32(&q[n - 1 - i - 3]);\n        \n        // Reverse right vector\n        int32x4_t right_rev = vrev64q_s32(right);\n        right_rev = vcombine_s32(vget_high_s32(right_rev), vget_low_s32(right_rev));\n        \n        uint32x4_t cmp = vceqq_s32(left, right_rev);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n    \n    // Handle remaining elements for odd-length vectors\n    for (int i = (n / 2 / 4) * 4; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int vector_size = n - (n % 4);\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&arr[i]);\n        int32x4_t vec2 = vld1q_s32(&arr[n - i - 4]);\n        \n        // Compare corresponding elements\n        uint32x4_t compare_mask = vceqq_s32(vec1, vec2);\n        \n        // Count mismatches\n        uint32x2_t low = vget_low_u32(compare_mask);\n        uint32x2_t high = vget_high_u32(compare_mask);\n        \n        uint32x2_t sum_low = vpmin_u32(low, low);\n        uint32x2_t sum_high = vpmin_u32(high, high);\n        \n        uint32_t result_low = vget_lane_u32(sum_low, 0);\n        uint32_t result_high = vget_lane_u32(sum_high, 0);\n        \n        changes += 4 - __builtin_popcount(result_low | result_high);\n    }\n    \n    // Handle remaining elements\n    for (int i = vector_size; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_width = 4;\n    for (int i = 0; i < n / 2; i += simd_width) {\n        // Load 4 elements from start and end of array\n        int32x4_t start_vec = vld1q_s32(&arr[i]);\n        int32x4_t end_vec = vld1q_s32(&arr[n - 4 - i]);\n        \n        // Reverse the end vector\n        int32x4_t reversed_end_vec = vrev64q_s32(start_vec);\n        \n        // Compare elements\n        uint32x4_t compare_mask = vceqq_s32(start_vec, reversed_end_vec);\n        \n        // Count mismatches\n        uint32x2_t low = vget_low_u32(compare_mask);\n        uint32x2_t high = vget_high_u32(compare_mask);\n        \n        // Horizontal add to count non-matching elements\n        uint32x2_t sum = vadd_u32(low, high);\n        uint32_t total_match = vget_lane_u32(sum, 0) + vget_lane_u32(sum, 1);\n        \n        changes += (4 - __builtin_popcount(total_match));\n    }\n    \n    // Handle remaining elements if vector length is not multiple of 4\n    for (int i = n / 2 - (n % 4); i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int vector_size = n - (n % 4);\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&arr[i]);\n        int32x4_t vec2 = vld1q_s32(&arr[n - i - 4]);\n        \n        // Compare corresponding elements\n        uint32x4_t compare_mask = vceqq_s32(vec1, vec2);\n        \n        // Count mismatches\n        uint32x4_t mismatch_mask = vmvnq_u32(compare_mask);\n        changes += vaddvq_u32(mismatch_mask) / 2;\n    }\n    \n    // Handle remaining elements\n    for (int i = vector_size; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int vector_length = n - (n % 4);\n    for (int i = 0; i < vector_length; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&arr[i]);\n        int32x4_t vec2 = vld1q_s32(&arr[n - i - 4]);\n        \n        // Compare corresponding elements\n        uint32x4_t compare_mask = vceqq_s32(vec1, vec2);\n        \n        // Count mismatches\n        uint32x4_t mismatch_mask = vmvnq_u32(compare_mask);\n        changes += vaddvq_u32(mismatch_mask) / 2;\n    }\n    \n    // Handle remaining elements\n    for (int i = vector_length; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_width = 4;\n    int vector_length = n - (n % simd_width);\n    \n    for (int i = 0; i < vector_length; i += simd_width) {\n        // Load 4 elements from the start and end\n        int32x4_t start_vec = vld1q_s32(&arr[i]);\n        int32x4_t end_vec = vld1q_s32(&arr[n - i - simd_width]);\n        \n        // Reverse the end vector\n        int32x4_t reversed_end_vec = vrev64q_s32(start_vec);\n        reversed_end_vec = vcombine_s32(vget_high_s32(reversed_end_vec), vget_low_s32(reversed_end_vec));\n        \n        // Compare elements\n        uint32x4_t compare_mask = vceqq_s32(start_vec, reversed_end_vec);\n        \n        // Count mismatches\n        int32x4_t mismatch_count = vmvnq_s32(compare_mask);\n        changes += vaddvq_s32(mismatch_count) / 2;\n    }\n    \n    // Handle remaining elements\n    for (int i = vector_length; i < n / 2; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters for first vector\n    size_t total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters for second vector\n    size_t total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return vector with fewer total characters\n    // If equal, return first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters in first vector\n    size_t total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters in second vector\n    size_t total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // If total chars are equal or first vector has less, return first vector\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    }\n\n    // Otherwise return second vector\n    return lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters for lst1\n    size_t total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters for lst2\n    size_t total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return the vector with fewer total characters\n    // If equal, return the first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters in lst1\n    size_t total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    size_t total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return the vector with fewer total characters\n    // If equal, return the first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters in lst1\n    size_t total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    size_t total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return the vector with fewer total characters\n    // If equal, return the first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Handle edge cases\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Use Neon intrinsics to compute logarithm\n    float64x2_t x_vec = vdupq_n_f64((double)x);\n    float64x2_t n_vec = vdupq_n_f64((double)n);\n    \n    // Compute log(x) / log(n)\n    float64x2_t log_x = vlogq_f64(x_vec);\n    float64x2_t log_n = vlogq_f64(n_vec);\n    float64x2_t log_div = vdivq_f64(log_x, log_n);\n\n    // Check if result is an integer\n    float64x2_t rounded = vrndq_f64(log_div);\n    uint64x2_t comparison = vceqq_f64(log_div, rounded);\n\n    // Horizontal AND to check if any lane is true\n    uint64_t result = vgetq_lane_u64(comparison, 0);\n    return result != 0;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 1) return false;\n    if (x == n) return true;\n\n    // Use Neon intrinsics for parallel computation\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t result_vec = one_vec;\n\n    // Parallel power computation\n    for (int i = 0; i < 64; i++) {\n        result_vec = vmulq_u64(result_vec, n_vec);\n        uint64x2_t cmp_vec = vceqq_u64(result_vec, x_vec);\n        \n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Handle special cases\n    if (n <= 1 || x == 1) return false;\n    if (x == n) return true;\n\n    // Use Neon intrinsics to compute powers efficiently\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t result_vec = one_vec;\n\n    // Parallel power computation\n    for (int i = 0; i < 64; i++) {\n        result_vec = vmulq_u64(result_vec, n_vec);\n        uint64x2_t compare_vec = vceqq_u64(result_vec, x_vec);\n        \n        if (vgetq_lane_u64(compare_vec, 0) || vgetq_lane_u64(compare_vec, 1)) {\n            return true;\n        }\n        \n        // Break if result exceeds x\n        if (vgetq_lane_u64(result_vec, 0) > x || vgetq_lane_u64(result_vec, 1) > x) {\n            break;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Use Neon 64-bit vector operations\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    \n    // Initial power value\n    uint64x2_t power_vec = n_vec;\n    \n    // Maximum iterations to prevent infinite loop\n    for (int i = 1; i <= 64; i++) {\n        // Compare if current power matches x\n        uint64x2_t cmp_vec = vceqq_u64(power_vec, x_vec);\n        \n        // Check if any vector lane matches\n        if (vgetq_lane_u64(cmp_vec, 0) || vgetq_lane_u64(cmp_vec, 1)) {\n            return true;\n        }\n        \n        // Multiply power by n\n        power_vec = vmulq_u64(power_vec, n_vec);\n        \n        // Break if power exceeds x\n        if (vgetq_lane_u64(power_vec, 0) > x || vgetq_lane_u64(power_vec, 1) > x) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Use Neon 64-bit vector operations\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n    uint64x2_t result_vec = one_vec;\n\n    // Perform parallel power computation\n    for (int i = 0; i < 64; i++) {\n        // Multiply result by n if current bit is set\n        uint64x2_t compare = vceqq_u64(vandq_u64(vdupq_n_u64(1ULL << i), x_vec), x_vec);\n        result_vec = vmulq_u64(result_vec, vbslq_u64(compare, n_vec, one_vec));\n    }\n\n    // Check if any vector element matches x\n    return vgetq_lane_u64(vceqq_u64(result_vec, x_vec), 0) || \n           vgetq_lane_u64(vceqq_u64(result_vec, x_vec), 1);\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_hex_digits[] = {2, 3, 5, 7, 11, 13};\n    \n    int prime_count = 0;\n    const int vector_size = 16;\n    \n    // Process 16 characters at a time using Neon\n    for (size_t i = 0; i < num.length(); i += vector_size) {\n        // Load 16 characters into Neon register\n        uint8x16_t hex_chars = vld1q_u8(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        \n        // Convert hex characters to decimal values\n        uint8x16_t decimal_values = vsubq_u8(hex_chars, vdupq_n_u8('0'));\n        \n        // Handle A-F conversion\n        uint8x16_t hex_offset = vcgeq_u8(hex_chars, vdupq_n_u8('A'));\n        uint8x16_t hex_correction = vandq_u8(hex_offset, vdupq_n_u8(9));\n        decimal_values = vaddq_u8(decimal_values, hex_correction);\n        \n        // Create mask for prime digits\n        uint8x16_t prime_mask = vdupq_n_u8(0);\n        for (int j = 0; j < 6; j++) {\n            uint8x16_t prime_check = vceqq_u8(decimal_values, vdupq_n_u8(prime_hex_digits[j]));\n            prime_mask = vorrq_u8(prime_mask, prime_check);\n        }\n        \n        // Count prime digits\n        uint8x16_t result_mask = vandq_u8(prime_mask, vdupq_n_u8(1));\n        int16x8_t result_low = vpaddlq_u8(result_mask);\n        int32x4_t result_final = vpaddlq_s16(result_low);\n        \n        // Sum up prime digits\n        prime_count += vgetq_lane_s32(result_final, 0) + \n                       vgetq_lane_s32(result_final, 1) + \n                       vgetq_lane_s32(result_final, 2) + \n                       vgetq_lane_s32(result_final, 3);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = num.length() - (num.length() % vector_size); i < num.length(); i++) {\n        int val = (num[i] >= 'A') ? (num[i] - 'A' + 10) : (num[i] - '0');\n        if (val == 2 || val == 3 || val == 5 || val == 7 || val == 11 || val == 13) {\n            prime_count++;\n        }\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_mask[] = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    int count = 0;\n    int len = num.length();\n    int vector_len = len - (len % 16);\n\n    // Process 16 characters at a time using Neon\n    for (int i = 0; i < vector_len; i += 16) {\n        // Convert hex characters to their numeric values\n        uint8x16_t hex_values = vdupq_n_u8(0);\n        for (int j = 0; j < 16; j++) {\n            char c = num[i + j];\n            uint8_t val;\n            if (c >= '0' && c <= '9') \n                val = c - '0';\n            else \n                val = c - 'A' + 10;\n            hex_values = vsetq_lane_u8(val, hex_values, j);\n        }\n\n        // Load prime mask as a vector\n        uint8x16_t prime_mask_vec = vld1q_u8(prime_mask);\n\n        // Compare hex values with prime mask\n        uint8x16_t is_prime = vceqq_u8(prime_mask_vec, vgetq_lane_u8(prime_mask_vec, 0));\n\n        // Count prime digits\n        uint8x16_t count_vec = vandq_u8(is_prime, vdupq_n_u8(1));\n        count += vaddvq_u8(count_vec);\n    }\n\n    // Process remaining characters\n    for (int i = vector_len; i < len; i++) {\n        char c = num[i];\n        uint8_t val;\n        if (c >= '0' && c <= '9') \n            val = c - '0';\n        else \n            val = c - 'A' + 10;\n\n        if (prime_mask[val]) \n            count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_mask[] = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    int prime_count = 0;\n    size_t len = num.length();\n    size_t vec_len = len - (len % 16);\n\n    // Process 16 characters at a time using Neon\n    for (size_t i = 0; i < vec_len; i += 16) {\n        // Convert hex characters to their numeric values\n        uint8x16_t hex_values = vdupq_n_u8(0);\n        for (size_t j = 0; j < 16; ++j) {\n            char c = num[i + j];\n            uint8_t val;\n            if (c >= '0' && c <= '9') \n                val = c - '0';\n            else \n                val = c - 'A' + 10;\n            hex_values = vsetq_lane_u8(val, hex_values, j);\n        }\n\n        // Use prime mask to count prime digits\n        uint8x16_t prime_values = vld1q_u8(prime_mask);\n        uint8x16_t is_prime = vqtbl1q_u8(prime_values, hex_values);\n        uint8x16_t zero_vec = vdupq_n_u8(0);\n        uint8x16_t cmp_result = vceqq_u8(is_prime, zero_vec);\n        uint8x16_t inv_cmp_result = vmvnq_u8(cmp_result);\n        \n        // Horizontal sum of prime digits\n        uint16x8_t sum_low = vpaddlq_u8(inv_cmp_result);\n        uint32x4_t sum_wider = vpaddlq_u16(sum_low);\n        uint64x2_t sum_widest = vpaddlq_u32(sum_wider);\n        \n        prime_count += vgetq_lane_u64(sum_widest, 0) + vgetq_lane_u64(sum_widest, 1);\n    }\n\n    // Process remaining characters\n    for (size_t i = vec_len; i < len; ++i) {\n        char c = num[i];\n        int val;\n        if (c >= '0' && c <= '9') \n            val = c - '0';\n        else \n            val = c - 'A' + 10;\n        \n        if (prime_mask[val]) \n            ++prime_count;\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_mask[] = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    int count = 0;\n    int len = num.length();\n    int vector_len = len - (len % 16);\n\n    // Process 16 characters at a time using NEON\n    for (int i = 0; i < vector_len; i += 16) {\n        // Convert hex characters to their numeric values\n        uint8x16_t hex_values = vdupq_n_u8(0);\n        for (int j = 0; j < 16; j++) {\n            char c = num[i + j];\n            uint8_t val;\n            if (c >= '0' && c <= '9') \n                val = c - '0';\n            else \n                val = c - 'A' + 10;\n            hex_values = vsetq_lane_u8(val, hex_values, j);\n        }\n\n        // Create a vector of prime mask values\n        uint8x16_t prime_mask_vec = vld1q_u8(prime_mask);\n\n        // Compare hex values with prime mask\n        uint8x16_t prime_check = vqtbl1q_u8(prime_mask_vec, hex_values);\n\n        // Count the number of prime digits\n        uint8x16_t zero_vec = vdupq_n_u8(0);\n        uint8x16_t compare_result = vceqq_u8(prime_check, zero_vec);\n        uint8x16_t inverted_result = vmvnq_u8(compare_result);\n        \n        uint64x2_t sum = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(inverted_result)));\n        count += vgetq_lane_u64(sum, 0) + vgetq_lane_u64(sum, 1);\n    }\n\n    // Process remaining characters\n    for (int i = vector_len; i < len; i++) {\n        char c = num[i];\n        int val;\n        if (c >= '0' && c <= '9') \n            val = c - '0';\n        else \n            val = c - 'A' + 10;\n        \n        if (prime_mask[val]) \n            count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_digits[] = {2, 3, 5, 7, 11, 13};\n    int prime_count = 0;\n    \n    // Process 16 characters at a time using Neon\n    int i = 0;\n    for (; i + 15 < num.length(); i += 16) {\n        // Load 16 hex characters\n        uint8x16_t hex_chars = vld1q_u8(reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        \n        // Convert ASCII to numeric values\n        uint8x16_t zero = vdupq_n_u8('0');\n        uint8x16_t nine = vdupq_n_u8('9');\n        uint8x16_t A_offset = vdupq_n_u8('A' - 10);\n        \n        // Mask for digits 0-9\n        uint8x16_t digit_mask = vandq_u8(vcgeq_u8(hex_chars, zero), vcleq_u8(hex_chars, nine));\n        \n        // Mask for A-F\n        uint8x16_t hex_mask = vandq_u8(vcgeq_u8(hex_chars, vdupq_n_u8('A')), vcleq_u8(hex_chars, vdupq_n_u8('F')));\n        \n        // Convert digits\n        uint8x16_t numeric_chars = vbslq_u8(digit_mask, \n            vsubq_u8(hex_chars, zero), \n            vaddq_u8(vsubq_u8(hex_chars, A_offset), vdupq_n_u8(10))\n        );\n        \n        // Check prime digits\n        uint8x16_t prime_mask = vdupq_n_u8(0);\n        for (int j = 0; j < 6; j++) {\n            uint8x16_t prime_check = vceqq_u8(numeric_chars, vdupq_n_u8(prime_digits[j]));\n            prime_mask = vorrq_u8(prime_mask, prime_check);\n        }\n        \n        // Count prime digits\n        prime_count += vaddvq_u8(vandq_u8(prime_mask, vorrq_u8(digit_mask, hex_mask)));\n    }\n    \n    // Process remaining characters\n    for (; i < num.length(); i++) {\n        int val;\n        if (num[i] >= '0' && num[i] <= '9') {\n            val = num[i] - '0';\n        } else {\n            val = num[i] - 'A' + 10;\n        }\n        \n        for (int j = 0; j < 6; j++) {\n            if (val == prime_digits[j]) {\n                prime_count++;\n                break;\n            }\n        }\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // If string length is less than 3, it cannot be happy\n    if (s.length() < 3) return false;\n\n    // Process 16 characters at a time using Neon SIMD\n    int i = 0;\n    for (; i + 16 <= s.length(); i += 16) {\n        // Load 16 characters into Neon register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for 3 consecutive distinct characters in 16-byte chunks\n        for (int j = 0; j < 14; j++) {\n            uint8x16_t subset = vextq_u8(chars, chars, j);\n            uint8x16_t first = vdupq_n_u8(subset[0]);\n            uint8x16_t second = vdupq_n_u8(subset[1]);\n            uint8x16_t third = vdupq_n_u8(subset[2]);\n            \n            // Compare if any two characters are the same\n            uint8x16_t compare1 = vceqq_u8(first, second);\n            uint8x16_t compare2 = vceqq_u8(first, third);\n            uint8x16_t compare3 = vceqq_u8(second, third);\n            \n            // If any comparison is true, characters are not distinct\n            if (vaddvq_u8(compare1) || vaddvq_u8(compare2) || vaddvq_u8(compare3)) {\n                return false;\n            }\n        }\n    }\n\n    // Process remaining characters\n    for (; i + 2 < s.length(); i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // If string length is less than 3, it cannot be happy\n    if (s.length() < 3) return false;\n\n    // Process 16 characters at a time using Neon SIMD\n    int i = 0;\n    for (; i + 16 <= s.length(); i += 16) {\n        // Load 16 consecutive characters\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for 4 consecutive 3-character windows\n        for (int j = 0; j < 14; j += 4) {\n            // Extract 3 characters for each window\n            uint8x16_t window1 = vextq_u8(chars, chars, j);\n            uint8x16_t window2 = vextq_u8(chars, chars, j+1);\n            uint8x16_t window3 = vextq_u8(chars, chars, j+2);\n\n            // Compare characters within each window\n            uint8x16_t distinct1 = vceqq_u8(window1, window2);\n            uint8x16_t distinct2 = vceqq_u8(window1, window3);\n            uint8x16_t distinct3 = vceqq_u8(window2, window3);\n\n            // If any characters are the same, not happy\n            if (vaddvq_u8(distinct1) || vaddvq_u8(distinct2) || vaddvq_u8(distinct3)) {\n                return false;\n            }\n        }\n    }\n\n    // Process remaining characters sequentially\n    for (; i + 2 < s.length(); i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // If string length is less than 3, it cannot be happy\n    if (s.length() < 3) return false;\n\n    // Process 16 characters at a time using Neon SIMD\n    int i = 0;\n    for (; i + 16 <= s.length(); i += 16) {\n        // Load 16 characters into Neon vector\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for 3 consecutive distinct characters in 16-byte chunks\n        for (int j = 0; j < 14; j++) {\n            uint8x16_t slice = vextq_u8(chars, chars, j);\n            uint8x16_t next = vextq_u8(chars, chars, j + 1);\n            uint8x16_t last = vextq_u8(chars, chars, j + 2);\n            \n            // Check if any 3 consecutive characters are the same\n            uint8x16_t eq1 = vceqq_u8(slice, next);\n            uint8x16_t eq2 = vceqq_u8(slice, last);\n            uint8x16_t eq3 = vceqq_u8(next, last);\n            \n            uint8x16_t any_equal = vorrq_u8(vorrq_u8(eq1, eq2), eq3);\n            \n            if (vmaxvq_u8(any_equal) > 0) {\n                return false;\n            }\n        }\n    }\n\n    // Process remaining characters sequentially\n    for (; i + 2 < s.length(); i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // If string length is less than 3, it cannot be happy\n    if (s.length() < 3) return false;\n\n    // Process 16 characters at a time using Neon SIMD\n    int i = 0;\n    for (; i + 16 <= s.length(); i += 16) {\n        // Load 16 characters into Neon register\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for 3 consecutive distinct characters in 16-byte chunks\n        for (int j = 0; j < 14; j++) {\n            uint8x16_t subset = vextq_u8(chars, chars, j);\n            uint8x16_t first = vdupq_n_u8(subset[0]);\n            uint8x16_t second = vdupq_n_u8(subset[1]);\n            uint8x16_t third = vdupq_n_u8(subset[2]);\n            \n            // Compare if any two characters are the same\n            uint8x16_t compare1 = vceqq_u8(first, second);\n            uint8x16_t compare2 = vceqq_u8(first, third);\n            uint8x16_t compare3 = vceqq_u8(second, third);\n            \n            // If any comparison is true, return false\n            if (vaddvq_u8(compare1) || vaddvq_u8(compare2) || vaddvq_u8(compare3)) {\n                return false;\n            }\n        }\n    }\n\n    // Process remaining characters sequentially\n    for (; i + 2 < s.length(); i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // If string length is less than 3, it cannot be happy\n    if (s.length() < 3) return false;\n\n    // Process 16 characters at a time using Neon SIMD\n    int i = 0;\n    for (; i + 16 <= s.length(); i += 16) {\n        // Load 16 consecutive characters\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for 3 consecutive distinct characters in 16-byte chunk\n        for (int j = 0; j < 14; j++) {\n            uint8x16_t subset = vextq_u8(chars, chars, j);\n            uint8x16_t first = vdupq_n_u8(subset[0]);\n            uint8x16_t second = vdupq_n_u8(subset[1]);\n            uint8x16_t third = vdupq_n_u8(subset[2]);\n            \n            // Compare if all 3 characters are different\n            uint8x16_t compare1 = vceqq_u8(first, second);\n            uint8x16_t compare2 = vceqq_u8(first, third);\n            uint8x16_t compare3 = vceqq_u8(second, third);\n            \n            // If any comparison is true, characters are not distinct\n            if (vaddvq_u8(compare1) || vaddvq_u8(compare2) || vaddvq_u8(compare3)) {\n                return false;\n            }\n        }\n    }\n\n    // Process remaining characters sequentially\n    for (; i + 2 < s.length(); i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Fast check for small primes\n    if (len == 2 || len == 3 || len == 5 || len == 7 || len == 11 || len == 13) {\n        return true;\n    }\n    \n    // Quick elimination of even lengths\n    if (len <= 1 || len % 2 == 0) {\n        return false;\n    }\n    \n    // Use NEON for parallel primality checking\n    int sqrt_len = std::sqrt(len);\n    \n    // Process 4 divisors in parallel using Neon\n    for (int i = 3; i <= sqrt_len; i += 4) {\n        int32x4_t divisors = {i, i+1, i+2, i+3};\n        int32x4_t zero = vdupq_n_s32(0);\n        int32x4_t length = vdupq_n_s32(len);\n        \n        // Parallel modulo operations\n        int32x4_t mod_results = vmodq_s32(length, divisors);\n        \n        // Check if any divisor divides length evenly\n        uint32x4_t compare = vceqq_s32(mod_results, zero);\n        \n        if (vgetq_lane_u32(compare, 0) || \n            vgetq_lane_u32(compare, 1) || \n            vgetq_lane_u32(compare, 2) || \n            vgetq_lane_u32(compare, 3)) {\n            return false;\n        }\n    }\n    \n    // Check remaining divisors\n    for (int i = sqrt_len + 1; i <= sqrt_len; i++) {\n        if (len % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Quick checks for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // Use Neon to parallelize primality check\n    int32x4_t divisors = {5, 7, 11, 13};\n    int32x4_t increments = {6, 6, 6, 6};\n    uint32_t max_divisor = sqrt(len);\n\n    for (int32_t i = 0; i <= max_divisor; i += 24) {\n        int32x4_t current_divisors = divisors;\n        uint32x4_t comparison = vcgtq_u32(vmovq_n_u32(len), current_divisors);\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(comparison, j) && (len % vgetq_lane_u32(current_divisors, j) == 0)) {\n                return false;\n            }\n        }\n        \n        divisors = vaddq_s32(divisors, increments);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Fast check for small primes\n    if (len == 2 || len == 3 || len == 5 || len == 7 || len == 11 || len == 13) {\n        return true;\n    }\n    \n    // Quick elimination of even lengths\n    if (len <= 1 || len % 2 == 0) {\n        return false;\n    }\n    \n    // Use Neon to parallelize primality check\n    int sqrt_len = static_cast<int>(std::sqrt(len));\n    \n    // Process multiple divisors in parallel using Neon\n    for (int i = 3; i <= sqrt_len; i += 4) {\n        // Load 4 potential divisors\n        int32x4_t divisors = {i, i+1, i+2, i+3};\n        \n        // Broadcast length to all lanes\n        int32x4_t length_vec = vdupq_n_s32(len);\n        \n        // Compute modulo in parallel\n        int32x4_t mod_results = vmovq_n_s32(0);\n        mod_results = vremq_s32(length_vec, divisors);\n        \n        // Check if any modulo is zero\n        uint32x4_t zero_check = vceqzq_s32(mod_results);\n        if (vgetq_lane_u32(zero_check, 0) || \n            vgetq_lane_u32(zero_check, 1) || \n            vgetq_lane_u32(zero_check, 2) || \n            vgetq_lane_u32(zero_check, 3)) {\n            return false;\n        }\n    }\n    \n    // Handle remaining divisors\n    for (int i = sqrt_len + 1; i < len; i++) {\n        if (len % i == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Handle small lengths directly\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n    \n    // Use NEON to parallelize primality check\n    int32x4_t divisors = {5, 7, 11, 13};\n    int32x4_t increments = {6, 6, 6, 6};\n    \n    for (int32_t i = 0; i < sqrtf(len); i += 24) {\n        uint32x4_t div1 = vdupq_n_u32(0);\n        uint32x4_t div2 = vdupq_n_u32(0);\n        uint32x4_t div3 = vdupq_n_u32(0);\n        \n        div1 = vaddq_u32(divisors, vdupq_n_u32(i));\n        div2 = vaddq_u32(div1, increments);\n        div3 = vaddq_u32(div2, increments);\n        \n        uint32x4_t mod1 = vdupq_n_u32(len % vgetq_lane_u32(div1, 0));\n        uint32x4_t mod2 = vdupq_n_u32(len % vgetq_lane_u32(div1, 1));\n        uint32x4_t mod3 = vdupq_n_u32(len % vgetq_lane_u32(div1, 2));\n        uint32x4_t mod4 = vdupq_n_u32(len % vgetq_lane_u32(div1, 3));\n        \n        uint32x4_t mod5 = vdupq_n_u32(len % vgetq_lane_u32(div2, 0));\n        uint32x4_t mod6 = vdupq_n_u32(len % vgetq_lane_u32(div2, 1));\n        uint32x4_t mod7 = vdupq_n_u32(len % vgetq_lane_u32(div2, 2));\n        uint32x4_t mod8 = vdupq_n_u32(len % vgetq_lane_u32(div2, 3));\n        \n        uint32x4_t mod9 = vdupq_n_u32(len % vgetq_lane_u32(div3, 0));\n        uint32x4_t mod10 = vdupq_n_u32(len % vgetq_lane_u32(div3, 1));\n        uint32x4_t mod11 = vdupq_n_u32(len % vgetq_lane_u32(div3, 2));\n        uint32x4_t mod12 = vdupq_n_u32(len % vgetq_lane_u32(div3, 3));\n        \n        if (mod1[0] == 0 || mod2[0] == 0 || mod3[0] == 0 || mod4[0] == 0 ||\n            mod5[0] == 0 || mod6[0] == 0 || mod7[0] == 0 || mod8[0] == 0 ||\n            mod9[0] == 0 || mod10[0] == 0 || mod11[0] == 0 || mod12[0] == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Quick checks for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n    \n    // Use Neon to parallelize primality check\n    int32x4_t divisors = {5, 7, 11, 13};\n    int32x4_t increments = {6, 6, 6, 6};\n    \n    for (int32_t i = 0; i * i <= len; ) {\n        // Parallel divisibility check\n        uint32x4_t remainder_vec = {\n            len % vgetq_lane_s32(divisors, 0),\n            len % vgetq_lane_s32(divisors, 1),\n            len % vgetq_lane_s32(divisors, 2),\n            len % vgetq_lane_s32(divisors, 3)\n        };\n        \n        // Check if any remainder is zero\n        uint32x4_t zero_check = vceqzq_u32(remainder_vec);\n        if (vgetq_lane_u32(zero_check, 0) || \n            vgetq_lane_u32(zero_check, 1) || \n            vgetq_lane_u32(zero_check, 2) || \n            vgetq_lane_u32(zero_check, 3)) {\n            return false;\n        }\n        \n        // Update divisors using Neon\n        divisors = vaddq_s32(divisors, increments);\n        i = vgetq_lane_s32(divisors, 3);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Extract individual digits\n    uint8x8_t digits = {0};\n    int digit_count = 0;\n    \n    while (N > 0) {\n        digits[digit_count++] = N % 10;\n        N /= 10;\n    }\n    \n    // Use Neon to compute digit sum in parallel\n    uint8x8_t sum_vector = {0};\n    for (int i = 0; i < digit_count; i += 8) {\n        uint8x8_t current_digits = vld1_u8(digits + i);\n        sum_vector = vadd_u8(sum_vector, current_digits);\n    }\n    \n    // Horizontal sum of digits\n    uint64_t total_sum = vaddv_u8(sum_vector);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum & 1) + binary;\n        total_sum >>= 1;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Extract digits using SIMD\n    uint8x16_t digits = {0};\n    int digit_count = 0;\n    \n    // Extract digits from N\n    while (N > 0) {\n        digits[digit_count++] = N % 10;\n        N /= 10;\n    }\n    \n    // Use SIMD to sum digits\n    uint32x4_t sum_vec = {0, 0, 0, 0};\n    for (int i = 0; i < digit_count; i += 4) {\n        uint32x4_t current_digits = {\n            digits[i], \n            i+1 < digit_count ? digits[i+1] : 0,\n            i+2 < digit_count ? digits[i+2] : 0,\n            i+3 < digit_count ? digits[i+3] : 0\n        };\n        sum_vec = vaddq_u32(sum_vec, current_digits);\n    }\n    \n    // Horizontal sum of digits\n    uint32_t total_sum = vaddvq_u32(sum_vec);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum & 1) + binary;\n        total_sum >>= 1;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Extract individual digits\n    uint8x8_t digits = {0};\n    int digit_count = 0;\n    \n    while (N > 0) {\n        digits[digit_count++] = N % 10;\n        N /= 10;\n    }\n    \n    // Use Neon to compute digit sum in parallel\n    uint16x8_t sum_vector = {0};\n    for (int i = 0; i < 8; i += 4) {\n        uint16x4_t low_half = vget_low_u16(vmovl_u8(vld1_u8(&digits[i])));\n        uint16x4_t high_half = vget_high_u16(vmovl_u8(vld1_u8(&digits[i+4])));\n        sum_vector = vaddq_u16(sum_vector, vcombine_u16(low_half, high_half));\n    }\n    \n    // Horizontal sum of digits\n    uint16_t total_sum = vaddv_u16(vget_low_u16(sum_vector)) + \n                         vaddv_u16(vget_high_u16(sum_vector));\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum & 1) + binary;\n        total_sum >>= 1;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Extract digits using SIMD division and modulo operations\n    uint8x16_t digits = {0};\n    int digit_count = 0;\n    \n    while (N > 0) {\n        uint8_t current_digit = N % 10;\n        digits[digit_count++] = current_digit;\n        N /= 10;\n    }\n    \n    // Use Neon to compute sum of digits in parallel\n    uint32x4_t sum_vec = {0, 0, 0, 0};\n    for (int i = 0; i < digit_count; i += 4) {\n        uint8x16_t digit_vec = vld1q_u8(&digits[i]);\n        uint16x8_t digit_wide = vmovl_u8(vget_low_u8(digit_vec));\n        uint32x4_t digit_sum = vpaddlq_u16(digit_wide);\n        sum_vec = vaddq_u32(sum_vec, digit_sum);\n    }\n    \n    // Horizontal sum of vector\n    uint32_t total_sum = vgetq_lane_u32(sum_vec, 0) + \n                         vgetq_lane_u32(sum_vec, 1) + \n                         vgetq_lane_u32(sum_vec, 2) + \n                         vgetq_lane_u32(sum_vec, 3);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum & 1) + binary;\n        total_sum >>= 1;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Extract digits using SIMD division and modulo operations\n    uint8x16_t digits;\n    uint8x16_t zero = vdupq_n_u8(0);\n    uint8x16_t ten = vdupq_n_u8(10);\n    \n    int digit_count = 0;\n    uint8_t digit_array[16] = {0};\n    \n    while (N > 0) {\n        uint64_t remainder = N % 10;\n        digit_array[digit_count++] = remainder;\n        N /= 10;\n    }\n    \n    // Load digits into Neon vector\n    digits = vld1q_u8(digit_array);\n    \n    // Compute sum of digits using SIMD addition\n    uint32x4_t sum_vec = {0, 0, 0, 0};\n    for (int i = 0; i < digit_count; i++) {\n        sum_vec = vaddq_u32(sum_vec, vmovl_u16(vget_low_u16(vmovl_u8(vget_low_u8(digits)))));\n    }\n    \n    // Horizontal sum of digits\n    uint32_t total_sum = vaddvq_u32(sum_vec);\n    \n    // Convert sum to binary string\n    std::string binary_result;\n    while (total_sum > 0) {\n        binary_result = std::to_string(total_sum % 2) + binary_result;\n        total_sum /= 2;\n    }\n    \n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {1, 3, 5, 7};\n        uint32x4_t mask = vcgeq_s32(indices, vdupq_n_s32(size));\n        int32x4_t masked_vec = vbslq_s32(mask, vdupq_n_s32(0), vec);\n        \n        int32x4_t even_mask = vbicq_s32(masked_vec, vdupq_n_s32(1));\n        sum_vec = vaddq_s32(sum_vec, even_mask);\n    }\n\n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    result = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {1, 3, 5, 7};\n        uint32x4_t mask = vcgeq_s32(indices, vdupq_n_s32(size));\n        int32x4_t masked_vec = vbslq_s32(mask, vdupq_n_s32(0), vec);\n        \n        int32x4_t even_mask = vbicq_s32(masked_vec, vdupq_n_s32(1));\n        sum_vec = vaddq_s32(sum_vec, even_mask);\n    }\n\n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    result = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Handle remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {1, 3, 5, 7};\n        uint32x4_t mask = vcgeq_s32(indices, vdupq_n_s32(size));\n        int32x4_t masked_vec = vbslq_s32(mask, vdupq_n_s32(0), vec);\n        int32x4_t even_mask = vbicq_s32(masked_vec, vdupq_n_s32(1));\n        sum_vec = vaddq_s32(sum_vec, even_mask);\n    }\n\n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    result = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {1, 3, 5, 7};\n        uint32x4_t mask = vcgeq_s32(indices, vdupq_n_s32(size));\n        int32x4_t masked_vec = vbslq_s32(mask, vdupq_n_s32(0), vec);\n        \n        int32x4_t even_mask = vbicq_s32(masked_vec, vdupq_n_s32(1));\n        sum_vec = vaddq_s32(sum_vec, even_mask);\n    }\n\n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    result = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {1, 3, 5, 7};\n        uint32x4_t mask = vcgeq_s32(indices, vdupq_n_s32(size));\n        int32x4_t even_mask = vandq_s32(vec, vdupq_n_s32(1));\n        int32x4_t masked_vec = vbslq_s32(mask, vdupq_n_s32(0), vec);\n        int32x4_t masked_even_vec = vbslq_s32(vcmpeqq_s32(even_mask, vdupq_n_s32(0)), vdupq_n_s32(0), masked_vec);\n        sum_vec = vaddq_s32(sum_vec, masked_even_vec);\n    }\n\n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    result = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t vectorLen = len - (len % 16);\n    for (size_t i = 0; i < vectorLen; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Separate lowercase and uppercase handling\n        uint8x16_t lowercaseMask = vcltq_u8(input, vdupq_n_u8('z' + 1));\n        uint8x16_t uppercaseMask = vcltq_u8(input, vdupq_n_u8('Z' + 1));\n        \n        // Shift by 4 (2 * 2)\n        uint8x16_t shifted = vaddq_u8(input, vdupq_n_u8(4));\n        \n        // Wrap around for lowercase\n        uint8x16_t lowerWrapMask = vcgtq_u8(shifted, vdupq_n_u8('z'));\n        shifted = vbslq_u8(lowerWrapMask, vsubq_u8(shifted, vdupq_n_u8(26)), shifted);\n        \n        // Wrap around for uppercase\n        uint8x16_t upperWrapMask = vcgtq_u8(shifted, vdupq_n_u8('Z'));\n        shifted = vbslq_u8(upperWrapMask, vsubq_u8(shifted, vdupq_n_u8(26)), shifted);\n        \n        // Preserve non-alphabetic characters\n        shifted = vbslq_u8(vorrq_u8(lowercaseMask, uppercaseMask), shifted, input);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (size_t i = vectorLen; i < len; ++i) {\n        char c = s[i];\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result[i] = (c - 'a' + 4) % 26 + 'a';\n            } else {\n                result[i] = (c - 'A' + 4) % 26 + 'A';\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t vectorLen = len - (len % 16);\n    for (size_t i = 0; i < vectorLen; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Shift lowercase letters by 4 (2 * 2)\n        uint8x16_t shifted = vaddq_u8(input, vmovq_n_u8(4));\n        \n        // Wrap around for letters past 'z'\n        uint8x16_t mask_z = vcgeq_u8(input, vmovq_n_u8('a'));\n        uint8x16_t mask_past_z = vcgtq_u8(shifted, vmovq_n_u8('z'));\n        uint8x16_t correction = vandq_u8(mask_z, vandq_u8(mask_past_z, vmovq_n_u8(26)));\n        \n        shifted = vsubq_u8(shifted, correction);\n        \n        // Store result back\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (size_t i = vectorLen; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            result[i] = ((s[i] - 'a' + 4) % 26) + 'a';\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon SIMD\n    size_t vectorLen = len - (len % 16);\n    for (size_t i = 0; i < vectorLen; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Separate lowercase and uppercase ranges\n        uint8x16_t lowercaseMask = vcgeq_u8(input, vmovq_n_u8('a'));\n        lowercaseMask = vandq_u8(lowercaseMask, vcleq_u8(input, vmovq_n_u8('z')));\n        \n        uint8x16_t uppercaseMask = vcgeq_u8(input, vmovq_n_u8('A'));\n        uppercaseMask = vandq_u8(uppercaseMask, vcleq_u8(input, vmovq_n_u8('Z')));\n        \n        // Rotate lowercase letters\n        uint8x16_t lowercaseRotated = vaddq_u8(input, vmovq_n_u8(4));\n        lowercaseRotated = vbslq_u8(lowercaseMask, lowercaseRotated, input);\n        \n        // Rotate uppercase letters\n        uint8x16_t uppercaseRotated = vaddq_u8(input, vmovq_n_u8(4));\n        uppercaseRotated = vbslq_u8(uppercaseMask, uppercaseRotated, input);\n        \n        // Combine rotated letters\n        uint8x16_t rotated = vorrq_u8(lowercaseRotated, uppercaseRotated);\n        \n        // Wrap around if necessary\n        uint8x16_t lowerWrapMask = vcgtq_u8(rotated, vmovq_n_u8('z'));\n        uint8x16_t upperWrapMask = vcgtq_u8(rotated, vmovq_n_u8('Z'));\n        \n        rotated = vsubq_u8(rotated, vbslq_u8(lowerWrapMask, vmovq_n_u8(26), vmovq_n_u8(0)));\n        rotated = vsubq_u8(rotated, vbslq_u8(upperWrapMask, vmovq_n_u8(26), vmovq_n_u8(0)));\n        \n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), rotated);\n    }\n    \n    // Process remaining characters sequentially\n    for (size_t i = vectorLen; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = (c - 'a' + 4) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = (c - 'A' + 4) % 26 + 'A';\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    size_t vectorLen = len - (len % 16);\n    for (size_t i = 0; i < vectorLen; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Shift lowercase letters by 4 (2 * 2)\n        uint8x16_t shifted = vaddq_u8(input, vmovq_n_u8(4));\n        \n        // Wrap around for letters past 'z'\n        uint8x16_t mask_z = vcgeq_u8(input, vmovq_n_u8('a'));\n        uint8x16_t mask_past_z = vcgtq_u8(shifted, vmovq_n_u8('z'));\n        mask_z = vandq_u8(mask_z, mask_past_z);\n        \n        shifted = vsubq_u8(shifted, vandq_u8(mask_z, vmovq_n_u8(26)));\n        \n        // Store back to result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (size_t i = vectorLen; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            result[i] = ((s[i] - 'a' + 4) % 26) + 'a';\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    size_t vectorLen = len - (len % 16);\n    for (size_t i = 0; i < vectorLen; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Shift lowercase letters by 4 (2 * 2)\n        uint8x16_t shifted = vaddq_u8(input, vmovq_n_u8(4));\n        \n        // Wrap around for letters past 'z'\n        uint8x16_t mask_z = vcgeq_u8(input, vmovq_n_u8('z'));\n        uint8x16_t wrap_correction = vandq_u8(mask_z, vmovq_n_u8(26));\n        shifted = vsubq_u8(shifted, wrap_correction);\n        \n        // Only modify lowercase letters\n        uint8x16_t mask_a = vcgeq_u8(input, vmovq_n_u8('a'));\n        uint8x16_t mask_z_check = vcleq_u8(input, vmovq_n_u8('z'));\n        uint8x16_t letter_mask = vandq_u8(mask_a, mask_z_check);\n        \n        shifted = vbslq_u8(letter_mask, shifted, input);\n        \n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (size_t i = vectorLen; i < len; ++i) {\n        if (s[i] >= 'a' && s[i] <= 'z') {\n            result[i] = ((s[i] - 'a' + 4) % 26) + 'a';\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n\n    // Process 16 bytes at a time using Neon SIMD\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        uint8x16_t lower_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcltq_u8(chars, vdupq_n_u8('Z'+1)));\n        lower_mask = vandq_u8(lower_mask, vcgeq_u8(chars, vdupq_n_u8('a')));\n        \n        uint8x16_t swapped_case = veorq_u8(chars, vdupq_n_u8(32));\n        swapped_case = vbslq_u8(lower_mask, swapped_case, chars);\n        swapped_case = vbslq_u8(upper_mask, swapped_case, chars);\n\n        // Replace vowels\n        uint8x16_t vowels = vceqq_u8(swapped_case, vdupq_n_u8('a'));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('e')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('i')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('o')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('u')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('A')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('E')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('I')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('O')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('U')));\n\n        uint8x16_t vowel_replacements = vaddq_u8(swapped_case, vdupq_n_u8(2));\n        swapped_case = vbslq_u8(vowels, vowel_replacements, swapped_case);\n\n        // Store results\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), swapped_case);\n    }\n\n    // Handle remaining characters\n    for (size_t i = len - (len % 16); i < len; ++i) {\n        char c = result[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = toupper(c);\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = tolower(c);\n        }\n\n        if (strchr(\"aeiouAEIOU\", c)) {\n            result[i] += 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process 16 bytes at a time using Neon\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        uint8x16_t lower_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcltq_u8(chars, vdupq_n_u8('Z'+1)));\n        lower_mask = vandq_u8(lower_mask, vcgeq_u8(chars, vdupq_n_u8('a')));\n        \n        uint8x16_t swapped_case = veorq_u8(chars, vdupq_n_u8(32));\n        swapped_case = vbslq_u8(lower_mask, swapped_case, chars);\n        swapped_case = vbslq_u8(upper_mask, swapped_case, chars);\n        \n        // Replace vowels\n        uint8x16_t vowels = vceqq_u8(swapped_case, vdupq_n_u8('a'));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('e')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('i')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('o')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('u')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('A')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('E')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('I')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('O')));\n        vowels = vorrq_u8(vowels, vceqq_u8(swapped_case, vdupq_n_u8('U')));\n        \n        uint8x16_t vowel_replacements = vaddq_u8(swapped_case, vdupq_n_u8(2));\n        swapped_case = vbslq_u8(vowels, vowel_replacements, swapped_case);\n        \n        // Store back to result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), swapped_case);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = len - (len % 16); i < len; ++i) {\n        char c = result[i];\n        \n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 32;\n        }\n        \n        // Replace vowels\n        if (strchr(\"aeiouAEIOU\", c)) {\n            result[i] += 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process 16 bytes at a time using Neon\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        uint8x16_t lower_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcltq_u8(chars, vdupq_n_u8('Z'+1)));\n        \n        uint8x16_t lower_case = vaddq_u8(chars, vdupq_n_u8(32));\n        uint8x16_t upper_case = vsubq_u8(chars, vdupq_n_u8(32));\n        \n        chars = vbslq_u8(lower_mask, lower_case, chars);\n        chars = vbslq_u8(upper_mask, upper_case, chars);\n        \n        // Replace vowels\n        uint8x16_t vowels = vceqq_u8(chars, vdupq_n_u8('a'));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('e')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('i')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('o')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('u')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('A')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('E')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('I')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('O')));\n        vowels = vorrq_u8(vowels, vceqq_u8(chars, vdupq_n_u8('U')));\n        \n        uint8x16_t vowel_replace = vaddq_u8(chars, vdupq_n_u8(2));\n        chars = vbslq_u8(vowels, vowel_replace, chars);\n        \n        // Store back\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), chars);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = len - (len % 16); i < len; ++i) {\n        char c = result[i];\n        \n        // Swap case\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 32;\n        }\n        \n        // Replace vowels\n        if (strchr(\"aeiouAEIOU\", c)) {\n            result[i] += 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process 16 bytes at a time using Neon\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n        \n        // Swap case\n        uint8x16_t lower_mask = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcltq_u8(chars, vdupq_n_u8('Z'+1)));\n        lower_mask = vandq_u8(lower_mask, vcgeq_u8(chars, vdupq_n_u8('a')));\n        \n        uint8x16_t case_swap = veorq_u8(chars, vdupq_n_u8(32));\n        chars = vbslq_u8(vorrq_u8(lower_mask, upper_mask), case_swap, chars);\n        \n        // Replace vowels\n        uint8x16_t vowel_mask = vceqq_u8(chars, vdupq_n_u8('a'));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('e')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('i')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('o')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('u')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('A')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('E')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('I')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('O')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(chars, vdupq_n_u8('U')));\n        \n        uint8x16_t vowel_replace = vaddq_u8(chars, vdupq_n_u8(2));\n        chars = vbslq_u8(vowel_mask, vowel_replace, chars);\n        \n        // Store results\n        size_t remaining = std::min(len - i, static_cast<size_t>(16));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process 16 bytes at a time using Neon SIMD\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(message.data() + i));\n        uint8x16_t output = input;\n        \n        // Swap case\n        uint8x16_t lower_mask = vcltq_u8(input, vdupq_n_u8('a'));\n        uint8x16_t upper_mask = vcgeq_u8(input, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcltq_u8(input, vdupq_n_u8('Z'+1)));\n        \n        output = vorrq_u8(\n            vandq_u8(input, vorrq_u8(lower_mask, upper_mask)),\n            veorq_u8(input, vdupq_n_u8(32))\n        );\n        \n        // Replace vowels\n        uint8x16_t vowel_mask = vceqq_u8(output, vdupq_n_u8('a'));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('e')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('i')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('o')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('u')));\n        \n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('A')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('E')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('I')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('O')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(output, vdupq_n_u8('U')));\n        \n        output = vbslq_u8(vowel_mask, vaddq_u8(output, vdupq_n_u8(2)), output);\n        \n        // Store back to result\n        size_t remaining = std::min(len - i, size_t(16));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    // Process 16 characters at a time using Neon SIMD\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 bytes at a time\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            \n            // Check if all characters are lowercase\n            uint8x16_t lower_mask = vcltq_u8(chars, vmovq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(chars, vmovq_n_u8('z'));\n            uint8x16_t non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_lower = false;\n            }\n            \n            // Check if all characters are uppercase\n            lower_mask = vcltq_u8(chars, vmovq_n_u8('A'));\n            upper_mask = vcgtq_u8(chars, vmovq_n_u8('Z'));\n            non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_upper = false;\n            }\n            \n            if (!all_lower && !all_upper) return false;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!std::islower(c)) all_lower = false;\n            if (!std::isupper(c)) all_upper = false;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Process keys in parallel using Neon SIMD\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 characters at a time using Neon\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            \n            // Check if all characters are lowercase\n            uint8x16_t lower_mask = vcltq_u8(chars, vmovq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(chars, vmovq_n_u8('z'));\n            uint8x16_t non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_lower = false;\n            }\n            \n            // Check if all characters are uppercase\n            lower_mask = vcltq_u8(chars, vmovq_n_u8('A'));\n            upper_mask = vcgtq_u8(chars, vmovq_n_u8('Z'));\n            non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_upper = false;\n            }\n        }\n        \n        // Process remaining characters sequentially\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!(c >= 'a' && c <= 'z')) {\n                all_lower = false;\n            }\n            if (!(c >= 'A' && c <= 'Z')) {\n                all_upper = false;\n            }\n        }\n        \n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Process keys in parallel using Neon SIMD\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 characters at a time using Neon\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            \n            // Check if all characters are lowercase\n            uint8x16_t lower_mask = vcltq_u8(chars, vmovq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(chars, vmovq_n_u8('z'));\n            uint8x16_t non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_lower = false;\n            }\n            \n            // Check if all characters are uppercase\n            lower_mask = vcltq_u8(chars, vmovq_n_u8('A'));\n            upper_mask = vcgtq_u8(chars, vmovq_n_u8('Z'));\n            non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_upper = false;\n            }\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!(c >= 'a' && c <= 'z')) {\n                all_lower = false;\n            }\n            if (!(c >= 'A' && c <= 'Z')) {\n                all_upper = false;\n            }\n        }\n        \n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    // Process 16 characters at a time using Neon SIMD\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 bytes at a time\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            \n            // Check if all characters are lowercase\n            uint8x16_t lower_mask = vcltq_u8(chars, vmovq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(chars, vmovq_n_u8('z'));\n            uint8x16_t non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_lower = false;\n            }\n            \n            // Check if all characters are uppercase\n            lower_mask = vcltq_u8(chars, vmovq_n_u8('A'));\n            upper_mask = vcgtq_u8(chars, vmovq_n_u8('Z'));\n            non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_upper = false;\n            }\n            \n            if (!all_lower && !all_upper) return false;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!std::islower(c)) all_lower = false;\n            if (!std::isupper(c)) all_upper = false;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Process keys in parallel using Neon SIMD\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 characters at a time using Neon\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            \n            // Check lowercase\n            uint8x16_t lower_mask = vcltq_u8(chars, vmovq_n_u8('a'));\n            uint8x16_t upper_mask = vcgtq_u8(chars, vmovq_n_u8('z'));\n            uint8x16_t non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_lower = false;\n            }\n            \n            // Check uppercase\n            lower_mask = vcltq_u8(chars, vmovq_n_u8('A'));\n            upper_mask = vcgtq_u8(chars, vmovq_n_u8('Z'));\n            non_alpha_mask = vorrq_u8(lower_mask, upper_mask);\n            \n            if (vaddvq_u8(non_alpha_mask) > 0) {\n                all_upper = false;\n            }\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!(c >= 'a' && c <= 'z')) all_lower = false;\n            if (!(c >= 'A' && c <= 'Z')) all_upper = false;\n        }\n        \n        if (!all_lower && !all_upper) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use Neon SIMD for parallel sieve of Eratosthenes\n    for (int i = 2; i * i < n; i += 4) {\n        // Process 4 numbers at a time using Neon\n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t squares = vmulq_u32(indices, indices);\n        \n        for (int j = 0; j < 4; j++) {\n            int current = vgetq_lane_u32(indices, j);\n            int square = vgetq_lane_u32(squares, j);\n            \n            if (is_prime[current]) {\n                for (int k = square; k < n; k += current) {\n                    is_prime[k] = false;\n                }\n            }\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use Neon SIMD for parallel sieve of Eratosthenes\n    for (int i = 2; i * i < n; i += 4) {\n        // Process 4 numbers at a time using Neon\n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t squares = vmulq_u32(indices, indices);\n        \n        for (int j = 0; j < 4; j++) {\n            int current = vgetq_lane_u32(indices, j);\n            int square = vgetq_lane_u32(squares, j);\n            \n            if (is_prime[current]) {\n                for (int k = square; k < n; k += current) {\n                    is_prime[k] = false;\n                }\n            }\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use NEON SIMD for parallel sieve of Eratosthenes\n    for (int i = 2; i * i < n; i += 4) {\n        // Process 4 potential primes simultaneously\n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t squares = vmulq_u32(indices, indices);\n        uint32x4_t limits = vdupq_n_u32(n);\n\n        // Check if indices are within range\n        uint32x4_t mask = vcltq_u32(indices, limits);\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(mask, j) && is_prime[i+j]) {\n                int prime = i + j;\n                for (int k = prime * prime; k < n; k += prime) {\n                    is_prime[k] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use NEON SIMD for faster sieve of Eratosthenes\n    for (int i = 2; i * i < n; i += 4) {\n        uint32x4_t vec_i = {i, i+1, i+2, i+3};\n        \n        for (int j = 0; j < 4; j++) {\n            int current = vec_i[j];\n            if (is_prime[current]) {\n                for (int k = current * current; k < n; k += current) {\n                    is_prime[k] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use Neon SIMD for parallel sieve of Eratosthenes\n    for (int i = 2; i * i < n; i += 4) {\n        // Use 128-bit Neon vector to process 4 integers simultaneously\n        uint32x4_t vec_i = {i, i+1, i+2, i+3};\n        uint32x4_t vec_squared = vmulq_u32(vec_i, vec_i);\n        \n        for (int j = 0; j < 4; j++) {\n            int current_i = i + j;\n            if (is_prime[current_i]) {\n                for (int k = current_i * current_i; k < n; k += current_i) {\n                    is_prime[k] = false;\n                }\n            }\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    int vector_len = len - (len % 16);\n    \n    // Vectors for uppercase vowels\n    uint8x16_t upper_vowels = vcombine_u8(\n        vcreate_u8(0x41 | (0x45 << 8) | (0x49 << 16) | (0x4F << 24) | (0x55 << 32)),\n        vcreate_u8(0x00)\n    );\n    \n    for (int i = 0; i < vector_len; i += 16) {\n        // Load 16 characters\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check even indices\n        uint8x16_t even_mask = vcombine_u8(\n            vcreate_u8(0x00FF00FF00FF00FFULL),\n            vcreate_u8(0x00FF00FF00FF00FFULL)\n        );\n        uint8x16_t even_chars = vandq_u8(chars, even_mask);\n        \n        // Compare with uppercase vowels\n        uint8x16_t match = vceqq_u8(even_chars, upper_vowels);\n        \n        // Count matches\n        uint8x16_t count_vec = vcntq_u8(match);\n        uint64_t count_result = vaddlv_u32(vpaddl_u16(vpaddl_u8(count_vec)));\n        \n        result += count_result;\n    }\n    \n    // Handle remaining characters\n    for (int i = vector_len; i < len; i += 2) {\n        if (i < len && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t even_indices = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30};\n        uint8x16_t selected_chars = vqtbl1q_u8(chars, even_indices);\n        \n        // Check for uppercase vowels\n        uint8x16_t is_upper = vcgeq_u8(selected_chars, 'A');\n        uint8x16_t is_lower = vcleq_u8(selected_chars, 'Z');\n        uint8x16_t is_uppercase = vandq_u8(is_upper, is_lower);\n        \n        uint8x16_t is_vowel = vceqq_u8(selected_chars, 'A') | \n                               vceqq_u8(selected_chars, 'E') | \n                               vceqq_u8(selected_chars, 'I') | \n                               vceqq_u8(selected_chars, 'O') | \n                               vceqq_u8(selected_chars, 'U');\n        \n        uint8x16_t result = vandq_u8(is_uppercase, is_vowel);\n        \n        // Count the number of set bits\n        uint64x2_t count_vec = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(vcntq_u8(result))));\n        count += vgetq_lane_u64(count_vec, 0) + vgetq_lane_u64(count_vec, 1);\n    }\n    \n    // Process remaining characters\n    for (; i < len; i += 2) {\n        if (i < len && s[i] >= 'A' && s[i] <= 'Z') {\n            if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t even_indices = vcombine_u8(\n            vtbl1_u8(chars, vcreate_u8(0x00020406080A0C0EULL)),\n            vtbl1_u8(chars, vcreate_u8(0x00020406080A0C0EULL))\n        );\n        \n        // Check for uppercase vowels (A, E, I, O, U)\n        uint8x16_t is_upper = vcgeq_u8(even_indices, vdupq_n_u8('A'));\n        uint8x16_t is_vowel = vorrq_u8(\n            vorrq_u8(\n                vceqq_u8(even_indices, vdupq_n_u8('A')),\n                vceqq_u8(even_indices, vdupq_n_u8('E'))\n            ),\n            vorrq_u8(\n                vceqq_u8(even_indices, vdupq_n_u8('I')),\n                vorrq_u8(\n                    vceqq_u8(even_indices, vdupq_n_u8('O')),\n                    vceqq_u8(even_indices, vdupq_n_u8('U'))\n                )\n            )\n        );\n        \n        uint8x16_t result = vandq_u8(is_upper, is_vowel);\n        uint64_t mask = vaddvq_u8(result);\n        count += __builtin_popcount(mask);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i += 2) {\n        if (i < len && s[i] >= 'A' && s[i] <= 'Z' && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t even_indices = vcombine_u8(\n            vtbl1_u8(chars, vcreate_u8(0x00020406080A0C0E)),\n            vtbl1_u8(chars, vcreate_u8(0x00020406080A0C0E))\n        );\n        \n        // Check for uppercase vowels (A, E, I, O, U)\n        uint8x16_t is_upper = vandq_u8(\n            vcgeq_u8(even_indices, vmovq_n_u8('A')),\n            vcleq_u8(even_indices, vmovq_n_u8('Z'))\n        );\n        \n        uint8x16_t is_vowel = vandq_u8(\n            vceqq_u8(even_indices, vmovq_n_u8('A')) |\n            vceqq_u8(even_indices, vmovq_n_u8('E')) |\n            vceqq_u8(even_indices, vmovq_n_u8('I')) |\n            vceqq_u8(even_indices, vmovq_n_u8('O')) |\n            vceqq_u8(even_indices, vmovq_n_u8('U')),\n            is_upper\n        );\n        \n        uint64_t mask = vaddvq_u8(is_vowel);\n        result += __builtin_popcount(mask);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i += 2) {\n        if (i < len && isupper(s[i]) && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using Neon\n    int i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t even_indices = {0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30};\n        uint8x16_t selected_chars = vqtbl1q_u8(chars, even_indices);\n        \n        // Check for uppercase vowels\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(selected_chars, vmov_n_u8('A')), \n                                       vcleq_u8(selected_chars, vmov_n_u8('Z')));\n        \n        uint8x16_t is_vowel = vorrq_u8(\n            vorrq_u8(\n                vceqq_u8(selected_chars, vmov_n_u8('A')),\n                vceqq_u8(selected_chars, vmov_n_u8('E'))\n            ),\n            vorrq_u8(\n                vceqq_u8(selected_chars, vmov_n_u8('I')),\n                vorrq_u8(\n                    vceqq_u8(selected_chars, vmov_n_u8('O')),\n                    vceqq_u8(selected_chars, vmov_n_u8('U'))\n                )\n            )\n        );\n        \n        uint8x16_t is_upper_vowel = vandq_u8(is_upper, is_vowel);\n        uint64x2_t counts = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(is_upper_vowel)));\n        result += vgetq_lane_u64(counts, 0) + vgetq_lane_u64(counts, 1);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i += 2) {\n        if (i < len && \n            s[i] >= 'A' && s[i] <= 'Z' && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first level with n stones\n    int32x4_t initial_level = vdupq_n_s32(n);\n    vst1q_s32(result.data(), initial_level);\n    \n    // Process remaining levels using NEON intrinsics\n    for (int i = 1; i < n; i++) {\n        // Determine next level stones based on previous level's stones\n        int prev_level = result[i-1];\n        int32x4_t next_level;\n        \n        if (prev_level % 2 == 0) {\n            // If previous level is even, next level is next even number\n            next_level = vdupq_n_s32(prev_level + 2);\n        } else {\n            // If previous level is odd, next level is next odd number\n            next_level = vdupq_n_s32(prev_level + 2);\n        }\n        \n        vst1q_s32(&result[i], next_level);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use Neon intrinsics to parallelize the computation\n    int32x4_t initial_vec = vdupq_n_s32(n);\n    int32x4_t increment_vec = vdupq_n_s32(1);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current_vec = initial_vec;\n        \n        // Compute stones for each level\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            result[i + j] = vgetq_lane_s32(current_vec, j);\n            \n            // Increment based on odd/even rule\n            current_vec = vaddq_s32(current_vec, \n                vbslq_s32(vceqq_s32(vmodq_s32(current_vec, vdupq_n_s32(2)), vdupq_n_s32(0)), \n                          vdupq_n_s32(2), \n                          vdupq_n_s32(1)));\n        }\n        \n        initial_vec = current_vec;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initial level with n stones\n    int32x4_t initial_level = vdupq_n_s32(n);\n    vst1q_s32(result.data(), initial_level);\n    \n    // Process subsequent levels\n    for (int i = 1; i < n; i++) {\n        // Check if previous level was odd or even\n        int prev_level = result[i-1];\n        int next_level = (prev_level % 2 == 0) ? prev_level + 2 : prev_level + 2;\n        result[i] = next_level;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first level with n stones\n    int32x4_t initial_level = vdupq_n_s32(n);\n    vst1q_s32(result.data(), initial_level);\n    \n    // Process subsequent levels in parallel\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t levels = vld1q_s32(result.data() + i - 1);\n        \n        // Increment levels based on odd/even condition\n        int32x4_t increments = vdupq_n_s32(2);\n        int32x4_t next_levels = vaddq_s32(levels, increments);\n        \n        // Store results, handling boundary conditions\n        int remaining = n - i;\n        if (remaining >= 4) {\n            vst1q_s32(result.data() + i, next_levels);\n        } else {\n            for (int j = 0; j < remaining; ++j) {\n                result[i + j] = result[i + j - 1] + 2;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use Neon intrinsics to parallelize the computation\n    int32x4_t initial_vec = vdupq_n_s32(n);\n    int32x4_t increment_vec = vdupq_n_s32(1);\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current_vec = vaddq_s32(initial_vec, vmulq_n_s32(increment_vec, i));\n        \n        // Compute next level stones based on odd/even condition\n        int32x4_t odd_mask = vandq_s32(current_vec, vdupq_n_s32(1));\n        int32x4_t next_level_vec = vbslq_s32(\n            vcgtq_s32(odd_mask, vdupq_n_s32(0)),\n            vaddq_s32(current_vec, vdupq_n_s32(2)),\n            vaddq_s32(current_vec, vdupq_n_s32(1))\n        );\n        \n        // Store results\n        vst1q_s32(&result[i], next_level_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using Neon SIMD\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    \n    // Process 4 integers at a time using Neon\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int i;\n    for (i = 0; i + 1 < count; i += 2) {\n        int64x2_t current_vec = {n + i, n + i + 1};\n        sum_vec = vaddq_s64(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum of vector\n    sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    // Add remaining elements\n    for (; i < count; i++) {\n        sum += n + i;\n    }\n    \n    // Compute rounded average\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    \n    // Use Neon SIMD for summing if count is large enough\n    if (count >= 4) {\n        int64x2_t sum_vec = vdupq_n_s64(0);\n        \n        // Process 4 elements at a time\n        for (int64_t i = n; i + 3 < m + 1; i += 4) {\n            int64x2_t vec1 = {i, i+1};\n            int64x2_t vec2 = {i+2, i+3};\n            sum_vec = vaddq_s64(sum_vec, vec1);\n            sum_vec = vaddq_s64(sum_vec, vec2);\n        }\n        \n        // Horizontal sum\n        sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n    \n    // Handle remaining elements\n    for (int64_t i = n + ((count / 4) * 4); i <= m; ++i) {\n        sum += i;\n    }\n    \n    // Compute rounded average\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using Neon SIMD\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    \n    // Process 4 elements at a time using Neon 64-bit vectors\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int i;\n    for (i = 0; i + 1 < count; i += 2) {\n        int64x2_t current_vec = {n + i, n + i + 1};\n        sum_vec = vaddq_s64(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum of vector\n    sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    // Add remaining elements\n    for (; i < count; i++) {\n        sum += n + i;\n    }\n    \n    // Compute rounded average\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using Neon SIMD\n    int64_t total = 0;\n    int64_t count = m - n + 1;\n    \n    // Process in chunks of 2 64-bit integers\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int i;\n    for (i = 0; i + 1 < count; i += 2) {\n        int64x2_t current_vec = {n + i, n + i + 1};\n        sum_vec = vaddq_s64(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum of vector\n    total = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    // Process remaining elements\n    for (; i < count; i++) {\n        total += n + i;\n    }\n    \n    // Compute rounded average\n    int64_t avg = total / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate sum using Neon SIMD\n    int64_t total = 0;\n    int64_t count = m - n + 1;\n    \n    // Process 4 integers at a time using Neon\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int i;\n    for (i = 0; i + 1 < count; i += 2) {\n        int64x2_t current_vec = {n + i, n + i + 1};\n        sum_vec = vaddq_s64(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum of vector\n    total = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    \n    // Add remaining elements\n    for (; i < count; i++) {\n        total += n + i;\n    }\n    \n    // Calculate rounded average\n    int64_t avg = total / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_size = 4;\n    int i = 0;\n    \n    // Process 4 elements in parallel\n    for (; i + simd_size <= n; i += simd_size) {\n        int32x4_t indices = {i+1, i+2, i+3, i+4};\n        int32x4_t results_vec;\n        \n        // Compute results for 4 elements simultaneously\n        for (int j = 0; j < 4; j++) {\n            int idx = vgetq_lane_s32(indices, j);\n            \n            if (idx % 2 == 0) {\n                // Factorial modulo 10000 for even indices\n                int factorial = 1;\n                for (int k = 1; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                vsetq_lane_s32(factorial, results_vec, j);\n            } else {\n                // Sum of numbers from 1 to index for odd indices\n                int sum = (idx * (idx + 1)) / 2;\n                vsetq_lane_s32(sum, results_vec, j);\n            }\n        }\n        \n        // Store results back to vector\n        vst1q_s32(&result[i], results_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if ((i+1) % 2 == 0) {\n            // Factorial modulo 10000 for even indices\n            int factorial = 1;\n            for (int k = 1; k <= i+1; k++) {\n                factorial = (factorial * k) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            // Sum of numbers from 1 to index for odd indices\n            result[i] = ((i+1) * (i+2)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_width = 4;\n    int i = 0;\n    \n    // Process 4 elements in parallel\n    for (; i + simd_width <= n; i += simd_width) {\n        int32x4_t indices = {i+1, i+2, i+3, i+4};\n        int32x4_t results_vec = vdupq_n_s32(0);\n        \n        // Compute results for each index\n        for (int j = 0; j < 4; j++) {\n            int idx = vgetq_lane_s32(indices, j);\n            int val;\n            \n            if (idx % 2 == 0) {\n                // Factorial for even indices\n                val = 1;\n                for (int k = 1; k <= idx; k++) {\n                    val = (val * k) % 10000;\n                }\n            } else {\n                // Sum for odd indices\n                val = (idx * (idx + 1)) / 2;\n            }\n            \n            results_vec = vsetq_lane_s32(val, results_vec, j);\n        }\n        \n        // Store results back to vector\n        vst1q_s32(&result[i], results_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if ((i+1) % 2 == 0) {\n            // Factorial for even indices\n            int val = 1;\n            for (int k = 1; k <= i+1; k++) {\n                val = (val * k) % 10000;\n            }\n            result[i] = val;\n        } else {\n            // Sum for odd indices\n            result[i] = ((i+1) * (i+2)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_width = 4;\n    int i = 0;\n    \n    // Process 4 elements in parallel\n    for (; i + simd_width <= n; i += simd_width) {\n        int32x4_t indices = {i+1, i+2, i+3, i+4};\n        int32x4_t results_vec = vdupq_n_s32(0);\n        \n        // Compute results for each index\n        for (int j = 0; j < simd_width; j++) {\n            int idx = i + j + 1;\n            if (idx % 2 == 0) {\n                // Factorial modulo 10000\n                int factorial = 1;\n                for (int k = 1; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                result[i + j] = factorial;\n            } else {\n                // Sum of numbers from 1 to idx\n                int sum = (idx * (idx + 1)) / 2;\n                result[i + j] = sum;\n            }\n        }\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        int idx = i + 1;\n        if (idx % 2 == 0) {\n            int factorial = 1;\n            for (int k = 1; k <= idx; k++) {\n                factorial = (factorial * k) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            int sum = (idx * (idx + 1)) / 2;\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_width = 4;\n    int i;\n    \n    for (i = 0; i + simd_width <= n; i += simd_width) {\n        // Create Neon vectors for indices\n        int32x4_t indices = {i+1, i+2, i+3, i+4};\n        \n        // Compute even/odd mask\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(indices, vdupq_n_u32(1)));\n        \n        // Factorial computation for even indices\n        int32x4_t factorial_vec = vdupq_n_s32(1);\n        int32x4_t factorial_result = vdupq_n_s32(1);\n        for (int j = 1; j <= 4; j++) {\n            factorial_vec = vmulq_s32(factorial_vec, vaddq_s32(indices, vdupq_n_s32(j-1)));\n            factorial_result = vbslq_s32(even_mask, vmodq_s32(factorial_vec, vdupq_n_s32(10000)), vdupq_n_s32(0));\n        }\n        \n        // Sum computation for odd indices\n        int32x4_t sum_result = vdupq_n_s32(0);\n        for (int j = 1; j <= 4; j++) {\n            sum_result = vbslq_s32(vmvnq_u32(even_mask), \n                                   vaddq_s32(sum_result, vaddq_s32(indices, vdupq_n_s32(-j+1))), \n                                   vdupq_n_s32(0));\n        }\n        \n        // Combine results\n        int32x4_t final_result = vbslq_s32(even_mask, factorial_result, sum_result);\n        \n        // Store results\n        vst1q_s32(&result[i], final_result);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if ((i+1) % 2 == 0) {\n            // Factorial computation\n            int factorial = 1;\n            for (int j = 1; j <= i+1; j++) {\n                factorial *= j;\n            }\n            result[i] = factorial % 10000;\n        } else {\n            // Sum computation\n            int sum = 0;\n            for (int j = 1; j <= i+1; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_width = 4;\n    int i;\n    \n    for (i = 0; i + simd_width <= n; i += simd_width) {\n        // Create Neon vectors for indices\n        int32x4_t indices = {i+1, i+2, i+3, i+4};\n        \n        // Compute even/odd mask\n        uint32x4_t even_mask = vceqzq_u32(vandq_u32(indices, vdupq_n_u32(1)));\n        \n        // Factorial computation for even indices\n        int32x4_t factorial_vec = vdupq_n_s32(1);\n        int32x4_t factorial_mask = vdupq_n_s32(1);\n        for (int j = 1; j <= 12; j++) {\n            factorial_mask = vmulq_s32(factorial_mask, vdupq_n_s32(j));\n            factorial_vec = vmulq_s32(factorial_vec, vbslq_s32(vceqzq_s32(vmodq_s32(indices, vdupq_n_s32(j))), factorial_mask, vdupq_n_s32(1)));\n        }\n        factorial_vec = vmodq_s32(factorial_vec, vdupq_n_s32(10000));\n        \n        // Sum computation for odd indices\n        int32x4_t sum_vec = vdivq_s32(vmulq_s32(indices, vaddq_s32(indices, vdupq_n_s32(1))), vdupq_n_s32(2));\n        \n        // Blend results based on even/odd mask\n        int32x4_t result_vec = vbslq_s32(even_mask, factorial_vec, sum_vec);\n        \n        // Store results\n        vst1q_s32(&result[i], result_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if ((i + 1) % 2 == 0) {\n            // Factorial computation\n            int factorial = 1;\n            for (int j = 1; j <= i + 1; j++) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            // Sum computation\n            result[i] = ((i + 1) * (i + 2)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int32x4_t even_count_vec = vdupq_n_s32(0);\n    int32x4_t odd_count_vec = vdupq_n_s32(0);\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t current_nums = {i, i+1, i+2, i+3};\n        \n        // Check palindrome for each number\n        int32x4_t is_palindrome_mask = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = current_nums[j];\n            if (num > n) break;\n            \n            // Palindrome check\n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed) {\n                is_palindrome_mask = vsetq_lane_s32(1, is_palindrome_mask, j);\n            }\n        }\n        \n        // Count even and odd palindromes\n        int32x4_t even_mask = vandq_s32(is_palindrome_mask, vdupq_n_s32(1));\n        int32x4_t odd_mask = vandq_s32(is_palindrome_mask, vdupq_n_s32(1));\n        \n        even_count_vec = vaddq_s32(even_count_vec, \n            vandq_s32(even_mask, vcltq_s32(current_nums, vdupq_n_s32(n+1))));\n        \n        odd_count_vec = vaddq_s32(odd_count_vec, \n            vandq_s32(odd_mask, vcltq_s32(current_nums, vdupq_n_s32(n+1))));\n    }\n    \n    // Horizontal sum\n    int even_total = vgetq_lane_s32(even_count_vec, 0) + \n                     vgetq_lane_s32(even_count_vec, 1) + \n                     vgetq_lane_s32(even_count_vec, 2) + \n                     vgetq_lane_s32(even_count_vec, 3);\n    \n    int odd_total = vgetq_lane_s32(odd_count_vec, 0) + \n                    vgetq_lane_s32(odd_count_vec, 1) + \n                    vgetq_lane_s32(odd_count_vec, 2) + \n                    vgetq_lane_s32(odd_count_vec, 3);\n    \n    return {even_total, odd_total};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Use Neon SIMD to process multiple numbers in parallel\n    int32x4_t even_vec = vdupq_n_s32(0);\n    int32x4_t odd_vec = vdupq_n_s32(0);\n    \n    // Process numbers in groups of 4\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t nums = {i, i+1, i+2, i+3};\n        \n        // Check palindrome for each number\n        int32x4_t is_palindrome_mask = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = nums[j];\n            if (num > n) break;\n            \n            // Palindrome check\n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed) {\n                is_palindrome_mask = vsetq_lane_s32(0xFFFFFFFF, is_palindrome_mask, j);\n                \n                // Even or odd check\n                if (original % 2 == 0) {\n                    even_vec = vaddq_s32(even_vec, vbslq_s32(vsetq_lane_s32(0xFFFFFFFF, vdupq_n_s32(0), j), vdupq_n_s32(1), vdupq_n_s32(0)));\n                } else {\n                    odd_vec = vaddq_s32(odd_vec, vbslq_s32(vsetq_lane_s32(0xFFFFFFFF, vdupq_n_s32(0), j), vdupq_n_s32(1), vdupq_n_s32(0)));\n                }\n            }\n        }\n    }\n    \n    // Reduce SIMD vectors to scalar values\n    int32x2_t even_sum_low = vget_low_s32(even_vec);\n    int32x2_t even_sum_high = vget_high_s32(even_vec);\n    int32x2_t odd_sum_low = vget_low_s32(odd_vec);\n    int32x2_t odd_sum_high = vget_high_s32(odd_vec);\n    \n    even_sum_low = vadd_s32(even_sum_low, even_sum_high);\n    odd_sum_low = vadd_s32(odd_sum_low, odd_sum_high);\n    \n    even_count = vget_lane_s32(even_sum_low, 0) + vget_lane_s32(even_sum_low, 1);\n    odd_count = vget_lane_s32(odd_sum_low, 0) + vget_lane_s32(odd_sum_low, 1);\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int32x4_t even_count_vec = vdupq_n_s32(0);\n    int32x4_t odd_count_vec = vdupq_n_s32(0);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t current_nums = {i, i+1, i+2, i+3};\n        \n        // Palindrome check\n        int32x4_t palindrome_mask = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = current_nums[j];\n            if (num > n) break;\n            \n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed) {\n                palindrome_mask = vsetq_lane_s32(0xFFFFFFFF, palindrome_mask, j);\n            }\n        }\n\n        // Even/Odd count\n        int32x4_t even_mask = vandq_s32(palindrome_mask, vdupq_n_s32(1));\n        int32x4_t odd_mask = vandq_s32(palindrome_mask, vdupq_n_s32(1));\n        vrshrq_n_s32(odd_mask, 1);\n\n        even_count_vec = vaddq_s32(even_count_vec, vpaddlq_s32(even_mask));\n        odd_count_vec = vaddq_s32(odd_count_vec, vpaddlq_s32(odd_mask));\n    }\n\n    int even_total = vgetq_lane_s32(even_count_vec, 0) + \n                     vgetq_lane_s32(even_count_vec, 1) + \n                     vgetq_lane_s32(even_count_vec, 2) + \n                     vgetq_lane_s32(even_count_vec, 3);\n\n    int odd_total = vgetq_lane_s32(odd_count_vec, 0) + \n                    vgetq_lane_s32(odd_count_vec, 1) + \n                    vgetq_lane_s32(odd_count_vec, 2) + \n                    vgetq_lane_s32(odd_count_vec, 3);\n\n    return {even_total, odd_total};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Use Neon SIMD to process multiple palindromes in parallel\n    int32x4_t even_vec = vdupq_n_s32(0);\n    int32x4_t odd_vec = vdupq_n_s32(0);\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t nums = {i, i+1, i+2, i+3};\n        \n        // Check palindrome for each number\n        int32x4_t is_palindrome_mask = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = nums[j];\n            if (num > n) break;\n            \n            // Palindrome check\n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed) {\n                is_palindrome_mask = vsetq_lane_s32(0xFFFFFFFF, is_palindrome_mask, j);\n                \n                // Even or odd check\n                if (original % 2 == 0) {\n                    even_vec = vaddq_s32(even_vec, vandq_s32(vdupq_n_s32(1), is_palindrome_mask));\n                } else {\n                    odd_vec = vaddq_s32(odd_vec, vandq_s32(vdupq_n_s32(1), is_palindrome_mask));\n                }\n            }\n        }\n    }\n    \n    // Horizontal sum of SIMD vectors\n    int32x2_t even_sum_low = vget_low_s32(even_vec);\n    int32x2_t even_sum_high = vget_high_s32(even_vec);\n    int32x2_t even_sum = vadd_s32(even_sum_low, even_sum_high);\n    even_count = vget_lane_s32(even_sum, 0) + vget_lane_s32(even_sum, 1);\n    \n    int32x2_t odd_sum_low = vget_low_s32(odd_vec);\n    int32x2_t odd_sum_high = vget_high_s32(odd_vec);\n    int32x2_t odd_sum = vadd_s32(odd_sum_low, odd_sum_high);\n    odd_count = vget_lane_s32(odd_sum, 0) + vget_lane_s32(odd_sum, 1);\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int32x4_t even_count_vec = vdupq_n_s32(0);\n    int32x4_t odd_count_vec = vdupq_n_s32(0);\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t current_nums = {i, i+1, i+2, i+3};\n        \n        // Check palindrome for each number\n        int32x4_t is_palindrome_mask = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = current_nums[j];\n            if (num > n) break;\n            \n            int original = num;\n            int reversed = 0;\n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed) {\n                is_palindrome_mask = vsetq_lane_s32(1, is_palindrome_mask, j);\n            }\n        }\n        \n        // Count even and odd palindromes\n        int32x4_t even_mask = vandq_s32(is_palindrome_mask, vdupq_n_s32(1));\n        int32x4_t odd_mask = vandq_s32(is_palindrome_mask, vdupq_n_s32(1));\n        \n        even_count_vec = vaddq_s32(even_count_vec, vcntq_s32(even_mask));\n        odd_count_vec = vaddq_s32(odd_count_vec, vcntq_s32(odd_mask));\n    }\n    \n    // Horizontal sum\n    int even_count = vgetq_lane_s32(even_count_vec, 0) + \n                     vgetq_lane_s32(even_count_vec, 1) + \n                     vgetq_lane_s32(even_count_vec, 2) + \n                     vgetq_lane_s32(even_count_vec, 3);\n    \n    int odd_count = vgetq_lane_s32(odd_count_vec, 0) + \n                    vgetq_lane_s32(odd_count_vec, 1) + \n                    vgetq_lane_s32(odd_count_vec, 2) + \n                    vgetq_lane_s32(odd_count_vec, 3);\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 elements at a time using Neon SIMD\n    int simd_size = size - (size % 4);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        \n        // Compute absolute value of each number\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        // Convert each number to digits and sum them\n        int32x4_t digit_sums = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = vgetq_lane_s32(abs_nums, j);\n            int digit_sum = 0;\n            while (num > 0) {\n                digit_sum += num % 10;\n                num /= 10;\n            }\n            digit_sums = vsetq_lane_s32(digit_sum, digit_sums, j);\n        }\n        \n        // Compare digit sums > 0 and accumulate count\n        uint32x4_t mask = vcgtq_s32(digit_sums, vdupq_n_s32(0));\n        count_vec = vaddq_s32(count_vec, vreinterpretq_s32_u32(mask));\n    }\n    \n    // Horizontal sum of count vector\n    int32x2_t sum_low = vget_low_s32(count_vec);\n    int32x2_t sum_high = vget_high_s32(count_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    count += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Process remaining elements\n    for (int i = simd_size; i < size; i++) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        \n        // Compute absolute value of digits\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        // Extract individual digits\n        int32x4_t digit1 = vmovq_n_s32(0);\n        int32x4_t digit2 = vmovq_n_s32(0);\n        int32x4_t digit3 = vmovq_n_s32(0);\n        int32x4_t digit4 = vmovq_n_s32(0);\n        \n        for (int j = 0; j < 10; j++) {\n            digit1 = vaddq_s32(digit1, vandq_s32(vceqq_s32(abs_nums, vmovq_n_s32(j)), vmovq_n_s32(1)));\n            digit2 = vaddq_s32(digit2, vandq_s32(vceqq_s32(abs_nums, vmovq_n_s32(j * 10)), vmovq_n_s32(1)));\n            digit3 = vaddq_s32(digit3, vandq_s32(vceqq_s32(abs_nums, vmovq_n_s32(j * 100)), vmovq_n_s32(1)));\n            digit4 = vaddq_s32(digit4, vandq_s32(vceqq_s32(abs_nums, vmovq_n_s32(j * 1000)), vmovq_n_s32(1)));\n        }\n        \n        // Compute digit sum\n        int32x4_t digit_sum = vaddq_s32(vaddq_s32(digit1, digit2), vaddq_s32(digit3, digit4));\n        \n        // Count numbers with digit sum > 0\n        int32x4_t mask = vcgtq_s32(digit_sum, vmovq_n_s32(0));\n        count_vec = vaddq_s32(count_vec, vandq_s32(mask, vmovq_n_s32(1)));\n    }\n    \n    // Horizontal sum of count_vec\n    int32x2_t count_vec_low = vget_low_s32(count_vec);\n    int32x2_t count_vec_high = vget_high_s32(count_vec);\n    count_vec_low = vadd_s32(count_vec_low, count_vec_high);\n    count += vget_lane_s32(count_vec_low, 0) + vget_lane_s32(count_vec_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        int abs_num = std::abs(n[i]);\n        int digit_sum = 0;\n        while (abs_num > 0) {\n            digit_sum += abs_num % 10;\n            abs_num /= 10;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 elements at a time using Neon\n    int vector_size = size - (size % 4);\n    int32x4_t count_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        \n        // Compute absolute value of each number\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        // Compute digit sum for each number\n        int32x4_t digit_sums = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int num = vgetq_lane_s32(abs_nums, j);\n            int digit_sum = 0;\n            while (num > 0) {\n                digit_sum += num % 10;\n                num /= 10;\n            }\n            digit_sums = vsetq_lane_s32(digit_sum, digit_sums, j);\n        }\n        \n        // Compare digit sums > 0\n        uint32x4_t mask = vcgtq_s32(digit_sums, vdupq_n_s32(0));\n        \n        // Count elements with digit sum > 0\n        int32x4_t increments = vreinterpretq_s32_u32(mask);\n        count_vec = vaddq_s32(count_vec, increments);\n    }\n    \n    // Horizontal sum of count_vec\n    int32x2_t count_low = vget_low_s32(count_vec);\n    int32x2_t count_high = vget_high_s32(count_vec);\n    count_low = vadd_s32(count_low, count_high);\n    count += vget_lane_s32(count_low, 0) + vget_lane_s32(count_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int vec_size = n.size();\n    \n    // Process 4 integers at a time using Neon\n    int simd_width = 4;\n    int i = 0;\n    \n    // Process 4 integers in parallel\n    for (; i + simd_width <= vec_size; i += simd_width) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        \n        // Compute absolute value of each integer\n        int32x4_t abs_vec = vabsq_s32(vec);\n        \n        // Compute digit sum for each integer\n        int32x4_t digit_sum_vec = vdupq_n_s32(0);\n        \n        for (int j = 0; j < 32; j += 8) {\n            int32x4_t shifted_vec = vshrq_n_s32(abs_vec, j);\n            int32x4_t digit_vec = vandq_s32(shifted_vec, vdupq_n_s32(0xFF));\n            digit_sum_vec = vaddq_s32(digit_sum_vec, digit_vec);\n        }\n        \n        // Check if digit sum is greater than 0\n        uint32x4_t mask = vcgtq_s32(digit_sum_vec, vdupq_n_s32(0));\n        int32x4_t result_vec = vreinterpretq_s32_u32(mask);\n        \n        // Count number of elements with digit sum > 0\n        count += vaddvq_s32(result_vec);\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < vec_size; i++) {\n        int num = abs(n[i]);\n        int digit_sum = 0;\n        \n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int vec_size = n.size();\n    \n    // Process 4 integers at a time using Neon\n    int simd_width = 4;\n    int i = 0;\n    \n    // Process 4 integers in parallel\n    for (; i + simd_width <= vec_size; i += simd_width) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        \n        // Compute digit sum for each number\n        int32x4_t digit_sums = vdupq_n_s32(0);\n        \n        for (int j = 0; j < 10; j++) {  // Max 10 digit places\n            int32x4_t abs_vec = vabsq_s32(vec);\n            int32x4_t digit = vmodq_s32(abs_vec, vdupq_n_s32(10));\n            digit_sums = vaddq_s32(digit_sums, digit);\n            vec = vdivq_s32(vec, vdupq_n_s32(10));\n        }\n        \n        // Compare digit sums > 0\n        uint32x4_t mask = vcgtq_s32(digit_sums, vdupq_n_s32(0));\n        \n        // Count numbers with digit sum > 0\n        count += vaddv_u32(vmovn_u64(vpaddlq_u32(mask)));\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < vec_size; i++) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        \n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Use Neon SIMD to find the minimum element and its index\n    int32x4_t min_vec = vdupq_n_s32(arr[0]);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        uint32x4_t compare_mask = vcltq_s32(current_vec, min_vec);\n        \n        // Update minimum value and index\n        min_vec = vbslq_s32(compare_mask, current_vec, min_vec);\n        \n        // Find the index of minimum element\n        for (int j = 0; j < 4 && i + j < n; j++) {\n            if (vgetq_lane_s32(min_vec, j) == arr[i + j]) {\n                min_idx = i + j;\n                break;\n            }\n        }\n    }\n\n    // Check if the array can be sorted by right shifts\n    for (int shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        for (int i = 1; i < n; i++) {\n            if (arr[(min_idx + i) % n] < arr[(min_idx + i - 1) % n]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n        min_idx = (min_idx + 1) % n;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element and its index\n    int32x4_t min_vec = vdupq_n_s32(arr[0]);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        uint32x4_t min_mask = vcltq_s32(current_vec, min_vec);\n        min_vec = vbslq_s32(min_mask, current_vec, min_vec);\n        \n        // Update min index\n        int32x4_t idx_vec = vdupq_n_s32(i);\n        uint32x4_t idx_mask = vcltq_s32(current_vec, min_vec);\n        min_idx = vgetq_lane_s32(vbslq_s32(idx_mask, idx_vec, vdupq_n_s32(min_idx)), 0);\n    }\n\n    // Rotate the array to start from minimum element\n    std::rotate(arr.begin(), arr.begin() + min_idx, arr.end());\n\n    // Check if array is sorted\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i-1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Use Neon SIMD to find the minimum element and its index\n    int32x4_t min_vec = vdupq_n_s32(arr[0]);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        uint32x4_t compare_mask = vcltq_s32(current_vec, min_vec);\n        \n        // Update minimum if a smaller element is found\n        min_vec = vbslq_s32(compare_mask, current_vec, min_vec);\n        \n        // Track index of minimum element\n        int32x4_t idx_vec = vdupq_n_s32(i);\n        min_idx = vgetq_lane_s32(idx_vec, __builtin_ctz(vgetq_lane_u32(compare_mask, 0)));\n    }\n\n    // Rotate the array to check if it becomes sorted\n    for (int shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        // Use Neon to check if array is sorted after rotation\n        for (int i = 0; i < n - 1; i += 4) {\n            int32x4_t current_vec = vld1q_s32(&arr[(i + shift) % n]);\n            int32x4_t next_vec = vld1q_s32(&arr[(i + shift + 1) % n]);\n            \n            uint32x4_t compare_mask = vcgtq_s32(current_vec, next_vec);\n            \n            if (vaddvq_u32(compare_mask) > 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element's index\n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n\n    // Use Neon SIMD for checking sorted order\n    int32x4_t prev_vec, curr_vec;\n    int rotations = 0;\n\n    for (int shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        // Process 4 elements at a time using Neon\n        for (int i = 0; i < n - 4; i += 4) {\n            int start_idx = (min_idx + shift + i) % n;\n            int next_start_idx = (min_idx + shift + i + 4) % n;\n\n            prev_vec = vld1q_s32(&arr[start_idx]);\n            curr_vec = vld1q_s32(&arr[next_start_idx]);\n\n            // Compare adjacent 4-element vectors\n            uint32x4_t cmp_result = vcleq_s32(prev_vec, curr_vec);\n            if (vgetq_lane_u32(cmp_result, 3) == 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        // Check remaining elements\n        for (int i = n - (n % 4); i < n; i++) {\n            int curr_idx = (min_idx + shift + i) % n;\n            int next_idx = (min_idx + shift + i + 1) % n;\n            if (arr[curr_idx] > arr[next_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Use Neon SIMD to find the minimum element and its index\n    int32x4_t min_vec = vdupq_n_s32(arr[0]);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        uint32x4_t compare_mask = vcltq_s32(current_vec, min_vec);\n        \n        // Update minimum and index using SIMD comparison\n        min_vec = vbslq_s32(compare_mask, current_vec, min_vec);\n        \n        // Horizontal min and index tracking\n        int32_t min_elements[4];\n        vst1q_s32(min_elements, min_vec);\n        \n        for (int j = 0; j < 4 && i + j < n; j++) {\n            if (min_elements[j] < vgetq_lane_s32(min_vec, 0)) {\n                min_vec = vsetq_lane_s32(min_elements[j], min_vec, 0);\n                min_idx = i + j;\n            }\n        }\n    }\n\n    // Check if rotated array is sorted\n    for (int shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        // Use Neon SIMD for sorted check\n        for (int i = 0; i < n - 1; i += 4) {\n            int32x4_t current_vec = vld1q_s32(&arr[(i + min_idx) % n]);\n            int32x4_t next_vec = vld1q_s32(&arr[(i + min_idx + 1) % n]);\n            \n            uint32x4_t compare_mask = vcgtq_s32(current_vec, next_vec);\n            \n            if (vaddvq_u32(compare_mask) > 0) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n        min_idx = (min_idx + 1) % n;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, even_count1 = 0;\n    int odd_count2 = 0, even_count2 = 0;\n    \n    // Use Neon SIMD for parallel processing\n    int n = lst1.size();\n    int vector_size = 4;\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n; i += vector_size) {\n        int remaining = std::min(vector_size, n - i);\n        \n        // Load vectors\n        int32x4_t vec1 = vld1q_s32(lst1.data() + i);\n        int32x4_t vec2 = vld1q_s32(lst2.data() + i);\n        \n        // Create mask for odd/even numbers\n        uint32x4_t odd_mask1 = vreinterpretq_u32_u8(vandq_u8(\n            vreinterpretq_u8_s32(vec1), \n            vreinterpretq_u8_u32(vmovq_n_u32(1))\n        ));\n        \n        uint32x4_t odd_mask2 = vreinterpretq_u8_u32(vandq_u8(\n            vreinterpretq_u8_s32(vec2), \n            vreinterpretq_u8_u32(vmovq_n_u32(1))\n        ));\n        \n        // Count odd/even numbers\n        for (int j = 0; j < remaining; ++j) {\n            if (vgetq_lane_u32(odd_mask1, j)) {\n                odd_count1++;\n            } else {\n                even_count1++;\n            }\n            \n            if (vgetq_lane_u32(odd_mask2, j)) {\n                odd_count2++;\n            } else {\n                even_count2++;\n            }\n        }\n    }\n    \n    // Check if exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, even_count1 = 0;\n    int odd_count2 = 0, even_count2 = 0;\n    \n    // Use Neon SIMD for parallel processing\n    int n = lst1.size();\n    int vector_size = 4;\n    \n    for (int i = 0; i < n; i += vector_size) {\n        int remaining = std::min(vector_size, n - i);\n        \n        // Load vectors\n        int32x4_t vec1 = vld1q_s32(lst1.data() + i);\n        int32x4_t vec2 = vld1q_s32(lst2.data() + i);\n        \n        // Create mask for odd/even numbers\n        uint32x4_t odd_mask1 = vtstq_u32(vec1, vdupq_n_u32(1));\n        uint32x4_t even_mask1 = vmvnq_u32(odd_mask1);\n        \n        uint32x4_t odd_mask2 = vtstq_u32(vec2, vdupq_n_u32(1));\n        uint32x4_t even_mask2 = vmvnq_u32(odd_mask2);\n        \n        // Count odd and even numbers\n        for (int j = 0; j < remaining; ++j) {\n            if (vgetq_lane_u32(odd_mask1, j)) odd_count1++;\n            if (vgetq_lane_u32(even_mask1, j)) even_count1++;\n            \n            if (vgetq_lane_u32(odd_mask2, j)) odd_count2++;\n            if (vgetq_lane_u32(even_mask2, j)) even_count2++;\n        }\n    }\n    \n    // Check if exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, even_count1 = 0;\n    int odd_count2 = 0, even_count2 = 0;\n    \n    // Use Neon SIMD for parallel processing\n    int n = lst1.size();\n    int vector_size = 4;\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < n; i += vector_size) {\n        int remaining = std::min(vector_size, n - i);\n        \n        // Load vectors\n        int32x4_t vec1 = vld1q_s32(lst1.data() + i);\n        int32x4_t vec2 = vld1q_s32(lst2.data() + i);\n        \n        // Create mask for odd/even numbers\n        uint32x4_t odd_mask1 = vtstq_u32(vec1, vdupq_n_u32(1));\n        uint32x4_t even_mask1 = vmvnq_u32(odd_mask1);\n        \n        uint32x4_t odd_mask2 = vtstq_u32(vec2, vdupq_n_u32(1));\n        uint32x4_t even_mask2 = vmvnq_u32(odd_mask2);\n        \n        // Count odd and even numbers\n        for (int j = 0; j < remaining; ++j) {\n            if (vgetq_lane_u32(odd_mask1, j)) odd_count1++;\n            if (vgetq_lane_u32(even_mask1, j)) even_count1++;\n            \n            if (vgetq_lane_u32(odd_mask2, j)) odd_count2++;\n            if (vgetq_lane_u32(even_mask2, j)) even_count2++;\n        }\n    }\n    \n    // Check if we can exchange to make lst1 all even\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, even_count1 = 0;\n    int odd_count2 = 0, even_count2 = 0;\n    \n    // Use Neon SIMD to count odd and even numbers\n    size_t vec_size = lst1.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n    \n    // Process 4 elements at a time using Neon\n    for (size_t i = 0; i < simd_size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n        \n        // Check evenness using bitwise AND\n        uint32x4_t is_even1 = vceqq_u32(vandq_u32(vreinterpretq_u32_s32(vec1), vdupq_n_u32(1)), vdupq_n_u32(0));\n        uint32x4_t is_even2 = vceqq_u32(vandq_u32(vreinterpretq_u32_s32(vec2), vdupq_n_u32(1)), vdupq_n_u32(0));\n        \n        // Count even and odd numbers\n        odd_count1 += 4 - vaddvq_u32(is_even1);\n        even_count1 += vaddvq_u32(is_even1);\n        odd_count2 += 4 - vaddvq_u32(is_even2);\n        even_count2 += vaddvq_u32(is_even2);\n    }\n    \n    // Process remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        if (lst1[i] % 2 == 0) {\n            even_count1++;\n        } else {\n            odd_count1++;\n        }\n        \n        if (lst2[i] % 2 == 0) {\n            even_count2++;\n        } else {\n            odd_count2++;\n        }\n    }\n    \n    // Check if we can exchange elements to make lst1 all even\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, even_count1 = 0;\n    int odd_count2 = 0, even_count2 = 0;\n    \n    // Use Neon SIMD for parallel processing\n    int n = lst1.size();\n    int vec_size = n - (n % 4);\n    \n    // Process 4 elements at a time using Neon\n    for (int i = 0; i < vec_size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n        \n        // Check evenness using bitwise AND\n        uint32x4_t is_even1 = vceqzq_s32(vandq_s32(vec1, vdupq_n_s32(1)));\n        uint32x4_t is_even2 = vceqzq_s32(vandq_s32(vec2, vdupq_n_s32(1)));\n        \n        // Count odd and even elements\n        odd_count1 += 4 - vaddvq_u32(is_even1);\n        even_count1 += vaddvq_u32(is_even1);\n        odd_count2 += 4 - vaddvq_u32(is_even2);\n        even_count2 += vaddvq_u32(is_even2);\n    }\n    \n    // Process remaining elements sequentially\n    for (int i = vec_size; i < n; ++i) {\n        if (lst1[i] % 2 == 0) {\n            even_count1++;\n        } else {\n            odd_count1++;\n        }\n        \n        if (lst2[i] % 2 == 0) {\n            even_count2++;\n        } else {\n            odd_count2++;\n        }\n    }\n    \n    // Check if we can exchange elements to make lst1 all even\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using Neon SIMD\n        size_t i = 0;\n        for (; i + 16 <= str.length(); i += 16) {\n            // Load 16 characters into Neon register\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert to numeric values\n            uint8x16_t numeric_vals = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Create mask for odd digits (last bit set)\n            uint8x16_t odd_mask = vandq_u8(numeric_vals, vdupq_n_u8(1));\n            \n            // Count odd digits using horizontal sum\n            uint8x16_t zero_vec = vdupq_n_u8(0);\n            odd_count += vaddvq_u8(odd_mask);\n        }\n        \n        // Process remaining characters sequentially\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using Neon SIMD\n        size_t i = 0;\n        for (; i + 16 <= str.length(); i += 16) {\n            // Load 16 characters into uint8x16_t\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert characters to numeric values\n            uint8x16_t zero = vdupq_n_u8('0');\n            uint8x16_t digits = vsubq_u8(chars, zero);\n            \n            // Check which digits are odd\n            uint8x16_t odd_mask = vandq_u8(digits, vdupq_n_u8(1));\n            \n            // Count odd digits\n            uint8x16_t cnt = vcntq_u8(odd_mask);\n            odd_count += vaddvq_u8(cnt);\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        \n        // Process 16 characters at a time using Neon SIMD\n        size_t i = 0;\n        for (; i + 15 < len; i += 16) {\n            uint8x16_t digits = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert characters to numeric values\n            uint8x16_t zero = vdupq_n_u8('0');\n            uint8x16_t numeric_digits = vsubq_u8(digits, zero);\n            \n            // Check for odd digits\n            uint8x16_t odd_mask = vandq_u8(numeric_digits, vdupq_n_u8(1));\n            \n            // Count odd digits\n            uint8x16_t count_vec = vcgtq_u8(odd_mask, vdupq_n_u8(0));\n            odd_count += vaddvq_u8(count_vec);\n        }\n        \n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using Neon SIMD\n        size_t i = 0;\n        for (; i + 16 <= str.length(); i += 16) {\n            // Load 16 characters\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert to numeric values\n            uint8x16_t numeric_vals = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Check which digits are odd\n            uint8x16_t odd_mask = vandq_u8(numeric_vals, vdupq_n_u8(1));\n            \n            // Count odd digits\n            uint8x16_t cnt = vcntq_u8(odd_mask);\n            odd_count += vaddvq_u8(cnt);\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using Neon SIMD\n        size_t i = 0;\n        for (; i + 16 <= str.length(); i += 16) {\n            // Load 16 characters\n            uint8x16_t chars = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert to numeric values\n            uint8x16_t numeric_vals = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Check which digits are odd (lowest bit set)\n            uint8x16_t odd_mask = vandq_u8(numeric_vals, vdupq_n_u8(1));\n            \n            // Count odd digits\n            uint8x16_t cnt = vcntq_u8(odd_mask);\n            odd_count += vaddvq_u8(cnt);\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    // Process 4 elements at a time using Neon\n    int64x2_t min_sum_vec = vdup_n_s64(INT64_MAX);\n    int64x2_t current_sum_vec = vdup_n_s64(0);\n    \n    for (int i = 0; i < n - 1; i += 2) {\n        // Load 2 elements\n        int64x2_t vec = vld1_s64(&nums[i]);\n        \n        // Update current sum\n        current_sum_vec = vadd_s64(current_sum_vec, vec);\n        \n        // Update min sum\n        min_sum_vec = vmin_s64(min_sum_vec, current_sum_vec);\n        \n        // Reset current sum if it becomes positive\n        int64x2_t zero_vec = vdup_n_s64(0);\n        current_sum_vec = vmin_s64(current_sum_vec, zero_vec);\n    }\n    \n    // Horizontal min of SIMD vector\n    int64_t simd_min_sum = vget_lane_s64(min_sum_vec, 0);\n    simd_min_sum = std::min(simd_min_sum, vget_lane_s64(min_sum_vec, 1));\n    \n    // Process remaining elements\n    for (int i = (n / 2) * 2; i < n; i++) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum, 0LL);\n    }\n    \n    return std::min(min_sum, simd_min_sum);\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    // Process 4 elements at a time using Neon\n    int64x2_t min_sum_vec = vdup_n_s64(INT64_MAX);\n    int64x2_t current_sum_vec = vdup_n_s64(0);\n    \n    int i = 0;\n    // Process 4 elements at a time\n    for (; i + 1 < n; i += 2) {\n        // Load 2 elements\n        int64x2_t vec = vld1_s64(&nums[i]);\n        \n        // Update current sum\n        current_sum_vec = vadd_s64(current_sum_vec, vec);\n        \n        // Update min sum\n        min_sum_vec = vmin_s64(min_sum_vec, current_sum_vec);\n        \n        // Reset current sum if it becomes positive\n        int64x2_t zero_vec = vdup_n_s64(0);\n        current_sum_vec = vmin_s64(current_sum_vec, zero_vec);\n    }\n    \n    // Horizontal min of vector\n    int64_t lane0 = vget_lane_s64(min_sum_vec, 0);\n    int64_t lane1 = vget_lane_s64(min_sum_vec, 1);\n    min_sum = std::min({min_sum, lane0, lane1});\n    \n    // Process remaining elements\n    current_sum = 0;\n    for (; i < n; i++) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        current_sum = std::min(current_sum, 0LL);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements into Neon vector\n        int64x2_t vec_low = vld1_s64(&nums[i]);\n        int64x2_t vec_high = vld1_s64(&nums[i+2]);\n        \n        // Compute cumulative sums\n        int64x2_t sum_low = vpadd_s64(vec_low, vec_high);\n        \n        // Horizontal add to get total sum\n        int64_t lane_sum = vget_lane_s64(sum_low, 0) + vget_lane_s64(sum_low, 1);\n        \n        current_sum += lane_sum;\n        min_sum = std::min(min_sum, current_sum);\n        \n        // Reset sum if it becomes positive\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        \n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements into Neon vector\n        int64x2_t vec_low = vld1_s64(&nums[i]);\n        int64x2_t vec_high = vld1_s64(&nums[i+2]);\n        \n        // Compute cumulative sums\n        int64x2_t sum_low = vset_lane_s64(current_sum, vec_low, 0);\n        int64x2_t sum_high = vset_lane_s64(current_sum + vec_low[0] + vec_low[1], vec_high, 0);\n        \n        // Horizontal add to update current sum\n        current_sum += vec_low[0] + vec_low[1] + vec_high[0] + vec_high[1];\n        \n        // Update min sum\n        min_sum = std::min({min_sum, sum_low[0], sum_low[1], sum_high[0], sum_high[1], current_sum});\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 3 < n; i += 4) {\n        // Load 4 elements into Neon vector\n        int64x2_t vec_low = vld1_s64(&nums[i]);\n        int64x2_t vec_high = vld1_s64(&nums[i+2]);\n        \n        // Compute cumulative sums\n        int64x2_t sum_low = vpadd_s64(vec_low, vec_high);\n        \n        // Horizontal add to get total sum\n        int64_t lane_sum = vget_lane_s64(sum_low, 0) + vget_lane_s64(sum_low, 1);\n        \n        current_sum += lane_sum;\n        min_sum = std::min(min_sum, current_sum);\n        \n        // Reset if current sum becomes positive\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        \n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Accumulate water in each column using NEON\n    int32x4_t column_water_vec = vdupq_n_s32(0);\n    \n    for (int j = 0; j < cols; j += 4) {\n        int32x4_t column_sum = vdupq_n_s32(0);\n        \n        // Vectorized column sum calculation\n        for (int i = 0; i < rows; i++) {\n            int32x4_t row_vec = vld1q_s32(&grid[i][j]);\n            column_sum = vaddq_s32(column_sum, row_vec);\n        }\n        \n        column_water_vec = vaddq_s32(column_water_vec, column_sum);\n    }\n    \n    // Handle remaining columns if not divisible by 4\n    int remaining_cols = cols % 4;\n    for (int j = cols - remaining_cols; j < cols; j++) {\n        int column_sum = 0;\n        for (int i = 0; i < rows; i++) {\n            column_sum += grid[i][j];\n        }\n        column_water_vec = vsetq_lane_s32(column_sum, column_water_vec, 0);\n    }\n    \n    // Horizontal sum of column water\n    int32x2_t sum_low = vget_low_s32(column_water_vec);\n    int32x2_t sum_high = vget_high_s32(column_water_vec);\n    int32x2_t total_sum = vadd_s32(sum_low, sum_high);\n    total_sum = vpadd_s32(total_sum, total_sum);\n    \n    int total_water = vget_lane_s32(total_sum, 0);\n    \n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use Neon intrinsics to parallelize water counting\n    for (int i = 0; i < rows; i += 4) {\n        int remaining_rows = std::min(4, rows - i);\n        \n        // Use 128-bit vector to process 4 rows simultaneously\n        uint32x4_t water_count_vec = vdupq_n_u32(0);\n\n        for (int j = 0; j < cols; j++) {\n            uint32x4_t row_water = vdupq_n_u32(0);\n\n            // Load water units for up to 4 rows\n            for (int k = 0; k < remaining_rows; k++) {\n                row_water = vsetq_lane_u32(grid[i + k][j], row_water, k);\n            }\n\n            // Accumulate water count\n            water_count_vec = vaddq_u32(water_count_vec, row_water);\n        }\n\n        // Horizontal sum of water count\n        uint32x2_t sum_low = vget_low_u32(water_count_vec);\n        uint32x2_t sum_high = vget_high_u32(water_count_vec);\n        uint32x2_t sum_total = vadd_u32(sum_low, sum_high);\n        sum_total = vpadd_u32(sum_total, sum_total);\n\n        // Calculate bucket lowerings\n        int row_water_count = vget_lane_u32(sum_total, 0);\n        total_water += (row_water_count + capacity - 1) / capacity;\n    }\n\n    return total_water;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use NEON intrinsics to count water in parallel\n    for (int i = 0; i < rows; i += 4) {\n        int remaining_rows = std::min(4, rows - i);\n        \n        // Initialize NEON vectors to store water counts\n        uint32x4_t water_counts = vmovq_n_u32(0);\n        \n        // Process 4 rows at a time or remaining rows\n        for (int j = 0; j < cols; j++) {\n            uint32x4_t row_water = vmovq_n_u32(0);\n            \n            // Load water for each row\n            for (int k = 0; k < remaining_rows; k++) {\n                row_water = vsetq_lane_u32(grid[i + k][j], row_water, k);\n            }\n            \n            // Accumulate water counts\n            water_counts = vaddq_u32(water_counts, row_water);\n        }\n        \n        // Horizontal sum of water counts\n        uint32x2_t sum_low = vget_low_u32(water_counts);\n        uint32x2_t sum_high = vget_high_u32(water_counts);\n        sum_low = vadd_u32(sum_low, sum_high);\n        sum_low = vpadd_u32(sum_low, sum_low);\n        \n        // Calculate number of bucket lowerings\n        int row_water_count = vget_lane_u32(sum_low, 0);\n        total_water += (row_water_count + capacity - 1) / capacity;\n    }\n    \n    return total_water;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use Neon intrinsics to count water in each column\n    for (int j = 0; j < cols; j += 4) {\n        int32x4_t column_water = vdupq_n_s32(0);\n\n        // Vectorized column water counting\n        for (int i = 0; i < rows; i++) {\n            // Load 4 elements from the column\n            int32x4_t row_data = vld1q_s32(grid[i].data() + j);\n            column_water = vaddq_s32(column_water, row_data);\n        }\n\n        // Horizontal sum of column water\n        int32x2_t sum_low = vget_low_s32(column_water);\n        int32x2_t sum_high = vget_high_s32(column_water);\n        int32x2_t total_sum = vadd_s32(sum_low, sum_high);\n        total_sum = vpadd_s32(total_sum, total_sum);\n        int column_total = vget_lane_s32(total_sum, 0);\n\n        // Calculate bucket lowerings for this column\n        total_water += (column_total + capacity - 1) / capacity;\n    }\n\n    // Handle remaining columns if not divisible by 4\n    for (int j = cols - (cols % 4); j < cols; j++) {\n        int column_water = 0;\n        for (int i = 0; i < rows; i++) {\n            column_water += grid[i][j];\n        }\n        total_water += (column_water + capacity - 1) / capacity;\n    }\n\n    return total_water;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use Neon intrinsics to count water in each column\n    for (int j = 0; j < cols; j += 4) {\n        int32x4_t column_water = vdupq_n_s32(0);\n\n        // Vectorized column water counting\n        for (int i = 0; i < rows; i++) {\n            int32x4_t row_vec = vld1q_s32(grid[i].data() + j);\n            column_water = vaddq_s32(column_water, row_vec);\n        }\n\n        // Horizontal sum of column water\n        int32x2_t sum_low = vget_low_s32(column_water);\n        int32x2_t sum_high = vget_high_s32(column_water);\n        int32x2_t sum_total = vadd_s32(sum_low, sum_high);\n        sum_total = vpadd_s32(sum_total, sum_total);\n        int column_total = vget_lane_s32(sum_total, 0);\n\n        // Calculate bucket lowerings for this column\n        total_water += (column_total + capacity - 1) / capacity;\n    }\n\n    // Handle remaining columns if not divisible by 4\n    for (int j = cols - (cols % 4); j < cols; j++) {\n        int column_water = 0;\n        for (int i = 0; i < rows; i++) {\n            column_water += grid[i][j];\n        }\n        total_water += (column_water + capacity - 1) / capacity;\n    }\n\n    return total_water;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    size_t n = lst.size();\n    \n    // Process 8 elements at a time using Neon\n    size_t i = 0;\n    for (; i + 8 <= n; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        \n        // Create mask for even positions (0, 2, 4, 6)\n        int16x8_t even_mask = {0, -1, 0, -1, 0, -1, 0, -1};\n        \n        // Mask to select odd elements\n        int16x8_t odd_mask = {0, 1, 0, 1, 0, 1, 0, 1};\n        \n        // Apply even position mask\n        int16x8_t even_pos_vec = vandq_s16(vec, even_mask);\n        \n        // Apply odd element mask\n        int16x8_t odd_elements = vandq_s16(even_pos_vec, odd_mask);\n        \n        // Sum the odd elements\n        int32x4_t low = vpaddlq_s16(vget_low_s16(odd_elements));\n        int32x4_t high = vpaddlq_s16(vget_high_s16(odd_elements));\n        \n        int64x2_t sum = vpaddlq_s32(low);\n        sum = vpadalq_s32(sum, high);\n        \n        result += vgetq_lane_s64(sum, 0) + vgetq_lane_s64(sum, 1);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i += 2) {\n        if (lst[i + 1] % 2 == 1) {\n            result += lst[i + 1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    size_t n = lst.size();\n    \n    // Process 8 elements at a time using Neon\n    size_t i = 0;\n    for (; i + 7 < n; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        \n        // Create mask for even positions\n        int16x8_t indices = {0, 1, 2, 3, 4, 5, 6, 7};\n        uint16x8_t even_mask = vceqq_u16(vandq_u16(indices, vdupq_n_u16(1)), vdupq_n_u16(0));\n        \n        // Mask out odd elements in even positions\n        int16x8_t masked_vec = vandq_s16(vec, even_mask);\n        \n        // Sum the masked elements\n        int32x4_t low = vmovl_s16(vget_low_s16(masked_vec));\n        int32x4_t high = vmovl_s16(vget_high_s16(masked_vec));\n        \n        int32x4_t sum_low = vpaddq_s32(low, low);\n        int32x4_t sum_high = vpaddq_s32(high, high);\n        \n        int32x2_t final_sum = vadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        final_sum = vadd_s32(final_sum, vget_low_s32(sum_high));\n        final_sum = vadd_s32(final_sum, vget_high_s32(sum_high));\n        \n        result += vget_lane_s32(final_sum, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    int64_t result = 0;\n\n    // Process 8 elements at a time using Neon\n    int vectorSize = size - (size % 8);\n    int16x8_t oddPositionMask = vcreate_s16(0x0001000100010001ULL);\n    int16x8_t evenPositionMask = vcreate_s16(0x0000000100000001ULL);\n    int64x2_t sumVector = vdupq_n_s64(0);\n\n    for (int i = 0; i < vectorSize; i += 8) {\n        int16x8_t loadedVector = vld1q_s16(&lst[i]);\n        int16x8_t evenPositions = vandq_s16(loadedVector, evenPositionMask);\n        int16x8_t oddElements = vandq_s16(loadedVector, oddPositionMask);\n        int16x8_t selectedElements = vbslq_s16(evenPositionMask, oddElements, vdupq_n_s16(0));\n        \n        int32x4_t lowSum = vpaddlq_s16(vget_low_s16(selectedElements));\n        int32x4_t highSum = vpaddlq_s16(vget_high_s16(selectedElements));\n        int64x2_t sumPair = vpaddlq_s32(lowSum);\n        sumPair = vaddq_s64(sumPair, vpaddlq_s32(highSum));\n        \n        sumVector = vaddq_s64(sumVector, sumPair);\n    }\n\n    // Horizontal sum of vector\n    int64_t sumArray[2];\n    vst1q_s64(sumArray, sumVector);\n    result = sumArray[0] + sumArray[1];\n\n    // Handle remaining elements\n    for (int i = vectorSize; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 1) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t result = 0;\n    size_t n = lst.size();\n    \n    // Process 8 elements at a time using Neon\n    size_t vectorSize = n - (n % 8);\n    \n    int16x8_t oddPositionMask = vcombine_s16(vcreate_s16(0x0001000100010001), vcreate_s16(0x0001000100010001));\n    int16x8_t evenPositionMask = vcombine_s16(vcreate_s16(0x0000000000000000), vcreate_s16(0x0000000000000000));\n    \n    int32x4_t sumVector = vdupq_n_s32(0);\n    \n    for (size_t i = 0; i < vectorSize; i += 8) {\n        int16x8_t loadedVector = vld1q_s16(&lst[i]);\n        \n        // Mask for even positions\n        int16x8_t evenPositionElements = vandq_s16(loadedVector, evenPositionMask);\n        \n        // Mask for odd elements in even positions\n        int16x8_t oddElementsInEvenPositions = vandq_s16(evenPositionElements, oddPositionMask);\n        \n        // Convert to 32-bit and accumulate\n        int32x4_t lowSum = vpaddlq_s16(vget_low_s16(oddElementsInEvenPositions));\n        int32x4_t highSum = vpaddlq_s16(vget_high_s16(oddElementsInEvenPositions));\n        \n        sumVector = vaddq_s32(sumVector, lowSum);\n        sumVector = vaddq_s32(sumVector, highSum);\n    }\n    \n    // Horizontal sum\n    int64_t horizontalSum = vgetq_lane_s32(sumVector, 0) + \n                             vgetq_lane_s32(sumVector, 1) + \n                             vgetq_lane_s32(sumVector, 2) + \n                             vgetq_lane_s32(sumVector, 3);\n    \n    // Handle remaining elements\n    for (size_t i = vectorSize; i < n; i += 2) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            horizontalSum += lst[i];\n        }\n    }\n    \n    return horizontalSum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    int64_t result = 0;\n\n    // Process 8 elements at a time using Neon\n    int vectorSize = size - (size % 8);\n    int16x8_t oddPositionMask = vcombine_s16(vcreate_s16(0x0001000100010001), vcreate_s16(0x0001000100010001));\n    int16x8_t evenPositionMask = vcombine_s16(vcreate_s16(0x0000000100000001), vcreate_s16(0x0000000100000001));\n    int64x2_t sumVector = vdupq_n_s64(0);\n\n    for (int i = 0; i < vectorSize; i += 8) {\n        int16x8_t loadedVector = vld1q_s16(&lst[i]);\n        int16x8_t evenPositionElements = vandq_s16(loadedVector, evenPositionMask);\n        int16x8_t oddElements = vandq_s16(evenPositionElements, oddPositionMask);\n        \n        int32x4_t lowHalf = vmovl_s16(vget_low_s16(oddElements));\n        int32x4_t highHalf = vmovl_s16(vget_high_s16(oddElements));\n        \n        int64x2_t lowSum = vpaddlq_s32(lowHalf);\n        int64x2_t highSum = vpaddlq_s32(highHalf);\n        \n        sumVector = vaddq_s64(sumVector, lowSum);\n        sumVector = vaddq_s64(sumVector, highSum);\n    }\n\n    // Horizontal sum of vector\n    result = vgetq_lane_s64(sumVector, 0) + vgetq_lane_s64(sumVector, 1);\n\n    // Handle remaining elements\n    for (int i = vectorSize; i < size; i += 2) {\n        if (lst[i] % 2 == 1) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for two-digit numbers\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        mask = vandq_u32(mask, vcgtq_s32(vec, vdupq_n_s32(9)));\n        \n        // Zero out numbers outside two-digit range\n        int32x4_t filtered_vec = vbslq_s32(mask, vec, vdupq_n_s32(0));\n        \n        // Sum the filtered vector\n        int32x4_t sum_vec = filtered_vec;\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        \n        sum += vgetq_lane_s32(sum_vec, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers with at most 2 digits\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        mask = vandq_u32(mask, vcgtq_s32(vec, vdupq_n_s32(-100)));\n        \n        // Zero out numbers outside the range\n        int32x4_t filtered = vandq_s32(vec, vmvnq_u32(mask));\n        \n        // Sum the filtered elements\n        int32x4_t zero = vdupq_n_s32(0);\n        int32x4_t sumVec = vaddq_s32(filtered, zero);\n        \n        // Horizontal sum\n        int32x2_t sumLow = vget_low_s32(sumVec);\n        int32x2_t sumHigh = vget_high_s32(sumVec);\n        sumLow = vadd_s32(sumLow, sumHigh);\n        sum += vget_lane_s32(sumLow, 0) + vget_lane_s32(sumLow, 1);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for two-digit numbers\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        mask = vandq_u32(mask, vcgtq_s32(vec, vdupq_n_s32(9)));\n        \n        // Mask the vector to keep only two-digit numbers\n        int32x4_t masked_vec = vandq_s32(vec, vmvnq_u32(mask));\n        \n        // Sum the masked vector\n        int32x4_t sum_vec = masked_vec;\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        \n        sum += vgetq_lane_s32(sum_vec, 0);\n    }\n    \n    // Process remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers with at most 2 digits\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        mask = vandq_u32(mask, vcgtq_s32(vec, vdupq_n_s32(-100)));\n        \n        // Zero out numbers outside the mask\n        int32x4_t masked_vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        \n        // Sum the masked elements\n        int32x4_t sum_vec = masked_vec;\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        \n        sum += vgetq_lane_s32(sum_vec, 0);\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < k; i++) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for two-digit numbers\n        uint32x4_t mask = vcltq_s32(vec, vdupq_n_s32(100));\n        mask = vandq_u32(mask, vcgtq_s32(vec, vdupq_n_s32(9)));\n        \n        // Mask the vector to keep only two-digit numbers\n        int32x4_t masked_vec = vbslq_s32(mask, vec, vdupq_n_s32(0));\n        \n        // Sum the masked vector\n        int32x4_t sum_vec = masked_vec;\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        sum_vec = vpaddq_s32(sum_vec, sum_vec);\n        \n        sum += vgetq_lane_s32(sum_vec, 0);\n    }\n    \n    // Process remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 elements at a time using Neon\n    int simd_length = n - (n % 4);\n    for (int i = 0; i < simd_length; i += 4) {\n        // Load 4 consecutive integers\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i+1]);\n\n        // Check if elements are in ascending order\n        uint32x4_t order_check = vcgeq_s32(current, next);\n        \n        // Check for duplicates\n        uint32x4_t duplicate_check = vceqq_s32(current, next);\n\n        // If any element is greater than next or equal, return false\n        if (vaddvq_u32(order_check) > 0 || vaddvq_u32(duplicate_check) > 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = simd_length; i < n - 1; i++) {\n        if (lst[i] >= lst[i+1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 elements at a time using Neon\n    int vectorLength = n - (n % 4);\n    \n    for (int i = 0; i < vectorLength; i += 4) {\n        // Load 4 consecutive elements\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i+1]);\n\n        // Check if elements are in ascending order\n        uint32x4_t compareOrder = vcgeq_s32(current, next);\n        \n        // Check for duplicates\n        uint32x4_t duplicates = vceqq_s32(current, next);\n\n        // If any element is greater than next or duplicate, return false\n        if (vaddvq_u32(compareOrder) > 0 || vaddvq_u32(duplicates) > 0) {\n            return false;\n        }\n    }\n\n    // Check remaining elements\n    for (int i = vectorLength; i < n - 1; i++) {\n        if (lst[i] > lst[i+1] || lst[i] == lst[i+1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 elements at a time using Neon\n    int vectorLength = n - (n % 4);\n    \n    // Check ascending order and uniqueness\n    for (int i = 0; i < vectorLength; i += 4) {\n        uint32x4_t current = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        uint32x4_t next = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i+1]));\n        \n        // Check if current is less than next\n        uint32x4_t compareResult = vcltq_u32(current, next);\n        \n        // Check for duplicates\n        uint32x4_t duplicateCheck = vceqq_u32(current, next);\n        \n        // If any element is not less than the next or has duplicates, return false\n        if (!vaddvq_u32(compareResult) || vaddvq_u32(duplicateCheck)) {\n            return false;\n        }\n    }\n    \n    // Check remaining elements\n    for (int i = vectorLength; i < n - 1; ++i) {\n        if (lst[i] >= lst[i+1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 elements at a time using Neon\n    int simd_length = n - (n % 4);\n    for (int i = 0; i < simd_length; i += 4) {\n        // Load 4 consecutive elements\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i+1]);\n\n        // Check if elements are in ascending order\n        uint32x4_t compare_order = vcgtq_s32(current, next);\n        if (vaddvq_u32(compare_order) > 0) return false;\n\n        // Check for duplicates\n        uint32x4_t compare_equal = vceqq_s32(current, next);\n        if (vaddvq_u32(compare_equal) > 1) return false;\n    }\n\n    // Handle remaining elements\n    for (int i = simd_length; i < n - 1; ++i) {\n        if (lst[i] > lst[i+1]) return false;\n        if (lst[i] == lst[i+1]) {\n            int count = 1;\n            for (int j = i + 2; j < n; ++j) {\n                if (lst[j] == lst[i]) count++;\n                if (count > 1) return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 elements at a time using Neon\n    int simd_length = n - (n % 4);\n    for (int i = 0; i < simd_length; i += 4) {\n        // Load 4 consecutive elements\n        int32x4_t current = vld1q_s32(&lst[i]);\n        int32x4_t next = vld1q_s32(&lst[i+1]);\n\n        // Check if elements are in ascending order\n        uint32x4_t order_check = vcgtq_s32(current, next);\n        if (vaddvq_u32(order_check) > 0) return false;\n\n        // Check for duplicates\n        uint32x4_t duplicate_check = vceqq_s32(current, next);\n        if (vaddvq_u32(duplicate_check) > 1) return false;\n    }\n\n    // Handle remaining elements\n    for (int i = simd_length; i < n - 1; i++) {\n        if (lst[i] > lst[i+1]) return false;\n        if (lst[i] == lst[i+1]) {\n            int count = 1;\n            for (int j = i + 2; j < n; j++) {\n                if (lst[j] == lst[i]) count++;\n                if (count > 1) return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int32_t total_magnitude = 0;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    int32x4_t magnitude_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n\n    // Process main vector in chunks of 4\n    for (; i + 3 < arr.size(); i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        \n        // Get absolute values\n        int32x4_t abs_vec = vabsq_s32(current_vec);\n        magnitude_vec = vaddq_s32(magnitude_vec, abs_vec);\n\n        // Compute signs\n        int32x4_t sign_mask = vshrq_n_s32(current_vec, 31);\n        sign_vec = vmulq_s32(sign_vec, vsubq_s32(vdupq_n_s32(0), sign_mask));\n    }\n\n    // Horizontal sum of magnitude\n    int32x2_t sum_low = vget_low_s32(magnitude_vec);\n    int32x2_t sum_high = vget_high_s32(magnitude_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    total_magnitude = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Horizontal sign product\n    int32x2_t sign_low = vget_low_s32(sign_vec);\n    int32x2_t sign_high = vget_high_s32(sign_vec);\n    sign_low = vmul_s32(sign_low, sign_high);\n    sign_product = vget_lane_s32(sign_low, 0) * vget_lane_s32(sign_low, 1);\n\n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        if (arr[i] == 0) return 0;\n        total_magnitude += std::abs(arr[i]);\n        sign_product *= (arr[i] < 0) ? -1 : 1;\n    }\n\n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int32_t total_magnitude = 0;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    int32x4_t magnitude_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n\n    for (; i + 3 < arr.size(); i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        \n        // Get absolute values\n        int32x4_t abs_vec = vabsq_s32(current_vec);\n        magnitude_vec = vaddq_s32(magnitude_vec, abs_vec);\n\n        // Compute signs\n        int32x4_t sign_mask = vshrq_n_s32(current_vec, 31);\n        sign_vec = vmulq_s32(sign_vec, vsubq_s32(vdupq_n_s32(0), sign_mask));\n    }\n\n    // Horizontal sum of magnitude\n    int32x2_t sum_low = vget_low_s32(magnitude_vec);\n    int32x2_t sum_high = vget_high_s32(magnitude_vec);\n    int32x2_t sum_total = vadd_s32(sum_low, sum_high);\n    sum_total = vpadd_s32(sum_total, sum_total);\n    total_magnitude = vget_lane_s32(sum_total, 0);\n\n    // Horizontal sign product\n    int32x2_t sign_low = vget_low_s32(sign_vec);\n    int32x2_t sign_high = vget_high_s32(sign_vec);\n    int32x2_t sign_total = vmul_s32(sign_low, sign_high);\n    sign_total = vpadd_s32(sign_total, sign_total);\n    sign_product = vget_lane_s32(sign_total, 0);\n\n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        total_magnitude += std::abs(arr[i]);\n        sign_product *= (arr[i] >= 0) ? 1 : -1;\n    }\n\n    // Check for zero\n    for (int val : arr) {\n        if (val == 0) return 0;\n    }\n\n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int32_t total_magnitude = 0;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    int32x4_t magnitude_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n\n    // Process 4 elements in parallel\n    for (; i + 3 < arr.size(); i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        \n        // Get absolute values\n        int32x4_t abs_vec = vabsq_s32(current_vec);\n        magnitude_vec = vaddq_s32(magnitude_vec, abs_vec);\n\n        // Compute signs\n        int32x4_t sign_mask = vshrq_n_s32(current_vec, 31);\n        sign_vec = vmulq_s32(sign_vec, vsubq_s32(vdupq_n_s32(0), sign_mask));\n    }\n\n    // Horizontal sum of magnitude\n    int32x2_t sum_low = vget_low_s32(magnitude_vec);\n    int32x2_t sum_high = vget_high_s32(magnitude_vec);\n    int32x2_t sum_total = vadd_s32(sum_low, sum_high);\n    total_magnitude = vget_lane_s32(sum_total, 0) + vget_lane_s32(sum_total, 1);\n\n    // Horizontal sign product\n    int32x2_t sign_low = vget_low_s32(sign_vec);\n    int32x2_t sign_high = vget_high_s32(sign_vec);\n    int32x2_t sign_total = vmul_s32(sign_low, sign_high);\n    sign_product = vget_lane_s32(sign_total, 0);\n\n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        if (arr[i] == 0) return 0;\n        total_magnitude += std::abs(arr[i]);\n        sign_product *= (arr[i] < 0) ? -1 : 1;\n    }\n\n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int32_t total_magnitude = 0;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    int32x4_t magnitude_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n\n    // Process main vector in chunks of 4\n    for (; i + 3 < arr.size(); i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        \n        // Get absolute values\n        int32x4_t abs_vec = vabsq_s32(current_vec);\n        magnitude_vec = vaddq_s32(magnitude_vec, abs_vec);\n\n        // Compute signs\n        int32x4_t sign_mask = vshrq_n_s32(current_vec, 31);\n        sign_vec = vmulq_s32(sign_vec, vsubq_s32(vdupq_n_s32(0), sign_mask));\n    }\n\n    // Horizontal sum of magnitude\n    int32x2_t sum_low = vget_low_s32(magnitude_vec);\n    int32x2_t sum_high = vget_high_s32(magnitude_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    total_magnitude = vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n\n    // Horizontal sign product\n    int32x2_t sign_low = vget_low_s32(sign_vec);\n    int32x2_t sign_high = vget_high_s32(sign_vec);\n    sign_low = vmul_s32(sign_low, sign_high);\n    sign_product = vget_lane_s32(sign_low, 0) * vget_lane_s32(sign_low, 1);\n\n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        if (arr[i] == 0) return 0;\n        total_magnitude += std::abs(arr[i]);\n        sign_product *= (arr[i] < 0) ? -1 : 1;\n    }\n\n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int sign_product = 1;\n    int32_t total_magnitude = 0;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    int32x4_t magnitude_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n\n    for (; i + 3 < arr.size(); i += 4) {\n        int32x4_t current_vec = vld1q_s32(&arr[i]);\n        \n        // Get absolute values\n        int32x4_t abs_vec = vabsq_s32(current_vec);\n        magnitude_vec = vaddq_s32(magnitude_vec, abs_vec);\n\n        // Compute signs\n        int32x4_t sign_mask = vshrq_n_s32(current_vec, 31);\n        sign_vec = vmulq_s32(sign_vec, vsubq_s32(vdupq_n_s32(0), sign_mask));\n    }\n\n    // Horizontal sum of magnitude\n    int32x2_t sum_low = vget_low_s32(magnitude_vec);\n    int32x2_t sum_high = vget_high_s32(magnitude_vec);\n    int32x2_t sum_combined = vadd_s32(sum_low, sum_high);\n    total_magnitude = vget_lane_s32(sum_combined, 0) + vget_lane_s32(sum_combined, 1);\n\n    // Horizontal sign product\n    int32x2_t sign_low = vget_low_s32(sign_vec);\n    int32x2_t sign_high = vget_high_s32(sign_vec);\n    int32x2_t sign_combined = vmul_s32(sign_low, sign_high);\n    sign_product = vget_lane_s32(sign_combined, 0) * vget_lane_s32(sign_combined, 1);\n\n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        total_magnitude += std::abs(arr[i]);\n        sign_product *= (arr[i] >= 0) ? 1 : -1;\n    }\n\n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> paths(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    // Initialize first step paths for all cells\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: right, down, left, up\n    int dx[4] = {0, 1, 0, -1};\n    int dy[4] = {1, 0, -1, 0};\n\n    // SIMD processing for path finding\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int32x4_t min_path_vec = vdupq_n_s32(std::numeric_limits<int>::max());\n                int min_path_idx = -1;\n\n                // Parallel processing of 4 directions using Neon\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        if (dp[ni][nj][len-1] != std::numeric_limits<int>::max()) {\n                            int32x4_t current_path_vec = vdupq_n_s32(dp[ni][nj][len-1]);\n                            int32x4_t current_cell_vec = vdupq_n_s32(grid[i][j]);\n                            int32x4_t combined_path_vec = vaddq_s32(current_path_vec, current_cell_vec);\n\n                            // Find minimum path\n                            uint32x4_t compare_vec = vcltq_s32(combined_path_vec, min_path_vec);\n                            if (vgetq_lane_u32(compare_vec, 0)) {\n                                min_path_vec = combined_path_vec;\n                                min_path_idx = d;\n                            }\n                        }\n                    }\n                }\n\n                if (min_path_idx != -1) {\n                    int ni = i + dx[min_path_idx];\n                    int nj = j + dy[min_path_idx];\n                    dp[i][j][len] = vgetq_lane_s32(min_path_vec, 0);\n                    paths[i][j][len] = paths[ni][nj][len-1];\n                    paths[i][j][len].push_back(grid[i][j]);\n                }\n            }\n        }\n    }\n\n    // Find the minimum path\n    std::vector<int> result;\n    int min_val = std::numeric_limits<int>::max();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n                result = paths[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> paths(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    // Initialize first step\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    // SIMD processing for path finding\n    for (int steps = 2; steps <= k; steps++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int32x4_t min_val_vec = vdupq_n_s32(std::numeric_limits<int>::max());\n                int best_prev_x = -1, best_prev_y = -1;\n\n                for (int d = 0; d < 4; d++) {\n                    int prev_x = i + dx[d];\n                    int prev_y = j + dy[d];\n\n                    if (prev_x >= 0 && prev_x < N && prev_y >= 0 && prev_y < N) {\n                        if (dp[prev_x][prev_y][steps - 1] != std::numeric_limits<int>::max()) {\n                            int32x4_t current_vec = vdupq_n_s32(grid[i][j]);\n                            int32x4_t prev_vec = vdupq_n_s32(dp[prev_x][prev_y][steps - 1]);\n                            int32x4_t compare_vec = vaddq_s32(prev_vec, current_vec);\n\n                            uint32x4_t compare_mask = vcltq_s32(compare_vec, min_val_vec);\n                            if (vgetq_lane_u32(compare_mask, 0)) {\n                                min_val_vec = compare_vec;\n                                best_prev_x = prev_x;\n                                best_prev_y = prev_y;\n                            }\n                        }\n                    }\n                }\n\n                if (best_prev_x != -1) {\n                    dp[i][j][steps] = vgetq_lane_s32(min_val_vec, 0);\n                    paths[i][j][steps] = paths[best_prev_x][best_prev_y][steps - 1];\n                    paths[i][j][steps].push_back(grid[i][j]);\n                }\n            }\n        }\n    }\n\n    // Find minimum path\n    int min_val = std::numeric_limits<int>::max();\n    std::vector<int> result;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n                result = paths[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> paths(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    // Initialize first step\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    // SIMD path finding\n    for (int step = 2; step <= k; step++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int32x4_t min_vec = vdupq_n_s32(std::numeric_limits<int>::max());\n                int min_idx = -1;\n\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        int32x4_t curr_vec = vdupq_n_s32(dp[ni][nj][step - 1]);\n                        int32x4_t grid_vec = vdupq_n_s32(grid[i][j]);\n                        int32x4_t sum_vec = vaddq_s32(curr_vec, grid_vec);\n\n                        uint32x4_t cmp_vec = vcltq_s32(sum_vec, min_vec);\n                        if (vgetq_lane_u32(cmp_vec, 0)) {\n                            min_vec = sum_vec;\n                            min_idx = d;\n                        }\n                    }\n                }\n\n                if (min_idx != -1) {\n                    int ni = i + dx[min_idx];\n                    int nj = j + dy[min_idx];\n                    dp[i][j][step] = dp[ni][nj][step - 1] + grid[i][j];\n                    paths[i][j][step] = paths[ni][nj][step - 1];\n                    paths[i][j][step].push_back(grid[i][j]);\n                }\n            }\n        }\n    }\n\n    // Find minimum path\n    std::vector<int> min_path;\n    int min_val = std::numeric_limits<int>::max();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n                min_path = paths[i][j][k];\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<int>> paths(N * N, std::vector<int>(k));\n    std::vector<int> min_path(k);\n    \n    // Parallel initialization of paths\n    for (int start_row = 0; start_row < N; start_row += 4) {\n        int32x4_t start_indices = vdupq_n_s32(start_row);\n        \n        for (int start_col = 0; start_col < N; start_col += 4) {\n            int32x4_t col_indices = vdupq_n_s32(start_col);\n            \n            // Parallel path generation using NEON\n            for (int path_idx = 0; path_idx < 4; path_idx++) {\n                int row = vgetq_lane_s32(start_indices, path_idx);\n                int col = vgetq_lane_s32(col_indices, path_idx);\n                \n                std::vector<int> current_path(k);\n                current_path[0] = grid[row][col];\n                \n                int curr_row = row, curr_col = col;\n                \n                // Path generation\n                for (int step = 1; step < k; step++) {\n                    int min_neighbor_val = INT_MAX;\n                    int next_row = curr_row, next_col = curr_col;\n                    \n                    // Check 4 neighbors using NEON\n                    int32x4_t dr = {-1, 1, 0, 0};\n                    int32x4_t dc = {0, 0, -1, 1};\n                    \n                    for (int n = 0; n < 4; n++) {\n                        int new_row = curr_row + vgetq_lane_s32(dr, n);\n                        int new_col = curr_col + vgetq_lane_s32(dc, n);\n                        \n                        if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                            if (grid[new_row][new_col] < min_neighbor_val) {\n                                min_neighbor_val = grid[new_row][new_col];\n                                next_row = new_row;\n                                next_col = new_col;\n                            }\n                        }\n                    }\n                    \n                    current_path[step] = grid[next_row][next_col];\n                    curr_row = next_row;\n                    curr_col = next_col;\n                }\n                \n                // Compare paths lexicographically\n                if (current_path < paths[start_row * N + start_col]) {\n                    paths[start_row * N + start_col] = current_path;\n                }\n            }\n        }\n    }\n    \n    // Find minimum path\n    min_path = paths[0];\n    for (const auto& path : paths) {\n        if (path < min_path) {\n            min_path = path;\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <limits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, std::numeric_limits<int>::max())));\n    std::vector<std::vector<std::vector<std::vector<int>>>> paths(N, std::vector<std::vector<std::vector<int>>>(N, std::vector<std::vector<int>>(k + 1)));\n\n    // Initialize first step for all cells\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    int dx[] = {-1, 1, 0, 0};\n    int dy[] = {0, 0, -1, 1};\n\n    // SIMD parallel path finding\n    for (int steps = 2; steps <= k; steps++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int32x4_t min_val_vec = vdupq_n_s32(std::numeric_limits<int>::max());\n                int32x4_t current_val_vec = vdupq_n_s32(grid[i][j]);\n                \n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    \n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        if (dp[ni][nj][steps-1] != std::numeric_limits<int>::max()) {\n                            int candidate_val = dp[ni][nj][steps-1];\n                            int32x4_t candidate_vec = vdupq_n_s32(candidate_val);\n                            \n                            // Compare and update min\n                            uint32x4_t compare_mask = vcltq_s32(candidate_vec, min_val_vec);\n                            min_val_vec = vbslq_s32(compare_mask, candidate_vec, min_val_vec);\n                        }\n                    }\n                }\n\n                // Scalar fallback for final comparison\n                int min_val = vgetq_lane_s32(min_val_vec, 0);\n                for (int lane = 1; lane < 4; lane++) {\n                    min_val = std::min(min_val, vgetq_lane_s32(min_val_vec, lane));\n                }\n\n                if (min_val != std::numeric_limits<int>::max()) {\n                    for (int d = 0; d < 4; d++) {\n                        int ni = i + dx[d];\n                        int nj = j + dy[d];\n                        \n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            if (dp[ni][nj][steps-1] == min_val) {\n                                std::vector<int> new_path = paths[ni][nj][steps-1];\n                                new_path.push_back(grid[i][j]);\n                                \n                                if (dp[i][j][steps] == std::numeric_limits<int>::max() || \n                                    new_path < paths[i][j][steps]) {\n                                    dp[i][j][steps] = min_val + grid[i][j];\n                                    paths[i][j][steps] = new_path;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Find minimum path\n    std::vector<int> min_path;\n    int min_total = std::numeric_limits<int>::max();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < min_total) {\n                min_total = dp[i][j][k];\n                min_path = paths[i][j][k];\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string for digit extraction\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad with zeros if needed to align to 16-byte vector\n    int padded_len = ((len + 15) / 16) * 16;\n    \n    // Initialize Neon vectors\n    uint8x16_t zero_vec = vdupq_n_u8(0);\n    uint8x16_t digit_vec = vld1q_u8((uint8_t*)digits);\n    \n    // Subtract ASCII offset to convert to actual digit values\n    uint8x16_t ascii_offset = vdupq_n_u8('0');\n    digit_vec = vsubq_u8(digit_vec, ascii_offset);\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vandq_u8(digit_vec, vdupq_n_u8(1));\n    odd_mask = vceqq_u8(odd_mask, vdupq_n_u8(1));\n    \n    // Select odd digits\n    uint8x16_t odd_digits = vandq_u8(digit_vec, odd_mask);\n    \n    // Horizontal multiply of odd digits\n    uint64_t product = 1;\n    for (int i = 0; i < len; i++) {\n        if (odd_digits[i] > 0) {\n            product *= odd_digits[i];\n        }\n    }\n    \n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string for digit extraction\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad to multiple of 16 for SIMD processing\n    int padded_len = ((len + 15) / 16) * 16;\n    \n    // Prepare SIMD vectors\n    uint8x16_t zero_vec = vdupq_n_u8(0);\n    uint8x16_t digit_vec = vld1q_u8((uint8_t*)digits);\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vceqq_u8(vandq_u8(digit_vec, vdupq_n_u8(1)), vdupq_n_u8(1));\n    \n    // Extract odd digits\n    uint8x16_t odd_digits = vandq_u8(digit_vec, odd_mask);\n    \n    // Convert ASCII digits to actual numeric values\n    uint8x16_t numeric_digits = vsubq_u8(odd_digits, vdupq_n_u8('0'));\n    \n    // Horizontal multiply of odd digits\n    uint64_t product = 1;\n    for (int i = 0; i < padded_len; i++) {\n        if (numeric_digits[i] > 0 && numeric_digits[i] <= 9) {\n            product *= numeric_digits[i];\n        }\n    }\n    \n    return (product == 1) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    // Convert number to string of digits\n    uint8_t digits[20] = {0};\n    int digit_count = 0;\n    while (n > 0) {\n        digits[digit_count++] = n % 10;\n        n /= 10;\n    }\n\n    // Process digits in parallel using Neon\n    uint64_t result = 1;\n    for (int i = 0; i < digit_count; i += 16) {\n        uint8x16_t digit_vec = vld1q_u8(digits + i);\n        uint8x16_t odd_mask = vandq_u8(digit_vec, vmovq_n_u8(1));\n        uint8x16_t is_odd = vceqq_u8(odd_mask, vmovq_n_u8(1));\n        \n        uint16x8_t low_half = vreinterpretq_u16_u8(vget_low_u8(is_odd));\n        uint16x8_t high_half = vreinterpretq_u16_u8(vget_high_u8(is_odd));\n        \n        uint16x8_t odd_digits_low = vmulq_u16(low_half, vld1q_u16((uint16_t*)(digits + i)));\n        uint16x8_t odd_digits_high = vmulq_u16(high_half, vld1q_u16((uint16_t*)(digits + i + 8)));\n        \n        uint32x4_t sum_low = vpaddlq_u16(odd_digits_low);\n        uint32x4_t sum_high = vpaddlq_u16(odd_digits_high);\n        \n        uint64x2_t total = vpaddlq_u32(sum_low);\n        total = vpadalq_u32(total, sum_high);\n        \n        result *= vgetq_lane_u64(total, 0) * vgetq_lane_u64(total, 1);\n    }\n\n    return result == 1 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string for digit extraction\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad to multiple of 16 bytes for NEON processing\n    int padded_len = ((len + 15) / 16) * 16;\n    \n    // Initialize NEON vectors\n    uint8x16_t zero_vec = vdupq_n_u8(0);\n    uint8x16_t digit_vec = vld1q_u8((uint8_t*)digits);\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vceqq_u8(vandq_u8(digit_vec, vdupq_n_u8(1)), vdupq_n_u8(1));\n    \n    // Extract odd digits\n    uint8x16_t odd_digits = vandq_u8(digit_vec, odd_mask);\n    \n    // Convert characters to actual digit values\n    uint8x16_t digit_values = vsubq_u8(odd_digits, vdupq_n_u8('0'));\n    \n    // Multiply odd digits\n    uint64_t product = 1;\n    for (int i = 0; i < padded_len; i++) {\n        if (digit_values[i] > 0 && digit_values[i] <= 9) {\n            product *= digit_values[i];\n        }\n    }\n    \n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad to multiple of 16 bytes\n    int padded_len = ((len + 15) / 16) * 16;\n    \n    // Load digits into Neon vector\n    uint8x16_t digit_vec = vdupq_n_u8(0);\n    for (int i = 0; i < len; i++) {\n        digit_vec = vsetq_lane_u8(digits[i] - '0', digit_vec, i);\n    }\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vandq_u8(digit_vec, vdupq_n_u8(1));\n    \n    // Compute product of odd digits\n    uint64_t product = 1;\n    for (int i = 0; i < len; i++) {\n        uint8_t digit = vgetq_lane_u8(digit_vec, i);\n        uint8_t is_odd = vgetq_lane_u8(odd_mask, i);\n        \n        if (is_odd) {\n            product *= digit;\n        }\n    }\n    \n    return (product == 1) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vector_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < vector_size; i += 4) {\n        // Load 4 float values\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n\n        // Round up to ceiling using vceilq_f32\n        float32x4_t ceil_vec = vceilq_f32(input_vec);\n\n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n\n        // Square the integers\n        int32x4_t squared_vec = vmulq_s32(int_vec, int_vec);\n\n        // Add to sum vector\n        sum_vec = vaddq_f32(sum_vec, vcvtq_f32_s32(squared_vec));\n    }\n\n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    sum_low = vpadd_f32(sum_low, sum_low);\n    result += (uint64_t)vget_lane_f32(sum_low, 0);\n\n    // Process remaining elements\n    for (size_t i = vector_size; i < n; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vector_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < vector_size; i += 4) {\n        // Load 4 float values\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Round up to ceiling using vceilq_f32 (requires ARMv8.6-A)\n        float32x4_t ceil_vec = vceilq_f32(input_vec);\n        \n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        \n        // Square the values\n        int32x4_t squared_vec = vmulq_s32(int_vec, int_vec);\n        \n        // Add to sum vector\n        sum_vec = vaddq_f32(sum_vec, vcvtq_f32_s32(squared_vec));\n    }\n\n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t sum_scalar = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    // Process remaining elements\n    for (size_t i = vector_size; i < n; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        sum_scalar += ceil_val * ceil_val;\n    }\n\n    return static_cast<uint64_t>(sum_scalar);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vec_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < vec_size; i += 4) {\n        // Load 4 float values\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Round up to ceiling using vceilq_f32 (requires ARMv8.6-A)\n        float32x4_t ceil_vec = vceilq_f32(input_vec);\n        \n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n        \n        // Square the integers\n        int32x4_t squared_vec = vmulq_s32(int_vec, int_vec);\n        \n        // Add to sum vector\n        sum_vec = vaddq_f32(sum_vec, vcvtq_f32_s32(squared_vec));\n    }\n\n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t lane_sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    // Process remaining elements\n    for (size_t i = vec_size; i < n; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        lane_sum += ceil_val * ceil_val;\n    }\n\n    return static_cast<uint64_t>(lane_sum);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vector_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < vector_size; i += 4) {\n        // Load 4 float values\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n\n        // Round up to ceiling using vceilq_f32\n        float32x4_t ceil_vec = vceilq_f32(input_vec);\n\n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n\n        // Square the values\n        int32x4_t squared_vec = vmulq_s32(int_vec, int_vec);\n\n        // Accumulate squared values\n        sum_vec = vaddq_f32(sum_vec, vcvtq_f32_s32(squared_vec));\n    }\n\n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t lane_sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    // Process remaining elements\n    for (size_t i = vector_size; i < n; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        lane_sum += ceil_val * ceil_val;\n    }\n\n    return static_cast<uint64_t>(lane_sum);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vector_size = n - (n % 4);\n\n    // Process 4 elements at a time using Neon\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < vector_size; i += 4) {\n        // Load 4 float values\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n\n        // Round up to ceiling using vceilq_f32\n        float32x4_t ceil_vec = vceilq_f32(input_vec);\n\n        // Convert to integers\n        int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n\n        // Square the integers\n        int32x4_t squared_vec = vmulq_s32(int_vec, int_vec);\n\n        // Add to sum vector\n        sum_vec = vaddq_f32(sum_vec, vcvtq_f32_s32(squared_vec));\n    }\n\n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t sum_scalar = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    result += static_cast<uint64_t>(sum_scalar);\n\n    // Process remaining elements\n    for (size_t i = vector_size; i < n; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n - 1; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n\n        // Compare if current elements are less than next elements\n        uint32x4_t compare_mask = vcgeq_s32(current, next);\n        \n        // Check if any element violates the condition\n        if (vgetq_lane_u32(compare_mask, 0) || \n            vgetq_lane_u32(compare_mask, 1) || \n            vgetq_lane_u32(compare_mask, 2) || \n            vgetq_lane_u32(compare_mask, 3)) {\n            // Find exact index\n            for (int j = i; j < i + 4; j++) {\n                if (arr[j] >= arr[j+1]) {\n                    return j;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n - 1; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        // Compare if current is not less than next\n        uint32x4_t comparison = vcgeq_s32(current, next);\n        \n        // Check if any element satisfies the condition\n        if (vgetq_lane_u32(comparison, 0) || \n            vgetq_lane_u32(comparison, 1) || \n            vgetq_lane_u32(comparison, 2) || \n            vgetq_lane_u32(comparison, 3)) {\n            // Find the specific index\n            for (int j = 0; j < 4; j++) {\n                if (arr[i+j] >= arr[i+j+1]) {\n                    return i + j;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n - 1; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n\n        // Compare if current is not less than next\n        uint32x4_t comparison = vcgeq_s32(current, next);\n        \n        // Check if any element satisfies the condition\n        uint64x2_t reduced = vpaddlq_u32(comparison);\n        uint64_t result = vgetq_lane_u64(reduced, 0) | vgetq_lane_u64(reduced, 1);\n\n        if (result) {\n            // Find exact index\n            for (int j = i; j < i + 4; j++) {\n                if (arr[j] >= arr[j+1]) {\n                    return j;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n - 1; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        // Compare if current is not less than next\n        uint32x4_t comparison = vcgeq_s32(current, next);\n        \n        // Check if any element satisfies the condition\n        if (vgetq_lane_u32(comparison, 0) || \n            vgetq_lane_u32(comparison, 1) || \n            vgetq_lane_u32(comparison, 2) || \n            vgetq_lane_u32(comparison, 3)) {\n            // Find the exact index\n            for (int j = 0; j < 4; j++) {\n                if (arr[i+j] >= arr[i+j+1]) {\n                    return i + j;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Process 4 elements at a time using Neon\n    int i = 0;\n    for (; i + 4 <= n - 1; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        // Compare if current elements are not less than next elements\n        uint32x4_t comparison = vcgeq_s32(current, next);\n        \n        // Check if any comparison is true\n        if (vgetq_lane_u32(comparison, 0) || \n            vgetq_lane_u32(comparison, 1) || \n            vgetq_lane_u32(comparison, 2) || \n            vgetq_lane_u32(comparison, 3)) {\n            // Find exact index\n            for (int j = i; j < i + 4; j++) {\n                if (arr[j] >= arr[j+1]) {\n                    return j;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Find max negative\n        int32x4_t is_neg = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_neg = vandq_s32(vec, is_neg);\n        max_neg = vmaxq_s32(max_neg, masked_neg);\n        \n        // Find min positive\n        int32x4_t is_pos = vcgtq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_pos = vandq_s32(vec, is_pos);\n        min_pos = vminq_s32(min_pos, masked_pos);\n    }\n\n    // Horizontal max/min for negative and positive\n    int max_neg_scalar = vgetq_lane_s32(max_neg, 0);\n    max_neg_scalar = std::max(max_neg_scalar, vgetq_lane_s32(max_neg, 1));\n    max_neg_scalar = std::max(max_neg_scalar, vgetq_lane_s32(max_neg, 2));\n    max_neg_scalar = std::max(max_neg_scalar, vgetq_lane_s32(max_neg, 3));\n\n    int min_pos_scalar = vgetq_lane_s32(min_pos, 0);\n    min_pos_scalar = std::min(min_pos_scalar, vgetq_lane_s32(min_pos, 1));\n    min_pos_scalar = std::min(min_pos_scalar, vgetq_lane_s32(min_pos, 2));\n    min_pos_scalar = std::min(min_pos_scalar, vgetq_lane_s32(min_pos, 3));\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = std::max(max_neg_scalar, lst[i]);\n        }\n        if (lst[i] > 0) {\n            min_pos_scalar = std::min(min_pos_scalar, lst[i]);\n        }\n    }\n\n    // Adjust if no negative or positive found\n    if (max_neg_scalar == INT32_MIN) max_neg_scalar = 0;\n    if (min_pos_scalar == INT32_MAX) min_pos_scalar = 0;\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Find max negative\n        int32x4_t is_neg = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_neg = vandq_s32(vec, is_neg);\n        max_neg = vmaxq_s32(max_neg, masked_neg);\n        \n        // Find min positive\n        int32x4_t is_pos = vcgtq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_pos = vandq_s32(vec, is_pos);\n        min_pos = vminq_s32(min_pos, vbslq_s32(is_pos, masked_pos, vdupq_n_s32(INT32_MAX)));\n    }\n\n    // Handle remaining elements\n    int max_neg_scalar = INT32_MIN;\n    int min_pos_scalar = INT32_MAX;\n    \n    for (int32_t val : std::vector<int>(lst.begin() + i, lst.end())) {\n        if (val < 0 && val > max_neg_scalar) {\n            max_neg_scalar = val;\n        }\n        if (val > 0 && val < min_pos_scalar) {\n            min_pos_scalar = val;\n        }\n    }\n\n    // Reduce SIMD vectors\n    int32_t max_neg_arr[4], min_pos_arr[4];\n    vst1q_s32(max_neg_arr, max_neg);\n    vst1q_s32(min_pos_arr, min_pos);\n\n    for (int j = 0; j < 4; j++) {\n        if (max_neg_arr[j] > max_neg_scalar && max_neg_arr[j] < 0) {\n            max_neg_scalar = max_neg_arr[j];\n        }\n        if (min_pos_arr[j] < min_pos_scalar && min_pos_arr[j] > 0) {\n            min_pos_scalar = min_pos_arr[j];\n        }\n    }\n\n    max_neg_scalar = (max_neg_scalar == INT32_MIN) ? 0 : max_neg_scalar;\n    min_pos_scalar = (min_pos_scalar == INT32_MAX) ? 0 : min_pos_scalar;\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Find max negative\n        int32x4_t is_neg = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_neg = vandq_s32(vec, is_neg);\n        max_neg = vmaxq_s32(max_neg, masked_neg);\n        \n        // Find min positive\n        int32x4_t is_pos = vcgtq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_pos = vandq_s32(vec, is_pos);\n        min_pos = vminq_s32(min_pos, masked_pos);\n    }\n\n    // Horizontal max and min\n    int max_neg_scalar = vgetq_lane_s32(max_neg, 0);\n    max_neg_scalar = std::max(max_neg_scalar, vgetq_lane_s32(max_neg, 1));\n    max_neg_scalar = std::max(max_neg_scalar, vgetq_lane_s32(max_neg, 2));\n    max_neg_scalar = std::max(max_neg_scalar, vgetq_lane_s32(max_neg, 3));\n\n    int min_pos_scalar = vgetq_lane_s32(min_pos, 0);\n    min_pos_scalar = std::min(min_pos_scalar, vgetq_lane_s32(min_pos, 1));\n    min_pos_scalar = std::min(min_pos_scalar, vgetq_lane_s32(min_pos, 2));\n    min_pos_scalar = std::min(min_pos_scalar, vgetq_lane_s32(min_pos, 3));\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_neg_scalar = std::max(max_neg_scalar, lst[i]);\n        }\n        if (lst[i] > 0) {\n            min_pos_scalar = std::min(min_pos_scalar, lst[i]);\n        }\n    }\n\n    // Check if no negative or positive integers found\n    if (max_neg_scalar == INT32_MIN) max_neg_scalar = 0;\n    if (min_pos_scalar == INT32_MAX) min_pos_scalar = 0;\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Find max negative\n        int32x4_t is_neg = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_neg = vandq_s32(vec, is_neg);\n        max_neg = vmaxq_s32(max_neg, masked_neg);\n        \n        // Find min positive\n        int32x4_t is_pos = vcgtq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_pos = vandq_s32(vec, is_pos);\n        min_pos = vminq_s32(min_pos, masked_pos);\n    }\n\n    // Horizontal max/min for negative and positive\n    int32x2_t max_neg_low = vmax_s32(vget_low_s32(max_neg), vget_high_s32(max_neg));\n    int32x2_t min_pos_low = vmin_s32(vget_low_s32(min_pos), vget_high_s32(min_pos));\n    \n    int max_negative = vget_lane_s32(max_neg_low, 0);\n    int min_positive = vget_lane_s32(min_pos_low, 0);\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_negative = std::max(max_negative, lst[i]);\n        }\n        if (lst[i] > 0) {\n            min_positive = std::min(min_positive, lst[i]);\n        }\n    }\n\n    // Adjust if no negative or positive found\n    max_negative = (max_negative == INT32_MIN) ? 0 : max_negative;\n    min_positive = (min_positive == INT32_MAX) ? 0 : min_positive;\n\n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(INT32_MIN);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Find max negative\n        int32x4_t is_neg = vcltq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_neg = vandq_s32(vec, is_neg);\n        max_neg = vmaxq_s32(max_neg, masked_neg);\n        \n        // Find min positive\n        int32x4_t is_pos = vcgtq_s32(vec, vdupq_n_s32(0));\n        int32x4_t masked_pos = vandq_s32(vec, is_pos);\n        min_pos = vminq_s32(min_pos, masked_pos);\n    }\n\n    // Horizontal reduction\n    int max_neg_scalar = vmaxvq_s32(max_neg);\n    int min_pos_scalar = vminvq_s32(min_pos);\n\n    // Handle remaining elements\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > max_neg_scalar) {\n            max_neg_scalar = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < min_pos_scalar) {\n            min_pos_scalar = lst[i];\n        }\n    }\n\n    // Adjust if no negative or positive found\n    max_neg_scalar = (max_neg_scalar == INT32_MIN) ? 0 : max_neg_scalar;\n    min_pos_scalar = (min_pos_scalar == INT32_MAX) ? 0 : min_pos_scalar;\n\n    return {max_neg_scalar, min_pos_scalar};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Precompute factorials up to n\n    uint64_t factorials[n+1];\n    factorials[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorials[i] = factorials[i-1] * i;\n    }\n\n    // Use NEON for parallel multiplication\n    uint64x2_t result_vec = vdupq_n_u64(1);\n    for (int i = 0; i <= n; i += 2) {\n        uint64x2_t fact_vec = {factorials[i], i+1 <= n ? factorials[i+1] : 1};\n        result_vec = vmulq_u64(result_vec, fact_vec);\n    }\n\n    // Horizontal reduction\n    uint64_t result = vgetq_lane_u64(result_vec, 0) * vgetq_lane_u64(result_vec, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Precompute factorials up to n\n    uint64_t factorials[n+1];\n    factorials[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorials[i] = factorials[i-1] * i;\n    }\n\n    // Use Neon to parallelize multiplication\n    uint64x2_t result_vec = vdupq_n_u64(1);\n    for (int i = 0; i <= n; i += 2) {\n        uint64x2_t fact_vec = {factorials[i], i+1 <= n ? factorials[i+1] : 1};\n        result_vec = vmulq_u64(result_vec, fact_vec);\n    }\n\n    // Horizontal multiply to get final result\n    uint64_t result = vgetq_lane_u64(result_vec, 0) * vgetq_lane_u64(result_vec, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Precompute factorials up to n\n    uint64_t factorials[n+1];\n    factorials[0] = 1;\n    \n    // Compute factorials using SIMD\n    for (int i = 1; i <= n; i += 4) {\n        uint64x2_t fact_vec1 = vdupq_n_u64(1);\n        uint64x2_t fact_vec2 = vdupq_n_u64(1);\n        \n        for (int j = 1; j <= i; ++j) {\n            fact_vec1 = vmulq_u64(fact_vec1, vdupq_n_u64(j));\n            fact_vec2 = vmulq_u64(fact_vec2, vdupq_n_u64(j+2));\n        }\n        \n        vst1q_u64(&factorials[i], fact_vec1);\n        if (i+2 <= n) {\n            vst1q_u64(&factorials[i+2], fact_vec2);\n        }\n    }\n    \n    // Compute Brazilian factorial by multiplying all precomputed factorials\n    uint64_t result = 1;\n    for (int i = 1; i <= n; ++i) {\n        result *= factorials[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Precompute factorials up to n\n    uint64_t factorials[n+1];\n    factorials[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorials[i] = factorials[i-1] * i;\n    }\n\n    // Use NEON for parallel multiplication\n    uint64x2_t result_vec = vdupq_n_u64(1);\n    for (int i = 0; i <= n; i += 2) {\n        uint64x2_t fact_vec = {factorials[i], i+1 <= n ? factorials[i+1] : 1};\n        result_vec = vmulq_u64(result_vec, fact_vec);\n    }\n\n    // Horizontal sum of vector\n    uint64_t result = vgetq_lane_u64(result_vec, 0) * vgetq_lane_u64(result_vec, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Precompute factorials up to n\n    uint64_t factorials[n+1];\n    factorials[0] = 1;\n    for (int i = 1; i <= n; i++) {\n        factorials[i] = factorials[i-1] * i;\n    }\n\n    // Use Neon to parallelize multiplication\n    uint64x2_t result_vec = vdupq_n_u64(1);\n    for (int i = 0; i <= n; i += 2) {\n        uint64x2_t fact_vec = {factorials[i], i+1 <= n ? factorials[i+1] : 1};\n        result_vec = vmulq_u64(result_vec, fact_vec);\n    }\n\n    // Horizontal reduction\n    uint64_t result = vgetq_lane_u64(result_vec, 0) * vgetq_lane_u64(result_vec, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t modified_vec = vec;\n        \n        // Square elements at indices multiple of 3\n        int32x4_t mask_3 = {(i % 3 == 0), ((i+1) % 3 == 0), ((i+2) % 3 == 0), ((i+3) % 3 == 0)};\n        int32x4_t squared_vec = vmulq_s32(vec, vec);\n        modified_vec = vbslq_s32(mask_3, squared_vec, modified_vec);\n        \n        // Cube elements at indices multiple of 4 but not 3\n        int32x4_t mask_4 = {(i % 4 == 0 && i % 3 != 0), \n                             ((i+1) % 4 == 0 && (i+1) % 3 != 0), \n                             ((i+2) % 4 == 0 && (i+2) % 3 != 0), \n                             ((i+3) % 4 == 0 && (i+3) % 3 != 0)};\n        int32x4_t cubed_vec = vmulq_s32(vmulq_s32(vec, vec), vec);\n        modified_vec = vbslq_s32(mask_4, cubed_vec, modified_vec);\n        \n        sum_vec = vaddq_s32(sum_vec, modified_vec);\n    }\n    \n    // Horizontal sum of SIMD vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Process 4 elements at a time using NEON\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t modified_vec = vec;\n        \n        // Square elements at indices multiple of 3\n        int32x4_t mask_3 = {(i % 3 == 0), ((i+1) % 3 == 0), ((i+2) % 3 == 0), ((i+3) % 3 == 0)};\n        int32x4_t squared_vec = vmulq_s32(vec, vec);\n        modified_vec = vbslq_s32(mask_3, squared_vec, modified_vec);\n        \n        // Cube elements at indices multiple of 4 but not 3\n        int32x4_t mask_4 = {(i % 4 == 0 && i % 3 != 0), \n                            ((i+1) % 4 == 0 && (i+1) % 3 != 0), \n                            ((i+2) % 4 == 0 && (i+2) % 3 != 0), \n                            ((i+3) % 4 == 0 && (i+3) % 3 != 0)};\n        int32x4_t cubed_vec = vmulq_s32(vmulq_s32(vec, vec), vec);\n        modified_vec = vbslq_s32(mask_4, cubed_vec, modified_vec);\n        \n        sum_vec = vaddq_s32(sum_vec, modified_vec);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        int32x4_t modified_data = data;\n        \n        // Square elements at indices multiple of 3\n        int32x4_t mask_3 = {(i % 3 == 0), ((i+1) % 3 == 0), ((i+2) % 3 == 0), ((i+3) % 3 == 0)};\n        int32x4_t squared_data = vmulq_s32(data, data);\n        modified_data = vbslq_s32(mask_3, squared_data, modified_data);\n        \n        // Cube elements at indices multiple of 4 but not 3\n        int32x4_t mask_4 = {(i % 4 == 0 && i % 3 != 0), \n                            ((i+1) % 4 == 0 && (i+1) % 3 != 0), \n                            ((i+2) % 4 == 0 && (i+2) % 3 != 0), \n                            ((i+3) % 4 == 0 && (i+3) % 3 != 0)};\n        int32x4_t cubed_data = vmulq_s32(vmulq_s32(data, data), data);\n        modified_data = vbslq_s32(mask_4, cubed_data, modified_data);\n        \n        sum_vec = vaddq_s32(sum_vec, modified_data);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t modified_vec = vec;\n        \n        // Square elements at indices multiple of 3\n        int32x4_t mask_3 = {(i % 3 == 0), ((i+1) % 3 == 0), ((i+2) % 3 == 0), ((i+3) % 3 == 0)};\n        int32x4_t squared_vec = vmulq_s32(vec, vec);\n        modified_vec = vbslq_s32(mask_3, squared_vec, modified_vec);\n        \n        // Cube elements at indices multiple of 4 (not multiple of 3)\n        int32x4_t mask_4 = {(i % 4 == 0 && i % 3 != 0), \n                             ((i+1) % 4 == 0 && (i+1) % 3 != 0), \n                             ((i+2) % 4 == 0 && (i+2) % 3 != 0), \n                             ((i+3) % 4 == 0 && (i+3) % 3 != 0)};\n        int32x4_t cubed_vec = vmulq_s32(vmulq_s32(vec, vec), vec);\n        modified_vec = vbslq_s32(mask_4, cubed_vec, modified_vec);\n        \n        sum_vec = vaddq_s32(sum_vec, modified_vec);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Process 4 elements at a time using NEON\n    int vector_size = size - (size % 4);\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vector_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t modified_vec = vec;\n        \n        // Create mask for indices divisible by 3\n        uint32x4_t div_3_mask = vcgeq_u32(vcvtq_u32_s32(vdupq_n_s32(i)), vcvtq_u32_s32(vsetq_lane_s32(0, vdupq_n_s32(3), 0)));\n        div_3_mask = vandq_u32(div_3_mask, vcltq_u32(vcvtq_u32_s32(vdupq_n_s32(i)), vcvtq_u32_s32(vdupq_n_s32(size))));\n        \n        // Create mask for indices divisible by 4\n        uint32x4_t div_4_mask = vcgeq_u32(vcvtq_u32_s32(vdupq_n_s32(i)), vcvtq_u32_s32(vsetq_lane_s32(0, vdupq_n_s32(4), 0)));\n        div_4_mask = vandq_u32(div_4_mask, vcltq_u32(vcvtq_u32_s32(vdupq_n_s32(i)), vcvtq_u32_s32(vdupq_n_s32(size))));\n        \n        // Square elements divisible by 3\n        int32x4_t squared_vec = vmulq_s32(vec, vec);\n        modified_vec = vbslq_s32(div_3_mask, squared_vec, modified_vec);\n        \n        // Cube elements divisible by 4 but not 3\n        uint32x4_t not_div_3_mask = vmvnq_u32(div_3_mask);\n        uint32x4_t div_4_not_div_3_mask = vandq_u32(div_4_mask, not_div_3_mask);\n        int32x4_t cubed_vec = vmulq_s32(vmulq_s32(vec, vec), vec);\n        modified_vec = vbslq_s32(div_4_not_div_3_mask, cubed_vec, modified_vec);\n        \n        sum_vec = vaddq_s32(sum_vec, modified_vec);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_low = vget_low_s32(sum_vec);\n    int32x2_t sum_high = vget_high_s32(sum_vec);\n    sum_low = vadd_s32(sum_low, sum_high);\n    sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    \n    // Process remaining elements\n    for (int i = vector_size; i < size; i++) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val *= val;\n        } else if (i % 4 == 0) {\n            val *= val * val;\n        }\n        sum += val;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // SIMD processing for 4 elements at a time\n    for (size_t i = 0; i < simd_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        \n        // Check values > 10\n        int32x4_t gt_10_mask = vcgtq_s32(vec, vdupq_n_s32(10));\n        \n        // First digit check (absolute value)\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digit_vec = vdupq_n_s32(0);\n        \n        while (vgetq_lane_s32(abs_vec, 0) > 0) {\n            first_digit_vec = vsetq_lane_s32(vgetq_lane_s32(abs_vec, 0) % 10, first_digit_vec, 0);\n            abs_vec = vsetq_lane_s32(vgetq_lane_s32(abs_vec, 0) / 10, abs_vec, 0);\n        }\n        \n        int32x4_t first_digit_odd_mask = vceqq_s32(vmodq_s32(first_digit_vec, vdupq_n_s32(2)), vdupq_n_s32(1));\n        \n        // Last digit check\n        int32x4_t last_digit_vec = vmodq_s32(vec, vdupq_n_s32(10));\n        int32x4_t last_digit_odd_mask = vceqq_s32(vmodq_s32(last_digit_vec, vdupq_n_s32(2)), vdupq_n_s32(1));\n        \n        // Combine masks\n        int32x4_t combined_mask = vandq_s32(gt_10_mask, \n                                            vandq_s32(first_digit_odd_mask, last_digit_odd_mask));\n        \n        // Count matching elements\n        count += vaddvq_s32(combined_mask);\n    }\n    \n    // Process remaining elements sequentially\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        if (nums[i] > 10) {\n            int abs_num = std::abs(nums[i]);\n            int first_digit = 0;\n            while (abs_num > 0) {\n                first_digit = abs_num % 10;\n                abs_num /= 10;\n            }\n            \n            if (first_digit % 2 == 1 && std::abs(nums[i]) % 10 % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < simd_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Check if elements are greater than 10\n        int32x4_t gt_10_mask = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract first and last digits\n        int32x4_t first_digit_vec = vabsq_s32(vec);\n        int32x4_t last_digit_vec = vabsq_s32(vec);\n\n        while (vgetq_lane_s32(first_digit_vec, 0) >= 10) first_digit_vec = vdivq_s32(first_digit_vec, vdupq_n_s32(10));\n        while (vgetq_lane_s32(last_digit_vec, 0) >= 10) last_digit_vec = vmodq_s32(last_digit_vec, vdupq_n_s32(10));\n\n        // Check if first and last digits are odd\n        int32x4_t first_digit_odd_mask = vceqq_s32(vmodq_s32(first_digit_vec, vdupq_n_s32(2)), vdupq_n_s32(1));\n        int32x4_t last_digit_odd_mask = vceqq_s32(vmodq_s32(last_digit_vec, vdupq_n_s32(2)), vdupq_n_s32(1));\n\n        // Combine masks\n        int32x4_t combined_mask = vandq_s32(gt_10_mask, first_digit_odd_mask);\n        combined_mask = vandq_s32(combined_mask, last_digit_odd_mask);\n\n        // Count elements satisfying conditions\n        count += vaddvq_s32(combined_mask);\n    }\n\n    // Process remaining elements sequentially\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        if (nums[i] > 10) {\n            int abs_num = std::abs(nums[i]);\n            int first_digit = abs_num;\n            while (first_digit >= 10) first_digit /= 10;\n            int last_digit = abs_num % 10;\n\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // SIMD processing for 4 elements at a time\n    for (size_t i = 0; i < simd_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Check values > 10\n        int32x4_t gt_10_mask = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // First digit check (absolute value)\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digit_vec = vdupq_n_s32(0);\n        \n        while (vgetq_lane_s32(abs_vec, 0) > 9) abs_vec = vdupq_n_s32(vgetq_lane_s32(abs_vec, 0) / 10);\n        first_digit_vec = abs_vec;\n\n        // First digit odd check\n        int32x4_t first_digit_odd_mask = vandq_s32(first_digit_vec, vdupq_n_s32(1));\n        first_digit_odd_mask = vceqq_s32(first_digit_odd_mask, vdupq_n_s32(1));\n\n        // Last digit check\n        int32x4_t last_digit_vec = vandq_s32(vec, vdupq_n_s32(1));\n        int32x4_t last_digit_odd_mask = vceqq_s32(last_digit_vec, vdupq_n_s32(1));\n\n        // Combine all conditions\n        int32x4_t final_mask = vandq_s32(gt_10_mask, first_digit_odd_mask);\n        final_mask = vandq_s32(final_mask, last_digit_odd_mask);\n\n        // Count matching elements\n        count += vaddvq_s32(final_mask);\n    }\n\n    // Process remaining elements sequentially\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        int num = nums[i];\n        int abs_num = std::abs(num);\n        int first_digit = abs_num;\n        while (first_digit > 9) first_digit /= 10;\n\n        if (num > 10 && first_digit % 2 == 1 && num % 2 == 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // Process 4 elements at a time using Neon SIMD\n    for (size_t i = 0; i < simd_size; i += 4) {\n        // Load 4 integers into Neon register\n        int32x4_t vec_nums = vld1q_s32(&nums[i]);\n\n        // Compare elements > 10\n        int32x4_t gt_10_mask = vcgtq_s32(vec_nums, vdupq_n_s32(10));\n\n        // Check first and last digit odd\n        int32x4_t first_digit_odd_mask = vceqq_s32(vandq_s32(vabsq_s32(vec_nums), vdupq_n_s32(1)), vdupq_n_s32(1));\n        int32x4_t last_digit_odd_mask = vceqq_s32(vandq_s32(vabsq_s32(vec_nums), vdupq_n_s32(10)), vdupq_n_s32(10));\n\n        // Combine masks\n        int32x4_t combined_mask = vandq_s32(gt_10_mask, first_digit_odd_mask);\n        combined_mask = vandq_s32(combined_mask, last_digit_odd_mask);\n\n        // Count matching elements\n        uint32x4_t result = vreinterpretq_u32_s32(combined_mask);\n        count += vaddvq_u32(result);\n    }\n\n    // Process remaining elements sequentially\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        if (nums[i] > 10 && \n            abs(nums[i]) % 10 % 2 == 1 && \n            abs(nums[i]) / pow(10, floor(log10(abs(nums[i])))) % 2 == 1) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // Process 4 elements at a time using Neon\n    for (size_t i = 0; i < simd_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Check values > 10\n        int32x4_t gt_10_mask = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract first and last digits\n        int32x4_t first_digit_vec = vabsq_s32(vec);\n        int32x4_t last_digit_vec = vabsq_s32(vec);\n\n        while (vgetq_lane_s32(first_digit_vec, 0) >= 10) \n            first_digit_vec = vdivq_n_s32(first_digit_vec, 10);\n        while (vgetq_lane_s32(last_digit_vec, 0) >= 10) \n            last_digit_vec = vmodq_n_s32(last_digit_vec, 10);\n\n        // Check first and last digits are odd\n        int32x4_t first_odd_mask = vceqq_s32(vmodq_n_s32(first_digit_vec, 2), vdupq_n_s32(1));\n        int32x4_t last_odd_mask = vceqq_s32(vmodq_n_s32(last_digit_vec, 2), vdupq_n_s32(1));\n\n        // Combine masks\n        int32x4_t final_mask = vandq_s32(gt_10_mask, first_odd_mask);\n        final_mask = vandq_s32(final_mask, last_odd_mask);\n\n        // Count matching elements\n        count += vaddvq_s32(final_mask);\n    }\n\n    // Process remaining elements sequentially\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        int num = std::abs(nums[i]);\n        int first_digit = num;\n        int last_digit = num % 10;\n\n        while (first_digit >= 10) \n            first_digit /= 10;\n\n        if (nums[i] > 10 && first_digit % 2 == 1 && last_digit % 2 == 1)\n            ++count;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate vector to store the sequence\n    std::vector<uint64_t> a(n);\n    \n    // Use Neon SIMD to compute the sequence in parallel\n    const int VECTOR_WIDTH = 4;\n    for (int i = 0; i < n; i += VECTOR_WIDTH) {\n        uint64x2_t indices = {i, i+1};\n        uint64x2_t indices2 = {i+2, i+3};\n        \n        // Compute i*i - i + 1 using SIMD\n        uint64x2_t squared1 = vmulq_u64(indices, indices);\n        uint64x2_t squared2 = vmulq_u64(indices2, indices2);\n        \n        uint64x2_t result1 = vsubq_u64(squared1, indices);\n        uint64x2_t result2 = vsubq_u64(squared2, indices2);\n        \n        result1 = vaddq_u64(result1, vdupq_n_u64(1));\n        result2 = vaddq_u64(result2, vdupq_n_u64(1));\n        \n        // Store results back to vector\n        vst1q_u64(&a[i], result1);\n        if (i+2 < n) vst1q_u64(&a[i+2], result2);\n    }\n    \n    // Count triples divisible by 3\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Precompute the vector a\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = (i + 1) * (i + 1) - (i + 1) + 1;\n    }\n\n    uint64_t count = 0;\n    const int VECTOR_WIDTH = 2; // Using 64-bit Neon vectors\n\n    // Vectorized triple counting\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            // Use Neon to load and process k values\n            for (uint64_t k_start = j + 1; k_start < n; k_start += VECTOR_WIDTH) {\n                uint64x2_t sum_vec = vdupq_n_u64(a[i] + a[j]);\n                uint64x2_t k_vec = {k_start, k_start + 1};\n                uint64x2_t a_k_vec = {a[k_start], a[k_start + 1]};\n                \n                uint64x2_t total_sum_vec = vaddq_u64(sum_vec, a_k_vec);\n                \n                // Check divisibility by 3\n                uint64x2_t div_check = {\n                    (total_sum_vec[0] % 3 == 0),\n                    (total_sum_vec[1] % 3 == 0)\n                };\n                \n                count += div_check[0] + div_check[1];\n            }\n            \n            // Handle remaining elements\n            for (uint64_t k = (n / VECTOR_WIDTH) * VECTOR_WIDTH; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Precompute the vector a using Neon intrinsics\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Use Neon intrinsics for vector computation\n    for (uint64_t i = 0; i < n; i += 2) {\n        uint64x2_t indices = {i, i+1};\n        uint64x2_t squares = vmulq_u64(indices, indices);\n        uint64x2_t result = vsubq_u64(squares, indices);\n        result = vaddq_u64(result, vdupq_n_u64(1));\n        \n        vst1q_u64(a + i, result);\n    }\n    \n    // Handle remaining elements if n is odd\n    if (n % 2 != 0) {\n        a[n-1] = (n-1) * (n-1) - (n-1) + 1;\n    }\n    \n    uint64_t triples_count = 0;\n    \n    // Parallel triple counting using nested loops\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            // Use Neon intrinsics for vectorized comparison\n            uint64x2_t sum_vec = vdupq_n_u64(a[i] + a[j]);\n            \n            for (uint64_t k = j + 1; k < n; k++) {\n                uint64x2_t k_vec = {a[k], 0};\n                uint64x2_t total_sum = vaddq_u64(sum_vec, k_vec);\n                \n                // Check divisibility by 3\n                uint64x2_t div_check = vdupq_n_u64(3);\n                uint64x2_t mod_result = vmodq_u64(total_sum, div_check);\n                \n                if (mod_result[0] == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n    \n    free(a);\n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate vector to store a\n    std::vector<uint64_t> a(n);\n    \n    // Compute a vector using NEON intrinsics\n    uint64_t* ptr = a.data();\n    uint64x2_t indices = {0, 1};\n    uint64x2_t increment = {2, 2};\n    \n    for (uint64_t i = 0; i < n; i += 2) {\n        uint64x2_t current_indices = vaddq_u64(indices, vmovq_n_u64(i));\n        uint64x2_t values = vsubq_u64(vmulq_u64(current_indices, current_indices), current_indices);\n        values = vaddq_u64(values, vmovq_n_u64(1));\n        \n        vst1q_u64(ptr + i, values);\n        indices = vaddq_u64(indices, increment);\n    }\n    \n    // Handle remaining elements if n is odd\n    if (n % 2 != 0) {\n        a[n-1] = (n-1) * (n-1) - (n-1) + 1;\n    }\n    \n    // Count triples\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate vector to store sequence\n    std::vector<uint64_t> a(n);\n    \n    // Use Neon to compute sequence in parallel\n    uint64_t* ptr = a.data();\n    uint64x2_t indices = {1, 2};\n    uint64x2_t increment = {2, 2};\n    \n    for (uint64_t i = 0; i < n; i += 2) {\n        uint64x2_t current_indices = indices;\n        uint64x2_t squared = vmulq_u64(current_indices, current_indices);\n        uint64x2_t subtracted = vsubq_u64(squared, current_indices);\n        uint64x2_t result = vaddq_u64(subtracted, vdupq_n_u64(1));\n        \n        vst1q_u64(ptr + i, result);\n        indices = vaddq_u64(indices, increment);\n    }\n    \n    // Handle remaining elements if n is odd\n    if (n % 2 != 0) {\n        a[n-1] = n * n - n + 1;\n    }\n    \n    // Count triples divisible by 3\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check primality using Neon SIMD instructions\n    if (n <= 1) return y;\n    \n    // Optimization for small primes\n    if (n == 2 || n == 3) return x;\n    \n    // Skip even numbers\n    if (n % 2 == 0) return y;\n    \n    // SIMD-based primality test\n    int32x4_t divisors = {2, 3, 5, 7};\n    int32x4_t limit_vec = vdupq_n_s32(sqrt(n));\n    \n    for (int i = 0; i < 4; i++) {\n        int32x4_t current_div = vdupq_n_s32(divisors[i]);\n        int32x4_t mod_result = vmodq_s32(vdupq_n_s32(n), current_div);\n        \n        // If any division results in zero remainder, not prime\n        if (vminvq_s32(mod_result) == 0) return y;\n        \n        // Break if divisors exceed sqrt(n)\n        if (vcgeq_s32(current_div, limit_vec)[0]) break;\n    }\n    \n    // If no divisors found, it's prime\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check primality using SIMD-like approach\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n\n    // SIMD optimization for primality check\n    int32x4_t divisors = {2, 3, 5, 7};\n    int32x4_t limit_vec = vdupq_n_s32((int)sqrt(n));\n    \n    for (int i = 0; i < 4; i++) {\n        int32x4_t current_div = vdupq_n_s32(divisors[i]);\n        int32x4_t compare = vcgtq_s32(current_div, limit_vec);\n        \n        if (n % divisors[i] == 0) return y;\n    }\n\n    // Additional divisor checks\n    for (int i = 11; i * i <= n; i += 2) {\n        if (n % i == 0) return y;\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SIMD-like approach\n    if (n <= 1) return y;\n    \n    // Optimization for small primes\n    if (n == 2 || n == 3) return x;\n    \n    // Skip even numbers\n    if (n % 2 == 0) return y;\n    \n    // SIMD-like prime check\n    int32x4_t divisors = {2, 3, 5, 7};\n    int32x4_t max_div = vdupq_n_s32((int)sqrt(n));\n    \n    for (int i = 0; i < 4; i++) {\n        int32x4_t current_div = vdupq_n_s32(divisors[i]);\n        \n        // If divisor is greater than sqrt(n), break\n        uint32x4_t cmp = vcgtq_s32(current_div, max_div);\n        if (vgetq_lane_u32(cmp, 0)) break;\n        \n        // Check divisibility\n        if (n % divisors[i] == 0) return y;\n    }\n    \n    // Additional divisibility check for remaining divisors\n    for (int div = 11; div * div <= n; div += 2) {\n        if (n % div == 0) return y;\n    }\n    \n    // If no divisors found, n is prime\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using Neon SIMD operations\n    if (n <= 1) return y;\n    \n    // Vectorized primality check\n    int32x4_t divisors = {2, 3, 5, 7};\n    int32x4_t n_vec = vdupq_n_s32(n);\n    uint32x4_t is_divisible = vceqq_s32(vmovq_n_s32(0), vmodq_s32(n_vec, divisors));\n    \n    // Horizontal OR to check if any divisor divides n\n    uint32_t result = vaddvq_u32(is_divisible);\n    \n    // If result is 0, n is prime (return x), otherwise return y\n    return (result == 0 && n > 1) ? x : y;\n}\n\n// Helper function for modulo operation using Neon\nint32x4_t vmodq_s32(int32x4_t a, int32x4_t b) {\n    int32x4_t div = vdivq_s32(a, b);\n    return vsubq_s32(a, vmulq_s32(div, b));\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using Neon SIMD\n    if (n <= 1) return y;\n    \n    // Optimization for small primes\n    if (n == 2 || n == 3) return x;\n    \n    // Check divisibility using Neon vector operations\n    int32x4_t divisors = {2, 3, 5, 7};\n    int32x4_t n_vec = vdupq_n_s32(n);\n    \n    // Check divisibility by small prime numbers\n    uint32x4_t div_check = vceqzq_u32(vandq_u32(\n        vdivq_s32(n_vec, divisors), \n        vreinterpretq_u32_s32(vsubq_s32(vdivq_s32(n_vec, divisors), vmulq_s32(divisors, vdivq_s32(n_vec, divisors))))\n    ));\n    \n    // Horizontal OR to check if divisible\n    uint32_t result = vaddvq_u32(div_check);\n    \n    return (result == 0 && n > 7) ? y : x;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vec_size = n - (n % 4);\n    uint64_t result = 0;\n\n    // Process 4 elements at a time using NEON\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Check for odd integers\n        uint32x4_t is_odd_mask = vceqq_u32(\n            vandq_u32(vcvtq_u32_f32(input_vec), vdupq_n_u32(1)),\n            vdupq_n_u32(1)\n        );\n        \n        // Check for positive\n        uint32x4_t is_positive_mask = vcgtq_f32(input_vec, vdupq_n_f32(0.0f));\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(is_odd_mask, is_positive_mask);\n        \n        // Square valid numbers\n        float32x4_t squared_vec = vmulq_f32(input_vec, input_vec);\n        squared_vec = vbslq_f32(valid_mask, squared_vec, vdupq_n_f32(0.0f));\n        \n        // Accumulate\n        sum_vec = vaddq_f32(sum_vec, squared_vec);\n    }\n\n    // Horizontal sum\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t sum = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < n; ++i) {\n        float val = lst[i];\n        if (val > 0 && static_cast<int>(val) == val && static_cast<int>(val) % 2 == 1) {\n            sum += val * val;\n        }\n    }\n\n    return static_cast<uint64_t>(sum);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vec_size = n - (n % 4);\n    uint64_t result = 0;\n\n    // Process 4 elements at a time using Neon SIMD\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Check for odd integers\n        uint32x4_t is_odd_mask = vceqq_u32(\n            vandq_u32(vcvtq_u32_f32(input_vec), vdupq_n_u32(1)),\n            vdupq_n_u32(1)\n        );\n        \n        // Check for positive numbers\n        uint32x4_t is_positive_mask = vcgtq_f32(input_vec, vdupq_n_f32(0.0f));\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(is_odd_mask, is_positive_mask);\n        \n        // Square valid numbers\n        float32x4_t squared_vec = vmulq_f32(input_vec, input_vec);\n        \n        // Mask squared values\n        float32x4_t masked_squared_vec = vbslq_f32(valid_mask, squared_vec, vdupq_n_f32(0.0f));\n        \n        // Accumulate\n        sum_vec = vaddq_f32(sum_vec, masked_squared_vec);\n    }\n\n    // Horizontal sum\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    float32_t sum_scalar = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    // Process remaining elements\n    for (size_t i = vec_size; i < n; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) == lst[i] && static_cast<int>(lst[i]) % 2 == 1) {\n            sum_scalar += lst[i] * lst[i];\n        }\n    }\n\n    return static_cast<uint64_t>(sum_scalar);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t vector_size = lst.size();\n    size_t simd_size = vector_size - (vector_size % 4);\n    uint64_t result = 0;\n\n    // Process 4 elements at a time using Neon SIMD\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Check for odd integers\n        uint32x4_t is_odd_mask = vceqq_u32(\n            vandq_u32(vcvtq_u32_f32(input_vec), vdupq_n_u32(1)),\n            vdupq_n_u32(1)\n        );\n        \n        // Check for positive numbers\n        uint32x4_t is_positive_mask = vcgtq_f32(input_vec, vdupq_n_f32(0.0f));\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(is_odd_mask, is_positive_mask);\n        \n        // Square valid numbers\n        float32x4_t squared_vec = vmulq_f32(input_vec, input_vec);\n        \n        // Mask out invalid numbers\n        float32x4_t masked_squared_vec = vbslq_f32(valid_mask, squared_vec, vdupq_n_f32(0.0f));\n        \n        // Accumulate sum\n        sum_vec = vaddq_f32(sum_vec, masked_squared_vec);\n    }\n    \n    // Horizontal sum of SIMD vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    sum_low = vpadd_f32(sum_low, sum_low);\n    result += (uint64_t)vget_lane_f32(sum_low, 0);\n    \n    // Process remaining elements\n    for (size_t i = simd_size; i < vector_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && static_cast<int>(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += static_cast<uint64_t>(val * val);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vec_size = n - (n % 4);\n    uint64_t result = 0;\n\n    // Process 4 elements at a time using NEON\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Check for odd integers\n        uint32x4_t is_odd_mask = vandq_u32(\n            vcgeq_f32(input_vec, vdupq_n_f32(0.0f)),  // non-negative\n            vceqq_f32(vfmaq_n_f32(input_vec, input_vec, -1.0f), vdupq_n_f32(0.0f))  // integer check\n        );\n        \n        // Square odd integers\n        float32x4_t squared_vec = vmulq_f32(input_vec, input_vec);\n        squared_vec = vbslq_f32(is_odd_mask, squared_vec, vdupq_n_f32(0.0f));\n        \n        sum_vec = vaddq_f32(sum_vec, squared_vec);\n    }\n\n    // Horizontal sum of vector\n    float32x2_t sum_low = vget_low_f32(sum_vec);\n    float32x2_t sum_high = vget_high_f32(sum_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    result = vget_lane_f32(sum_low, 0) + vget_lane_f32(sum_low, 1);\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < n; ++i) {\n        float val = lst[i];\n        if (val > 0 && std::floor(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += val * val;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vector_size = lst.size();\n    size_t simd_size = vector_size - (vector_size % 4);\n\n    // Process 4 elements at a time using Neon SIMD\n    float32x4_t sum_squares_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        float32x4_t input_vec = vld1q_f32(&lst[i]);\n        \n        // Check for odd integers\n        uint32x4_t is_odd_mask = vreinterpretq_u32_u8(\n            vcgeq_f32(\n                vabsq_f32(input_vec), \n                vdupq_n_f32(0.0f)\n            )\n        );\n        is_odd_mask = vandq_u32(\n            is_odd_mask, \n            vreinterpretq_u32_u8(\n                vceqq_f32(\n                    vfmoq_f32(input_vec, vdupq_n_f32(2.0f)), \n                    vdupq_n_f32(1.0f)\n                )\n            )\n        );\n\n        // Square the odd integers\n        float32x4_t squared_vec = vmulq_f32(input_vec, input_vec);\n        squared_vec = vbslq_f32(is_odd_mask, squared_vec, vdupq_n_f32(0.0f));\n\n        // Accumulate sum of squares\n        sum_squares_vec = vaddq_f32(sum_squares_vec, squared_vec);\n    }\n\n    // Horizontal sum of SIMD vector\n    float32x2_t sum_low = vget_low_f32(sum_squares_vec);\n    float32x2_t sum_high = vget_high_f32(sum_squares_vec);\n    sum_low = vadd_f32(sum_low, sum_high);\n    sum_low = vpadd_f32(sum_low, sum_low);\n    result += (uint64_t)vget_lane_f32(sum_low, 0);\n\n    // Process remaining elements\n    for (size_t i = simd_size; i < vector_size; ++i) {\n        float val = lst[i];\n        if (std::abs(val) > 0 && std::fmod(val, 2.0f) == 1.0f) {\n            result += (uint64_t)(val * val);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    \n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 game and guess values\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        \n        // Compute absolute difference\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        \n        // Store results\n        vst1q_s32(&result[i], diff_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n\n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 game scores and 4 guesses into Neon registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compare if guesses match game scores\n        int32x4_t match_mask = vceqq_s32(game_vec, guess_vec);\n\n        // Compute absolute difference\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n\n        // Where match_mask is true (0xFFFFFFFF), set result to 0, else use diff\n        int32x4_t result_vec = vbslq_s32(match_mask, vdupq_n_s32(0), diff_vec);\n\n        // Store result back to vector\n        vst1q_s32(&result[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = (game[i] == guess[i]) ? 0 : std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n\n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 game scores and 4 guesses into Neon registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compute absolute difference\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n\n        // Store results back to result vector\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < game.size(); ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n\n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 game scores and 4 guesses into Neon registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compare if guesses match game scores\n        int32x4_t match_vec = vceqq_s32(game_vec, guess_vec);\n\n        // Compute absolute difference\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n\n        // Where match_vec is zero (no match), keep diff_vec, else zero\n        int32x4_t result_vec = vbslq_s32(match_vec, vdupq_n_s32(0), diff_vec);\n\n        // Store result back to result vector\n        vst1q_s32(&result[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < game.size(); ++i) {\n        result[i] = (game[i] == guess[i]) ? 0 : std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n\n    // Process 4 elements at a time using Neon SIMD\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 game scores and 4 guesses into Neon registers\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        // Compare if guesses match scores\n        int32x4_t match_vec = vceqq_s32(game_vec, guess_vec);\n\n        // Calculate absolute difference\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n\n        // Where match_vec is zero (no match), keep diff_vec; otherwise, zero out\n        int32x4_t result_vec = vbslq_s32(match_vec, vdupq_n_s32(0), diff_vec);\n\n        // Store results back to result vector\n        vst1q_s32(&result[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < game.size(); ++i) {\n        result[i] = (game[i] == guess[i]) ? 0 : std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}

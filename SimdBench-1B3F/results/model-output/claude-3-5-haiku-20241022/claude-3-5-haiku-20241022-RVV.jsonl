{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load mask vector\n        vbool64_t vmask = __riscv_vmload_m1(mask + i, vl);\n        \n        // Load source vector\n        vint64m1_t vsrc = __riscv_vle64_v_i64m1(src + i, vl);\n        \n        // Load destination vector\n        vint64m1_t vdst = __riscv_vle64_v_i64m1(dst + i, vl);\n        \n        // Conditionally select elements\n        vint64m1_t vresult = __riscv_vmerge_vvm(vdst, vsrc, vmask, vl);\n        \n        // Store result back to destination\n        __riscv_vse64_v_i64m1(dst + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load mask vector\n        vbool64_t vmask = __riscv_vmsne_vx_b64(\n            __riscv_vle8_v_b64(mask + i, vl), \n            0, vl\n        );\n        \n        // Load source vector\n        vint64m1_t vsrc = __riscv_vle64_v_i64m1(src + i, vl);\n        \n        // Conditionally move elements\n        vint64m1_t vdst = __riscv_vmerge_vvm_i64m1(\n            __riscv_vle64_v_i64m1(dst + i, vl), \n            vsrc, \n            vmask, \n            vl\n        );\n        \n        // Store result\n        __riscv_vse64_v_i64m1(dst + i, vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    vbool64_t vmask;\n    size_t i = 0;\n\n    while (i < length) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e64m1(length - i);\n\n        // Load mask vector\n        vmask = __riscv_vmseq_vx_b64_b64(\n            __riscv_vle8_v_b64(mask + i, vl),\n            1, vl\n        );\n\n        // Load source vector\n        vint64m1_t vsrc = __riscv_vle64_v_i64m1(src + i, vl);\n\n        // Conditionally move elements using mask\n        vint64m1_t vdst = __riscv_vmerge_vvm_i64m1(\n            __riscv_vle64_v_i64m1(dst + i, vl),\n            vsrc,\n            vmask,\n            vl\n        );\n\n        // Store result back to destination\n        __riscv_vse64_v_i64m1(dst + i, vdst, vl);\n\n        // Update loop counter\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load mask vector\n        vbool64_t vmask = __riscv_vmfirst_m_b64(\n            __riscv_vlm_v_b64(mask + i, vl), \n            vl\n        );\n        \n        // Load source vector\n        vint64m1_t vsrc = __riscv_vle64_v_i64m1(src + i, vl);\n        \n        // Conditionally move elements\n        vint64m1_t vdst = __riscv_vmerge_vvm_i64m1(\n            __riscv_vle64_v_i64m1(dst + i, vl), \n            vsrc, \n            vmask, \n            vl\n        );\n        \n        // Store result\n        __riscv_vse64_v_i64m1(dst + i, vdst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load mask vector\n        vbool64_t vmask = __riscv_vmsne_vv_b64_b64(\n            __riscv_vle8_v_b64(mask + i, vl),\n            __riscv_vmv_v_x_b64(0, vl),\n            vl\n        );\n        \n        // Load source vector\n        vint64m1_t vsrc = __riscv_vle64_v_i64m1(src + i, vl);\n        \n        // Conditionally move elements\n        __riscv_vmerge_vvm_i64m1(dst + i, vsrc, vmask, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Multiply source with scale\n        vint32m1_t v_scaled = __riscv_vmul_vx_i32m1(v_src, scale, vl);\n        \n        // Calculate tmp1: right shift by 3\n        vint32m1_t v_tmp1 = __riscv_vsra_vx_i32m1(v_scaled, 3, vl);\n        \n        // Calculate tmp2: left shift by 3\n        vint32m1_t v_tmp2 = __riscv_vsll_vx_i32m1(v_scaled, 3, vl);\n        \n        // Multiply tmp1 and tmp2\n        vint32m1_t v_tmp_mul = __riscv_vmul_vv_i32m1(v_tmp1, v_tmp2, vl);\n        \n        // Add scaled and tmp_mul\n        vint32m1_t v_result = __riscv_vadd_vv_i32m1(v_scaled, v_tmp_mul, vl);\n        \n        // Divide by 7\n        vint32m1_t v_final = __riscv_vdiv_vx_i32m1(v_result, 7, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, v_final, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Multiply by scale\n        vint32m1_t v_scaled = __riscv_vmul_vx_i32m1(v_src, scale, vl);\n        \n        // Calculate tmp1: right shift by 3\n        vint32m1_t v_tmp1 = __riscv_vsra_vx_i32m1(v_scaled, 3, vl);\n        \n        // Calculate tmp2: left shift by 3\n        vint32m1_t v_tmp2 = __riscv_vsll_vx_i32m1(v_scaled, 3, vl);\n        \n        // Multiply tmp1 and tmp2\n        vint32m1_t v_tmp_mul = __riscv_vmul_vv_i32m1(v_tmp1, v_tmp2, vl);\n        \n        // Add scaled and tmp_mul\n        vint32m1_t v_result = __riscv_vadd_vv_i32m1(v_scaled, v_tmp_mul, vl);\n        \n        // Divide by 7\n        vint32m1_t v_final = __riscv_vdiv_vx_i32m1(v_result, 7, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, v_final, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Multiply source with scale\n        vint32m1_t v_scaled = __riscv_vmul_vx_i32m1(v_src, scale, vl);\n        \n        // Right shift by 3 bits (tmp1)\n        vint32m1_t v_tmp1 = __riscv_vsra_vx_i32m1(v_scaled, 3, vl);\n        \n        // Left shift by 3 bits (tmp2)\n        vint32m1_t v_tmp2 = __riscv_vsll_vx_i32m1(v_scaled, 3, vl);\n        \n        // Multiply tmp1 and tmp2\n        vint32m1_t v_tmp_mul = __riscv_vmul_vv_i32m1(v_tmp1, v_tmp2, vl);\n        \n        // Add scaled and tmp_mul\n        vint32m1_t v_sum = __riscv_vadd_vv_i32m1(v_scaled, v_tmp_mul, vl);\n        \n        // Divide by 7\n        vint32m1_t v_result = __riscv_vdiv_vx_i32m1(v_sum, 7, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t vec_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Multiply source with scale\n        vint32m1_t vec_scaled = __riscv_vmul_vx_i32m1(vec_src, scale, vl);\n        \n        // Compute tmp1: right shift by 3\n        vint32m1_t vec_tmp1 = __riscv_vsra_vx_i32m1(vec_scaled, 3, vl);\n        \n        // Compute tmp2: left shift by 3\n        vint32m1_t vec_tmp2 = __riscv_vsll_vx_i32m1(vec_scaled, 3, vl);\n        \n        // Multiply tmp1 and tmp2\n        vint32m1_t vec_tmp_mul = __riscv_vmul_vv_i32m1(vec_tmp1, vec_tmp2, vl);\n        \n        // Add scaled and tmp_mul\n        vint32m1_t vec_sum = __riscv_vadd_vv_i32m1(vec_scaled, vec_tmp_mul, vl);\n        \n        // Divide by 7\n        vint32m1_t vec_result = __riscv_vdiv_vx_i32m1(vec_sum, 7, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t vec_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Multiply by scale\n        vint32m1_t vec_scaled = __riscv_vmul_vx_i32m1(vec_src, scale, vl);\n        \n        // Calculate tmp1: right shift by 3\n        vint32m1_t vec_tmp1 = __riscv_vsra_vx_i32m1(vec_scaled, 3, vl);\n        \n        // Calculate tmp2: left shift by 3\n        vint32m1_t vec_tmp2 = __riscv_vsll_vx_i32m1(vec_scaled, 3, vl);\n        \n        // Multiply tmp1 and tmp2\n        vint32m1_t vec_tmp_product = __riscv_vmul_vv_i32m1(vec_tmp1, vec_tmp2, vl);\n        \n        // Add scaled vector and tmp product\n        vint32m1_t vec_sum = __riscv_vadd_vv_i32m1(vec_scaled, vec_tmp_product, vl);\n        \n        // Divide by 7\n        vint32m1_t vec_result = __riscv_vdiv_vx_i32m1(vec_sum, 7, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = __riscv_vsetvl_e64m1(rows);\n    \n    for (size_t r = 0; r < rows; r += vl) {\n        size_t num_elements = __riscv_vsetvl_e64m1(rows - r);\n        \n        // Create index vector for strided load\n        vuint64m1_t idx = __riscv_vid_v_u64m1(num_elements);\n        idx = __riscv_vmul_vx_u64m1(idx, cols, num_elements);\n        idx = __riscv_vadd_vx_u64m1(idx, stride, num_elements);\n        \n        // Load from source array with strided access\n        vfloat64m1_t vec_data = __riscv_vloxei64_v_f64m1(src, idx, num_elements);\n        \n        // Store to destination array\n        __riscv_vse64_v_f64m1(dst + r, vec_data, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = __riscv_vsetvl_e64m1(rows);\n    \n    for (size_t r = 0; r < rows; r += vl) {\n        size_t num_elements = __riscv_vsetvl_e64m1(rows - r);\n        \n        // Create index vector for strided load\n        vuint64m1_t indices = __riscv_vid_v_u64m1(num_elements);\n        indices = __riscv_vmul_vx_u64m1(indices, cols, num_elements);\n        indices = __riscv_vadd_vx_u64m1(indices, stride, num_elements);\n        \n        // Perform strided load from source array\n        vfloat64m1_t loaded_values = __riscv_vloxei64_v_f64m1(src, indices, num_elements);\n        \n        // Store loaded values to destination array\n        __riscv_vse64_v_f64m1(dst + r, loaded_values, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = __riscv_vsetvl_e64m1(rows);\n    \n    for (size_t r = 0; r < rows; r += vl) {\n        size_t num_elements = __riscv_vsetvl_e64m1(rows - r);\n        \n        // Create index vector for strided load\n        vuint64m1_t indices = __riscv_vid_v_u64m1(num_elements);\n        indices = __riscv_vmul_vx_u64m1(indices, cols, num_elements);\n        indices = __riscv_vadd_vx_u64m1(indices, stride, num_elements);\n        \n        // Load from src with computed indices\n        vfloat64m1_t loaded_values = __riscv_vloxei64_v_f64m1(src, indices, num_elements);\n        \n        // Store to dst\n        __riscv_vsxei64_v_f64m1(dst + r, indices, loaded_values, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = __riscv_vsetvl_e64m1(rows);\n    \n    for (size_t r = 0; r < rows; r += vl) {\n        size_t num_elements = __riscv_vsetvl_e64m1(rows - r);\n        \n        // Create index vector for strided load\n        vuint64m1_t indices = __riscv_vid_v_u64m1(num_elements);\n        indices = __riscv_vmul_vx_u64m1(indices, cols, num_elements);\n        indices = __riscv_vadd_vx_u64m1(indices, stride, num_elements);\n        \n        // Perform strided load from source array\n        vfloat64m1_t loaded_values = __riscv_vloxei64_v_f64m1(src, indices, num_elements);\n        \n        // Store loaded values to destination array\n        __riscv_vse64_v_f64m1(dst + r, loaded_values, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = __riscv_vsetvl_e64m1(rows);\n    \n    for (size_t r = 0; r < rows; r += vl) {\n        size_t num_elements = __riscv_vsetvl_e64m1(rows - r);\n        \n        // Create index vector for strided load\n        vuint64m1_t indices = __riscv_vid_v_u64m1(num_elements);\n        indices = __riscv_vmul_vx_u64m1(indices, cols, num_elements);\n        indices = __riscv_vadd_vx_u64m1(indices, stride, num_elements);\n        \n        // Load from src with computed indices\n        vfloat64m1_t loaded_values = __riscv_vloxei64_v_f64m1(src, indices, num_elements);\n        \n        // Store to dst\n        __riscv_vsxei64_v_f64m1(dst + r, indices, loaded_values, num_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Gather values from source using indices\n        vfloat32m1_t gathered_vec = __riscv_vloxei32_v_f32m1(src, idx_vec, vl);\n        \n        // Store gathered values to destination\n        __riscv_vse32_v_f32m1(dst + i, gathered_vec, vl);\n    }\n    \n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Load values from source\n        vfloat32m1_t src_vec = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Scatter values to destination using indices\n        __riscv_vsoxei32_v_f32m1(dst, idx_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Perform gather operation\n        vfloat32m1_t gathered_vec = __riscv_vloxei32_v_f32m1(src, idx_vec, vl);\n        \n        // Store gathered values to destination\n        __riscv_vse32_v_f32m1(dst + i, gathered_vec, vl);\n    }\n    \n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Load source values\n        vfloat32m1_t src_vec = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Perform scatter operation\n        __riscv_vsoxei32_v_f32m1(dst, idx_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Perform gather operation\n        vfloat32m1_t gathered_vec = __riscv_vloxei32_v_f32m1(src, idx_vec, vl);\n        \n        // Store gathered values to destination\n        __riscv_vse32_v_f32m1(dst + i, gathered_vec, vl);\n    }\n    \n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Load source values\n        vfloat32m1_t src_vec = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Perform scatter operation\n        __riscv_vsoxei32_v_f32m1(dst, idx_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Perform gather operation\n        vfloat32m1_t gathered_vec = __riscv_vloxei32_v_f32m1(src, idx_vec, vl);\n        \n        // Store gathered values to destination\n        __riscv_vse32_v_f32m1(dst + i, gathered_vec, vl);\n    }\n    \n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Load source values\n        vfloat32m1_t src_vec = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Perform scatter operation\n        __riscv_vsoxei32_v_f32m1(dst, idx_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Gather values from source array using indices\n        vfloat32m1_t gathered_vec = __riscv_vloxei32_v_f32m1(src, idx_vec, vl);\n        \n        // Store gathered values to destination array\n        __riscv_vse32_v_f32m1(dst + i, gathered_vec, vl);\n    }\n    \n    // Scatter operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load indices vector\n        vuint32m1_t idx_vec = __riscv_vle32_v_u32m1(indices + i, vl);\n        \n        // Load values from source array\n        vfloat32m1_t src_vec = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Scatter values to destination array using indices\n        __riscv_vsoxei32_v_f32m1(dst, idx_vec, src_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl = __riscv_vsetvlmax_e16m1();\n    uint64_t length = end - start + 1;\n    \n    // Swap elements from start to end\n    for (uint64_t i = 0; i < length / 2; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e16m1(length / 2 - i);\n        \n        // Load from start + i\n        vint16m1_t left = __riscv_vle16_v_i16m1(arr + start + i, vlmax);\n        \n        // Load from end - i\n        vint16m1_t right = __riscv_vle16_v_i16m1(arr + end - i - vlmax + 1, vlmax);\n        \n        // Reverse the loaded vectors\n        vint16m1_t reversed_left = __riscv_vrev16_v_i16m1(right, vlmax);\n        vint16m1_t reversed_right = __riscv_vrev16_v_i16m1(left, vlmax);\n        \n        // Store back to original positions\n        __riscv_vse16_v_i16m1(arr + start + i, reversed_left, vlmax);\n        __riscv_vse16_v_i16m1(arr + end - i - vlmax + 1, reversed_right, vlmax);\n    }\n    \n    // Handle middle element if length is odd\n    if (length % 2 == 1) {\n        arr[start + length / 2] = arr[start + length / 2];\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl = __riscv_vsetvlmax_e16m1();\n    uint64_t range_length = end - start + 1;\n    uint64_t half_length = range_length / 2;\n\n    for (uint64_t i = 0; i < half_length; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e16m1(vl);\n        \n        // Load from start + i\n        vint16m1_t left_vec = __riscv_vle16_v_i16m1(arr + start + i, vlmax);\n        \n        // Load from end - i - vl\n        vint16m1_t right_vec = __riscv_vle16_v_i16m1(arr + end - i - vlmax + 1, vlmax);\n        \n        // Reverse right vector\n        vint16m1_t reversed_right = __riscv_vrgather_vv_i16m1(right_vec, __riscv_vid_v_u16m1(vlmax), vlmax);\n        \n        // Store reversed right vector to start + i\n        __riscv_vse16_v_i16m1(arr + start + i, reversed_right, vlmax);\n        \n        // Store reversed left vector to end - i - vl\n        __riscv_vse16_v_i16m1(arr + end - i - vlmax + 1, left_vec, vlmax);\n    }\n\n    // Handle odd-length ranges with a final swap if needed\n    if (range_length % 2 != 0) {\n        int16_t temp = arr[start + half_length];\n        arr[start + half_length] = arr[end - half_length];\n        arr[end - half_length] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the length of the range to reverse\n    size_t range_length = end - start + 1;\n    \n    // If range is empty or single element, no reversal needed\n    if (range_length <= 1) return;\n    \n    // Get the current vector length\n    size_t vl = __riscv_vsetvl_e16m1(range_length);\n    \n    // Iterate and swap elements from start to end\n    for (size_t i = 0; i < range_length / 2; i += vl) {\n        // Calculate remaining elements\n        size_t vlmax = (range_length / 2 - i < vl) ? range_length / 2 - i : vl;\n        \n        // Load from start + i and end - i\n        vint16m1_t left_vec = __riscv_vle16_v_i16m1(arr + start + i, vlmax);\n        vint16m1_t right_vec = __riscv_vle16_v_i16m1(arr + end - i - vlmax + 1, vlmax);\n        \n        // Reverse the loaded vectors\n        vint16m1_t reversed_left = __riscv_vrev16_v_i16m1(right_vec);\n        vint16m1_t reversed_right = __riscv_vrev16_v_i16m1(left_vec);\n        \n        // Store back to swapped positions\n        __riscv_vse16_v_i16m1(arr + start + i, reversed_left, vlmax);\n        __riscv_vse16_v_i16m1(arr + end - i - vlmax + 1, reversed_right, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the length of the range to reverse\n    size_t range_length = end - start + 1;\n    \n    // If range is empty or single element, no reversal needed\n    if (range_length <= 1) return;\n    \n    // Get the current vector length for 16-bit elements\n    size_t vl = __riscv_vsetvl_e16m1(range_length);\n    \n    // Iterate through half the range, swapping elements from start and end\n    for (size_t i = 0; i < range_length / 2; i += vl) {\n        // Calculate remaining elements to process\n        size_t vlmax = (range_length / 2 - i < vl) ? range_length / 2 - i : vl;\n        \n        // Load vector from start of range\n        vint16m1_t left_vec = __riscv_vle16_v_i16m1(arr + start + i, vlmax);\n        \n        // Load vector from end of range\n        vint16m1_t right_vec = __riscv_vle16_v_i16m1(arr + end - i - vlmax + 1, vlmax);\n        \n        // Reverse the loaded vectors\n        vint16m1_t reversed_left = __riscv_vrev16_v_i16m1(right_vec);\n        vint16m1_t reversed_right = __riscv_vrev16_v_i16m1(left_vec);\n        \n        // Store back to original positions\n        __riscv_vse16_v_i16m1(arr + start + i, reversed_left, vlmax);\n        __riscv_vse16_v_i16m1(arr + end - i - vlmax + 1, reversed_right, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    size_t num_elements = end - start + 1;\n    \n    // If no elements to reverse, return\n    if (num_elements <= 1) return;\n    \n    // Get the vector length for 16-bit elements\n    size_t vl = __riscv_vsetvl_e16m1(num_elements);\n    \n    // Iterate through half the elements\n    for (size_t i = 0; i < num_elements / 2; i += vl) {\n        // Calculate remaining elements\n        size_t vlmax = (num_elements / 2 - i < vl) ? num_elements / 2 - i : vl;\n        \n        // Load vector from start of range\n        vint16m1_t left_vec = __riscv_vle16_v_i16m1(arr + start + i, vlmax);\n        \n        // Load vector from end of range\n        vint16m1_t right_vec = __riscv_vle16_v_i16m1(arr + end - i - vlmax + 1, vlmax);\n        \n        // Reverse the loaded vectors\n        vint16m1_t reversed_left = __riscv_vrev16_v_i16m1(right_vec);\n        vint16m1_t reversed_right = __riscv_vrev16_v_i16m1(left_vec);\n        \n        // Store back to original positions\n        __riscv_vse16_v_i16m1(arr + start + i, reversed_left, vlmax);\n        __riscv_vse16_v_i16m1(arr + end - i - vlmax + 1, reversed_right, vlmax);\n    }\n    \n    // Handle middle element if odd number of elements\n    if (num_elements % 2 != 0) {\n        size_t mid_index = start + num_elements / 2;\n        int16_t temp = arr[mid_index];\n        arr[mid_index] = arr[mid_index];\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    size_t vl = dim1 * dim2;\n    size_t avl = vl;\n    \n    for (size_t vec_start = 0; vec_start < vl; vec_start += avl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(avl);\n        \n        vint8m1_t vec_data = __riscv_vle8_v_i8m1(slice_start + vec_start, vlmax);\n        __riscv_vse8_v_i8m1(slice + vec_start, vec_data, vlmax);\n        \n        avl -= vlmax;\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_slice_size = dim1 * dim2;\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Get the maximum vector length\n    size_t vl = __riscv_vsetvl_e8m1(dim1 * dim2);\n\n    // Process the slice in vector chunks\n    for (size_t i = 0; i < total_slice_size; i += vl) {\n        // Determine the number of elements to process in this iteration\n        size_t vlmax = __riscv_vsetvl_e8m1(total_slice_size - i);\n\n        // Load vector from the source tensor slice\n        vuint8m1_t v_slice = __riscv_vle8_v_u8m1(tensor + slice_offset + i, vlmax);\n\n        // Store the vector to the destination slice\n        __riscv_vse8_v_u8m1(slice + i, v_slice, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_slice_size = dim1 * dim2;\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Get the vector length for uint8_t\n    size_t vl = __riscv_vsetvl_e8m1(dim1 * dim2);\n\n    // Process the slice in vector chunks\n    for (size_t i = 0; i < total_slice_size; i += vl) {\n        // Determine the number of elements to process in this iteration\n        size_t num_elements = (total_slice_size - i < vl) ? (total_slice_size - i) : vl;\n        \n        // Set vector length for this iteration\n        vl = __riscv_vsetvl_e8m1(num_elements);\n\n        // Load vector from the source tensor slice\n        vuint8m1_t v_slice = __riscv_vle8_v_u8m1(tensor + slice_offset + i, vl);\n\n        // Store vector to the destination slice\n        __riscv_vse8_v_u8m1(slice + i, v_slice, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t total_slice_size = dim1 * dim2;\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Get the vector length\n    size_t vl = __riscv_vsetvl_e8m1(dim1 * dim2);\n\n    // Process the slice in vector chunks\n    for (size_t i = 0; i < total_slice_size; i += vl) {\n        // Determine the current vector length\n        size_t current_vl = __riscv_vsetvl_e8m1(total_slice_size - i);\n\n        // Load vector from the source tensor slice\n        vuint8m1_t v_slice = __riscv_vle8_v_u8m1(tensor + slice_offset + i, current_vl);\n\n        // Store vector to the destination slice\n        __riscv_vse8_v_u8m1(slice + i, v_slice, current_vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Get the vector length\n    size_t vl = __riscv_vsetvl_e8m1(dim1 * dim2);\n\n    // Iterate through the slice in vector-sized chunks\n    for (size_t i = 0; i < dim1 * dim2; i += vl) {\n        // Adjust vector length for the last iteration if needed\n        vl = __riscv_vsetvl_e8m1(dim1 * dim2 - i);\n\n        // Load vector from source slice\n        vuint8m1_t v_data = __riscv_vle8_v_u8m1(slice_start + i, vl);\n\n        // Store vector to destination slice\n        __riscv_vse8_v_u8m1(slice + i, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            size_t max_row = (block_row + block_size < rows) ? block_row + block_size : rows;\n            size_t max_col = (block_col + block_size < cols) ? block_col + block_size : cols;\n\n            for (size_t row = block_row; row < max_row; row++) {\n                size_t col = block_col;\n                \n                // Use vector length agnostic approach\n                size_t vl = __riscv_vsetvl_e16m1(max_col - col);\n                \n                while (col < max_col) {\n                    vint16m1_t v_src = __riscv_vle16_v_i16m1(src + row * cols + col, vl);\n                    __riscv_vse16_v_i16m1(dst + col * rows + row, v_src, vl);\n                    \n                    col += vl;\n                    vl = __riscv_vsetvl_e16m1(max_col - col);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            size_t max_row = (block_row + block_size < rows) ? block_row + block_size : rows;\n            size_t max_col = (block_col + block_size < cols) ? block_col + block_size : cols;\n\n            for (size_t row = block_row; row < max_row; row++) {\n                size_t col = block_col;\n                \n                // Use RVV vector length\n                size_t vl = __riscv_vsetvl_e16m1(max_col - col);\n                \n                while (col + vl <= max_col) {\n                    // Load vector from source matrix\n                    vint16m1_t v_src = __riscv_vle16_v_i16m1(src + row * cols + col, vl);\n                    \n                    // Store transposed vector to destination matrix\n                    __riscv_vse16_v_i16m1(dst + col * rows + row, v_src, vl);\n                    \n                    col += vl;\n                    vl = __riscv_vsetvl_e16m1(max_col - col);\n                }\n                \n                // Handle remaining elements\n                for (; col < max_col; col++) {\n                    dst[col * rows + row] = src[row * cols + col];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            size_t max_row = (block_row + block_size < rows) ? block_row + block_size : rows;\n            size_t max_col = (block_col + block_size < cols) ? block_col + block_size : cols;\n\n            for (size_t r = block_row; r < max_row; r++) {\n                size_t vec_col = block_col;\n                for (; vec_col + 16 <= max_col; vec_col += 16) {\n                    size_t vl = __riscv_vsetvl_e16m1(16);\n                    vint16m1_t v_src = __riscv_vle16_v_i16m1(src + r * cols + vec_col, vl);\n                    __riscv_vse16_v_i16m1(dst + vec_col * rows + r, v_src, vl);\n                }\n\n                // Handle remaining columns\n                for (; vec_col < max_col; vec_col++) {\n                    dst[vec_col * rows + r] = src[r * cols + vec_col];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            size_t max_row = (block_row + block_size < rows) ? block_row + block_size : rows;\n            size_t max_col = (block_col + block_size < cols) ? block_col + block_size : cols;\n\n            for (size_t row = block_row; row < max_row; row++) {\n                size_t col = block_col;\n                \n                // Use vector length agnostic approach\n                size_t vl = __riscv_vsetvl_e16m1(max_col - col);\n                \n                while (col < max_col) {\n                    vint16m1_t v_src = __riscv_vle16_v_i16m1(src + row * cols + col, vl);\n                    __riscv_vse16_v_i16m1(dst + col * rows + row, v_src, vl);\n                    \n                    col += vl;\n                    vl = __riscv_vsetvl_e16m1(max_col - col);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            size_t max_row = (block_row + block_size < rows) ? block_row + block_size : rows;\n            size_t max_col = (block_col + block_size < cols) ? block_col + block_size : cols;\n\n            for (size_t row = block_row; row < max_row; row++) {\n                size_t col = block_col;\n                \n                // Use vector length agnostic approach\n                size_t vl = __riscv_vsetvl_e16m1(max_col - col);\n                \n                while (col < max_col) {\n                    vint16m1_t v_src = __riscv_vle16_v_i16m1(src + row * cols + col, vl);\n                    __riscv_vse16_v_i16m1(dst + col * rows + row, v_src, vl);\n                    \n                    col += vl;\n                    vl = __riscv_vsetvl_e16m1(max_col - col);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t avl = dim;\n    vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, 16);\n\n    for (size_t i = 0; i < dim; i += vl) {\n        vl = vsetvl_e32m1(avl);\n        size_t diagonal_index = i * dim + i;\n        vfloat32m1_t v_diagonal = vlse32_v_f32m1(array + diagonal_index, dim * sizeof(float), vl);\n        v_sum = vfredsum_vs_f32m1_f32m1(v_sum, v_diagonal, v_sum, vl);\n        avl -= vl;\n    }\n\n    sum = vfmv_f_s_f32m1_f32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float total_sum = 0.0f;\n    size_t vl;\n    size_t vector_stride = dim * dim + dim + 1;\n    \n    vl = __riscv_vsetvl_e32m1(dim);\n    vfloat32m1_t sum_vec = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n    \n    for (size_t i = 0; i < dim; i++) {\n        size_t diagonal_index = i * vector_stride;\n        vfloat32m1_t diagonal_vec = __riscv_vle32_v_f32m1(&array[diagonal_index], vl);\n        sum_vec = __riscv_vfadd_vv_f32m1(sum_vec, diagonal_vec, vl);\n    }\n    \n    float partial_sums[16];  // Adjust size based on max vector length\n    __riscv_vse32_v_f32m1(partial_sums, sum_vec, vl);\n    \n    for (size_t i = 0; i < vl; i++) {\n        total_sum += partial_sums[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t i = 0;\n    vfloat32m1_t v_sum = __riscv_vfmv_s_f_f32m1(0.0f, __riscv_vsetvl_e32m1(1));\n\n    for (; i + __riscv_vsetvl_e32m1(dim - i) <= dim; i += vl) {\n        vl = __riscv_vsetvl_e32m1(dim - i);\n        size_t diag_index = i * dim + i;\n        vfloat32m1_t v_diag = __riscv_vle32_v_f32m1(array + diag_index, vl);\n        v_sum = __riscv_vfredsum_vs_f32m1_f32m1(v_sum, v_diag, v_sum, vl);\n    }\n\n    for (; i < dim; i++) {\n        sum += array[i * dim + i];\n    }\n\n    sum += __riscv_vfmv_f_s_f32m1_f32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t i = 0;\n    vfloat32m1_t v_sum = __riscv_vfmv_s_f_f32m1(0.0f, __riscv_vsetvl_e32m1(1));\n\n    for (; i + __riscv_vsetvl_e32m1(dim) <= dim; i += vl) {\n        vl = __riscv_vsetvl_e32m1(dim - i);\n        size_t diagonal_index = i * dim + i;\n        vfloat32m1_t v_diagonal = __riscv_vle32_v_f32m1(array + diagonal_index, vl);\n        v_sum = __riscv_vfredsum_vs_f32m1_f32m1(v_sum, v_diagonal, v_sum, vl);\n    }\n\n    sum = __riscv_vfmv_f_s_f32m1_f32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vl;\n    size_t i = 0;\n    vfloat32m1_t v_sum = __riscv_vfmv_s_f_f32m1(0.0f, __riscv_vsetvl_e32m1(1));\n\n    for (; i + __riscv_vsetvl_e32m1(dim - i) <= dim; i += vl) {\n        vl = __riscv_vsetvl_e32m1(dim - i);\n        size_t diag_index = i * dim + i;\n        vfloat32m1_t v_diag = __riscv_vle32_v_f32m1(array + diag_index, vl);\n        v_sum = __riscv_vfredsum_vs_f32m1_f32m1(v_sum, v_diag, v_sum, vl);\n    }\n\n    for (; i < dim; i++) {\n        sum += array[i * dim + i];\n    }\n\n    sum += __riscv_vfmv_f_s_f32m1_f32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        // Load source vector\n        vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src + i, vl);\n        \n        // Compare if values are greater than threshold\n        vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(v_src, threshold, vl);\n        \n        // Scale values above threshold\n        vfloat64m1_t v_scaled = __riscv_vfmul_vf_f64m1_m(mask, v_src, v_src, scale, vl);\n        \n        // Store result in destination\n        __riscv_vse64_v_f64m1(dst + i, v_scaled, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t vl = __riscv_vsetvl_e64m1(cols);\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - c);\n            \n            // Load source vector\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src + r * cols + c, vl);\n            \n            // Create mask for values above threshold\n            vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(v_src, threshold, vl);\n            \n            // Scale values above threshold\n            vfloat64m1_t v_scaled = __riscv_vfmul_vf_f64m1_m(mask, v_src, v_src, scale, vl);\n            \n            // Store result in destination\n            __riscv_vse64_v_f64m1(dst + r * cols + c, v_scaled, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t vl = __riscv_vsetvl_e64m1(cols);\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - c);\n            \n            // Load source vector\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src + r * cols + c, vl);\n            \n            // Create mask for values above threshold\n            vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(v_src, threshold, vl);\n            \n            // Scale values above threshold\n            vfloat64m1_t v_scaled = __riscv_vfmul_vf_f64m1_m(mask, v_src, v_src, scale, vl);\n            \n            // Store result in destination\n            __riscv_vse64_v_f64m1(dst + r * cols + c, v_scaled, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        // Load source vector\n        vfloat64m1_t vec_src = __riscv_vle64_v_f64m1(src + i, vlmax);\n        \n        // Create mask for values greater than threshold\n        vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(vec_src, threshold, vlmax);\n        \n        // Scale values above threshold\n        vfloat64m1_t vec_scaled = __riscv_vfmul_vf_f64m1_m(mask, vec_src, vec_src, scale, vlmax);\n        \n        // Store result in destination\n        __riscv_vse64_v_f64m1(dst + i, vec_scaled, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t vl = __riscv_vsetvl_e64m1(cols);\n        for (size_t c = 0; c < cols; c += vl) {\n            // Adjust vector length for last iteration if needed\n            vl = __riscv_vsetvl_e64m1(cols - c);\n\n            // Load source vector\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src + r * cols + c, vl);\n\n            // Create mask for values above threshold\n            vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(v_src, threshold, vl);\n\n            // Scale values above threshold\n            vfloat64m1_t v_scaled = __riscv_vfmul_vf_f64m1_m(mask, v_src, v_src, scale, vl);\n\n            // Store result in destination\n            __riscv_vse64_v_f64m1(dst + r * cols + c, v_scaled, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec = __riscv_vle64_v_f64m1(src_row + j, vl);\n            __riscv_vse64_v_f64m1(dst_row + j, vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t index = indices[i];\n        const double *src_row = src + index * cols;\n        double *dst_row = dst + i * cols;\n\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - j);\n            vfloat64m1_t vec = __riscv_vle64_v_f64m1(src_row + j, vl);\n            __riscv_vse64_v_f64m1(dst_row + j, vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        vl = __riscv_vsetvl_e64m1(cols);\n        \n        while (j + vl <= cols) {\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src_row + j, vl);\n            __riscv_vse64_v_f64m1(dst_row + j, v_src, vl);\n            j += vl;\n            vl = __riscv_vsetvl_e64m1(cols - j);\n        }\n        \n        if (j < cols) {\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src_row + j, cols - j);\n            __riscv_vse64_v_f64m1(dst_row + j, v_src, cols - j);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - j);\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src_row + j, vl);\n            __riscv_vse64_v_f64m1(dst_row + j, v_src, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t idx = indices[i];\n        const double *src_row = src + idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        vl = __riscv_vsetvl_e64m1(cols);\n        \n        while (j + vl <= cols) {\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src_row + j, vl);\n            __riscv_vse64_v_f64m1(dst_row + j, v_src, vl);\n            j += vl;\n            vl = __riscv_vsetvl_e64m1(cols - j);\n        }\n        \n        if (j < cols) {\n            vfloat64m1_t v_src = __riscv_vle64_v_f64m1(src_row + j, cols - j);\n            __riscv_vse64_v_f64m1(dst_row + j, v_src, cols - j);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from src1 and src2\n        vint64m1_t vec1 = __riscv_vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vec2 = __riscv_vle64_v_i64m1(src2 + i, vl);\n        \n        // Add vectors\n        vint64m1_t sum_vec = __riscv_vadd_vv_i64m1(vec1, vec2, vl);\n        \n        // Add scalar to result\n        vint64m1_t scalar_vec = __riscv_vmv_v_x_i64m1(scalar, vl);\n        vint64m1_t result_vec = __riscv_vadd_vv_i64m1(sum_vec, scalar_vec, vl);\n        \n        // Divide by 2 (round toward zero)\n        vint64m1_t div_result = __riscv_vsra_vx_i64m1(result_vec, 1, vl);\n        \n        // Store result in destination\n        __riscv_vse64_v_i64m1(dst + i, div_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from src1 and src2\n        vint64m1_t vec1 = __riscv_vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vec2 = __riscv_vle64_v_i64m1(src2 + i, vl);\n        \n        // Add vectors\n        vint64m1_t sum_vec = __riscv_vadd_vv_i64m1(vec1, vec2, vl);\n        \n        // Add scalar to each element\n        vint64m1_t scalar_vec = __riscv_vmv_v_x_i64m1(scalar, vl);\n        vint64m1_t result_vec = __riscv_vadd_vv_i64m1(sum_vec, scalar_vec, vl);\n        \n        // Divide by 2 (round toward zero)\n        vint64m1_t div_result = __riscv_vsra_vx_i64m1(result_vec, 1, vl);\n        \n        // Store result in destination array\n        __riscv_vse64_v_i64m1(dst + i, div_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from src1 and src2\n        vint64m1_t vec1 = __riscv_vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vec2 = __riscv_vle64_v_i64m1(src2 + i, vl);\n        \n        // Add vectors\n        vint64m1_t sum_vec = __riscv_vadd_vv_i64m1(vec1, vec2, vl);\n        \n        // Add scalar to each element\n        vint64m1_t scalar_vec = __riscv_vmv_v_x_i64m1(scalar, vl);\n        vint64m1_t result_vec = __riscv_vadd_vv_i64m1(sum_vec, scalar_vec, vl);\n        \n        // Divide by 2 (round toward zero)\n        vint64m1_t div_result = __riscv_vsra_vx_i64m1(result_vec, 1, vl);\n        \n        // Store result in destination array\n        __riscv_vse64_v_i64m1(dst + i, div_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from src1 and src2\n        vint64m1_t v_src1 = __riscv_vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t v_src2 = __riscv_vle64_v_i64m1(src2 + i, vl);\n        \n        // Add src1 and src2 element-wise\n        vint64m1_t v_sum = __riscv_vadd_vv_i64m1(v_src1, v_src2, vl);\n        \n        // Add scalar to the sum\n        vint64m1_t v_scalar = __riscv_vmv_V_x_i64m1(scalar, vl);\n        v_sum = __riscv_vadd_vv_i64m1(v_sum, v_scalar, vl);\n        \n        // Divide by 2 (round toward zero)\n        vint64m1_t v_result = __riscv_vsra_vx_i64m1(v_sum, 1, vl);\n        \n        // Store result in destination array\n        __riscv_vse64_v_i64m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from src1 and src2\n        vint64m1_t vec1 = __riscv_vle64_v_i64m1(src1 + i, vl);\n        vint64m1_t vec2 = __riscv_vle64_v_i64m1(src2 + i, vl);\n        \n        // Add vectors\n        vint64m1_t sum_vec = __riscv_vadd_vv_i64m1(vec1, vec2, vl);\n        \n        // Add scalar to each element\n        vint64m1_t scalar_vec = __riscv_vmv_v_x_i64m1(scalar, vl);\n        sum_vec = __riscv_vadd_vv_i64m1(sum_vec, scalar_vec, vl);\n        \n        // Divide by 2 (round toward zero)\n        sum_vec = __riscv_vsra_vx_i64m1(sum_vec, 1, vl);\n        \n        // Store result in destination\n        __riscv_vse64_v_i64m1(dst + i, sum_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT_MAX;\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    size_t stride = 2;\n\n    for (size_t i = 0; i < length; i += vl * stride) {\n        size_t remaining = length - i;\n        size_t vlmax = __riscv_vsetvl_e32m1(remaining);\n\n        vint32m1_t v_src = __riscv_vlse32_v_i32m1(src + i, stride * sizeof(int), vlmax);\n        vint32m1_t v_min = __riscv_vredmin_vs_i32m1_i32m1(v_src, __riscv_vmv_v_x_i32m1(INT_MAX, vlmax), vlmax);\n        \n        int current_min = __riscv_vmv_x_s_i32m1_i32(v_min);\n        min_val = (current_min < min_val) ? current_min : min_val;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT_MAX;\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    size_t stride = 2;\n\n    for (size_t i = 0; i < length; i += vl * stride) {\n        size_t remaining = length - i;\n        size_t vlmax = __riscv_vsetvl_e32m1(remaining);\n\n        vint32m1_t v_src = __riscv_vlse32_v_i32m1(src + i, stride * sizeof(int), vlmax);\n        vint32m1_t v_min = __riscv_vredmin_vs_i32m1_i32m1(v_src, __riscv_vmv_v_x_i32m1(INT_MAX, vlmax), vlmax);\n        \n        int current_min = __riscv_vmv_x_s_i32m1_i32(v_min);\n        min_val = (current_min < min_val) ? current_min : min_val;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT_MAX;\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    size_t stride = 2;\n\n    for (size_t i = 0; i < length; i += vl * stride) {\n        size_t remaining = length - i;\n        size_t current_vl = __riscv_vsetvl_e32m1(remaining);\n\n        vint32m1_t v_src = __riscv_vlse32_v_i32m1(src + i * stride, stride * sizeof(int), current_vl);\n        vint32m1_t v_min = __riscv_vredmin_vs_i32m1_i32m1(v_src, __riscv_vmv_s_x_i32m1(INT_MAX, current_vl), current_vl);\n        \n        int current_min = __riscv_vmv_x_s_i32m1_i32(v_min);\n        min_val = (current_min < min_val) ? current_min : min_val;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT_MAX;\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    size_t stride = 2 * sizeof(int);\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(length - i);\n        vint32m1_t v_src = __riscv_vlse32_v_i32m1(src + i * 2, stride, vlmax);\n        \n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(v_src, v_src, vlmax);\n        vint32m1_t v_min = __riscv_vfirst_m_i32m1(mask, vlmax);\n        \n        if (v_min != -1) {\n            int current_min = __riscv_vmv_x_s_i32m1_i32(v_min);\n            min_val = (current_min < min_val) ? current_min : min_val;\n        }\n    }\n\n    return (min_val == INT_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    int min_val = INT_MAX;\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    size_t stride = 2;\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(length - i);\n        vint32m1_t v_src = __riscv_vlse32_v_i32m1(src + i * stride, stride * sizeof(int), vlmax);\n        \n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(v_src, v_src, vlmax);\n        int local_min = __riscv_vfirst_m_b32(mask, vlmax);\n        \n        if (local_min != -1) {\n            int candidate = __riscv_vmv_x_s_i32m1_i32(v_src);\n            min_val = (candidate < min_val) ? candidate : min_val;\n        }\n    }\n\n    return (min_val == INT_MAX) ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vint32m1_t v_src;\n    vint32m1_t v_arith_shift;\n    vuint32m1_t v_unsigned_src;\n    vint32m1_t v_logical_shift;\n    vint32m1_t v_result;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Arithmetic right shift\n        v_arith_shift = __riscv_vsra_vx_i32m1(v_src, shift, vl);\n        \n        // Convert to unsigned and perform logical right shift\n        v_unsigned_src = __riscv_vreinterpret_v_i32m1_u32m1(v_src);\n        v_logical_shift = __riscv_vreinterpret_v_u32m1_i32m1(__riscv_vsrl_vx_u32m1(v_unsigned_src, shift, vl));\n        \n        // Add arithmetic and logical shifts\n        v_result = __riscv_vadd_vv_i32m1(v_arith_shift, v_logical_shift, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t vec_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Arithmetic right shift\n        vint32m1_t arith_shift = __riscv_vsra_vx_i32m1(vec_src, shift, vl);\n        \n        // Convert to unsigned and perform logical right shift\n        vuint32m1_t unsigned_src = __riscv_vreinterpret_v_i32m1_u32m1(vec_src);\n        vuint32m1_t logical_shift = __riscv_vsrl_vx_u32m1(unsigned_src, shift, vl);\n        \n        // Convert logical shift back to signed int\n        vint32m1_t signed_logical_shift = __riscv_vreinterpret_v_u32m1_i32m1(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        vint32m1_t result = __riscv_vadd_vv_i32m1(arith_shift, signed_logical_shift, vl);\n        \n        // Store result in destination\n        __riscv_vse32_v_i32m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Arithmetic right shift\n        vint32m1_t v_arith_shift = __riscv_vsra_vx_i32m1(v_src, shift, vl);\n        \n        // Convert to unsigned and perform logical right shift\n        vuint32m1_t v_unsigned = __riscv_vreinterpret_v_i32m1_u32m1(v_src);\n        vuint32m1_t v_logical_shift = __riscv_vsrl_vx_u32m1(v_unsigned, shift, vl);\n        \n        // Convert logical shift back to signed int\n        vint32m1_t v_logical_int = __riscv_vreinterpret_v_u32m1_i32m1(v_logical_shift);\n        \n        // Add arithmetic and logical shifts\n        vint32m1_t v_result = __riscv_vadd_vv_i32m1(v_arith_shift, v_logical_int, vl);\n        \n        // Store result in destination\n        __riscv_vse32_v_i32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Arithmetic right shift\n        vint32m1_t v_arith_shift = __riscv_vsra_vx_i32m1(v_src, shift, vl);\n        \n        // Convert to unsigned and perform logical right shift\n        vuint32m1_t v_unsigned = __riscv_vreinterpret_v_i32m1_u32m1(v_src);\n        vuint32m1_t v_logical_shift = __riscv_vsrl_vx_u32m1(v_unsigned, shift, vl);\n        vint32m1_t v_logical_int = __riscv_vreinterpret_v_u32m1_i32m1(v_logical_shift);\n        \n        // Add arithmetic and logical shifts\n        vint32m1_t v_result = __riscv_vadd_vv_i32m1(v_arith_shift, v_logical_int, vl);\n        \n        // Store result in destination\n        __riscv_vse32_v_i32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vint32m1_t v_src = __riscv_vle32_v_i32m1(src + i, vl);\n        \n        // Arithmetic right shift\n        vint32m1_t v_arith_shift = __riscv_vsra_vx_i32m1(v_src, shift, vl);\n        \n        // Logical right shift (convert to unsigned, shift, then convert back)\n        vuint32m1_t v_unsigned = __riscv_vreinterpret_v_i32m1_u32m1(v_src);\n        vuint32m1_t v_logical_shift = __riscv_vsrl_vx_u32m1(v_unsigned, shift, vl);\n        vint32m1_t v_logical_int = __riscv_vreinterpret_v_u32m1_i32m1(v_logical_shift);\n        \n        // Add arithmetic and logical shifts\n        vint32m1_t v_result = __riscv_vadd_vv_i32m1(v_arith_shift, v_logical_int, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(total_elements);\n    \n    // Initialize sum vector\n    vint64m2_t sum_vec = __riscv_vmv_v_x_i64m2(0, vl);\n    \n    // Process matrix in vector chunks\n    for (size_t i = 0; i < total_elements; i += vl) {\n        // Determine vector length for current iteration\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of integers\n        vint32m1_t vec = __riscv_vle32_v_i32m1(matrix + i, vl);\n        \n        // Convert 32-bit integers to 64-bit integers\n        vint64m2_t vec_64 = __riscv_vwcvt_x_x_v_i64m2(vec, vl);\n        \n        // Add to running sum vector\n        sum_vec = __riscv_vadd_vv_i64m2(sum_vec, vec_64, vl);\n    }\n    \n    // Reduce vector sum to scalar\n    total_sum = __riscv_vredsum_vs_i64m2_i64m1(sum_vec, __riscv_vmv_v_x_i64m1(0, 1), total_elements);\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; ) {\n        vl = __riscv_vsetvl_e32m8(total_elements - i);\n        vint32m8_t v_elements = __riscv_vle32_v_i32m8(matrix + i, vl);\n        vint64m8_t v_elements_64 = __riscv_vzext_vf2_i64m8(v_elements, vl);\n        vint64m8_t v_sum = __riscv_vredsum_vs_i64m8_i64m1(v_elements_64, __riscv_vmv_v_x_i64m8(0, vl), vl);\n        \n        sum += __riscv_vmv_x_s_i64m1_i64(v_sum);\n        \n        i += vl;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    \n    size_t vl = __riscv_vsetvl_e32m8(total_elements);\n    vint32m8_t v_sum = __riscv_vmv_v_x_i32m8(0, vl);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m8(total_elements - i);\n        vint32m8_t v_data = __riscv_vle32_v_i32m8(matrix + i, vlmax);\n        v_sum = __riscv_vadd_vv_i32m8(v_sum, v_data, vlmax);\n    }\n    \n    vint64m8_t v_sum_wide = __riscv_vwcvt_x_x_v_i64m8(v_sum, vl);\n    vint64m1_t v_scalar_sum = __riscv_vredsum_vs_i64m8_i64m1(v_sum_wide, __riscv_vmv_v_x_i64m1(0, 1), vl);\n    \n    sum = __riscv_vmv_x_s_i64m1_i64(v_scalar_sum);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; ) {\n        vl = __riscv_vsetvl_e32m8(total_elements - i);\n        \n        vint32m8_t v_data = __riscv_vle32_v_i32m8(matrix + i, vl);\n        vint64m8_t v_sum = __riscv_vwcvt_x_x_v_i64m8(v_data, vl);\n        vint64m8_t v_partial_sum = __riscv_vredsum_vs_i64m8_i64m1(v_sum, __riscv_vmv_v_x_i64m1(0, vl), vl);\n        \n        sum += __riscv_vmv_x_s_i64m1_i64(v_partial_sum);\n        \n        i += vl;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_length;\n    vint32m1_t v_data;\n    vint64m2_t v_sum = vmv_v_x_i64m2(0, 16);\n\n    for (size_t i = 0; i < total_elements; i += vector_length) {\n        vector_length = __riscv_vsetvl_e32m1(total_elements - i);\n        v_data = __riscv_vle32_v_i32m1(matrix + i, vector_length);\n        \n        vint64m2_t v_converted = __riscv_vwadd_vx_i64m2(v_data, 0, vector_length);\n        v_sum = __riscv_vadd_vv_i64m2(v_sum, v_converted, vector_length);\n    }\n\n    total_sum = __riscv_vmv_x_s_i64m2_i64(__riscv_vredsum_vs_i64m2_i64m2(v_sum, vmv_v_x_i64m2(0, 16), total_elements));\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t max_vec = __riscv_vle8_v_i8m1(src, vl);\n    vint8m1_t current_vec;\n    size_t current_index = 0;\n\n    while (current_index + vl < length) {\n        current_index += vl;\n        current_vec = __riscv_vle8_v_i8m1(src + current_index, vl);\n        \n        vbool8_t mask = __riscv_vfgt_vv_i8m1_b8(current_vec, max_vec);\n        max_vec = __riscv_vmerge_vvm_i8m1(max_vec, current_vec, mask, vl);\n        max_index = mask ? current_index : max_index;\n    }\n\n    int8_t max_val = __riscv_vmv_x_s_i8m1_i8(max_vec);\n    \n    for (size_t i = current_index; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t max_vec = __riscv_vle8_v_i8m1(src, vl);\n    vint8m1_t current_vec;\n    size_t current_index = 0;\n\n    while (current_index + vl < length) {\n        current_index += vl;\n        current_vec = __riscv_vle8_v_i8m1(src + current_index, vl);\n        \n        vbool8_t mask = __riscv_vmsgt_vv_i8m1_b8(current_vec, max_vec);\n        if (__riscv_vmfirst_m_b8(mask, vl) != -1) {\n            max_vec = __riscv_vmerge_vvm_i8m1(max_vec, current_vec, mask, vl);\n            max_index = current_index;\n        }\n        \n        vl = __riscv_vsetvl_e8m1(length - current_index);\n    }\n\n    int8_t max_val = __riscv_vmv_x_s_i8m1_i8(max_vec);\n    \n    // Scalar fallback for final comparison\n    for (size_t i = max_index; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t max_vec = __riscv_vle8_v_i8m1(src, vl);\n    vint8m1_t current_vec;\n    size_t current_index = 0;\n\n    while (current_index + vl < length) {\n        current_index += vl;\n        current_vec = __riscv_vle8_v_i8m1(src + current_index, vl);\n        \n        vbool8_t mask = __riscv_vmsgt_vv_i8m1_b8(current_vec, max_vec);\n        if (__riscv_vmfirst_m_b8(mask, vl) != -1) {\n            max_vec = __riscv_vmerge_vvm_i8m1(max_vec, current_vec, mask, vl);\n            max_index = current_index;\n        }\n        \n        vl = __riscv_vsetvl_e8m1(length - current_index);\n    }\n\n    int8_t max_val = __riscv_vmv_x_s_i8m1_i8(max_vec);\n    \n    // Fallback to scalar search for final verification\n    for (size_t i = max_index; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t max_vec = __riscv_vle8_v_i8m1(src, vl);\n    vint8m1_t current_vec;\n    size_t current_index = 0;\n\n    while (current_index + vl < length) {\n        current_index += vl;\n        current_vec = __riscv_vle8_v_i8m1(src + current_index, vl);\n        \n        vbool8_t mask = __riscv_vmsgt_vv_i8m1_b8(current_vec, max_vec);\n        if (__riscv_vmfirst_m_b8(mask, vl) != -1) {\n            max_vec = __riscv_vmerge_vvm_i8m1(max_vec, current_vec, mask, vl);\n            max_index = current_index;\n        }\n        \n        vl = __riscv_vsetvl_e8m1(length - current_index);\n    }\n\n    int8_t max_val = __riscv_vmv_x_s_i8m1_i8(max_vec);\n    \n    // Fallback to scalar search for remaining elements\n    for (size_t i = current_index; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    vint8m1_t max_vec = __riscv_vle8_v_i8m1(src, vl);\n    vint8m1_t current_vec;\n    size_t current_index = 0;\n\n    while (current_index + vl < length) {\n        current_index += vl;\n        current_vec = __riscv_vle8_v_i8m1(src + current_index, vl);\n        \n        vbool8_t mask = __riscv_vmsgt_vv_i8m1_b8(current_vec, max_vec);\n        if (__riscv_vmfirst_m_b8(mask, vl) != -1) {\n            max_vec = __riscv_vmerge_vvm_i8m1(max_vec, current_vec, mask, vl);\n            max_index = current_index;\n        }\n    }\n\n    int8_t max_val = __riscv_vmv_x_s_i8m1_i8(max_vec);\n    \n    for (size_t i = current_index; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source arrays\n        vuint16m1_t vec_src1 = __riscv_vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vec_src2 = __riscv_vle16_v_u16m1(src2 + i, vl);\n        \n        // Create mask based on index and given mask\n        vbool16_t blend_mask = __riscv_vmseq_vx_u16m1_b16(\n            __riscv_vand_vx_u16m1(\n                __riscv_vid_v_u16m1(vl), \n                mask, \n                vl\n            ), \n            0, \n            vl\n        );\n        \n        // Blend vectors using mask\n        vuint16m1_t result = __riscv_vmerge_vvm_u16m1(vec_src2, vec_src1, blend_mask, vl);\n        \n        // Store result\n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source arrays\n        vuint16m1_t vec_src1 = __riscv_vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vec_src2 = __riscv_vle16_v_u16m1(src2 + i, vl);\n        \n        // Create mask based on index and given mask\n        vbool16_t blend_mask = __riscv_vmseq_vx_u16m1_b16(\n            __riscv_vand_vx_u16m1(__riscv_vid_v_u16m1(vl), mask, vl), \n            0, \n            vl\n        );\n        \n        // Blend vectors using mask\n        vuint16m1_t result = __riscv_vmerge_vvm_u16m1(vec_src2, vec_src1, blend_mask, vl);\n        \n        // Store result\n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source arrays\n        vuint16m1_t v_src1 = __riscv_vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t v_src2 = __riscv_vle16_v_u16m1(src2 + i, vl);\n        \n        // Create mask based on index and given mask\n        vbool16_t v_mask = __riscv_vmseq_vx_u16m1_b16(\n            __riscv_vand_vx_u16m1(\n                __riscv_vid_v_u16m1(vl), \n                mask, \n                vl\n            ), \n            0, \n            vl\n        );\n        \n        // Blend vectors using mask\n        vuint16m1_t v_result = __riscv_vmerge_vvm_u16m1(v_src2, v_src1, v_mask, vl);\n        \n        // Store result\n        __riscv_vse16_v_u16m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source vectors\n        vuint16m1_t vec1 = __riscv_vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vec2 = __riscv_vle16_v_u16m1(src2 + i, vl);\n        \n        // Create mask vector based on index and mask condition\n        vbool16_t mask_vec = __riscv_vmseq_vx_u16m1_b16((vuint16m1_t)__riscv_vid_v_u16m1(vl), mask, vl);\n        \n        // Blend vectors using mask\n        vuint16m1_t result = __riscv_vmerge_vvm_u16m1(vec2, vec1, mask_vec, vl);\n        \n        // Store result\n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source arrays\n        vuint16m1_t vec_src1 = __riscv_vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t vec_src2 = __riscv_vle16_v_u16m1(src2 + i, vl);\n        \n        // Create mask based on index and given mask\n        vbool16_t blend_mask = __riscv_vmseq_vx_u16m1_b16(\n            __riscv_vand_vx_u16m1(\n                __riscv_vid_v_u16m1(vl), \n                mask, \n                vl\n            ), \n            0, \n            vl\n        );\n        \n        // Blend vectors using mask\n        vuint16m1_t result = __riscv_vmerge_vvm_u16m1(vec_src2, vec_src1, blend_mask, vl);\n        \n        // Store result\n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t vec_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Population count vector\n        vuint32m1_t vec_popcount = __riscv_vcpop_v_u32m1(vec_src, vl);\n        \n        // Store result to destination\n        __riscv_vse32_v_u32m1(dst + i, vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Initialize destination vector\n        vuint32m1_t v_dst = __riscv_vmv_v_x_u32m1(0, vl);\n        \n        // Perform population count\n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m1_t v_mask = __riscv_vsrl_vx_u32m1(v_src, bit, vl);\n            v_mask = __riscv_vand_vx_u32m1(v_mask, 1, vl);\n            v_dst = __riscv_vadd_vv_u32m1(v_dst, v_mask, vl);\n        }\n        \n        // Store result\n        __riscv_vse32_v_u32m1(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t vec_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Population count vector\n        vuint32m1_t vec_popcount = __riscv_vcpop_v_u32m1(vec_src, vl);\n        \n        // Store result to destination\n        __riscv_vse32_v_u32m1(dst + i, vec_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Population count vector\n        vuint32m1_t v_popcount = __riscv_vcpop_v_u32m1(v_src, vl);\n        \n        // Store result to destination\n        __riscv_vse32_v_u32m1(dst + i, v_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Population count vector\n        vuint32m1_t v_popcount = __riscv_vcpop_v_u32m1(v_src, vl);\n        \n        // Store result to destination\n        __riscv_vse32_v_u32m1(dst + i, v_popcount, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vint16m1_t vec1 = __riscv_vle16_v_i16m1(src1 + i, vl);\n        vint16m1_t vec2 = __riscv_vle16_v_i16m1(src2 + i, vl);\n        \n        vint16m1_t result = __riscv_vsaddu_vv_u16m1(vec1, vec2, vl);\n        \n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vint16m1_t vec1 = __riscv_vle16_v_i16m1(src1 + i, vl);\n        vint16m1_t vec2 = __riscv_vle16_v_i16m1(src2 + i, vl);\n        \n        vint16m1_t result = __riscv_vsaddu_vv_u16m1(vec1, vec2, vl);\n        \n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vint16m1_t vec1 = __riscv_vle16_v_i16m1(src1 + i, vl);\n        vint16m1_t vec2 = __riscv_vle16_v_i16m1(src2 + i, vl);\n        \n        vint16m1_t result = __riscv_vsaddu_vv_u16m1(vec1, vec2, vl);\n        \n        __riscv_vse16_v_u16m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vuint16m1_t v_src1 = __riscv_vle16_v_u16m1(src1 + i, vl);\n        vuint16m1_t v_src2 = __riscv_vle16_v_u16m1(src2 + i, vl);\n        \n        vuint16m1_t v_result = __riscv_vsaddu_vv_u16m1(v_src1, v_src2, vl);\n        \n        __riscv_vse16_v_u16m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    vint16m1_t va, vb, vc;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        va = __riscv_vle16_v_i16m1(src1 + i, vl);\n        vb = __riscv_vle16_v_i16m1(src2 + i, vl);\n        \n        vc = __riscv_vsaddu_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(dst + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p);\n            vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                \n                if (a_val >= -100 && a_val <= 100) {\n                    vfloat64m1_t b_vec = __riscv_vle64_v_f64m1(&B[k * p], vl);\n                    vfloat64m1_t b_filtered_vec = __riscv_vfmul_vf_f64m1(b_vec, (b_vec >= -100 && b_vec <= 100) ? a_val : 0.0, vl);\n                    sum_vec = __riscv_vfadd_vv_f64m1(sum_vec, b_filtered_vec, vl);\n                }\n            }\n\n            C[i * p + j] = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(n);\n            vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k += vl) {\n                vfloat64m1_t a_vec = __riscv_vle64_v_f64m1(&A[i*n + k], vl);\n                vfloat64m1_t b_vec = __riscv_vle64_v_f64m1(&B[k*p + j], vl);\n                \n                // Check range condition\n                vbool64_t mask_a = __riscv_vfmlt_vf_f64m1_b64(a_vec, 100.0, vl) & \n                                   __riscv_vfmgt_vf_f64m1_b64(a_vec, -100.0, vl);\n                vbool64_t mask_b = __riscv_vfmlt_vf_f64m1_b64(b_vec, 100.0, vl) & \n                                   __riscv_vfmgt_vf_f64m1_b64(b_vec, -100.0, vl);\n                vbool64_t mask = __riscv_vmand_mm_b64(mask_a, mask_b, vl);\n\n                vfloat64m1_t mul_vec = __riscv_vfmul_vv_f64m1_m(mask, a_vec, b_vec, vl);\n                sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(sum_vec, mul_vec, vl);\n            }\n\n            C[i*p + j] = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p);\n            vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, vl);\n            \n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                \n                if (a_val >= -100 && a_val <= 100) {\n                    vfloat64m1_t b_vec = __riscv_vle64_v_f64m1(&B[k * p], vl);\n                    vfloat64m1_t masked_b_vec = __riscv_vfmul_vf_f64m1_m(\n                        __riscv_vmfge_vf_f64m1_b(b_vec, -100, vl) & \n                        __riscv_vmfle_vf_f64m1_b(b_vec, 100, vl),\n                        b_vec, a_val, vl\n                    );\n                    sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(sum_vec, masked_b_vec, vl);\n                }\n            }\n            \n            C[i * p + j] = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(n);\n            vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k += vl) {\n                vl = __riscv_vsetvl_e64m1(n - k);\n                \n                vfloat64m1_t a_vec = __riscv_vle64_v_f64m1(A + i * n + k, vl);\n                vfloat64m1_t b_vec = __riscv_vle64_v_f64m1(B + k * p + j, vl);\n                \n                // Mask for range check\n                vbool64_t a_mask = __riscv_vmfge_vf_f64m1_b64(a_vec, -100.0, vl);\n                a_mask = __riscv_vmfle_vf_f64m1_b64(a_vec, 100.0, a_mask, vl);\n                \n                vbool64_t b_mask = __riscv_vmfge_vf_f64m1_b64(b_vec, -100.0, vl);\n                b_mask = __riscv_vmfle_vf_f64m1_b64(b_vec, 100.0, b_mask, vl);\n                \n                // Combine masks\n                vbool64_t range_mask = __riscv_vmand_mm_b64(a_mask, b_mask, vl);\n                \n                // Masked multiply-add\n                vfloat64m1_t mul_vec = __riscv_vfmul_vv_f64m1_m(range_mask, a_vec, b_vec, vl);\n                sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(mul_vec, sum_vec, vl);\n            }\n            \n            // Store result\n            C[i * p + j] = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p - j);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k++) {\n                // Load A[i*n + k]\n                double a_val = A[i*n + k];\n                \n                // Skip if A[i*n + k] outside range\n                if (a_val < -100 || a_val > 100) continue;\n\n                // Load vector of B[k*p + j : k*p + j + vl]\n                vfloat64m1_t b_vec = __riscv_vle64_v_f64m1(&B[k*p + j], vl);\n\n                // Mask for B values in range\n                vbool64_t mask = __riscv_vmfge_vf_f64m1_b64(b_vec, -100, vl);\n                mask = __riscv_vmfle_vf_f64m1_b64(b_vec, 100, vl);\n\n                // Multiply and accumulate with range check\n                vfloat64m1_t a_vec = __riscv_vfmv_v_f_f64m1(a_val, vl);\n                sum_vec = __riscv_vfmadd_vv_f64m1_m(mask, sum_vec, a_vec, b_vec, vl);\n            }\n\n            // Store result\n            __riscv_vse64_v_f64m1(&C[i*p + j], sum_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process elements in vector chunks\n            size_t vec_len = dim3;\n            size_t vl = __riscv_vsetvl_e64m1(vec_len);\n            \n            for (size_t k = 0; k < dim3; k += vl) {\n                vl = __riscv_vsetvl_e64m1(vec_len - k);\n                \n                // Load vectors\n                vint64m1_t va = __riscv_vle64_v_i64m1(A + base_idx + k, vl);\n                vint64m1_t vb = __riscv_vle64_v_i64m1(B + base_idx + k, vl);\n                \n                // Add vectors\n                vint64m1_t vc = __riscv_vadd_vv_i64m1(va, vb, vl);\n                \n                // Store result\n                __riscv_vse64_v_i64m1(C + base_idx + k, vc, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process vector elements\n            size_t vec_len = dim3;\n            size_t vl;\n            for (size_t k = 0; k < vec_len; k += vl) {\n                vl = __riscv_vsetvl_e64m1(vec_len - k);\n                \n                // Load vectors\n                vint64m1_t va = __riscv_vle64_v_i64m1(A + base_idx + k, vl);\n                vint64m1_t vb = __riscv_vle64_v_i64m1(B + base_idx + k, vl);\n                \n                // Add vectors\n                vint64m1_t vc = __riscv_vadd_vv_i64m1(va, vb, vl);\n                \n                // Store result\n                __riscv_vse64_v_i64m1(C + base_idx + k, vc, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process vector elements\n            size_t vec_len = dim3;\n            size_t vl;\n            for (size_t k = 0; k < vec_len; k += vl) {\n                vl = __riscv_vsetvl_e64m1(vec_len - k);\n                \n                // Load vectors\n                vint64m1_t va = __riscv_vle64_v_i64m1(A + base_idx + k, vl);\n                vint64m1_t vb = __riscv_vle64_v_i64m1(B + base_idx + k, vl);\n                \n                // Add vectors\n                vint64m1_t vc = __riscv_vadd_vv_i64m1(va, vb, vl);\n                \n                // Store result\n                __riscv_vse64_v_i64m1(C + base_idx + k, vc, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process vector elements\n            size_t vec_len = dim3;\n            size_t vl;\n            for (size_t k = 0; k < vec_len; k += vl) {\n                vl = __riscv_vsetvl_e64m1(vec_len - k);\n                \n                // Load vectors\n                vint64m1_t va = __riscv_vle64_v_i64m1(A + base_idx + k, vl);\n                vint64m1_t vb = __riscv_vle64_v_i64m1(B + base_idx + k, vl);\n                \n                // Add vectors\n                vint64m1_t vc = __riscv_vadd_vv_i64m1(va, vb, vl);\n                \n                // Store result\n                __riscv_vse64_v_i64m1(C + base_idx + k, vc, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t base_idx = (i * dim2 + j) * dim3;\n            \n            // Process vector elements\n            size_t vec_len = dim3;\n            size_t vl = __riscv_vsetvl_e64m1(vec_len);\n            \n            for (size_t k = 0; k < vec_len; k += vl) {\n                vl = __riscv_vsetvl_e64m1(vec_len - k);\n                \n                // Load vectors\n                vint64m1_t va = __riscv_vle64_v_i64m1(A + base_idx + k, vl);\n                vint64m1_t vb = __riscv_vle64_v_i64m1(B + base_idx + k, vl);\n                \n                // Add vectors\n                vint64m1_t vc = __riscv_vadd_vv_i64m1(va, vb, vl);\n                \n                // Store result\n                __riscv_vse64_v_i64m1(C + base_idx + k, vc, vl);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t va = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vb = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        vfloat32m1_t vc = __riscv_vfadd_vv_f32m1(va, vb, vl);\n        \n        vint32m1_t vi = __riscv_vfcvt_rtz_x_f_v_i32m1(vc, vl);\n        vfloat32m1_t vr = __riscv_vfcvt_f_x_v_f32m1(vi, vl);\n        \n        __riscv_vse32_v_f32m1(dst + i, vr, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        vfloat32m1_t sum = __riscv_vfadd_vv_f32m1(vec1, vec2, vl);\n        \n        vint32m1_t rounded = __riscv_vfcvt_rtz_x_f_v_i32m1(sum, vl);\n        vfloat32m1_t float_rounded = __riscv_vfcvt_f_x_v_f32m1(rounded, vl);\n        \n        __riscv_vse32_v_f32m1(dst + i, float_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, vc;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        va = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vb = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        vc = __riscv_vfadd_vv_f32m1(va, vb, vl);\n        vc = __riscv_vfcvt_rtz_x_f_v_f32m1(vc, vl);\n        vc = __riscv_vfcvt_f_x_v_f32m1(vc, vl);\n        \n        __riscv_vse32_v_f32m1(dst + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t va = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vb = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        vfloat32m1_t vc = __riscv_vfadd_vv_f32m1(va, vb, vl);\n        \n        vint32m1_t vi = __riscv_vfcvt_rtz_x_f_v_i32m1(vc, vl);\n        vfloat32m1_t vr = __riscv_vfcvt_f_x_v_f32m1(vi, vl);\n        \n        __riscv_vse32_v_f32m1(dst + i, vr, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        vfloat32m1_t sum = __riscv_vfadd_vv_f32m1(vec1, vec2, vl);\n        \n        vint32m1_t rounded = __riscv_vfcvt_rtz_x_f_v_i32m1(sum, vl);\n        vfloat32m1_t float_rounded = __riscv_vfcvt_f_x_v_f32m1(rounded, vl);\n        \n        __riscv_vse32_v_f32m1(dst + i, float_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vectors\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        // Create mask for index multiple of 2\n        vbool32_t index_mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vid_v_u32m1(vl), 0, vl);\n        index_mask = __riscv_vmand_mm_b32(index_mask, index_mask, vl);\n        \n        // Calculate absolute difference\n        vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n        diff = __riscv_vfabs_v_f32m1(diff, vl);\n        \n        // Create mask for difference within 50\n        vbool32_t diff_mask = __riscv_vmfle_vf_f32m1_b32(diff, 50.0f, vl);\n        \n        // Combine masks\n        vbool32_t final_mask = __riscv_vmand_mm_b32(index_mask, diff_mask, vl);\n        \n        // Multiply where conditions are met\n        vfloat32m1_t result = __riscv_vfmul_vv_f32m1_m(final_mask, vec1, vec2, vl);\n        \n        // Round up\n        result = __riscv_vfceil_v_f32m1_m(final_mask, result, vl);\n        \n        // Set to -1 where conditions are not met\n        result = __riscv_vfmerge_vfm_f32m1(final_mask, -1.0f, result, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vectors\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        // Create mask for index multiple of 2\n        vbool32_t index_mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vid_v_u32m1(vl), 0, vl);\n        index_mask = __riscv_vmand_mm_b32(index_mask, index_mask, vl);\n        \n        // Calculate absolute difference\n        vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n        diff = __riscv_vfabs_v_f32m1(diff, vl);\n        \n        // Create mask for difference within 50\n        vbool32_t diff_mask = __riscv_vmfle_vf_f32m1_b32(diff, 50.0f, vl);\n        \n        // Combine masks\n        vbool32_t final_mask = __riscv_vmand_mm_b32(index_mask, diff_mask, vl);\n        \n        // Multiply where conditions are met\n        vfloat32m1_t mul_result = __riscv_vfmul_vv_f32m1_m(final_mask, vec1, vec2, vl);\n        \n        // Round up result where conditions are met\n        mul_result = __riscv_vfceil_v_f32m1_m(final_mask, mul_result, vl);\n        \n        // Set -1 where conditions are not met\n        mul_result = __riscv_vfmerge_vfm_f32m1(final_mask, -1.0f, mul_result, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(dst + i, mul_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vectors\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        // Create mask for index multiple of 2\n        vbool32_t index_mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vid_v_u32m1(vl), 0, vl);\n        index_mask = __riscv_vmand_mm_b32(index_mask, index_mask, vl);\n        \n        // Calculate absolute difference\n        vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n        diff = __riscv_vfabs_v_f32m1(diff, vl);\n        \n        // Create mask for difference within 50\n        vbool32_t diff_mask = __riscv_vmfle_vf_f32m1_b32(diff, 50.0f, vl);\n        \n        // Combine masks\n        vbool32_t final_mask = __riscv_vmand_mm_b32(index_mask, diff_mask, vl);\n        \n        // Multiply where conditions are met\n        vfloat32m1_t result = __riscv_vfmul_vv_f32m1_m(final_mask, vec1, vec2, vl);\n        \n        // Round up where conditions are met\n        result = __riscv_vfceil_v_f32m1_m(final_mask, result, vl);\n        \n        // Set to -1 where conditions are not met\n        result = __riscv_vfmerge_vfm_f32m1(final_mask, -1.0f, result, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vectors\n        vfloat32m1_t v_src1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t v_src2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        // Create mask for index multiple of 2\n        vbool32_t v_index_mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vid_v_u32m1(vl), 0, vl);\n        v_index_mask = __riscv_vmand_mm_b32(v_index_mask, v_index_mask, vl);\n        \n        // Calculate absolute difference\n        vfloat32m1_t v_diff = __riscv_vfsub_vv_f32m1(v_src1, v_src2, vl);\n        v_diff = __riscv_vfabs_v_f32m1(v_diff, vl);\n        \n        // Create mask for difference within 50\n        vbool32_t v_diff_mask = __riscv_vmfle_vf_f32m1_b32(v_diff, 50.0f, vl);\n        \n        // Combine masks\n        vbool32_t v_final_mask = __riscv_vmand_mm_b32(v_index_mask, v_diff_mask, vl);\n        \n        // Multiply and round up\n        vfloat32m1_t v_result = __riscv_vfmul_vv_f32m1_m(v_final_mask, v_src1, v_src2, vl);\n        v_result = __riscv_vfceil_v_f32m1_m(v_final_mask, v_result, vl);\n        \n        // Set non-matching elements to -1\n        v_result = __riscv_vfmerge_vfm_f32m1(v_final_mask, -1.0f, v_result, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vectors\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(src2 + i, vl);\n        \n        // Create index vector\n        vuint32m1_t index_vec = __riscv_vid_v_u32m1(vl);\n        \n        // Compute absolute difference\n        vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n        vfloat32m1_t abs_diff = __riscv_vfabs_v_f32m1(diff, vl);\n        \n        // Create mask for conditions\n        vbool32_t diff_mask = __riscv_vmflt_vf_f32m1_b32(abs_diff, 50.0f, vl);\n        vbool32_t index_mask = __riscv_vmseq_vx_u32m1_b32(index_vec, 0, vl);\n        vbool32_t combined_mask = __riscv_vmand_mm_b32(diff_mask, index_mask, vl);\n        \n        // Compute result with mask\n        vfloat32m1_t mul_result = __riscv_vfmul_vv_f32m1(vec1, vec2, vl);\n        vfloat32m1_t rounded_result = __riscv_vfceil_v_f32m1(mul_result, vl);\n        \n        // Masked selection\n        vfloat32m1_t result = __riscv_vfmerge_vfm_f32m1(rounded_result, -1.0f, combined_mask, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        vfloat64m1_t vec_mat = __riscv_vle64_v_f64m1(mat + i, vl);\n        vfloat64m1_t vec_result = __riscv_vfmul_vf_f64m1(vec_mat, scalar, vl);\n        \n        __riscv_vse64_v_f64m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        // Load vector from source matrix\n        vfloat64m1_t vec_mat = __riscv_vle64_v_f64m1(mat + i, vl);\n        \n        // Multiply vector with scalar \n        vfloat64m1_t vec_result = __riscv_vfmul_vf_f64m1(vec_mat, scalar, vl);\n        \n        // Store result in destination matrix\n        __riscv_vse64_v_f64m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        // Load vector of matrix elements\n        vfloat64m1_t vec_mat = __riscv_vle64_v_f64m1(mat + i, vl);\n        \n        // Multiply matrix elements with scalar\n        vfloat64m1_t vec_result = __riscv_vfmul_vf_f64m1(vec_mat, scalar, vl);\n        \n        // Store result in destination matrix\n        __riscv_vse64_v_f64m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        // Load vector of matrix values\n        vfloat64m1_t vec_mat = __riscv_vle64_v_f64m1(mat + i, vl);\n        \n        // Multiply matrix values with scalar\n        vfloat64m1_t vec_result = __riscv_vfmul_vf_f64m1(vec_mat, scalar, vl);\n        \n        // Store result in destination matrix\n        __riscv_vse64_v_f64m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        // Load vector from source matrix\n        vfloat64m1_t vec_mat = __riscv_vle64_v_f64m1(mat + i, vl);\n        \n        // Multiply vector with scalar \n        vfloat64m1_t vec_result = __riscv_vfmul_vf_f64m1(vec_mat, scalar, vl);\n        \n        // Store result to destination matrix\n        __riscv_vse64_v_f64m1(dst + i, vec_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum_vec = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(vec, vec, vl);\n            sum_vec = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        }\n        \n        float norm = sqrtf(__riscv_vfmv_f_s_f32m1_f32(sum_vec));\n        \n        // Normalize row\n        vl = __riscv_vsetvl_e32m1(n);\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t normalized_vec = __riscv_vfdiv_vf_f32m1(vec, norm, vl);\n            __riscv_vse32_v_f32m1(row + j, normalized_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared values\n        vfloat32m1_t sum_vec = __riscv_vfmv_s_f_f32m1(0.0f, n);\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(vec, vec, vl);\n            sum_vec = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        }\n        \n        // Compute L2 norm (square root of sum of squares)\n        float sum_scalar = __riscv_vfmv_f_s_f32m1_f32(sum_vec);\n        float norm = sqrtf(sum_scalar);\n        \n        // Normalize row by dividing by norm\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t normalized_vec = __riscv_vfdiv_vf_f32m1(vec, norm, vl);\n            __riscv_vse32_v_f32m1(row + j, normalized_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using vector instructions\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum_vec = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(vec, vec, vl);\n            sum_vec = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        }\n        \n        float norm = sqrtf(__riscv_vfmv_f_s_f32m1_f32(sum_vec));\n        \n        // Normalize row using vector instructions\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t normalized_vec = __riscv_vfdiv_vf_f32m1(vec, norm, vl);\n            __riscv_vse32_v_f32m1(row + j, normalized_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using vector instructions\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum_vec = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(vec, vec, vl);\n            sum_vec = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        }\n        \n        float norm = sqrtf(__riscv_vfmv_f_s_f32m1_f32(sum_vec));\n        \n        // Normalize row using vector instructions\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t normalized_vec = __riscv_vfdiv_vf_f32m1(vec, norm, vl);\n            __riscv_vse32_v_f32m1(row + j, normalized_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using vector instructions\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum_vec = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(vec, vec, vl);\n            sum_vec = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        }\n        \n        float norm = sqrtf(__riscv_vfmv_f_s_f32m1_f32(sum_vec));\n        \n        // Normalize row using vector instructions\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vfloat32m1_t vec = __riscv_vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t normalized_vec = __riscv_vfdiv_vf_f32m1(vec, norm, vl);\n            __riscv_vse32_v_f32m1(row + j, normalized_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p);\n            vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k++) {\n                vfloat64m1_t mat2_vec = __riscv_vle64_v_f64m1(mat2 + k * p + j, vl);\n                vfloat64m1_t mat1_val = __riscv_vfmv_s_f_f64m1(mat1[i * n + k], vl);\n                vfloat64m1_t prod_vec = __riscv_vfmul_vv_f64m1(mat1_val, mat2_vec, vl);\n                sum_vec = __riscv_vfadd_vv_f64m1(sum_vec, prod_vec, vl);\n            }\n\n            double sum = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p);\n            vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, vl);\n            \n            for (size_t k = 0; k < n; k++) {\n                // Load row of mat1\n                vfloat64m1_t mat1_vec = __riscv_vle64_v_f64m1(mat1 + i * n + k, vl);\n                \n                // Load column of mat2\n                vfloat64m1_t mat2_vec = __riscv_vle64_v_f64m1(mat2 + k * p + j, vl);\n                \n                // Multiply and accumulate\n                sum_vec = __riscv_vfmadd_vv_f64m1(mat1_vec, mat2_vec, sum_vec, vl);\n            }\n            \n            // Round to nearest integer and store\n            vfloat64m1_t rounded_vec = __riscv_vfcvt_f_x_v_f64m1(__riscv_vfcvt_x_f_v_i64m1(sum_vec, vl), vl);\n            __riscv_vse64_v_f64m1(dst + i * p + j, rounded_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p - j);\n            vfloat64m1_t sum = __riscv_vfmv_v_f_f64m1(0.0, vl);\n            \n            for (size_t k = 0; k < n; k++) {\n                vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(mat1 + i * n + k, vl);\n                vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(mat2 + k * p + j, vl);\n                \n                sum = __riscv_vfmadd_vv_f64m1(vec1, vec2, sum, vl);\n            }\n            \n            vfloat64m1_t rounded = __riscv_vfcvt_rtz_x_f_v_f64m1(sum, vl);\n            vfloat64m1_t converted = __riscv_vfcvt_f_x_v_f64m1(rounded, vl);\n            \n            __riscv_vse64_v_f64m1(dst + i * p + j, converted, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p - j);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k++) {\n                vfloat64m1_t mat1_vec = __riscv_vle64_v_f64m1(&mat1[i * n + k], vl);\n                vfloat64m1_t mat2_vec = __riscv_vle64_v_f64m1(&mat2[k * p + j], vl);\n                \n                sum_vec = __riscv_vfmacc_vv_f64m1(sum_vec, mat1_vec[0], mat2_vec, vl);\n            }\n\n            vfloat64m1_t rounded_vec = __riscv_vfcvt_rtz_x_f_v_f64m1(sum_vec, vl);\n            __riscv_vse64_v_f64m1(&dst[i * p + j], rounded_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(p);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n            for (size_t k = 0; k < n; k++) {\n                vfloat64m1_t mat1_vec = __riscv_vle64_v_f64m1(&mat1[i * n + k], vl);\n                vfloat64m1_t mat2_vec = __riscv_vle64_v_f64m1(&mat2[k * p + j], vl);\n                \n                sum_vec = __riscv_vfmadd_vv_f64m1(mat1_vec, mat2_vec, sum_vec, vl);\n            }\n\n            double sum = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t j = 0; j < cols; j++) {\n        vl = __riscv_vsetvl_e32m1(rows);\n        for (size_t i = 0; i < rows; i += vl) {\n            vfloat32m1_t v_src = __riscv_vle32_v_f32m1(src + i * cols + j, vl);\n            \n            // Round to nearest quarter\n            vfloat32m1_t v_rounded = __riscv_vfmul_vf_f32m1(\n                __riscv_vfround_vf_f32m1(\n                    __riscv_vfdiv_vf_f32m1(v_src, 0.25f, vl), \n                    0, vl\n                ), \n                4.0f, vl\n            );\n            \n            __riscv_vse32_v_f32m1(dst + j * rows + i, v_rounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i += vl) {\n            vl = __riscv_vsetvl_e32m1(rows - i);\n            \n            // Load source matrix row\n            vfloat32m1_t v_src = __riscv_vle32_v_f32m1(src + i * cols + j, vl);\n            \n            // Round to nearest quarter\n            vfloat32m1_t v_rounded = __riscv_vfmul_vf_f32m1(\n                __riscv_vfround_vf_f32m1(v_src, 2, vl), \n                4.0f, vl);\n            v_rounded = __riscv_vfdiv_vf_f32m1(v_rounded, 4.0f, vl);\n            \n            // Store to transposed destination matrix\n            __riscv_vse32_v_f32m1(dst + j * rows + i, v_rounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i += vl) {\n            vl = __riscv_vsetvl_e32m1(rows - i);\n            \n            // Load vector of source matrix elements\n            vfloat32m1_t v_src = __riscv_vle32_v_f32m1(src + i * cols + j, vl);\n            \n            // Round to nearest quarter\n            vfloat32m1_t v_rounded = __riscv_vfcvt_f_x_v_f32m1(\n                __riscv_vfcvt_x_f_v_i32m1(\n                    __riscv_vfmul_vf_f32m1(v_src, 4.0f, vl), \n                    __riscv_vfroundnear_vf_f32m1(v_src, vl), \n                    vl\n                ), vl\n            ) / 4.0f;\n            \n            // Store in transposed destination matrix\n            __riscv_vse32_v_f32m1(dst + j * rows + i, v_rounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i += vl) {\n            vl = __riscv_vsetvl_e32m1(rows - i);\n            \n            // Load vector of source matrix elements\n            vfloat32m1_t v_src = __riscv_vle32_v_f32m1(src + i * cols + j, vl);\n            \n            // Round to nearest quarter\n            vfloat32m1_t v_rounded = __riscv_vfcvt_f_x_v_f32m1(\n                __riscv_vfcvt_x_f_v_i32m1(\n                    __riscv_vfmul_vf_f32m1(v_src, 4.0f, vl), \n                    __riscv_vfroundnear_vf_f32m1(v_src, vl), \n                    vl\n                ), vl\n            ) / 4.0f;\n            \n            // Store in transposed destination matrix\n            __riscv_vse32_v_f32m1(dst + j * rows + i, v_rounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t j = 0; j < cols; j++) {\n        for (size_t i = 0; i < rows; i += vl) {\n            vl = __riscv_vsetvl_e32m1(rows - i);\n            \n            // Load vector of source matrix elements\n            vfloat32m1_t v_src = __riscv_vle32_v_f32m1(src + i * cols + j, vl);\n            \n            // Round to nearest quarter\n            vfloat32m1_t v_rounded = __riscv_vfcvt_f_x_v_f32m1(\n                __riscv_vfcvt_x_f_v_i32m1(\n                    __riscv_vfmul_vf_f32m1(v_src, 4.0f, vl), \n                    __riscv_vfroundnear_vf_f32m1(v_src, vl), \n                    vl\n                ), vl\n            ) / 4.0f;\n            \n            // Store in transposed destination matrix\n            __riscv_vse32_v_f32m1(dst + j * rows + i, v_rounded, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(tensor1 + i, vlmax);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(tensor2 + i, vlmax);\n        \n        vfloat32m1_t result = __riscv_vfsub_vv_f32m1(vec1, vec2, vlmax);\n        \n        // Round towards zero\n        vfloat32m1_t rounded = __riscv_vfcvt_rtz_x_f_v_f32m1(result, vlmax);\n        vfloat32m1_t converted_back = __riscv_vfcvt_f_x_v_f32m1(rounded, vlmax);\n        \n        __riscv_vse32_v_f32m1(dst + i, converted_back, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e32m1(total_elements - i);\n\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(tensor1 + i, vlmax);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(tensor2 + i, vlmax);\n\n        vfloat32m1_t result = __riscv_vfsub_vv_f32m1(vec1, vec2, vlmax);\n        \n        // Round towards zero\n        vfloat32m1_t rounded = __riscv_vfcvt_rtz_x_f_v_f32m1(result, vlmax);\n        vfloat32m1_t converted_back = __riscv_vfcvt_f_x_v_f32m1(rounded, vlmax);\n\n        __riscv_vse32_v_f32m1(dst + i, converted_back, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e32m1(total_elements - i);\n\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(tensor1 + i, vlmax);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(tensor2 + i, vlmax);\n\n        vfloat32m1_t result = __riscv_vfsub_vv_f32m1(vec1, vec2, vlmax);\n        \n        // Round towards zero\n        vfloat32m1_t rounded = __riscv_vfcvt_rtz_x_f_v_f32m1(result, vlmax);\n        vfloat32m1_t converted_back = __riscv_vfcvt_f_x_v_f32m1(rounded, vlmax);\n\n        __riscv_vse32_v_f32m1(dst + i, converted_back, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e32m1(total_elements - i);\n\n        // Load vectors from tensor1 and tensor2\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(tensor1 + i, vlmax);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(tensor2 + i, vlmax);\n\n        // Perform element-wise subtraction\n        vfloat32m1_t result_vec = __riscv_vfsub_vv_f32m1(vec1, vec2, vlmax);\n\n        // Round towards zero\n        vfloat32m1_t rounded_vec = __riscv_vfcvt_rtz_x_f_v_f32m1(result_vec, vlmax);\n        vfloat32m1_t final_vec = __riscv_vfcvt_f_x_v_f32m1(rounded_vec, vlmax);\n\n        // Store result in destination tensor\n        __riscv_vse32_v_f32m1(dst + i, final_vec, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e32m1(total_elements - i);\n\n        // Load vectors\n        vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(tensor1 + i, vlmax);\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(tensor2 + i, vlmax);\n\n        // Subtract vectors\n        vfloat32m1_t result_vec = __riscv_vfsub_vv_f32m1(vec1, vec2, vlmax);\n\n        // Round towards zero\n        vfloat32m1_t rounded_vec = __riscv_vfcvt_rtz_x_f_v_f32m1(result_vec, vlmax);\n        vfloat32m1_t final_vec = __riscv_vfcvt_f_x_v_f32m1(rounded_vec, vlmax);\n\n        // Store result\n        __riscv_vse32_v_f32m1(dst + i, final_vec, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(mat1 + i, vl);\n        vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(mat2 + i, vl);\n        \n        vfloat64m1_t result = __riscv_vfmul_vv_f64m1(vec1, vec2, vl);\n        \n        __riscv_vse64_v_f64m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        size_t vl = __riscv_vsetvl_e64m1(n);\n        \n        for (; j + vl <= n; j += vl) {\n            // Load vectors from mat1 and mat2\n            vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(mat1 + i*n + j, vl);\n            vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(mat2 + i*n + j, vl);\n            \n            // Perform element-wise multiplication\n            vfloat64m1_t result = __riscv_vfmul_vv_f64m1(vec1, vec2, vl);\n            \n            // Store result in destination matrix\n            __riscv_vse64_v_f64m1(dst + i*n + j, result, vl);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            dst[i*n + j] = mat1[i*n + j] * mat2[i*n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e64m1(total_elements - i);\n        \n        vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(mat1 + i, vl);\n        vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(mat2 + i, vl);\n        \n        vfloat64m1_t result = __riscv_vfmul_vv_f64m1(vec1, vec2, vl);\n        \n        __riscv_vse64_v_f64m1(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        size_t vl = __riscv_vsetvl_e64m1(n);\n        \n        for (; j + vl <= n; j += vl) {\n            // Load vectors from mat1 and mat2\n            vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(mat1 + i*n + j, vl);\n            vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(mat2 + i*n + j, vl);\n            \n            // Perform element-wise multiplication\n            vfloat64m1_t result = __riscv_vfmul_vv_f64m1(vec1, vec2, vl);\n            \n            // Store result in destination matrix\n            __riscv_vse64_v_f64m1(dst + i*n + j, result, vl);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            dst[i*n + j] = mat1[i*n + j] * mat2[i*n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        size_t vl = __riscv_vsetvl_e64m1(n);\n        \n        for (; j + vl <= n; j += vl) {\n            // Load vectors from mat1 and mat2\n            vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(mat1 + i*n + j, vl);\n            vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(mat2 + i*n + j, vl);\n            \n            // Perform element-wise multiplication\n            vfloat64m1_t result = __riscv_vfmul_vv_f64m1(vec1, vec2, vl);\n            \n            // Store result in destination matrix\n            __riscv_vse64_v_f64m1(dst + i*n + j, result, vl);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            dst[i*n + j] = mat1[i*n + j] * mat2[i*n + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t mat_vec = __riscv_vle32_v_f32m1(mat + i * n + j, vl);\n            vfloat32m1_t vec_vec = __riscv_vle32_v_f32m1(vec + j, vl);\n            \n            vfloat32m1_t mul_vec = __riscv_vfmul_vv_f32m1(mat_vec, vec_vec, vl);\n            sum = __riscv_vfredsum_vs_f32m1_f32m1(sum, mul_vec, sum, vl);\n        }\n\n        dst[i] = __riscv_vfmv_f_s_f32m1_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t mat_vec = __riscv_vle32_v_f32m1(mat + i * n + j, vl);\n            vfloat32m1_t vec_vec = __riscv_vle32_v_f32m1(vec + j, vl);\n            \n            vfloat32m1_t prod = __riscv_vfmul_vv_f32m1(mat_vec, vec_vec, vl);\n            sum = __riscv_vfredsum_vs_f32m1_f32m1(sum, prod, vl);\n        }\n        \n        dst[i] = __riscv_vfmv_f_s_f32m1_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t mat_vec = __riscv_vle32_v_f32m1(mat + i * n + j, vl);\n            vfloat32m1_t vec_vec = __riscv_vle32_v_f32m1(vec + j, vl);\n            \n            vfloat32m1_t prod = __riscv_vfmul_vv_f32m1(mat_vec, vec_vec, vl);\n            sum = __riscv_vfredsum_vs_f32m1_f32m1(sum, prod, vl);\n        }\n        \n        dst[i] = __riscv_vfmv_f_s_f32m1_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t mat_vec = __riscv_vle32_v_f32m1(mat + i * n + j, vl);\n            vfloat32m1_t vec_vec = __riscv_vle32_v_f32m1(vec + j, vl);\n            \n            vfloat32m1_t prod = __riscv_vfmul_vv_f32m1(mat_vec, vec_vec, vl);\n            sum = __riscv_vfredsum_vs_f32m1_f32m1(sum, prod, vl);\n        }\n\n        dst[i] = __riscv_vfmv_f_s_f32m1_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        size_t vl = __riscv_vsetvl_e32m1(n);\n        vfloat32m1_t sum = __riscv_vfmv_s_f_f32m1(0.0f, vl);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t mat_vec = __riscv_vle32_v_f32m1(mat + i * n + j, vl);\n            vfloat32m1_t vec_vec = __riscv_vle32_v_f32m1(vec + j, vl);\n            \n            vfloat32m1_t prod = __riscv_vfmul_vv_f32m1(mat_vec, vec_vec, vl);\n            sum = __riscv_vfredsum_vs_f32m1_f32m1(sum, prod, vl);\n        }\n        \n        dst[i] = __riscv_vfmv_f_s_f32m1_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m8(total_elements);\n    \n    // Initialize vector sum\n    vfloat64m8_t vec_sum = __riscv_vfmv_v_f_f64m8(0.0, vl);\n    \n    // Process matrix in vector chunks\n    for (size_t i = 0; i < total_elements; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e64m8(total_elements - i);\n        \n        // Load vector chunk\n        vfloat64m8_t vec_data = __riscv_vle64_v_f64m8(mat + i, vl);\n        \n        // Accumulate sum\n        vec_sum = __riscv_vfredsum_vs_f64m8_f64m1(vec_sum, vec_data, vec_sum, vl);\n    }\n    \n    // Reduce vector sum to scalar\n    sum = __riscv_vfmv_f_s_f64m1_f64(vec_sum);\n    \n    // Calculate average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    // Get the maximum vector length for double\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    \n    // Initialize vector sum\n    vfloat64m1_t v_sum = __riscv_vfmv_s_f_f64m1(0.0, vlen);\n    \n    // Process elements in vector chunks\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        // Determine vector length for this iteration\n        size_t vlmax = __riscv_vsetvl_e64m1(total_elements - i, vlen);\n        \n        // Load vector chunk\n        vfloat64m1_t v_chunk = __riscv_vle64_v_f64m1(&mat[i], vlmax);\n        \n        // Add chunk to running sum\n        v_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_chunk, v_sum, vlmax);\n    }\n    \n    // Extract final sum\n    sum = __riscv_vfmv_f_s_f64m1_f64(v_sum);\n    \n    // Compute average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    size_t vl;\n    \n    // Use vector length configuration\n    vl = __riscv_vsetvl_e64m8(total_elements);\n    \n    // Initialize vector sum\n    vfloat64m8_t v_sum = __riscv_vfmv_v_f_f64m8(0.0, vl);\n    \n    // Process matrix in vector chunks\n    for (size_t i = 0; i < total_elements; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e64m8(total_elements - i);\n        \n        // Load vector chunk\n        vfloat64m8_t v_chunk = __riscv_vle64_v_f64m8(mat + i, vl);\n        \n        // Add chunk to sum vector\n        v_sum = __riscv_vfadd_vv_f64m8(v_sum, v_chunk, vl);\n    }\n    \n    // Reduce vector sum to scalar sum\n    sum = __riscv_vfmv_f_s_f64m8_f64(v_sum);\n    \n    // Calculate average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    // Get the maximum vector length for double\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    \n    // Initialize vector sum\n    vfloat64m1_t vec_sum = __riscv_vfmv_v_f_f64m1(0.0, vlen);\n    \n    // Process elements in vector chunks\n    for (size_t i = 0; i < total_elements; i += vlen) {\n        // Determine vector length for this iteration\n        size_t vlmax = __riscv_vsetvl_e64m1(total_elements - i, vlen);\n        \n        // Load vector chunk\n        vfloat64m1_t vec_data = __riscv_vle64_v_f64m1(mat + i, vlmax);\n        \n        // Add chunk to vector sum\n        vec_sum = __riscv_vfadd_vv_f64m1(vec_sum, vec_data, vlmax);\n    }\n    \n    // Reduce vector sum to scalar\n    sum = __riscv_vfmv_f_s_f64m1_f64(vec_sum);\n    \n    // Return average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m8(total_elements);\n    \n    // Initialize vector sum\n    vfloat64m8_t v_sum = __riscv_vfmv_v_f_f64m8(0.0, vl);\n    \n    // Process matrix elements in vector chunks\n    for (size_t i = 0; i < total_elements; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e64m8(total_elements - i);\n        \n        // Load vector chunk\n        vfloat64m8_t v_elements = __riscv_vle64_v_f64m8(mat + i, vl);\n        \n        // Add chunk to running sum\n        v_sum = __riscv_vfadd_vv_f64m8(v_sum, v_elements, vl);\n    }\n    \n    // Reduce vector sum to scalar\n    sum = __riscv_vfmv_f_s_f64m8_f64(v_sum);\n    \n    // Calculate average\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        bool ascending = directions[r];\n        \n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        \n        for (size_t c = vl; c < cols; c += vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + c, vl);\n            \n            if (ascending) {\n                vbool32_t mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n                if (__riscv_vcpop_m_b32(mask, vl) != vl) {\n                    return false;\n                }\n            } else {\n                vbool32_t mask = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n                if (__riscv_vcpop_m_b32(mask, vl) != vl) {\n                    return false;\n                }\n            }\n            \n            prev_vec = curr_vec;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_start = matrix + r * cols;\n        bool ascending = directions[r];\n\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_start, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n\n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_start + offset, vl);\n            \n            if (ascending) {\n                vbool32_t cmp_result = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n                if (__riscv_vcpop_m_b32(cmp_result, vl) != vl) {\n                    return false;\n                }\n            } else {\n                vbool32_t cmp_result = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n                if (__riscv_vcpop_m_b32(cmp_result, vl) != vl) {\n                    return false;\n                }\n            }\n\n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n\n        // Handle remaining elements\n        if (remaining > 0) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_start + offset, remaining);\n            \n            if (ascending) {\n                vbool32_t cmp_result = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, remaining);\n                if (__riscv_vcpop_m_b32(cmp_result, remaining) != remaining) {\n                    return false;\n                }\n            } else {\n                vbool32_t cmp_result = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, remaining);\n                if (__riscv_vcpop_m_b32(cmp_result, remaining) != remaining) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        bool ascending = directions[r];\n\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n\n        while (offset < cols) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            vbool32_t compare_mask;\n\n            if (ascending) {\n                compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n            } else {\n                compare_mask = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n            }\n\n            if (__riscv_vmand_mm_b32(compare_mask, compare_mask, vl) == 0) {\n                return false;\n            }\n\n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n            vl = __riscv_vsetvl_e32m1(remaining);\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        bool ascending = directions[r];\n\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n\n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            \n            if (ascending) {\n                vbool32_t cmp_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n                if (__riscv_vcpop_m_b32(cmp_mask, vl) != vl) {\n                    return false;\n                }\n            } else {\n                vbool32_t cmp_mask = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n                if (__riscv_vcpop_m_b32(cmp_mask, vl) != vl) {\n                    return false;\n                }\n            }\n\n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n\n        // Handle remaining elements\n        if (remaining > 0) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, remaining);\n            \n            if (ascending) {\n                vbool32_t cmp_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, remaining);\n                if (__riscv_vcpop_m_b32(cmp_mask, remaining) != remaining) {\n                    return false;\n                }\n            } else {\n                vbool32_t cmp_mask = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, remaining);\n                if (__riscv_vcpop_m_b32(cmp_mask, remaining) != remaining) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        bool ascending = directions[r];\n\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n\n        while (offset < cols) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            vbool32_t compare_mask;\n\n            if (ascending) {\n                compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n            } else {\n                compare_mask = __riscv_vmsgt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n            }\n\n            if (__riscv_vmand_mm_b32(compare_mask, compare_mask, vl) == 0) {\n                return false;\n            }\n\n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n            vl = __riscv_vsetvl_e32m1(remaining);\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m1_t v_src, v_result;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle16_v_i16m1(src + i, vl);\n        \n        // Perform division and multiplication to find nearest multiple\n        vint16m1_t v_base = __riscv_vmv_v_x_i16m1(base, vl);\n        vint16m1_t v_quotient = __riscv_vdiv_vv_i16m1(v_src, v_base, vl);\n        vint16m1_t v_floor_multiple = __riscv_vmul_vv_i16m1(v_quotient, v_base, vl);\n        \n        // Store result vector\n        __riscv_vse16_v_i16m1(dst + i, v_floor_multiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source vector\n        vint16m1_t v_src = __riscv_vle16_v_i16m1(src + i, vl);\n        \n        // Divide each element by base\n        vint16m1_t v_div = __riscv_vdiv_vx_i16m1(v_src, base, vl);\n        \n        // Multiply back to get nearest multiple\n        vint16m1_t v_multiple = __riscv_vmul_vx_i16m1(v_div, base, vl);\n        \n        // Store result in destination\n        __riscv_vse16_v_i16m1(dst + i, v_multiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source vector\n        vint16m1_t src_vec = __riscv_vle16_v_i16m1(src + i, vl);\n        \n        // Divide each element by base and floor\n        vint16m1_t div_vec = __riscv_vdiv_vx_i16m1(src_vec, base, vl);\n        \n        // Multiply back to get nearest multiple\n        vint16m1_t multiple_vec = __riscv_vmul_vx_i16m1(div_vec, base, vl);\n        \n        // Store result to destination\n        __riscv_vse16_v_i16m1(dst + i, multiple_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source vector\n        vint16m1_t src_vec = __riscv_vle16_v_i16m1(src + i, vl);\n        \n        // Compute division\n        vint16m1_t div_vec = __riscv_vdiv_vx_i16m1(src_vec, base, vl);\n        \n        // Multiply back to get nearest multiple\n        vint16m1_t multiple_vec = __riscv_vmul_vx_i16m1(div_vec, base, vl);\n        \n        // Store result\n        __riscv_vse16_v_i16m1(dst + i, multiple_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for last iteration\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        // Load source vector\n        vint16m1_t v_src = __riscv_vle16_v_i16m1(src + i, vl);\n        \n        // Perform division and multiplication to find nearest multiple\n        vint16m1_t v_quotient = __riscv_vdiv_vx_i16m1(v_src, base, vl);\n        vint16m1_t v_multiple = __riscv_vmul_vx_i16m1(v_quotient, base, vl);\n        \n        // Store result to destination\n        __riscv_vse16_v_i16m1(dst + i, v_multiple, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e64m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        for (size_t c = 0; c < cols; c += vl) {\n            size_t vlmax = __riscv_vsetvl_e64m1(cols - c);\n            \n            vfloat64m1_t matrix_vec = __riscv_vle64_v_f64m1(matrix + r * cols + c, vlmax);\n            vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(vector + c, vlmax);\n            \n            vbool64_t compare_mask = __riscv_vmfeq_vv_f64m1_b64(matrix_vec, input_vec, vlmax);\n            \n            if (__riscv_vcpop_m_b64(compare_mask, vlmax) != vlmax) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e64m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        for (size_t c = 0; c < cols; c += vl) {\n            size_t vlmax = __riscv_vsetvl_e64m1(cols - c);\n            \n            vfloat64m1_t matrix_vec = __riscv_vle64_v_f64m1(matrix + r * cols + c, vlmax);\n            vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(vector + c, vlmax);\n            \n            vbool64_t compare_mask = __riscv_vmfeq_vv_f64m1_b64(matrix_vec, input_vec, vlmax);\n            \n            if (__riscv_vcpop_m_b64(compare_mask, vlmax) != vlmax) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e64m1(cols);\n\n    for (size_t r = 0; r < rows; r++) {\n        vfloat64m1_t row_vec = __riscv_vle64_v(matrix + r * cols, vl);\n        vbool64_t match_mask = __riscv_vmfeq_vv_f64m1_b64(row_vec, __riscv_vle64_v(vector, vl), vl);\n        \n        if (__riscv_vcpop_m_b64(match_mask, vl) == cols) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e64m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        for (size_t c = 0; c < cols; c += vl) {\n            size_t vlmax = __riscv_vsetvl_e64m1(cols - c);\n            \n            vfloat64m1_t matrix_vec = __riscv_vle64_v_f64m1(matrix + r * cols + c, vlmax);\n            vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(vector + c, vlmax);\n            \n            vbool64_t compare_mask = __riscv_vmfeq_vv_f64m1_b64(matrix_vec, input_vec, vlmax);\n            \n            if (__riscv_vcpop_m_b64(compare_mask, vlmax) != vlmax) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = __riscv_vsetvl_e64m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n        \n        for (size_t c = 0; c < cols; c += vl) {\n            size_t vlmax = __riscv_vsetvl_e64m1(cols - c);\n            \n            vfloat64m1_t matrix_vec = __riscv_vle64_v_f64m1(matrix + r * cols + c, vlmax);\n            vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(vector + c, vlmax);\n            \n            vbool64_t compare_mask = __riscv_vmfeq_vv_f64m1_b64(matrix_vec, input_vec, vlmax);\n            \n            if (__riscv_vcpop_m_b64(compare_mask, vlmax) != vlmax) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(total_elements - i);\n        \n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vlmax);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vlmax);\n        \n        vbool8_t mask = __riscv_vmseq_vv_i8m1_b8(va, vb, vlmax);\n        \n        size_t count = __riscv_vcpop_m_b8(mask, vlmax);\n        equal_count += count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(total_elements - i);\n        \n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vlmax);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vlmax);\n        \n        vbool8_t mask = __riscv_vmseq_vv_i8m1_b8(va, vb, vlmax);\n        \n        size_t count = __riscv_vcpop_m_b8(mask, vlmax);\n        equal_count += count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(total_elements - i);\n        \n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vlmax);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vlmax);\n        \n        vbool8_t mask = __riscv_vmseq_vv_i8m1_b8(va, vb, vlmax);\n        \n        size_t count = __riscv_vcpop_m_b8(mask, vlmax);\n        equal_count += count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(total_elements - i);\n        \n        vuint8m1_t va = __riscv_vle8_v_u8m1(A + i, vlmax);\n        vuint8m1_t vb = __riscv_vle8_v_u8m1(B + i, vlmax);\n        \n        vbool8_t mask = __riscv_vmseq_vv_u8m1_b8(va, vb, vlmax);\n        \n        size_t count = __riscv_vcpop_m_b8(mask, vlmax);\n        equal_count += count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(total_elements - i);\n        \n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vlmax);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vlmax);\n        \n        vbool8_t mask = __riscv_vmseq_vv_i8m1_b8(va, vb, vlmax);\n        \n        size_t count = __riscv_vcpop_m_b8(mask, vlmax);\n        equal_count += count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load x vector\n        vint64m1_t x_vec = __riscv_vle64_v_i64m1(x + i, vl);\n        \n        // Scalar-vector multiplication\n        vint64m1_t ax_vec = __riscv_vmul_vx_i64m1(x_vec, a, vl);\n        \n        // Absolute value\n        vint64m1_t abs_vec = __riscv_vabs_v_i64m1(ax_vec, vl);\n        \n        // Store result to y\n        __riscv_vse64_v_i64m1(y + i, abs_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load x vector\n        vint64m1_t x_vec = __riscv_vle64_v_i64m1(x + i, vl);\n        \n        // Scalar-vector multiplication\n        vint64m1_t ax_vec = __riscv_vmul_vx_i64m1(x_vec, a, vl);\n        \n        // Absolute value\n        vint64m1_t abs_vec = __riscv_vabs_v_i64m1(ax_vec, vl);\n        \n        // Store result to y\n        __riscv_vse64_v_i64m1(y + i, abs_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load x vector\n        vint64m1_t x_vec = __riscv_vle64_v_i64m1(x + i, vl);\n        \n        // Scalar-vector multiplication\n        vint64m1_t ax_vec = __riscv_vmul_vx_i64m1(x_vec, a, vl);\n        \n        // Absolute value\n        vint64m1_t abs_vec = __riscv_vabs_v_i64m1(ax_vec, vl);\n        \n        // Store result to y\n        __riscv_vse64_v_i64m1(y + i, abs_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load x vector\n        vint64m1_t x_vec = __riscv_vle64_v_i64m1(x + i, vl);\n        \n        // Scalar-vector multiplication\n        vint64m1_t ax_vec = __riscv_vmul_vx_i64m1(x_vec, a, vl);\n        \n        // Absolute value\n        vint64m1_t abs_vec = __riscv_vabs_v_i64m1(ax_vec, vl);\n        \n        // Store result to y\n        __riscv_vse64_v_i64m1(y + i, abs_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = __riscv_vsetvl_e64m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load x vector\n        vint64m1_t x_vec = __riscv_vle64_v_i64m1(x + i, vl);\n        \n        // Scalar-vector multiplication\n        vint64m1_t ax_vec = __riscv_vmul_vx_i64m1(x_vec, a, vl);\n        \n        // Absolute value\n        vint64m1_t abs_vec = __riscv_vabs_v_i64m1(ax_vec, vl);\n        \n        // Store result to y\n        __riscv_vse64_v_i64m1(y + i, abs_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    vint16m1_t min_vec = __riscv_vle16_v_i16m1(vec, vl);\n    vint16m1_t max_vec = __riscv_vle16_v_i16m1(vec, vl);\n    \n    size_t remaining = length;\n    const int16_t* current = vec;\n    \n    while (remaining > 0) {\n        vl = __riscv_vsetvl_e16m1(remaining);\n        \n        min_vec = __riscv_vmin_vv_i16m1(min_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        max_vec = __riscv_vmax_vv_i16m1(max_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        \n        current += vl;\n        remaining -= vl;\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmin_vs_i16m1_i16m1(min_vec, __riscv_vmv_s_x_i16m1(0, INT16_MAX), vl));\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmax_vs_i16m1_i16m1(max_vec, __riscv_vmv_s_x_i16m1(0, INT16_MIN), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    vint16m1_t min_vec = __riscv_vle16_v_i16m1(vec, vl);\n    vint16m1_t max_vec = min_vec;\n    \n    size_t remaining = length;\n    const int16_t* current = vec;\n    \n    while (remaining > 0) {\n        vl = __riscv_vsetvl_e16m1(remaining);\n        min_vec = __riscv_vmin_vv_i16m1(min_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        max_vec = __riscv_vmax_vv_i16m1(max_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        \n        remaining -= vl;\n        current += vl;\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmin_vs_i16m1_i16m1(min_vec, __riscv_vmv_s_x_i16m1(0, vl), vl));\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmax_vs_i16m1_i16m1(max_vec, __riscv_vmv_s_x_i16m1(0, vl), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    vint16m1_t min_vec = __riscv_vle16_v_i16m1(vec, vl);\n    vint16m1_t max_vec = min_vec;\n    \n    size_t remaining = length;\n    const int16_t* current = vec;\n    \n    while (remaining > 0) {\n        vl = __riscv_vsetvl_e16m1(remaining);\n        min_vec = __riscv_vmin_vv_i16m1(min_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        max_vec = __riscv_vmax_vv_i16m1(max_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        \n        remaining -= vl;\n        current += vl;\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmin_vs_i16m1_i16m1(min_vec, __riscv_vmv_s_x_i16m1(0, INT16_MAX), vl));\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmax_vs_i16m1_i16m1(max_vec, __riscv_vmv_s_x_i16m1(0, INT16_MIN), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    vint16m1_t min_vec = __riscv_vle16_v_i16m1(vec, vl);\n    vint16m1_t max_vec = min_vec;\n    \n    size_t remaining = length;\n    const int16_t* current = vec;\n    \n    while (remaining > 0) {\n        vl = __riscv_vsetvl_e16m1(remaining);\n        min_vec = __riscv_vmin_vv_i16m1(min_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        max_vec = __riscv_vmax_vv_i16m1(max_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        \n        remaining -= vl;\n        current += vl;\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmin_vs_i16m1_i16m1(min_vec, __riscv_vmv_s_x_i16m1(0, vl), vl));\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmax_vs_i16m1_i16m1(max_vec, __riscv_vmv_s_x_i16m1(0, vl), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    vint16m1_t min_vec = __riscv_vle16_v_i16m1(vec, vl);\n    vint16m1_t max_vec = min_vec;\n    \n    size_t remaining = length;\n    const int16_t* current = vec;\n    \n    while (remaining > 0) {\n        vl = __riscv_vsetvl_e16m1(remaining);\n        min_vec = __riscv_vmin_vv_i16m1(min_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        max_vec = __riscv_vmax_vv_i16m1(max_vec, __riscv_vle16_v_i16m1(current, vl), vl);\n        \n        remaining -= vl;\n        current += vl;\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmin_vs_i16m1_i16m1(min_vec, __riscv_vmv_s_x_i16m1(0, INT16_MAX), vl));\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(__riscv_vredmax_vs_i16m1_i16m1(max_vec, __riscv_vmv_s_x_i16m1(0, INT16_MIN), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n        \n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row + offset, vl);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, vl);\n            \n            if (__riscv_vmand_mm_b32(compare_mask, compare_mask, vl) == 0) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n        \n        // Handle remaining elements\n        if (remaining > 1) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row + offset, remaining);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec, remaining);\n            \n            if (__riscv_vmand_mm_b32(compare_mask, compare_mask, remaining) == 0) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        \n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n        \n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vcpop_m_b32(compare_mask, vl) != vl) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n        \n        // Handle remaining elements\n        if (remaining > 1) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, remaining);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vcpop_m_b32(compare_mask, remaining) != remaining) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        \n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n        \n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vcpop_m_b32(compare_mask, vl) != vl) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n        \n        // Handle remaining elements\n        if (remaining > 1) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, remaining);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vcpop_m_b32(compare_mask, remaining) != remaining) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        \n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row_ptr, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n\n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vcpop_m_b32(compare_mask, vl) != vl) {\n                return false;\n            }\n\n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n\n        // Handle remaining elements\n        if (remaining > 0) {\n            vl = __riscv_vsetvl_e32m1(remaining);\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row_ptr + offset, vl);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vcpop_m_b32(compare_mask, vl) != vl) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(row, vl);\n        size_t remaining = cols;\n        size_t offset = vl;\n        \n        while (remaining > vl) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row + offset, vl);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vmand_mm_b32(compare_mask, compare_mask, vl) == 0) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n            remaining -= vl;\n            offset += vl;\n        }\n        \n        // Handle remaining elements\n        if (remaining > 1) {\n            vint32m1_t curr_vec = __riscv_vle32_v_i32m1(row + offset, remaining);\n            vbool32_t compare_mask = __riscv_vmslt_vv_i32m1_b32(prev_vec, curr_vec);\n            \n            if (__riscv_vmand_mm_b32(compare_mask, compare_mask, remaining) == 0) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for invalid block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Reference block (first block)\n    const int* ref_block = matrix;\n\n    // SIMD vector length configuration\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            // Compare each element of the block\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* ref_row = ref_block + i * cols;\n                const int* current_row = current_block + i * cols;\n\n                // Process vector-length elements at a time\n                size_t j = 0;\n                for (; j + vlen <= block_size; j += vlen) {\n                    vint32m1_t ref_vec = __riscv_vle32_v_i32m1(ref_row + j, vlen);\n                    vint32m1_t current_vec = __riscv_vle32_v_i32m1(current_row + j, vlen);\n                    \n                    vbool32_t compare_mask = __riscv_vneq_vv_i32m1_b32(ref_vec, current_vec);\n                    \n                    if (__riscv_vmfirst_m_b32(compare_mask, vlen) != -1) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements\n                for (; j < block_size; ++j) {\n                    if (ref_row[j] != current_row[j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Reference block to compare against\n    const int* first_block = matrix;\n\n    // RISC-V Vector Extension setup\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            // Compare each element in the block\n            for (size_t i = 0; i < block_size; ++i) {\n                const int* first_block_row = first_block + i * cols;\n                const int* current_block_row = current_block + i * cols;\n\n                // Vector comparison\n                for (size_t j = 0; j < block_size; j += vlen) {\n                    size_t vlmax = __riscv_vsetvl_e32m1(block_size - j);\n                    \n                    vint32m1_t first_vec = __riscv_vle32_v_i32m1(first_block_row + j, vlmax);\n                    vint32m1_t current_vec = __riscv_vle32_v_i32m1(current_block_row + j, vlmax);\n                    \n                    vbool32_t compare_mask = __riscv_vneq_vv_i32m1_b32(first_vec, current_vec, vlmax);\n                    \n                    if (__riscv_vmfirst_m_b32(compare_mask, vlmax) != -1) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Reference block (first block)\n    const int* first_block = matrix;\n\n    // SIMD vector length configuration\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t offset = i * cols;\n                \n                // Process full vector lengths\n                size_t j = 0;\n                for (; j + vlen <= block_size; j += vlen) {\n                    vint32m1_t first_vec = __riscv_vle32_v_i32m1(first_block + offset + j, vlen);\n                    vint32m1_t curr_vec = __riscv_vle32_v_i32m1(current_block + offset + j, vlen);\n                    \n                    vbool32_t compare = __riscv_vneq_vv_i32m1_b32(first_vec, curr_vec, vlen);\n                    \n                    if (__riscv_vmfirst_m_b32(compare, vlen) != -1) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements\n                for (; j < block_size; ++j) {\n                    if (first_block[offset + j] != current_block[offset + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Get vector length\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n\n    // First block as reference\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Offset to start of current block\n            size_t current_block_start = (block_row * block_size * cols) + (block_col * block_size);\n            size_t ref_block_start = block_col * block_size;\n\n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; c += vlen) {\n                    size_t remaining = block_size - c;\n                    size_t vec_len = (remaining < vlen) ? remaining : vlen;\n\n                    // Load reference block\n                    vint32m1_t ref_vec = __riscv_vle32_v_i32m1(\n                        &matrix[ref_block_start + (r * cols) + c], \n                        vec_len\n                    );\n\n                    // Load current block\n                    vint32m1_t current_vec = __riscv_vle32_v_i32m1(\n                        &matrix[current_block_start + (r * cols) + c], \n                        vec_len\n                    );\n\n                    // Compare vectors\n                    vbool32_t compare_mask = __riscv_vneq_vv_i32m1_b32(ref_vec, current_vec, vec_len);\n\n                    // If any elements are different, return false\n                    if (__riscv_vmfirst_m_b32(compare_mask, vec_len) != -1) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Reference block (first block)\n    const int* first_block = matrix;\n\n    // RISC-V Vector Extension variables\n    size_t vl;\n    vint32m1_t reference_vec, current_vec;\n\n    // Iterate through all blocks except the first one\n    for (size_t block_row = 0; block_row < num_block_rows; block_row++) {\n        for (size_t block_col = (block_row == 0) ? 1 : 0; block_col < num_block_cols; block_col++) {\n            // Get current block start\n            const int* current_block = matrix + (block_row * num_block_cols + block_col) * block_size * block_size;\n\n            // Compare each element in the block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j += vl) {\n                    // Determine vector length\n                    vl = __riscv_vsetvl_e32m1(block_size - j);\n\n                    // Load reference and current block vectors\n                    reference_vec = __riscv_vle32_v_i32m1(first_block + i * block_size + j, vl);\n                    current_vec = __riscv_vle32_v_i32m1(current_block + i * block_size + j, vl);\n\n                    // Compare vectors\n                    if (__riscv_vmseq_vv_b8_b8(reference_vec, current_vec, vl) != -1) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Get vector length and create initial vector configuration\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vfloat64m1_t first_block_vec;\n    \n    // Load first block\n    for (size_t i = 0; i < block_size; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e64m1(block_size - i);\n        first_block_vec = __riscv_vle64_v_f64m1(vec + i, vlmax);\n    }\n\n    // Compare subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        size_t block_start = block * block_size;\n        \n        for (size_t i = 0; i < block_size; i += vlen) {\n            size_t vlmax = __riscv_vsetvl_e64m1(block_size - i);\n            \n            // Load current block\n            vfloat64m1_t current_block_vec = __riscv_vle64_v_f64m1(vec + block_start + i, vlmax);\n            \n            // Compare with first block\n            vfloat64m1_t diff_vec = __riscv_vfsub_vv_f64m1(first_block_vec, current_block_vec, vlmax);\n            vfloat64m1_t abs_diff_vec = __riscv_vfabs_v_f64m1(diff_vec, vlmax);\n            \n            // Check if absolute difference exceeds tolerance\n            vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(abs_diff_vec, tolerance, vlmax);\n            \n            if (__riscv_vmfirst_m_b64(mask, vlmax) != -1) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Get vector length and create initial vector configuration\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    \n    // Load first block as reference\n    vfloat64m1_t reference_block = __riscv_vle64_v_f64m1(vec, block_size);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        // Load current block\n        const double* current_block_ptr = vec + block * block_size;\n        vfloat64m1_t current_block = __riscv_vle64_v_f64m1(current_block_ptr, block_size);\n\n        // Compare each element with absolute difference\n        vfloat64m1_t diff = __riscv_vfsub_vv_f64m1(reference_block, current_block, block_size);\n        vfloat64m1_t abs_diff = __riscv_vfabs_v_f64m1(diff, block_size);\n        \n        // Check if any difference exceeds tolerance\n        vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(abs_diff, tolerance, block_size);\n        if (__riscv_vmfirst_m_b64(mask, block_size) != -1) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Get vector length and create initial vector configuration\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vfloat64m1_t first_block_vec;\n    \n    // Load first block\n    for (size_t i = 0; i < block_size; i += vlen) {\n        size_t vlmax = __riscv_vsetvl_e64m1(block_size - i);\n        first_block_vec = __riscv_vle64_v_f64m1(vec + i, vlmax);\n    }\n\n    // Compare subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        size_t block_start = block * block_size;\n        \n        for (size_t i = 0; i < block_size; i += vlen) {\n            size_t vlmax = __riscv_vsetvl_e64m1(block_size - i);\n            \n            // Load current block\n            vfloat64m1_t current_block_vec = __riscv_vle64_v_f64m1(vec + block_start + i, vlmax);\n            \n            // Compute absolute difference\n            vfloat64m1_t diff_vec = __riscv_vfsub_vv_f64m1(first_block_vec, current_block_vec, vlmax);\n            vfloat64m1_t abs_diff_vec = __riscv_vfabs_v_f64m1(diff_vec, vlmax);\n            \n            // Check if absolute difference exceeds tolerance\n            vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(abs_diff_vec, tolerance, vlmax);\n            \n            // If any element exceeds tolerance, return false\n            if (__riscv_vmfirst_m_b64(mask, vlmax) != -1) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Get vector length\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n\n    // Load first block as reference\n    vfloat64m1_t ref_block = __riscv_vle64_v_f64m1(vec, block_size);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block_ptr = vec + block * block_size;\n        \n        // Process block in vector chunks\n        for (size_t i = 0; i < block_size; i += vlen) {\n            size_t vlmax = __riscv_vsetvl_e64m1(block_size - i);\n            \n            // Load current block chunk\n            vfloat64m1_t current_chunk = __riscv_vle64_v_f64m1(current_block_ptr + i, vlmax);\n            \n            // Compare absolute difference against tolerance\n            vfloat64m1_t diff = __riscv_vfabs_v_f64m1(__riscv_vfsub_vv_f64m1(ref_block, current_chunk, vlmax), vlmax);\n            vbool64_t mask = __riscv_vmfgt_vf_f64m1_b64(diff, tolerance, vlmax);\n            \n            // If any element exceeds tolerance, return false\n            if (__riscv_vmfirst_m_b64(mask, vlmax) != -1) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Get vector length\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n\n    // Load first block as reference\n    vfloat64m1_t reference_block = __riscv_vlse64_v_f64m1(vec, block_size * sizeof(double), block_size, vlen);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        // Load current block\n        vfloat64m1_t current_block = __riscv_vlse64_v_f64m1(vec + block * block_size, block_size * sizeof(double), block_size, vlen);\n\n        // Compare blocks element-wise\n        vbool64_t comparison_mask = __riscv_vmfle_vv_f64m1_b64(\n            __riscv_vfabs_v_f64m1(__riscv_vfsub_vv_f64m1(reference_block, current_block, block_size, vlen), \n            block_size, vlen),\n            tolerance, block_size, vlen\n        );\n\n        // Check if all elements are within tolerance\n        if (__riscv_vmand_mm_b64(comparison_mask, comparison_mask, block_size, vlen) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    vfloat64m1_t v_row, v_squared;\n    vfloat64m1_t v_threshold;\n    vfloat64m1_t v_sum;\n    \n    for (size_t i = 0; i < rows; i++) {\n        v_sum = __riscv_vfmv_s_f_f64m1(0.0, cols);\n        \n        for (size_t j = 0; j < cols; j += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - j);\n            \n            v_row = __riscv_vle64_v_f64m1(matrix + i * cols + j, vl);\n            v_squared = __riscv_vfmul_vv_f64m1(v_row, v_row, vl);\n            v_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_squared, v_sum, vl);\n        }\n        \n        double norm = __riscv_vfmv_f_s_f64m1_f64(v_sum);\n        norm = sqrt(norm);\n        \n        v_threshold = __riscv_vle64_v_f64m1(thresholds + i, 1);\n        result[i] = norm > __riscv_vfmv_f_s_f64m1_f64(v_threshold);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    vfloat64m1_t v_row_sum, v_threshold;\n    \n    for (size_t r = 0; r < rows; r++) {\n        // Initialize row sum vector to zero\n        vfloat64m1_t v_sum = __riscv_vfmv_v_f_f64m1(0.0, __riscv_vsetvl_e64m1(cols));\n        \n        // Process matrix row in vector chunks\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - c);\n            \n            // Load matrix row elements\n            vfloat64m1_t v_elements = __riscv_vle64_v_f64m1(matrix + r * cols + c, vl);\n            \n            // Square the elements\n            vfloat64m1_t v_squared = __riscv_vfmul_vv_f64m1(v_elements, v_elements, vl);\n            \n            // Accumulate squared values\n            v_sum = __riscv_vfadd_vv_f64m1(v_sum, v_squared, vl);\n        }\n        \n        // Reduce sum across vector\n        double row_norm = __riscv_vfmv_f_s_f64m1_f64(__riscv_vfredsum_vs_f64m1_f64m1(v_sum, __riscv_vfmv_v_f_f64m1(0.0, 1), __riscv_vsetvl_e64m1(1)));\n        \n        // Take square root of sum\n        row_norm = sqrt(row_norm);\n        \n        // Compare with threshold\n        result[r] = row_norm > thresholds[r];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t r = 0; r < rows; r++) {\n        double row_norm = 0.0;\n        size_t col = 0;\n        vl = __riscv_vsetvl_e64m1(cols);\n        \n        // Compute row norm using vector instructions\n        for (; col + vl <= cols; col += vl) {\n            vfloat64m1_t vec = __riscv_vle64_v_f64m1(matrix + r * cols + col, vl);\n            vfloat64m1_t squared_vec = __riscv_vfmul_vv_f64m1(vec, vec, vl);\n            float64_t partial_sum = __riscv_vfredsum_vs_f64m1_f64(squared_vec, 0.0, vl);\n            row_norm += partial_sum;\n        }\n        \n        // Handle remaining elements\n        for (; col < cols; col++) {\n            double val = matrix[r * cols + col];\n            row_norm += val * val;\n        }\n        \n        // Take square root and compare with threshold\n        row_norm = sqrt(row_norm);\n        result[r] = row_norm > thresholds[r];\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    vfloat64m1_t v_row, v_squared;\n    vfloat64m1_t v_sum;\n    vbool64_t v_mask;\n    \n    for (size_t r = 0; r < rows; r++) {\n        v_sum = __riscv_vfmv_s_f_f64m1(0.0, cols);  // Initialize sum to zero\n        \n        // Process matrix row in vector chunks\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e64m1(cols - c);\n            \n            // Load row elements\n            v_row = __riscv_vle64_v_f64m1(matrix + r * cols + c, vl);\n            \n            // Square row elements\n            v_squared = __riscv_vfmul_vv_f64m1(v_row, v_row, vl);\n            \n            // Accumulate squared values\n            v_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_squared, v_sum, vl);\n        }\n        \n        // Compute square root of sum\n        double norm = __riscv_vfmv_f_s_f64m1_f64(v_sum);\n        norm = __builtin_sqrt(norm);\n        \n        // Compare norm with threshold\n        result[r] = (norm > thresholds[r]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t r = 0; r < rows; r++) {\n        double row_norm = 0.0;\n        size_t col = 0;\n        \n        // Vector processing of columns\n        for (; col + (vl = __riscv_vsetvl_e64m1(cols - col)) < cols; col += vl) {\n            vfloat64m1_t vec = __riscv_vle64_v_f64m1(matrix + r * cols + col, vl);\n            vfloat64m1_t squared_vec = __riscv_vfmul_vv_f64m1(vec, vec, vl);\n            row_norm += __riscv_vfmv_f_s_f64m1_f64(__riscv_vfred_sum_vs_f64m1_f64m1(squared_vec, __riscv_vfmv_s_f_f64m1(0.0), vl));\n        }\n        \n        // Scalar processing of remaining columns\n        for (; col < cols; col++) {\n            double val = matrix[r * cols + col];\n            row_norm += val * val;\n        }\n        \n        row_norm = sqrt(row_norm);\n        result[r] = row_norm > thresholds[r];\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length;\n    size_t i = 0;\n    \n    while (i < length) {\n        vector_length = __riscv_vsetvl_e32m1(length - i);\n        \n        vint32m1_t va = __riscv_vle32_v_i32m1(A + i, vector_length);\n        vint32m1_t vb = __riscv_vle32_v_i32m1(B + i, vector_length);\n        \n        vint32m1_t vc = __riscv_vor_vv_i32m1(va, vb, vector_length);\n        \n        __riscv_vse32_v_i32m1(C + i, vc, vector_length);\n        \n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length;\n    size_t i = 0;\n    \n    while (i < length) {\n        vector_length = __riscv_vsetvl_e32m1(length - i);\n        \n        vint32m1_t va = __riscv_vle32_v_i32m1(A + i, vector_length);\n        vint32m1_t vb = __riscv_vle32_v_i32m1(B + i, vector_length);\n        \n        vint32m1_t vc = __riscv_vor_vv_i32m1(va, vb, vector_length);\n        \n        __riscv_vse32_v_i32m1(C + i, vc, vector_length);\n        \n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors from A and B\n        vuint32m1_t va = __riscv_vle32_v_u32m1(A + i, vl);\n        vuint32m1_t vb = __riscv_vle32_v_u32m1(B + i, vl);\n        \n        // Perform bitwise OR\n        vuint32m1_t vc = __riscv_vor_vv_u32m1(va, vb, vl);\n        \n        // Store result in C\n        __riscv_vse32_v_u32m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length;\n    vint32m1_t va, vb, vc;\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        vector_length = __riscv_vsetvl_e32m1(length - i);\n        \n        va = __riscv_vle32_v_i32m1(A + i, vector_length);\n        vb = __riscv_vle32_v_i32m1(B + i, vector_length);\n        \n        vc = __riscv_vor_vv_i32m1(va, vb, vector_length);\n        \n        __riscv_vse32_v_i32m1(C + i, vc, vector_length);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length;\n    size_t i = 0;\n    \n    while (i < length) {\n        vector_length = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors from A and B\n        vuint32m1_t va = __riscv_vle32_v_u32m1(A + i, vector_length);\n        vuint32m1_t vb = __riscv_vle32_v_u32m1(B + i, vector_length);\n        \n        // Perform bitwise OR\n        vuint32m1_t vc = __riscv_vor_vv_u32m1(va, vb, vector_length);\n        \n        // Store result in C\n        __riscv_vse32_v_u32m1(C + i, vc, vector_length);\n        \n        i += vector_length;\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n        \n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n        \n        vint16m2_t va_squared = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vint16m2_t vb_squared = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n        \n        vint16m2_t vproduct = __riscv_vmul_vv_i16m2(va, vb, vl);\n        \n        vint32m4_t va_squares_ext = __riscv_vwmul_vv_i32m4(va_squared, __riscv_vmv_v_x_i16m2(1, vl), vl);\n        vint32m4_t vb_squares_ext = __riscv_vwmul_vv_i32m4(vb_squared, __riscv_vmv_v_x_i16m2(1, vl), vl);\n        vint32m4_t vproduct_ext = __riscv_vwmul_vv_i32m4(vproduct, __riscv_vmv_v_x_i16m2(1, vl), vl);\n        \n        sum_squares += __riscv_vmv_x_v_i32m4(__riscv_vredsum_vs_i32m4_i32m1(va_squares_ext, __riscv_vmv_s_x_i32m1(0, vl), vl));\n        sum_squares += __riscv_vmv_x_v_i32m4(__riscv_vredsum_vs_i32m4_i32m1(vb_squares_ext, __riscv_vmv_s_x_i32m1(0, vl), vl));\n        sum_products += __riscv_vmv_x_v_i32m4(__riscv_vredsum_vs_i32m4_i32m1(vproduct_ext, __riscv_vmv_s_x_i32m1(0, vl), vl));\n    }\n\n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n\n        // Load vectors\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n\n        // Compute squares\n        vint16m2_t va_squared = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vint16m2_t vb_squared = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n\n        // Compute products\n        vint16m2_t vproducts = __riscv_vwmul_vv_i16m2(va, vb, vl);\n\n        // Reduce sum of squares\n        vint32m4_t va_squares_wide = __riscv_vwmul_vv_i32m4(va, va, vl);\n        vint32m4_t vb_squares_wide = __riscv_vwmul_vv_i32m4(vb, vb, vl);\n        sum_squares += __riscv_vmv_x_s_i32m4_i32(__riscv_vredsum_vs_i32m4_i32m1(va_squares_wide, __riscv_vmv_s_x_i32m1(0), vl)) +\n                       __riscv_vmv_x_s_i32m4_i32(__riscv_vredsum_vs_i32m4_i32m1(vb_squares_wide, __riscv_vmv_s_x_i32m1(0), vl));\n\n        // Reduce sum of products\n        vint32m4_t vproducts_wide = __riscv_vwmul_vv_i32m4(va, vb, vl);\n        sum_products += __riscv_vmv_x_s_i32m4_i32(__riscv_vredsum_vs_i32m4_i32m1(vproducts_wide, __riscv_vmv_s_x_i32m1(0), vl));\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n\n        // Load vectors\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n\n        // Compute squares\n        vint16m2_t va_squared = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vint16m2_t vb_squared = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n\n        // Compute products\n        vint16m2_t vproducts = __riscv_vwmul_vv_i16m2(va, vb, vl);\n\n        // Reduce sum of squares\n        vint32m4_t va_squares_wide = __riscv_vwmul_vv_i32m4(va_squared, __riscv_vmv_v_x_i16m2(1, vl), vl);\n        vint32m4_t vb_squares_wide = __riscv_vwmul_vv_i32m4(vb_squared, __riscv_vmv_v_x_i16m2(1, vl), vl);\n        sum_squares += __riscv_vmv_x_v_i32m4(__riscv_vredsum_vs_i32m4_i32m1(va_squares_wide, __riscv_vmv_v_x_i32m1(0, vl), vl));\n        sum_squares += __riscv_vmv_x_v_i32m4(__riscv_vredsum_vs_i32m4_i32m1(vb_squares_wide, __riscv_vmv_v_x_i32m1(0, vl), vl));\n\n        // Reduce sum of products\n        vint32m4_t vproducts_wide = __riscv_vwmul_vv_i32m4(vproducts, __riscv_vmv_v_x_i16m2(1, vl), vl);\n        sum_products += __riscv_vmv_x_v_i32m4(__riscv_vredsum_vs_i32m4_i32m1(vproducts_wide, __riscv_vmv_v_x_i32m1(0, vl), vl));\n    }\n\n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n\n        // Load vectors\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n\n        // Compute squares\n        vint16m2_t va_squared = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vint16m2_t vb_squared = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n\n        // Compute products\n        vint16m2_t vproducts = __riscv_vwmul_vv_i16m2(va, vb, vl);\n\n        // Reduce squares\n        vint64m4_t va_squares_wide = __riscv_vwcvt_x_x_v_i64m4(va_squared, vl);\n        vint64m4_t vb_squares_wide = __riscv_vwcvt_x_x_v_i64m4(vb_squared, vl);\n        int64_t squares_sum = __riscv_vredsum_vs_i64m4_i64(va_squares_wide, 0, vl) +\n                               __riscv_vredsum_vs_i64m4_i64(vb_squares_wide, 0, vl);\n\n        // Reduce products\n        vint64m4_t vproducts_wide = __riscv_vwcvt_x_x_v_i64m4(vproducts, vl);\n        int64_t products_sum = __riscv_vredsum_vs_i64m4_i64(vproducts_wide, 0, vl);\n\n        sum_squares += squares_sum;\n        sum_products += products_sum;\n    }\n\n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    size_t vl = __riscv_vsetvl_e8m1(length);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n\n        // Load vectors\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n\n        // Compute squares\n        vint16m2_t va_squared = __riscv_vwmul_vv_i16m2(va, va, vl);\n        vint16m2_t vb_squared = __riscv_vwmul_vv_i16m2(vb, vb, vl);\n\n        // Compute products\n        vint16m2_t vproducts = __riscv_vwmul_vv_i16m2(va, vb, vl);\n\n        // Reduce sum of squares\n        vint32m4_t va_squares_wide = __riscv_vwmul_vv_i32m4(va, va, vl);\n        vint32m4_t vb_squares_wide = __riscv_vwmul_vv_i32m4(vb, vb, vl);\n        sum_squares += __riscv_vmv_x_s_i32m4_i32(__riscv_vredsum_vs_i32m4_i32m1(va_squares_wide, __riscv_vmv_s_x_i32m1(0), vl)) +\n                       __riscv_vmv_x_s_i32m4_i32(__riscv_vredsum_vs_i32m4_i32m1(vb_squares_wide, __riscv_vmv_s_x_i32m1(0), vl));\n\n        // Reduce sum of products\n        vint32m4_t vproducts_wide = __riscv_vwmul_vv_i32m4(va, vb, vl);\n        sum_products += __riscv_vmv_x_s_i32m4_i32(__riscv_vredsum_vs_i32m4_i32m1(vproducts_wide, __riscv_vmv_s_x_i32m1(0), vl));\n    }\n\n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length;\n    vbool64_t mask;\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        vector_length = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from A and B\n        vuint64m1_t va = __riscv_vle64_v_u64m1(A + i, vector_length);\n        vuint64m1_t vb = __riscv_vle64_v_u64m1(B + i, vector_length);\n        \n        // Perform bitwise NOT on B\n        vuint64m1_t vb_not = __riscv_vnot_v_u64m1(vb, vector_length);\n        \n        // Perform bitwise AND between A and NOT(B)\n        vuint64m1_t vc = __riscv_vand_vv_u64m1(va, vb_not, vector_length);\n        \n        // Store result in C\n        __riscv_vse64_v_u64m1(C + i, vc, vector_length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length;\n    for (size_t i = 0; i < length; i += vector_length) {\n        vector_length = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from A and B\n        vint64m1_t va = __riscv_vle64_v_i64m1(A + i, vector_length);\n        vint64m1_t vb = __riscv_vle64_v_i64m1(B + i, vector_length);\n        \n        // Bitwise NOT of B\n        vint64m1_t vb_not = __riscv_vnot_v_i64m1(vb, vector_length);\n        \n        // Bitwise AND between A and NOT(B)\n        vint64m1_t vc = __riscv_vand_vv_i64m1(va, vb_not, vector_length);\n        \n        // Store result in C\n        __riscv_vse64_v_i64m1(C + i, vc, vector_length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length;\n    for (size_t i = 0; i < length; i += vector_length) {\n        vector_length = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from A and B\n        vint64m1_t va = __riscv_vle64_v_i64m1(A + i, vector_length);\n        vint64m1_t vb = __riscv_vle64_v_i64m1(B + i, vector_length);\n        \n        // Bitwise NOT of B\n        vint64m1_t vb_not = __riscv_vnot_v_i64m1(vb, vector_length);\n        \n        // Bitwise AND between A and NOT(B)\n        vint64m1_t vc = __riscv_vand_vv_i64m1(va, vb_not, vector_length);\n        \n        // Store result in C\n        __riscv_vse64_v_i64m1(C + i, vc, vector_length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length;\n    vbool64_t mask;\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        vector_length = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from A and B\n        vuint64m1_t va = __riscv_vle64_v_u64m1(A + i, vector_length);\n        vuint64m1_t vb = __riscv_vle64_v_u64m1(B + i, vector_length);\n        \n        // Bitwise NOT of B\n        vuint64m1_t vb_not = __riscv_vnot_v_u64m1(vb, vector_length);\n        \n        // Bitwise AND between A and NOT(B)\n        vuint64m1_t vc = __riscv_vand_vv_u64m1(va, vb_not, vector_length);\n        \n        // Store result in C\n        __riscv_vse64_v_u64m1(C + i, vc, vector_length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length;\n    vbool64_t mask;\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        vector_length = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load vectors from A and B\n        vuint64m1_t va = __riscv_vle64_v_u64m1(A + i, vector_length);\n        vuint64m1_t vb = __riscv_vle64_v_u64m1(B + i, vector_length);\n        \n        // Bitwise NOT of B\n        vuint64m1_t vb_not = __riscv_vnot_v_u64m1(vb, vector_length);\n        \n        // Bitwise AND between A and NOT(B)\n        vuint64m1_t vc = __riscv_vand_vv_u64m1(va, vb_not, vector_length);\n        \n        // Store result in C\n        __riscv_vse64_v_u64m1(C + i, vc, vector_length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e8m1(length - i);\n        \n        // Load vectors A and B\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n        \n        // Create masks for positive and negative conditions\n        vbool8_t pos_mask_a = __riscv_vmsgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_mask_b = __riscv_vmsgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_mask_a = __riscv_vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_mask_b = __riscv_vmslt_vx_i8m1_b8(vb, 0, vl);\n        \n        // Combine masks for different conditions\n        vbool8_t both_pos_mask = __riscv_vmand_mm_b8(pos_mask_a, pos_mask_b, vl);\n        vbool8_t both_neg_mask = __riscv_vmand_mm_b8(neg_mask_a, neg_mask_b, vl);\n        \n        // Create result vector\n        vint8m1_t result = __riscv_vmv_v_x_i8m1(0, vl);\n        \n        // Set values based on conditions\n        result = __riscv_vmerge_vxm_i8m1(result, 1, both_pos_mask, vl);\n        result = __riscv_vmerge_vxm_i8m1(result, -1, both_neg_mask, vl);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e8m1(length - i);\n        \n        // Load vectors A and B\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n        \n        // Check if both A and B are positive\n        vbool8_t both_positive = __riscv_vmsgt_vx_i8m1_b8(va, 0, vl) & \n                                 __riscv_vmsgt_vx_i8m1_b8(vb, 0, vl);\n        \n        // Check if both A and B are negative\n        vbool8_t both_negative = __riscv_vmslt_vx_i8m1_b8(va, 0, vl) & \n                                 __riscv_vmslt_vx_i8m1_b8(vb, 0, vl);\n        \n        // Create result vector\n        vint8m1_t vc = __riscv_vmv_v_x_i8m1(0, vl);\n        \n        // Set 1 where both are positive\n        vc = __riscv_vmerge_vxm_i8m1(vc, 1, both_positive, vl);\n        \n        // Set -1 where both are negative\n        vc = __riscv_vmerge_vxm_i8m1(vc, -1, both_negative, vl);\n        \n        // Store result vector\n        __riscv_vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e8m1(length - i);\n        \n        // Load vectors from A and B\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n        \n        // Create masks for positive and negative conditions\n        vbool8_t pos_mask_a = __riscv_vmsgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_mask_b = __riscv_vmsgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_mask_a = __riscv_vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_mask_b = __riscv_vmslt_vx_i8m1_b8(vb, 0, vl);\n        \n        // Combine masks for different conditions\n        vbool8_t both_pos_mask = __riscv_vmand_mm_b8(pos_mask_a, pos_mask_b, vl);\n        vbool8_t both_neg_mask = __riscv_vmand_mm_b8(neg_mask_a, neg_mask_b, vl);\n        \n        // Create result vector\n        vint8m1_t result = __riscv_vmv_v_x_i8m1(0, vl);\n        \n        // Set 1 for both positive\n        result = __riscv_vmerge_vxm_i8m1(result, 1, both_pos_mask, vl);\n        \n        // Set -1 for both negative\n        result = __riscv_vmerge_vxm_i8m1(result, -1, both_neg_mask, vl);\n        \n        // Store result vector\n        __riscv_vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e8m1(length - i);\n        \n        // Load vectors from A and B\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n        \n        // Create masks for positive and negative conditions\n        vbool8_t pos_mask_a = __riscv_vmsgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_mask_b = __riscv_vmsgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_mask_a = __riscv_vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_mask_b = __riscv_vmslt_vx_i8m1_b8(vb, 0, vl);\n        \n        // Combine masks\n        vbool8_t both_pos_mask = __riscv_vmand_mm_b8(pos_mask_a, pos_mask_b, vl);\n        vbool8_t both_neg_mask = __riscv_vmand_mm_b8(neg_mask_a, neg_mask_b, vl);\n        \n        // Create result vector\n        vint8m1_t result = __riscv_vmv_v_x_i8m1(0, vl);\n        \n        // Set values based on conditions\n        result = __riscv_vmerge_vxm_i8m1(result, 1, both_pos_mask, vl);\n        result = __riscv_vmerge_vxm_i8m1(result, -1, both_neg_mask, vl);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = __riscv_vsetvl_e8m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e8m1(length - i);\n        \n        // Load vectors from A and B\n        vint8m1_t va = __riscv_vle8_v_i8m1(A + i, vl);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(B + i, vl);\n        \n        // Create masks for positive and negative conditions\n        vbool8_t pos_mask_a = __riscv_vmsgt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t pos_mask_b = __riscv_vmsgt_vx_i8m1_b8(vb, 0, vl);\n        vbool8_t neg_mask_a = __riscv_vmslt_vx_i8m1_b8(va, 0, vl);\n        vbool8_t neg_mask_b = __riscv_vmslt_vx_i8m1_b8(vb, 0, vl);\n        \n        // Combine masks for different conditions\n        vbool8_t both_pos_mask = __riscv_vmand_mm_b8(pos_mask_a, pos_mask_b, vl);\n        vbool8_t both_neg_mask = __riscv_vmand_mm_b8(neg_mask_a, neg_mask_b, vl);\n        \n        // Create result vector\n        vint8m1_t result = __riscv_vmv_v_x_i8m1(0, vl);\n        \n        // Set 1 for both positive\n        result = __riscv_vmerge_vxm_i8m1(result, 1, both_pos_mask, vl);\n        \n        // Set -1 for both negative\n        result = __riscv_vmerge_vxm_i8m1(result, -1, both_neg_mask, vl);\n        \n        // Store result vector\n        __riscv_vse8_v_i8m1(C + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    // Process elements before midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e16m1(midpoint - i);\n        \n        vint16m1_t va = __riscv_vle16_v_i16m1(A + i, vlmax);\n        vint16m1_t vb = __riscv_vle16_v_i16m1(B + i, vlmax);\n        \n        vint16m1_t vxor = __riscv_vxor_vv_i16m1(va, vb, vlmax);\n        \n        __riscv_vse16_v_i16m1(C + i, vxor, vlmax);\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + 1; i < length; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e16m1(length - i);\n        \n        vint16m1_t va = __riscv_vle16_v_i16m1(A + i, vlmax);\n        vint16m1_t vb = __riscv_vle16_v_i16m1(B + i, vlmax);\n        \n        vint16m1_t vand = __riscv_vand_vv_i16m1(va, vb, vlmax);\n        \n        __riscv_vse16_v_i16m1(C + i, vand, vlmax);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements before midpoint with XOR\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    for (size_t i = 0; i < midpoint; i += vl) {\n        vl = __riscv_vsetvl_e16m1(midpoint - i);\n        \n        vuint16m1_t va = __riscv_vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = __riscv_vle16_v_u16m1(B + i, vl);\n        \n        vuint16m1_t vxor = __riscv_vxor_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(C + i, vxor, vl);\n    }\n    \n    // Process midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vuint16m1_t va = __riscv_vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = __riscv_vle16_v_u16m1(B + i, vl);\n        \n        vuint16m1_t vand = __riscv_vand_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements before midpoint with XOR\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    for (size_t i = 0; i < midpoint; i += vl) {\n        vl = __riscv_vsetvl_e16m1(midpoint - i);\n        \n        vuint16m1_t va = __riscv_vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = __riscv_vle16_v_u16m1(B + i, vl);\n        \n        vuint16m1_t vxor = __riscv_vxor_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(C + i, vxor, vl);\n    }\n    \n    // Process midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vuint16m1_t va = __riscv_vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = __riscv_vle16_v_u16m1(B + i, vl);\n        \n        vuint16m1_t vand = __riscv_vand_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    \n    // Process elements before midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e16m1(midpoint - i);\n        \n        vint16m1_t va = __riscv_vle16_v_i16m1(A + i, vlmax);\n        vint16m1_t vb = __riscv_vle16_v_i16m1(B + i, vlmax);\n        \n        vint16m1_t vxor = __riscv_vxor_vv_i16m1(va, vb, vlmax);\n        \n        __riscv_vse16_v_i16m1(C + i, vxor, vlmax);\n    }\n    \n    // Process midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e16m1(length - i);\n        \n        vint16m1_t va = __riscv_vle16_v_i16m1(A + i, vlmax);\n        vint16m1_t vb = __riscv_vle16_v_i16m1(B + i, vlmax);\n        \n        vint16m1_t vand = __riscv_vand_vv_i16m1(va, vb, vlmax);\n        \n        __riscv_vse16_v_i16m1(C + i, vand, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements before midpoint with XOR\n    size_t vl = __riscv_vsetvl_e16m1(length);\n    for (size_t i = 0; i < midpoint; i += vl) {\n        vl = __riscv_vsetvl_e16m1(midpoint - i);\n        \n        vuint16m1_t va = __riscv_vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = __riscv_vle16_v_u16m1(B + i, vl);\n        \n        vuint16m1_t vxor = __riscv_vxor_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(C + i, vxor, vl);\n    }\n    \n    // Process midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m1(length - i);\n        \n        vuint16m1_t va = __riscv_vle16_v_u16m1(A + i, vl);\n        vuint16m1_t vb = __riscv_vle16_v_u16m1(B + i, vl);\n        \n        vuint16m1_t vand = __riscv_vand_vv_u16m1(va, vb, vl);\n        \n        __riscv_vse16_v_u16m1(C + i, vand, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t k = 0;\n            size_t vl;\n            \n            while (k < dim3) {\n                vl = __riscv_vsetvl_e32m1(dim3 - k);\n                \n                // Load condition vectors\n                vbool32_t cond1_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond1 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                vbool32_t cond2_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond2 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                \n                // Load input vectors\n                vfloat32m1_t a_vec = __riscv_vle32_v_f32m1(A + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t b_vec = __riscv_vle32_v_f32m1(B + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t c_vec = __riscv_vle32_v_f32m1(C + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t d_vec = __riscv_vle32_v_f32m1(D + i*dim2*dim3 + j*dim3 + k, vl);\n                \n                // Combine conditions\n                vbool32_t cond1_true_cond2_true = __riscv_vmand_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_true_cond2_false = __riscv_vmandn_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_false_cond2_true = __riscv_vmandn_mm_b32(cond2_vec, cond1_vec, vl);\n                vbool32_t cond1_false_cond2_false = __riscv_vmnand_mm_b32(cond1_vec, cond2_vec, vl);\n                \n                // Select values based on conditions\n                vfloat32m1_t result_vec = __riscv_vmerge_vvm_f32m1(\n                    __riscv_vmerge_vvm_f32m1(\n                        __riscv_vmerge_vvm_f32m1(d_vec, c_vec, cond1_false_cond2_true, vl),\n                        b_vec, \n                        cond1_true_cond2_false, \n                        vl\n                    ),\n                    a_vec, \n                    cond1_true_cond2_true, \n                    vl\n                );\n                \n                // Store result\n                __riscv_vse32_v_f32m1(out + i*dim2*dim3 + j*dim3 + k, result_vec, vl);\n                \n                k += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            size_t vl;\n            \n            while (k < dim3) {\n                vl = __riscv_vsetvl_e32m1(dim3 - k);\n                \n                // Load condition vectors\n                vbool32_t cond1_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1((uint8_t*)(cond1 + i*dim2*dim3 + j*dim3 + k), vl), 0, vl);\n                vbool32_t cond2_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1((uint8_t*)(cond2 + i*dim2*dim3 + j*dim3 + k), vl), 0, vl);\n                \n                // Load input vectors\n                vfloat32m1_t a_vec = __riscv_vle32_v_f32m1(A + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t b_vec = __riscv_vle32_v_f32m1(B + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t c_vec = __riscv_vle32_v_f32m1(C + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t d_vec = __riscv_vle32_v_f32m1(D + i*dim2*dim3 + j*dim3 + k, vl);\n                \n                // Combine conditions\n                vbool32_t cond1_true_cond2_true = __riscv_vmand_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_true_cond2_false = __riscv_vmandn_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_false_cond2_true = __riscv_vmandn_mm_b32(cond2_vec, cond1_vec, vl);\n                \n                // Select values based on conditions\n                vfloat32m1_t result_vec = __riscv_vmerge_vvm_f32m1(\n                    __riscv_vmerge_vvm_f32m1(\n                        __riscv_vmerge_vvm_f32m1(d_vec, c_vec, cond1_false_cond2_true, vl),\n                        b_vec, cond1_true_cond2_false, vl),\n                    a_vec, cond1_true_cond2_true, vl);\n                \n                // Store result\n                __riscv_vse32_v_f32m1(out + i*dim2*dim3 + j*dim3 + k, result_vec, vl);\n                \n                k += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t k = 0;\n            size_t vl;\n            \n            while (k < dim3) {\n                vl = __riscv_vsetvl_e32m1(dim3 - k);\n                \n                // Load condition vectors\n                vbool32_t cond1_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond1 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                vbool32_t cond2_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond2 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                \n                // Load input vectors\n                vfloat32m1_t a_vec = __riscv_vle32_v_f32m1(A + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t b_vec = __riscv_vle32_v_f32m1(B + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t c_vec = __riscv_vle32_v_f32m1(C + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t d_vec = __riscv_vle32_v_f32m1(D + i*dim2*dim3 + j*dim3 + k, vl);\n                \n                // Combine conditions\n                vbool32_t cond1_and_cond2 = __riscv_vmand_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t not_cond1 = __riscv_vmnot_m_b32(cond1_vec, vl);\n                \n                // Select results based on conditions\n                vfloat32m1_t result1 = __riscv_vmerge_vvm_f32m1(a_vec, b_vec, not_cond1, vl);\n                vfloat32m1_t result2 = __riscv_vmerge_vvm_f32m1(c_vec, d_vec, not_cond2, vl);\n                vfloat32m1_t final_result = __riscv_vmerge_vvm_f32m1(result1, result2, cond1_and_cond2, vl);\n                \n                // Store result\n                __riscv_vse32_v_f32m1(out + i*dim2*dim3 + j*dim3 + k, final_result, vl);\n                \n                k += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t k = 0;\n            size_t vl;\n            \n            while (k < dim3) {\n                vl = __riscv_vsetvl_e32m1(dim3 - k);\n                \n                // Load condition vectors\n                vbool32_t cond1_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond1 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                vbool32_t cond2_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond2 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                \n                // Load input vectors\n                vfloat32m1_t a_vec = __riscv_vle32_v_f32m1(A + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t b_vec = __riscv_vle32_v_f32m1(B + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t c_vec = __riscv_vle32_v_f32m1(C + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t d_vec = __riscv_vle32_v_f32m1(D + i*dim2*dim3 + j*dim3 + k, vl);\n                \n                // Combine conditions\n                vbool32_t cond1_true_cond2_true = __riscv_vmand_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_true_cond2_false = __riscv_vmandn_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_false_cond2_true = __riscv_vmandn_mm_b32(cond2_vec, cond1_vec, vl);\n                vbool32_t cond1_false_cond2_false = __riscv_vmnand_mm_b32(cond1_vec, cond2_vec, vl);\n                \n                // Select based on conditions\n                vfloat32m1_t result_vec = __riscv_vmerge_vvm_f32m1(\n                    __riscv_vmerge_vvm_f32m1(\n                        __riscv_vmerge_vvm_f32m1(d_vec, c_vec, cond1_false_cond2_true, vl),\n                        b_vec, \n                        cond1_true_cond2_false, \n                        vl\n                    ),\n                    a_vec, \n                    cond1_true_cond2_true, \n                    vl\n                );\n                \n                // Store result\n                __riscv_vse32_v_f32m1(out + i*dim2*dim3 + j*dim3 + k, result_vec, vl);\n                \n                k += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t k = 0;\n            size_t vl;\n            \n            while (k < dim3) {\n                vl = __riscv_vsetvl_e32m1(dim3 - k);\n                \n                // Load condition vectors\n                vbool32_t cond1_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond1 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                vbool32_t cond2_vec = __riscv_vmsne_vx_u32m1_b32(__riscv_vle8_v_u8m1(cond2 + i*dim2*dim3 + j*dim3 + k, vl), 0, vl);\n                \n                // Load input vectors\n                vfloat32m1_t a_vec = __riscv_vle32_v_f32m1(A + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t b_vec = __riscv_vle32_v_f32m1(B + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t c_vec = __riscv_vle32_v_f32m1(C + i*dim2*dim3 + j*dim3 + k, vl);\n                vfloat32m1_t d_vec = __riscv_vle32_v_f32m1(D + i*dim2*dim3 + j*dim3 + k, vl);\n                \n                // Combine conditions\n                vbool32_t cond1_true_cond2_true = __riscv_vmand_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_true_cond2_false = __riscv_vmandn_mm_b32(cond1_vec, cond2_vec, vl);\n                vbool32_t cond1_false_cond2_true = __riscv_vmandn_mm_b32(cond2_vec, cond1_vec, vl);\n                \n                // Select values based on conditions\n                vfloat32m1_t result_vec = __riscv_vmerge_vvm_f32m1(\n                    __riscv_vmerge_vvm_f32m1(\n                        __riscv_vmerge_vvm_f32m1(d_vec, c_vec, cond1_false_cond2_true, vl),\n                        b_vec, cond1_true_cond2_false, vl),\n                    a_vec, cond1_true_cond2_true, vl);\n                \n                // Store result\n                __riscv_vse32_v_f32m1(out + i*dim2*dim3 + j*dim3 + k, result_vec, vl);\n                \n                k += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of 32-bit integers\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Initialize output vector\n        vuint8m1_t vec_out = __riscv_vmv_v_x_u8m1(0, vl);\n        \n        // Popcount for each 32-bit element\n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m1_t masked = __riscv_vsrl_vx_u32m1(vec_a, bit, vl);\n            vuint32m1_t bitset = __riscv_vand_vx_u32m1(masked, 1, vl);\n            vec_out = __riscv_vadd_vv_u8m1(vec_out, __riscv_vreinterpret_v_u32m1_u8m1(bitset), vl);\n        }\n        \n        // Store result to output\n        __riscv_vse8_v_u8m1(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of 32-bit integers\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Initialize output vector\n        vuint8m1_t vec_out = __riscv_vmv_v_x_u8m1(0, vl);\n        \n        // Popcount algorithm using RVV intrinsics\n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m1_t masked = __riscv_vsrl_vx_u32m1(vec_a, bit, vl);\n            vuint32m1_t bitset = __riscv_vand_vx_u32m1(masked, 1, vl);\n            vuint8m1_t bitcount = __riscv_vreinterpret_v_u32m1_u8m1(bitset);\n            vec_out = __riscv_vadd_vv_u8m1(vec_out, bitcount, vl);\n        }\n        \n        // Store result in output tensor\n        __riscv_vse8_v_u8m1(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of 32-bit unsigned integers\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Initialize output vector\n        vuint8m1_t vec_out = __riscv_vmv_v_x_u8m1(0, vl);\n        \n        // Count bits using popcount\n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m1_t mask = __riscv_vsrl_vx_u32m1(vec_a, bit, vl);\n            mask = __riscv_vand_vx_u32m1(mask, 1, vl);\n            vuint8m1_t bit_count = __riscv_vreinterpret_v_u32m1_u8m1(mask);\n            vec_out = __riscv_vadd_vv_u8m1(vec_out, bit_count, vl);\n        }\n        \n        // Store result\n        __riscv_vse8_v_u8m1(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of 32-bit integers\n        vuint32m1_t vec_input = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Initialize output vector\n        vuint8m1_t vec_output = __riscv_vmv_v_x_u8m1(0, vl);\n        \n        // Popcount for each 32-bit element\n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m1_t masked = __riscv_vsrl_vx_u32m1(vec_input, bit, vl);\n            vuint32m1_t bitset = __riscv_vand_vx_u32m1(masked, 1, vl);\n            vuint8m1_t bitcount = __riscv_vreinterpret_v_u32m1_u8m1(bitset);\n            vec_output = __riscv_vadd_vv_u8m1(vec_output, bitcount, vl);\n        }\n        \n        // Store result back to output tensor\n        __riscv_vse8_v_u8m1(out + i, vec_output, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of 32-bit integers\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Initialize output vector\n        vuint8m1_t vec_out = __riscv_vmv_v_x_u8m1(0, vl);\n        \n        // Popcount implementation\n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m1_t masked = __riscv_vsrl_vx_u32m1(vec_a, bit, vl);\n            vuint32m1_t bitset = __riscv_vand_vx_u32m1(masked, 1, vl);\n            vec_out = __riscv_vadd_vv_u8m1(vec_out, __riscv_vmv_v_x_u8m1(__riscv_vmv_x_s_u32m1_u32(bitset), vl), vl);\n        }\n        \n        // Store result\n        __riscv_vse8_v_u8m1(out + i, vec_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    vint32m1_t va, vresult;\n    \n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e32m1(cols - c);\n            \n            // Load vector of matrix elements\n            va = __riscv_vle32_v_i32m1(A + r * cols + c, vl);\n            \n            // Create mask for elements divisible by 3\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(va, 0, vl);\n            mask = __riscv_vmnot_m_b32(mask, vl);\n            \n            // Take absolute value for elements divisible by 3\n            vresult = __riscv_vabs_v_i32m1_m(mask, va, va, vl);\n            \n            // Store result back to destination matrix\n            __riscv_vse32_v_i32m1(B + r * cols + c, vresult, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = __riscv_vsetvl_e32m1(cols - j);\n            \n            // Load vector of matrix elements\n            vint32m1_t va = __riscv_vle32_v_i32m1(A + i * cols + j, vl);\n            \n            // Check divisibility by 3\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(va % 3, 0, vl);\n            \n            // Take absolute value where divisible by 3\n            vint32m1_t vabs = __riscv_vabs_v_i32m1_m(mask, va, va, vl);\n            \n            // Store result vector\n            __riscv_vse32_v_i32m1(B + i * cols + j, vabs, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = __riscv_vsetvl_e32m1(total_elements - i);\n        \n        // Load vector of integers\n        vint32m1_t va = __riscv_vle32_v_i32m1(A + i, vl);\n        \n        // Create mask for elements divisible by 3\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(va, 0, vl);\n        mask = __riscv_vmand_mm_b32(mask, __riscv_vrem_vx_i32m1_b32(va, 3, vl), vl);\n        \n        // Compute absolute values\n        vint32m1_t vabs = __riscv_vabs_v_i32m1_m(mask, va, va, vl);\n        \n        // Store result vector\n        __riscv_vse32_v_i32m1(B + i, vabs, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    vint32m1_t va, vresult;\n    \n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e32m1(cols - c);\n            \n            // Load vector of matrix elements\n            va = __riscv_vle32_v_i32m1(A + r * cols + c, vl);\n            \n            // Create vector of divisibility condition\n            vbool32_t vmask = __riscv_vmseq_vx_i32m1_b32(va, 0, vl);\n            vmask = __riscv_vmnot_m_b32(vmask, vl);\n            \n            // Compute absolute values where condition is true\n            vresult = __riscv_vabs_v_i32m1_m(vmask, va, va, vl);\n            \n            // Store result vector\n            __riscv_vse32_v_i32m1(B + r * cols + c, vresult, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    vint32m1_t va, vresult;\n    \n    for (size_t r = 0; r < rows; r++) {\n        for (size_t c = 0; c < cols; c += vl) {\n            vl = __riscv_vsetvl_e32m1(cols - c);\n            \n            // Load vector of matrix elements\n            va = __riscv_vle32_v_i32m1(A + r * cols + c, vl);\n            \n            // Create mask for elements divisible by 3\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(va, 0, vl);\n            mask = __riscv_vmnot_m_b32(mask, vl);\n            \n            // Take absolute value where divisible by 3\n            vresult = __riscv_vabs_v_i32m1_m(mask, va, va, vl);\n            \n            // Store result back to destination matrix\n            __riscv_vse32_v_i32m1(B + r * cols + c, vresult, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Check condition: low 4 bits are all 1\n        vuint32m1_t v_mask = __riscv_vand_vx_u32m1(v_src, 0xF, vl);\n        vbool32_t condition_mask = __riscv_vceq_vx_u32m1_b32(v_mask, 0xF, vl);\n        \n        // Rotate elements that meet condition\n        vuint32m1_t v_rotated = __riscv_vrol_vx_u32m1(v_src, rotate_bits, vl);\n        \n        // Bitwise negate elements that don't meet condition\n        vuint32m1_t v_negated = __riscv_vnot_v_u32m1(v_src, vl);\n        \n        // Blend results based on condition\n        vuint32m1_t v_result = __riscv_vmerge_vvm_u32m1(v_rotated, v_negated, condition_mask, vl);\n        \n        // Store result\n        __riscv_vse32_v_u32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Check condition: low 4 bits are all 1\n        vuint32m1_t v_mask = __riscv_vand_vx_u32m1(v_src, 0xF, vl);\n        vbool32_t condition = __riscv_vmeq_vx_u32m1_b32(v_mask, 0xF, vl);\n        \n        // Rotate elements where condition is true\n        vuint32m1_t v_rotated = __riscv_vrol_vx_u32m1(v_src, rotate_bits, vl);\n        \n        // Bitwise negate elements where condition is false\n        vuint32m1_t v_negated = __riscv_vnot_v_u32m1(v_src, vl);\n        \n        // Blend result based on condition\n        vuint32m1_t v_result = __riscv_vmerge_vvm_u32m1(v_rotated, v_negated, condition, vl);\n        \n        // Store result\n        __riscv_vse32_v_u32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Check condition: low 4 bits are all 1\n        vuint32m1_t v_mask = __riscv_vand_vx_u32m1(v_src, 0xF, vl);\n        vbool32_t condition_mask = __riscv_vceq_vx_u32m1_b32(v_mask, 0xF, vl);\n        \n        // Rotate elements that satisfy condition\n        vuint32m1_t v_rotated = __riscv_vrol_vx_u32m1(v_src, rotate_bits, vl);\n        \n        // Bitwise negate elements that do not satisfy condition\n        vuint32m1_t v_negated = __riscv_vnot_v_u32m1(v_src, vl);\n        \n        // Blend results based on condition\n        vuint32m1_t v_result = __riscv_vmerge_vvm_u32m1(v_rotated, v_negated, condition_mask, vl);\n        \n        // Store result\n        __riscv_vse32_v_u32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Check low 4 bits condition\n        vuint32m1_t v_mask = __riscv_vand_vx_u32m1(v_src, 0xF, vl);\n        vbool32_t condition = __riscv_vmeq_vx_u32m1_b32(v_mask, 0xF, vl);\n        \n        // Rotate elements that meet condition\n        vuint32m1_t v_rotated = __riscv_vrol_vx_u32m1(v_src, rotate_bits, vl);\n        \n        // Bitwise negate elements that don't meet condition\n        vuint32m1_t v_negated = __riscv_vnot_v_u32m1(v_src, vl);\n        \n        // Blend results based on condition\n        vuint32m1_t v_result = __riscv_vmerge_vvm_u32m1(v_rotated, v_negated, condition, vl);\n        \n        // Store result\n        __riscv_vse32_v_u32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl = __riscv_vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        vuint32m1_t v_src = __riscv_vle32_v_u32m1(src + i, vl);\n        \n        // Check condition: low 4 bits are all 1\n        vuint32m1_t v_mask = __riscv_vand_vx_u32m1(v_src, 0xF, vl);\n        vbool32_t condition_mask = __riscv_vceq_vx_u32m1_b32(v_mask, 0xF, vl);\n        \n        // Rotate elements that meet condition\n        vuint32m1_t v_rotated = __riscv_vror_vx_u32m1(v_src, rotate_bits, vl);\n        \n        // Bitwise negate elements that do not meet condition\n        vuint32m1_t v_negated = __riscv_vnot_v_u32m1(v_src, vl);\n        \n        // Select between rotated and negated based on condition\n        vuint32m1_t v_result = __riscv_vmerge_vvm_u32m1(v_rotated, v_negated, condition_mask, vl);\n        \n        // Store result\n        __riscv_vse32_v_u32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, veps;\n    vint8m1_t vout;\n    \n    // Broadcast epsilon to vector register\n    veps = vfmv_v_f_f32m1(epsilon, 16);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors from A and B\n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        // Compute A[i] - B[i]\n        vfloat32m1_t vdiff = __riscv_vfsub_vv_f32m1(va, vb, vl);\n        \n        // Compare with positive epsilon\n        vbool32_t vgt_eps = __riscv_vfgt_vv_f32m1_b32(vdiff, veps, vl);\n        \n        // Compare with negative epsilon\n        vbool32_t vlt_negeps = __riscv_vflt_vv_f32m1_b32(vdiff, __riscv_vfneg_v_f32m1(veps, vl), vl);\n        \n        // Create output vector\n        vout = __riscv_vmv_v_x_i8m1(0, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, 1, vgt_eps, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, -1, vlt_negeps, vl);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl = __riscv_vsetvlmax_e32m1();\n    float abs_epsilon = fabsf(epsilon);\n\n    for (size_t i = 0; i < length; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors A and B\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vlmax);\n        vfloat32m1_t vb = __riscv_vle32_v_f32m1(B + i, vlmax);\n        \n        // Compute A[i] - B[i]\n        vfloat32m1_t vdiff = __riscv_vfsub_vv_f32m1(va, vb, vlmax);\n        \n        // Compute absolute difference\n        vfloat32m1_t vabs_diff = __riscv_vfabs_v_f32m1(vdiff, vlmax);\n        \n        // Compare with epsilon\n        vbool32_t vgt_epsilon = __riscv_vmfgt_vf_f32m1_b32(vdiff, abs_epsilon, vlmax);\n        vbool32_t vlt_neg_epsilon = __riscv_vmflt_vf_f32m1_b32(vdiff, -abs_epsilon, vlmax);\n        vbool32_t veq_epsilon = __riscv_vmfle_vf_f32m1_b32(vabs_diff, abs_epsilon, vlmax);\n        \n        // Create output vector\n        vint8m1_t vout = __riscv_vmv_v_x_i8m1(0, vlmax);\n        vout = __riscv_vmerge_vxm_i8m1(vout, 1, vgt_epsilon, vlmax);\n        vout = __riscv_vmerge_vxm_i8m1(vout, -1, vlt_neg_epsilon, vlmax);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(out + i, vout, vlmax);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, veps;\n    vint8m1_t vout;\n    \n    // Broadcast epsilon to vector register\n    veps = vfmv_v_f_f32m1(epsilon, 16);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors from A and B\n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        // Compute A[i] - B[i]\n        vfloat32m1_t vdiff = __riscv_vfsub_vv_f32m1(va, vb, vl);\n        \n        // Compare with positive epsilon\n        vbool32_t vmask_pos = __riscv_vfgt_vv_f32m1_b32(vdiff, veps, vl);\n        \n        // Compare with negative epsilon\n        vbool32_t vmask_neg = __riscv_vflt_vv_f32m1_b32(vdiff, __riscv_vfneg_v_f32m1(veps, vl), vl);\n        \n        // Create output vector\n        vout = __riscv_vmv_v_x_i8m1(0, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, 1, vmask_pos, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, -1, vmask_neg, vl);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, veps;\n    vint8m1_t vout;\n    \n    // Broadcast epsilon to a vector\n    veps = vfmv_v_f_f32m1(epsilon, 16);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors from A and B\n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        // Compute A[i] - B[i]\n        vfloat32m1_t vdiff = __riscv_vfsub_vv_f32m1(va, vb, vl);\n        \n        // Compute absolute difference\n        vfloat32m1_t vabs_diff = __riscv_vfabs_v_f32m1(vdiff, vl);\n        \n        // Compare and set output vector\n        vout = __riscv_vmseq_vf_f32m1_b8(__riscv_vfle_vv_f32m1(vabs_diff, veps, vl), 0, vl);\n        vint8m1_t vgt = __riscv_vmfgt_vf_f32m1_b8(vdiff, 0, vl);\n        vint8m1_t vlt = __riscv_vmflt_vf_f32m1_b8(vdiff, 0, vl);\n        \n        vout = __riscv_vmerge_vxm_i8m1(vout, 1, vgt, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, -1, vlt, vl);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    vfloat32m1_t va, vb, veps;\n    vint8m1_t vout;\n    \n    // Broadcast epsilon to vector\n    veps = vfmv_v_f_f32m1(epsilon, 16);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load vectors A and B\n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        // Compute A[i] - B[i]\n        vfloat32m1_t vdiff = __riscv_vfsub_vv_f32m1(va, vb, vl);\n        \n        // Compare with positive epsilon\n        vbool32_t vgt_eps = __riscv_vfgt_vv_f32m1_b32(vdiff, veps, vl);\n        \n        // Compare with negative epsilon\n        vbool32_t vlt_neg_eps = __riscv_vflt_vv_f32m1_b32(vdiff, __riscv_vfneg_v_f32m1(veps, vl), vl);\n        \n        // Create output vector\n        vout = __riscv_vmv_v_x_i8m1(0, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, 1, vgt_eps, vl);\n        vout = __riscv_vmerge_vxm_i8m1(vout, -1, vlt_neg_eps, vl);\n        \n        // Store result\n        __riscv_vse8_v_i8m1(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load float vector\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        \n        // Convert float to int with saturation\n        vint32m1_t vb = __riscv_vfcvt_rtz_x_f_v_i32m1(va, vl);\n        \n        // Store result vector\n        __riscv_vse32_v_i32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load float vector\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        \n        // Convert float to int with saturation\n        vint32m1_t vb = __riscv_vfcvt_rtz_x_f_v_i32m1(va, vl);\n        \n        // Store result vector\n        __riscv_vse32_v_i32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load float vector\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        \n        // Convert float to int with saturation\n        vint32m1_t vb = __riscv_vfcvt_rtz_x_f_v_i32m1(va, vl);\n        \n        // Store result vector\n        __riscv_vse32_v_i32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load float vector\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        \n        // Convert float to int with saturation\n        vint32m1_t vb = __riscv_vfcvt_rtz_x_f_v_i32m1(va, vl);\n        \n        // Store converted vector\n        __riscv_vse32_v_i32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load float vector\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        \n        // Convert float to int with saturation\n        vint32m1_t vb = __riscv_vfcvt_rtz_x_f_v_i32m1(va, vl);\n        \n        // Store result vector\n        __riscv_vse32_v_i32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source vector\n        vint32m1_t vec_a = __riscv_vle32_v_i32m1(A + i, vl);\n        \n        // Convert int32 to float\n        vfloat32m1_t vec_float = __riscv_vfcvt_f_x_v_f32m1(vec_a, vl);\n        \n        // Scale the float values\n        vfloat32m1_t vec_scaled = __riscv_vfmul_vf_f32m1(vec_float, (float)scale, vl);\n        \n        // Store result to destination\n        __riscv_vse32_v_f32m1(B + i, vec_scaled, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    vfloat32m1_t scale_vec = __riscv_vfmv_v_f_f32m1((float)scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        vint32m1_t a_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t float_vec = __riscv_vfcvt_f_x_v_f32m1(a_vec, vl);\n        vfloat32m1_t scaled_vec = __riscv_vfmul_vv_f32m1(float_vec, scale_vec, vl);\n        __riscv_vse32_v_f32m1(B + i, scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    vfloat32m1_t scale_vec = __riscv_vfmv_v_f_f32m1((float)scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        vint32m1_t a_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t float_vec = __riscv_vfcvt_f_x_v_f32m1(a_vec, vl);\n        vfloat32m1_t scaled_vec = __riscv_vfmul_vv_f32m1(float_vec, scale_vec, vl);\n        __riscv_vse32_v_f32m1(B + i, scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    vfloat32m1_t scale_vec = __riscv_vfmv_v_f_f32m1((float)scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        vint32m1_t a_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t b_vec = __riscv_vfcvt_f_x_v_f32m1(a_vec, vl);\n        b_vec = __riscv_vfmul_vv_f32m1(b_vec, scale_vec, vl);\n        __riscv_vse32_v_f32m1(B + i, b_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    vfloat32m1_t scale_vec = __riscv_vfmv_v_f_f32m1((float)scale, vl);\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        vint32m1_t a_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vfloat32m1_t float_vec = __riscv_vfcvt_f_x_v_f32m1(a_vec, vl);\n        vfloat32m1_t scaled_vec = __riscv_vfmul_vv_f32m1(float_vec, scale_vec, vl);\n        __riscv_vse32_v_f32m1(B + i, scaled_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vresult;\n    vint32m1_t vround;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        vresult = __riscv_vfdiv_vv_f32m1(va, vb, vl);\n        \n        vround = __riscv_vfcvt_rtz_x_f_v_i32m1(vresult, vl);\n        \n        __riscv_vse32_v_i32m1(C + i, vround, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        vfloat32m1_t vdiv = __riscv_vfdiv_vv_f32m1(va, vb, vl);\n        \n        vint32m1_t vround = __riscv_vfcvt_rtz_x_f_v_i32m1(vdiv, vl);\n        \n        __riscv_vse32_v_i32m1(C + i, vround, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load vectors from A and B\n        vfloat32m1_t va = __riscv_vle32_v_f32m1(A + i, vl);\n        vfloat32m1_t vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        // Perform element-wise division\n        vfloat32m1_t vdiv = __riscv_vfdiv_vv_f32m1(va, vb, vl);\n        \n        // Round to nearest integer\n        vint32m1_t vround = __riscv_vfcvt_rtz_x_f_v_i32m1(vdiv, vl);\n        \n        // Store result in C\n        __riscv_vse32_v_i32m1(C + i, vround, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vresult;\n    vint32m1_t vround;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        vresult = __riscv_vfdiv_vv_f32m1(va, vb, vl);\n        \n        vround = __riscv_vfcvt_rtz_x_f_v_i32m1(vresult, vl);\n        \n        __riscv_vse32_v_i32m1(C + i, vround, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vresult;\n    vint32m1_t vround;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        va = __riscv_vle32_v_f32m1(A + i, vl);\n        vb = __riscv_vle32_v_f32m1(B + i, vl);\n        \n        vresult = __riscv_vfdiv_vv_f32m1(va, vb, vl);\n        \n        vround = __riscv_vfcvt_rtz_x_f_v_i32m1(vresult, vl);\n        \n        __riscv_vse32_v_i32m1(C + i, vround, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e64m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e64m1(size - i);\n        \n        // Load source vector\n        vfloat64m1_t src_vec = __riscv_vle64_v_f64m1(A + i, vl);\n        \n        // Saturate to float range\n        vfloat64m1_t max_vec = __riscv_vfmv_v_f_f64m1(FLT_MAX, vl);\n        vfloat64m1_t min_vec = __riscv_vfmv_v_f_f64m1(-FLT_MAX, vl);\n        \n        vfloat64m1_t saturated_vec = __riscv_vfmin_vv_f64m1(\n            __riscv_vfmax_vv_f64m1(src_vec, min_vec, vl), \n            max_vec, vl\n        );\n        \n        // Convert to float\n        vfloat32m1_t float_vec = __riscv_vfncvt_rod_f_f_w_f32m1(saturated_vec, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, float_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e64m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e64m1(size - i);\n        \n        // Load source vector\n        vfloat64m1_t src_vec = __riscv_vle64_v_f64m1(A + i, vl);\n        \n        // Convert and saturate to float\n        vfloat32m1_t dest_vec = __riscv_vfncvt_rod_f_f_w_f32m1(src_vec, vl);\n        \n        // Store result vector\n        __riscv_vse32_v_f32m1(B + i, dest_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e64m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e64m1(size - i);\n        \n        // Load source double vector\n        vfloat64m1_t vec_double = __riscv_vle64_v_f64m1(A + i, vl);\n        \n        // Clamp values to float range\n        vfloat64m1_t vec_max = __riscv_vfmin_vf_f64m1(vec_double, FLT_MAX, vl);\n        vfloat64m1_t vec_clamped = __riscv_vfmax_vf_f64m1(vec_max, -FLT_MAX, vl);\n        \n        // Convert double to float\n        vfloat32m1_t vec_float = __riscv_vfncvt_rod_f_f_w_f32m1(vec_clamped, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, vec_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e64m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e64m1(size - i);\n        \n        // Load source vector\n        vfloat64m1_t src_vec = __riscv_vle64_v_f64m1(A + i, vl);\n        \n        // Convert and saturate\n        vfloat32m1_t dest_vec = __riscv_vfncvt_rod_f_f_w_f32m1(src_vec, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, dest_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e64m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e64m1(size - i);\n        \n        // Load source double vector\n        vfloat64m1_t vec_double = __riscv_vle64_v_f64m1(A + i, vl);\n        \n        // Convert and saturate to float\n        vfloat32m1_t vec_float = __riscv_vfncvt_rod_f_f_w_f32m1(vec_double, vl);\n        \n        // Store result to destination\n        __riscv_vse32_v_f32m1(B + i, vec_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    vint16m1_t vec_input;\n    vint32m2_t vec_output;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e16m1(size - i);\n        vec_input = __riscv_vle16_v_i16m1(A + i, vl);\n        vec_output = __riscv_vwadd_vx_i32m2(vec_input, 0, vl);\n        __riscv_vse32_v_i32m2(B + i, vec_output, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    vint16m1_t vec_input;\n    vint32m2_t vec_output;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e16m1(size - i);\n        vec_input = __riscv_vle16_v_i16m1(A + i, vl);\n        vec_output = __riscv_vwcvt_x_x_v_i32m2(vec_input, vl);\n        __riscv_vse32_v_i32m2(B + i, vec_output, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    vint16m1_t vec_input;\n    vint32m2_t vec_output;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e16m1(size - i);\n        \n        vec_input = __riscv_vle16_v_i16m1(A + i, vl);\n        vec_output = __riscv_vwcvt_x_x_v_i32m2(vec_input, vl);\n        \n        __riscv_vse32_v_i32m2(B + i, vec_output, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    vint16m1_t vec_input;\n    vint32m2_t vec_output;\n\n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e16m1(size - i);\n        vec_input = __riscv_vle16_v_i16m1(A + i, vl);\n        vec_output = __riscv_vwcvt_x_x_v_i32m2(vec_input, vl);\n        __riscv_vse32_v_i32m2(B + i, vec_output, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e16m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e16m1(size - i);\n        \n        // Load 16-bit integers from source array\n        vint16m1_t va = __riscv_vle16_v_i16m1(A + i, vl);\n        \n        // Sign-extend 16-bit integers to 32-bit integers\n        vint32m2_t vb = __riscv_vsext_vf2_i32m2(va, vl);\n        \n        // Store converted values to destination array\n        __riscv_vse32_v_i32m2(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // Precompute denominator\n    float range = max_val - min_val;\n    vfloat32m1_t v_min = __riscv_vfmv_v_f_f32m1(min_val, vl);\n    vfloat32m1_t v_max = __riscv_vfmv_v_f_f32m1(max_val, vl);\n    vfloat32m1_t v_range = __riscv_vfmv_v_f_f32m1(range, vl);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load input arrays\n        vfloat32m1_t v_a = __riscv_vle32_v_f32m1(A + i, vl);\n        vint32m1_t v_control = __riscv_vle32_v_i32m1(control + i, vl);\n        \n        // Create mask for control > 0\n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(v_control, 0, vl);\n        \n        // Normalize where control > 0\n        vfloat32m1_t v_normalized = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n        v_normalized = __riscv_vfadd_vv_f32m1_m(mask, v_normalized, v_a, -v_min, vl);\n        v_normalized = __riscv_vfdiv_vv_f32m1_m(mask, v_normalized, v_normalized, v_range, vl);\n        \n        // Clamp values between 0 and 1\n        v_normalized = __riscv_vfmax_vf_f32m1_m(mask, v_normalized, v_normalized, 0.0f, vl);\n        v_normalized = __riscv_vfmin_vf_f32m1_m(mask, v_normalized, v_normalized, 1.0f, vl);\n        \n        // Where control <= 0, copy original values\n        v_normalized = __riscv_vmerge_vvm_f32m1(mask, v_a, v_normalized, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, v_normalized, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // Precompute denominator\n    float range = max_val - min_val;\n    vfloat32m1_t v_min = __riscv_vfmv_v_f_f32m1(min_val, vl);\n    vfloat32m1_t v_max = __riscv_vfmv_v_f_f32m1(max_val, vl);\n    vfloat32m1_t v_range = __riscv_vfmv_v_f_f32m1(range, vl);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load input arrays\n        vfloat32m1_t v_A = __riscv_vle32_v_f32m1(A + i, vl);\n        vint32m1_t v_control = __riscv_vle32_v_i32m1(control + i, vl);\n        \n        // Create mask for control > 0\n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(v_control, 0, vl);\n        \n        // Normalize values where control > 0\n        vfloat32m1_t v_normalized = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n        v_normalized = __riscv_vfsub_vv_f32m1_m(mask, v_A, v_min, vl);\n        v_normalized = __riscv_vfdiv_vv_f32m1_m(mask, v_normalized, v_range, vl);\n        \n        // Clamp normalized values between 0 and 1\n        v_normalized = __riscv_vfmax_vf_f32m1_m(mask, v_normalized, 0.0f, vl);\n        v_normalized = __riscv_vfmin_vf_f32m1_m(mask, v_normalized, 1.0f, vl);\n        \n        // Where control <= 0, copy original values\n        v_normalized = __riscv_vmerge_vvm_f32m1(mask, v_A, v_normalized, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, v_normalized, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // Precompute denominator\n    float range = max_val - min_val;\n    vfloat32m1_t v_min = __riscv_vfmv_v_f_f32m1(min_val, vl);\n    vfloat32m1_t v_range = __riscv_vfmv_v_f_f32m1(range, vl);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load input arrays\n        vfloat32m1_t v_a = __riscv_vle32_v_f32m1(A + i, vl);\n        vint32m1_t v_control = __riscv_vle32_v_i32m1(control + i, vl);\n        \n        // Create mask for control > 0\n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(v_control, 0, vl);\n        \n        // Compute normalized values where control > 0\n        vfloat32m1_t v_normalized = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t v_temp = __riscv_vfsub_vv_f32m1(v_a, v_min, vl);\n        v_temp = __riscv_vfdiv_vv_f32m1_m(mask, v_temp, v_range, vl);\n        \n        // Clamp values between 0 and 1\n        v_normalized = __riscv_vfmax_vf_f32m1_m(mask, v_normalized, v_temp, 0.0f, vl);\n        v_normalized = __riscv_vfmin_vf_f32m1_m(mask, v_normalized, v_normalized, 1.0f, vl);\n        \n        // Where control <= 0, copy original values\n        v_normalized = __riscv_vmerge_vvm_f32m1(mask, v_a, v_normalized, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, v_normalized, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // Precompute denominator\n    float range = max_val - min_val;\n    vfloat32m1_t v_min = __riscv_vfmv_v_f_f32m1(min_val, vl);\n    vfloat32m1_t v_max = __riscv_vfmv_v_f_f32m1(max_val, vl);\n    vfloat32m1_t v_range = __riscv_vfmv_v_f_f32m1(range, vl);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load control, source array\n        vint32m1_t v_control = __riscv_vle32_v_i32m1(control + i, vl);\n        vfloat32m1_t v_src = __riscv_vle32_v_f32m1(A + i, vl);\n        \n        // Create mask for normalization\n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(v_control, 0, vl);\n        \n        // Normalized values\n        vfloat32m1_t v_normalized = __riscv_vfsub_vv_f32m1_m(mask, v_src, v_min, vl);\n        v_normalized = __riscv_vfdiv_vv_f32m1_m(mask, v_normalized, v_range, vl);\n        \n        // Clamp values between 0 and 1\n        v_normalized = __riscv_vfmax_vf_f32m1_m(mask, v_normalized, 0.0f, vl);\n        v_normalized = __riscv_vfmin_vf_f32m1_m(mask, v_normalized, 1.0f, vl);\n        \n        // Select between normalized or original values\n        vfloat32m1_t v_result = __riscv_vmerge_vvm_f32m1(v_src, v_normalized, mask, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // Precompute range\n    float range = max_val - min_val;\n    vfloat32m1_t v_min = __riscv_vfmv_v_f_f32m1(min_val, vl);\n    vfloat32m1_t v_max = __riscv_vfmv_v_f_f32m1(1.0f, vl);\n    vfloat32m1_t v_zero = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source arrays\n        vfloat32m1_t v_a = __riscv_vle32_v_f32m1(A + i, vl);\n        vint32m1_t v_control = __riscv_vle32_v_i32m1(control + i, vl);\n        \n        // Create mask for control > 0\n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(v_control, 0, vl);\n        \n        // Normalize where control > 0\n        vfloat32m1_t v_normalized = __riscv_vfsub_vv_f32m1_m(mask, v_a, v_min, vl);\n        v_normalized = __riscv_vfdiv_vf_f32m1_m(mask, v_normalized, range, vl);\n        \n        // Clamp normalized values\n        v_normalized = __riscv_vfmin_vv_f32m1_m(mask, v_normalized, v_max, vl);\n        v_normalized = __riscv_vfmax_vv_f32m1_m(mask, v_normalized, v_zero, vl);\n        \n        // Where control <= 0, copy original values\n        vfloat32m1_t v_result = __riscv_vmerge_vvm_f32m1(v_normalized, v_a, mask, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source array\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Extract high 16 bits and convert to float\n        vuint16m1_t high_bits = __riscv_vsrl_vx_u32m1(vec_a, 16, vl);\n        vfloat32m1_t float_vals = __riscv_vfcvt_f_xu_v_f32m1(high_bits, vl);\n        \n        // Compute square root\n        vfloat32m1_t sqrt_vals = __riscv_vfsqrt_v_f32m1(float_vals, vl);\n        \n        // Store result\n        __riscv_vse32_v_f32m1(B + i, sqrt_vals, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source array\n        vuint32m1_t va = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        vuint32m1_t high_bits = __riscv_vsrl_vx_u32m1(va, 16, vl);\n        \n        // Convert unsigned int to float\n        vfloat32m1_t float_vals = __riscv_vfcvt_f_xu_v_f32m1(high_bits, vl);\n        \n        // Calculate square root\n        vfloat32m1_t sqrt_vals = __riscv_vfsqrt_v_f32m1(float_vals, vl);\n        \n        // Store results\n        __riscv_vse32_v_f32m1(B + i, sqrt_vals, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source array\n        vuint32m1_t va = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        vuint32m1_t high_bits = __riscv_vsrl_vx_u32m1(va, 16, vl);\n        \n        // Convert uint32 to float\n        vfloat32m1_t float_vals = __riscv_vfcvt_f_xu_v_f32m1(high_bits, vl);\n        \n        // Calculate square root\n        vfloat32m1_t sqrt_vals = __riscv_vfsqrt_v_f32m1(float_vals, vl);\n        \n        // Store result in destination array\n        __riscv_vse32_v_f32m1(B + i, sqrt_vals, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source array\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        vuint32m1_t vec_high = __riscv_vsrl_vx_u32m1(vec_a, 16, vl);\n        \n        // Convert uint32 to float\n        vfloat32m1_t vec_float = __riscv_vfcvt_f_xu_v_f32m1(vec_high, vl);\n        \n        // Calculate square root\n        vfloat32m1_t vec_sqrt = __riscv_vfsqrt_v_f32m1(vec_float, vl);\n        \n        // Store result in destination array\n        __riscv_vse32_v_f32m1(B + i, vec_sqrt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load source array\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        vuint32m1_t vec_high = __riscv_vsrl_vx_u32m1(vec_a, 16, vl);\n        \n        // Convert uint32 to float\n        vfloat32m1_t vec_float = __riscv_vfcvt_f_xu_v_f32m1(vec_high, vl);\n        \n        // Calculate square root\n        vfloat32m1_t vec_sqrt = __riscv_vfsqrt_v_f32m1(vec_float, vl);\n        \n        // Store result in destination array\n        __riscv_vse32_v_f32m1(B + i, vec_sqrt, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load uint32_t vector\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Reinterpret bits directly as float vector\n        vfloat32m1_t vec_b = __riscv_vreinterpret_v_u32m1_f32m1(vec_a);\n        \n        // Store float vector\n        __riscv_vse32_v_f32m1(B + i, vec_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load uint32_t values from source array\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Reinterpret bits directly as float using type-punning\n        vfloat32m1_t vec_b = __riscv_vreinterpret_v_u32m1_f32m1(vec_a);\n        \n        // Store result in destination array\n        __riscv_vse32_v_f32m1(B + i, vec_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load uint32_t vector from source array\n        vuint32m1_t vec_int = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Reinterpret bits directly as float vector\n        vfloat32m1_t vec_float = __riscv_vreinterpret_v_u32m1_f32m1(vec_int);\n        \n        // Store float vector to destination array\n        __riscv_vse32_v_f32m1(B + i, vec_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load uint32_t values from source array\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Reinterpret bits directly as float using type-punning\n        vfloat32m1_t vec_b = __riscv_vreinterpret_v_u32m1_f32m1(vec_a);\n        \n        // Store float values to destination array\n        __riscv_vse32_v_f32m1(B + i, vec_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load uint32_t values from source array\n        vuint32m1_t vec_a = __riscv_vle32_v_u32m1(A + i, vl);\n        \n        // Reinterpret bits directly as float using type-punning\n        vfloat32m1_t vec_b = __riscv_vreinterpret_v_u32m1_f32m1(vec_a);\n        \n        // Store float values to destination array\n        __riscv_vse32_v_f32m1(B + i, vec_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // First element always set to 0.0f\n    diff[0] = 0.0f;\n    \n    // Process remaining elements in vector chunks\n    for (size_t i = 1; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load condition vector\n        vbool32_t mask = __riscv_vlm_v_b32(cond + i, vl);\n        \n        // Load current and previous integer arrays\n        vint32m1_t current_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(A + i - 1, vl);\n        \n        // Compute differences\n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(current_vec, prev_vec, vl);\n        \n        // Convert differences to float\n        vfloat32m1_t float_diff_vec = __riscv_vcvt_f_x_v_f32m1(diff_vec, vl);\n        \n        // Conditionally store differences or zero\n        __riscv_vfmv_s_f_f32m1(float_diff_vec, 0.0f, vl);\n        __riscv_vsm_v_f32m1_m(mask, diff + i, float_diff_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // First element is always 0.0f\n    diff[0] = 0.0f;\n    \n    // Process remaining elements in vector chunks\n    for (size_t i = 1; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load condition vector\n        vbool32_t mask = __riscv_vlm_v_b32(cond + i, vl);\n        \n        // Load current and previous integer arrays\n        vint32m1_t curr_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(A + i - 1, vl);\n        \n        // Compute differences\n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(curr_vec, prev_vec, vl);\n        \n        // Convert differences to float\n        vfloat32m1_t float_diff = __riscv_vcvt_f_x_v_f32m1(diff_vec, vl);\n        \n        // Conditionally set values based on condition\n        vfloat32m1_t zero_vec = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t result_vec = __riscv_vmerge_vvm_f32m1(zero_vec, float_diff, mask, vl);\n        \n        // Store results\n        __riscv_vse32_v_f32m1(diff + i, result_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // First element always set to 0.0f\n    diff[0] = 0.0f;\n    \n    // Process remaining elements in vector chunks\n    for (size_t i = 1; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load condition vector\n        vbool32_t vmask = __riscv_vlm_v_b32(cond + i, vl);\n        \n        // Load current and previous integer arrays\n        vint32m1_t va_curr = __riscv_vle32_v_i32m1(A + i, vl);\n        vint32m1_t va_prev = __riscv_vle32_v_i32m1(A + i - 1, vl);\n        \n        // Compute differences\n        vint32m1_t vdiff = __riscv_vsub_vv_i32m1(va_curr, va_prev, vl);\n        \n        // Convert differences to float\n        vfloat32m1_t vf_diff = __riscv_vcvt_f_x_v_f32m1(vdiff, vl);\n        \n        // Conditionally set values based on mask\n        vfloat32m1_t vzero = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t vresult = __riscv_vmerge_vvm_f32m1(vzero, vf_diff, vmask, vl);\n        \n        // Store results\n        __riscv_vse32_v_f32m1(diff + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // First element always set to 0.0f\n    diff[0] = 0.0f;\n    \n    // Process remaining elements in vector chunks\n    for (size_t i = 1; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load condition vector\n        vbool32_t mask = __riscv_vlm_v_b32(cond + i, vl);\n        \n        // Load current and previous integer arrays\n        vint32m1_t current_vec = __riscv_vle32_v_i32m1(A + i, vl);\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(A + i - 1, vl);\n        \n        // Compute differences\n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(current_vec, prev_vec, vl);\n        \n        // Convert differences to float\n        vfloat32m1_t float_diff_vec = __riscv_vcvt_f_x_v_f32m1(diff_vec, vl);\n        \n        // Conditionally store differences or zero\n        __riscv_vfmv_s_f_f32m1(float_diff_vec, 0.0f, vl);\n        __riscv_vsm_v_f32m1_m(mask, diff + i, float_diff_vec, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t vl = __riscv_vsetvl_e32m1(size);\n    \n    // First element always set to 0.0f\n    diff[0] = 0.0f;\n    \n    // Process remaining elements in vector chunks\n    for (size_t i = 1; i < size; i += vl) {\n        vl = __riscv_vsetvl_e32m1(size - i);\n        \n        // Load condition vector\n        vbool32_t vmask = __riscv_vlm_v_b32(cond + i, vl);\n        \n        // Load current and previous integer elements\n        vint32m1_t va_curr = __riscv_vle32_v_i32m1(A + i, vl);\n        vint32m1_t va_prev = __riscv_vle32_v_i32m1(A + i - 1, vl);\n        \n        // Compute differences\n        vint32m1_t vdiff = __riscv_vsub_vv_i32m1(va_curr, va_prev, vl);\n        \n        // Convert differences to float\n        vfloat32m1_t vfloat_diff = __riscv_vfcvt_f_x_v_f32m1(vdiff, vl);\n        \n        // Conditionally set values based on condition mask\n        vfloat32m1_t vzero = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n        vfloat32m1_t vresult = __riscv_vmerge_vvm_f32m1(vzero, vfloat_diff, vmask, vl);\n        \n        // Store results\n        __riscv_vse32_v_f32m1(diff + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src;\n    vfloat64m2_t v_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Convert and set high bits to 1\n        v_dst = __riscv_vfwcvt_xu_f_v_f64m2(__riscv_vfcvt_f_xu_v_f32m1(v_src, vl), vl);\n        v_dst = __riscv_vor_vx_f64m2(v_dst, 0xFFFFFFFF00000000ULL, vl);\n        \n        // Store result vector\n        __riscv_vse64_v_f64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src;\n    vfloat64m2_t v_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Convert and set high bits to 1\n        v_dst = __riscv_vfwcvt_xu_f_v_f64m2(__riscv_vfcvt_f_xu_v_f32m1(v_src, vl), vl);\n        v_dst = __riscv_vor_vx_f64m2(v_dst, 0xFFFFFFFF00000000ULL, vl);\n        \n        // Store result\n        __riscv_vse64_v_f64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src;\n    vfloat64m2_t v_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Convert and set high 32 bits to 1\n        v_dst = __riscv_vfwcvt_xu_f_v_f64m2(__riscv_vfcvt_f_xu_v_f32m1(v_src, vl), vl);\n        v_dst = __riscv_vor_vx_f64m2(v_dst, 0xFFFFFFFF00000000ULL, vl);\n        \n        // Store result\n        __riscv_vse64_v_f64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src;\n    vfloat64m2_t v_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Convert and set high bits to 1\n        v_dst = __riscv_vfwcvt_xu_f_v_f64m2(__riscv_vfcvt_f_xu_v_f32m1(v_src, vl), vl);\n        v_dst = __riscv_vor_vx_f64m2(v_dst, 0xFFFFFFFF00000000ULL, vl);\n        \n        // Store destination vector\n        __riscv_vse64_v_f64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src;\n    vfloat64m2_t v_dst;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = __riscv_vle32_v_f32m1(src + i, vl);\n        \n        // Convert and set high 32 bits to 1\n        v_dst = __riscv_vfwcvt_xu_f_v_f64m2(__riscv_vfcvt_f_xu_v_f32m1(v_src, vl), vl);\n        v_dst = __riscv_vor_vx_f64m2(v_dst, 0xFFFFFFFF00000000ULL, vl);\n        \n        // Store result\n        __riscv_vse64_v_f64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n    vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load indices\n        vint16m1_t index_vec = __riscv_vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to size_t for gathering\n        vuint64m1_t index_u64 = __riscv_vzext_vf2_u64m1(index_vec, vl);\n        \n        // Gather elements from vec based on indices\n        vfloat64m1_t gathered_vec = __riscv_vloxei64_v_f64m1(vec, index_u64, vl);\n        \n        // Sum the gathered elements\n        sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(gathered_vec, sum_vec, vl);\n    }\n\n    // Extract final scalar sum\n    result = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n    vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load indices\n        vint16m1_t index_vec = __riscv_vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to size_t for gathering\n        vuint64m1_t index_u64 = __riscv_vzext_vf4_u64m1(index_vec, vl);\n        \n        // Gather elements from vec based on indices\n        vfloat64m1_t gathered_vec = __riscv_vloxei64_v_f64m1(vec, index_u64, vl);\n        \n        // Sum gathered elements\n        sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(sum_vec, gathered_vec, sum_vec, vl);\n    }\n\n    // Extract final sum\n    result = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n    vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load indices\n        vint16m1_t index_vec = __riscv_vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to size_t for gathering\n        vuint64m1_t index_u64 = __riscv_vzext_vf2_u64m1(index_vec, vl);\n        \n        // Gather elements from vec based on indices\n        vfloat64m1_t gathered_vec = __riscv_vloxei64_v_f64m1(vec, index_u64, vl);\n        \n        // Sum the gathered elements\n        sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(sum_vec, gathered_vec, sum_vec, vl);\n    }\n\n    // Extract final sum\n    result = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n    vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load indices\n        vint16m1_t index_vec = __riscv_vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to size_t for gathering\n        vuint64m1_t index_u64 = __riscv_vzext_vf4_u64m1(index_vec, vl);\n        \n        // Gather elements from vec based on indices\n        vfloat64m1_t gathered_vec = __riscv_vloxei64_v_f64m1(vec, index_u64, vl);\n        \n        // Sum gathered elements\n        sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(sum_vec, gathered_vec, sum_vec, vl);\n    }\n\n    // Extract final sum\n    result = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    size_t vl;\n    vfloat64m1_t sum_vec = __riscv_vfmv_s_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e64m1(length - i);\n        \n        // Load indices\n        vint16m1_t index_vec = __riscv_vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to size_t for gathering\n        vuint64m1_t index_u64 = __riscv_vzext_vf4_u64m1(index_vec, vl);\n        \n        // Gather elements from vec based on indices\n        vfloat64m1_t gathered_vec = __riscv_vloxei64_v_f64m1(vec, index_u64, vl);\n        \n        // Sum the gathered elements\n        sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(sum_vec, gathered_vec, sum_vec, vl);\n    }\n\n    // Extract final sum\n    result = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(output_size - j);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(\n                        &input[(i + ki) * input_size + j + kj], \n                        vl\n                    );\n                    \n                    vfloat64m1_t kernel_vec = __riscv_vfmv_v_f_f64m1(\n                        kernel[ki * kernel_size + kj], \n                        vl\n                    );\n                    \n                    sum_vec = __riscv_vfmadd_vf_f64m1(\n                        input_vec, \n                        kernel[ki * kernel_size + kj], \n                        sum_vec, \n                        vl\n                    );\n                }\n            }\n            \n            // ReLU activation\n            sum_vec = __riscv_vfmax_vf_f64m1(sum_vec, 0.0, vl);\n            \n            __riscv_vse64_v_f64m1(\n                &output[i * output_size + j], \n                sum_vec, \n                vl\n            );\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(output_size - j);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(\n                        &input[(i + ki) * input_size + j + kj], \n                        vl\n                    );\n                    vfloat64m1_t kernel_vec = __riscv_vfmv_v_f_f64m1(\n                        kernel[ki * kernel_size + kj], \n                        vl\n                    );\n                    \n                    sum_vec = __riscv_vfmadd_vf_f64m1(\n                        kernel[ki * kernel_size + kj], \n                        input_vec, \n                        sum_vec, \n                        vl\n                    );\n                }\n            }\n\n            // ReLU activation\n            sum_vec = __riscv_vfmax_vf_f64m1(sum_vec, 0.0, vl);\n\n            __riscv_vse64_v_f64m1(\n                &output[i * output_size + j], \n                sum_vec, \n                vl\n            );\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(output_size);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    double input_val = input[(i + ki) * input_size + (j + kj)];\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    \n                    vfloat64m1_t input_vec = __riscv_vfmv_v_f_f64m1(input_val, vl);\n                    vfloat64m1_t kernel_vec = __riscv_vfmv_v_f_f64m1(kernel_val, vl);\n                    \n                    sum_vec = __riscv_vfmadd_vv_f64m1(input_vec, kernel_vec, sum_vec, vl);\n                }\n            }\n            \n            // ReLU activation\n            sum_vec = __riscv_vfmax_vv_f64m1(sum_vec, __riscv_vfmv_v_f_f64m1(0.0, vl), vl);\n            \n            output[i * output_size + j] = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(output_size);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    double input_val = input[(i + ki) * input_size + (j + kj)];\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    \n                    vfloat64m1_t input_vec = __riscv_vfmv_v_f_f64m1(input_val, vl);\n                    vfloat64m1_t kernel_vec = __riscv_vfmv_v_f_f64m1(kernel_val, vl);\n                    \n                    sum_vec = __riscv_vfmadd_vv_f64m1(input_vec, kernel_vec, sum_vec, vl);\n                }\n            }\n            \n            // ReLU activation\n            sum_vec = __riscv_vfmax_vv_f64m1(sum_vec, __riscv_vfmv_v_f_f64m1(0.0, vl), vl);\n            \n            output[i * output_size + j] = __riscv_vfmv_f_s_f64m1_f64(sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t vl = __riscv_vsetvl_e64m1(output_size - j);\n            vfloat64m1_t sum_vec = __riscv_vfmv_v_f_f64m1(0.0, vl);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    vfloat64m1_t input_vec = __riscv_vle64_v_f64m1(\n                        &input[(i + ki) * input_size + j + kj], \n                        vl\n                    );\n                    \n                    vfloat64m1_t kernel_vec = __riscv_vfmv_v_f_f64m1(\n                        kernel[ki * kernel_size + kj], \n                        vl\n                    );\n                    \n                    sum_vec = __riscv_vfmacc_vv_f64m1(sum_vec, input_vec, kernel_vec, vl);\n                }\n            }\n            \n            // ReLU activation\n            sum_vec = __riscv_vfmax_vv_f64m1(sum_vec, __riscv_vfmv_v_f_f64m1(0.0, vl), vl);\n            \n            __riscv_vse64_v_f64m1(&output[i * output_size + j], sum_vec, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    // Determine maximum vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Load first vector\n    vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(numbers.data(), vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e64m1(n - i);\n\n        // Load current vector\n        vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(numbers.data() + i, vl);\n\n        // Compute absolute differences\n        for (size_t j = 0; j < i; j += vl) {\n            vfloat64m1_t vec_j = __riscv_vle64_v_f64m1(numbers.data() + j, vl);\n            vfloat64m1_t diff = __riscv_vfsub_vv_f64m1(vec1, vec2, vl);\n            vfloat64m1_t abs_diff = __riscv_vfabs_v_f64m1(diff, vl);\n\n            // Check if any difference is less than threshold\n            vbool64_t mask = __riscv_vmflt_vf_f64m1_b64(abs_diff, threshold, vl);\n            if (__riscv_vmfirst_m_b64(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    // Determine maximum vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Load first vector\n    vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(numbers.data(), vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e64m1(n - i);\n\n        // Load current vector\n        vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(numbers.data() + i, vl);\n\n        // Compute absolute differences\n        for (size_t j = 0; j < i; j += vl) {\n            vfloat64m1_t vec_j = __riscv_vle64_v_f64m1(numbers.data() + j, vl);\n            vfloat64m1_t diff = __riscv_vfsub_vv_f64m1(vec1, vec2, vl);\n            vfloat64m1_t abs_diff = __riscv_vfabs_v_f64m1(diff, vl);\n\n            // Check if any difference is less than threshold\n            vbool64_t mask = __riscv_vmflt_vf_f64m1_b64(abs_diff, threshold, vl);\n            if (__riscv_vmfirst_m_b64(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t vec_threshold = __riscv_vfmv_v_f_f64m1(threshold, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t vec_current = __riscv_vle64_v_f64m1(&numbers[i], vlmax);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            size_t vl_inner = __riscv_vsetvl_e64m1(n - j);\n            vfloat64m1_t vec_compare = __riscv_vle64_v_f64m1(&numbers[j], vl_inner);\n            \n            vfloat64m1_t vec_diff = __riscv_vfsub_vv_f64m1(vec_current, vec_compare, vlmax);\n            vfloat64m1_t vec_abs_diff = __riscv_vfabs_v_f64m1(vec_diff, vlmax);\n            \n            vbool64_t mask = __riscv_vmflt_vv_b64_f64m1(vec_abs_diff, vec_threshold, vlmax);\n            if (__riscv_vmfirst_m_b64(mask, vlmax) != -1) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t base_vec, compare_vec;\n    vbool64_t result_mask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e64m1(n - i);\n        base_vec = __riscv_vle64_v_f64m1(&numbers[i], vlmax);\n\n        for (size_t j = i + 1; j < n; j += vl) {\n            size_t vlmax_inner = __riscv_vsetvl_e64m1(n - j);\n            compare_vec = __riscv_vle64_v_f64m1(&numbers[j], vlmax_inner);\n\n            // Compute absolute difference\n            vfloat64m1_t diff_vec = __riscv_vfsub_vv_f64m1_tu(base_vec, compare_vec, vlmax_inner);\n            diff_vec = __riscv_vfabs_v_f64m1(diff_vec, vlmax_inner);\n\n            // Check if any difference is less than threshold\n            result_mask = __riscv_vmflt_vf_f64m1_b64(diff_vec, threshold, vlmax_inner);\n            \n            if (__riscv_vmfirst_m_b64(result_mask, vlmax_inner) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    // Determine maximum vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Load first vector\n    vfloat64m1_t vec1 = __riscv_vle64_v_f64m1(numbers.data(), vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e64m1(n - i);\n\n        // Load current vector\n        vfloat64m1_t vec2 = __riscv_vle64_v_f64m1(numbers.data() + i, vl);\n\n        // Compute absolute differences\n        for (size_t j = 0; j < i; j += vl) {\n            vfloat64m1_t vec_j = __riscv_vle64_v_f64m1(numbers.data() + j, vl);\n            vfloat64m1_t diff = __riscv_vfsub_vv_f64m1(vec1, vec2, vl);\n            vfloat64m1_t abs_diff = __riscv_vfabs_v_f64m1(diff, vl);\n\n            // Check if any difference is less than threshold\n            vbool64_t mask = __riscv_vmflt_vf_f64m1_b64(abs_diff, threshold, vl);\n            if (__riscv_vmfirst_m_b64(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    // Initialize running balance\n    int running_balance = 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load initial vector\n    vint32m1_t v_ops = __riscv_vle32_v_i32m1(operations.data(), vl);\n    \n    // Accumulate running balance\n    for (size_t i = 0; i < n; i += vl) {\n        // Update running balance\n        running_balance += __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(v_ops, __riscv_vmv_s_x_i32m1(0, vl), vl));\n        \n        // Check if balance goes negative\n        if (running_balance < 0) return true;\n        \n        // Load next vector if needed\n        if (i + vl < n) {\n            v_ops = __riscv_vle32_v_i32m1(operations.data() + i + vl, __riscv_vsetvl_e32m1(n - i - vl));\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    // Initialize running balance\n    int running_balance = 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load initial vector\n    vint32m1_t v_ops = __riscv_vle32_v_i32m1(operations.data(), vl);\n    \n    // Accumulate running balance\n    for (size_t i = 0; i < n; i += vl) {\n        // Update running balance\n        running_balance += __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(v_ops, __riscv_vmv_s_x_i32m1(0, vl), vl));\n        \n        // Check if balance goes negative\n        if (running_balance < 0) return true;\n        \n        // Load next vector if needed\n        if (i + vl < n) {\n            vl = __riscv_vsetvl_e32m1(n - i - vl);\n            v_ops = __riscv_vle32_v_i32m1(operations.data() + i + vl, vl);\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    // Initial balance\n    int balance = 0;\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector of operations\n        vint32m1_t op_vec = __riscv_vle32_v_i32m1(&operations[i], vl);\n        \n        // Accumulate balance\n        balance += __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(op_vec, __riscv_vmv_s_x_i32m1(0, vl), vl));\n        \n        // Check if balance goes negative\n        if (balance < 0) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    // Initial balance is 0\n    int current_balance = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t balance_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load operations vector\n        vint32m1_t op_vec = __riscv_vle32_v_i32m1(&operations[i], vl);\n        \n        // Accumulate balance\n        balance_vec = __riscv_vadd_vv_i32m1(balance_vec, op_vec, vl);\n        \n        // Check if any balance goes negative\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(balance_vec, 0, vl);\n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    int balance = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t running_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec_ops = __riscv_vle32_v_i32m1(&operations[i], vlmax);\n        \n        running_sum = __riscv_vadd_vv_i32m1(running_sum, vec_ops, vlmax);\n        \n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(running_sum, 0, vlmax);\n        if (__riscv_vmfirst_m_b32(mask, vlmax) != -1) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Load input vector\n    vfloat64m1_t vec = __riscv_vle64_v_f64m1(numbers.data(), vl);\n\n    // Calculate mean\n    vfloat64m1_t sum_vec = __riscv_vfredusum_vs_f64m1_f64m1(vec, __riscv_vfmv_s_f_f64m1(0.0), vl);\n    double mean = __riscv_vfmv_f_s_f64m1_f64(sum_vec) / n;\n\n    // Subtract mean from each element and take absolute value\n    vfloat64m1_t mean_vec = __riscv_vfmv_s_f_f64m1(mean);\n    vfloat64m1_t diff_vec = __riscv_vfsub_vv_f64m1(vec, mean_vec, vl);\n    vfloat64m1_t abs_diff_vec = __riscv_vfabs_v_f64m1(diff_vec, vl);\n\n    // Reduce sum of absolute differences\n    vfloat64m1_t mad_vec = __riscv_vfredusum_vs_f64m1_f64m1(abs_diff_vec, __riscv_vfmv_s_f_f64m1(0.0), vl);\n    double mad = __riscv_vfmv_f_s_f64m1_f64(mad_vec) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double mean = 0.0;\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_sum = __riscv_vfmv_s_f_f64m1(0.0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_data = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        v_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_sum, v_data, vl);\n    }\n    mean = __riscv_vfmv_f_s_f64m1_f64(v_sum) / n;\n\n    // Calculate mean absolute deviation\n    vfloat64m1_t v_mad_sum = __riscv_vfmv_s_f_f64m1(0.0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_data = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = __riscv_vfsubvf_v_f64m1(v_data, mean, vl);\n        vfloat64m1_t v_abs_diff = __riscv_vfabsv_v_f64m1(v_diff, vl);\n        v_mad_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_mad_sum, v_abs_diff, vl);\n    }\n    \n    return __riscv_vfmv_f_s_f64m1_f64(v_mad_sum) / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Load input vector\n    vfloat64m1_t vec = __riscv_vle64_v_f64m1(numbers.data(), vl);\n\n    // Calculate mean\n    vfloat64m1_t sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(vec, __riscv_vfmv_s_f_f64m1(0.0, vl), vl);\n    double mean = __riscv_vfmv_f_s_f64m1_f64(sum_vec) / n;\n\n    // Subtract mean from each element and take absolute value\n    vfloat64m1_t mean_vec = __riscv_vfmv_v_f_f64m1(mean, vl);\n    vfloat64m1_t diff_vec = __riscv_vfsub_vv_f64m1(vec, mean_vec, vl);\n    vfloat64m1_t abs_diff_vec = __riscv_vfabs_v_f64m1(diff_vec, vl);\n\n    // Calculate sum of absolute differences\n    vfloat64m1_t mad_sum_vec = __riscv_vfredsum_vs_f64m1_f64m1(abs_diff_vec, __riscv_vfmv_s_f_f64m1(0.0, vl), vl);\n    \n    // Return mean absolute deviation\n    return __riscv_vfmv_f_s_f64m1_f64(mad_sum_vec) / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double mean = 0.0;\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vfloat64m1_t v_sum = __riscv_vfmv_s_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_data = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        v_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_sum, v_data, vl);\n    }\n    mean = __riscv_vfmv_f_s_f64m1_f64(v_sum) / n;\n\n    // Calculate MAD\n    vfloat64m1_t v_mad_sum = __riscv_vfmv_s_f_f64m1(0.0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vfloat64m1_t v_data = __riscv_vle64_v_f64m1(&numbers[i], vl);\n        vfloat64m1_t v_diff = __riscv_vfsubvf_v_f64m1(v_data, mean, vl);\n        vfloat64m1_t v_abs_diff = __riscv_vfsgnjx_v_f64m1(v_diff, v_diff, vl);\n        v_mad_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_mad_sum, v_abs_diff, vl);\n    }\n    \n    return __riscv_vfmv_f_s_f64m1_f64(v_mad_sum) / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Load input vector\n    vfloat64m1_t v_input = __riscv_vle64_v_f64m1(numbers.data(), vl);\n\n    // Calculate mean\n    vfloat64m1_t v_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_input, __riscv_vfmv_s_f_f64m1(0.0, vl), vl);\n    double mean = __riscv_vfmv_f_s_f64m1_f64(v_sum) / n;\n\n    // Subtract mean from each element and take absolute value\n    vfloat64m1_t v_mean = __riscv_vfmv_v_f_f64m1(mean, vl);\n    vfloat64m1_t v_diff = __riscv_vfsub_vv_f64m1(v_input, v_mean, vl);\n    vfloat64m1_t v_abs_diff = __riscv_vfabs_v_f64m1(v_diff, vl);\n\n    // Calculate sum of absolute differences\n    vfloat64m1_t v_abs_sum = __riscv_vfredsum_vs_f64m1_f64m1(v_abs_diff, __riscv_vfmv_s_f_f64m1(0.0, vl), vl);\n    \n    // Return mean absolute deviation\n    return __riscv_vfmv_f_s_f64m1_f64(v_abs_sum) / n;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t original_size = numbers.size();\n    size_t new_size = original_size * 2 - 1;\n    std::vector<int> result(new_size);\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(original_size);\n\n    // Load original vector\n    vint32m1_t v_numbers = __riscv_vle32_v_i32m1(numbers.data(), vl);\n\n    // Scatter delimiters\n    for (size_t i = 0; i < original_size; i++) {\n        result[2*i] = numbers[i];\n        if (2*i + 1 < new_size) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t original_size = numbers.size();\n    size_t new_size = original_size * 2 - 1;\n    std::vector<int> result(new_size);\n\n    size_t vl = __riscv_vsetvl_e32m1(original_size);\n    vint32m1_t v_delimeter = __riscv_vmv_v_x_i32m1(delimeter, vl);\n\n    for (size_t i = 0; i < original_size; i++) {\n        result[2*i] = numbers[i];\n        if (2*i + 1 < new_size) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t original_size = numbers.size();\n    size_t new_size = original_size * 2 - 1;\n    std::vector<int> result(new_size);\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(original_size);\n\n    // Load original vector\n    vint32m1_t v_numbers = __riscv_vle32_v_i32m1(numbers.data(), vl);\n\n    // Scatter store with delimiter\n    for (size_t i = 0; i < original_size; i++) {\n        result[2*i] = numbers[i];\n        if (2*i + 1 < new_size) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t original_size = numbers.size();\n    size_t result_size = original_size * 2 - 1;\n    std::vector<int> result(result_size);\n\n    size_t vl = __riscv_vsetvl_e32m1(original_size);\n    vint32m1_t v_delimeter = __riscv_vmv_v_x_i32m1(delimeter, vl);\n\n    for (size_t i = 0; i < original_size; i++) {\n        result[2*i] = numbers[i];\n        if (2*i + 1 < result_size) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t original_size = numbers.size();\n    size_t new_size = original_size * 2 - 1;\n    std::vector<int> result(new_size);\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(original_size);\n\n    // Load original vector\n    vint32m1_t v_numbers = __riscv_vle32_v_i32m1(numbers.data(), vl);\n\n    // Scatter delimiters and original elements\n    for (size_t i = 0; i < original_size; i++) {\n        result[2*i] = __riscv_vmv_x_s(__riscv_vslidedown_vx_i32m1(v_numbers, i, vl));\n        if (2*i + 1 < new_size) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t v_numbers = __riscv_vle16_v_i16m1(numbers.data(), vl);\n    \n    // Sum reduction\n    vint32m2_t v_sum = __riscv_vwcvt_x_x_v_i32m2(v_numbers, vl);\n    vint32m2_t v_sum_red = __riscv_vredsum_vs_i32m2_i32m1(v_sum, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum_red);\n\n    // Product reduction\n    vint16m1_t v_product = __riscv_vmv_v_x_i16m1(1, vl);\n    vint16m1_t v_prod_red = __riscv_vredmul_vs_i16m1_i16m1(v_numbers, v_product, vl);\n    product = __riscv_vmv_x_s_i16m1_i16(v_prod_red);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t v_input = __riscv_vle16_v_i16m1(numbers.data(), vl);\n    \n    // Compute sum\n    vint32m2_t v_sum = __riscv_vwcvt_x_x_v_i32m2(v_input, vl);\n    vint32m2_t v_sum_red = __riscv_vredsum_vs_i32m2_i32m1(v_sum, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum_red);\n\n    // Compute product\n    vint16m1_t v_prod = __riscv_vmv_v_x_i16m1(1, vl);\n    vint16m1_t v_prod_red = __riscv_vredmul_vs_i16m1_i16m1(v_input, v_prod, vl);\n    product = __riscv_vmv_x_s_i16m1_i16(v_prod_red);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t v_numbers = __riscv_vle16_v_i16m1(numbers.data(), vl);\n    \n    // Compute sum\n    vint32m2_t v_sum = __riscv_vwcvt_x_x_v_i32m2(v_numbers, vl);\n    vint32m2_t v_sum_red = __riscv_vredsum_vs_i32m2_i32m1(v_sum, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum_red);\n\n    // Compute product\n    vint32m2_t v_product = __riscv_vwmul_vv_i32m2(v_numbers, v_numbers, vl);\n    vint32m2_t v_prod_red = __riscv_vredmul_vs_i32m2_i32m1(v_product, __riscv_vmv_v_x_i32m1(1, vl), vl);\n    product = __riscv_vmv_x_s_i32m1_i32(v_prod_red);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    size_t vl = __riscv_vsetvl_e16m1(n);\n\n    vint16m1_t v_input = __riscv_vle16_v_i16m1(numbers.data(), vl);\n    \n    // Compute sum\n    vint64m1_t v_sum = __riscv_vwredsum_vs_i16m1_i64m1(v_input, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    int64_t sum = __riscv_vmv_x_s_i64m1_i64(v_sum);\n\n    // Compute product\n    vint64m1_t v_product = __riscv_vmv_v_x_i64m1(1, vl);\n    for (size_t i = 0; i < n; i += vl) {\n        vint16m1_t v_chunk = __riscv_vle16_v_i16m1(numbers.data() + i, vl);\n        v_product = __riscv_vwmul_vv_i64m1(v_product, __riscv_vwadd_vx_i32m1(v_chunk, 0, vl), vl);\n    }\n    int64_t product = __riscv_vmv_x_s_i64m1_i64(v_product);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    size_t n = numbers.size();\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    vint16m1_t v_numbers = __riscv_vle16_v_i16m1(numbers.data(), vl);\n    \n    // Compute sum\n    vint32m2_t v_sum = __riscv_vwcvt_x_x_v_i32m2(v_numbers, vl);\n    vint32m2_t v_sum_red = __riscv_vredsum_vs_i32m2_i32m1(v_sum, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum_red);\n\n    // Compute product\n    vint32m2_t v_product = __riscv_vwmul_vv_i32m2(v_numbers, v_numbers, vl);\n    vint32m2_t v_prod_red = __riscv_vredmul_vs_i32m2_i32m1(v_product, __riscv_vmv_v_x_i32m1(1, vl), vl);\n    product = __riscv_vmv_x_s_i32m1_i32(v_prod_red);\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return {};\n\n    std::vector<int> result(numbers.size());\n    size_t n = numbers.size();\n    \n    // Initial setup\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t current_max = __riscv_vle32_v_i32m1(numbers.data(), vl);\n    __riscv_vse32_v_i32m1(result.data(), current_max, vl);\n\n    // Process remaining elements\n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t new_elements = __riscv_vle32_v_i32m1(numbers.data() + i, vl);\n        \n        // Compute rolling max\n        current_max = __riscv_vmax_vv_i32m1(current_max, new_elements, vl);\n        __riscv_vse32_v_i32m1(result.data() + i, current_max, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return {};\n\n    std::vector<int> result(numbers.size());\n    size_t n = numbers.size();\n    \n    // Initial vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load first element\n    vint32m1_t current_max = __riscv_vle32_v_i32m1(numbers.data(), vl);\n    __riscv_vse32_v_i32m1(result.data(), current_max, vl);\n    \n    // Process remaining elements in vector chunks\n    for (size_t i = vl; i < n; i += vl) {\n        // Remaining elements in this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load next chunk of data\n        vint32m1_t new_data = __riscv_vle32_v_i32m1(numbers.data() + i, vl);\n        \n        // Compute rolling max\n        current_max = __riscv_vmax_vv_i32m1(current_max, new_data, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(result.data() + i, current_max, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return {};\n\n    std::vector<int> result(numbers.size());\n    size_t n = numbers.size();\n    \n    // Initial setup\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t current_max = __riscv_vle32_v_i32m1(numbers.data(), vl);\n    __riscv_vse32_v_i32m1(result.data(), current_max, vl);\n\n    // Process remaining elements\n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t next_vec = __riscv_vle32_v_i32m1(numbers.data() + i, vl);\n        \n        // Compute rolling max\n        current_max = __riscv_vmax_vv_i32m1(current_max, next_vec, vl);\n        __riscv_vse32_v_i32m1(result.data() + i, current_max, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return {};\n\n    std::vector<int> result(numbers.size());\n    size_t n = numbers.size();\n    \n    // Initial vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load first element\n    vint32m1_t current_max = __riscv_vle32_v_i32m1(numbers.data(), vl);\n    __riscv_vse32_v_i32m1(result.data(), current_max, vl);\n    \n    // Process remaining elements\n    for (size_t i = vl; i < n; i += vl) {\n        // Remaining vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load next chunk of data\n        vint32m1_t new_vec = __riscv_vle32_v_i32m1(numbers.data() + i, vl);\n        \n        // Compute rolling max\n        current_max = __riscv_vmax_vv_i32m1(current_max, new_vec, vl);\n        \n        // Store result\n        __riscv_vse32_v_i32m1(result.data() + i, current_max, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return {};\n\n    std::vector<int> result(numbers.size());\n    size_t n = numbers.size();\n    \n    // Initial setup\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t current_max = __riscv_vle32_v_i32m1(numbers.data(), vl);\n    __riscv_vse32_v_i32m1(result.data(), current_max, vl);\n\n    // Process remaining elements\n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t next_chunk = __riscv_vle32_v_i32m1(numbers.data() + i, vl);\n        \n        // Compute rolling max\n        current_max = __riscv_vmax_vv_i32m1(current_max, next_chunk, vl);\n        __riscv_vse32_v_i32m1(result.data() + i, current_max, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(len, '0');\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(len - i);\n        \n        vuint8m1_t va = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.data() + i), vlmax);\n        vuint8m1_t vb = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.data() + i), vlmax);\n        \n        vuint8m1_t vxor = __riscv_vxor_vv_u8m1(va, vb, vlmax);\n        \n        __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(&result[i]), vxor, vlmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(len, '0');\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(len - i);\n        \n        vuint8m1_t va = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.data() + i), vlmax);\n        vuint8m1_t vb = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.data() + i), vlmax);\n        \n        vuint8m1_t vxor = __riscv_vxor_vv_u8m1(va, vb, vlmax);\n        \n        __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(&result[i]), vxor, vlmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    std::string result(len, '0');\n    \n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    for (size_t i = 0; i < len; i += vl) {\n        // Calculate remaining elements\n        size_t vlmax = __riscv_vsetvl_e8m1(len - i);\n        \n        // Load vector segments\n        vuint8_t va = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.data() + i), vlmax);\n        vuint8_t vb = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.data() + i), vlmax);\n        \n        // Perform XOR\n        vuint8_t vxor = __riscv_vxor_vv_u8m1(va, vb, vlmax);\n        \n        // Store result\n        __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(&result[i]), vxor, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure input strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    // Get vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Process vector chunks\n    for (size_t i = 0; i < len; i += vl) {\n        // Calculate remaining elements\n        size_t vlmax = (len - i < vl) ? (len - i) : vl;\n\n        // Load vector chunks\n        vint8m1_t va = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(a.data() + i), vlmax);\n        vint8m1_t vb = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(b.data() + i), vlmax);\n\n        // Perform XOR\n        vint8m1_t vxor = __riscv_vxor_vv_i8m1(va, vb, vlmax);\n\n        // Store results\n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[i]), vxor, vlmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    if (len != b.length()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    std::string result(len, '0');\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < len; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(len - i);\n        \n        vuint8m1_t va = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(a.data() + i), vlmax);\n        vuint8m1_t vb = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(b.data() + i), vlmax);\n\n        vuint8m1_t vxor = __riscv_vxor_vv_u8m1(va, vb, vlmax);\n\n        __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(&result[i]), vxor, vlmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Create vector to store string lengths\n    vint64m1_t length_vec = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    // Compute lengths in parallel\n    for (size_t i = 0; i < n; i += vl) {\n        size_t remaining = n - i;\n        vl = __riscv_vsetvl_e64m1(remaining);\n\n        // Load string lengths\n        vint64m1_t curr_lengths = __riscv_vle64_v_i64m1(\n            reinterpret_cast<const int64_t*>(strings.data() + i), \n            vl\n        );\n        \n        // Compute string lengths\n        vint64m1_t lengths = __riscv_vnsrl_wx_i64m1(\n            __riscv_vreinterpret_v_i64m1_u64m1(curr_lengths), \n            [](const std::string& s) { return s.length(); }, \n            vl\n        );\n\n        // Update max length vector\n        length_vec = __riscv_vmax_vv_i64m1_m(\n            __riscv_vmseq_vv_b64_m(length_vec, length_vec, length_vec, vl),\n            length_vec, \n            lengths, \n            vl\n        );\n    }\n\n    // Find index of max length\n    for (size_t i = 0; i < n; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Create vector to store string lengths\n    vint64m1_t lengths_vec = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    // Compute lengths in parallel\n    for (size_t i = 0; i < n; i += vl) {\n        size_t remaining = std::min(vl, n - i);\n        \n        // Load string lengths\n        vint64m1_t current_lengths = __riscv_vle64_v_i64m1(\n            reinterpret_cast<const int64_t*>(strings.data() + i), \n            remaining\n        );\n        \n        // Update max length vector\n        lengths_vec = __riscv_vmax_vv_i64m1(lengths_vec, current_lengths, remaining);\n    }\n\n    // Find max length\n    for (size_t i = 0; i < vl; ++i) {\n        int64_t length = __riscv_vmv_x_s_i64m1_i64(lengths_vec);\n        if (length > max_length) {\n            max_length = length;\n            max_index = i;\n        }\n        lengths_vec = __riscv_vslide1down_vx_i64m1(lengths_vec, 0, vl);\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Create vector to store string lengths\n    vint64m1_t length_vec = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    // Compute lengths in parallel\n    for (size_t i = 0; i < n; i += vl) {\n        size_t remaining = n - i;\n        size_t current_vl = __riscv_vsetvl_e64m1(remaining);\n\n        // Load string lengths\n        vint64m1_t current_lengths = __riscv_vle64_v_i64m1(\n            reinterpret_cast<const int64_t*>(strings.data() + i), \n            current_vl\n        );\n\n        // Compute string lengths\n        vint64m1_t lengths = __riscv_vnsrl_wx_i64m1(\n            __riscv_vreinterpret_v_i64m1_u64m1(current_lengths), \n            current_vl\n        );\n\n        // Find max length and index\n        vint64m1_t max_vec = __riscv_vmaxu_vv_i64m1(lengths, length_vec, current_vl);\n        length_vec = max_vec;\n\n        // Update max index if needed\n        vbool64_t mask = __riscv_vmseq_vv_b64_i64m1(max_vec, lengths, current_vl);\n        max_index = __riscv_vfirst_m_b64(mask, current_vl);\n        if (max_index != -1) {\n            max_index += i;\n            max_length = __riscv_vmv_x_s_i64m1_i64(max_vec);\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    \n    // Create vector to store string lengths\n    vint64m1_t length_vec = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    // Compute lengths in parallel\n    for (size_t i = 0; i < n; i += vl) {\n        size_t remaining = n - i;\n        vl = __riscv_vsetvl_e64m1(remaining);\n        \n        // Load string lengths\n        vint64m1_t current_lengths = __riscv_vle64_v_i64m1(\n            reinterpret_cast<const int64_t*>(strings.data() + i), \n            vl\n        );\n        \n        // Compute string lengths\n        vint64m1_t lengths = __riscv_vreinterpret_v_i64m1_u64m1(\n            __riscv_vreinterpret_v_u64m1_i64m1(\n                __riscv_vmv_v_x_u64m1(0, vl)\n            )\n        );\n        \n        for (auto& str : strings) {\n            lengths = __riscv_vadd_vx_i64m1(lengths, str.length(), vl);\n        }\n        \n        // Find max length\n        vint64m1_t max_lengths = __riscv_vredmax_vs_i64m1_i64m1(lengths, length_vec, vl);\n        \n        // Update max length and index\n        int64_t current_max = __riscv_vmv_x_s_i64m1_i64(max_lengths);\n        if (current_max > max_length) {\n            max_length = current_max;\n            max_index = i;\n        }\n    }\n    \n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Create vector to store string lengths\n    vint64m1_t length_vec = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    // Compute lengths in parallel\n    for (size_t i = 0; i < n; i += vl) {\n        size_t remaining = n - i;\n        vl = __riscv_vsetvl_e64m1(remaining);\n\n        // Load string lengths\n        vint64m1_t current_lengths = __riscv_vle64_v_i64m1(\n            reinterpret_cast<const int64_t*>(strings.data() + i), \n            vl\n        );\n        \n        // Compute string lengths\n        vint64m1_t lengths = __riscv_vnsrl_wx_i64m1(\n            __riscv_vreinterpret_v_i64m1_u64m1(current_lengths), \n            0, \n            vl\n        );\n\n        // Update max length vector\n        length_vec = __riscv_vmax_vv_i64m1_m(\n            __riscv_vmseq_vx_b64m1(length_vec, 0, vl),\n            length_vec, \n            lengths, \n            vl\n        );\n    }\n\n    // Find max length and index\n    for (size_t i = 0; i < n; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t va = __riscv_vmv_s_x_i64m1(a, vl);\n    vint64m1_t vb = __riscv_vmv_s_x_i64m1(b, vl);\n\n    while (__riscv_vmsgtu_vv_b64_b(vb, va, vl)) {\n        va = __riscv_vrem_vv_i64m1(va, vb, vl);\n        vint64m1_t vtmp = va;\n        va = vb;\n        vb = vtmp;\n    }\n\n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t va = __riscv_vmv_s_x_i64m1(a, vl);\n    vint64m1_t vb = __riscv_vmv_s_x_i64m1(b, vl);\n\n    while (__riscv_vmsgtu_vv_b64_b(vb, va, vl)) {\n        va = __riscv_vrem_vv_i64m1(va, vb, vl);\n        vint64m1_t vtmp = va;\n        va = vb;\n        vb = vtmp;\n    }\n\n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t va = __riscv_vmv_s_x_i64m1(a, vl);\n    vint64m1_t vb = __riscv_vmv_s_x_i64m1(b, vl);\n\n    while (__riscv_vmsgtu_vv_b64_b(vb, va, vl)) {\n        va = __riscv_vrem_vv_i64m1(va, vb, vl);\n        vint64m1_t vtmp = va;\n        va = vb;\n        vb = vtmp;\n    }\n\n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t va = __riscv_vmv_s_x_i64m1(a, vl);\n    vint64m1_t vb = __riscv_vmv_s_x_i64m1(b, vl);\n\n    while (__riscv_vmsgtu_vv_b64_b(vb, va, vl)) {\n        va = __riscv_vrem_vv_i64m1(va, vb, vl);\n        \n        vint64m1_t vtmp = va;\n        va = vb;\n        vb = vtmp;\n    }\n\n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t va = __riscv_vmv_s_x_i64m1(a, vl);\n    vint64m1_t vb = __riscv_vmv_s_x_i64m1(b, vl);\n\n    while (__riscv_vmsgtu_vv_b64_b(vb, va, vl)) {\n        va = __riscv_vrem_vv_i64m1(va, vb, vl);\n        __riscv_vswap_vv_i64m1(va, vb, vl);\n    }\n\n    return __riscv_vmv_x_s_i64m1_i64(vb);\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load initial vector\n    vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(numbers.data(), vl);\n    \n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Slide window and compute differences\n        for (size_t j = i + 1; j < n; j++) {\n            vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(numbers.data() + j, vl);\n            \n            // Compute absolute difference\n            vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n            diff = __riscv_vfabs_v_f32m1(diff, vl);\n            \n            // Find minimum difference\n            float current_min_diff = __riscv_vfmv_f_s_f32m1_f32(__riscv_vfredmin_vs_f32m1_f32m1(diff, __riscv_vfmv_s_f_f32m1(0.0f), vl));\n            \n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n    \n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load initial vector\n    vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(numbers.data(), vl);\n    \n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load next vector\n        vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(numbers.data() + i + 1, vl);\n        \n        // Compute absolute differences\n        vfloat32m1_t diffs = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n        diffs = __riscv_vfabs_v_f32m1(diffs, vl);\n        \n        // Find minimum difference\n        float current_min_diff = __riscv_vfmv_f_s_f32m1_f32(__riscv_vfredmin_vs_f32m1_f32m1(diffs, __riscv_vfmv_s_f_f32m1(0.0f), vl));\n        \n        if (current_min_diff < min_diff) {\n            min_diff = current_min_diff;\n            closest_a = numbers[i];\n            closest_b = numbers[i + __riscv_vfirst_m_b32(diffs, vl) + 1];\n        }\n        \n        // Shift vectors\n        vec1 = vec2;\n    }\n    \n    return {std::min(closest_a, closest_b), std::max(closest_a, closest_b)};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0];\n    float closest_b = numbers[1];\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load initial vector\n    vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(numbers.data(), vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Slide window of vectors\n        vfloat32m1_t vec2 = __riscv_vslide1down_vf_f32m1(vec1, 0, vl);\n        \n        // Compute absolute differences\n        vfloat32m1_t diffs = __riscv_vfsub_vv_f32m1(vec2, vec1, vl);\n        diffs = __riscv_vfabs_v_f32m1(diffs, vl);\n        \n        // Find minimum difference\n        float curr_min_diff = __riscv_vfmv_f_s_f32m1_f32(__riscv_vfredmin_vs_f32m1_f32m1(diffs, __riscv_vfmv_s_f_f32m1(0.0f), vl));\n        \n        // Update closest pair if needed\n        if (curr_min_diff < min_diff) {\n            size_t min_idx = 0;\n            for (size_t j = 0; j < vl; ++j) {\n                if (__riscv_vfmv_f_s_f32m1_f32(__riscv_vslidedown_vx_f32m1(diffs, j, vl)) == curr_min_diff) {\n                    min_idx = j;\n                    break;\n                }\n            }\n            \n            min_diff = curr_min_diff;\n            closest_a = numbers[i + min_idx];\n            closest_b = numbers[i + min_idx + 1];\n        }\n        \n        // Prepare next iteration\n        vec1 = __riscv_vle32_v_f32m1(numbers.data() + i + vl, vl);\n    }\n    \n    return {std::min(closest_a, closest_b), std::max(closest_a, closest_b)};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load initial vector\n    vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(numbers.data(), vl);\n\n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Shift vector by 1 to compare adjacent elements\n        vfloat32m1_t vec2 = __riscv_vslide1down_vf_f32m1(vec1, 0, vl);\n\n        // Compute absolute difference between adjacent elements\n        vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec2, vec1, vl);\n        diff = __riscv_vfabs_v_f32m1(diff, vl);\n\n        // Find minimum difference\n        float local_min_diff = __riscv_vfmv_f_s_f32m1_f32(__riscv_vfmin_vf_f32m1(diff, vl));\n\n        if (local_min_diff < min_diff) {\n            // Find indices of closest elements\n            for (size_t j = 0; j < vl; j++) {\n                float curr_diff = std::abs(numbers[i + j + 1] - numbers[i + j]);\n                if (curr_diff == local_min_diff) {\n                    closest_a = std::min(numbers[i + j], numbers[i + j + 1]);\n                    closest_b = std::max(numbers[i + j], numbers[i + j + 1]);\n                    min_diff = local_min_diff;\n                    break;\n                }\n            }\n        }\n\n        // Slide to next vector\n        vec1 = __riscv_vslide1down_vf_f32m1(vec1, 0, vl);\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return {};\n\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load initial vector\n    vfloat32m1_t vec1 = __riscv_vle32_v_f32m1(numbers.data(), vl);\n    \n    for (size_t i = 0; i < n - 1; i += vl) {\n        // Slide window and compute differences\n        for (size_t j = i + 1; j < n; j++) {\n            vfloat32m1_t vec2 = __riscv_vle32_v_f32m1(numbers.data() + j, vl);\n            \n            // Compute absolute difference\n            vfloat32m1_t diff = __riscv_vfsub_vv_f32m1(vec1, vec2, vl);\n            diff = __riscv_vfabs_v_f32m1(diff, vl);\n            \n            // Find minimum difference\n            float curr_min_diff = __riscv_vfmv_f_s_f32m1_f32(__riscv_vfredmin_vs_f32m1_f32m1(diff, __riscv_vfmv_s_f_f32m1(0.0f), vl));\n            \n            if (curr_min_diff < min_diff) {\n                min_diff = curr_min_diff;\n                closest_a = numbers[i];\n                closest_b = numbers[j];\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load entire vector\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(numbers.data(), vl);\n\n    // Find min and max\n    vfloat32m1_t min_vec = __riscv_vfredmin_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(INFINITY, vl), vl);\n    vfloat32m1_t max_vec = __riscv_vfredmax_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(-INFINITY, vl), vl);\n\n    float min_val = __riscv_vfmv_f_s_f32m1_f32(min_vec);\n    float max_val = __riscv_vfmv_f_s_f32m1_f32(max_vec);\n\n    // Compute scaling factor\n    float scale = max_val > min_val ? 1.0f / (max_val - min_val) : 1.0f;\n\n    // Subtract min and scale\n    vfloat32m1_t scaled_vec = __riscv_vfmul_vf_f32m1(\n        __riscv_vfsub_vf_f32m1(vec, min_val, vl), \n        scale, \n        vl\n    );\n\n    // Store result\n    std::vector<float> result(n);\n    __riscv_vse32_v_f32m1(result.data(), scaled_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load entire vector\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(numbers.data(), vl);\n\n    // Find min and max\n    vfloat32m1_t min_vec = __riscv_vfredmin_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(INFINITY, vl), vl);\n    vfloat32m1_t max_vec = __riscv_vfredmax_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(-INFINITY, vl), vl);\n\n    float min_val = __riscv_vfmv_f_s_f32m1_f32(min_vec);\n    float max_val = __riscv_vfmv_f_s_f32m1_f32(max_vec);\n\n    // Compute scale factors\n    float scale = max_val > min_val ? 1.0f / (max_val - min_val) : 1.0f;\n    float offset = -min_val;\n\n    // Rescale vector\n    vfloat32m1_t offset_vec = __riscv_vfmv_s_f_f32m1(offset, vl);\n    vfloat32m1_t scale_vec = __riscv_vfmv_s_f_f32m1(scale, vl);\n\n    vfloat32m1_t result_vec = __riscv_vfmacc_vf_f32m1(\n        __riscv_vfmul_vf_f32m1(\n            __riscv_vfadd_vv_f32m1(vec, offset_vec, vl),\n            scale, vl\n        ), 0.0f, __riscv_vfmv_s_f_f32m1(1.0f, vl), vl\n    );\n\n    // Store result\n    std::vector<float> result(n);\n    __riscv_vse32_v_f32m1(result.data(), result_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load entire vector\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(numbers.data(), vl);\n\n    // Find min and max\n    vfloat32m1_t min_vec = __riscv_vfredmin_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(INFINITY, vl), vl);\n    vfloat32m1_t max_vec = __riscv_vfredmax_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(-INFINITY, vl), vl);\n\n    float min_val = __riscv_vfmv_f_s_f32m1_f32(min_vec);\n    float max_val = __riscv_vfmv_f_s_f32m1_f32(max_vec);\n\n    // Compute scale factors\n    float scale = max_val > min_val ? 1.0f / (max_val - min_val) : 1.0f;\n    vfloat32m1_t scale_vec = __riscv_vfmv_s_f_f32m1(scale, vl);\n    vfloat32m1_t min_vec_broadcast = __riscv_vfmv_s_f_f32m1(min_val, vl);\n\n    // Rescale vector\n    vfloat32m1_t result_vec = __riscv_vfmul_vv_f32m1(\n        __riscv_vfsub_vv_f32m1(vec, min_vec_broadcast, vl),\n        scale_vec, \n        vl\n    );\n\n    // Store result\n    std::vector<float> result(n);\n    __riscv_vse32_v_f32m1(result.data(), result_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load entire vector\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(numbers.data(), vl);\n\n    // Find min and max\n    vfloat32m1_t min_vec = __riscv_vfredmin_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(INFINITY, vl), vl);\n    vfloat32m1_t max_vec = __riscv_vfredmax_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(-INFINITY, vl), vl);\n\n    float min_val = __riscv_vfmv_f_s_f32m1_f32(min_vec);\n    float max_val = __riscv_vfmv_f_s_f32m1_f32(max_vec);\n\n    // Compute scaling factors\n    float scale = max_val > min_val ? 1.0f / (max_val - min_val) : 0.0f;\n    vfloat32m1_t scale_vec = __riscv_vfmv_s_f_f32m1(scale, vl);\n    vfloat32m1_t min_vec_broadcast = __riscv_vfmv_s_f_f32m1(min_val, vl);\n\n    // Rescale vector\n    vfloat32m1_t result_vec = __riscv_vfsub_vv_f32m1(vec, min_vec_broadcast, vl);\n    result_vec = __riscv_vfmul_vv_f32m1(result_vec, scale_vec, vl);\n\n    // Store result\n    std::vector<float> result(n);\n    __riscv_vse32_v_f32m1(result.data(), result_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load entire vector\n    vfloat32m1_t vec = __riscv_vle32_v_f32m1(numbers.data(), vl);\n\n    // Find min and max\n    vfloat32m1_t min_vec = __riscv_vfredmin_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(INFINITY, vl), vl);\n    vfloat32m1_t max_vec = __riscv_vfredmax_vs_f32m1_f32m1(vec, __riscv_vfmv_s_f_f32m1(-INFINITY, vl), vl);\n\n    float min_val = __riscv_vfmv_f_s_f32m1_f32(min_vec);\n    float max_val = __riscv_vfmv_f_s_f32m1_f32(max_vec);\n\n    // Compute scaling factor\n    float scale = max_val > min_val ? 1.0f / (max_val - min_val) : 0.0f;\n\n    // Subtract min and scale\n    vfloat32m1_t scaled_vec = __riscv_vfmul_vf_f32m1(\n        __riscv_vfsub_vf_f32m1(vec, min_val, vl), \n        scale, \n        vl\n    );\n\n    // Store result\n    std::vector<float> result(n);\n    __riscv_vse32_v_f32m1(result.data(), scaled_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 1, vl);\n\n    vbool64_t mask = __riscv_vmseq_vx_i64m1_b64(divisors, 0, vl);\n    mask = __riscv_vmnot_m_b64(mask, vl);\n\n    vint64m1_t candidates = __riscv_vcompress_vm_i64m1_i64m1(divisors, mask, vl);\n    vbool64_t div_mask = __riscv_vmseq_vx_i64m1_b64(__riscv_vrem_vx_i64m1(n, candidates, vl), 0, vl);\n\n    vint64m1_t valid_divisors = __riscv_vcompress_vm_i64m1_i64m1(candidates, div_mask, vl);\n    \n    if (__riscv_vcpop_m_b64(div_mask, vl) > 0) {\n        return __riscv_vmv_x_s_i64m1_i64(valid_divisors);\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 1, vl);\n\n    vbool64_t mask = __riscv_vmseq_vx_i64m1_b64(divisors, 0, vl);\n    mask = __riscv_vmnot_m_b64(mask, vl);\n\n    vint64m1_t candidates = __riscv_vcompress_vm_i64m1_i64m1(divisors, mask, vl);\n    vbool64_t div_mask = __riscv_vmseq_vx_i64m1_b64(__riscv_vrem_vx_i64m1(n, candidates, vl), 0, vl);\n\n    vint64m1_t divisors_of_n = __riscv_vcompress_vm_i64m1_i64m1(candidates, div_mask, vl);\n    \n    size_t num_divisors = __riscv_vcpop_m_b64(div_mask, vl);\n    if (num_divisors == 0) return 1;\n\n    vint64m1_t max_divisor = __riscv_vredmax_vs_i64m1_i64m1(divisors_of_n, __riscv_vmv_s_x_i64m1(0, vl), vl);\n    return __riscv_vmv_x_s_i64m1_i64(max_divisor);\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 1, vl);\n\n    vbool64_t mask = __riscv_vmseq_vx_i64m1_b64(divisors, 0, vl);\n    mask = __riscv_vmnot_m_b64(mask, vl);\n\n    vint64m1_t candidates = __riscv_vcompress_vm_i64m1_i64m1(divisors, mask, vl);\n    vbool64_t div_mask = __riscv_vmseq_vx_i64m1_b64(__riscv_vrem_vx_i64m1(n, candidates, vl), 0, vl);\n\n    vint64m1_t divisors_of_n = __riscv_vcompress_vm_i64m1_i64m1(candidates, div_mask, vl);\n    \n    size_t num_divisors = __riscv_vcpop_m_b64(div_mask, vl);\n    if (num_divisors == 0) return 1;\n\n    vint64m1_t max_divisor = __riscv_vredmax_vs_i64m1_i64m1(divisors_of_n, __riscv_vmv_s_x_i64m1(0, vl), vl);\n    return __riscv_vmv_x_s_i64m1_i64(max_divisor);\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    \n    // Create vector with indices from 1 to sqrt(n)\n    vint64m1_t indices = __riscv_vid_v_i64m1(vl);\n    indices = __riscv_vadd_vx_i64m1(indices, 1, vl);\n    \n    // Mask for valid indices (less than or equal to sqrt(n))\n    uint64_t sqrt_n = sqrt(n);\n    vbool64_t mask = __riscv_vmslt_vx_i64m1_b64(indices, sqrt_n + 1, vl);\n    \n    // Compute divisibility mask\n    vbool64_t div_mask = __riscv_vmseq_vx_i64m1_b64(\n        __riscv_vrem_vx_i64m1(n, indices, vl), \n        0, \n        vl\n    );\n    \n    // Combine masks\n    vbool64_t combined_mask = __riscv_vmand_mm_b64(mask, div_mask, vl);\n    \n    // Find max divisor\n    vint64m1_t divisors = __riscv_vcompress_v_i64m1_m(indices, combined_mask, vl);\n    \n    return __riscv_vmv_x_s_i64m1_i64(\n        __riscv_vredmax_vs_i64m1_i64(divisors, __riscv_vmv_s_x_i64m1(0), vl)\n    );\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 1, vl);\n\n    vbool64_t mask = __riscv_vmseq_vx_i64m1_b64(divisors, 0, vl);\n    mask = __riscv_vmnot_m_b64(mask, vl);\n\n    vbool64_t divisible_mask = __riscv_vmseq_vx_i64m1_b64(__riscv_vrem_vx_i64m1(n, divisors, vl), 0, vl);\n    mask = __riscv_vmand_mm_b64(mask, divisible_mask, vl);\n\n    vint64m1_t divisors_filtered = __riscv_vcompress_vm_i64m1(divisors, mask, vl);\n    \n    size_t result_len = __riscv_vcpop_m_b64(mask, vl);\n    if (result_len == 0) return 1;\n\n    return __riscv_vmv_x_s_i64m1_i64(__riscv_vlmul_ext_i64m1(__riscv_vmax_vx_i64m1(divisors_filtered, 0, result_len)));\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(16);\n    \n    // Initialize vector for potential factors\n    vint32m1_t factor_vec = __riscv_vmv_v_x_i32m1(2, vl);\n    \n    while (n > 1) {\n        // Vectorized division check\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vv_i32m1(n, factor_vec, vl), \n            0, \n            vl\n        );\n        \n        // Find first divisible factor\n        size_t first_factor_idx = __riscv_vfirst_m_b32(mask, vl);\n        \n        if (first_factor_idx < vl) {\n            // Extract the factor\n            int factor = __riscv_vmv_x_v_i32m1(factor_vec + first_factor_idx);\n            \n            // Add factor to result\n            factors.push_back(factor);\n            \n            // Divide n by factor\n            n /= factor;\n        } else {\n            // Increment factors if no division found\n            factor_vec = __riscv_vadd_vx_i32m1_mu(\n                mask, \n                factor_vec, \n                factor_vec, \n                1, \n                vl\n            );\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(16);\n    \n    // Initialize vector for divisors\n    vint32m1_t divisors = __riscv_vmv_v_x_i32m1(2, vl);\n    \n    while (n > 1) {\n        // Vectorized division check\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vv_i32m1(n, divisors, vl), \n            0, \n            vl\n        );\n        \n        // Find first divisor\n        size_t first_divisor_idx = __riscv_vfirst_m_b32(mask, vl);\n        \n        if (first_divisor_idx < vl) {\n            int divisor = __riscv_vmv_x_v_i32m1(divisors + first_divisor_idx);\n            factors.push_back(divisor);\n            n /= divisor;\n        } else {\n            // If no divisors found, increment divisors\n            divisors = __riscv_vadd_vx_i32m1(divisors, 1, vl);\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Set vector length to maximum available\n    size_t vl = __riscv_vsetvl_e32m1(16);\n    \n    // Start with smallest prime factor 2\n    int divisor = 2;\n    \n    while (n > 1) {\n        // Check if current divisor divides n\n        if (n % divisor == 0) {\n            // Vectorize the factor addition\n            vint32m1_t factor_vec = __riscv_vmv_v_x_i32m1(divisor, vl);\n            \n            // Append factor to vector\n            factors.push_back(divisor);\n            \n            // Divide n by divisor\n            n /= divisor;\n        } else {\n            // Move to next potential divisor\n            divisor++;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Set initial vector length\n    size_t vl = __riscv_vsetvl_e32m1(16);\n    \n    // Temporary vector for storing potential factors\n    vint32m1_t factor_vec = __riscv_vmv_v_x_i32m1(2, vl);\n    \n    while (n > 1) {\n        // Find smallest factor\n        for (int factor = 2; factor * factor <= n; factor++) {\n            // Vectorized comparison\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(factor_vec, factor, vl);\n            \n            // If factor divides n\n            while (__riscv_vcpop_m_b32(mask, vl) > 0 && n % factor == 0) {\n                factors.push_back(factor);\n                n /= factor;\n            }\n            \n            // Update factor vector\n            factor_vec = __riscv_vadd_vx_i32m1(factor_vec, 1, vl);\n        }\n        \n        // Handle remaining prime factor\n        if (n > 1) {\n            factors.push_back(n);\n            break;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Set initial vector length\n    size_t vl = __riscv_vsetvl_e32m1(16);\n    \n    // Iterate through potential divisors up to sqrt(n)\n    for (int divisor = 2; divisor * divisor <= n; divisor++) {\n        // Create vector to track divisibility\n        vint32m1_t divisors = __riscv_vmv_v_x_i32m1(divisor, vl);\n        \n        while (n % divisor == 0) {\n            // Vectorized division tracking\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n    }\n    \n    // Handle remaining prime factor if greater than 1\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Use RVV vector length agnostic approach\n    for (size_t vl = 0; vl < n; ) {\n        size_t max_vl = __riscv_vsetvl_e32m1(n - vl);\n        \n        // Load vector\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(l.data() + vl, max_vl);\n        \n        // Create mask for positive numbers\n        vbool32_t mask = __riscv_vmfgt_vf_f32m1_b32(vec, 0.0f, max_vl);\n        \n        // Compress positive numbers\n        vfloat32m1_t positive_vec = __riscv_vcompress_vv_f32m1(vec, mask, max_vl);\n        \n        // Count number of positive elements\n        size_t positive_count = __riscv_vcpop_m_b32(mask, max_vl);\n        \n        // Store positive numbers to result\n        std::vector<float> temp(positive_count);\n        __riscv_vse32_v_f32m1(temp.data(), positive_vec, positive_count);\n        \n        result.insert(result.end(), temp.begin(), temp.end());\n        \n        // Update loop variables\n        vl += max_vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // Use RVV vector length agnostic approach\n    for (size_t vl = 0; vl < n; ) {\n        // Determine vector length for this iteration\n        size_t max_vl = __riscv_vsetvl_e32m1(n - vl);\n        \n        // Load vector\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(l.data() + vl, max_vl);\n        \n        // Create mask for positive numbers\n        vbool32_t mask = __riscv_vmfgt_vf_f32m1_b32(vec, 0.0f, max_vl);\n        \n        // Compress vector to keep only positive numbers\n        vfloat32m1_t positive_vec = __riscv_vcompress_vvm_f32m1(vec, mask, vec, max_vl);\n        \n        // Count number of positive elements\n        size_t positive_count = __riscv_vcpop_m_b32(mask, max_vl);\n        \n        // Store positive elements\n        std::vector<float> temp_result(positive_count);\n        __riscv_vse32_v_f32m1(temp_result.data(), positive_vec, positive_count);\n        \n        // Append to result\n        result.insert(result.end(), temp_result.begin(), temp_result.end());\n        \n        // Update loop variables\n        vl += max_vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t n = l.size();\n    std::vector<float> result;\n    \n    // Use RVV intrinsics for vectorized processing\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t zero_vec = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector segment\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&l[i], vlmax);\n        \n        // Create mask for positive values\n        vbool32_t mask = __riscv_vmfgt_vv_f32m1_b32(vec, zero_vec, vlmax);\n        \n        // Compress positive values\n        vfloat32m1_t pos_vec = __riscv_vcompress_v_f32m1_m(mask, vec, vec, vlmax);\n        \n        // Count positive elements\n        size_t pos_count = __riscv_vcpop_m_b32(mask, vlmax);\n        \n        // Append to result vector\n        result.resize(result.size() + pos_count);\n        __riscv_vse32_v_f32m1(&result[result.size() - pos_count], pos_vec, pos_count);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // If vector is empty, return empty vector\n    if (n == 0) return result;\n    \n    // Set initial vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Iterate through vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for last iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(l.data() + i, vl);\n        \n        // Create mask for positive numbers\n        vbool32_t mask = __riscv_vmfgt_vf_f32m1_b32(vec, 0.0f, vl);\n        \n        // Compress vector to keep only positive numbers\n        vfloat32m1_t positive_vec = __riscv_vcompress_vm_f32m1(vec, mask, vl);\n        \n        // Count number of positive elements\n        size_t positive_count = __riscv_vcpop_m_b32(mask, vl);\n        \n        // Append positive elements to result\n        result.resize(result.size() + positive_count);\n        __riscv_vse32_v_f32m1(result.data() + result.size() - positive_count, positive_vec, positive_count);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    \n    // If vector is empty, return empty vector\n    if (n == 0) return result;\n    \n    // Set initial vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Iterate through the vector in vector-sized chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for last iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&l[i], vl);\n        \n        // Create mask for positive numbers\n        vbool32_t mask = __riscv_vmfgt_vf_f32m1_b32(vec, 0.0f, vl);\n        \n        // Compress positive numbers\n        vfloat32m1_t positive_vec = __riscv_vcompress_vv_f32m1(vec, mask, vl);\n        \n        // Count number of positive elements\n        size_t positive_count = __riscv_vcpop_m_b32(mask, vl);\n        \n        // Resize result vector and append positive numbers\n        result.resize(result.size() + positive_count);\n        __riscv_vse32_v_f32m1(&result[result.size() - positive_count], positive_vec, positive_count);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    size_t vl = __riscv_vsetvl_e64m1(sqrt_n / 2);\n    \n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vmul_vx_i64m1(divisors, 2, vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 3, vl);\n\n    for (size_t i = 0; i < vl; i++) {\n        int64_t div = __riscv_vmv_x_s(__riscv_vslidedown_vx_i64m1(divisors, i, vl));\n        if (div > sqrt_n) break;\n        if (n % div == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    size_t vl = __riscv_vsetvl_e64m1(sqrt_n / 2);\n    \n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vmul_vx_i64m1(divisors, 2, vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 3, vl);\n\n    for (size_t i = 0; i < vl; i++) {\n        int64_t divisor = __riscv_vmv_x_s(divisors);\n        if (divisor > sqrt_n) break;\n        if (n % divisor == 0) return false;\n        divisors = __riscv_vslide1up_vx_i64m1(divisors, 0, vl);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    size_t vl = __riscv_vsetvl_e64m1(sqrt_n / 2);\n    \n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vmul_vx_i64m1(divisors, 2, vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 3, vl);\n\n    vbool64_t mask = __riscv_vmslt_vx_i64m1_b64(divisors, sqrt_n + 1, vl);\n    \n    while (__riscv_vcpop_m_b64(mask, vl)) {\n        vint64m1_t remainder = __riscv_vrem_vv_i64m1(n, divisors, mask, vl);\n        if (__riscv_vcpop_m_b64(__riscv_vmseq_vx_i64m1_b64(remainder, 0, mask, vl), vl)) {\n            return false;\n        }\n        \n        divisors = __riscv_vadd_vx_i64m1(divisors, vl * 2, vl);\n        mask = __riscv_vmslt_vx_i64m1_b64(divisors, sqrt_n + 1, vl);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    size_t vl = __riscv_vsetvl_e64m1(sqrt_n / 2);\n    \n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vmul_vx_i64m1(divisors, 2, vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 3, vl);\n\n    for (size_t i = 0; i < vl; i++) {\n        int64_t div = __riscv_vmv_x_s(__riscv_vslidedown_vx_i64m1(divisors, i, vl));\n        if (div > sqrt_n) break;\n        if (n % div == 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    size_t vl = __riscv_vsetvl_e64m1(sqrt_n / 2);\n    \n    vint64m1_t divisors = __riscv_vid_v_i64m1(vl);\n    divisors = __riscv_vmul_vx_i64m1(divisors, 2, vl);\n    divisors = __riscv_vadd_vx_i64m1(divisors, 3, vl);\n\n    for (size_t i = 0; i < vl; i++) {\n        int64_t div = __riscv_vmv_x_s(__riscv_vslidedown_vx_i64m1(divisors, i, vl));\n        if (div > sqrt_n) break;\n        if (n % div == 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if string contains no letters\n    bool has_letters = false;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i, vl);\n        vint8m1_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        vbool8_t is_letter_mask = __riscv_vmsltu_vx_u8m1_b8(v_chars, 128, vlmax);\n        is_letter_mask = __riscv_vmand_mm_b8(\n            is_letter_mask, \n            __riscv_vmor_mm_b8(\n                __riscv_vmseq_vx_u8m1_b8(v_chars, 'a', vlmax),\n                __riscv_vmseq_vx_u8m1_b8(v_chars, 'A', vlmax),\n                vlmax\n            ),\n            vlmax\n        );\n        \n        if (__riscv_vcpop_m_b8(is_letter_mask, vlmax) > 0) {\n            has_letters = true;\n            break;\n        }\n    }\n    \n    if (!has_letters) {\n        // Reverse the entire string\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string with case conversion\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i, vl);\n        vint8m1_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        // Mask for lowercase letters\n        vbool8_t is_lower_mask = __riscv_vmand_mm_b8(\n            __riscv_vmsltu_vx_u8m1_b8(v_chars, 128, vlmax),\n            __riscv_vmseq_vx_u8m1_b8(v_chars, 'a', vlmax),\n            vlmax\n        );\n        \n        // Mask for uppercase letters\n        vbool8_t is_upper_mask = __riscv_vmand_mm_b8(\n            __riscv_vmsltu_vx_u8m1_b8(v_chars, 128, vlmax),\n            __riscv_vmseq_vx_u8m1_b8(v_chars, 'A', vlmax),\n            vlmax\n        );\n        \n        // Convert lowercase to uppercase\n        vint8m1_t v_upper = __riscv_vsub_vx_i8m1_m(is_lower_mask, v_chars, 32, vlmax);\n        \n        // Convert uppercase to lowercase\n        vint8m1_t v_lower = __riscv_vadd_vx_i8m1_m(is_upper_mask, v_chars, 32, vlmax);\n        \n        // Merge converted chars with original chars\n        vint8m1_t v_result = __riscv_vmerge_vvm_i8m1(v_chars, v_upper, is_lower_mask, vlmax);\n        v_result = __riscv_vmerge_vvm_i8m1(v_result, v_lower, is_upper_mask, vlmax);\n        \n        // Store result back to string\n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[i]), v_result, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if the string contains any letters\n    bool has_letters = false;\n    \n    // Use RVV to process the string\n    size_t vl = __riscv_vsetvlmax_e8m1();\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load characters\n        vint8m1_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        // Create mask for letters\n        vbool8_t letter_mask = __riscv_vmseq_vx_i8m1_b8(\n            __riscv_vand_vx_i8m1(\n                __riscv_vor_vx_i8m1(\n                    __riscv_vslt_vx_i8m1(v_chars, 123, vlmax),\n                    __riscv_vmsge_vx_i8m1(v_chars, 65, vlmax),\n                    vlmax\n                ),\n                1, vlmax\n            ), 1, vlmax);\n        \n        // Process letters\n        vint8m1_t v_processed = __riscv_vxor_vx_i8m1_m(letter_mask, v_chars, v_chars, 32, vlmax);\n        \n        // Store processed characters\n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[i]), v_processed, vlmax);\n        \n        // Check if any letters found\n        if (__riscv_vcpop_m_b8(letter_mask, vlmax)) {\n            has_letters = true;\n        }\n    }\n    \n    // If no letters found, reverse the string\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if the string contains no letters\n    bool has_letter = false;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        vbool8_t v_is_letter = __riscv_vmsltu_vx_u8m1_b8(v_chars, 128, vlmax);\n        v_is_letter = __riscv_vand_vv_u8m1_b8(\n            v_is_letter, \n            __riscv_vmsleu_vx_u8m1_b8(v_chars, 'z', vlmax), \n            vlmax\n        );\n        v_is_letter = __riscv_vor_vv_u8m1_b8(\n            v_is_letter, \n            __riscv_vmsleu_vx_u8m1_b8(v_chars, 'Z', vlmax), \n            vlmax\n        );\n        \n        if (__riscv_vmfirst_m_b8(v_is_letter, vlmax) != -1) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (!has_letter) {\n        // Reverse the string\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Change case for letters\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        // Check if character is lowercase\n        vbool8_t v_is_lower = __riscv_vmsleu_vx_u8m1_b8(v_chars, 'z', vlmax);\n        v_is_lower = __riscv_vand_vv_u8m1_b8(\n            v_is_lower, \n            __riscv_vmsleu_vx_u8m1_b8(v_chars, 'a', vlmax), \n            vlmax\n        );\n        \n        // Check if character is uppercase\n        vbool8_t v_is_upper = __riscv_vmsleu_vx_u8m1_b8(v_chars, 'Z', vlmax);\n        v_is_upper = __riscv_vand_vv_u8m1_b8(\n            v_is_upper, \n            __riscv_vmsleu_vx_u8m1_b8(v_chars, 'A', vlmax), \n            vlmax\n        );\n        \n        // Modify case\n        vint8m1_t v_modified = __riscv_vmerge_vxm_i8m1(v_chars, v_chars ^ 32, v_is_lower | v_is_upper, vlmax);\n        \n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[i]), v_modified, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    size_t n = s.length();\n    std::string result(n, ' ');\n    \n    // Check if string contains no letters\n    bool has_letters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    // If no letters, simply reverse the string\n    if (!has_letters) {\n        size_t vl = __riscv_vsetvl_e8m1(n);\n        for (size_t i = 0; i < n; i += vl) {\n            size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n            vint8m1_t v = __riscv_vle8_v_i8m1(s.data() + n - i - vlmax, vlmax);\n            __riscv_vse8_v_i8m1(result.data() + i, v, vlmax);\n        }\n        return result;\n    }\n\n    // Process string with letters\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        vint8m1_t v = __riscv_vle8_v_i8m1(s.data() + i, vlmax);\n\n        // Create mask for alphabetic characters\n        vbool8_t mask = __riscv_vmseq_vv_i8m1_b8(v, v);\n        mask = __riscv_vmand_mm_b8(mask, __riscv_vmnand_mm_b8(\n            __riscv_vmsltu_vx_i8m1_b8(v, 'A', vlmax),\n            __riscv_vmslt_vx_i8m1_b8(v, 127, vlmax)\n        ), vlmax);\n\n        // Swap case for alphabetic characters\n        vint8m1_t lower_mask = __riscv_vand_vx_i8m1_m(mask, v, 0x20, vlmax);\n        vint8m1_t case_swap = __riscv_vxor_vx_i8m1_m(mask, v, 0x20, vlmax);\n\n        __riscv_vse8_v_i8m1(result.data() + i, case_swap, vlmax);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if the string contains any letters\n    bool has_letters = false;\n    \n    // Use RVV to process the string\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n    \n    // Process each character\n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e8m1(n - i);\n        v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vl);\n        \n        // Create mask for letters\n        vbool8_t letter_mask = __riscv_vmsltu_vx_u8m1_b8(v_input, 'A', vl);\n        letter_mask = __riscv_vmand_mm_b8(\n            letter_mask, \n            __riscv_vmslt_vx_i8m1_b8(v_input, 'z' + 1, vl), \n            vl\n        );\n        \n        // Mask for uppercase letters\n        vbool8_t upper_mask = __riscv_vmsltu_vx_u8m1_b8(v_input, 'A', vl);\n        upper_mask = __riscv_vmand_mm_b8(\n            upper_mask, \n            __riscv_vmslt_vx_i8m1_b8(v_input, 'Z' + 1, vl), \n            vl\n        );\n        \n        // Mask for lowercase letters\n        vbool8_t lower_mask = __riscv_vmsltu_vx_u8m1_b8(v_input, 'a', vl);\n        lower_mask = __riscv_vmand_mm_b8(\n            lower_mask, \n            __riscv_vmslt_vx_i8m1_b8(v_input, 'z' + 1, vl), \n            vl\n        );\n        \n        // Change case for letters\n        vint8_t case_change = __riscv_vmerge_vxm_i8m1(v_input, 0, letter_mask, vl);\n        case_change = __riscv_vmerge_vxm_i8m1(\n            case_change, \n            __riscv_vadd_vx_i8m1(v_input, 'A' - 'a', vl), \n            __riscv_vand_mm_b8(letter_mask, lower_mask, vl), \n            vl\n        );\n        case_change = __riscv_vmerge_vxm_i8m1(\n            case_change, \n            __riscv_vsub_vx_i8m1(v_input, 'A' - 'a', vl), \n            __riscv_vand_mm_b8(letter_mask, upper_mask, vl), \n            vl\n        );\n        \n        // Check if any letters exist\n        has_letters |= __riscv_vcpop_m_b8(letter_mask, vl);\n        \n        // Store back to result\n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[i]), case_change, vl);\n    }\n    \n    // If no letters, reverse the string\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n <= 2) return l;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create mask for indices divisible by 3\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), 3, vl\n    );\n\n    // Extract elements divisible by 3\n    size_t count = __riscv_vcpop_m_b32(mask, vl);\n    std::vector<int> third_elements(count);\n    \n    vint32m1_t third_vec = __riscv_vcompress_vvm_i32m1(\n        __riscv_vle32_v_i32m1(l.data(), vl), \n        mask, \n        vl\n    );\n    \n    // Sort extracted elements\n    std::sort(third_elements.begin(), third_elements.end());\n    \n    // Reconstruct result vector\n    std::vector<int> result(n);\n    vint32m1_t sorted_third = __riscv_vle32_v_i32m1(third_elements.data(), count);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vbool32_t cur_mask = __riscv_vmseq_vx_u32m1_b32(\n            __riscv_vid_v_u32m1(vl), 3, vl\n        );\n        \n        vint32m1_t cur_vec = __riscv_vle32_v_i32m1(l.data() + i, vl);\n        vint32m1_t result_vec = __riscv_vmerge_vvm_i32m1(\n            cur_vec, \n            sorted_third, \n            cur_mask, \n            vl\n        );\n        \n        __riscv_vse32_v_i32m1(result.data() + i, result_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n <= 2) return l;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create mask for indices divisible by 3\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vseq_vx_u32m1(vl), 0, vl);\n\n    // Extract elements divisible by 3\n    vint32m1_t third_elements = __riscv_vcompress_vx_u32m1(\n        __riscv_vle32_v_i32m1(l.data(), vl), \n        mask, \n        vl\n    );\n\n    // Get number of elements divisible by 3\n    size_t third_count = __riscv_vcpop_m_b32(mask, vl);\n\n    // Sort these elements\n    std::vector<int> third_vec(third_count);\n    __riscv_vse32_v_i32m1(third_vec.data(), \n        __riscv_vsort_vx_i32m1(third_elements, third_count), \n        third_count\n    );\n\n    // Reconstruct result vector\n    std::vector<int> result(n);\n    size_t third_idx = 0;\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = third_vec[third_idx++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n <= 2) return l;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create mask for indices divisible by 3\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        3, \n        vl\n    );\n\n    // Extract elements divisible by 3\n    size_t count = __riscv_vcpop_m_b32(mask, vl);\n    std::vector<int> third_elements(count);\n    \n    vint32m1_t third_vec = __riscv_vcompress_vm_i32m1(\n        __riscv_vle32_v_i32m1(l.data(), vl), \n        mask, \n        vl\n    );\n    \n    // Sort extracted elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Create result vector\n    std::vector<int> result(l);\n    \n    // Replace elements divisible by 3 with sorted values\n    for (size_t i = 0; i < count; ++i) {\n        result[i * 3] = third_elements[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n <= 2) return l;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create mask for indices divisible by 3\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        3, \n        vl\n    );\n\n    // Extract elements divisible by 3\n    size_t count = __riscv_vcpop_m_b32(mask, vl);\n    std::vector<int> third_elements(count);\n    \n    vint32m1_t third_vec = __riscv_vcompress_vm_u32m1(\n        __riscv_vle32_v_u32m1(l.data(), vl), \n        mask, \n        vl\n    );\n\n    // Sort the extracted elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Reconstruct the result vector\n    std::vector<int> result(n);\n    size_t third_idx = 0;\n\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            result[i] = third_elements[third_idx++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n <= 2) return l;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Create mask for indices divisible by 3\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vseq_vx_u32m1(vl), 0, vl);\n\n    // Extract elements divisible by 3\n    size_t count = __riscv_vcpop_m_b32(mask, vl);\n    std::vector<int> third_elements(count);\n    \n    vint32m1_t v_input = __riscv_vle32_v_i32m1(l.data(), vl);\n    vint32m1_t v_third = __riscv_vcompress_vm_i32m1(v_input, mask, vl);\n    __riscv_vse32_v_i32m1(third_elements.data(), v_third, count);\n\n    // Sort third elements\n    std::sort(third_elements.begin(), third_elements.end());\n\n    // Reconstruct result vector\n    std::vector<int> result(n);\n    size_t third_idx = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (i % 3 == 0) {\n            result[i] = third_elements[third_idx++];\n        } else {\n            result[i] = l[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t max_vec = __riscv_vle32_v_f32m1(l.data(), vl);\n    \n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vfloat32m1_t curr_vec = __riscv_vle32_v_f32m1(l.data() + i, vl);\n        max_vec = __riscv_vfmax_vv_f32m1(max_vec, curr_vec, vl);\n    }\n    \n    vfloat32m1_t red_max = __riscv_vfredmax_vs_f32m1_f32m1(max_vec, __riscv_vfmv_s_f_f32m1(0.0f, vl), vl);\n    max_val = __riscv_vfmv_f_s_f32m1_f32(red_max);\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t max_vec = __riscv_vle32_v_f32m1(l.data(), vl);\n    \n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vfloat32m1_t curr_vec = __riscv_vle32_v_f32m1(l.data() + i, vl);\n        max_vec = __riscv_vfmax_vv_f32m1(max_vec, curr_vec, vl);\n    }\n    \n    vfloat32m1_t red_max = __riscv_vfredmax_vs_f32m1_f32m1(max_vec, __riscv_vfmv_s_f_f32m1(0.0f, vl), vl);\n    max_val = __riscv_vfmv_f_s_f32m1_f32(red_max);\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t max_vec = __riscv_vle32_v_f32m1(l.data(), vl);\n    \n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vfloat32m1_t curr_vec = __riscv_vle32_v_f32m1(l.data() + i, vl);\n        max_vec = __riscv_vfmax_vv_f32m1(max_vec, curr_vec, vl);\n    }\n    \n    vfloat32m1_t red_max = __riscv_vfredmax_vs_f32m1_f32m1(max_vec, __riscv_vfmv_s_f_f32m1(0.0f, vl), vl);\n    max_val = __riscv_vfmv_f_s_f32m1_f32(red_max);\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t max_vec = __riscv_vle32_v_f32m1(l.data(), vl);\n    \n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vfloat32m1_t curr_vec = __riscv_vle32_v_f32m1(l.data() + i, vl);\n        max_vec = __riscv_vfmax_vv_f32m1(max_vec, curr_vec, vl);\n    }\n    \n    vfloat32m1_t red_max = __riscv_vfredmax_vs_f32m1_f32m1(max_vec, __riscv_vfmv_s_f_f32m1(0.0f, vl), vl);\n    max_val = __riscv_vfmv_f_s_f32m1_f32(red_max);\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t max_vec = __riscv_vle32_v_f32m1(l.data(), vl);\n    \n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vfloat32m1_t curr_vec = __riscv_vle32_v_f32m1(l.data() + i, vl);\n        max_vec = __riscv_vfmax_vv_f32m1(max_vec, curr_vec, vl);\n    }\n    \n    vfloat32m1_t red_max = __riscv_vfredmax_vs_f32m1_f32m1(max_vec, __riscv_vfmv_s_f_f32m1(0.0f, vl), vl);\n    max_val = __riscv_vfmv_f_s_f32m1_f32(red_max);\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vzero = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t vec_indices = __riscv_vadd_vx_i32m1(__riscv_vmv_v_x_i32m1(i, vl), \n                                                       __riscv_vid_v_i32m1(vl), \n                                                       vl);\n        vbool32_t mask_div11 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 11, vl), 0, vl);\n        vbool32_t mask_div13 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 13, vl), 0, vl);\n        vbool32_t mask_combined = __riscv_vmor_vv_b32(mask_div11, mask_div13, vl);\n        \n        vint32m1_t vec_digits = __riscv_vrem_vx_i32m1(vec_indices, 10, vl);\n        vbool32_t mask_seven = __riscv_vmseq_vx_i32m1_b32(vec_digits, 7, vl);\n        \n        vbool32_t final_mask = __riscv_vmand_vv_b32(mask_combined, mask_seven, vl);\n        \n        count += __riscv_vcpop_m_b32(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vzero = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t vid = __riscv_vid_v_i32m1(vl);\n        vid = __riscv_vadd_vx_i32m1(vid, i, vl);\n        \n        vbool32_t div_11 = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(vid, 11, vl), 0, vl);\n        \n        vbool32_t div_13 = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(vid, 13, vl), 0, vl);\n        \n        vbool32_t divisible = __riscv_vmor_mm_b32(div_11, div_13, vl);\n        \n        vint32m1_t digits = __riscv_vrem_vx_i32m1(vid, 10, vl);\n        vbool32_t is_seven = __riscv_vmseq_vx_i32m1_b32(digits, 7, vl);\n        \n        vbool32_t result = __riscv_vmand_mm_b32(divisible, is_seven, vl);\n        \n        count += __riscv_vcpop_m_b32(result, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vzero = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t vec_indices = __riscv_vadd_vx_i32m1(__riscv_vmv_v_x_i32m1(i, vl), __riscv_vid_v_i32m1(vl), vl);\n        vbool32_t mask_div_11 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 11, vl), 0, vl);\n        vbool32_t mask_div_13 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 13, vl), 0, vl);\n        vbool32_t mask_combined = __riscv_vmor_vv_b32(mask_div_11, mask_div_13, vl);\n        \n        vint32m1_t vec_digits = __riscv_vrem_vx_i32m1(vec_indices, 10, vl);\n        vbool32_t mask_seven = __riscv_vmseq_vx_i32m1_b32(vec_digits, 7, vl);\n        \n        vbool32_t final_mask = __riscv_vmand_vv_b32(mask_combined, mask_seven, vl);\n        count += __riscv_vcpop_m_b32(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vzero = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t vec_indices = __riscv_vadd_vx_i32m1(__riscv_vmv_v_x_i32m1(i, vl), \n                                                       __riscv_vid_v_i32m1(vl), vl);\n        vbool32_t mask_div_11 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 11, vl), 0, vl);\n        vbool32_t mask_div_13 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 13, vl), 0, vl);\n        vbool32_t mask_combined = __riscv_vmor_mm_b32(mask_div_11, mask_div_13, vl);\n        \n        vint32m1_t vec_digits = __riscv_vrem_vx_i32m1(vec_indices, 10, vl);\n        vbool32_t mask_seven = __riscv_vmseq_vx_i32m1_b32(vec_digits, 7, vl);\n        \n        vbool32_t final_mask = __riscv_vmand_mm_b32(mask_combined, mask_seven, vl);\n        \n        count += __riscv_vcpop_m_b32(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vzero = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t vec_indices = __riscv_vadd_vx_i32m1(__riscv_vmv_v_x_i32m1(i, vl), \n                                                       __riscv_vid_v_i32m1(vl), vl);\n        vbool32_t mask_div_11 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 11, vl), vzero, vl);\n        vbool32_t mask_div_13 = __riscv_vmseq_vx_i32m1_b32(__riscv_vrem_vx_i32m1(vec_indices, 13, vl), vzero, vl);\n        vbool32_t mask_combined = __riscv_vmor_mm_b32(mask_div_11, mask_div_13, vl);\n        \n        vint32m1_t vec_digits = __riscv_vrem_vx_i32m1(vec_indices, 10, vl);\n        vbool32_t mask_seven = __riscv_vmseq_vx_i32m1_b32(vec_digits, 7, vl);\n        \n        vbool32_t final_mask = __riscv_vmand_mm_b32(mask_combined, mask_seven, vl);\n        count += __riscv_vcpop_m_b32(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create result vector same as input\n    std::vector<float> result = l;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n\n    // Load even indices into vector\n    float* even_ptr = l.data() + 0;\n    vfloat32m1_t v_even = __riscv_vle32_v_f32m1(even_ptr, vl);\n\n    // Sort even indices vector\n    for (size_t i = 1; i < vl; i *= 2) {\n        vfloat32m1_t v_sorted = __riscv_vssrl_vv_f32m1(v_even, v_even, vl);\n        v_even = __riscv_vfmin_vv_f32m1(v_even, v_sorted, vl);\n    }\n\n    // Store sorted even indices back into result\n    __riscv_vse32_v_f32m1(result.data() + 0, v_even, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create result vector same as input\n    std::vector<float> result = l;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n\n    // Load even indices into vector\n    float* even_ptr = l.data() + 0;\n    vfloat32m1_t v_even = __riscv_vle32_v_f32m1(even_ptr, vl);\n\n    // Sort even indices vector\n    for (size_t i = 1; i < vl; i *= 2) {\n        vfloat32m1_t v_sorted = __riscv_vmerge_vvm_f32m1(v_even, v_even, 0, vl);\n        v_sorted = __riscv_vssrl_vx_f32m1(v_sorted, 1, vl);\n        v_even = __riscv_vmin_vv_f32m1(v_even, v_sorted, vl);\n    }\n\n    // Store sorted even indices back\n    __riscv_vse32_v_f32m1(result.data() + 0, v_even, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create result vector same as input\n    std::vector<float> result = l;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n\n    // Load even indices into vector\n    float* even_ptr = l.data() + 0;\n    vfloat32m1_t v_even = __riscv_vle32_v_f32m1(even_ptr, vl);\n\n    // Sort even indices vector\n    for (size_t gap = vl/2; gap > 0; gap /= 2) {\n        for (size_t i = 0; i < vl; i += gap * 2) {\n            vfloat32m1_t v_a = __riscv_vslide1down_vf_f32m1(v_even, 0.0f, vl);\n            v_even = __riscv_vmerge_vvm_f32m1(__riscv_vfmin_vv_f32m1(v_even, v_a, vl), v_even, v_a, vl);\n        }\n    }\n\n    // Store sorted even indices back to result\n    __riscv_vse32_v_f32m1(result.data() + 0, v_even, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create result vector as a copy of input\n    std::vector<float> result = l;\n\n    // Determine vector length and create masks\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), 0, vl);\n\n    // Extract even indices\n    vfloat32m1_t even_vec = __riscv_vcompress_v_f32m1_f32m1(\n        __riscv_vle32_v_f32m1(l.data(), vl), \n        mask, vl);\n\n    // Sort even indices\n    vfloat32m1_t sorted_even = __riscv_vsort_v_f32m1(even_vec, vl);\n\n    // Scatter sorted values back to even indices\n    for (size_t i = 0; i < n/2; i++) {\n        result[2*i] = __riscv_vfmv_f_s_f32m1_f32(\n            __riscv_vslidedown_v_f32m1(sorted_even, i, vl));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create result vector as a copy of input\n    std::vector<float> result = l;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n\n    // Extract even indices\n    std::vector<float> even_elements(n/2);\n    for (size_t i = 0; i < n/2; i++) {\n        even_elements[i] = l[2*i];\n    }\n\n    // Load even elements into vector register\n    vfloat32m1_t vec_even = __riscv_vle32_v_f32m1(even_elements.data(), vl);\n\n    // Sort even elements using vector bitonic sort\n    for (size_t step = 1; step < vl; step *= 2) {\n        for (size_t substep = step; substep > 0; substep /= 2) {\n            vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(__riscv_vand_vx_u32m1(vec_even, substep, vl), 0, vl);\n            vec_even = __riscv_vfmin_vv_f32m1_m(mask, vec_even, vec_even, vec_even, vl);\n        }\n    }\n\n    // Store sorted even elements back into result\n    for (size_t i = 0; i < n/2; i++) {\n        result[2*i] = __riscv_vfmv_f_s_f32m1_f32(vec_even);\n        vec_even = __riscv_vslide1down_vf_f32m1(vec_even, 0, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Use RVV intrinsics for vector processing\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = -(l[i] + l[j]);\n\n            // Vectorized search for third element\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n            bool found = __riscv_vmfirst_m_b32(mask, vl) != -1;\n\n            if (found) {\n                // Ensure the found element is not i or j\n                for (int k = 0; k < n; k++) {\n                    if (k != i && k != j && l[k] == target) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Use RVV intrinsics for vectorized processing\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = -(l[i] + l[j]);\n\n            // Vectorized search for third element\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n            uint32_t result = __riscv_vmfirst_m_b32(mask, vl);\n\n            if (result != -1 && result != i && result != j) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Use RVV intrinsics for vector processing\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = -(l[i] + l[j]);\n\n            // Vectorized search for third element\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n            unsigned int found = __riscv_vmfirst_m_b32(mask, vl);\n\n            if (found != -1 && found != i && found != j) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Use RVV intrinsics for vector processing\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            // Compute the target value needed to sum to zero\n            int target = -(l[i] + l[j]);\n\n            // Use vector search for the target\n            vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n            bool found = __riscv_vmfirst_m_b32(mask, vl) != -1;\n\n            // Ensure the found index is different from i and j\n            if (found) {\n                size_t k = __riscv_vmfirst_m_b32(mask, vl);\n                if (k != i && k != j) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Use RVV intrinsics for vector processing\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    // Nested loops to check all possible triples\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            // Vectorized search for third element\n            vint32m1_t target_vec = __riscv_vmv_v_x_i32m1(-(l[i] + l[j]), vl);\n            vbool32_t mask = __riscv_vmerge_vvm_b32(vec, target_vec, vl);\n            \n            // Check if target exists in remaining vector\n            if (__riscv_vcpop_m_b32(mask, vl) > 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vlmax);\n        vint32m1_t incremented = __riscv_vadd_vx_i32m1(vec, 1, vlmax);\n        \n        __riscv_vse32_v_i32m1(&result[i], incremented, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vlmax);\n        vint32m1_t inc_vec = __riscv_vadd_vx_i32m1(vec, 1, vlmax);\n        \n        __riscv_vse32_v_i32m1(&result[i], inc_vec, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vlmax);\n        vint32m1_t incremented = __riscv_vadd_vx_i32m1(vec, 1, vlmax);\n        \n        __riscv_vse32_v_i32m1(&result[i], incremented, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vlmax);\n        vint32m1_t incremented = __riscv_vadd_vx_i32m1(vec, 1, vlmax);\n        \n        __riscv_vse32_v_i32m1(&result[i], incremented, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(l.data() + i, vlmax);\n        vint32m1_t incremented = __riscv_vadd_vx_i32m1(vec, 1, vlmax);\n        \n        __riscv_vse32_v_i32m1(result.data() + i, incremented, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load input vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    // Iterate through each element\n    for (int i = 0; i < n; i++) {\n        int target = -l[i];\n        \n        // Create mask for elements after current index\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n        \n        // Check if any element matches the target\n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    size_t n = l.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n    \n    for (size_t i = 0; i < n; i++) {\n        int current = l[i];\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(-current, vec, vl);\n        \n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    for (int i = 0; i < n; i++) {\n        int target = -l[i];\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n        \n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    size_t n = l.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n\n    for (size_t i = 0; i < n; i++) {\n        int current = l[i];\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(-current, vec, vl);\n        \n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    size_t n = l.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vint32m1_t vec = __riscv_vle32_v_i32m1(l.data(), vl);\n    \n    for (size_t i = 0; i < n; i++) {\n        int target = -l[i];\n        \n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, target, vl);\n        \n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate a buffer to store digits\n    std::vector<char> digits(64);  // Maximum 64-bit number\n    int len = 0;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(64);\n    vint8m1_t v_base = __riscv_vmv_v_x_i8m1(base, vl);\n    \n    // Convert to base representation\n    while (x > 0) {\n        // Vectorized division and remainder\n        vint64m1_t v_x = __riscv_vmv_v_x_i64m1(x, vl);\n        vint64m1_t v_quotient = __riscv_vdivu_vv_u64m1(v_x, v_base, vl);\n        vint64m1_t v_remainder = __riscv_vremu_vv_u64m1(v_x, v_base, vl);\n        \n        // Store remainder as digit\n        int remainder = __riscv_vmv_x_s_i64m1_i64(v_remainder);\n        digits[len++] = remainder + '0';\n        \n        // Update x\n        x = __riscv_vmv_x_s_i64m1_i64(v_quotient);\n    }\n    \n    // Reverse the digits\n    std::reverse(digits.begin(), digits.begin() + len);\n    \n    return std::string(digits.begin(), digits.begin() + len);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate a buffer to store digits\n    char buffer[65];  // Max 64 bits + null terminator\n    int index = 64;\n    buffer[index] = '\\0';\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e64m1(64);\n    \n    // Create vector for base\n    vint64m1_t base_vec = __riscv_vmv_v_x_i64m1(base, vl);\n    \n    // Process digits in parallel\n    while (x > 0) {\n        // Compute remainder using vector division\n        vint64m1_t x_vec = __riscv_vmv_v_x_i64m1(x, vl);\n        vint64m1_t remainder_vec = __riscv_vrem_vv_i64m1(x_vec, base_vec, vl);\n        \n        // Extract remainder\n        int64_t remainder = __riscv_vmv_x_s_i64m1_i64(remainder_vec);\n        \n        // Convert remainder to character\n        buffer[--index] = '0' + remainder;\n        \n        // Integer division\n        x /= base;\n    }\n    \n    // Return substring starting from first non-zero digit\n    return std::string(buffer + index);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate a buffer for digits\n    std::vector<char> digits(64);\n    size_t digit_count = 0;\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e8m1(64);\n    \n    // Create vector to store digits\n    vint8m1_t digit_vec = __riscv_vmv_v_x_i8m1(0, vl);\n    \n    // Convert to base\n    while (x > 0) {\n        int8_t remainder = x % base;\n        digits[digit_count++] = remainder + '0';\n        x /= base;\n    }\n    \n    // Reverse the digits\n    for (size_t i = 0; i < digit_count / 2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[digit_count - 1 - i];\n        digits[digit_count - 1 - i] = temp;\n    }\n    \n    // Convert to string\n    return std::string(digits.begin(), digits.begin() + digit_count);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate a buffer to store digits\n    std::vector<char> digits(64);  // Max 64-bit number\n    int len = 0;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(64);\n    vint8m1_t v_base = __riscv_vmv_v_x_i8m1(base, vl);\n    \n    // Convert to base using vector division\n    while (x > 0) {\n        vint64m1_t v_x = __riscv_vmv_v_x_i64m1(x, vl);\n        vint64m1_t v_quotient = __riscv_vdivu_vv_i64m1(v_x, v_base, vl);\n        vint64m1_t v_remainder = __riscv_vremu_vv_i64m1(v_x, v_base, vl);\n        \n        // Store remainder as digit\n        int8_t remainder = __riscv_vmv_x_s_i64m1_i64(v_remainder);\n        digits[len++] = '0' + remainder;\n        \n        x = __riscv_vmv_x_s_i64m1_i64(v_quotient);\n    }\n    \n    // Reverse the digits\n    std::reverse(digits.begin(), digits.begin() + len);\n    \n    return std::string(digits.begin(), digits.begin() + len);\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate a buffer for digits\n    const int max_digits = 64;\n    char digits[max_digits];\n    int digit_count = 0;\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e64m1(max_digits);\n    \n    // Create vector for digits\n    vint64m1_t v_digits = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    // Convert to base\n    while (x > 0) {\n        digits[digit_count++] = '0' + (x % base);\n        x /= base;\n    }\n    \n    // Reverse the digits\n    for (int i = 0; i < digit_count / 2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[digit_count - 1 - i];\n        digits[digit_count - 1 - i] = temp;\n    }\n    \n    // Convert to string\n    return std::string(digits, digit_count);\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e8m1(len / 2);\n    size_t half_len = len / 2;\n\n    // Load first half of string\n    vint8m1_t first_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str(), vl);\n    \n    // Load reversed second half of string\n    vint8m1_t second_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str() + len - vl, vl);\n    second_half = __riscv_vrev8_v_i8m1(second_half);\n\n    // Compare first and reversed second half\n    vbool8_t mask = __riscv_vmsne_vv_i8m1_b8(first_half, second_half, vl);\n    \n    return __riscv_vmand_mm_b8(mask, vl) == 0;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e8m1(len / 2);\n    size_t vec_size = vl;\n\n    // Load first half of string\n    vint8m1_t first_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str(), vec_size);\n    \n    // Load reversed second half of string\n    vint8m1_t second_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str() + len - vec_size, vec_size);\n    second_half = __riscv_vrev8_v_i8m1(second_half);\n\n    // Compare first and second half\n    vbool8_t mask = __riscv_vmsne_vv_i8m1_b8(first_half, second_half);\n    \n    return __riscv_vmfirst_m_b8(mask, vec_size) == -1;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e8m1(len / 2);\n    size_t half_len = len / 2;\n\n    // Load first half of string\n    vint8m1_t first_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str(), vl);\n    \n    // Load reversed second half of string\n    vint8m1_t second_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str() + len - vl, vl);\n    second_half = __riscv_vrev8_v_i8m1(second_half);\n\n    // Compare first and second half\n    vbool8_t mask = __riscv_vmsne_vv_i8m1_b8(first_half, second_half, vl);\n    \n    return __riscv_vmfirst_m_b8(mask, vl) == -1;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e8m1(len / 2);\n    size_t half_len = len / 2;\n\n    // Load first half of string\n    vint8m1_t first_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str(), vl);\n    \n    // Load reversed second half of string\n    vint8m1_t second_half = __riscv_vle8_v_i8m1((int8_t*)text.c_str() + len - vl, vl);\n    second_half = __riscv_vrev8_v_i8m1(second_half);\n\n    // Compare first and reversed second half\n    vbool8_t mask = __riscv_vmsne_vv_i8m1_b8(first_half, second_half, vl);\n    \n    return __riscv_vmand_mm_b8(mask, vl) == 0;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vl = __riscv_vsetvl_e8m1(len / 2);\n    size_t half_len = len / 2;\n\n    // Load first half of string\n    vint8m1_t first_half = __riscv_vle8_v_i8m1(text.data(), vl);\n    \n    // Load reversed second half of string\n    vint8m1_t second_half = __riscv_vle8_v_i8m1(text.data() + len - vl, vl);\n    vint8m1_t reversed_second_half = __riscv_vrev8_v_i8m1(second_half);\n\n    // Compare first and reversed second half\n    vbool8_t comparison = __riscv_vseq_vv_i8m1_b8(first_half, reversed_second_half);\n    bool all_match = __riscv_vmand_mm_b8(comparison, comparison, vl);\n\n    // Handle odd length strings\n    if (len % 2 != 0) {\n        return all_match && text[half_len] == text[half_len];\n    }\n\n    return all_match;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t len = s.length();\n    \n    // Process vector elements\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    for (size_t i = 0; i < len; i += vl) {\n        vl = __riscv_vsetvl_e8m1(len - i);\n        \n        // Load input vector\n        vint8m1_t input_vec = __riscv_vle8_v_i8m1((int8_t*)(s.data() + i), vl);\n        \n        // Subtract 5 and wrap around alphabet\n        vint8m1_t shifted_vec = __riscv_vsub_vx_i8m1(input_vec, 5, vl);\n        vint8m1_t wrapped_vec = __riscv_vrem_vx_i8m1(\n            __riscv_vsub_vx_i8m1(shifted_vec, (int8_t)'a', vl), \n            26, \n            vl\n        );\n        vint8m1_t result_vec = __riscv_vadd_vx_i8m1(wrapped_vec, (int8_t)'a', vl);\n        \n        // Store result vector\n        __riscv_vse8_v_i8m1((int8_t*)(out.data() + i), result_vec, vl);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t l = s.length();\n    \n    // Process vector elements\n    size_t vl;\n    for (size_t i = 0; i < l; i += vl) {\n        vl = __riscv_vsetvl_e8m1(l - i);\n        \n        // Load input string characters\n        vint8_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vl);\n        \n        // Subtract 5 and handle wrap-around\n        vint8_t v_decoded = __riscv_vsub_vx_i8m1(v_chars, 5, vl);\n        vint8_t v_wrapped = __riscv_vrem_vx_i8m1(\n            __riscv_vadd_vx_i8m1(v_decoded, 26, vl), \n            26, vl\n        );\n        vint8_t v_result = __riscv_vadd_vx_i8m1(v_wrapped, (int8_t)'a', vl);\n        \n        // Store decoded characters\n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&out[i]), v_result, vl);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t l = s.length();\n    \n    for (size_t vl = 0; vl < l; ) {\n        size_t max_vl = __riscv_vsetvl_e8m1(l - vl);\n        \n        // Load input vector\n        vuint8_t v_input = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data() + vl), max_vl);\n        \n        // Subtract 5 and handle wrap-around\n        vuint8_t v_sub = __riscv_vsub_vx_u8m1(v_input, 5, max_vl);\n        vuint8_t v_base = __riscv_vmv_v_x_u8m1('a', max_vl);\n        vuint8_t v_wrap = __riscv_vadd_vv_u8m1(__riscv_vrem_vx_u8m1(v_sub, 26, max_vl), v_base, max_vl);\n        \n        // Store result\n        __riscv_vse8_v_u8m1(reinterpret_cast<uint8_t*>(&out[vl]), v_wrap, max_vl);\n        \n        vl += max_vl;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t len = s.length();\n    \n    // Process vector chunks\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    for (size_t i = 0; i < len; i += vl) {\n        vl = __riscv_vsetvl_e8m1(len - i);\n        \n        // Load input string vector\n        vuint8m1_t input_vec = __riscv_vle8_v_u8m1((uint8_t*)(s.data() + i), vl);\n        \n        // Subtract 5 and wrap around alphabet\n        vuint8m1_t five_vec = __riscv_vmv_v_x_u8m1(5, vl);\n        vuint8m1_t sub_vec = __riscv_vsub_vv_u8m1(input_vec, five_vec, vl);\n        \n        // Handle wrap-around for characters below 'a'\n        vuint8m1_t a_vec = __riscv_vmv_v_x_u8m1('a', vl);\n        vbool8_t mask = __riscv_vmslt_vv_u8m1_b8(sub_vec, a_vec, vl);\n        vuint8m1_t wrap_vec = __riscv_vadd_vx_u8m1_m(mask, sub_vec, sub_vec, 26, vl);\n        \n        // Store result back to output string\n        __riscv_vse8_v_u8m1((uint8_t*)(out.data() + i), wrap_vec, vl);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t l = s.length();\n    \n    // Process vector-length chunks\n    size_t vl;\n    for (size_t i = 0; i < l; i += vl) {\n        vl = __riscv_vsetvl_e8m1(l - i);\n        \n        // Load input characters\n        vint8_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vl);\n        \n        // Shift back by 5 and wrap around alphabet\n        vint8_t shifted_vec = __riscv_vsub_vx_i8m1(input_vec, 5, vl);\n        vint8_t wrapped_vec = __riscv_vrem_vx_i8m1(\n            __riscv_vsub_vx_i8m1(shifted_vec, 'a', vl), \n            26, \n            vl\n        );\n        vint8_t decoded_vec = __riscv_vadd_vx_i8m1(wrapped_vec, 'a', vl);\n        \n        // Store decoded characters\n        __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&out[i]), decoded_vec, vl);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(vec, t, vl);\n        \n        if (__riscv_vmand_mm_b32(mask, mask, vl) == 0) {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(vec, t, vl);\n        \n        if (__riscv_vmand_mm_b32(mask, mask, vl) == 0) {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(vec, t, vl);\n        \n        if (__riscv_vmand_mm_b32(mask, mask, vl) == 0) {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(vec, t, vl);\n        \n        if (__riscv_vmand_mm_b32(mask, mask, vl) == 0) {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(vec, t, vl);\n        \n        if (__riscv_vmand_mm_b32(mask, mask, vl) == 0) {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Configure vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Load input string into vector\n    vint8_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), vl);\n    \n    // Initialize running sum vector\n    vint32_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Accumulate bracket balance\n    for (size_t i = 0; i < n; i += vl) {\n        // Update vector length for remaining elements\n        vl = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load current chunk\n        v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str() + i), vl);\n        \n        // Create mask for '<' and '>'\n        vbool8_t v_less_mask = __riscv_vmseq_vx_i8m1_b8(v_brackets, '<', vl);\n        vbool8_t v_greater_mask = __riscv_vmseq_vx_i8m1_b8(v_brackets, '>', vl);\n        \n        // Increment/decrement based on bracket type\n        vint32_t v_less_inc = __riscv_vmerge_vxm_i32m1(v_sum, 1, v_less_mask, vl);\n        vint32_t v_greater_dec = __riscv_vmerge_vxm_i32m1(v_sum, -1, v_greater_mask, vl);\n        \n        // Update sum\n        v_sum = __riscv_vadd_vv_i32m1(v_less_inc, v_greater_dec, vl);\n        \n        // Check for negative sum (invalid bracketing)\n        vbool32_t v_negative_mask = __riscv_vmslt_vx_i32m1_b32(v_sum, 0, vl);\n        if (__riscv_vmfirst_m_b32(v_negative_mask, vl) != -1) {\n            return false;\n        }\n    }\n    \n    // Reduce final sum\n    int32_t final_sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    return final_sum == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Create vector from input string\n    vint8_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), vl);\n    \n    // Initialize running sum vector\n    vint32_t running_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32_t current_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Mask for '<' and '>' comparisons\n    vbool32_t open_mask = __riscv_vmsne_vx_i8m1_b32(v_brackets, '>', vl);\n    vbool32_t close_mask = __riscv_vmsne_vx_i8m1_b32(v_brackets, '<', vl);\n    \n    // Increment/decrement based on bracket type\n    vint32_t open_inc = __riscv_vmerge_vxm_i32m1(running_sum, 1, open_mask, vl);\n    vint32_t close_dec = __riscv_vmerge_vxm_i32m1(running_sum, -1, close_mask, vl);\n    \n    // Compute cumulative sum\n    current_sum = __riscv_vadd_vv_i32m1(open_inc, close_dec, vl);\n    \n    // Reduce to check if sum ever goes negative or doesn't end at zero\n    int32_t min_val = __riscv_vredmin_vs_i32m1_i32(current_sum, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    int32_t final_sum = __riscv_vmv_x_s_i32m1_i32(current_sum);\n    \n    return min_val >= 0 && final_sum == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Load input vector\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), vl);\n    \n    // Initialize running sum vector\n    vint32_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Mask for '<' and '>' comparisons\n    vbool32_t v_lt_mask = __riscv_vmsne_vx_i8m1_b32(v_input, '<', vl);\n    vbool32_t v_gt_mask = __riscv_vmsne_vx_i8m1_b32(v_input, '>', vl);\n    \n    // Increment/decrement based on bracket type\n    vint32_t v_lt_inc = __riscv_vmerge_vxm_i32m1(v_sum, 1, v_lt_mask, vl);\n    vint32_t v_gt_dec = __riscv_vmerge_vxm_i32m1(v_sum, -1, v_gt_mask, vl);\n    \n    // Compute running sum\n    v_sum = __riscv_vadd_vv_i32m1(v_lt_inc, v_gt_dec, vl);\n    \n    // Reduce sum\n    int32_t total_sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    return total_sum == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Create vector from input string\n    vint8_t v_brackets = __riscv_vle8_v_i8m1((const int8_t*)brackets.c_str(), vl);\n    \n    // Track bracket balance\n    int balance = 0;\n    vint8_t v_zero = __riscv_vmv_v_x_i8m1(0, vl);\n    vbool8_t v_lt_mask, v_gt_mask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Compare with '<'\n        v_lt_mask = __riscv_vmeq_vx_i8m1_b8(v_brackets, '<', vl);\n        balance += __riscv_vcpop_m_b8(v_lt_mask, vl);\n\n        // Compare with '>'\n        v_gt_mask = __riscv_vmeq_vx_i8m1_b8(v_brackets, '>', vl);\n        balance -= __riscv_vcpop_m_b8(v_gt_mask, vl);\n\n        // Check for negative balance\n        if (balance < 0) return false;\n\n        // Move to next vector chunk\n        v_brackets = __riscv_vle8_v_i8m1((const int8_t*)brackets.c_str() + i + vl, \n                                         __riscv_vsetvl_e8m1(n - i - vl));\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Load input vector\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), vl);\n    \n    // Initialize running sum vector\n    vint32_m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    vint32_m1_t v_zero = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Mask for '<' and '>' comparisons\n    vbool32_t v_lt_mask = __riscv_vmsne_vx_i8m1_b32(v_input, '<', vl);\n    vbool32_t v_gt_mask = __riscv_vmsne_vx_i8m1_b32(v_input, '>', vl);\n    \n    // Increment/decrement based on bracket type\n    vint32_m1_t v_lt_inc = __riscv_vmerge_vxm_i32m1(v_zero, 1, v_lt_mask, vl);\n    vint32_m1_t v_gt_dec = __riscv_vmerge_vxm_i32m1(v_zero, -1, v_gt_mask, vl);\n    \n    // Compute running sum\n    v_sum = __riscv_vadd_vv_i32m1(v_sum, v_lt_inc, vl);\n    v_sum = __riscv_vadd_vv_i32m1(v_sum, v_gt_dec, vl);\n    \n    // Reduce sum\n    int32_t total_sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    return total_sum == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create vector of input characters\n    vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), n);\n    \n    // Track open bracket count\n    int open_count = 0;\n    size_t vl = __riscv_vsetvl_e8m1(n);\n\n    for (size_t i = 0; i < n; i++) {\n        int8_t current = __riscv_vmv_s_x_i8m1(brackets[i]);\n        \n        if (current == '(') {\n            open_count++;\n        } else if (current == ')') {\n            if (open_count == 0) return false;\n            open_count--;\n        }\n    }\n\n    return open_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Get vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Convert string to char array\n    const char* data = brackets.c_str();\n    \n    // Initialize vector for tracking bracket balance\n    vint8m1_t balance = __riscv_vmv_v_x_i8m1(0, vl);\n    int current_balance = 0;\n\n    // Process vector chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load current chunk of brackets\n        vint8m1_t vec_brackets = __riscv_vle8_v_i8m1((const int8_t*)(data + i), vlmax);\n        \n        // Create mask for open and close brackets\n        vbool8_t open_mask = __riscv_vmseq_vx_i8m1_b8(vec_brackets, '(', vlmax);\n        vbool8_t close_mask = __riscv_vmseq_vx_i8m1_b8(vec_brackets, ')', vlmax);\n        \n        // Increment/decrement balance\n        vint8m1_t open_inc = __riscv_vmerge_vxm_i8m1(vec_brackets, 1, open_mask, vlmax);\n        vint8m1_t close_dec = __riscv_vmerge_vxm_i8m1(vec_brackets, -1, close_mask, vlmax);\n        \n        balance = __riscv_vadd_vv_i8m1(balance, open_inc, vlmax);\n        balance = __riscv_vadd_vv_i8m1(balance, close_dec, vlmax);\n        \n        // Reduce to check if balance goes negative\n        int min_balance = __riscv_vmv_x_s_i8m1_i8(\n            __riscv_vredmin_vs_i8m1_i8m1(balance, __riscv_vmv_v_x_i8m1(INT8_MAX, vlmax), vlmax)\n        );\n        \n        if (min_balance < 0) return false;\n    }\n    \n    // Final balance check\n    int final_balance = __riscv_vmv_x_s_i8m1_i8(\n        __riscv_vredsum_vs_i8m1_i8m1(balance, __riscv_vmv_v_x_i8m1(0, vl), vl)\n    );\n    \n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Get vector length\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    // Convert string to char array\n    const char* data = brackets.c_str();\n    \n    // Initialize vector registers\n    vint8m1_t bracket_vec = __riscv_vle8_v_i8m1((const int8_t*)data, vl);\n    \n    // Track bracket balance\n    int balance = 0;\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Update vector length for last chunk\n        vl = __riscv_vsetvl_e8m1(n - i);\n        \n        // Iterate through vector\n        for (size_t j = 0; j < vl; ++j) {\n            int8_t bracket = __riscv_vmv_x_s_i8m1_i8(\n                __riscv_vslidedown_vx_i8m1(bracket_vec, j, 1)\n            );\n            \n            if (bracket == '(') {\n                balance++;\n            } else if (bracket == ')') {\n                balance--;\n            }\n            \n            // Invalid if balance becomes negative\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    \n    // Valid if final balance is zero\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create vector of input characters\n    vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), n);\n    \n    // Track running balance of open/closed brackets\n    int balance = 0;\n    size_t i = 0;\n    \n    // Process vector in chunks\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    while (i < n) {\n        // Load current vector segment\n        vint8m1_t current = __riscv_vslide1down_vx_i8m1(vec, 0, vl);\n        \n        // Compare with open and close bracket\n        vbool8_t is_open = __riscv_vmseq_vx_i8m1_b8(current, '(', vl);\n        vbool8_t is_close = __riscv_vmseq_vx_i8m1_b8(current, ')', vl);\n        \n        // Update balance\n        int open_count = __riscv_vcpop_m_b8(is_open, vl);\n        int close_count = __riscv_vcpop_m_b8(is_close, vl);\n        \n        balance += open_count - close_count;\n        \n        // Early exit if balance becomes negative\n        if (balance < 0) return false;\n        \n        i += vl;\n        vec = __riscv_vslide1down_vx_i8m1(vec, 0, vl);\n        vl = __riscv_vsetvl_e8m1(n - i);\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Get vector length and create vector types\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    vint8m1_t v_brackets = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(brackets.c_str()), vl);\n    \n    // Initialize counters\n    int open_count = 0;\n    vint8m1_t v_open = __riscv_vmv_v_x_i8m1(0, vl);\n    vint8m1_t v_close = __riscv_vmv_v_x_i8m1(0, vl);\n\n    // Compare with '(' and ')'\n    vbool8_t v_is_open = __riscv_vmeq_vx_i8m1_b8(v_brackets, '(', vl);\n    vbool8_t v_is_close = __riscv_vmeq_vx_i8m1_b8(v_brackets, ')', vl);\n\n    // Count open and close brackets\n    v_open = __riscv_vcompress_vm_i8m1(v_brackets, v_is_open, vl);\n    v_close = __riscv_vcompress_vm_i8m1(v_brackets, v_is_close, vl);\n\n    // Reduce open and close counts\n    for (size_t i = 0; i < vl; ++i) {\n        if (__riscv_vmv_x_s_i8m1_i8(v_open) == '(') open_count++;\n        if (__riscv_vmv_x_s_i8m1_i8(v_close) == ')') open_count--;\n        \n        if (open_count < 0) return false;\n    }\n\n    return open_count == 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t n = xs.size() - 1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load input vector\n    vfloat32m1_t v_xs = __riscv_vle32_v_f32m1(xs.data() + 1, vl);\n    \n    // Multiply each coefficient by its power \n    vfloat32m1_t v_multipliers = __riscv_vfmul_vf_f32m1(v_xs, 1.0f, vl);\n    \n    // Store result\n    __riscv_vse32_v_f32m1(result.data(), v_multipliers, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t n = xs.size() - 1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load input vector\n    vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(xs.data() + 1, vl);\n    \n    // Multiply with indices (1, 2, 3, ...)\n    vfloat32m1_t indices_vec = __riscv_vfmul_vf_f32m1(input_vec, 1.0f, vl);\n    \n    // Store result\n    __riscv_vse32_v_f32m1(result.data(), indices_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t n = xs.size() - 1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load input vector\n    vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(xs.data() + 1, vl);\n\n    // Multiply each coefficient by its index \n    vfloat32m1_t indices_vec = __riscv_vfmul_vf_f32m1(input_vec, 1.0f, vl);\n    for (size_t i = 1; i < n; i++) {\n        indices_vec = __riscv_vfmul_vf_f32m1(input_vec, (float)i, vl);\n        __riscv_vse32_v_f32m1(result.data() + i - 1, indices_vec, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t n = result.size();\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load coefficients\n    for (size_t i = 0; i < n; i += vl) {\n        // Compute how many elements to process in this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load indices (1, 2, 3, ...)\n        vint32m1_t indices = __riscv_vid_v_i32m1(vl);\n        indices = __riscv_vadd_vx_i32m1(indices, 1, vl);\n\n        // Load corresponding coefficients\n        vfloat32m1_t coeffs = __riscv_vslide1up_vf_f32m1(__riscv_vle32_v_f32m1(&xs[i+1], vl), 0.0f, vl);\n\n        // Multiply indices with coefficients\n        vfloat32m1_t derivative = __riscv_vfmul_vv_f32m1(coeffs, __riscv_vfcvt_f_x_v_f32m1(indices, vl), vl);\n\n        // Store results\n        __riscv_vse32_v_f32m1(&result[i], derivative, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t n = result.size();\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load coefficients\n    for (size_t i = 0; i < n; i += vl) {\n        // Compute how many elements to process in this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load indices (1, 2, 3, ...)\n        vint32m1_t indices = __riscv_vid_v_i32m1(vl);\n        indices = __riscv_vadd_vx_i32m1(indices, 1, vl);\n\n        // Load corresponding coefficients\n        vfloat32m1_t coeffs = __riscv_vslide1up_vf_f32m1(__riscv_vle32_v_f32m1(&xs[i+1], vl), 0.0f, vl);\n\n        // Multiply indices with coefficients\n        vfloat32m1_t derivative = __riscv_vfmul_vv_f32m1(coeffs, __riscv_vfcvt_f_x_v_f32m1(indices, vl), vl);\n\n        // Store results\n        __riscv_vse32_v_f32m1(&result[i], derivative, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n\n    // Create vector length configuration\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load string into vector\n    vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.c_str()), vl);\n    \n    // Mask for vowel detection\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(vec, 'a', vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'e', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'i', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'o', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'u', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'A', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'E', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'I', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'O', vl), vl);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(vec, 'U', vl), vl);\n    \n    // Special case for 'y' at the end\n    if (s.back() == 'y' || s.back() == 'Y') {\n        vowel_mask = __riscv_vmset_m_b8(vowel_mask, len-1, vl);\n    }\n    \n    // Count vowels using mask\n    vuint8m1_t vowel_count = __riscv_vcpop_m_b8(vowel_mask, vl);\n    \n    return __riscv_vmv_x_s_u8m1_u8(vowel_count);\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n\n    // Create vector length and mask\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    vbool8_t mask;\n\n    // Load string into vector\n    vuint8_t vec = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.c_str()), vl);\n\n    // Check for vowels (lowercase and uppercase)\n    vuint8_t vowels_lower = __riscv_vmv_v_x_u8m1('a', vl);\n    vuint8_t vowels_upper = __riscv_vmv_v_x_u8m1('A', vl);\n\n    // Vowel comparison masks\n    vbool8_t is_a = __riscv_vmseq_vv_u8m1_b8(vec, vowels_lower, vl);\n    vbool8_t is_e = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_lower, 4, vl), vl);\n    vbool8_t is_i = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_lower, 8, vl), vl);\n    vbool8_t is_o = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_lower, 14, vl), vl);\n    vbool8_t is_u = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_lower, 20, vl), vl);\n    vbool8_t is_y_end = __riscv_vmseq_vx_u8m1_b8(vec, 'y', vl) & (len - 1 == 0);\n\n    vbool8_t is_A = __riscv_vmseq_vv_u8m1_b8(vec, vowels_upper, vl);\n    vbool8_t is_E = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_upper, 4, vl), vl);\n    vbool8_t is_I = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_upper, 8, vl), vl);\n    vbool8_t is_O = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_upper, 14, vl), vl);\n    vbool8_t is_U = __riscv_vmseq_vv_u8m1_b8(vec, __riscv_vadd_vx_u8m1(vowels_upper, 20, vl), vl);\n    vbool8_t is_Y_end = __riscv_vmseq_vx_u8m1_b8(vec, 'Y', vl) & (len - 1 == 0);\n\n    // Combine all vowel masks\n    vbool8_t is_vowel = is_a | is_e | is_i | is_o | is_u | is_y_end |\n                        is_A | is_E | is_I | is_O | is_U | is_Y_end;\n\n    // Count vowels\n    return __riscv_vcpop_m_b8(is_vowel, vl);\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Check if string is empty\n    if (len == 0) return 0;\n    \n    // Set up vector length and mask\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    vbool8_t mask;\n    \n    // Load string into vector\n    vuint8_t vec = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.c_str()), vl);\n    \n    // Create masks for vowels (lowercase and uppercase)\n    mask = __riscv_vmseq_vx_u8m1_b8(vec, 'a', vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'A', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'e', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'E', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'i', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'I', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'o', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'O', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'u', vl), vl);\n    mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, 'U', vl), vl);\n    \n    // Special case for 'y' at the end of the string\n    if (s.back() == 'y' || s.back() == 'Y') {\n        mask = __riscv_vmor_vv_b8(mask, __riscv_vmseq_vx_u8m1_b8(vec, s.back(), vl), vl);\n    }\n    \n    // Count vowels using mask\n    vuint8_t vowel_vec = __riscv_vcompress_vm_u8m1(vec, mask, vl);\n    vowel_count = __riscv_vcpop_m_b8(mask, vl);\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n\n    // Create vector of input characters\n    vint8m1_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.c_str()), len);\n\n    // Create mask for vowels\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(input_vec, 'a', len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'e', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'i', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'o', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'u', len), len);\n    \n    // Add case-insensitive check\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'A', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'E', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'I', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'O', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'U', len), len);\n\n    // Special case for 'y' at the end\n    if (s.back() == 'y' || s.back() == 'Y') {\n        vowel_mask = __riscv_vmset_m_b8(vowel_mask, len-1, 1, len);\n    }\n\n    // Count vowels using mask\n    return __riscv_vcpop_m_b8(vowel_mask, len);\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n\n    // Create vector of input characters\n    vint8m1_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.c_str()), len);\n\n    // Create mask for vowels\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(input_vec, 'a', len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'e', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'i', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'o', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'u', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'A', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'E', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'I', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'O', len), len);\n    vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(input_vec, 'U', len), len);\n\n    // Special case for 'y' at the end\n    if (s.back() == 'y' || s.back() == 'Y') {\n        vbool8_t last_char_mask = __riscv_vmseq_vx_i8m1_b8(input_vec, s.back(), len);\n        vowel_mask = __riscv_vmor_vvm_b8(vowel_mask, last_char_mask, len);\n    }\n\n    // Count vowels\n    return __riscv_vcpop_m_b8(vowel_mask, len);\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n\n    size_t n = s.length();\n    int result = 0;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load vector of characters\n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        // Create mask for uppercase characters\n        vbool8_t mask = __riscv_vmsgtu_vx_i8m1_b8(vec, 'A' - 1, vlmax);\n        mask = __riscv_vmsleu_vx_i8m1_b8(vec, 'Z', mask, vlmax);\n        \n        // Select uppercase characters\n        vint8m1_t uppercase = __riscv_vcompress_vm_i8m1(vec, mask, vlmax);\n        \n        // Convert to integer and sum\n        vint16m2_t sum_vec = __riscv_vwcvt_x_x_v_i16m2(uppercase, vlmax);\n        int partial_sum = __riscv_vmv_x_s_i16m2_i16(__riscv_vredsum_vs_i16m2_i16(sum_vec, __riscv_vmv_s_x_i16m2(0), vlmax));\n        \n        result += partial_sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n\n    size_t n = s.length();\n    int sum = 0;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        vbool8_t mask = __riscv_vmslt_vx_i8m1_b8(vec, 'A', vlmax);\n        mask = __riscv_vmand_mm_b8(mask, __riscv_vmslt_vx_i8m1_b8(vec, 'Z' + 1, vlmax), vlmax);\n        \n        vint16m2_t upper_chars = __riscv_vwmul_vx_i16m2(vec, 1, vlmax);\n        vint16m2_t masked_chars = __riscv_vmerge_vxm_i16m2(upper_chars, 0, __riscv_vmnot_m_b8(mask, vlmax), vlmax);\n        \n        int partial_sum = __riscv_vmv_x_s_i16m2_i16(__riscv_vredsum_vs_i16m2_i16(masked_chars, __riscv_vmv_s_x_i16m2(0), vlmax));\n        sum += partial_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n\n    size_t n = s.length();\n    int result = 0;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load the current vector of characters\n        vint8m1_t v_chars = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        // Create a mask for uppercase characters\n        vbool8_t v_mask = __riscv_vmsgtu8_vx_b8(v_chars, 'A' - 1, vlmax);\n        vbool8_t v_mask_upper = __riscv_vmsleu8_vx_b8(v_chars, 'Z', vlmax);\n        vbool8_t v_final_mask = __riscv_vmand_mm_b8(v_mask, v_mask_upper, vlmax);\n        \n        // Mask the characters and convert to int\n        vint16m2_t v_upper_chars = __riscv_vwmul_vx_i16m2(v_chars, 1, vlmax);\n        vint16m2_t v_masked_chars = __riscv_vmerge_vxm_i16m2(v_upper_chars, 0, __riscv_vnot_v_b8(v_final_mask, vlmax), vlmax);\n        \n        // Reduce sum\n        int sum_chunk = __riscv_vmv_x_s_i16m2_i16(__riscv_vredsum_vs_i16m2_i16(v_masked_chars, __riscv_vmv_s_x_i16m2(0), vlmax));\n        \n        result += sum_chunk;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n\n    size_t n = s.length();\n    int result = 0;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        vbool8_t mask = __riscv_vmslt_vx_i8m1_b8(vec, 'A', vlmax);\n        mask = __riscv_vmand_mm_b8(mask, __riscv_vmslt_vx_i8m1_b8(vec, '[', vlmax), vlmax);\n        \n        vint16m2_t upper_chars = __riscv_vwmul_vx_i16m2(vec, 1, vlmax);\n        upper_chars = __riscv_vmerge_vxm_i16m2(upper_chars, 0, mask, vlmax);\n        \n        int sum = __riscv_vmv_x_s_i16m2_i16(__riscv_vredsum_vs_i16m2_i16(upper_chars, __riscv_vmv_s_x_i16m2(0), vlmax));\n        \n        result += sum;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n\n    size_t n = s.length();\n    int sum = 0;\n    size_t vl = __riscv_vsetvlmax_e8m1();\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + i), vlmax);\n        \n        vbool8_t mask = __riscv_vmslt_vx_i8m1_b8(vec, 'A', vlmax);\n        mask = __riscv_vmand_mm_b8(mask, __riscv_vmslt_vx_i8m1_b8(vec, '[', vlmax), vlmax);\n        \n        vint16m2_t upper_chars = __riscv_vwmul_vx_i16m2(vec, 1, vlmax);\n        vint16m2_t masked_chars = __riscv_vmerge_vxm_i16m2(upper_chars, 0, mask, vlmax);\n        \n        int partial_sum = __riscv_vmv_x_s_i16m2_i16(__riscv_vredsum_vs_i16m2_i16m1(masked_chars, __riscv_vmv_s_x_i16m1(0), vlmax));\n        sum += partial_sum;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load input vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Create mask for even numbers\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(vec % 2, 0, vl);\n    \n    // If no even numbers, return empty\n    if (!__riscv_vmfirst_m_b32(even_mask, vl)) return {};\n    \n    // Masked select of even numbers\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(vec, even_mask, vl);\n    \n    // Find minimum even value\n    vint32m1_t min_even = __riscv_vredmin_vs_i32m1_i32m1(even_vec, __riscv_vmv_v_x_i32m1(INT_MAX, vl), vl);\n    int min_val = __riscv_vmv_x_s_i32m1_i32(min_even);\n    \n    // Find first index of minimum value\n    vbool32_t min_mask = __riscv_vmeq_vx_i32m1_b32(vec, min_val, vl);\n    size_t min_idx = __riscv_vmfirst_m_b32(min_mask, vl);\n    \n    return {min_val, static_cast<int>(min_idx)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load input vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n\n    // Create mask for even numbers\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(vec % 2, 0, vl);\n\n    // If no even numbers, return empty\n    if (__riscv_vcpop_m_b32(even_mask, vl) == 0) return {};\n\n    // Masked select of even numbers\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(vec, even_mask, vl);\n    \n    // Find minimum even value\n    vint32m1_t min_even = __riscv_vredmin_vs_i32m1_i32m1(even_vec, __riscv_vmv_s_x_i32m1(INT_MAX, vl), vl);\n    int min_val = __riscv_vmv_x_s_i32m1_i32(min_even);\n\n    // Create mask for minimum even value\n    vbool32_t min_mask = __riscv_vmseq_vx_i32m1_b32(vec, min_val, vl);\n    \n    // Find first index of minimum even value\n    size_t min_idx = __riscv_vfirst_m_b32(min_mask, vl);\n\n    return {min_val, static_cast<int>(min_idx)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load input vector\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n\n    // Create mask for even numbers\n    vbool32_t v_even_mask = __riscv_vmseq_vx_i32m1_b32(v_arr % 2, 0, vl);\n\n    // If no even numbers, return empty\n    if (__riscv_vcpop_m_b32(v_even_mask, vl) == 0) return {};\n\n    // Mask out odd numbers\n    vint32m1_t v_even_nums = __riscv_vcompress_vm_i32m1(v_arr, v_even_mask, vl);\n\n    // Find minimum even value\n    vint32m1_t v_min_even = __riscv_vredmin_vs_i32m1_i32m1(v_even_nums, __riscv_vmv_s_x_i32m1(INT_MAX, vl), vl);\n    int min_even = __riscv_vmv_x_s_i32m1_i32(v_min_even);\n\n    // Find first index of minimum even value\n    vbool32_t v_min_mask = __riscv_vmseq_vx_i32m1_b32(v_arr, min_even, vl);\n    size_t min_index = __riscv_vfirst_m_b32(v_min_mask, vl);\n\n    return {min_even, static_cast<int>(min_index)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load input vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Create mask for even numbers\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(vec % 2, 0, vl);\n    \n    // If no even numbers, return empty\n    if (__riscv_vcpop_m_b32(even_mask, vl) == 0) return {};\n    \n    // Mask out odd numbers\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(vec, even_mask, vl);\n    \n    // Find minimum even value and its index\n    size_t min_idx = 0;\n    int min_val = INT_MAX;\n    \n    for (size_t i = 0; i < __riscv_vcpop_m_b32(even_mask, vl); ++i) {\n        int curr_val = __riscv_vmv_x_s_i32m1_i32(even_vec);\n        if (curr_val < min_val) {\n            min_val = curr_val;\n            min_idx = i;\n        }\n        even_vec = __riscv_vslide1down_vx_i32m1(even_vec, 0, vl);\n    }\n    \n    // Find original index\n    size_t orig_idx = 0;\n    for (size_t i = 0; i < n; ++i) {\n        if (arr[i] == min_val) {\n            orig_idx = i;\n            break;\n        }\n    }\n    \n    return {min_val, static_cast<int>(orig_idx)};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load input array\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Create mask for even values\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(vec % 2, 0, vl);\n    \n    // If no even values, return empty\n    if (__riscv_vcpop_m_b32(even_mask, vl) == 0) return {};\n    \n    // Mask out odd values\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(vec, even_mask, vl);\n    \n    // Find minimum even value\n    vint32m1_t min_even = __riscv_vredmin_vs_i32m1_i32m1(even_vec, __riscv_vmv_s_x_i32m1(INT_MAX, vl), vl);\n    int smallest_even = __riscv_vmv_x_s_i32m1_i32(min_even);\n    \n    // Find first index of smallest even value\n    vbool32_t min_mask = __riscv_vmseq_vx_i32m1_b32(vec, smallest_even, vl);\n    size_t min_index = __riscv_vfirst_m_b32(min_mask, vl);\n    \n    return {smallest_even, static_cast<int>(min_index)};\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find max element to determine vector length\n    int max_val = *std::max_element(lst.begin(), lst.end());\n\n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Use RVV to count frequencies\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_input = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        v_input = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int val = __riscv_vmv_x_s_i32m1_i32(v_input);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n            v_input = __riscv_vslide1down_vx_i32m1(v_input, 0);\n        }\n    }\n\n    // Find the largest value satisfying the condition\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find maximum element to determine vector length\n    int max_val = *std::max_element(lst.begin(), lst.end());\n\n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Use RVV to count frequencies\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec_input = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec_input = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int val = __riscv_vmv_x_s_i32m1_i32(vec_input);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n            vec_input = __riscv_vslide1down_vx_i32m1(vec_input, 0);\n        }\n    }\n\n    // Find the greatest integer satisfying the condition\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    \n    // Count frequencies using RVV\n    std::vector<int> freq(n + 1, 0);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t curr_vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        for (size_t j = 0; j < vl && i + j < n; ++j) {\n            int val = __riscv_vmv_x_s_i32m1_i32(curr_vec);\n            freq[val]++;\n            curr_vec = __riscv_vslide1down_vx_i32m1(curr_vec, 0);\n        }\n    }\n    \n    // Find max value satisfying condition\n    int max_val = -1;\n    for (int i = 1; i <= n; ++i) {\n        if (freq[i] >= i) {\n            max_val = std::max(max_val, i);\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    \n    // Create frequency map using vector operations\n    std::vector<int> freq(n + 1, 0);\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vint32m1_t freq_vec = __riscv_vle32_v_i32m1(freq.data(), vl);\n    \n    // Count frequencies\n    for (int i = 0; i < n; i += vl) {\n        vint32m1_t curr_vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        for (int j = 0; j < vl; j++) {\n            int val = __riscv_vmv_x_s_i32m1_i32(curr_vec);\n            freq[val]++;\n            curr_vec = __riscv_vslide1down_vx_i32m1(curr_vec, 0);\n        }\n    }\n    \n    // Find maximum value satisfying condition\n    int max_val = -1;\n    for (int i = n; i > 0; i--) {\n        if (freq[i] >= i) {\n            max_val = i;\n            break;\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Find max element to determine vector length\n    int max_val = *std::max_element(lst.begin(), lst.end());\n\n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Use RVV for frequency counting\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        for (size_t j = 0; j < vl; ++j) {\n            int val = __riscv_vmv_x_s_i32m1_i32(vec);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n            vec = __riscv_vslide1down_vx_i32m1(vec, 0);\n        }\n    }\n\n    // Find max value satisfying condition\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check total weight\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    int sum = __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(vec, __riscv_vmv_s_x_i32m1(0, vl), vl));\n    if (sum > w) return false;\n\n    // Check palindrome (balanced)\n    for (size_t i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n\n    // Calculate total sum\n    vint32m1_t sum_vec = __riscv_vredsum_vs_i32m1_i32m1(vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    int total_sum = __riscv_vmv_x_s_i32m1_i32(sum_vec);\n\n    // Check weight constraint\n    if (total_sum > w) return false;\n\n    // Check palindrome (balanced)\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check total weight\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    int sum = __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(vec, __riscv_vmv_s_x_i32m1(0, vl), vl));\n    if (sum > w) return false;\n\n    // Check palindromic balance\n    for (size_t i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check total weight\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    int sum = __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(vec, __riscv_vmv_s_x_i32m1(0, vl), vl));\n    if (sum > w) return false;\n\n    // Check palindrome (balanced)\n    for (size_t i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) return false;\n\n    // Check total weight\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec = __riscv_vle32_v_i32m1(q.data(), vl);\n    int sum = __riscv_vmv_x_s(__riscv_vredsum_vs_i32m1_i32m1(vec, __riscv_vmv_s_x_i32m1(0, vl), vl));\n    if (sum > w) return false;\n\n    // Check palindrome (balanced)\n    for (size_t i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length and create vector configuration\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n    \n    // Create vector views for first and last half\n    vint32m1_t first_half, last_half;\n    \n    // Load first half of vector\n    first_half = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Load reversed last half of vector\n    vint32m1_t reversed_last_half = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n    reversed_last_half = __riscv_vrev8_v_i32m1(reversed_last_half);\n    \n    // Compare elements and count differences\n    vbool32_t diff_mask = __riscv_vxor_vv_i32m1_b32(first_half, reversed_last_half);\n    \n    // Count number of changes needed\n    changes = __riscv_vcpop_m_b32(diff_mask, vl);\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length and create vector configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load vector from input array\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Iterate through half the vector comparing symmetric elements\n    for (int i = 0; i < n / 2; i++) {\n        // Load symmetric elements from opposite ends\n        int left = arr[i];\n        int right = arr[n - 1 - i];\n        \n        // If elements are different, increment changes\n        if (left != right) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n    \n    // Create vector views for first and last halves\n    vint32m1_t first_half, last_half;\n    \n    // Load first half of vector\n    first_half = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Load reversed last half of vector\n    vint32m1_t reversed_last_half = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n    reversed_last_half = __riscv_vrev8_v_i32m1(reversed_last_half);\n    \n    // Compare elements and count differences\n    vbool32_t diff_mask = __riscv_vxor_vv_i32m1_b32(first_half, reversed_last_half, vl);\n    changes += __riscv_vcpop_m_b32(diff_mask, vl);\n    \n    // Handle odd-length vectors or remaining elements\n    for (int i = vl; i < n/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n    \n    // Create vector views for first and last halves\n    vint32m1_t first_half, last_half;\n    \n    // Load first half of vector\n    first_half = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Load reversed last half of vector\n    vint32m1_t reversed_last_half = __riscv_vle32_v_i32m1(arr.data() + n - vl, vl);\n    reversed_last_half = __riscv_vrev8_v_i32m1(reversed_last_half);\n    \n    // Compare elements and count differences\n    vbool32_t diff_mask = __riscv_vxor_vv_i32m1_b32(first_half, reversed_last_half, vl);\n    changes += __riscv_vcpop_m_b32(diff_mask, vl);\n    \n    // Handle odd-length vectors or remaining elements\n    for (int i = vl; i < n/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length and create vector configuration\n    size_t vl = __riscv_vsetvl_e32m1(n/2);\n    \n    // Pointer to first and last half of array\n    int* first_half = arr.data();\n    int* last_half = arr.data() + n - 1;\n    \n    // Load first half and last half in reverse order\n    vint32m1_t v_first = __riscv_vle32_v_i32m1(first_half, vl);\n    vint32m1_t v_last = __riscv_vle32_v_i32m1(last_half - vl + 1, vl);\n    \n    // Reverse last half vector\n    v_last = __riscv_vrev_v_i32m1(v_last);\n    \n    // Compare elements and count differences\n    vbool32_t v_mask = __riscv_vxor_vv_i32m1_b32(v_first, v_last);\n    vuint32m1_t v_changes = __riscv_vcpop_m_b32(v_mask, vl);\n    \n    changes = __riscv_vmv_x_s_u32m1_u32(v_changes);\n    \n    // Handle odd length arrays\n    if (n % 2 != 0) {\n        for (int i = vl; i < n/2; i++) {\n            if (arr[i] != arr[n-1-i]) {\n                changes++;\n            }\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either vector is empty, return the first vector\n    if (lst1.empty()) return lst2.empty() ? lst1 : lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total character count for each vector using vector instructions\n    size_t vl = __riscv_vsetvl_e64m1(lst1.size());\n    size_t total_chars1 = 0, total_chars2 = 0;\n\n    // Vector to store string lengths\n    vint64m1_t vec_lengths1 = __riscv_vmv_v_x_i64m1(0, vl);\n    vint64m1_t vec_lengths2 = __riscv_vmv_v_x_i64m1(0, vl);\n\n    // Compute lengths of strings in lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        vint64m1_t lengths = __riscv_vle64_v_i64m1(lst1[i].length(), vl);\n        vec_lengths1 = __riscv_vadd_vv_i64m1(vec_lengths1, lengths, vl);\n    }\n\n    // Compute lengths of strings in lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        vint64m1_t lengths = __riscv_vle64_v_i64m1(lst2[i].length(), vl);\n        vec_lengths2 = __riscv_vadd_vv_i64m1(vec_lengths2, lengths, vl);\n    }\n\n    // Reduce vector to scalar total character count\n    total_chars1 = __riscv_vmv_x_s_i64m1_i64(vec_lengths1);\n    total_chars2 = __riscv_vmv_x_s_i64m1_i64(vec_lengths2);\n\n    // Return vector with fewer total characters\n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either vector is empty, return the first vector\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total characters in each vector\n    size_t chars_lst1 = 0, chars_lst2 = 0;\n    \n    // Use RVV to parallelize character counting\n    size_t vl = __riscv_vsetvl_e64m1(lst1.size());\n    vint64m1_t char_count1 = __riscv_vmv_v_x_i64m1(0, vl);\n    vint64m1_t char_count2 = __riscv_vmv_v_x_i64m1(0, vl);\n\n    // Parallel character counting for lst1\n    for (size_t i = 0; i < lst1.size(); i += vl) {\n        vint64m1_t lengths = __riscv_vle64_v_i64m1(lst1[i].length() + char_count1, vl);\n        char_count1 = __riscv_vadd_vv_i64m1(char_count1, lengths, vl);\n    }\n    chars_lst1 = __riscv_vmv_x_s_i64m1_i64(char_count1);\n\n    // Parallel character counting for lst2\n    for (size_t i = 0; i < lst2.size(); i += vl) {\n        vint64m1_t lengths = __riscv_vle64_v_i64m1(lst2[i].length() + char_count2, vl);\n        char_count2 = __riscv_vadd_vv_i64m1(char_count2, lengths, vl);\n    }\n    chars_lst2 = __riscv_vmv_x_s_i64m1_i64(char_count2);\n\n    // Return vector with fewer total characters\n    return (chars_lst1 <= chars_lst2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either vector is empty, return the first vector\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total chars for first vector\n    size_t chars1 = 0;\n    for (const auto& str : lst1) {\n        chars1 += str.length();\n    }\n\n    // Calculate total chars for second vector\n    size_t chars2 = 0;\n    for (const auto& str : lst2) {\n        chars2 += str.length();\n    }\n\n    // Return vector with fewer total chars\n    return (chars1 <= chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either vector is empty, return the first vector\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total chars for first vector\n    size_t chars_count1 = 0;\n    for (const auto& str : lst1) {\n        chars_count1 += str.length();\n    }\n\n    // Calculate total chars for second vector\n    size_t chars_count2 = 0;\n    for (const auto& str : lst2) {\n        chars_count2 += str.length();\n    }\n\n    // Return vector with fewer total chars\n    return (chars_count1 <= chars_count2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either vector is empty, return the first vector\n    if (lst1.empty()) return lst2.empty() ? lst1 : lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total characters in lst1\n    size_t total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    size_t total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return the vector with fewer total characters\n    // If equal, return the first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```\n\nNote: While the problem statement requested RVV intrinsics, the specific implementation doesn't benefit significantly from vector parallelism due to the nature of the operation (string length calculation and comparison). The current implementation uses standard C++ sequential processing.\n\nA true RVV implementation would require more complex handling of string lengths and would depend on the specific RVV intrinsics available. The core logic of comparing total string lengths remains the same."}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 1) return false;\n    if (x == n) return true;\n\n    // Determine vector length\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    \n    // Initialize result vector\n    vbool64_t mask = __riscv_vmseq_vv_u64m1_b64(\n        __riscv_vmv_v_x_u64m1(1, vlen),\n        __riscv_vmv_v_x_u64m1(0, vlen),\n        vlen\n    );\n\n    // Compute powers of n\n    vuint64m1_t current_power = __riscv_vmv_v_x_u64m1(n, vlen);\n    \n    while (__riscv_vfirst_m_b64(mask, vlen) != -1) {\n        // Check if current power matches x\n        vbool64_t match_mask = __riscv_vmeq_vx_u64m1_b64(current_power, x, vlen);\n        mask = __riscv_vmand_mm_b64(mask, match_mask, vlen);\n\n        // If match found, return true\n        if (__riscv_vfirst_m_b64(mask, vlen) != -1) {\n            return true;\n        }\n\n        // Multiply current power by n\n        current_power = __riscv_vmul_vv_u64m1(current_power, \n                        __riscv_vmv_v_x_u64m1(n, vlen), vlen);\n\n        // Break if power exceeds x\n        vbool64_t exceed_mask = __riscv_vmgt_vx_u64m1_b64(current_power, x, vlen);\n        mask = __riscv_vmand_mm_b64(mask, __riscv_vmnot_m_b64(exceed_mask, vlen), vlen);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e64m1(1);\n\n    // Initialize power vector\n    vfloat64m1_t power_vec = __riscv_vfmv_v_f_f64m1(n, vl);\n    vfloat64m1_t result_vec = power_vec;\n\n    // Iterative power calculation using vector operations\n    for (int i = 1; i <= 64; ++i) {\n        result_vec = __riscv_vfmul_vv_f64m1(result_vec, power_vec, vl);\n        \n        // Check if current power matches x\n        if (__riscv_vfmv_f_s_f64m1_f64(result_vec) == x) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special cases\n    if (n <= 1 || x == 1) return false;\n    if (x == n) return true;\n\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    \n    // Initialize result vector\n    vbool64_t mask = __riscv_vmseq_vv_u64m1_b64(\n        __riscv_vmv_v_x_u64m1(1, vl), \n        __riscv_vmv_v_x_u64m1(0, vl), \n        vl\n    );\n\n    // Compute logarithm using repeated multiplication\n    uint64_t current = n;\n    uint64_t power = 1;\n    \n    while (current <= x) {\n        if (current == x) {\n            return true;\n        }\n        current *= n;\n        power++;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t vx = __riscv_vmv_s_x_i64m1(x, vl);\n    vint64m1_t vn = __riscv_vmv_s_x_i64m1(n, vl);\n    vint64m1_t result = vx;\n\n    while (__riscv_vmsgtu_vx_i64m1_b1(result, x, vl)) {\n        result = __riscv_vmul_vv_i64m1(result, vn, vl);\n    }\n\n    return __riscv_vmseq_vx_i64m1_b1(result, x, vl);\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    size_t vl = __riscv_vsetvl_e64m1(1);\n    vint64m1_t vx = __riscv_vmv_s_x_i64m1(x, vl);\n    vint64m1_t vn = __riscv_vmv_s_x_i64m1(n, vl);\n    vint64m1_t vresult = vx;\n\n    while (__riscv_vmsgtu_vx_u64m1_b(vresult, n, vl)) {\n        vresult = __riscv_vdiv_vv_i64m1(vresult, vn, vl);\n    }\n\n    return __riscv_vmseq_vx_u64m1_b(vresult, 1, vl);\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_hex_digits[] = {2, 3, 5, 7, 11, 13};\n    \n    size_t vl = __riscv_vsetvl_e8m1(num.length());\n    size_t prime_count = 0;\n\n    // Convert input string to vector of hex digit values\n    vuint8m1_t input_vec = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(num.c_str()), vl);\n\n    // Convert hex characters to numeric values\n    for (size_t i = 0; i < num.length(); i += vl) {\n        vuint8m1_t converted_vec = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(num.c_str() + i), vl);\n        \n        // Convert ASCII hex to numeric values\n        vuint8m1_t numeric_vec = __riscv_vsub_vx_u8m1(converted_vec, '0', vl);\n        vbool8_t mask_above_9 = __riscv_vmsgt_vx_u8m1_b8(numeric_vec, 9, vl);\n        \n        if (__riscv_vmfirst_m_b8(mask_above_9, vl) != -1) {\n            // Handle A-F conversion\n            vuint8m1_t adjusted_vec = __riscv_vmerge_vxm_u8m1(numeric_vec, \n                __riscv_vsub_vx_u8m1(converted_vec, 'A' - 10, vl), \n                mask_above_9, vl);\n            numeric_vec = adjusted_vec;\n        }\n\n        // Check for prime digits\n        for (int j = 0; j < sizeof(prime_hex_digits); ++j) {\n            vbool8_t prime_mask = __riscv_vmeq_vx_u8m1_b8(numeric_vec, prime_hex_digits[j], vl);\n            prime_count += __riscv_vcpop_m_b8(prime_mask, vl);\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_hex_digits[] = {2, 3, 5, 7, 11, 13};\n    \n    size_t vl = __riscv_vsetvl_e8m1(num.length());\n    size_t n = num.length();\n    \n    // Convert input string to vector of hex digit values\n    vuint8_t input_vec = __riscv_vle8_v(reinterpret_cast<const uint8_t*>(num.c_str()), vl);\n    \n    // Convert hex characters to numeric values\n    vbool8_t is_alpha_mask = __riscv_vmsltu8(input_vec, 'A');\n    vuint8_t digit_vec = __riscv_vmerge_vxm(input_vec, input_vec - 'A' + 10, is_alpha_mask, vl);\n    digit_vec = __riscv_vmerge_vxm(digit_vec, input_vec - '0', __riscv_vmsltu8(input_vec, 'A'), vl);\n    \n    // Create mask for prime hex digits\n    vbool8_t prime_mask = __riscv_vmseq_vv(digit_vec, __riscv_vle8_v(prime_hex_digits, 6), vl);\n    \n    // Count prime digits\n    return __riscv_vcpop_m(prime_mask, vl);\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const char primes[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e8m1(num.length());\n    \n    // Create vector of input string\n    vint8m1_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(num.c_str()), vl);\n    \n    // Initialize result vector\n    vint8m1_t result_vec = __riscv_vmv_v_x_i8m1(0, vl);\n    \n    // Iterate through prime digits\n    for (char prime : primes) {\n        // Compare input vector with current prime digit\n        vbool8_t mask = __riscv_vseq_vx_i8m1_b8(input_vec, prime, vl);\n        \n        // Add 1 where mask is true\n        vint8m1_t ones = __riscv_vmerge_vxm_i8m1(result_vec, 1, mask, vl);\n        result_vec = __riscv_vadd_vv_i8m1(result_vec, ones, vl);\n    }\n    \n    // Reduce vector sum\n    int count = __riscv_vmv_x_s_i8m1_i8(result_vec);\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_mask[] = {\n        0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0\n    };\n\n    int count = 0;\n    size_t n = num.length();\n    \n    // Use RVV vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load hex digits as unsigned chars\n        vuint8m1_t vec = __riscv_vle8_v_u8m1(\n            reinterpret_cast<const uint8_t*>(num.c_str() + i), \n            vl\n        );\n        \n        // Convert ASCII hex to numeric value\n        vuint8m1_t numeric_vec = __riscv_vsub_vx_u8m1(vec, '0', vl);\n        vuint8m1_t hex_vec = __riscv_vmin_vx_u8m1(numeric_vec, 15, vl);\n        \n        // Mask for hex digits above 9 (A-F)\n        vbool8_t above_9_mask = __riscv_vmslt_vx_u8m1_b8(numeric_vec, 10, vl);\n        vuint8m1_t hex_adjust = __riscv_vmerge_vxm_u8m1(\n            hex_vec, \n            __riscv_vsub_vx_u8m1(hex_vec, 7, vl), \n            above_9_mask, \n            vl\n        );\n        \n        // Create mask for prime hex digits\n        vuint8m1_t prime_vec = __riscv_vle8_v_u8m1(prime_mask, vl);\n        vbool8_t prime_mask_bool = __riscv_vmseq_vv_u8m1_b8(\n            __riscv_vrgather_vv_u8m1(prime_vec, hex_adjust, vl), \n            __riscv_vmv_v_x_u8m1(1, vl), \n            vl\n        );\n        \n        // Count prime digits in this vector\n        count += __riscv_vcpop_m_b8(prime_mask_bool, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const char primes[] = {'2', '3', '5', '7', 'B', 'D'};\n    \n    // Get vector length\n    size_t vl = __riscv_vsetvl_e8m1(num.length());\n    \n    // Create vector of input characters\n    vint8m1_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(num.c_str()), vl);\n    \n    // Create mask for prime digits\n    vbool8_t prime_mask = __riscv_vmseq_vv_i8m1_b8(input_vec, __riscv_vle8_v_i8m1(primes, 6), 6);\n    \n    // Count prime digits\n    vuint8m1_t result_vec = __riscv_vcpop_m_b8(prime_mask, vl);\n    \n    return __riscv_vmv_x_s_u8m1_u8(result_vec);\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t vl = __riscv_vsetvl_e8m1(s.length());\n    size_t n_chunks = (s.length() + vl - 1) / vl;\n\n    for (size_t chunk = 0; chunk < n_chunks; chunk++) {\n        size_t start = chunk * vl;\n        size_t end = std::min(start + vl, s.length());\n        size_t len = end - start;\n\n        if (len < 3) break;\n\n        vint8m1_t vec1 = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data() + start), len);\n        vint8m1_t vec2 = __riscv_vslidedown_vx_i8m1(vec1, 1, len - 1);\n        vint8m1_t vec3 = __riscv_vslidedown_vx_i8m1(vec1, 2, len - 2);\n\n        vbool8_t distinct_mask1 = __riscv_vxor_vv_i8m1_b8(vec1, vec2, len - 1);\n        vbool8_t distinct_mask2 = __riscv_vxor_vv_i8m1_b8(vec1, vec3, len - 2);\n        vbool8_t distinct_mask3 = __riscv_vxor_vv_i8m1_b8(vec2, vec3, len - 2);\n\n        if (__riscv_vmand_mm_b8(distinct_mask1, distinct_mask2, len - 2) == 0 ||\n            __riscv_vmand_mm_b8(distinct_mask1, distinct_mask3, len - 2) == 0 ||\n            __riscv_vmand_mm_b8(distinct_mask2, distinct_mask3, len - 2) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t n = s.length();\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    vuint8m1_t vec = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data()), vl);\n    \n    for (size_t i = 0; i + 2 < n; i++) {\n        vuint8m1_t first = __riscv_vslide1down_vx_u8m1(vec, s[i], vl);\n        vuint8m1_t second = __riscv_vslide1down_vx_u8m1(first, s[i+1], vl);\n        \n        vbool8_t first_eq = __riscv_vmseq_vv_u8m1_b8(vec, first, vl);\n        vbool8_t second_eq = __riscv_vmseq_vv_u8m1_b8(vec, second, vl);\n        \n        if (__riscv_vmfirst_m_b8(first_eq, vl) != -1 || \n            __riscv_vmfirst_m_b8(second_eq, vl) != -1) {\n            return false;\n        }\n        \n        vec = first;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t n = s.length();\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    vuint8m1_t vec = __riscv_vle8_v_u8m1(reinterpret_cast<const uint8_t*>(s.data()), vl);\n    \n    for (size_t i = 0; i + 2 < n; i++) {\n        vuint8m1_t window = __riscv_vslidedown_vx_u8m1(vec, i, vl);\n        \n        vuint8m1_t first = __riscv_vrgather_vx_u8m1(window, 0, vl);\n        vuint8m1_t second = __riscv_vrgather_vx_u8m1(window, 1, vl);\n        vuint8m1_t third = __riscv_vrgather_vx_u8m1(window, 2, vl);\n        \n        vbool8_t first_eq_second = __riscv_vmseq_vv_u8m1_b8(first, second, vl);\n        vbool8_t first_eq_third = __riscv_vmseq_vv_u8m1_b8(first, third, vl);\n        vbool8_t second_eq_third = __riscv_vmseq_vv_u8m1_b8(second, third, vl);\n        \n        if (__riscv_vmfirst_m_b8(first_eq_second, vl) != -1 ||\n            __riscv_vmfirst_m_b8(first_eq_third, vl) != -1 ||\n            __riscv_vmfirst_m_b8(second_eq_third, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t n = s.length();\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n    \n    for (size_t i = 0; i + 2 < n; i++) {\n        vint8m1_t first = __riscv_vslide1down_vx_i8m1(vec, s[i], vl);\n        vint8m1_t second = __riscv_vslide1down_vx_i8m1(first, s[i+1], vl);\n        \n        vbool8_t first_eq = __riscv_vmseq_vv_i8m1_b8(vec, first, vl);\n        vbool8_t second_eq = __riscv_vmseq_vv_i8m1_b8(first, second, vl);\n        \n        if (__riscv_vmfirst_m_b8(first_eq, vl) != -1 || \n            __riscv_vmfirst_m_b8(second_eq, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    size_t n = s.length();\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    vint8m1_t vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n    \n    for (size_t i = 0; i + 2 < n; i++) {\n        vint8m1_t first = __riscv_vslide1down_vx_i8m1(vec, s[i], vl);\n        vint8m1_t second = __riscv_vslide1down_vx_i8m1(first, s[i+1], vl);\n        \n        vbool8_t first_eq = __riscv_vmeq_vv_i8m1_b8(vec, first, vl);\n        vbool8_t second_eq = __riscv_vmeq_vv_i8m1_b8(first, second, vl);\n        \n        if (__riscv_vmand_mm_b8(first_eq, second_eq, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Handle small lengths directly\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    \n    // Determine vector length and configure\n    size_t vl = __riscv_vsetvl_e32m1(len);\n    \n    // Iterate up to sqrt(len)\n    for (size_t i = 3; i * i <= len; i += 2) {\n        // Vector comparison\n        vint32m1_t vec_i = __riscv_vmv_v_x_i32m1(i, vl);\n        vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(vec_i, __riscv_vmv_v_x_i32m1(0, vl), vl);\n        \n        // Check divisibility\n        if (len % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    // Vector-based primality check\n    size_t vl = __riscv_vsetvl_e32m1(len);\n    size_t max_iter = (size_t)sqrt(len);\n    \n    for (size_t divisor = 3; divisor <= max_iter; divisor += 2) {\n        vint32m1_t vec_divisor = __riscv_vmv_v_x_i32m1(divisor, vl);\n        vint32m1_t vec_remainder = __riscv_vrem_vv_i32m1(\n            __riscv_vmv_v_x_i32m1(len, vl), \n            vec_divisor, \n            vl\n        );\n        \n        if (__riscv_vmseq_vx_b1_b8(vec_remainder, 0, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    \n    // Vector-based primality check\n    size_t vl = __riscv_vsetvl_e32m1(len);\n    size_t max_iter = (size_t)sqrt(len);\n    \n    for (size_t divisor = 3; divisor <= max_iter; divisor += 2) {\n        vint32m1_t vec_divisor = __riscv_vmv_v_x_i32m1(divisor, vl);\n        vint32m1_t vec_remainder = __riscv_vrem_vv_i32m1(\n            __riscv_vmv_v_x_i32m1(len, vl), \n            vec_divisor, \n            vl\n        );\n        \n        if (__riscv_vmseq_vx_b8_b1(vec_remainder, 0, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n    \n    // Vector-based primality check\n    size_t vl = __riscv_vsetvl_e64m1(len);\n    vbool64_t mask = __riscv_vmseq_vx_u64m1_b64(\n        __riscv_vrem_vx_u64m1(__riscv_vmv_v_x_u64m1(len, vl), \n                               __riscv_vmv_v_x_u64m1(2, vl), vl), \n        __riscv_vmv_v_x_u64m1(0, vl), vl);\n    \n    // Check divisibility up to sqrt(len)\n    for (size_t i = 3; i * i <= len; i += 2) {\n        vbool64_t div_mask = __riscv_vmseq_vx_u64m1_b64(\n            __riscv_vrem_vx_u64m1(__riscv_vmv_v_x_u64m1(len, vl), \n                                   __riscv_vmv_v_x_u64m1(i, vl), vl), \n            __riscv_vmv_v_x_u64m1(0, vl), vl);\n        \n        mask = __riscv_vmor_vv_b64(mask, div_mask, vl);\n    }\n    \n    return !__riscv_vmfirst_m_b64(mask, vl);\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    // Determine vector length and create vector of divisors\n    size_t vl = __riscv_vsetvl_e32m1(len);\n    vint32m1_t divisors = __riscv_vid_v_i32m1(vl);\n    divisors = __riscv_vadd_vx_i32m1(divisors, 3, vl);\n\n    // Mask for odd divisors\n    vbool32_t mask = __riscv_vmsne_vx_i32m1_b32(divisors, 0, vl);\n\n    // Vectorized primality check\n    for (size_t i = 3; i * i <= len; i += 2) {\n        vint32m1_t current_divisors = __riscv_vmul_vx_i32m1(divisors, i, vl);\n        vbool32_t divisible_mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(len * __riscv_vreinterpret_v_i32m1_u32m1(divisors), i, vl),\n            0, vl\n        );\n        mask = __riscv_vmand_mm_b32(mask, __riscv_vmnot_m_b32(divisible_mask, vl), vl);\n\n        if (!__riscv_vmfirst_m_b32(mask, vl)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // If N is 0, return \"0\"\n    if (N == 0) return \"0\";\n\n    // Vector to store individual digits\n    std::vector<int> digits;\n\n    // Extract digits\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n\n    // Get vector length\n    size_t vl = digits.size();\n    \n    // Create vector for digits\n    vint32m1_t v_digits = __riscv_vle32_v_i32m1(digits.data(), vl);\n    \n    // Compute sum of digits using vector reduction\n    int32_t sum = __riscv_vredsum_vs_i32m1_i32(v_digits, 0, vl);\n\n    // Convert sum to binary string\n    std::string binary;\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // If N is 0, return \"0\"\n    if (N == 0) return \"0\";\n\n    // Vector to store individual digits\n    std::vector<int> digits;\n    \n    // Extract digits\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n\n    // Get vector length\n    size_t vl = digits.size();\n    \n    // Create vector for digits\n    vint32m1_t v_digits = __riscv_vle32_v_i32m1(digits.data(), vl);\n    \n    // Create vector for accumulation\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Parallel sum of digits\n    v_sum = __riscv_vredsum_vs_i32m1_i32m1(v_digits, v_sum, vl);\n    \n    // Extract total sum\n    int total_sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum % 2) + binary;\n        total_sum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // If N is 0, return \"0\"\n    if (N == 0) return \"0\";\n\n    // Vector to store individual digits\n    std::vector<int> digits;\n    \n    // Extract digits\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n\n    // Get vector length\n    size_t vl = digits.size();\n    \n    // Create vector for processing\n    vint32m1_t v_digits = __riscv_vlse32_v_i32m1(digits.data(), sizeof(int), vl, vl);\n    \n    // Vector to accumulate digit sum\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Compute sum of digits using vector reduction\n    v_sum = __riscv_vredsum_vs_i32m1_i32m1(v_digits, v_sum, vl);\n    \n    // Extract total sum\n    int total_sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum % 2) + binary;\n        total_sum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // If N is 0, return \"0\"\n    if (N == 0) return \"0\";\n\n    // Vector to store individual digits\n    std::vector<int> digits;\n    \n    // Extract digits\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n\n    // Get vector length\n    size_t vl = digits.size();\n    \n    // Create vector for digits\n    vint32m1_t v_digits = __riscv_vle32_v_i32m1(digits.data(), vl);\n    \n    // Vector to accumulate digit sum\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Compute sum of digits using vector reduction\n    v_sum = __riscv_vredsum_vs_i32m1_i32m1(v_digits, v_sum, vl);\n    \n    // Extract total sum\n    int total_sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum % 2) + binary;\n        total_sum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // If N is 0, return \"0\"\n    if (N == 0) return \"0\";\n\n    // Vector to store individual digits\n    std::vector<int> digits;\n    \n    // Extract digits\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n\n    // Get vector length and configure vector length\n    size_t vl = __riscv_vsetvl_e32m1(digits.size());\n    \n    // Create vector for digits\n    vint32m1_t v_digits = __riscv_vle32_v_i32m1(digits.data(), vl);\n    \n    // Compute popcount (number of 1 bits) for each digit\n    vint32m1_t v_popcounts = __riscv_vcpop_v_i32m1(v_digits, vl);\n    \n    // Reduce sum of popcounts\n    int total_sum = __riscv_vredsum_vs_i32m1_i32(v_popcounts, 0, vl);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum % 2) + binary;\n        total_sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int result = 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask for odd indices\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        1, \n        vl\n    );\n    \n    // Load vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Mask select elements at odd indices\n    vint32m1_t odd_indices_vec = __riscv_vcompress_vm_i32m1(vec, mask, vl);\n    \n    // Mask for even elements\n    vbool32_t even_mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vand_vx_i32m1(odd_indices_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress even elements\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(odd_indices_vec, even_mask, vl);\n    \n    // Reduce sum\n    result = __riscv_vredsum_vs_i32m1_i32m1(even_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int result = 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask for odd indices\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        1, \n        vl\n    );\n    \n    // Load vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Mask select elements at odd indices\n    vint32m1_t odd_indices_vec = __riscv_vcompress_vm_i32m1(vec, mask, vl);\n    \n    // Mask select even elements\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(\n        __riscv_vand_vx_i32m1(odd_indices_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress even elements\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(odd_indices_vec, even_mask, vl);\n    \n    // Reduce sum\n    result = __riscv_vredsum_vs_i32m1_i32m1(even_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t n = lst.size();\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask for odd indices\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        1, \n        vl\n    );\n    \n    // Load vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Mask select elements at odd indices\n    vint32m1_t odd_indices_vec = __riscv_vcompress_v_i32m1_m(mask, vec, vec, vl);\n    \n    // Keep only even elements\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(\n        __riscv_vand_vx_i32m1(odd_indices_vec, 1, vl), \n        0, \n        vl\n    );\n    vint32m1_t even_vec = __riscv_vcompress_v_i32m1_m(even_mask, odd_indices_vec, odd_indices_vec, vl);\n    \n    // Sum even elements\n    result = __riscv_vmv_x_s_i32m1_i32(\n        __riscv_vredsum_vs_i32m1_i32m1(even_vec, __riscv_vmv_s_x_i32m1(0), vl)\n    );\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int result = 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask for odd indices\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        1, \n        vl\n    );\n    \n    // Load vector\n    vint32_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Mask select elements at odd indices\n    vint32_t odd_indices_vec = __riscv_vcompress_v_i32m1_m(mask, vec, vec, vl);\n    \n    // Mask select even elements\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(\n        __riscv_vand_vx_i32m1(odd_indices_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress even elements\n    vint32_t even_vec = __riscv_vcompress_v_i32m1_m(even_mask, odd_indices_vec, odd_indices_vec, vl);\n    \n    // Reduce sum\n    result = __riscv_vredsum_vs_i32m1_i32m1(even_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    int result = 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask for odd indices\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        1, \n        vl\n    );\n    \n    // Load vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Mask select elements at odd indices\n    vint32m1_t odd_indices_vec = __riscv_vcompress_vm_i32m1(vec, mask, vec, vl);\n    \n    // Mask select even elements\n    vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(\n        __riscv_vand_vx_i32m1(odd_indices_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress even elements\n    vint32m1_t even_vec = __riscv_vcompress_vm_i32m1(odd_indices_vec, even_mask, odd_indices_vec, vl);\n    \n    // Reduce sum\n    result = __riscv_vredsum_vs_i32m1_i32m1(even_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return \"\";\n\n    // Create output string of same length\n    std::string result(len, ' ');\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load input string\n    vint8_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n\n    // Perform encryption by adding 4 (2 * 2) to each character\n    vint8_t encrypted_vec = __riscv_vadd_vx_i8m1(input_vec, 4, vl);\n\n    // Store result back to output string\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), encrypted_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return \"\";\n\n    std::string result(len, ' ');\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load input string\n    vint8_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n    \n    // Perform encryption by adding 4 to each character\n    vint8_t encrypted_vec = __riscv_vadd_vx_i8m1(input_vec, 4, vl);\n    \n    // Store result back to string\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), encrypted_vec, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return \"\";\n\n    // Create output string of same length\n    std::string result(len, ' ');\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load input string into vector\n    vint8_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n\n    // Perform encryption by adding 4 to each character\n    vint8_t encrypted_vec = __riscv_vadd_vx_i8m1(input_vec, 4, vl);\n\n    // Store encrypted vector back to result string\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), encrypted_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return \"\";\n\n    // Create output string of same length\n    std::string result(len, ' ');\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load input string\n    vint8_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n\n    // Perform encryption by adding 4 (2 * 2) to each character\n    vint8_t encrypted_vec = __riscv_vadd_vx_i8m1(input_vec, 4, vl);\n\n    // Store result back to output string\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), encrypted_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) return \"\";\n\n    // Create output string of same length\n    std::string result(len, ' ');\n\n    // Set vector length \n    size_t vl = __riscv_vsetvl_e8m1(len);\n\n    // Load input string into vector\n    vint8_t input_vec = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(s.data()), vl);\n\n    // Perform encryption by adding 4 to each character\n    vint8_t encrypted_vec = __riscv_vadd_vx_i8m1(input_vec, 4, vl);\n\n    // Store encrypted vector back to result string\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), encrypted_vec, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load input message\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(message.c_str()), vl);\n    \n    // Process vector\n    vint8_t v_result = __riscv_vnot_v_i8m1(v_input, vl);  // Swap case\n    \n    // Vowel replacement logic\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(v_result, 'a', vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'e', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'i', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'o', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'u', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'A', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'E', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'I', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'O', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'U', vl), vl);\n    \n    vint8_t v_vowel_replace = __riscv_vadd_vx_i8m1_m(vowel_mask, v_result, v_result, 2, vl);\n    \n    // Store result\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), v_vowel_replace, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load input message\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(message.c_str()), vl);\n    \n    // Process vector\n    vint8_t v_result = __riscv_vnot_v_i8m1(v_input, vl);  // Swap case\n    \n    // Vowel replacement logic\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(v_result, 'a', vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'e', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'i', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'o', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'u', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'A', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'E', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'I', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'O', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'U', vl), vl);\n    \n    vint8_t v_vowel_replace = __riscv_vadd_vx_i8m1_m(vowel_mask, v_result, v_result, 2, vl);\n    \n    // Store result\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), v_vowel_replace, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load input message\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(message.data()), vl);\n    \n    // Process vector\n    vint8_t v_result = __riscv_vnot_v_i8m1(v_input, vl);  // Swap case\n    \n    // Vowel replacement logic\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(v_result, 'a', vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'e', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'i', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'o', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'u', vl), vl);\n    \n    vint8_t vowel_replace = __riscv_vadd_vx_i8m1_m(vowel_mask, v_result, v_result, 2, vl);\n    \n    // Store result\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), vowel_replace, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load input message\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(message.c_str()), vl);\n    \n    // Process vector\n    vint8_t v_result = __riscv_vnot_v_i8m1(v_input, vl);  // Swap case\n    \n    // Vowel replacement logic\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(v_result, 'a', vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'e', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'i', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'o', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'u', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'A', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'E', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'I', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'O', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'U', vl), vl);\n    \n    vint8_t v_vowel_replace = __riscv_vadd_vx_i8m1_m(vowel_mask, v_result, v_result, 2, vl);\n    \n    // Store result\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), v_vowel_replace, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    size_t len = message.length();\n    std::string result(len, ' ');\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    \n    // Load input string\n    vint8_t v_input = __riscv_vle8_v_i8m1(reinterpret_cast<const int8_t*>(message.c_str()), vl);\n    \n    // Process vector\n    vint8_t v_result = __riscv_vnot_v_i8m1(v_input, vl);  // Swap case\n    \n    // Vowel replacement logic\n    vbool8_t vowel_mask = __riscv_vmseq_vx_i8m1_b8(v_result, 'a', vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'e', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'i', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'o', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'u', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'A', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'E', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'I', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'O', vl), vl);\n    vowel_mask = __riscv_vor_vx_b8(vowel_mask, __riscv_vmseq_vx_i8m1_b8(v_result, 'U', vl), vl);\n    \n    vint8_t vowel_replace = __riscv_vadd_vx_i8m1_m(vowel_mask, v_result, v_result, 2, vl);\n    \n    // Store result\n    __riscv_vse8_v_i8m1(reinterpret_cast<int8_t*>(&result[0]), vowel_replace, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    size_t vl = __riscv_vsetvl_e8m1(size);\n\n    // Prepare vectors for tracking case\n    vbool8_t is_lower_vec = __riscv_vmv_v_x_b8(1, vl);\n    vbool8_t is_upper_vec = __riscv_vmv_v_x_b8(1, vl);\n\n    size_t i = 0;\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Check if key is non-alphabetic\n        vbool8_t is_alpha_vec = __riscv_vmv_v_x_b8(1, vl);\n        for (char c : key) {\n            is_alpha_vec = __riscv_vand_vx_b8(\n                is_alpha_vec, \n                (std::isalpha(c) != 0), \n                vl\n            );\n        }\n\n        // Check lowercase\n        vbool8_t curr_lower_vec = __riscv_vmv_v_x_b8(1, vl);\n        for (char c : key) {\n            curr_lower_vec = __riscv_vand_vx_b8(\n                curr_lower_vec, \n                (std::islower(c) != 0), \n                vl\n            );\n        }\n\n        // Check uppercase\n        vbool8_t curr_upper_vec = __riscv_vmv_v_x_b8(1, vl);\n        for (char c : key) {\n            curr_upper_vec = __riscv_vand_vx_b8(\n                curr_upper_vec, \n                (std::isupper(c) != 0), \n                vl\n            );\n        }\n\n        // Update case tracking vectors\n        is_lower_vec = __riscv_vand_vx_b8(\n            is_lower_vec, \n            (curr_lower_vec && is_alpha_vec), \n            vl\n        );\n        is_upper_vec = __riscv_vand_vx_b8(\n            is_upper_vec, \n            (curr_upper_vec && is_alpha_vec), \n            vl\n        );\n\n        i++;\n        if (i >= vl) break;\n    }\n\n    // Final check\n    return __riscv_vmand_mm_b8(is_lower_vec, is_upper_vec, vl) == 0;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    size_t vl = __riscv_vsetvl_e8m1(size);\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        vl = __riscv_vsetvl_e8m1(key.length());\n        vuint8m1_t v_key = __riscv_vle8_v_u8m1((const uint8_t*)key.c_str(), vl);\n\n        vuint8m1_t v_lower = __riscv_vand_vx_u8m1(v_key, 0x20, vl);\n        vuint8m1_t v_upper = __riscv_vand_vx_u8m1(v_key, 0x20, vl);\n\n        vuint8m1_t v_alpha = __riscv_vand_vx_u8m1(v_key, 0xC0, vl);\n        vuint8m1_t v_alpha_mask = __riscv_vmseq_vx_u8m1_b8(v_alpha, 0x40, vl);\n\n        vuint8m1_t v_lower_mask = __riscv_vmseq_vx_u8m1_b8(v_lower, 0x20, vl);\n        vuint8m1_t v_upper_mask = __riscv_vmseq_vx_u8m1_b8(v_upper, 0x00, vl);\n\n        bool is_alpha = __riscv_vmand_mm_b8(v_alpha_mask, v_alpha_mask, vl);\n        bool is_lower = __riscv_vmand_mm_b8(v_lower_mask, v_alpha_mask, vl);\n        bool is_upper = __riscv_vmand_mm_b8(v_upper_mask, v_alpha_mask, vl);\n\n        all_lower &= is_lower;\n        all_upper &= is_upper;\n\n        if (!is_alpha) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    size_t vl = __riscv_vsetvl_e8m1(size);\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Create vector of key characters\n        vint8m1_t v_key = __riscv_vlse8_v_i8m1((int8_t*)key.c_str(), 1, vl);\n\n        // Check lowercase\n        vbool8_t v_lower_mask = __riscv_vmsltu8_vx_u8m1_b8(v_key, 'a', vl);\n        vbool8_t v_lower_mask2 = __riscv_vmsgt8_vx_u8m1_b8(v_key, 'z', vl);\n        vbool8_t v_lower_combined = __riscv_vmor_mm_b8(v_lower_mask, v_lower_mask2, vl);\n        \n        if (__riscv_vmfirst_m_b8(v_lower_combined, vl) != -1) {\n            all_lower = false;\n        }\n\n        // Check uppercase\n        vbool8_t v_upper_mask = __riscv_vmsltu8_vx_u8m1_b8(v_key, 'A', vl);\n        vbool8_t v_upper_mask2 = __riscv_vmsgt8_vx_u8m1_b8(v_key, 'Z', vl);\n        vbool8_t v_upper_combined = __riscv_vmor_mm_b8(v_upper_mask, v_upper_mask2, vl);\n        \n        if (__riscv_vmfirst_m_b8(v_upper_combined, vl) != -1) {\n            all_upper = false;\n        }\n\n        // Early exit if not all lower or upper\n        if (!all_lower && !all_upper) return false;\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    size_t vl = __riscv_vsetvl_e8m1(size);\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Create vector of key characters\n        vint8m1_t v_key = __riscv_vlm_v_i8m1((int8_t*)key.c_str(), vl);\n        \n        // Check lowercase\n        vbool8_t v_is_lower = __riscv_vmsltu_vx_u8m1_b8(v_key, 'a', vl);\n        vbool8_t v_is_upper = __riscv_vmsltu_vx_u8m1_b8(v_key, 'A', vl);\n        \n        all_lower &= __riscv_vmand_mm_b8(v_is_lower, v_is_upper, vl);\n        all_upper &= __riscv_vmand_mm_b8(v_is_upper, v_is_lower, vl);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    size_t size = dict.size();\n    size_t vl = __riscv_vsetvl_e8m1(size);\n\n    // Allocate vectors for tracking case\n    vbool8_t is_lower_v = __riscv_vmv_v_x_b8(1, vl);\n    vbool8_t is_upper_v = __riscv_vmv_v_x_b8(1, vl);\n\n    size_t i = 0;\n    for (const auto& [key, _] : dict) {\n        // Check if all characters are lowercase\n        vbool8_t lower_check_v = __riscv_vmv_v_x_b8(1, vl);\n        for (char c : key) {\n            vbool8_t curr_lower_v = __riscv_vmsle_vx_b8_b8(\n                __riscv_vle8_v_i8m1((int8_t*)&c, vl), \n                'z', vl\n            );\n            vbool8_t curr_lower_start_v = __riscv_vmsge_vx_b8_b8(\n                __riscv_vle8_v_i8m1((int8_t*)&c, vl), \n                'a', vl\n            );\n            lower_check_v = __riscv_vmand_mm_b8(curr_lower_v, curr_lower_start_v, vl);\n        }\n        is_lower_v = __riscv_vmand_mm_b8(is_lower_v, lower_check_v, vl);\n\n        // Check if all characters are uppercase\n        vbool8_t upper_check_v = __riscv_vmv_v_x_b8(1, vl);\n        for (char c : key) {\n            vbool8_t curr_upper_v = __riscv_vmsle_vx_b8_b8(\n                __riscv_vle8_v_i8m1((int8_t*)&c, vl), \n                'Z', vl\n            );\n            vbool8_t curr_upper_start_v = __riscv_vmsge_vx_b8_b8(\n                __riscv_vle8_v_i8m1((int8_t*)&c, vl), \n                'A', vl\n            );\n            upper_check_v = __riscv_vmand_mm_b8(curr_upper_v, curr_upper_start_v, vl);\n        }\n        is_upper_v = __riscv_vmand_mm_b8(is_upper_v, upper_check_v, vl);\n\n        i++;\n    }\n\n    // Return true if all keys are lowercase or all keys are uppercase\n    return __riscv_vmfne_mm_b8(is_lower_v, is_upper_v, vl) == 0;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Get vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Sieve of Eratosthenes with vector operations\n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n\n        // Vector marking of multiples\n        for (int j = i * i; j < n; j += i) {\n            size_t remaining = n - j;\n            vbool32_t mask = __riscv_vmslt_vx_u32m1_b32(\n                __riscv_vid_v_u32m1(vl), \n                __riscv_vdup_vx_u32m1(remaining, vl), \n                vl\n            );\n            \n            vuint32m1_t indices = __riscv_vadd_vx_u32m1(\n                __riscv_vid_v_u32m1(vl), \n                __riscv_vdup_vx_u32m1(j, vl), \n                vl\n            );\n            \n            vuint32m1_t multiples = __riscv_vrem_vx_u32m1(indices, __riscv_vdup_vx_u32m1(i, vl), vl);\n            vbool32_t multiple_mask = __riscv_vmseq_vx_u32m1_b32(multiples, __riscv_vdup_vx_u32m1(0, vl), vl);\n            \n            __riscv_vmerge_vm_b32(mask, mask, multiple_mask, vl);\n            \n            __riscv_vcompress_vm_u32m1(\n                __riscv_vdup_vx_u32m1(false, vl), \n                is_prime.data() + j, \n                mask, \n                vl\n            );\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use RVV for Sieve of Eratosthenes\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vuint32m1_t indices = __riscv_vid_v_u32m1(vl);\n\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            // Vectorized marking of non-prime numbers\n            for (size_t j = 0; j < n; j += vl) {\n                vl = __riscv_vsetvl_e32m1(n - j);\n                vuint32m1_t multiples = __riscv_vmul_vx_u32m1(indices, i, vl);\n                vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(multiples, i, vl);\n                __riscv_vmerge_vm_b32(is_prime.data() + j, mask, false, vl);\n            }\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Sieve of Eratosthenes with vectorized operations\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vuint32m1_t indices = __riscv_vid_v_u32m1(vl);\n    \n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n\n        // Vectorized marking of non-prime numbers\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vuint32m1_t multiples = __riscv_vmul_vx_u32m1(indices, i, vl);\n            vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(multiples, i, vl);\n            __riscv_vmerge_vxm_u32m1(is_prime.data() + j, false, is_prime.data() + j, mask, vl);\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Sieve of Eratosthenes with vectorized operations\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vuint32m1_t indices = __riscv_vid_v_u32m1(vl);\n    \n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n\n        // Vectorized marking of non-primes\n        for (size_t j = 0; j < n; j += vl) {\n            vl = __riscv_vsetvl_e32m1(n - j);\n            vuint32m1_t curr_indices = __riscv_vadd_vx_u32m1(indices, j, vl);\n            vbool32_t multiple_mask = __riscv_vmseq_vx_u32m1_b32(\n                __riscv_vrem_vx_u32m1(curr_indices, i, vl), 0, vl);\n            \n            vuint32m1_t curr_indices_ge_i = __riscv_vmax_vx_u32m1(curr_indices, i, vl);\n            vbool32_t valid_mask = __riscv_vmsgtu_vx_u32m1_b32(curr_indices_ge_i, 0, vl);\n            \n            vbool32_t final_mask = __riscv_vmand_mm_b32(multiple_mask, valid_mask, vl);\n            __riscv_vmerge_vm_b32(is_prime.data() + j, final_mask, false, vl);\n        }\n    }\n\n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Get vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Sieve of Eratosthenes with vector operations\n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n\n        // Vector marking of multiples\n        for (int j = i * i; j < n; j += i) {\n            size_t remaining = n - j;\n            vbool32_t mask = __riscv_vlm_v_b32(is_prime.data() + j, vl);\n            vint32_t indices = __riscv_vid_v_i32m1(vl);\n            vint32_t scaled_indices = __riscv_vmul_vx_i32m1(indices, i, vl);\n            \n            vbool32_t multiple_mask = __riscv_vmseq_vv_i32m1_b32(scaled_indices, 0, vl);\n            __riscv_vms_and_b32(mask, mask, multiple_mask, vl);\n            \n            __riscv_vsm_v_b32(is_prime.data() + j, __riscv_vmand_mm_b32(mask, multiple_mask, vl), vl);\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t n = s.length();\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine how many elements to process in this iteration\n        vl = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load characters at even indices\n        vuint8m1_t vec = __riscv_vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n        \n        // Create mask for even indices\n        vbool8_t even_mask = __riscv_vmseq_vx_u8m1_b8(vec % 2, 0, vl);\n        \n        // Check for uppercase vowels\n        vbool8_t vowel_mask = __riscv_vor_vv_b8(\n            __riscv_vor_vv_b8(\n                __riscv_vmsle_vx_u8m1_b8(vec, 'Z', vl),\n                __riscv_vmsge_vx_u8m1_b8(vec, 'A', vl),\n                vl\n            ),\n            __riscv_vor_vv_b8(\n                __riscv_vmsle_vx_u8m1_b8(vec, 'U', vl),\n                __riscv_vmsge_vx_u8m1_b8(vec, 'A', vl),\n                vl\n            ),\n            vl\n        );\n        \n        // Combine even index and uppercase vowel masks\n        vbool8_t final_mask = __riscv_vand_vv_b8(even_mask, vowel_mask, vl);\n        \n        // Count matching elements\n        result += __riscv_vcpop_m_b8(final_mask, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t n = s.length();\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine how many elements to process in this iteration\n        vl = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load characters from even indices\n        vuint8m1_t chars = __riscv_vle8_v_u8m1((const uint8_t*)(s.data() + i), vl);\n        \n        // Create mask for even indices\n        vbool8_t even_mask = __riscv_vmseq_vx_u8m1_b8(\n            __riscv_vand_vx_u8m1(\n                __riscv_vid_v_u8m1(vl), \n                1, \n                vl\n            ), \n            0, \n            vl\n        );\n        \n        // Check for uppercase vowels: A(65), E(69), I(73), O(79), U(85)\n        vbool8_t vowel_mask = __riscv_vor_vv_b8(\n            __riscv_vor_vv_b8(\n                __riscv_vor_vv_b8(\n                    __riscv_vmseq_vx_u8m1_b8(chars, 'A', vl),\n                    __riscv_vmseq_vx_u8m1_b8(chars, 'E', vl),\n                    vl\n                ),\n                __riscv_vmseq_vx_u8m1_b8(chars, 'I', vl),\n                vl\n            ),\n            __riscv_vor_vv_b8(\n                __riscv_vmseq_vx_u8m1_b8(chars, 'O', vl),\n                __riscv_vmseq_vx_u8m1_b8(chars, 'U', vl),\n                vl\n            ),\n            vl\n        );\n        \n        // Combine even index and uppercase vowel masks\n        vbool8_t final_mask = __riscv_vand_vv_b8(even_mask, vowel_mask, vl);\n        \n        // Count matching elements\n        result += __riscv_vcpop_m_b8(final_mask, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t n = s.length();\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine how many elements to process in this iteration\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load characters from even indices\n        vuint8m1_t vec = __riscv_vlse8_v_u8m1(\n            reinterpret_cast<const uint8_t*>(s.data() + i), \n            2 * sizeof(char), \n            vlmax\n        );\n        \n        // Check for uppercase vowels\n        vuint8m1_t is_upper = __riscv_vand_vx_u8m1(\n            __riscv_vmslt_vx_u8m1(vec, 91, vlmax),  // >= 'A' and < 91\n            __riscv_vmsgtu_vx_u8m1(vec, 64, vlmax), // > 64\n            vlmax\n        );\n        \n        vuint8m1_t is_vowel = __riscv_vor_vv_u8m1(\n            __riscv_vand_vv_u8m1(\n                __riscv_vceq_vx_u8m1(vec, 'A', vlmax),\n                is_upper, \n                vlmax\n            ),\n            __riscv_vor_vv_u8m1(\n                __riscv_vceq_vx_u8m1(vec, 'E', vlmax),\n                __riscv_vor_vv_u8m1(\n                    __riscv_vceq_vx_u8m1(vec, 'I', vlmax),\n                    __riscv_vor_vv_u8m1(\n                        __riscv_vceq_vx_u8m1(vec, 'O', vlmax),\n                        __riscv_vceq_vx_u8m1(vec, 'U', vlmax),\n                        vlmax\n                    ),\n                    vlmax\n                ),\n                vlmax\n            ),\n            vlmax\n        );\n        \n        vuint8m1_t upper_vowels = __riscv_vand_vv_u8m1(is_upper, is_vowel, vlmax);\n        \n        // Count the number of uppercase vowels\n        result += __riscv_vcpop_m_b8(upper_vowels, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t n = s.length();\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Calculate remaining elements\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load mask for even indices\n        vuint8m1_t indices = __riscv_vid_v_u8m1(vlmax);\n        vbool8_t even_mask = __riscv_vmseq_vx_u8m1_b8(indices, 0, vlmax);\n        \n        // Load characters at even indices\n        vint8m1_t chars = __riscv_vle8_v_i8m1((const int8_t*)(s.data() + i), vlmax);\n        \n        // Mask out odd indices\n        vint8m1_t masked_chars = __riscv_vcompress_v_i8m1_m(even_mask, chars, chars, vlmax);\n        \n        // Check for uppercase vowels\n        vbool8_t is_upper = __riscv_vmsge_vx_i8m1_b8(masked_chars, 'A', vlmax);\n        vbool8_t is_lower = __riscv_vmsle_vx_i8m1_b8(masked_chars, 'Z', vlmax);\n        vbool8_t is_vowel = __riscv_vmand_mm_b8(\n            __riscv_vmseq_vx_i8m1_b8(masked_chars, 'A', vlmax),\n            __riscv_vmseq_vx_i8m1_b8(masked_chars, 'E', vlmax),\n            vlmax\n        );\n        vbool8_t is_upper_vowel = __riscv_vmand_mm_b8(is_upper, is_lower, is_vowel, vlmax);\n        \n        // Count uppercase vowels\n        result += __riscv_vcpop_m_b8(is_upper_vowel, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t n = s.length();\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e8m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Calculate remaining elements\n        size_t vlmax = __riscv_vsetvl_e8m1(n - i);\n        \n        // Load mask for even indices\n        vuint8m1_t indices = __riscv_vid_v_u8m1(vlmax);\n        vbool8_t even_mask = __riscv_vmseq_vx_u8m1_b8(indices, 0, vlmax);\n        \n        // Load characters at even indices\n        vint8m1_t chars = __riscv_vle8_v_i8m1((const int8_t*)(s.data() + i), vlmax);\n        \n        // Mask out odd indices\n        vint8m1_t masked_chars = __riscv_vcompress_v_i8m1_m(chars, even_mask, chars, vlmax);\n        \n        // Check for uppercase vowels\n        vbool8_t is_vowel = __riscv_vmseq_vx_i8m1_b8(masked_chars, 'A', vlmax);\n        vbool8_t is_vowel_e = __riscv_vmseq_vx_i8m1_b8(masked_chars, 'E', vlmax);\n        vbool8_t is_vowel_i = __riscv_vmseq_vx_i8m1_b8(masked_chars, 'I', vlmax);\n        vbool8_t is_vowel_o = __riscv_vmseq_vx_i8m1_b8(masked_chars, 'O', vlmax);\n        vbool8_t is_vowel_u = __riscv_vmseq_vx_i8m1_b8(masked_chars, 'U', vlmax);\n        \n        vbool8_t upper_vowel_mask = __riscv_vor_vv_b8(\n            __riscv_vor_vv_b8(\n                __riscv_vor_vv_b8(\n                    __riscv_vor_vv_b8(is_vowel, is_vowel_e, vlmax),\n                    is_vowel_i, vlmax),\n                is_vowel_o, vlmax),\n            is_vowel_u, vlmax);\n        \n        // Count uppercase vowels\n        result += __riscv_vcpop_m_b8(upper_vowel_mask, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length and create vector\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    std::vector<int> result(n);\n\n    // Create initial vector with first level stones\n    vint32m1_t initial_vec = __riscv_vmv_v_x_i32m1(n, vl);\n    __riscv_vse32_v_i32m1(result.data(), initial_vec, vl);\n\n    // Process subsequent levels\n    for (int i = 1; i < n; i++) {\n        // Load previous level's stones\n        vint32m1_t prev_level = __riscv_vle32_v_i32m1(result.data() + i - 1, vl);\n        \n        // Increment based on odd/even condition\n        vint32m1_t incremented;\n        if ((n % 2) == 1) {\n            // Odd case: next odd number\n            incremented = __riscv_vadd_vv_i32m1(prev_level, __riscv_vmv_v_x_i32m1(2, vl), vl);\n        } else {\n            // Even case: next even number\n            incremented = __riscv_vadd_vv_i32m1(prev_level, __riscv_vmv_v_x_i32m1(1, vl), vl);\n        }\n        \n        // Store result\n        __riscv_vse32_v_i32m1(result.data() + i, incremented, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create vector for storing levels\n    vint32m1_t levels = __riscv_vmv_v_x_i32m1(n, vl);\n    \n    // Create mask vector for tracking odd/even\n    vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(levels, 0, vl);\n    \n    // For odd levels, add next odd number\n    // For even levels, add next even number\n    vint32m1_t increments = __riscv_vmerge_vxm_i32m1(\n        __riscv_vadd_vx_i32m1(levels, 2, vl),   // even increments \n        __riscv_vadd_vx_i32m1(levels, 1, vl),   // odd increments\n        mask, vl\n    );\n    \n    // Compute cumulative levels\n    for (int i = 1; i < n; ++i) {\n        levels = __riscv_vadd_vv_i32m1(levels, increments, vl);\n    }\n    \n    // Convert vector to std::vector\n    std::vector<int> result(n);\n    __riscv_vse32_v_i32m1(result.data(), levels, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create vector for stone counts\n    vint32m1_t stone_counts = __riscv_vmv_v_x_i32m1(n, vl);\n    \n    // Create mask vector for tracking odd/even progression\n    vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(stone_counts, n, vl);\n    \n    // Perform vector operation to compute stone levels\n    for (int i = 1; i < n; i++) {\n        vint32m1_t next_stones;\n        if (__riscv_vmfirst_m_b32(mask, vl) != -1) {\n            // Odd case: next odd number\n            next_stones = __riscv_vadd_vx_i32m1_m(mask, stone_counts, stone_counts, 2, vl);\n        } else {\n            // Even case: next even number\n            next_stones = __riscv_vadd_vx_i32m1(stone_counts, 2, vl);\n        }\n        \n        // Update stone_counts\n        stone_counts = next_stones;\n        \n        // Update mask\n        mask = __riscv_vmseq_vx_i32m1_b32(stone_counts, n, vl);\n    }\n    \n    // Convert vector to std::vector\n    std::vector<int> result(n);\n    __riscv_vse32_v_i32m1(result.data(), stone_counts, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length and create vector\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create result vector\n    std::vector<int> result(n);\n    \n    // Create vector for initial values\n    vint32m1_t initial_vec = __riscv_vmv_v_x_i32m1(n, vl);\n    \n    // Store initial value\n    __riscv_vse32_v_i32m1(result.data(), initial_vec, vl);\n    \n    // Process subsequent levels\n    for (int i = 1; i < n; i++) {\n        vint32m1_t prev_vec = __riscv_vle32_v_i32m1(result.data() + i - 1, vl);\n        \n        // Increment by 1 for odd, 2 for even\n        vint32m1_t increment_vec = __riscv_vadd_vx_i32m1(\n            prev_vec, \n            (prev_vec[0] % 2 == 0) ? 2 : 1, \n            vl\n        );\n        \n        __riscv_vse32_v_i32m1(result.data() + i, increment_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create vector for storing stone counts\n    vint32m1_t stones_vec = __riscv_vmv_v_x_i32m1(n, vl);\n    \n    // Create vector for increments\n    vint32m1_t increment_vec;\n    if (n % 2 == 0) {\n        // If n is even, increment by 2 for even numbers\n        increment_vec = __riscv_vmv_v_x_i32m1(2, vl);\n    } else {\n        // If n is odd, increment by 2 for odd numbers\n        increment_vec = __riscv_vmv_v_x_i32m1(1, vl);\n    }\n    \n    // Allocate result vector\n    std::vector<int> result(n);\n    \n    // Perform vector addition for each level\n    for (int i = 0; i < n; i++) {\n        // Store current level's stone count\n        result[i] = __riscv_vmv_x_s_i32m1_i32(stones_vec);\n        \n        // Update stones for next level\n        stones_vec = __riscv_vadd_vv_i32m1(stones_vec, increment_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate total number of elements\n    size_t count = m - n + 1;\n    \n    // Create vector to hold range of numbers\n    vint64m1_t vec;\n    size_t vl = __riscv_vsetvl_e64m1(count);\n    \n    // Generate vector with sequential numbers from n\n    vec = __riscv_vid_v_i64m1(vl);\n    vec = __riscv_vadd_vx_i64m1(vec, n, vl);\n    \n    // Compute sum of vector\n    vint64m1_t sum = __riscv_vredsum_vs_i64m1_i64m1(vec, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    \n    // Extract scalar sum\n    int64_t total_sum = __riscv_vmv_x_s_i64m1_i64(sum);\n    \n    // Compute rounded average\n    int64_t avg = total_sum / count;\n    \n    // Convert to binary string\n    return std::bitset<64>(avg).to_string().substr(std::bitset<64>(avg).to_string().find('1'));\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n\n    // Calculate total number of elements\n    size_t count = m - n + 1;\n    \n    // Create vector for storing range of numbers\n    vint64m1_t v_range;\n    size_t vl = __riscv_vsetvl_e64m1(count);\n    \n    // Generate vector with sequential numbers from n\n    v_range = __riscv_vid_v_i64m1(vl);\n    v_range = __riscv_vadd_vx_i64m1(v_range, n, vl);\n    \n    // Compute sum of vector\n    vint64m1_t v_sum = __riscv_vredsum_vs_i64m1_i64m1(v_range, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    \n    // Extract scalar sum\n    int64_t total_sum = __riscv_vmv_x_s_i64m1_i64(v_sum);\n    \n    // Compute rounded average\n    int64_t avg = total_sum / count;\n    \n    // Convert to binary string\n    return std::bitset<64>(avg).to_string().substr(std::bitset<64>(avg).to_string().find('1'));\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate total number of elements\n    size_t count = m - n + 1;\n    \n    // Create vector for storing range of numbers\n    vint64m1_t vec_nums;\n    size_t vl = __riscv_vsetvl_e64m1(count);\n    \n    // Generate vector of consecutive numbers from n\n    vec_nums = __riscv_vid_v_i64m1(vl);\n    vec_nums = __riscv_vadd_vx_i64m1(vec_nums, n, vl);\n    \n    // Compute sum of vector\n    vint64m1_t sum_vec = __riscv_vredsum_vs_i64m1_i64m1(vec_nums, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    \n    // Extract scalar sum\n    int64_t total_sum = __riscv_vmv_x_s_i64m1_i64(sum_vec);\n    \n    // Compute rounded average\n    int64_t avg = total_sum / count;\n    \n    // Convert to binary string\n    return std::bitset<64>(avg).to_string().substr(std::string(std::bitset<64>(avg).to_string()).find('1'));\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate total number of elements\n    size_t count = m - n + 1;\n    \n    // Create vector to hold range of numbers\n    vint64m1_t vec;\n    size_t vl = __riscv_vsetvl_e64m1(count);\n    \n    // Create vector with sequential numbers from n\n    vec = __riscv_vid_v_i64m1(vl);\n    vec = __riscv_vadd_vx_i64m1(vec, n, vl);\n    \n    // Compute sum of vector\n    vint64m1_t sum = __riscv_vredsum_vs_i64m1_i64m1(vec, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    \n    // Extract scalar sum\n    int64_t total_sum = __riscv_vmv_x_s_i64m1_i64(sum);\n    \n    // Compute rounded average\n    int64_t avg = total_sum / count;\n    \n    // Convert to binary string\n    return std::bitset<64>(avg).to_string().substr(std::string(std::bitset<64>(avg).to_string()).find('1'));\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate number of elements\n    int64_t count = m - n + 1;\n    \n    // Set up vector length\n    size_t vl = __riscv_vsetvl_e64m1(count);\n    \n    // Create vector of indices\n    vint64m1_t indices = __riscv_vid_v_i64m1(vl);\n    \n    // Create vector of base values\n    vint64m1_t base_vec = __riscv_vmv_v_x_i64m1(n, vl);\n    \n    // Add indices to base to get full range\n    vint64m1_t range_vec = __riscv_vadd_vv_i64m1(base_vec, indices, vl);\n    \n    // Compute sum using reduction\n    int64_t sum = __riscv_vredsum_vs_i64m1_i64(range_vec, 0, vl);\n    \n    // Compute rounded average \n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Create vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Iterate through the vector in chunks\n    for (int i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Create index vector\n        vint32m1_t indices = __riscv_vid_v_i32m1(vl);\n        indices = __riscv_vadd_vx_i32m1(indices, i + 1, vl);\n        \n        // Compute values for each index\n        vint32m1_t values = __riscv_vmv_v_x_i32m1(0, vl);\n        \n        // Mask for even/odd indices\n        vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(indices, 0, vl);\n        even_mask = __riscv_vxor_m_b32(even_mask, even_mask, vl);\n        \n        // Factorial calculation for even indices\n        vint32m1_t factorial = __riscv_vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= 20; ++j) {\n            vint32m1_t multiplier = __riscv_vmv_v_x_i32m1(j, vl);\n            vint32m1_t new_factorial = __riscv_vmul_vv_i32m1(factorial, multiplier, vl);\n            new_factorial = __riscv_vrem_vx_i32m1(new_factorial, 10000, vl);\n            factorial = __riscv_vmerge_vvm_i32m1(factorial, new_factorial, even_mask, vl);\n        }\n        \n        // Sum calculation for odd indices\n        vint32m1_t sum = __riscv_vmv_v_x_i32m1(0, vl);\n        for (int j = 1; j <= 20; ++j) {\n            vint32m1_t current_sum = __riscv_vadd_vv_i32m1(sum, __riscv_vmv_v_x_i32m1(j, vl), vl);\n            sum = __riscv_vmerge_vvm_i32m1(sum, current_sum, even_mask, vl);\n        }\n        \n        // Merge factorial and sum based on even/odd mask\n        values = __riscv_vmerge_vvm_i32m1(sum, factorial, even_mask, vl);\n        \n        // Store results back to vector\n        __riscv_vse32_v_i32m1(&result[i], values, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Create vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Iterate through the vector in chunks\n    for (int i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Create index vector\n        vint32m1_t index_vec = __riscv_vid_v_i32m1(vl);\n        index_vec = __riscv_vadd_vx_i32m1(index_vec, i + 1, vl);\n        \n        // Compute values based on index\n        vint32m1_t result_vec = __riscv_vmv_v_x_i32m1(0, vl);\n        \n        for (int j = 0; j < vl; j++) {\n            int idx = __riscv_vmv_x_s_i32m1_i32(\n                __riscv_vslide1down_vx_i32m1(index_vec, 0, vl)\n            );\n            \n            if (idx % 2 == 0) {\n                // Factorial modulo 10000 for even indices\n                int factorial = 1;\n                for (int k = 1; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                result_vec = __riscv_vslide1up_vx_i32m1(result_vec, factorial, vl);\n            } else {\n                // Sum of numbers from 1 to index for odd indices\n                int sum = (idx * (idx + 1)) / 2;\n                result_vec = __riscv_vslide1up_vx_i32m1(result_vec, sum, vl);\n            }\n            \n            index_vec = __riscv_vslide1down_vx_i32m1(index_vec, 0, vl);\n        }\n        \n        // Store results back to vector\n        __riscv_vse32_v_i32m1(&result[i], result_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Create vector length agnostic implementation\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (int i = 0; i < n; i += vl) {\n        // Determine how many elements to process in this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Create index vector\n        vuint32m1_t index_vec = __riscv_vid_v_u32m1(vl);\n        index_vec = __riscv_vadd_vx_u32m1(index_vec, i + 1, vl);\n        \n        // Compute values based on even/odd index\n        vint32m1_t result_vec = __riscv_vnew_v_i32m1(vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            int idx = __riscv_vmv_x_s_u32m1_u32(\n                __riscv_vslidedown_vx_u32m1(index_vec, j, vl)\n            );\n            \n            if (idx % 2 == 0) {\n                // Factorial calculation for even indices\n                int factorial = 1;\n                for (int k = 1; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                result_vec = __riscv_vslideup_vx_i32m1_m(\n                    __riscv_vmv_v_x_i32m1(0, vl), \n                    result_vec, \n                    factorial, \n                    j, \n                    vl\n                );\n            } else {\n                // Sum of numbers for odd indices\n                int sum = (idx * (idx + 1)) / 2;\n                result_vec = __riscv_vslideup_vx_i32m1_m(\n                    __riscv_vmv_v_x_i32m1(0, vl), \n                    result_vec, \n                    sum, \n                    j, \n                    vl\n                );\n            }\n        }\n        \n        // Store results back to vector\n        __riscv_vse32_v_i32m1(&result[i], result_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Create vector length agnostic implementation\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (int i = 0; i < n; i += vl) {\n        // Determine how many elements to process in this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Create index vector\n        vuint32m1_t index_vec = __riscv_vid_v_u32m1(vl);\n        index_vec = __riscv_vadd_vx_u32m1(index_vec, i + 1, vl);\n        \n        // Compute values based on index parity\n        vint32m1_t result_vec = __riscv_vnew_v_i32m1(vl);\n        \n        // Mask for even/odd indices\n        vbool32_t even_mask = __riscv_vmseq_vx_u32m1_b32(index_vec, 0, vl);\n        \n        // Factorial computation for even indices\n        vint32m1_t factorial_vec = __riscv_vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= 20; ++j) {  // Limit to prevent overflow\n            factorial_vec = __riscv_vmul_vv_i32m1(factorial_vec, index_vec, vl);\n            factorial_vec = __riscv_vrem_vx_i32m1(factorial_vec, 10000, vl);\n        }\n        \n        // Sum computation for odd indices\n        vint32m1_t sum_vec = __riscv_vmul_vv_i32m1(index_vec, __riscv_vadd_vx_u32m1(index_vec, 1, vl), vl);\n        sum_vec = __riscv_vdiv_vx_i32m1(sum_vec, 2, vl);\n        \n        // Blend results based on even/odd mask\n        result_vec = __riscv_vmerge_vvm_i32m1(sum_vec, factorial_vec, even_mask, vl);\n        \n        // Store results back to vector\n        __riscv_vse32_v_i32m1(&result[i], result_vec, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Create vector length and mask\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Prepare initial indices\n    vint32m1_t indices = __riscv_vid_v_i32m1(vl);\n    \n    // Add 1 to indices to start from 1\n    vint32m1_t base_indices = __riscv_vadd_vx_i32m1(indices, 1, vl);\n    \n    for (int i = 0; i < n; i += vl) {\n        // Adjust vector length for last iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Compute values for current vector length\n        vint32m1_t current_indices = __riscv_vadd_vx_i32m1(base_indices, i, vl);\n        \n        // Compute values based on even/odd index\n        vint32m1_t values = __riscv_vmerge_vxm_i32m1(\n            // Even indices: factorial mod 10000\n            __riscv_vredsum_vs_i32m1_i32m1(__riscv_vmul_vx_i32m1(current_indices, 1, vl), __riscv_vmv_s_x_i32m1(1, vl), vl) % 10000,\n            // Odd indices: sum of numbers from 1 to index\n            __riscv_vredsum_vs_i32m1_i32m1(current_indices, __riscv_vmv_s_x_i32m1(0, vl), vl),\n            __riscv_vmsne_vx_b32m1(current_indices, 0, vl),\n            vl\n        );\n        \n        // Store results in output vector\n        __riscv_vse32_v_i32m1(&result[i], values, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // Vector to store results\n    std::vector<int> result(2, 0);\n    \n    // Check if n is less than 1\n    if (n < 1) return result;\n\n    // Vector length and configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_indices = __riscv_vid_v_i32m1(vl);\n    \n    // Create mask for valid indices\n    vbool32_t mask = __riscv_vmsltu_vx_u32m1_b32(v_indices, n, vl);\n    \n    // Increment indices by 1 to match problem requirement\n    vint32m1_t v_numbers = __riscv_vadd_vx_i32m1(v_indices, 1, vl);\n    \n    // Palindrome check function\n    auto is_palindrome = [](int num) {\n        int original = num;\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n        return original == reversed;\n    };\n    \n    // Vectorized palindrome and even/odd counting\n    vint32m1_t v_palindrome_flags = __riscv_vmseq_vx_i32m1_b32(v_numbers, v_numbers, vl);\n    v_palindrome_flags = __riscv_vand_vx_i32m1_m(mask, v_palindrome_flags, v_numbers, is_palindrome, vl);\n    \n    // Count even and odd palindromes\n    vint32m1_t v_even_flags = __riscv_vand_vx_i32m1(v_numbers, 1, vl);\n    v_even_flags = __riscv_vxor_vx_i32m1(v_even_flags, 1, vl);\n    \n    vint32m1_t v_even_palindromes = __riscv_vand_vx_i32m1(v_palindrome_flags, v_even_flags, vl);\n    vint32m1_t v_odd_palindromes = __riscv_vand_vx_i32m1(v_palindrome_flags, v_even_flags, vl);\n    \n    // Reduction sum\n    int even_count = __riscv_vcpop_m_b32(v_even_palindromes, vl);\n    int odd_count = __riscv_vcpop_m_b32(v_odd_palindromes, vl);\n    \n    result[0] = even_count;\n    result[1] = odd_count;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // Vector to store results\n    std::vector<int> result(2, 0);\n    \n    // Check vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask vector\n    vbool32_t mask = __riscv_vmsltu_vx_u32m1_b32(vl, n, vl);\n    \n    // Iterate through numbers\n    for (int i = 1; i <= n; i += vl) {\n        // Create vector of current range\n        vuint32m1_t vec = __riscv_vid_v_u32m1(vl);\n        vec = __riscv_vadd_vx_u32m1(vec, i, vl);\n        \n        // Mask out numbers beyond n\n        vec = __riscv_vmerge_vxm_u32m1(vec, 0, __riscv_vmnot_m_b32(mask, vl), vl);\n        \n        // Check palindrome\n        vbool32_t palindrome_mask = __riscv_vmseq_vx_u32m1_b32(vec, 0, vl);\n        for (int j = 0; j < vl; j++) {\n            if (__riscv_vmsbf_m_b32(palindrome_mask, vl) & (1 << j)) {\n                int num = __riscv_vmv_x_s_u32m1_u32(vec);\n                \n                // Check if palindrome\n                int original = num;\n                int reversed = 0;\n                while (num > 0) {\n                    reversed = reversed * 10 + num % 10;\n                    num /= 10;\n                }\n                \n                if (original == reversed) {\n                    // Count even or odd\n                    if (original % 2 == 0) {\n                        result[0]++;\n                    } else {\n                        result[1]++;\n                    }\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // Vector to store results\n    std::vector<int> result(2, 0);\n    \n    // Check vector length \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask vector\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        0, \n        vl\n    );\n    \n    // Iterate through numbers 1 to n\n    for (int num = 1; num <= n; num++) {\n        // Check if number is palindrome\n        int original = num;\n        int reversed = 0;\n        \n        while (num > 0) {\n            int digit = num % 10;\n            reversed = reversed * 10 + digit;\n            num /= 10;\n        }\n        \n        // If palindrome, check even/odd\n        if (original == reversed) {\n            if (original % 2 == 0) {\n                result[0]++;\n            } else {\n                result[1]++;\n            }\n        }\n        \n        // Restore original number\n        num = original;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // Vector to store results\n    std::vector<int> result(2, 0);\n    \n    // Check vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create vector for indices\n    vint32m1_t indices = __riscv_vid_v_i32m1(vl);\n    \n    // Mask for valid indices\n    vbool32_t mask = __riscv_vmsltu_vx_u32m1_b32(indices, n, vl);\n    \n    // Add 1 to indices to start from 1\n    vint32m1_t nums = __riscv_vadd_vx_i32m1(indices, 1, vl);\n    \n    // Palindrome check function\n    auto is_palindrome = [](int x) {\n        int original = x;\n        int reversed = 0;\n        while (x > 0) {\n            reversed = reversed * 10 + x % 10;\n            x /= 10;\n        }\n        return original == reversed;\n    };\n    \n    // Vectorized palindrome check\n    vbool32_t palindrome_mask = __riscv_vmand_mm_b32(\n        mask, \n        __riscv_vmsne_vv_i32m1_b32(\n            __riscv_vreinterpret_v_i32m1_u32m1(\n                __riscv_vand_vx_i32m1(nums, 1, vl)\n            ), \n            __riscv_vreinterpret_v_i32m1_u32m1(\n                __riscv_vmv_v_x_i32m1(0, vl)\n            ), \n            vl\n        ), \n        vl\n    );\n    \n    // Count even and odd palindromes\n    vint32m1_t even_count = __riscv_vzext_vf2_i32m1(\n        __riscv_vcpop_m_b32(\n            __riscv_vmand_mm_b32(\n                palindrome_mask, \n                __riscv_vmsne_vx_i32m1_b32(\n                    __riscv_vand_vx_i32m1(nums, 1, vl), \n                    0, \n                    vl\n                ), \n                vl\n            ), \n            vl\n        ), \n        vl\n    );\n    \n    vint32m1_t odd_count = __riscv_vzext_vf2_i32m1(\n        __riscv_vcpop_m_b32(\n            __riscv_vmand_mm_b32(\n                palindrome_mask, \n                __riscv_vmsne_vx_i32m1_b32(\n                    __riscv_vand_vx_i32m1(nums, 1, vl), \n                    1, \n                    vl\n                ), \n                vl\n            ), \n            vl\n        ), \n        vl\n    );\n    \n    // Reduce to scalar\n    result[0] = __riscv_vmv_x_s_i32m1_i32(even_count);\n    result[1] = __riscv_vmv_x_s_i32m1_i32(odd_count);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // Vector to store results\n    std::vector<int> result(2, 0);\n    \n    // Check vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask vector\n    vbool32_t mask = __riscv_vmseq_vx_u32m1_b32(\n        __riscv_vid_v_u32m1(vl), \n        0, \n        vl\n    );\n    \n    // Iterate through numbers 1 to n\n    for (int num = 1; num <= n; num++) {\n        // Check if number is palindrome\n        int original = num;\n        int reversed = 0;\n        \n        while (original > 0) {\n            reversed = reversed * 10 + original % 10;\n            original /= 10;\n        }\n        \n        // If palindrome\n        if (reversed == num) {\n            // Check if even or odd\n            if (num % 2 == 0) {\n                result[0]++;\n            } else {\n                result[1]++;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n.size());\n    int count = 0;\n    \n    for (size_t i = 0; i < n.size(); i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n.size() - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&n[i], vlmax);\n        \n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, vec);\n        \n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vlmax);\n        \n        vint32m1_t digit_sum = __riscv_vmv_v_x_i32m1(0, vlmax);\n        \n        while (__riscv_vmsne_vx_i32m1_b32(abs_vec, __riscv_vmv_v_x_i32m1(0, vlmax))) {\n            vint32m1_t digit = __riscv_vrem_vx_i32m1(abs_vec, __riscv_vmv_v_x_i32m1(10, vlmax), vlmax);\n            digit_sum = __riscv_vadd_vv_i32m1(digit_sum, digit, vlmax);\n            abs_vec = __riscv_vdiv_vx_i32m1(abs_vec, __riscv_vmv_v_x_i32m1(10, vlmax), vlmax);\n        }\n        \n        vbool32_t sum_mask = __riscv_vmsgt_vx_i32m1_b32(digit_sum, 0, vlmax);\n        \n        count += __riscv_vcpop_m_b32(sum_mask, vlmax);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n.size());\n    int count = 0;\n    \n    for (size_t i = 0; i < n.size(); i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n.size() - i);\n        \n        // Load vector of integers\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&n[i], vlmax);\n        \n        // Create mask for tracking valid elements\n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, vec, vlmax);\n        \n        // Compute digit sum for each number\n        vint32m1_t digit_sums = __riscv_vmv_v_x_i32m1(0, vlmax);\n        \n        while (vlmax > 0) {\n            // Extract absolute value\n            vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vlmax);\n            \n            // Digit sum computation\n            vint32m1_t digit_sum = __riscv_vmv_v_x_i32m1(0, vlmax);\n            while (__riscv_vmsne_vx_i32m1_b32(abs_vec, 0, vlmax)) {\n                vint32m1_t digit = __riscv_vrem_vx_i32m1(abs_vec, 10, vlmax);\n                digit_sum = __riscv_vadd_vv_i32m1(digit_sum, digit, vlmax);\n                abs_vec = __riscv_vdiv_vx_i32m1(abs_vec, 10, vlmax);\n            }\n            \n            // Handle sign for negative numbers\n            vbool32_t neg_mask = __riscv_vmslt_vx_i32m1_b32(vec, 0, vlmax);\n            digit_sum = __riscv_vneg_v_i32m1_m(neg_mask, digit_sum, digit_sum, vlmax);\n            \n            // Accumulate digit sums\n            digit_sums = __riscv_vadd_vv_i32m1(digit_sums, digit_sum, vlmax);\n            \n            break;\n        }\n        \n        // Count numbers with digit sum > 0\n        vbool32_t sum_mask = __riscv_vmsgt_vx_i32m1_b32(digit_sums, 0, vlmax);\n        count += __riscv_vcpop_m_b32(sum_mask, vlmax);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n.size());\n    int count = 0;\n    \n    for (size_t i = 0; i < n.size(); i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n.size() - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&n[i], vlmax);\n        \n        vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(vec, vec);\n        \n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vlmax);\n        \n        vint32m1_t digit_sum = __riscv_vmv_v_x_i32m1(0, vlmax);\n        \n        while (__riscv_vmsne_vx_i32m1_b32(abs_vec, __riscv_vmv_v_x_i32m1(0, vlmax))) {\n            vint32m1_t digit = __riscv_vrem_vx_i32m1(abs_vec, __riscv_vmv_v_x_i32m1(10, vlmax), vlmax);\n            digit_sum = __riscv_vadd_vv_i32m1(digit_sum, digit, vlmax);\n            abs_vec = __riscv_vdiv_vx_i32m1(abs_vec, __riscv_vmv_v_x_i32m1(10, vlmax), vlmax);\n        }\n        \n        vbool32_t sum_mask = __riscv_vmsgt_vx_i32m1_b32(digit_sum, 0, vlmax);\n        \n        count += __riscv_vcpop_m_b32(sum_mask, vlmax);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n.size());\n    int count = 0;\n    \n    for (size_t i = 0; i < n.size(); i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n.size() - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&n[i], vlmax);\n        \n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, vlmax);\n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vlmax);\n        \n        vint32m1_t digit_sum = __riscv_vmv_v_x_i32m1(0, vlmax);\n        \n        while (__riscv_vmsne_vx_i32m1_b32(abs_vec, 0, vlmax)) {\n            vint32m1_t digit = __riscv_vrem_vx_i32m1(abs_vec, 10, vlmax);\n            digit_sum = __riscv_vadd_vv_i32m1(digit_sum, digit, vlmax);\n            abs_vec = __riscv_vdiv_vx_i32m1(abs_vec, 10, vlmax);\n        }\n        \n        vbool32_t digit_sum_mask = __riscv_vmsgt_vx_i32m1_b32(digit_sum, 0, vlmax);\n        vbool32_t final_mask = __riscv_vmand_mm_b32(mask, digit_sum_mask, vlmax);\n        \n        count += __riscv_vcpop_m_b32(final_mask, vlmax);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    size_t vl = __riscv_vsetvl_e32m1(n.size());\n    int count = 0;\n    \n    for (size_t i = 0; i < n.size(); i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n.size() - i);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&n[i], vlmax);\n        \n        vbool32_t mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, vlmax);\n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vlmax);\n        \n        vint32m1_t digit_sum = __riscv_vmv_v_x_i32m1(0, vlmax);\n        \n        while (__riscv_vmsne_vx_i32m1_b32(abs_vec, 0, vlmax)) {\n            vint32m1_t digit = __riscv_vrem_vx_i32m1(abs_vec, 10, vlmax);\n            digit_sum = __riscv_vadd_vv_i32m1(digit_sum, digit, vlmax);\n            abs_vec = __riscv_vdiv_vx_i32m1(abs_vec, 10, vlmax);\n        }\n        \n        vbool32_t digit_sum_mask = __riscv_vmsgt_vx_i32m1_b32(digit_sum, 0, vlmax);\n        mask = __riscv_vmand_mm_b32(mask, digit_sum_mask, vlmax);\n        \n        count += __riscv_vcpop_m_b32(mask, vlmax);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    // Handle empty vector case\n    if (arr.empty()) return true;\n\n    size_t n = arr.size();\n    \n    // Find the minimum element's index\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    // Use RVV to find minimum element index\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool32_t v_mask = __riscv_vmseq_vv_i32m1_b32(v_arr, __riscv_vmv_v_x_i32m1(min_val, vl), vl);\n    \n    // Scan through the vector to find minimum element index\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n    \n    // Check if the vector can be sorted by right shifts\n    for (size_t shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        // Check if the vector is sorted after shift\n        for (size_t i = 0; i < n - 1; i++) {\n            size_t curr_idx = (min_idx + i + shift) % n;\n            size_t next_idx = (min_idx + i + shift + 1) % n;\n            \n            if (arr[curr_idx] > arr[next_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    // Handle empty vector case\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    \n    // Create vector length agnostic implementation\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Find the minimum element and its index\n    vint32m1_t min_vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    for (size_t i = 1; i < n; i++) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n    \n    // Check if the vector can be sorted by right shifts\n    for (size_t shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        for (size_t i = 0; i < n - 1; i++) {\n            size_t curr_idx = (min_idx + i + shift) % n;\n            size_t next_idx = (min_idx + i + shift + 1) % n;\n            \n            if (arr[curr_idx] > arr[next_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load the entire vector\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Find the minimum element's index\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    for (size_t i = 1; i < n; i++) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_idx = i;\n        }\n    }\n    \n    // Rotate the vector to check if it becomes sorted\n    for (size_t shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        // Check if the rotated vector is sorted\n        for (size_t i = 0; i < n - 1; i++) {\n            size_t curr_idx = (min_idx + i + shift) % n;\n            size_t next_idx = (min_idx + i + shift + 1) % n;\n            \n            if (arr[curr_idx] > arr[next_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    // Handle empty vector case\n    if (arr.empty()) return true;\n\n    size_t n = arr.size();\n    \n    // Find the minimum element's index\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    // Use RVV to find minimum element index\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vint32m1_t v_min = __riscv_vredmin_vs_i32m1_i32m1(v_arr, __riscv_vmv_s_x_i32m1(0), vl);\n    min_val = __riscv_vmv_x_s_i32m1_i32(v_min);\n    \n    // Find the actual minimum index\n    for (size_t i = 0; i < n; i++) {\n        if (arr[i] == min_val) {\n            min_idx = i;\n            break;\n        }\n    }\n    \n    // Check if the vector can be sorted by right shifts\n    for (size_t i = 0; i < n; i++) {\n        bool is_sorted = true;\n        \n        // Check if the vector is sorted after right shift\n        for (size_t j = 0; j < n - 1; j++) {\n            size_t curr_idx = (min_idx + j) % n;\n            size_t next_idx = (min_idx + j + 1) % n;\n            \n            if (arr[curr_idx] > arr[next_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n        min_idx = (min_idx + 1) % n;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Find the minimum element and its index\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(vec, __riscv_vfmv_s_f_i32m1(arr[0]), vl);\n    size_t min_idx = __riscv_vcpop_m_b32(mask, vl);\n    \n    // Check if the vector can be sorted by right shifts\n    for (size_t shift = 0; shift < n; ++shift) {\n        bool is_sorted = true;\n        \n        for (size_t i = 1; i < n; ++i) {\n            size_t prev_idx = (i - 1 + shift) % n;\n            size_t curr_idx = (i + shift) % n;\n            \n            if (arr[curr_idx] < arr[prev_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd numbers in lst1\n    size_t odd_count_l1 = 0;\n    size_t even_count_l1 = 0;\n    \n    // RVV vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load lst1 into vector register\n    vint32m1_t v_lst1 = __riscv_vle32_v_i32m1(lst1.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask = __riscv_vmsne_vx_i32m1_b32(v_lst1, 0, vl);\n    odd_mask = __riscv_vmand_mm_b32(odd_mask, __riscv_vmslt_vx_i32m1_b32(v_lst1, 0, vl), vl);\n    \n    // Count odd numbers\n    vuint32m1_t odd_count_vec = __riscv_vcpop_m_b32(odd_mask, vl);\n    odd_count_l1 = __riscv_vmv_x_s_u32m1_u32(odd_count_vec);\n    \n    // Count even numbers\n    even_count_l1 = n - odd_count_l1;\n    \n    // Count odd numbers in lst2\n    size_t odd_count_l2 = 0;\n    \n    // Load lst2 into vector register\n    vint32m1_t v_lst2 = __riscv_vle32_v_i32m1(lst2.data(), vl);\n    \n    // Create mask for odd numbers\n    odd_mask = __riscv_vmsne_vx_i32m1_b32(v_lst2, 0, vl);\n    odd_mask = __riscv_vmand_mm_b32(odd_mask, __riscv_vmslt_vx_i32m1_b32(v_lst2, 0, vl), vl);\n    \n    // Count odd numbers\n    odd_count_vec = __riscv_vcpop_m_b32(odd_mask, vl);\n    odd_count_l2 = __riscv_vmv_x_s_u32m1_u32(odd_count_vec);\n    \n    // Check if we can exchange to make lst1 all even\n    return (odd_count_l1 <= odd_count_l2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd numbers in lst1\n    size_t odd_count_l1 = 0;\n    size_t even_count_l1 = 0;\n    \n    // RVV vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load lst1 into vector register\n    vint32m1_t v_lst1 = __riscv_vle32_v_i32m1(lst1.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask = __riscv_vmseq_vx_i32m1_b32(v_lst1 % 2, 1, vl);\n    \n    // Count odd numbers\n    odd_count_l1 = __riscv_vcpop_m_b32(odd_mask, vl);\n    even_count_l1 = n - odd_count_l1;\n    \n    // Count odd numbers in lst2\n    size_t odd_count_l2 = 0;\n    \n    // Load lst2 into vector register\n    vint32m1_t v_lst2 = __riscv_vle32_v_i32m1(lst2.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask_l2 = __riscv_vmseq_vx_i32m1_b32(v_lst2 % 2, 1, vl);\n    \n    // Count odd numbers\n    odd_count_l2 = __riscv_vcpop_m_b32(odd_mask_l2, vl);\n    \n    // Check if we can exchange to make lst1 all even\n    return (odd_count_l1 <= odd_count_l2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd elements in lst1\n    size_t odd_count_l1 = 0;\n    size_t even_count_l1 = 0;\n    \n    // RVV vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load lst1 chunk\n        vint32m1_t v_lst1 = __riscv_vle32_v_i32m1(lst1.data() + i, vlmax);\n        \n        // Create mask for odd elements\n        vbool32_t odd_mask = __riscv_vmseq_vx_i32m1_b32(v_lst1 % 2, 1, vlmax);\n        \n        // Count odd elements\n        odd_count_l1 += __riscv_vcpop_m_b32(odd_mask, vlmax);\n    }\n    \n    even_count_l1 = n - odd_count_l1;\n    \n    // Count even elements in lst2\n    size_t even_count_l2 = 0;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load lst2 chunk\n        vint32m1_t v_lst2 = __riscv_vle32_v_i32m1(lst2.data() + i, vlmax);\n        \n        // Create mask for even elements\n        vbool32_t even_mask = __riscv_vmseq_vx_i32m1_b32(v_lst2 % 2, 0, vlmax);\n        \n        // Count even elements\n        even_count_l2 += __riscv_vcpop_m_b32(even_mask, vlmax);\n    }\n    \n    // Check if we can exchange elements to make lst1 all even\n    return (odd_count_l1 <= even_count_l2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd numbers in lst1\n    size_t odd_count_l1 = 0;\n    size_t even_count_l1 = 0;\n    \n    // RVV vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load lst1 into vector register\n    vint32m1_t v_lst1 = __riscv_vle32_v_i32m1(lst1.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask = __riscv_vmsne_vx_i32m1_b32(v_lst1, 0, vl);\n    odd_mask = __riscv_vmand_mm_b32(odd_mask, __riscv_vmsrem_vx_i32m1_b32(v_lst1, 2, vl), vl);\n    \n    // Count odd numbers\n    odd_count_l1 = __riscv_vcpop_m_b32(odd_mask, vl);\n    even_count_l1 = n - odd_count_l1;\n    \n    // Count odd numbers in lst2\n    size_t odd_count_l2 = 0;\n    \n    // Load lst2 into vector register\n    vint32m1_t v_lst2 = __riscv_vle32_v_i32m1(lst2.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask_l2 = __riscv_vmsne_vx_i32m1_b32(v_lst2, 0, vl);\n    odd_mask_l2 = __riscv_vmand_mm_b32(odd_mask_l2, __riscv_vmsrem_vx_i32m1_b32(v_lst2, 2, vl), vl);\n    \n    // Count odd numbers\n    odd_count_l2 = __riscv_vcpop_m_b32(odd_mask_l2, vl);\n    \n    // Check if we can exchange to make lst1 all even\n    return (odd_count_l1 <= odd_count_l2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd numbers in lst1\n    size_t odd_count_l1 = 0;\n    size_t even_count_l1 = 0;\n    \n    // Use RVV intrinsics for vectorized counting\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_lst1 = __riscv_vle32_v_i32m1(lst1.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask = __riscv_vmsne_vx_i32m1_b32(v_lst1, 0, vl);\n    odd_mask = __riscv_vmand_mm_b32(odd_mask, __riscv_vmslt_vx_i32m1_b32(v_lst1, 0, vl), vl);\n    \n    // Count odd numbers\n    odd_count_l1 = __riscv_vcpop_m_b32(odd_mask, vl);\n    even_count_l1 = n - odd_count_l1;\n    \n    // Count odd numbers in lst2\n    size_t odd_count_l2 = 0;\n    size_t even_count_l2 = 0;\n    \n    vint32m1_t v_lst2 = __riscv_vle32_v_i32m1(lst2.data(), vl);\n    \n    // Create mask for odd numbers\n    vbool32_t odd_mask2 = __riscv_vmsne_vx_i32m1_b32(v_lst2, 0, vl);\n    odd_mask2 = __riscv_vmand_mm_b32(odd_mask2, __riscv_vmslt_vx_i32m1_b32(v_lst2, 0, vl), vl);\n    \n    // Count odd numbers\n    odd_count_l2 = __riscv_vcpop_m_b32(odd_mask2, vl);\n    even_count_l2 = n - odd_count_l2;\n    \n    // Check if we can exchange to make lst1 all even\n    if (odd_count_l1 <= even_count_l2) {\n        return \"YES\";\n    }\n    \n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t n = lst.size();\n\n    // Use RVV vector length-agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Process each string in the current vector length\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j >= n) break;\n            \n            const std::string& str = lst[i + j];\n            int odd_count = 0;\n            \n            // Count odd digits using vector instructions\n            for (char c : str) {\n                if ((c - '0') % 2 == 1) {\n                    odd_count++;\n                }\n            }\n            \n            // Create result string\n            result.push_back(\"the number of odd elements \" + \n                             std::to_string(odd_count) + \n                             \"n the str\" + \n                             std::to_string(odd_count) + \n                             \"ng \" + \n                             std::to_string(odd_count) + \n                             \" of the \" + \n                             std::to_string(odd_count) + \n                             \"nput.\");\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t n = lst.size();\n\n    // Use RVV vector length-agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine actual vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Process each string in the current vector length\n        for (size_t j = 0; j < vl; ++j) {\n            const std::string& str = lst[i + j];\n            int odd_count = 0;\n            \n            // Count odd digits in the string\n            for (char c : str) {\n                if ((c - '0') % 2 == 1) {\n                    odd_count++;\n                }\n            }\n            \n            // Create result string\n            result.push_back(\"the number of odd elements \" + \n                             std::to_string(odd_count) + \n                             \"n the str\" + \n                             std::to_string(odd_count) + \n                             \"ng \" + \n                             std::to_string(odd_count) + \n                             \" of the \" + \n                             std::to_string(odd_count) + \n                             \"nput.\");\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t n = lst.size();\n\n    // Use RVV vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Process each string in the current vector length\n        for (size_t j = 0; j < vl; ++j) {\n            const std::string& str = lst[i + j];\n            int odd_count = 0;\n            \n            // Count odd digits in the string\n            for (char c : str) {\n                if ((c - '0') % 2 == 1) {\n                    odd_count++;\n                }\n            }\n            \n            // Create result string\n            result.push_back(\"the number of odd elements \" + \n                             std::to_string(odd_count) + \n                             \"n the str\" + \n                             std::to_string(odd_count) + \n                             \"ng \" + \n                             std::to_string(odd_count) + \n                             \" of the \" + \n                             std::to_string(odd_count) + \n                             \"nput.\");\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t n = lst.size();\n\n    // Use RVV vector length-agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Process each string in the current vector length\n        for (size_t j = 0; j < vl; ++j) {\n            if (i + j >= n) break;\n            \n            const std::string& str = lst[i + j];\n            int odd_count = 0;\n            \n            // Count odd digits using vector instructions\n            size_t str_len = str.length();\n            size_t vec_len = __riscv_vsetvl_e8m1(str_len);\n            \n            for (size_t k = 0; k < str_len; k += vec_len) {\n                vec_len = __riscv_vsetvl_e8m1(str_len - k);\n                \n                // Load string segment\n                vuint8_t vec_chars = __riscv_vle8_v_u8m1(\n                    reinterpret_cast<const uint8_t*>(str.data() + k), \n                    vec_len\n                );\n                \n                // Create mask for odd digits\n                vbool8_t odd_mask = __riscv_vmseq_vx_u8m1_b8(\n                    __riscv_vand_vx_u8m1(vec_chars, 1, vec_len), \n                    1, \n                    vec_len\n                );\n                \n                // Count odd digits\n                odd_count += __riscv_vcpop_m_b8(odd_mask, vec_len);\n            }\n            \n            // Create result string\n            result.push_back(\"the number of odd elements \" + \n                             std::to_string(odd_count) + \n                             \"n the str\" + \n                             std::to_string(odd_count) + \n                             \"ng \" + \n                             std::to_string(odd_count) + \n                             \" of the \" + \n                             std::to_string(odd_count) + \n                             \"nput.\");\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    size_t n = lst.size();\n\n    // Process strings in vector chunks\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t vec_indices = __riscv_vid_v_i32m1(vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Process each string in the current chunk\n        for (size_t j = i; j < std::min(i + vl, n); ++j) {\n            const std::string& str = lst[j];\n            \n            // Count odd digits using vector operations\n            size_t odd_count = 0;\n            size_t str_len = str.length();\n            \n            for (size_t k = 0; k < str_len; k += vl) {\n                size_t vec_len = std::min(vl, str_len - k);\n                \n                // Load characters as integers\n                vuint8m1_t vec_chars = __riscv_vle8_v_u8m1(\n                    reinterpret_cast<const uint8_t*>(str.data() + k), vec_len);\n                \n                // Convert characters to integers\n                vint32m1_t vec_digits = __riscv_vreinterpret_v_u8m1_i32m1(vec_chars);\n                \n                // Subtract ASCII '0' to get numeric value\n                vec_digits = __riscv_vsub_vx_i32m1(vec_digits, '0', vec_len);\n                \n                // Create mask for odd digits\n                vbool32_t odd_mask = __riscv_vmseq_vx_i32m1_b32(\n                    __riscv_vrem_vx_i32m1(vec_digits, 2), 1, vec_len);\n                \n                // Count odd digits\n                odd_count += __riscv_vcpop_m_b32(odd_mask, vec_len);\n            }\n            \n            // Create result string\n            result.push_back(\"the number of odd elements \" + \n                             std::to_string(odd_count) + \n                             \"n the str\" + std::to_string(odd_count) + \n                             \"ng \" + std::to_string(odd_count) + \n                             \" of the \" + std::to_string(odd_count) + \"nput.\");\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_current_sum = __riscv_vmv_v_x_i64m1(0, vl);\n    vint64m1_t v_min_sum = __riscv_vle64_v_i64m1(nums.data(), vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(nums.data() + i, vl);\n        \n        v_current_sum = __riscv_vadd_vv_i64m1(v_current_sum, v_nums, vl);\n        v_min_sum = __riscv_vmin_vv_i64m1(v_min_sum, v_current_sum, vl);\n        \n        v_current_sum = __riscv_vmin_vv_i64m1(v_current_sum, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    }\n    \n    for (size_t i = 0; i < vl; ++i) {\n        int64_t lane_min = __riscv_vmv_x_s_i64m1_i64(v_min_sum);\n        min_sum = std::min(min_sum, lane_min);\n        v_min_sum = __riscv_vslidedown_vx_i64m1(v_min_sum, 1, vl);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_current_sum = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e64m1(n - i);\n        \n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vlmax);\n        \n        v_current_sum = __riscv_vadd_vv_i64m1(v_current_sum, v_nums, vlmax);\n        \n        vint64m1_t v_zero = __riscv_vmv_v_x_i64m1(0, vlmax);\n        vbool64_t mask = __riscv_vmslt_vv_i64m1_b64(v_current_sum, v_zero, vlmax);\n        \n        v_current_sum = __riscv_vmerge_vvm_i64m1(v_current_sum, v_zero, mask, vlmax);\n        \n        for (size_t j = 0; j < vlmax; ++j) {\n            int64_t current = __riscv_vmv_x_s_i64m1_i64(v_current_sum);\n            min_sum = std::min(min_sum, current);\n            v_current_sum = __riscv_vslide1down_vx_i64m1(v_current_sum, 0, vlmax);\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_current_sum = __riscv_vmv_v_x_i64m1(0, vl);\n    vint64m1_t v_min_sum = __riscv_vle64_v_i64m1(nums.data(), vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e64m1(n - i);\n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(nums.data() + i, vlmax);\n        \n        v_current_sum = __riscv_vadd_vv_i64m1(v_current_sum, v_nums, vlmax);\n        v_min_sum = __riscv_vmin_vv_i64m1(v_min_sum, v_current_sum, vlmax);\n        \n        vint64m1_t v_zero = __riscv_vmv_v_x_i64m1(0, vlmax);\n        v_current_sum = __riscv_vmax_vv_i64m1(v_current_sum, v_zero, vlmax);\n    }\n    \n    for (size_t i = 0; i < vl; ++i) {\n        min_sum = std::min(min_sum, __riscv_vmv_x_s_i64m1_i64(v_min_sum));\n        v_min_sum = __riscv_vslidedown_vx_i64m1(v_min_sum, 1, vl);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_current_sum = __riscv_vmv_v_x_i64m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e64m1(n - i);\n        \n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vlmax);\n        \n        v_current_sum = __riscv_vadd_vv_i64m1(v_current_sum, v_nums, vlmax);\n        \n        vint64m1_t v_min_sum = __riscv_vredmin_vs_i64m1_i64m1(v_current_sum, __riscv_vmv_v_x_i64m1(min_sum, vlmax), vlmax);\n        min_sum = __riscv_vmv_x_s_i64m1_i64(v_min_sum);\n        \n        v_current_sum = __riscv_vmax_vx_i64m1(v_current_sum, 0, vlmax);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t v_min_sum = __riscv_vmv_v_x_i64m1(nums[0], vl);\n    vint64m1_t v_current_sum = __riscv_vmv_v_x_i64m1(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e64m1(n - i);\n        \n        vint64m1_t v_nums = __riscv_vle64_v_i64m1(&nums[i], vlmax);\n        \n        v_current_sum = __riscv_vadd_vv_i64m1(v_current_sum, v_nums, vlmax);\n        v_min_sum = __riscv_vmin_vv_i64m1(v_min_sum, v_current_sum, vlmax);\n        \n        vint64m1_t v_zero = __riscv_vmv_v_x_i64m1(0, vlmax);\n        v_current_sum = __riscv_vmin_vv_i64m1(v_current_sum, v_zero, vlmax);\n    }\n\n    int64_t result = __riscv_vmv_x_s_i64m1_i64(v_min_sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (int r = 0; r < rows; r++) {\n        // Load water units for current row\n        vint32m1_t water_vec = __riscv_vlev_v_i32m1(grid[r].data(), vl);\n        \n        // Compute water units in this row\n        vuint32m1_t water_sum_vec = __riscv_vredsum_vs_i32m1_u32m1(water_vec, __riscv_vmv_v_x_u32m1(0, vl), vl);\n        \n        // Extract scalar sum of water units\n        unsigned int row_water = __riscv_vmv_x_s_u32m1_u32(water_sum_vec);\n        \n        // Compute number of bucket lowerings needed\n        total_water += (row_water + capacity - 1) / capacity;\n    }\n    \n    return total_water;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    int total_water = 0;\n    \n    // Parallel processing of rows\n    for (int i = 0; i < rows; i++) {\n        // Load row data into vector register\n        vint32m1_t row_vec = __riscv_vlev_v_i32m1(grid[i].data(), vl);\n        \n        // Compute water in current row using vector reduction\n        vuint32m1_t water_vec = __riscv_vmv_v_x_u32m1(0, vl);\n        water_vec = __riscv_vredsum_vs_u32m1_u32m1(row_vec, water_vec, vl);\n        \n        // Extract total water in row\n        int row_water = __riscv_vmv_x_s_u32m1_u32(water_vec);\n        \n        // Compute number of bucket lowerings needed\n        total_water += (row_water + capacity - 1) / capacity;\n    }\n    \n    return total_water;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_operations = 0;\n\n    // Create vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n\n    // Iterate through each row\n    for (int i = 0; i < rows; i++) {\n        // Create vector to store current row\n        vint32m1_t row_vec = __riscv_vlev_v_i32m1(grid[i].data(), vl);\n\n        // Count water units in this row\n        vuint32m1_t water_mask = __riscv_vmseq_vx_u32m1_b8(row_vec, 1, vl);\n        vuint32m1_t water_units = __riscv_vcpop_m_u32m1(water_mask, vl);\n\n        // Calculate number of bucket lowerings needed\n        int row_operations = (water_units + capacity - 1) / capacity;\n        total_operations += row_operations;\n    }\n\n    return total_operations;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    for (int r = 0; r < rows; r++) {\n        // Load row water units\n        vint32m1_t row_water = __riscv_vlev_v_i32m1(grid[r].data(), vl);\n        \n        // Compute water units in this row\n        vuint32m1_t water_units = __riscv_vreinterpret_v_i32m1_u32m1(\n            __riscv_vredsum_vs_i32m1_i32m1(row_water, __riscv_vmv_v_x_i32m1(0, vl), vl)\n        );\n        \n        // Extract total water in row\n        int row_total_water = __riscv_vmv_x_s_u32m1_u32(water_units);\n        \n        // Compute number of bucket lowerings needed\n        total_water += (row_total_water + capacity - 1) / capacity;\n    }\n    \n    return total_water;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(cols);\n    \n    // Total water units to fill\n    int total_water = 0;\n    \n    // Parallel processing of rows\n    for (int i = 0; i < rows; i++) {\n        // Create vector register for current row\n        vint32m1_t row_vec = __riscv_vlev_v_i32m1(grid[i].data(), vl);\n        \n        // Sum water units in current row using vector reduction\n        vuint32m1_t water_vec = __riscv_vmv_v_x_u32m1(0, vl);\n        water_vec = __riscv_vredsum_vs_u32m1_u32m1(row_vec, water_vec, vl);\n        \n        // Extract total water for current row\n        int row_water = __riscv_vmv_x_s_u32m1_u32(water_vec);\n        total_water += row_water;\n    }\n    \n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    \n    // Create vector mask for even positions\n    vbool16_t mask = __riscv_vmseq_vx_u16m1_b16(\n        __riscv_vid_v_u16m1(vl), \n        0, \n        vl\n    );\n    \n    // Load vector\n    vint16m1_t vec = __riscv_vle16_v_i16m1(lst.data(), vl);\n    \n    // Mask select even positions\n    vint16m1_t even_pos_vec = __riscv_vcompress_vm_i16m1(vec, mask, vl);\n    \n    // Create mask for odd values\n    vbool16_t odd_mask = __riscv_vmsne_vx_i16m1_b16(\n        __riscv_vand_vx_i16m1(even_pos_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress odd values\n    vint16m1_t odd_vec = __riscv_vcompress_vm_i16m1(even_pos_vec, odd_mask, vl);\n    \n    // Reduce sum\n    sum = __riscv_vmv_x_s_i16m1_i16(__riscv_vredsum_vs_i16m1_i16m1(odd_vec, __riscv_vmv_s_x_i16m1(0, vl), vl));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n    \n    // If vector is empty, return 0\n    if (n == 0) return result;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    \n    // Create vector mask for even positions\n    vbool16_t mask = __riscv_vmseq_vx_u16m1_b16(\n        __riscv_vid_v_u16m1(vl), \n        0, \n        vl\n    );\n    \n    // Load vector\n    vint16m1_t vec = __riscv_vle16_v_i16m1(lst.data(), vl);\n    \n    // Mask select even positions\n    vint16m1_t even_pos_vec = __riscv_vcompress_vm_i16m1(vec, mask, vl);\n    \n    // Create mask for odd elements\n    vbool16_t odd_mask = __riscv_vmsne_vx_i16m1_b16(\n        __riscv_vand_vx_i16m1(even_pos_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress odd elements\n    vint16m1_t odd_elements = __riscv_vcompress_vm_i16m1(even_pos_vec, odd_mask, vl);\n    \n    // Reduce sum\n    result = __riscv_vmv_x_s_i16m1_i16(__riscv_vredsum_vs_i16m1_i16(odd_elements, __riscv_vmv_s_x_i16m1(0, vl), vl));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n\n    // If vector is empty, return 0\n    if (n == 0) return result;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e16m1(n);\n\n    // Load vector\n    vint16m1_t v_input = __riscv_vle16_v_i16m1(lst.data(), vl);\n\n    // Create mask for even positions\n    vuint16m1_t v_indices = __riscv_vid_v_u16m1(vl);\n    vbool16_t v_even_pos_mask = __riscv_vmseq_vx_u16m1_b16(v_indices, 0, vl);\n    v_even_pos_mask = __riscv_vmxor_mm_b16(v_even_pos_mask, v_even_pos_mask, vl);\n\n    // Create mask for odd elements\n    vbool16_t v_odd_mask = __riscv_vmseq_vx_i16m1_b16(\n        __riscv_vrem_vx_i16m1(v_input, 2, vl), 1, vl);\n\n    // Combine masks\n    vbool16_t v_combined_mask = __riscv_vmand_mm_b16(v_even_pos_mask, v_odd_mask, vl);\n\n    // Mask select and reduce sum\n    vint16m1_t v_selected = __riscv_vcompress_v_i16m1_m(v_input, v_combined_mask, vl);\n    vl = __riscv_vcpop_m_b16(v_combined_mask, vl);\n\n    if (vl > 0) {\n        result = __riscv_vredsum_vs_i16m1_i64m1(v_selected, __riscv_vmv_s_x_i64m1(0, vl), vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t sum = 0;\n\n    // If vector is empty, return 0\n    if (n == 0) return sum;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e16m1(n);\n\n    // Create vector mask for even positions\n    vbool16_t mask = __riscv_vmseq_vx_u16m1_b16(\n        __riscv_vid_v_u16m1(vl), \n        0, \n        vl\n    );\n\n    // Load vector\n    vint16m1_t vec = __riscv_vle16_v_i16m1(lst.data(), vl);\n\n    // Mask vector to keep only elements at even positions\n    vint16m1_t masked_vec = __riscv_vcompress_vm_i16m1(vec, mask, vl);\n\n    // Create mask for odd elements\n    vbool16_t odd_mask = __riscv_vmsne_vx_u16m1_b16(\n        __riscv_vand_vx_i16m1(masked_vec, 1, vl), \n        0, \n        vl\n    );\n\n    // Compress to keep only odd elements\n    vint16m1_t odd_vec = __riscv_vcompress_vm_i16m1(masked_vec, odd_mask, vl);\n\n    // Reduce sum\n    sum = __riscv_vmv_x_s_i16m1_i16(__riscv_vredsum_vs_i16m1_i16m1(odd_vec, __riscv_vmv_s_x_i16m1(0, vl), vl));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e16m1(n);\n    \n    // Create vector mask for even positions\n    vbool16_t mask = __riscv_vmseq_vx_u16m1_b16(\n        __riscv_vid_v_u16m1(vl), \n        0, \n        vl\n    );\n    \n    // Load vector\n    vint16m1_t vec = __riscv_vle16_v_i16m1(lst.data(), vl);\n    \n    // Mask select elements in even positions\n    vint16m1_t even_pos_vec = __riscv_vcompress_vm_i16m1(vec, mask, vl);\n    \n    // Create mask for odd elements\n    vbool16_t odd_mask = __riscv_vmsne_vx_i16m1_b16(\n        __riscv_vand_vx_i16m1(even_pos_vec, 1, vl), \n        0, \n        vl\n    );\n    \n    // Compress odd elements\n    vint16m1_t odd_elements = __riscv_vcompress_vm_i16m1(even_pos_vec, odd_mask, vl);\n    \n    // Sum odd elements\n    vint64m1_t sum_vec = __riscv_vwredsum_vs_i16m1_i64m1(odd_elements, __riscv_vmv_v_x_i64m1(0, vl), vl);\n    \n    // Extract scalar sum\n    result = __riscv_vmv_x_s_i64m1_i64(sum_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < k; i += vl) {\n        vint32m1_t v_data = __riscv_vle32_v_i32m1(&arr[i], vl);\n        vbool32_t v_mask = __riscv_vmslt_vx_i32m1_b32(v_data, 100, vl);\n        vbool32_t v_mask_neg = __riscv_vmslt_vx_i32m1_b32(v_data, -9, vl);\n        v_mask = __riscv_vmand_mm_b32(v_mask, __riscv_vmnot_m_b32(v_mask_neg, vl), vl);\n        \n        vint32m1_t v_filtered = __riscv_vcompress_vm_i32m1(v_data, v_mask, vl);\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_filtered, vl);\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t v_sum = __riscv_vmv_v_x(0, vl);\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = __riscv_vsetvl_e32m1(k - i);\n        vint32m1_t v_data = __riscv_vle32_v_i32m1(&arr[i], vl);\n        \n        vbool32_t v_mask = __riscv_vmsltu_vx_i32m1_b32(v_data, 100, vl);\n        vbool32_t v_mask2 = __riscv_vmsltu_vx_i32m1_b32(v_data, 10000, vl);\n        vbool32_t v_final_mask = __riscv_vmand_mm_b32(v_mask, v_mask2, vl);\n        \n        vint32m1_t v_filtered = __riscv_vcompress_vm_i32m1_i32m1(v_data, v_final_mask, vl);\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_filtered, vl);\n    }\n\n    sum = __riscv_vmv_x_v_i32m1_i32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t v_sum = __riscv_vmv_v_x(0, vl);\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = __riscv_vsetvl_e32m1(k - i);\n        vint32m1_t v_data = __riscv_vle32_v_i32m1(&arr[i], vl);\n        \n        vbool32_t v_mask = __riscv_vmsleu_vx_i32m1_b32(v_data, 99, vl);\n        vbool32_t v_mask_neg = __riscv_vmsgtu_vx_i32m1_b32(v_data, -10, vl);\n        vbool32_t v_final_mask = __riscv_vmand_mm_b32(v_mask, v_mask_neg, vl);\n        \n        vint32m1_t v_masked_data = __riscv_vmerge_vxm_i32m1(v_data, 0, v_final_mask, vl);\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_masked_data, vl);\n    }\n\n    sum = __riscv_vmv_x_s(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < k; i += vl) {\n        vint32m1_t v_data = __riscv_vle32_v_i32m1(&arr[i], vl);\n        vbool32_t v_mask = __riscv_vmslt_vx_i32m1_b32(v_data, 100, vl);\n        vbool32_t v_mask_neg = __riscv_vmslt_vx_i32m1_b32(v_data, -9, vl);\n        v_mask = __riscv_vmand_mm_b32(v_mask, __riscv_vmnot_m_b32(v_mask_neg, vl), vl);\n        \n        vint32m1_t v_masked = __riscv_vmerge_vxm_i32m1(v_data, 0, v_mask, vl);\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_masked, vl);\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < k; i += vl) {\n        vl = __riscv_vsetvl_e32m1(k - i);\n        vint32m1_t v_data = __riscv_vle32_v_i32m1(&arr[i], vl);\n        \n        // Check if number has at most 2 digits\n        vbool32_t v_mask = __riscv_vmslt_vx_i32m1_b32(v_data, 100, vl);\n        vbool32_t v_mask_positive = __riscv_vmsgt_vx_i32m1_b32(v_data, 0, vl);\n        vbool32_t v_final_mask = __riscv_vmand_mm_b32(v_mask, v_mask_positive, vl);\n        \n        vint32m1_t v_filtered = __riscv_vcompress_vm_i32m1_i32m1(v_data, v_final_mask, vl);\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_filtered, __riscv_vpopc_m_b32(v_final_mask, vl));\n    }\n\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vint32m1_t prev_vec, curr_vec;\n    vbool32_t mask;\n    \n    // Load first vector\n    prev_vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Check for duplicates in first vector\n    vint32m1_t unique_vec = __riscv_vcompress_vm_i32m1(prev_vec, __riscv_vmnot_m_b32(__riscv_vmeq_vv_b32(prev_vec, prev_vec, vl), vl), vl);\n    if (__riscv_vcpop_m_b32(unique_vec, vl) != vl) return false;\n    \n    size_t processed = vl;\n    while (processed < n) {\n        vl = __riscv_vsetvl_e32m1(n - processed);\n        \n        // Load next vector\n        curr_vec = __riscv_vle32_v_i32m1(lst.data() + processed, vl);\n        \n        // Check for duplicates in current vector\n        unique_vec = __riscv_vcompress_vm_i32m1(curr_vec, __riscv_vmnot_m_b32(__riscv_vmeq_vv_b32(curr_vec, curr_vec, vl), vl), vl);\n        if (__riscv_vcpop_m_b32(unique_vec, vl) != vl) return false;\n        \n        // Check if current vector is sorted and greater than previous vector\n        mask = __riscv_vmslt_vv_b32(curr_vec, prev_vec, vl);\n        if (__riscv_vcpop_m_b32(mask, vl) > 0) return false;\n        \n        prev_vec = curr_vec;\n        processed += vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load first vector chunk\n    vint32m1_t prev = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Track if sorted and duplicates\n    bool is_sorted = true;\n    bool has_duplicates = false;\n    \n    size_t processed = vl;\n    while (processed < n) {\n        // Remaining elements\n        size_t remaining = n - processed;\n        vl = __riscv_vsetvl_e32m1(remaining);\n        \n        // Load next vector chunk\n        vint32m1_t curr = __riscv_vle32_v_i32m1(lst.data() + processed, vl);\n        \n        // Check if current is greater than previous\n        vbool32_t gt_mask = __riscv_vmslt_vv_i32m1_b32(prev, curr, vl);\n        is_sorted &= __riscv_vmall_mm_b32(gt_mask, vl);\n        \n        // Check for duplicates\n        vbool32_t eq_mask = __riscv_vmeq_vv_i32m1_b32(prev, curr, vl);\n        size_t dup_count = __riscv_vcpop_m_b32(eq_mask, vl);\n        has_duplicates |= (dup_count > vl/2);\n        \n        prev = curr;\n        processed += vl;\n    }\n    \n    return is_sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vint32m1_t prev_vec = __riscv_vle32_v_i32m1(lst.data(), vl);\n    vbool32_t sorted_mask = __riscv_vmseq_vv_i32m1_b32(prev_vec, prev_vec);\n    \n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t curr_vec = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        // Check if current vector is sorted\n        vbool32_t curr_sorted_mask = __riscv_vmseq_vv_i32m1_b32(curr_vec, curr_vec);\n        \n        // Check if current vector is greater than previous vector\n        vbool32_t greater_mask = __riscv_vmsgt_vv_i32m1_b32(curr_vec, prev_vec);\n        \n        // Check for duplicates\n        vbool32_t no_duplicates_mask = __riscv_vmsne_vv_i32m1_b32(curr_vec, prev_vec);\n        \n        // Combine masks\n        vbool32_t valid_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(curr_sorted_mask, greater_mask),\n            no_duplicates_mask\n        );\n        \n        if (__riscv_vcpop_m_b32(valid_mask, vl) != vl) {\n            return false;\n        }\n        \n        prev_vec = curr_vec;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load first chunk of vector\n    vint32m1_t current = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Track duplicates and sorted status\n    vbool32_t sorted_mask = __riscv_vmsltu_vv_i32m1_b32(current, __riscv_vslide1up_vx_i32m1(current, 0, vl), vl);\n    vbool32_t duplicate_mask = __riscv_vmsne_vv_i32m1_b32(current, __riscv_vslide1up_vx_i32m1(current, 0, vl), vl);\n    \n    bool is_sorted = __riscv_vmall_m_b32(sorted_mask, vl);\n    bool no_extra_duplicates = !__riscv_vmany_m_b32(duplicate_mask, vl);\n\n    // Process remaining elements if vector is longer than initial vector length\n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        current = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        sorted_mask = __riscv_vmsltu_vv_i32m1_b32(current, __riscv_vslide1up_vx_i32m1(current, 0, vl), vl);\n        duplicate_mask = __riscv_vmsne_vv_i32m1_b32(current, __riscv_vslide1up_vx_i32m1(current, 0, vl), vl);\n        \n        is_sorted &= __riscv_vmall_m_b32(sorted_mask, vl);\n        no_extra_duplicates &= !__riscv_vmany_m_b32(duplicate_mask, vl);\n    }\n\n    return is_sorted && no_extra_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load first vector chunk\n    vint32m1_t prev = __riscv_vle32_v_i32m1(lst.data(), vl);\n    \n    // Track duplicates and sorted status\n    vbool32_t is_sorted_mask = __riscv_vmseq_vv_b32_b32m1(prev, prev, vl);\n    bool is_sorted = true;\n    int dup_count = 1;\n\n    for (size_t i = vl; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t curr = __riscv_vle32_v_i32m1(lst.data() + i, vl);\n        \n        // Check if current is greater than previous\n        vbool32_t gt_mask = __riscv_vmsgt_vv_b32_b32m1(curr, prev, vl);\n        \n        // Check for duplicates\n        vbool32_t eq_mask = __riscv_vmseq_vv_b32_b32m1(curr, prev, vl);\n        int curr_dups = __riscv_vcpop_m_b32m1(eq_mask, vl);\n        \n        dup_count += curr_dups;\n        if (dup_count > 2) {\n            is_sorted = false;\n            break;\n        }\n        \n        // Update sorted status\n        is_sorted &= __riscv_vmfirst_m_b32m1(gt_mask, vl) != -1;\n        \n        if (!is_sorted) break;\n        \n        prev = curr;\n    }\n\n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load vector\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Compute sign of each element\n    vint32m1_t v_signs = __riscv_vsign_vv_i32m1(v_arr, v_arr, vl);\n    \n    // Compute product of signs\n    int sign_product = 1;\n    for (size_t i = 0; i < n; i += vl) {\n        vint32m1_t v_curr_signs = __riscv_vslide1down_vx_i32m1(v_signs, sign_product, vl);\n        sign_product *= __riscv_vmv_x_s_i32m1_i32(v_curr_signs);\n    }\n    \n    // Compute sum of magnitudes\n    vint32m1_t v_abs = __riscv_vabs_v_i32m1(v_arr, vl);\n    int sum_magnitudes = __riscv_vredsum_vs_i32m1_i32(v_abs, __riscv_vmv_s_x_i32m1(0), vl);\n    \n    return sign_product * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load vector\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Compute sign of each element\n    vint32m1_t v_signs = __riscv_vsgn_vv_i32m1(v_arr, vl);\n    \n    // Compute product of signs\n    int sign_product = 1;\n    vint32m1_t v_sign_product = __riscv_vmv_v_x_i32m1(sign_product, vl);\n    v_sign_product = __riscv_vredmul_vs_i32m1_i32m1(v_signs, v_sign_product, vl);\n    sign_product = __riscv_vmv_x_s_i32m1_i32(v_sign_product);\n    \n    // Compute absolute values\n    vint32m1_t v_abs = __riscv_vabs_vv_i32m1(v_arr, vl);\n    \n    // Compute sum of magnitudes\n    int magnitude_sum = __riscv_vredsum_vs_i32m1_i32m1(v_abs, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load vector\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Compute sign of each element\n    vint32m1_t v_signs = __riscv_vsign_vv_i32m1(v_arr, vl);\n    \n    // Compute product of signs\n    int sign_product = 1;\n    for (size_t i = 0; i < n; i += vl) {\n        vint32m1_t v_curr_signs = __riscv_vslide1down_vx_i32m1(v_signs, sign_product, vl);\n        sign_product = __riscv_vmv_x_s_i32m1_i32(v_curr_signs);\n    }\n    \n    // Compute absolute values\n    vint32m1_t v_abs = __riscv_vabs_v_i32m1(v_arr, vl);\n    \n    // Compute sum of magnitudes\n    int sum_magnitudes = __riscv_vredsum_vs_i32m1_i32(v_abs, 0, vl);\n    \n    return sign_product * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load vector\n    vint32m1_t v_arr = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Create sign vector\n    vint32m1_t v_signs = __riscv_vsign_vv_i32m1(v_arr, v_arr, vl);\n    \n    // Compute product of signs\n    int sign_product = 1;\n    for (size_t i = 0; i < n; i += vl) {\n        vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(v_signs, 0, vl);\n        int neg_count = __riscv_vcpop_m_b32(mask, vl);\n        sign_product *= (neg_count % 2 == 0) ? 1 : -1;\n    }\n    \n    // Compute sum of magnitudes\n    vint32m1_t v_abs = __riscv_vabs_v_i32m1(v_arr, vl);\n    int sum_magnitudes = __riscv_vredsum_vs_i32m1_i32(v_abs, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    \n    return sign_product * sum_magnitudes;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    size_t n = arr.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Load vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Create sign vector\n    vint32m1_t signs = __riscv_vsignum_vv_i32m1(vec, vl);\n    \n    // Compute product of signs\n    vint32m1_t sign_prod = __riscv_vredmul_vs_i32m1_i32m1(signs, __riscv_vmv_v_x_i32m1(1, vl), vl);\n    int sign_result = __riscv_vmv_x_s_i32m1_i32(sign_prod);\n    \n    // Compute absolute values\n    vint32m1_t abs_vec = __riscv_vabs_vv_i32m1(vec, vl);\n    \n    // Compute sum of magnitudes\n    vint32m1_t sum_mag = __riscv_vred_sum_vs_i32m1_i32m1(abs_vec, __riscv_vmv_v_x_i32m1(0, vl), vl);\n    int magnitude_sum = __riscv_vmv_x_s_i32m1_i32(sum_mag);\n    \n    return sign_result * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Directions: right, down, left, up\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n    \n    // Parallel vector to track minimum path\n    std::vector<std::vector<int>> min_path(N, std::vector<int>(N, INT_MAX));\n    \n    // RVV vector length configuration\n    size_t vl = __riscv_vsetvl_e32m1(N);\n    \n    // Parallel initialization of min_path\n    vint32m1_t zero_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            // Parallel DFS to find minimum path\n            std::vector<int> current_path = {grid[i][j]};\n            \n            // Recursive DFS with pruning\n            auto dfs = [&](auto&& self, int x, int y, std::vector<int>& path) -> void {\n                if (path.size() == k) {\n                    // Update minimum path lexicographically\n                    if (path < result || result[0] == 0) {\n                        result = path;\n                    }\n                    return;\n                }\n                \n                // Parallel vector for tracking directions\n                vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(zero_vec, zero_vec, vl);\n                \n                for (int dir = 0; dir < 4; dir++) {\n                    int nx = x + dx[dir];\n                    int ny = y + dy[dir];\n                    \n                    // Check grid boundaries\n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        path.push_back(grid[nx][ny]);\n                        self(self, nx, ny, path);\n                        path.pop_back();\n                    }\n                }\n            };\n            \n            dfs(dfs, i, j, current_path);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Directions: right, down, left, up\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n    \n    // Use vector to store potential paths\n    std::vector<std::vector<int>> paths;\n    \n    // Vectorized path exploration\n    size_t vl = __riscv_vsetvl_e32m1(N * N);\n    \n    // Initialize vector registers for tracking\n    vint32m1_t path_values = __riscv_vmv_v_x_i32m1(0, vl);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(path_values, 0, vl);\n    \n    // Parallel path generation\n    for (int start_row = 0; start_row < N; start_row++) {\n        for (int start_col = 0; start_col < N; start_col++) {\n            std::vector<int> current_path = {grid[start_row][start_col]};\n            \n            // Vectorized DFS-like exploration\n            while (current_path.size() < k) {\n                int last_row = -1, last_col = -1;\n                int last_val = current_path.back();\n                \n                // Find last cell's position\n                for (int r = 0; r < N; r++) {\n                    for (int c = 0; c < N; c++) {\n                        if (grid[r][c] == last_val) {\n                            last_row = r;\n                            last_col = c;\n                            break;\n                        }\n                    }\n                    if (last_row != -1) break;\n                }\n                \n                // Vectorized neighbor exploration\n                vint32m1_t neighbor_values = __riscv_vmv_v_x_i32m1(0, vl);\n                \n                for (int d = 0; d < 4; d++) {\n                    int new_row = last_row + dx[d];\n                    int new_col = last_col + dy[d];\n                    \n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                        // Vectorized value insertion\n                        neighbor_values = __riscv_vadd_vx_i32m1(\n                            neighbor_values, \n                            grid[new_row][new_col], \n                            vl\n                        );\n                    }\n                }\n                \n                // Find minimum neighbor value\n                vint32m1_t min_neighbor = __riscv_vredmin_vs_i32m1_i32m1(neighbor_values, path_values, vl);\n                \n                current_path.push_back(__riscv_vmv_x_s_i32m1_i32(min_neighbor));\n            }\n            \n            paths.push_back(current_path);\n        }\n    }\n    \n    // Find lexicographically minimum path\n    std::vector<int> min_path = paths[0];\n    for (const auto& path : paths) {\n        if (path < min_path) {\n            min_path = path;\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Directions: right, down, left, up\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n    \n    // Use vector to track minimum path\n    std::vector<std::vector<std::vector<int>>> dp(N, \n        std::vector<std::vector<int>>(N, std::vector<int>(k + 1, INT_MAX)));\n    \n    // Initialize first step for all cells\n    size_t vl = __riscv_vsetvl_e32m1(N * N);\n    vint32m1_t v_grid = __riscv_vlse32_v_i32m1(grid[0].data(), N * sizeof(int), vl);\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n    }\n    \n    // Dynamic programming with k steps\n    for (int step = 2; step <= k; step++) {\n        for (int x = 0; x < N; x++) {\n            for (int y = 0; y < N; y++) {\n                for (int d = 0; d < 4; d++) {\n                    int nx = x + dx[d];\n                    int ny = y + dy[d];\n                    \n                    if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                        if (dp[x][y][step-1] != INT_MAX) {\n                            // Use vector comparison\n                            vint32m1_t v_current = __riscv_vmv_v_x_i32m1(dp[x][y][step-1], vl);\n                            vint32m1_t v_next = __riscv_vadd_vx_i32m1(v_current, grid[nx][ny], vl);\n                            \n                            dp[nx][ny][step] = std::min(dp[nx][ny][step], \n                                __riscv_vmv_x_s_i32m1_i32(v_next));\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Find minimum path\n    int min_val = INT_MAX;\n    int min_x = 0, min_y = 0;\n    \n    for (int x = 0; x < N; x++) {\n        for (int y = 0; y < N; y++) {\n            if (dp[x][y][k] < min_val) {\n                min_val = dp[x][y][k];\n                min_x = x;\n                min_y = y;\n            }\n        }\n    }\n    \n    // Reconstruct path\n    result[k-1] = grid[min_x][min_y];\n    for (int step = k; step > 1; step--) {\n        for (int d = 0; d < 4; d++) {\n            int nx = min_x - dx[d];\n            int ny = min_y - dy[d];\n            \n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                if (dp[nx][ny][step-1] != INT_MAX && \n                    dp[min_x][min_y][step] == dp[nx][ny][step-1] + grid[min_x][min_y]) {\n                    result[step-2] = grid[nx][ny];\n                    min_x = nx;\n                    min_y = ny;\n                    break;\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Directions: right, down, left, up\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n    \n    // Use RVV intrinsics for parallel path exploration\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    \n    // Parallel path tracking\n    vint32m1_t path_values = __riscv_vmv_v_x_i32m1(0, vl);\n    vbool32_t mask = __riscv_vmseq_vx_i32m1_b32(path_values, 0, vl);\n    \n    // Minimum path tracking\n    int min_path_value = INT_MAX;\n    std::vector<int> min_path(k);\n    \n    // Parallel DFS with RVV\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            std::vector<int> current_path(k);\n            current_path[0] = grid[start_row][start_col];\n            \n            // Parallel path exploration\n            for (int step = 1; step < k; ++step) {\n                vint32m1_t candidate_values = __riscv_vmv_v_x_i32m1(0, vl);\n                \n                // Explore 4 directions in parallel\n                for (int dir = 0; dir < 4; ++dir) {\n                    int new_row = start_row + dx[dir];\n                    int new_col = start_col + dy[dir];\n                    \n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                        vint32m1_t dir_values = __riscv_vmv_v_x_i32m1(grid[new_row][new_col], vl);\n                        candidate_values = __riscv_vmax_vv_i32m1(candidate_values, dir_values, vl);\n                    }\n                }\n                \n                // Select best candidate\n                int best_candidate = __riscv_vmv_x_s_i32m1_i32(candidate_values);\n                current_path[step] = best_candidate;\n            }\n            \n            // Compare paths lexicographically\n            bool is_smaller = false;\n            for (int i = 0; i < k; ++i) {\n                if (current_path[i] < min_path[i]) {\n                    is_smaller = true;\n                    break;\n                } else if (current_path[i] > min_path[i]) {\n                    break;\n                }\n            }\n            \n            if (is_smaller || min_path[0] == 0) {\n                min_path = current_path;\n            }\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Directions: right, down, left, up\n    const int dx[] = {0, 1, 0, -1};\n    const int dy[] = {1, 0, -1, 0};\n    \n    // Use RVV intrinsics for parallel path exploration\n    size_t vl = __riscv_vsetvl_e32m1(k);\n    \n    // Parallel path tracking\n    vint32m1_t path_values = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n    vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(path_values, path_values, vl);\n    \n    // Explore all possible starting points in parallel\n    for (int start_x = 0; start_x < N; start_x++) {\n        for (int start_y = 0; start_y < N; start_y++) {\n            std::vector<int> current_path(k);\n            current_path[0] = grid[start_x][start_y];\n            \n            // Parallel path generation\n            for (int step = 1; step < k; step++) {\n                vint32m1_t candidate_values = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n                \n                // Explore 4 directions in parallel\n                for (int dir = 0; dir < 4; dir++) {\n                    int new_x = start_x + dx[dir];\n                    int new_y = start_y + dy[dir];\n                    \n                    if (new_x >= 0 && new_x < N && new_y >= 0 && new_y < N) {\n                        vint32m1_t dir_value = __riscv_vmv_v_x_i32m1(grid[new_x][new_y], vl);\n                        candidate_values = __riscv_vmin_vv_i32m1(candidate_values, dir_value, vl);\n                    }\n                }\n                \n                // Select minimum value path\n                path_values = __riscv_vmin_vv_i32m1(path_values, candidate_values, vl);\n                current_path[step] = __riscv_vmv_x_v_i32m1(path_values);\n            }\n            \n            // Compare paths lexicographically\n            vbool32_t is_smaller = __riscv_vmslt_vv_i32m1_b32(\n                __riscv_vload_v_i32m1(current_path.data(), vl),\n                __riscv_vload_v_i32m1(result.data(), vl),\n                vl\n            );\n            \n            if (__riscv_vmfirst_m_b32(is_smaller, vl) != -1) {\n                result = current_path;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    // Determine number of digits\n    uint64_t temp = n;\n    int digit_count = 0;\n    while (temp > 0) {\n        temp /= 10;\n        digit_count++;\n    }\n\n    // Create vector to hold digits\n    vint8m1_t digits_vec = __riscv_vmv_v_x_i8m1(0, digit_count);\n    \n    // Extract digits\n    temp = n;\n    size_t vl = __riscv_vsetvl_e8m1(digit_count);\n    for (int i = digit_count - 1; i >= 0; i--) {\n        int8_t digit = temp % 10;\n        digits_vec = __riscv_vslide1down_vx_i8m1(digits_vec, digit, vl);\n        temp /= 10;\n    }\n\n    // Mask for odd digits\n    vbool8_t odd_mask = __riscv_vmsgtu_vx_i8m1_b8(digits_vec, 0, vl);\n    odd_mask = __riscv_vand_vm_b8(odd_mask, __riscv_vmseq_vx_i8m1_b8(digits_vec % 2, 1, vl), vl);\n\n    // Compute product of odd digits\n    vint64m1_t product_vec = __riscv_vmv_v_x_i64m1(1, 1);\n    vint8m1_t odd_digits = __riscv_vcompress_vm_i8m1(digits_vec, odd_mask, vl);\n    \n    for (size_t i = 0; i < __riscv_vcpop_m_b8(odd_mask, vl); i++) {\n        product_vec = __riscv_vmul_vx_i64m1(product_vec, odd_digits[i], 1);\n    }\n\n    return __riscv_vmv_x_s_i64m1_i64(product_vec);\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = 0;\n    do {\n        digits[len++] = n % 10;\n        n /= 10;\n    } while (n > 0);\n\n    // Reverse digits array\n    for (int i = 0; i < len / 2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[len - 1 - i];\n        digits[len - 1 - i] = temp;\n    }\n\n    // Use RVV to process digits\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    vint8m1_t v_digits = __riscv_vle8_v_i8m1(digits, vl);\n    \n    // Create mask for odd digits\n    vbool8_t mask = __riscv_vmseq_vx_i8m1_b8(v_digits % 2, 1, vl);\n    \n    // Keep only odd digits\n    vint8m1_t odd_digits = __riscv_vcompress_vm_i8m1(v_digits, mask, vl);\n    \n    // Compute product of odd digits\n    vint64m1_t product = __riscv_vmv_v_x_i64m1(1, vl);\n    for (size_t i = 0; i < vl; i++) {\n        if (__riscv_vmv_x_s_b8_b1(mask, i)) {\n            product = __riscv_vmul_vx_i64m1(product, __riscv_vmv_x_s_i8m1_i8(odd_digits, i), vl);\n        }\n    }\n    \n    return __riscv_vmv_x_s_i64m1_i64(product);\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = 0;\n    do {\n        digits[len++] = n % 10;\n        n /= 10;\n    } while (n > 0);\n\n    // Reverse digits array\n    for (int i = 0; i < len / 2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[len - 1 - i];\n        digits[len - 1 - i] = temp;\n    }\n\n    // Use RVV to process digits in parallel\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    vint8m1_t v_digits = __riscv_vle8_v_i8m1(digits, vl);\n    \n    // Create mask for odd digits\n    vbool8_t v_mask = __riscv_vmseq_vx_i8m1_b8(v_digits % 2, 1, vl);\n    \n    // Select odd digits\n    vint8m1_t v_odd_digits = __riscv_vcompress_vm_i8m1(v_digits, v_mask, vl);\n    \n    // Compute product of odd digits\n    uint64_t product = 1;\n    for (size_t i = 0; i < __riscv_vcpop_m_b8(v_mask, vl); i++) {\n        product *= v_odd_digits[i];\n    }\n\n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n\n    // Determine number of digits\n    uint64_t num = n;\n    int digit_count = 0;\n    while (num > 0) {\n        num /= 10;\n        digit_count++;\n    }\n\n    // Create vector to hold digits\n    vint8m1_t digits_vec = __riscv_vle8_v_i8m1(NULL, digit_count, __RISCV_VXRM_RNU, __RISCV_V_TAIL_AGNOSTIC);\n    \n    // Extract digits\n    num = n;\n    for (int i = digit_count - 1; i >= 0; i--) {\n        uint8_t digit = num % 10;\n        __riscv_vse8_v_i8m1(&digits_vec + i, digit, 1, __RISCV_VXRM_RNU, __RISCV_V_TAIL_AGNOSTIC);\n        num /= 10;\n    }\n\n    // Compute product of odd digits\n    vbool8_t mask = __riscv_vmseq_vx_i8m1_b8(digits_vec % 2, 1, digit_count, __RISCV_VXRM_RNU, __RISCV_V_TAIL_AGNOSTIC);\n    vint8m1_t odd_digits = __riscv_vcompress_vm_i8m1(digits_vec, mask, digit_count, __RISCV_VXRM_RNU, __RISCV_V_TAIL_AGNOSTIC);\n\n    // Reduce product\n    uint64_t product = 1;\n    for (int i = 0; i < __riscv_vcpop_m_b8(mask, digit_count, __RISCV_VXRM_RNU, __RISCV_V_TAIL_AGNOSTIC); i++) {\n        product *= odd_digits[i];\n    }\n\n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = 0;\n    do {\n        digits[len++] = n % 10;\n        n /= 10;\n    } while (n > 0);\n\n    // Reverse digits array\n    for (int i = 0; i < len / 2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[len - 1 - i];\n        digits[len - 1 - i] = temp;\n    }\n\n    // Use RVV to process digits\n    size_t vl = __riscv_vsetvl_e8m1(len);\n    vint8m1_t v_digits = __riscv_vle8_v_i8m1(digits, vl);\n    \n    // Create mask for odd digits\n    vbool8_t mask = __riscv_vmseq_vx_i8m1_b8(v_digits % 2, 1, vl);\n    \n    // Select odd digits\n    vint8m1_t odd_digits = __riscv_vcompress_vm_i8m1(v_digits, mask, vl);\n    \n    // Compute product of odd digits\n    uint64_t product = 1;\n    for (size_t i = 0; i < __riscv_vcpop_m_b8(mask, vl); i++) {\n        product *= odd_digits[i];\n    }\n\n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n\n    // If vector is empty, return 0\n    if (n == 0) return result;\n\n    // Set up vector length and mask\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t sum_vec = __riscv_vmv_v_x_f32m1(0, vl);\n\n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load vector chunk\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n\n        // Ceiling operation\n        vfloat32m1_t ceil_vec = __riscv_vfceil_v_f32m1(vec, vl);\n\n        // Square the values\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(ceil_vec, ceil_vec, vl);\n\n        // Reduce sum\n        vfloat32m1_t partial_sum = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        sum_vec = partial_sum;\n    }\n\n    // Convert final sum to uint64_t\n    result = (uint64_t)__riscv_vfmv_f_s_f32m1_f32(sum_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n    \n    // If vector is empty, return 0\n    if (n == 0) return result;\n    \n    // Set up vector configuration\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Initialize sum vector\n    vfloat32m1_t sum_vec = __riscv_vfmv_v_f_f32m1(0.0f, vl);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Ceiling operation using ceil intrinsic\n        vfloat32m1_t ceil_vec = __riscv_vfceil_v_f32m1(vec, vl);\n        \n        // Square the ceiling values\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(ceil_vec, ceil_vec, vl);\n        \n        // Accumulate sum\n        sum_vec = __riscv_vfadd_vv_f32m1(sum_vec, squared_vec, vl);\n    }\n    \n    // Reduce sum vector to scalar\n    result = (uint64_t)__riscv_vfmv_f_s_f32m1_f32(sum_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n    \n    // Use RVV vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t sum_vec = __riscv_vmv_v_x_f32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Determine vector length for this iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector of floats\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Ceiling operation using vceil intrinsic\n        vfloat32m1_t ceil_vec = __riscv_vfceil_v_f32m1(vec, vl);\n        \n        // Square each element\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(ceil_vec, ceil_vec, vl);\n        \n        // Reduce sum of squared elements\n        sum_vec = __riscv_vfredsum_vs_f32m1_f32m1(sum_vec, squared_vec, vl);\n    }\n    \n    // Extract final scalar sum\n    result = (uint64_t)__riscv_vfmv_f_s_f32m1_f32(sum_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n    \n    // If vector is empty, return 0\n    if (n == 0) return result;\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t sum_vec = __riscv_vmv_v_x_f32m1(0, vl);\n    \n    size_t i = 0;\n    for (; i + vl <= n; i += vl) {\n        // Load vector\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Ceiling operation using ceil intrinsic\n        vfloat32m1_t ceil_vec = __riscv_vfceil_v_f32m1(vec, vl);\n        \n        // Square the values\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(ceil_vec, ceil_vec, vl);\n        \n        // Add to sum vector\n        sum_vec = __riscv_vfadd_vv_f32m1(sum_vec, squared_vec, vl);\n    }\n    \n    // Reduce sum vector to scalar\n    result = __riscv_vfmv_f_s_f32m1_f32(sum_vec);\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        result += ceil_val * ceil_val;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64_t result = 0;\n    \n    // If vector is empty, return 0\n    if (n == 0) return result;\n    \n    // Set up vector length and initial parameters\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vfloat32m1_t sum_vec = __riscv_vmv_v_f_f32m1(0.0f, vl);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vfloat32m1_t vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Ceiling operation using vceil intrinsic\n        vfloat32m1_t ceil_vec = __riscv_vfceil_v_f32m1(vec, vl);\n        \n        // Square the ceiling values\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(ceil_vec, ceil_vec, vl);\n        \n        // Reduce sum of squared values\n        vfloat32m1_t chunk_sum = __riscv_vfredsum_vs_f32m1_f32m1(squared_vec, sum_vec, vl);\n        sum_vec = chunk_sum;\n    }\n    \n    // Convert final sum to uint64_t\n    result = static_cast<uint64_t>(__riscv_vfmv_f_s_f32m1_f32(sum_vec));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load the entire vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n\n    // Shift vector right by 1 for comparison\n    vint32m1_t shifted_vec = __riscv_vslideup_vx_i32m1(__riscv_vmv_v_x_i32m1(arr[0], vl), vec, 1, vl);\n\n    // Compare if current element is less than previous element\n    vbool32_t mask = __riscv_vmslt_vv_i32m1_b32(vec, shifted_vec, vl);\n\n    // Find first true index in mask\n    int result = __riscv_vfirst_m_b32(mask, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load first vector of elements\n    vint32m1_t prev = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool32_t mask_init = __riscv_vmseq_vv_i32m1_b32(prev, prev, vl);\n\n    int last_violation = -1;\n    size_t processed = 0;\n\n    while (processed < n - 1) {\n        // Load next vector of elements\n        size_t remaining = n - processed;\n        size_t current_vl = __riscv_vsetvl_e32m1(remaining);\n        \n        vint32m1_t curr = __riscv_vle32_v_i32m1(arr.data() + processed + 1, current_vl);\n        \n        // Compare current with previous vector\n        vbool32_t violation_mask = __riscv_vmslt_vv_i32m1_b32(curr, prev, current_vl);\n        \n        // Find first violation\n        int violation_index = __riscv_vfirst_m_b32(violation_mask, -1, current_vl);\n        \n        if (violation_index != -1) {\n            last_violation = processed + violation_index + 1;\n        }\n\n        // Shift previous vector\n        prev = curr;\n        processed += current_vl;\n    }\n\n    return last_violation;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load first vector of elements\n    vint32m1_t prev = __riscv_vle32_v_i32m1(arr.data(), vl);\n    vbool32_t mask = __riscv_vmslt_vv_i32m1_b32(prev, __riscv_vslidedown_vx_i32m1(prev, 1, vl), vl);\n\n    int result = -1;\n    for (int i = 1; i < n; i += vl) {\n        // Slide window and compare\n        vint32m1_t curr = __riscv_vle32_v_i32m1(arr.data() + i, vl);\n        vbool32_t curr_mask = __riscv_vmslt_vv_i32m1_b32(curr, __riscv_vslidedown_vx_i32m1(curr, 1, vl), vl);\n        \n        // Find first true in mask\n        int local_result = __riscv_vfirst_m_b32(curr_mask, vl);\n        if (local_result != -1) {\n            result = i + local_result;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n\n    // Load entire vector\n    vint32m1_t vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n\n    // Shift vector right by 1 for comparison\n    vint32m1_t shifted_vec = __riscv_vslidedown_vx_i32m1(vec, 1, vl);\n\n    // Compare if current element is less than previous element\n    vbool32_t mask = __riscv_vmslt_vv_i32m1_b32(vec, shifted_vec, vl);\n\n    // Find first true index in mask\n    int result = __riscv_vfirst_m_b32(mask, vl);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() <= 1) return -1;\n\n    size_t vl = arr.size();\n    size_t vlmax = __riscv_vsetvlmax_e32m1();\n    \n    // Prepare vector registers\n    vint32m1_t prev_vec, curr_vec;\n    vbool32_t mask;\n    \n    // Initial setup\n    prev_vec = __riscv_vle32_v_i32m1(arr.data(), vl);\n    \n    // Slide window and compare\n    for (size_t i = 1; i < vl; i += vlmax) {\n        size_t current_vl = __riscv_vsetvl_e32m1(vl - i);\n        \n        curr_vec = __riscv_vle32_v_i32m1(arr.data() + i, current_vl);\n        \n        // Check if current element is less than previous\n        mask = __riscv_vmslt_vv_i32m1_b32(curr_vec, prev_vec, current_vl);\n        \n        if (__riscv_vmfirst_m_b32(mask, current_vl) != -1) {\n            return i + __riscv_vmfirst_m_b32(mask, current_vl);\n        }\n        \n        prev_vec = curr_vec;\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return {0, 0};\n\n    // Initialize vector length and mask\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t largest_neg = __riscv_vmv_v_x_i32m1(INT_MIN, vl);\n    vint32m1_t smallest_pos = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load current chunk\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n        \n        // Create masks for negative and positive integers\n        vbool32_t neg_mask = __riscv_vmslt_vx_i32m1_b32(vec, 0, vl);\n        vbool32_t pos_mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, vl);\n        \n        // Update largest negative\n        vint32m1_t masked_neg = __riscv_vmerge_vvm_i32m1(vec, largest_neg, neg_mask, vl);\n        largest_neg = __riscv_vredmax_vs_i32m1_i32m1(masked_neg, largest_neg, vl);\n        \n        // Update smallest positive\n        vint32m1_t masked_pos = __riscv_vmerge_vvm_i32m1(vec, smallest_pos, pos_mask, vl);\n        smallest_pos = __riscv_vredmin_vs_i32m1_i32m1(masked_pos, smallest_pos, vl);\n    }\n    \n    // Extract final values\n    int max_neg = __riscv_vmv_x_s_i32m1_i32(largest_neg);\n    int min_pos = __riscv_vmv_x_s_i32m1_i32(smallest_pos);\n    \n    // Handle cases with no negative or positive integers\n    if (max_neg == INT_MIN) max_neg = 0;\n    if (min_pos == INT_MAX) min_pos = 0;\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return {0, 0};\n\n    // Initialize vector length and mask\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t largest_neg = __riscv_vmv_v_x_i32m1(INT_MIN, vl);\n    vint32m1_t smallest_pos = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load current chunk\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n        \n        // Create masks for negative and positive numbers\n        vbool32_t neg_mask = __riscv_vmslt_vx_i32m1_b32(vec, 0, vl);\n        vbool32_t pos_mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, vl);\n        \n        // Update largest negative\n        vint32m1_t masked_neg = __riscv_vmerge_vxm_i32m1(vec, INT_MIN, neg_mask, vl);\n        largest_neg = __riscv_vmax_vv_i32m1_m(neg_mask, largest_neg, largest_neg, masked_neg, vl);\n        \n        // Update smallest positive\n        vint32m1_t masked_pos = __riscv_vmerge_vxm_i32m1(vec, INT_MAX, pos_mask, vl);\n        smallest_pos = __riscv_vmin_vv_i32m1_m(pos_mask, smallest_pos, smallest_pos, masked_pos, vl);\n    }\n    \n    // Reduce to scalar values\n    int max_neg = __riscv_vmv_x_v_i32m1_i32(largest_neg);\n    int min_pos = __riscv_vmv_x_v_i32m1_i32(smallest_pos);\n    \n    // Handle edge cases\n    if (max_neg == INT_MIN) max_neg = 0;\n    if (min_pos == INT_MAX) min_pos = 0;\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return {0, 0};\n\n    // Initialize vector length and mask\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t largest_neg = __riscv_vmv_v_x_i32m1(INT_MIN, vl);\n    vint32m1_t smallest_pos = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load current chunk\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vl);\n        \n        // Create masks for negative and positive integers\n        vbool32_t neg_mask = __riscv_vmslt_vx_i32m1_b32(vec, 0, vl);\n        vbool32_t pos_mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, vl);\n        \n        // Update largest negative\n        vint32m1_t masked_neg = __riscv_vmerge_vvm_i32m1(vec, largest_neg, neg_mask, vl);\n        largest_neg = __riscv_vredmax_vs_i32m1_i32m1(masked_neg, largest_neg, vl);\n        \n        // Update smallest positive\n        vint32m1_t masked_pos = __riscv_vmerge_vvm_i32m1(vec, smallest_pos, pos_mask, vl);\n        smallest_pos = __riscv_vredmin_vs_i32m1_i32m1(masked_pos, smallest_pos, vl);\n    }\n    \n    // Extract final values\n    int max_neg = __riscv_vmv_x_s_i32m1_i32(largest_neg);\n    int min_pos = __riscv_vmv_x_s_i32m1_i32(smallest_pos);\n    \n    // Handle case where no negative/positive integers found\n    if (max_neg == INT_MIN) max_neg = 0;\n    if (min_pos == INT_MAX) min_pos = 0;\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = __riscv_vsetvl_e32m1(lst.size());\n    vint32m1_t max_neg = __riscv_vmv_v_x_i32m1(INT_MIN, vl);\n    vint32m1_t min_pos = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n    \n    for (size_t i = 0; i < lst.size(); i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(lst.size() - i);\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], vlmax);\n        \n        // Find max negative\n        vbool32_t neg_mask = __riscv_vmslt_vx_i32m1_b32(vec, 0, vlmax);\n        vint32m1_t max_neg_curr = __riscv_vmax_vv_i32m1_m(neg_mask, max_neg, max_neg, vec, vlmax);\n        max_neg = max_neg_curr;\n        \n        // Find min positive\n        vbool32_t pos_mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, vlmax);\n        vint32m1_t min_pos_curr = __riscv_vmin_vv_i32m1_m(pos_mask, min_pos, min_pos, vec, vlmax);\n        min_pos = min_pos_curr;\n    }\n    \n    int largest_neg = __riscv_vmv_x_v_i32m1_i32(max_neg);\n    int smallest_pos = __riscv_vmv_x_v_i32m1_i32(min_pos);\n    \n    if (largest_neg == INT_MIN) largest_neg = 0;\n    if (smallest_pos == INT_MAX) smallest_pos = 0;\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vl = __riscv_vsetvl_e32m1(lst.size());\n    vint32m1_t largest_neg = __riscv_vmv_v_x_i32m1(INT_MIN, vl);\n    vint32m1_t smallest_pos = __riscv_vmv_v_x_i32m1(INT_MAX, vl);\n    \n    for (size_t i = 0; i < lst.size(); i += vl) {\n        size_t remaining = lst.size() - i;\n        size_t current_vl = __riscv_vsetvl_e32m1(remaining);\n        \n        vint32m1_t vec = __riscv_vle32_v_i32m1(&lst[i], current_vl);\n        \n        vbool32_t neg_mask = __riscv_vmslt_vx_i32m1_b32(vec, 0, current_vl);\n        vbool32_t pos_mask = __riscv_vmsgt_vx_i32m1_b32(vec, 0, current_vl);\n        \n        largest_neg = __riscv_vmax_vv_i32m1_m(neg_mask, largest_neg, largest_neg, vec, current_vl);\n        smallest_pos = __riscv_vmin_vv_i32m1_m(pos_mask, smallest_pos, smallest_pos, vec, current_vl);\n    }\n    \n    int max_neg = __riscv_vmv_x_v_i32m1_i32(largest_neg);\n    int min_pos = __riscv_vmv_x_v_i32m1_i32(smallest_pos);\n    \n    max_neg = (max_neg == INT_MIN) ? 0 : max_neg;\n    min_pos = (min_pos == INT_MAX) ? 0 : min_pos;\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Vector length\n    size_t vl = __riscv_vsetvl_e64m1(n);\n\n    // Initialize result vector\n    vint64m1_t result_vec = __riscv_vmv_v_x_i64m1(1, vl);\n\n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        // Compute factorial of current number\n        vint64m1_t current_fact = __riscv_vmv_v_x_i64m1(1, vl);\n        for (uint64_t j = 1; j <= i; j++) {\n            current_fact = __riscv_vmul_vx_i64m1(current_fact, j, vl);\n        }\n\n        // Multiply result with current factorial\n        result_vec = __riscv_vmul_vv_i64m1(result_vec, current_fact, vl);\n    }\n\n    // Reduce vector to scalar\n    uint64_t result = __riscv_vmv_x_s_i64m1_i64(result_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    \n    // Initialize result vector\n    vint64m1_t result_vec = __riscv_vmv_v_x_i64m1(1, vl);\n    \n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        // Compute factorial of current number\n        uint64_t current_factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            current_factorial *= j;\n        }\n        \n        // Multiply result vector with current factorial\n        vint64m1_t current_vec = __riscv_vmv_v_x_i64m1(current_factorial, vl);\n        result_vec = __riscv_vmul_vv_i64m1(result_vec, current_vec, vl);\n    }\n    \n    // Reduce vector to scalar result\n    uint64_t result = __riscv_vmv_x_s_i64m1_i64(result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    \n    // Initialize result vector\n    vint64m1_t result_vec = __riscv_vmv_v_x_i64m1(1, vl);\n    \n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        // Compute factorial of current number\n        uint64_t current_factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            current_factorial *= j;\n        }\n        \n        // Multiply result vector with current factorial\n        vint64m1_t current_vec = __riscv_vmv_v_x_i64m1(current_factorial, vl);\n        result_vec = __riscv_vmul_vv_i64m1(result_vec, current_vec, vl);\n    }\n    \n    // Reduce vector to scalar result\n    uint64_t result = __riscv_vmv_x_s_i64m1_i64(result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    \n    // Initialize result vector\n    vint64m1_t result_vec = __riscv_vmv_v_x_i64m1(1, vl);\n    \n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        // Compute factorial of current number\n        uint64_t current_factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            current_factorial *= j;\n        }\n        \n        // Multiply result vector with current factorial\n        vint64m1_t current_vec = __riscv_vmv_v_x_i64m1(current_factorial, vl);\n        result_vec = __riscv_vmul_vv_i64m1(result_vec, current_vec, vl);\n    }\n    \n    // Reduce vector to scalar result\n    uint64_t result = __riscv_vmv_x_s_i64m1_i64(result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Vector length configuration\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    \n    // Initialize result vector\n    vint64m1_t result_vec = __riscv_vmv_v_x_i64m1(1, vl);\n    \n    // Compute factorial for each number from 1 to n\n    uint64_t result = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        // Compute factorial of current number\n        uint64_t current_factorial = 1;\n        for (uint64_t j = 1; j <= i; j++) {\n            current_factorial *= j;\n        }\n        \n        // Multiply result with current factorial\n        result *= current_factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    // Create vector length agnostic implementation\n    int sum = 0;\n    size_t vl;\n    vint32m1_t v_sum = vmv_v_x(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector\n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for indices multiple of 3\n        vbool32_t v_mask_3 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid_v_i32m1(vl), 3), 0, vl);\n        \n        // Create mask for indices multiple of 4 but not 3\n        vbool32_t v_mask_4 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid_v_i32m1(vl), 4), 0, vl);\n        vbool32_t v_mask_4_not_3 = vmandnot_mm_b32(v_mask_3, v_mask_4, vl);\n        \n        // Square values for indices multiple of 3\n        vint32m1_t v_squared = vmul_vv_i32m1_m(v_mask_3, v_data, v_data, vl);\n        \n        // Cube values for indices multiple of 4 but not 3\n        vint32m1_t v_cubed = vmul_vv_i32m1_m(v_mask_4_not_3, v_data, vmul_vv_i32m1(v_data, v_data, vl), vl);\n        \n        // Combine results\n        vint32m1_t v_result = vmerge_vvm_i32m1(v_mask_3, \n                               vmerge_vvm_i32m1(v_mask_4_not_3, v_data, v_cubed, vl), \n                               v_squared, vl);\n        \n        // Reduce sum\n        v_sum = vredsum_vs_i32m1_i32m1(v_sum, v_result, vl);\n    }\n\n    // Convert vector sum to scalar\n    sum = vmv_x_s_i32m1_i32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    // Create vector length agnostic implementation\n    int sum = 0;\n    size_t vl;\n    vint32m1_t v_sum = vmv_v_x(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector segment\n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for indices multiple of 3\n        vbool32_t v_mask_3 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid_v_i32m1(vl), 3), 0, vl);\n        \n        // Create mask for indices multiple of 4 but not 3\n        vbool32_t v_mask_4 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid_v_i32m1(vl), 4), 0, vl);\n        vbool32_t v_mask_4_not_3 = vmand_mm_b32(v_mask_4, vmnot_m_b32(v_mask_3, vl), vl);\n\n        // Square for indices multiple of 3\n        vint32m1_t v_squared = vmul_vv_i32m1_m(v_mask_3, v_data, v_data, vl);\n        \n        // Cube for indices multiple of 4 but not 3\n        vint32m1_t v_cubed = vmul_vv_i32m1_m(v_mask_4_not_3, v_data, vmul_vv_i32m1(v_data, v_data, vl), vl);\n\n        // Blend results\n        vint32m1_t v_result = vmerge_vvm_i32m1(v_mask_3, \n                               vmerge_vvm_i32m1(v_mask_4_not_3, v_data, v_cubed, vl), \n                               v_squared, vl);\n\n        // Reduce sum\n        v_sum = vredsum_vs_i32m1_i32m1(v_sum, v_result, vl);\n    }\n\n    // Convert vector sum to scalar\n    sum = vmv_x_s(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    // Create vector length agnostic implementation\n    int sum = 0;\n    size_t vl;\n    vint32m1_t v_sum = vmv_v_x(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector\n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for indices multiple of 3\n        vbool32_t v_mask_3 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid_v_i32m1(vl), 3), 0, vl);\n        \n        // Create mask for indices multiple of 4 but not 3\n        vbool32_t v_mask_4 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid_v_i32m1(vl), 4), 0, vl);\n        vbool32_t v_mask_4_not_3 = vmand_mm_b32(v_mask_4, vmnot_m_b32(v_mask_3, vl), vl);\n        \n        // Square entries for indices multiple of 3\n        vint32m1_t v_squared = vmul_vv_i32m1_m(v_mask_3, v_data, v_data, vl);\n        \n        // Cube entries for indices multiple of 4 but not 3\n        vint32m1_t v_cubed = vmul_vv_i32m1_m(v_mask_4_not_3, v_data, vmul_vv_i32m1(v_data, v_data, vl), vl);\n        \n        // Blend the results\n        vint32m1_t v_result = vmerge_vvm_i32m1(v_mask_3, \n                               vmerge_vvm_i32m1(v_mask_4_not_3, v_data, v_cubed, vl), \n                               v_squared, vl);\n        \n        // Accumulate sum\n        v_sum = vadd_vv_i32m1(v_sum, v_result, vl);\n    }\n\n    // Reduce vector sum to scalar\n    sum = vredsum_vs_i32m1_i32m1(v_sum, vmv_v_x(0, vl), vsetvl_e32m1(1));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    // Create vector length agnostic implementation\n    int sum = 0;\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n\n        // Load vector\n        vint32m1_t v_data = __riscv_vle32_v_i32m1(&lst[i], vl);\n\n        // Create mask for multiple of 3 indices\n        vbool32_t m_div3 = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(\n                __riscv_vid_v_i32m1(vl), \n                3, \n                vl\n            ), \n            0, \n            vl\n        );\n\n        // Create mask for multiple of 4 indices\n        vbool32_t m_div4 = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(\n                __riscv_vid_v_i32m1(vl), \n                4, \n                vl\n            ), \n            0, \n            vl\n        );\n\n        // Square values at multiple of 3 indices\n        vint32m1_t v_squared = __riscv_vmul_vv_i32m1_m(m_div3, v_data, v_data, vl);\n\n        // Cube values at multiple of 4 indices (not multiple of 3)\n        vbool32_t m_div4_not_div3 = __riscv_vmand_mm_b32(\n            m_div4, \n            __riscv_vmnot_m_b32(m_div3, vl), \n            vl\n        );\n        vint32m1_t v_cubed = __riscv_vmul_vv_i32m1_m(m_div4_not_div3, v_data, v_data, vl);\n        v_cubed = __riscv_vmul_vv_i32m1_m(m_div4_not_div3, v_cubed, v_data, vl);\n\n        // Combine squared and cubed values\n        vint32m1_t v_result = __riscv_vmerge_vvm_i32m1(v_data, v_squared, m_div3, vl);\n        v_result = __riscv_vmerge_vvm_i32m1(v_result, v_cubed, m_div4_not_div3, vl);\n\n        // Accumulate sum\n        v_sum = __riscv_vadd_vv_i32m1(v_sum, v_result, vl);\n    }\n\n    // Reduce vector sum to scalar\n    sum = __riscv_vmv_x_v_i32m1(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n\n    // Create vector length agnostic implementation\n    int sum = 0;\n    size_t vl;\n    vint32m1_t v_sum = vmv_v_x(0, vl);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector\n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for indices divisible by 3 or 4\n        vbool32_t v_mask_3 = vid_v_b32m1(vl);\n        vbool32_t v_mask_4 = vid_v_b32m1(vl);\n        v_mask_3 = vmseq_vx_b32m1(v_mask_3, 0, vl);\n        v_mask_4 = vmseq_vx_b32m1(v_mask_4, 0, vl);\n        \n        // Square entries divisible by 3\n        vint32m1_t v_squared = vmul_vv_i32m1(v_data, v_data, vl);\n        v_squared = vmerge_vvm_i32m1(v_mask_3, v_data, v_squared, vl);\n        \n        // Cube entries divisible by 4 but not 3\n        vbool32_t v_mask_4_not_3 = vmandn_mm_b32m1(v_mask_3, v_mask_4, vl);\n        vint32m1_t v_cubed = vmul_vv_i32m1(v_data, vmul_vv_i32m1(v_data, v_data, vl), vl);\n        v_cubed = vmerge_vvm_i32m1(v_mask_4_not_3, v_data, v_cubed, vl);\n        \n        // Combine results\n        v_sum = vadd_vv_i32m1(v_sum, v_cubed, vl);\n    }\n    \n    // Reduce vector sum to scalar\n    sum = vredsum_vs_i32m1_i32m1(v_sum, vmv_v_x(0, vl), vl);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    \n    // Check if vector is empty\n    if (n == 0) return 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Initialize count vector\n    vint32m1_t count_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for last iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&nums[i], vl);\n        \n        // Check > 10 condition\n        vbool32_t mask_gt_10 = __riscv_vmsgt_vx_i32m1_b32(vec, 10, vl);\n        \n        // First digit check (absolute value)\n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vl);\n        vint32m1_t first_digit = __riscv_vdivu_vx_i32m1(abs_vec, 10000, vl);\n        vbool32_t mask_first_odd = __riscv_vmseq_vx_i32m1_b32(first_digit % 2, 1, vl);\n        \n        // Last digit check\n        vint32m1_t last_digit = __riscv_vremu_vx_i32m1(abs_vec, 10, vl);\n        vbool32_t mask_last_odd = __riscv_vmseq_vx_i32m1_b32(last_digit % 2, 1, vl);\n        \n        // Combine masks\n        vbool32_t final_mask = __riscv_vmand_mm_b32(mask_gt_10, \n                                __riscv_vmand_mm_b32(mask_first_odd, mask_last_odd, vl), vl);\n        \n        // Count matching elements\n        vint32m1_t partial_count = __riscv_vcpop_m_b32(final_mask, vl);\n        count += __riscv_vmv_x_s_i32m1_i32(partial_count);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    \n    // Use maximum vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vint32m1_t v_nums = __riscv_vle32_v_i32m1(&nums[i], vl);\n        \n        // Create mask for numbers > 10\n        vbool32_t mask_gt_10 = __riscv_vfgt_vf_i32m1_b32(v_nums, 10, vl);\n        \n        // First digit check (absolute value)\n        vint32m1_t v_abs = __riscv_vabs_v_i32m1(v_nums, vl);\n        vint32m1_t v_first_digit = __riscv_vdiv_vx_i32m1(v_abs, 10, vl);\n        while (__riscv_vmsgt_vx_i32m1_b32(v_first_digit, 9, vl)) {\n            v_first_digit = __riscv_vdiv_vx_i32m1(v_first_digit, 10, vl);\n        }\n        \n        // Last digit check\n        vint32m1_t v_last_digit = __riscv_vrem_vx_i32m1(v_abs, 10, vl);\n        \n        // Mask for odd first and last digits\n        vbool32_t mask_first_odd = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(v_first_digit, 2, vl), 1, vl);\n        vbool32_t mask_last_odd = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(v_last_digit, 2, vl), 1, vl);\n        \n        // Combine masks\n        vbool32_t final_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(mask_gt_10, mask_first_odd, vl),\n            mask_last_odd, vl);\n        \n        // Count matching elements\n        count += __riscv_vcpop_m_b32(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    \n    // If vector is empty, return 0\n    if (n == 0) return 0;\n    \n    // Set vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Initialize count vector\n    vint32m1_t count_vec = __riscv_vmv_v_x_i32m1(0, vl);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for last iteration\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vint32m1_t vec = __riscv_vle32_v_i32m1(&nums[i], vl);\n        \n        // Check > 10 condition\n        vbool32_t mask_gt_10 = __riscv_vmsgt_vx_i32m1_b32(vec, 10, vl);\n        \n        // First digit check (absolute value)\n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vl);\n        vint32m1_t first_digit = __riscv_vdivu_vx_i32m1(abs_vec, 10000, vl);\n        vbool32_t first_odd = __riscv_vmseq_vx_i32m1_b32(first_digit % 2, 1, vl);\n        \n        // Last digit check\n        vint32m1_t last_digit = __riscv_vrem_vx_i32m1(abs_vec, 10, vl);\n        vbool32_t last_odd = __riscv_vmseq_vx_i32m1_b32(last_digit % 2, 1, vl);\n        \n        // Combine conditions\n        vbool32_t final_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(mask_gt_10, first_odd, vl),\n            last_odd, vl\n        );\n        \n        // Count matching elements\n        vint32m1_t chunk_count = __riscv_vcpop_m_b32(final_mask, vl);\n        count += __riscv_vmv_x_s_i32m1_i32(chunk_count);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    \n    // Use maximum vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        // Determine current vector length\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vint32m1_t v_nums = __riscv_vle32_v_i32m1(&nums[i], vlmax);\n        \n        // Create mask for numbers > 10\n        vbool32_t mask_gt_10 = __riscv_vfgt_vf_i32m1_b32(v_nums, 10, vlmax);\n        \n        // Process first and last digit check\n        vint32m1_t v_abs = __riscv_vabs_v_i32m1(v_nums, vlmax);\n        \n        // Get first digit mask\n        vint32m1_t first_digit = __riscv_vdiv_vx_i32m1(v_abs, 10, vlmax);\n        while (__riscv_vmsgt_vx_i32m1_b32(first_digit, 9, vlmax)) {\n            first_digit = __riscv_vdiv_vx_i32m1(first_digit, 10, vlmax);\n        }\n        vbool32_t first_odd_mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(first_digit, 2, vlmax), 1, vlmax);\n        \n        // Get last digit mask\n        vbool32_t last_odd_mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(v_abs, 2, vlmax), 1, vlmax);\n        \n        // Combine masks\n        vbool32_t final_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(mask_gt_10, first_odd_mask, vlmax),\n            last_odd_mask, vlmax);\n        \n        // Count matching elements\n        count += __riscv_vcpop_m_b32(final_mask, vlmax);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t n = nums.size();\n    \n    // Use maximum vector length\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create mask vector to track valid elements\n    vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(\n        __riscv_vle32_v_i32m1(nums.data(), vl), \n        __riscv_vmv_v_x_i32m1(0, vl), \n        vl\n    );\n    \n    for (size_t i = 0; i < n; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        // Load vector chunk\n        vint32m1_t vec = __riscv_vle32_v_i32m1(nums.data() + i, vl);\n        \n        // Check values > 10\n        vbool32_t gt_mask = __riscv_vmsgt_vx_i32m1_b32(vec, 10, vl);\n        \n        // First digit check (absolute value)\n        vint32m1_t abs_vec = __riscv_vabs_v_i32m1(vec, vl);\n        vint32m1_t first_digit = __riscv_vdivu_vx_i32m1(abs_vec, 10000, vl);\n        vbool32_t first_odd_mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(first_digit, 2, vl), \n            1, \n            vl\n        );\n        \n        // Last digit check\n        vint32m1_t last_digit = __riscv_vrem_vx_i32m1(abs_vec, 10, vl);\n        vbool32_t last_odd_mask = __riscv_vmseq_vx_i32m1_b32(\n            __riscv_vrem_vx_i32m1(last_digit, 2, vl), \n            1, \n            vl\n        );\n        \n        // Combine masks\n        vbool32_t combined_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(gt_mask, first_odd_mask, vl),\n            last_odd_mask, \n            vl\n        );\n        \n        // Count matching elements\n        count += __riscv_vcpop_m_b32(combined_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector with initial values\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t indices = __riscv_vid_v_i64m1(vl);\n    \n    // Compute a[i] = i * i - i + 1 using vector operations\n    vint64m1_t a = __riscv_vsub_vv_i64m1(\n        __riscv_vmul_vv_i64m1(indices, indices, vl), \n        indices, \n        vl\n    );\n    a = __riscv_vadd_vx_i64m1(a, 1, vl);\n    \n    uint64_t triples_count = 0;\n    \n    // Nested loops to check triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                int64_t ai = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, i, vl));\n                int64_t aj = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, j, vl));\n                int64_t ak = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, k, vl));\n                \n                if ((ai + aj + ak) % 3 == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n    \n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector with initial values\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t indices = __riscv_vid_v_i64m1(vl);\n    \n    // Compute a[i] = i * i - i + 1 using vector operations\n    vint64m1_t a = __riscv_vsub_vv_i64m1(\n        __riscv_vmul_vv_i64m1(indices, indices, vl),\n        indices, \n        vl\n    );\n    a = __riscv_vadd_vx_i64m1(a, 1, vl);\n    \n    uint64_t triples_count = 0;\n    \n    // Nested loops to check triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        int64_t ai = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, i, vl));\n        \n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            int64_t aj = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, j, vl));\n            \n            for (uint64_t k = j + 1; k < n; k++) {\n                int64_t ak = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, k, vl));\n                \n                if ((ai + aj + ak) % 3 == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n    \n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector with initial values\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t indices = __riscv_vid_v_i64m1(vl);\n    \n    // Compute a[i] = i * i - i + 1 using vector operations\n    vint64m1_t a = __riscv_vsub_vv_i64m1(\n        __riscv_vmul_vv_i64m1(indices, indices, vl),\n        indices, \n        vl\n    );\n    a = __riscv_vadd_vx_i64m1(a, 1, vl);\n    \n    uint64_t triples_count = 0;\n    \n    // Nested loops to check triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                int64_t val_i = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, i, vl));\n                int64_t val_j = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, j, vl));\n                int64_t val_k = __riscv_vmv_x_s(__riscv_vslide1down_vx_i64m1(a, k, vl));\n                \n                if ((val_i + val_j + val_k) % 3 == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n    \n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector with initial values\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vuint64m1_t indices = __riscv_vid_v_u64m1(vl);\n    \n    // Compute a[i] = i * i - i + 1 using vector operations\n    vuint64m1_t a = __riscv_vadd_vv_u64m1(\n        __riscv_vsub_vx_u64m1(\n            __riscv_vmul_vv_u64m1(indices, indices, vl), \n            indices, \n            vl\n        ), \n        __riscv_vmv_v_x_u64m1(1, vl), \n        vl\n    );\n\n    uint64_t triples_count = 0;\n    \n    // Nested loops to check triples\n    for (uint64_t i = 0; i < n - 2; i++) {\n        uint64_t ai = __riscv_vmv_x_s_u64m1_u64(\n            __riscv_vslidedown_vx_u64m1(a, i, vl)\n        );\n        \n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            uint64_t aj = __riscv_vmv_x_s_u64m1_u64(\n                __riscv_vslidedown_vx_u64m1(a, j, vl)\n            );\n            \n            for (uint64_t k = j + 1; k < n; k++) {\n                uint64_t ak = __riscv_vmv_x_s_u64m1_u64(\n                    __riscv_vslidedown_vx_u64m1(a, k, vl)\n                );\n                \n                if ((ai + aj + ak) % 3 == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n    \n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector with values i * i - i + 1\n    size_t vl = __riscv_vsetvl_e64m1(n);\n    vint64m1_t vec = __riscv_vid_v_i64m1(vl);\n    vint64m1_t vec_squared = __riscv_vmul_vv_i64m1(vec, vec, vl);\n    vint64m1_t vec_subtracted = __riscv_vsub_vv_i64m1(vec_squared, vec, vl);\n    vint64m1_t result_vec = __riscv_vadd_vx_i64m1(vec_subtracted, 1, vl);\n\n    // Count triples divisible by 3\n    uint64_t triples_count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                int64_t a_i = result_vec[i];\n                int64_t a_j = result_vec[j];\n                int64_t a_k = result_vec[k];\n                \n                if ((a_i + a_j + a_k) % 3 == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n\n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime\n    if (n <= 1) return y;\n    \n    // Vectorized primality check\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t divisors = __riscv_vid_v_i32m1(vl);\n    divisors = __riscv_vadd_vx_i32m1(divisors, 2, vl);\n    \n    vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(divisors, n, vl);\n    vint32m1_t remainders = __riscv_vrem_vv_i32m1(n, divisors, mask, vl);\n    \n    vbool32_t zero_mask = __riscv_vmseq_vx_i32m1_b32(remainders, 0, mask, vl);\n    \n    // If any divisor divides n evenly, it's not prime\n    if (__riscv_vmfirst_m_b32(zero_mask, vl) != -1) {\n        return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime\n    if (n <= 1) return y;\n    \n    size_t vl = __riscv_vsetvl_e32m1(1);\n    vint32m1_t v_n = __riscv_vmv_s_x_i32m1(n, vl);\n    \n    for (int i = 2; i * i <= n; i++) {\n        vint32m1_t v_i = __riscv_vmv_s_x_i32m1(i, vl);\n        vbool32_t mask = __riscv_vmsltu_vv_i32m1_b32(v_n, v_i, vl);\n        \n        if (__riscv_vmand_mm_b32(\n            __riscv_vmsne_vv_i32m1_b32(v_n, v_i, vl),\n            __riscv_vmeq_vx_i32m1_b32(v_n, 0, vl),\n            vl\n        )) {\n            return y;\n        }\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using vector operations\n    if (n <= 1) return y;\n    \n    // Use vector length agnostic approach\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    // Create vector for divisors\n    vint32m1_t divisors = __riscv_vid_v_i32m1(vl);\n    divisors = __riscv_vadd_vx_i32m1(divisors, 2, vl);\n    \n    // Mask for tracking potential prime\n    vbool32_t mask = __riscv_vmsltu_vx_i32m1_b32(divisors, n, vl);\n    \n    // Check divisibility\n    vint32m1_t remainders = __riscv_vrem_vv_i32m1(n, divisors, mask, vl);\n    vbool32_t div_mask = __riscv_vmseq_vx_i32m1_b32(remainders, 0, mask, vl);\n    \n    // If no divisors found, return x (prime)\n    if (!__riscv_vmfirst_m_b32(div_mask, vl)) {\n        return x;\n    }\n    \n    return y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using vector operations\n    if (n <= 1) return y;\n    \n    // Use vector length of 1 for scalar operations\n    size_t vl = __riscv_vsetvl_e32m1(1);\n    \n    // Iterate from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        // Check divisibility using vector comparison\n        vint32m1_t divisor = __riscv_vmv_v_x_i32m1(i, vl);\n        vint32m1_t remainder = __riscv_vrem_vv_i32m1(\n            __riscv_vmv_v_x_i32m1(n, vl), \n            divisor, \n            vl\n        );\n        \n        // If remainder is zero, n is not prime\n        if (__riscv_vmseq_vx_b1(remainder, 0, vl)) {\n            return y;\n        }\n    }\n    \n    // If no divisors found, n is prime\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime\n    if (n <= 1) return y;\n    \n    // Vectorized primality check\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    vint32m1_t divisors = __riscv_vid_v_i32m1(vl);\n    divisors = __riscv_vadd_vx_i32m1(divisors, 2, vl);\n    \n    vbool32_t mask = __riscv_vmslt_vx_i32m1_b32(divisors, n, vl);\n    vint32m1_t remainders = __riscv_vrem_vv_i32m1(n, divisors, mask, vl);\n    \n    vbool32_t is_divisible = __riscv_vmseq_vx_i32m1_b32(remainders, 0, mask, vl);\n    \n    // If no divisors found, n is prime\n    return __riscv_vmfirst_m_b32(is_divisible, vl) == -1 ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vuint32m1_t sum_vec = __riscv_vmv_v_x_u32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Create mask for odd positive integers\n        vbool32_t odd_mask = __riscv_vmfgt_vf_f32m1_b32(input_vec, 0, vl);\n        odd_mask = __riscv_vmand_mm_b32(\n            odd_mask, \n            __riscv_vmfeq_vf_f32m1_b32(\n                __riscv_vfrem_vf_f32m1(input_vec, 2.0f, vl), \n                1.0f, \n                vl\n            ), \n            vl\n        );\n        \n        // Square the odd positive integers\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1_m(odd_mask, input_vec, input_vec, vl);\n        \n        // Convert to unsigned int and sum\n        vuint32m1_t int_vec = __riscv_vfcvt_xu_f_v_u32m1_m(odd_mask, squared_vec, vl);\n        sum_vec = __riscv_vadd_vv_u32m1(sum_vec, int_vec, vl);\n    }\n    \n    // Horizontal sum\n    uint64_t total_sum = __riscv_vmv_x_s_u32m1_u64(sum_vec);\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vuint32m1_t sum_vec = __riscv_vmv_v_x_u32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(&lst[i], vlmax);\n        \n        // Create mask for odd positive integers\n        vbool32_t odd_mask = __riscv_vmflt_vf_f32m1_b32(input_vec, 0, vlmax);\n        odd_mask = __riscv_vmxor_mm_b32(odd_mask, odd_mask, vlmax);\n        \n        vbool32_t positive_mask = __riscv_vmfge_vf_f32m1_b32(input_vec, 0, vlmax);\n        vbool32_t integer_mask = __riscv_vmfeq_vf_f32m1_b32(input_vec, __riscv_vfround_vf_f32m1(input_vec, vlmax), vlmax);\n        \n        vbool32_t final_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(odd_mask, positive_mask, vlmax),\n            integer_mask, \n            vlmax\n        );\n        \n        // Square the values\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(input_vec, input_vec, vlmax);\n        \n        // Mask and sum\n        vuint32m1_t masked_sum = __riscv_vfmv_v_f_u32m1(0, vlmax);\n        masked_sum = __riscv_vfmv_v_f_u32m1_m(final_mask, masked_sum, __riscv_vfcvt_xu_f_v_u32m1(squared_vec, vlmax), vlmax);\n        \n        sum_vec = __riscv_vadd_vv_u32m1(sum_vec, masked_sum, vlmax);\n    }\n    \n    // Horizontal sum\n    uint64_t total_sum = __riscv_vmv_x_s_u32m1_u64(sum_vec);\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vuint32m1_t sum_vec = __riscv_vmv_v_x_u32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(&lst[i], vlmax);\n        \n        // Create mask for odd positive integers\n        vbool32_t odd_mask = __riscv_vmfgt_vf_f32m1_b32(input_vec, 0, vlmax);\n        odd_mask = __riscv_vmand_mm_b32(\n            odd_mask, \n            __riscv_vmfeq_vf_f32m1_b32(\n                __riscv_vfrem_vf_f32m1(input_vec, 2.0f, vlmax), \n                1.0f, \n                vlmax\n            ), \n            vlmax\n        );\n        \n        // Square the odd positive integers\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1_m(odd_mask, input_vec, input_vec, vlmax);\n        \n        // Convert to unsigned int and sum\n        vuint32m1_t uint_vec = __riscv_vfcvt_xu_f_v_u32m1_m(odd_mask, squared_vec, vlmax);\n        vuint32m1_t partial_sum = __riscv_vredsum_vs_u32m1_u32m1(uint_vec, sum_vec, vlmax);\n        \n        sum_vec = partial_sum;\n    }\n    \n    // Reduce to scalar\n    return __riscv_vmv_x_s_u32m1_u64(sum_vec);\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vuint32m1_t sum_vec = __riscv_vmv_v_x_u32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Create mask for odd positive integers\n        vbool32_t odd_mask = __riscv_vmfgt_vf_f32m1_b32(input_vec, 0, vl);\n        vbool32_t integer_mask = __riscv_vmfeq_vf_f32m1_b32(input_vec, __builtin_floorf(input_vec), vl);\n        vbool32_t odd_int_mask = __riscv_vmand_mm_b32(odd_mask, integer_mask, vl);\n        \n        // Square the odd integers\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1(input_vec, input_vec, vl);\n        \n        // Mask the squared values\n        vfloat32m1_t masked_squared = __riscv_vfmerge_vfm_f32m1(squared_vec, 0, odd_int_mask, vl);\n        \n        // Reduce sum\n        vuint32m1_t masked_sum = __riscv_vfcvt_xu_f_v_u32m1(masked_squared, vl);\n        sum_vec = __riscv_vadd_vv_u32m1(sum_vec, masked_sum, vl);\n    }\n    \n    // Horizontal sum\n    uint64_t total_sum = __riscv_vmv_x_s_u32m1_u64(sum_vec);\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t n = lst.size();\n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    vuint32m1_t sum_vec = __riscv_vmv_v_x_u32m1(0, vl);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = __riscv_vsetvl_e32m1(n - i);\n        \n        vfloat32m1_t input_vec = __riscv_vle32_v_f32m1(&lst[i], vl);\n        \n        // Create mask for odd positive integers\n        vbool32_t odd_mask = __riscv_vmfgt_vf_f32m1_b32(input_vec, 0, vl);\n        vbool32_t integer_mask = __riscv_vmfge_vf_f32m1_b32(input_vec, 0, vl);\n        vbool32_t frac_mask = __riscv_vmfne_vv_f32m1_b32(\n            __riscv_vfrem_vf_f32m1(input_vec, 1.0f, vl), \n            __riscv_vfmv_v_f_f32m1(0.0f, vl), \n            vl\n        );\n        \n        vbool32_t final_mask = __riscv_vmand_mm_b32(\n            __riscv_vmand_mm_b32(odd_mask, integer_mask, vl),\n            __riscv_vmnot_m_b32(frac_mask, vl),\n            vl\n        );\n        \n        // Square the odd integers\n        vfloat32m1_t squared_vec = __riscv_vfmul_vv_f32m1_m(final_mask, input_vec, input_vec, vl);\n        \n        // Convert to unsigned int and sum\n        vuint32m1_t uint_squared = __riscv_vfcvt_xu_f_v_u32m1_m(final_mask, squared_vec, vl);\n        \n        sum_vec = __riscv_vadd_vv_u32m1_m(final_mask, sum_vec, uint_squared, vl);\n    }\n    \n    // Horizontal sum\n    uint64_t total_sum = __riscv_vmv_x_s_u32m1_u64(sum_vec);\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t game_vec = __riscv_vle32_v_i32m1(game.data() + i, vlmax);\n        vint32m1_t guess_vec = __riscv_vle32_v_i32m1(guess.data() + i, vlmax);\n        \n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(game_vec, guess_vec, vlmax);\n        vint32m1_t abs_diff_vec = __riscv_vabs_v_i32m1(diff_vec, vlmax);\n        \n        __riscv_vse32_v_i32m1(result.data() + i, abs_diff_vec, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t game_vec = __riscv_vle32_v_i32m1(game.data() + i, vlmax);\n        vint32m1_t guess_vec = __riscv_vle32_v_i32m1(guess.data() + i, vlmax);\n        \n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(game_vec, guess_vec, vlmax);\n        vint32m1_t abs_diff_vec = __riscv_vabs_v_i32m1(diff_vec, vlmax);\n        \n        __riscv_vse32_v_i32m1(result.data() + i, abs_diff_vec, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t game_vec = __riscv_vle32_v_i32m1(game.data() + i, vlmax);\n        vint32m1_t guess_vec = __riscv_vle32_v_i32m1(guess.data() + i, vlmax);\n        \n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(game_vec, guess_vec, vlmax);\n        vint32m1_t abs_diff_vec = __riscv_vabs_v_i32m1(diff_vec, vlmax);\n        \n        __riscv_vse32_v_i32m1(result.data() + i, abs_diff_vec, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t game_vec = __riscv_vle32_v_i32m1(game.data() + i, vlmax);\n        vint32m1_t guess_vec = __riscv_vle32_v_i32m1(guess.data() + i, vlmax);\n        \n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(game_vec, guess_vec, vlmax);\n        vint32m1_t abs_diff_vec = __riscv_vabs_v_i32m1(diff_vec, vlmax);\n        \n        __riscv_vse32_v_i32m1(result.data() + i, abs_diff_vec, vlmax);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vl = __riscv_vsetvl_e32m1(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t vlmax = __riscv_vsetvl_e32m1(n - i);\n        \n        vint32m1_t game_vec = __riscv_vle32_v_i32m1(game.data() + i, vlmax);\n        vint32m1_t guess_vec = __riscv_vle32_v_i32m1(guess.data() + i, vlmax);\n        \n        vint32m1_t diff_vec = __riscv_vsub_vv_i32m1(game_vec, guess_vec, vlmax);\n        vint32m1_t abs_diff_vec = __riscv_vabs_v_i32m1(diff_vec, vlmax);\n        \n        __riscv_vse32_v_i32m1(result.data() + i, abs_diff_vec, vlmax);\n    }\n    \n    return result;\n}\n```"}

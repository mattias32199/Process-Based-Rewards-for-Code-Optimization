{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Load mask values and convert to integer mask\n        __m128i mask_vec = _mm_set_epi64x(\n            mask[i+1] ? 0xFFFFFFFFFFFFFFFF : 0,\n            mask[i] ? 0xFFFFFFFFFFFFFFFF : 0\n        );\n        \n        // Conditionally move elements using bitwise AND with mask\n        __m128i result = _mm_and_si128(src_vec, mask_vec);\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)&dst[i]);\n        result = _mm_or_si128(_mm_andnot_si128(mask_vec, dst_vec), result);\n        \n        // Store result back to destination\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 source values\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Load mask values and convert to integer mask\n        __m128i mask_vec = _mm_setzero_si128();\n        mask_vec = _mm_insert_epi64(mask_vec, mask[i], 0);\n        mask_vec = _mm_insert_epi64(mask_vec, mask[i+1], 1);\n        \n        // Create comparison mask\n        __m128i cmp_mask = _mm_cmpeq_epi64(mask_vec, _mm_cmpeq_epi64(mask_vec, mask_vec));\n        \n        // Conditionally move source values to destination\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)&dst[i]);\n        dst_vec = _mm_blendv_epi8(dst_vec, src_vec, cmp_mask);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&dst[i], dst_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Load mask values and convert to integer mask\n        __m128i mask_vec = _mm_set_epi64x(\n            mask[i+1] ? 0xFFFFFFFFFFFFFFFF : 0,\n            mask[i] ? 0xFFFFFFFFFFFFFFFF : 0\n        );\n        \n        // Conditionally move using bitwise AND with mask\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)&dst[i]);\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(src_vec, mask_vec),\n            _mm_andnot_si128(mask_vec, dst_vec)\n        );\n        \n        // Store result back to destination\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using SSE2\n    for (; i + 1 < length; i += 2) {\n        // Load 2 source values\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Convert mask to integer mask\n        int mask_val = (mask[i+1] << 1) | mask[i];\n        \n        // Blend source values based on mask\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)&dst[i]);\n        __m128i result = _mm_blendv_epi8(dst_vec, src_vec, _mm_set1_epi64x(mask_val ? -1 : 0));\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Load mask values and convert to integer mask\n        __m128i mask_vec = _mm_set_epi64x(\n            mask[i+1] ? 0xFFFFFFFFFFFFFFFF : 0,\n            mask[i] ? 0xFFFFFFFFFFFFFFFF : 0\n        );\n        \n        // Conditionally move source elements to destination\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)&dst[i]);\n        __m128i result = _mm_blendv_epi8(dst_vec, src_vec, mask_vec);\n        \n        // Store result back to destination\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining single element if length is odd\n    if (i < length) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from src\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Multiply each element by scale\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // Calculate tmp1 (right shift by 3)\n        __m128i tmp1_vec = _mm_srai_epi32(scaled_vec, 3);\n        \n        // Calculate tmp2 (left shift by 3)\n        __m128i tmp2_vec = _mm_slli_epi32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        __m128i tmp_mul_vec = _mm_mullo_epi32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        __m128i result_vec = _mm_add_epi32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        __m128i div_vec = _mm_set1_epi32(7);\n        result_vec = _mm_div_epi32(result_vec, div_vec);\n        \n        // Store results in dst\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 integers from src\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Multiply each element by scale\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // tmp1: right shift by 3 bits\n        __m128i tmp1_vec = _mm_srai_epi32(scaled_vec, 3);\n        \n        // tmp2: left shift by 3 bits\n        __m128i tmp2_vec = _mm_slli_epi32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        __m128i tmp_mul_vec = _mm_mullo_epi32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        __m128i result_vec = _mm_add_epi32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        __m128i div_vec = _mm_div_epi32(result_vec, _mm_set1_epi32(7));\n        \n        // Store results in dst\n        _mm_storeu_si128((__m128i*)&dst[i], div_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from src\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Multiply each element by scale\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // tmp1: right shift by 3\n        __m128i tmp1_vec = _mm_srai_epi32(scaled_vec, 3);\n        \n        // tmp2: left shift by 3\n        __m128i tmp2_vec = _mm_slli_epi32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        __m128i tmp_mul_vec = _mm_mullo_epi32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        __m128i result_vec = _mm_add_epi32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        __m128i div_vec = _mm_div_epi32(result_vec, _mm_set1_epi32(7));\n        \n        // Store results in dst\n        _mm_storeu_si128((__m128i*)&dst[i], div_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Multiply source elements by scale\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // tmp1: right shift by 3 bits\n        __m128i tmp1_vec = _mm_srai_epi32(scaled_vec, 3);\n        \n        // tmp2: left shift by 3 bits\n        __m128i tmp2_vec = _mm_slli_epi32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        __m128i tmp_mul_vec = _mm_mullo_epi32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        __m128i result_vec = _mm_add_epi32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        result_vec = _mm_div_epi32(result_vec, _mm_set1_epi32(7));\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        // Load 4 integers from src\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Multiply each element by scale\n        __m128i scaled_vec = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // tmp1: right shift by 3 bits\n        __m128i tmp1_vec = _mm_srai_epi32(scaled_vec, 3);\n        \n        // tmp2: left shift by 3 bits\n        __m128i tmp2_vec = _mm_slli_epi32(scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        __m128i tmp_mul_vec = _mm_mullo_epi32(tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_mul_vec\n        __m128i result_vec = _mm_add_epi32(scaled_vec, tmp_mul_vec);\n        \n        // Divide by 7\n        __m128i div_vec = _mm_div_epi32(result_vec, _mm_set1_epi32(7));\n        \n        // Store results in dst\n        _mm_storeu_si128((__m128i*)&dst[i], div_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        // Load 2 doubles from src at the strided positions\n        __m128d vec1 = _mm_loadu_pd(src + (i * cols + stride));\n        __m128d vec2 = _mm_loadu_pd(src + ((i + 1) * cols + stride));\n        \n        // Store 2 doubles into dst\n        _mm_storeu_pd(dst + i, vec1);\n        _mm_storeu_pd(dst + i + 1, vec2);\n    }\n    \n    // Handle remaining row if rows is odd\n    if (i < rows) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        // Load 2 doubles from src at strided positions\n        __m128d vec1 = _mm_loaddup_pd(&src[i * cols + stride]);\n        __m128d vec2 = _mm_loaddup_pd(&src[(i+1) * cols + stride]);\n\n        // Store 2 doubles to dst\n        _mm_storeu_pd(&dst[i], vec1);\n        _mm_storeu_pd(&dst[i+1], vec2);\n    }\n\n    // Handle remaining row if rows is odd\n    if (i < rows) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        // Load 2 doubles from src at strided positions\n        __m128d vec1 = _mm_loaddup_pd(&src[(i * cols) + stride]);\n        __m128d vec2 = _mm_loaddup_pd(&src[((i+1) * cols) + stride]);\n        \n        // Store 2 doubles to dst\n        _mm_storeu_pd(&dst[i], vec1);\n        _mm_storeu_pd(&dst[i+1], vec2);\n    }\n    \n    // Handle any remaining row\n    if (i < rows) {\n        dst[i] = src[(i * cols) + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i = 0;\n    \n    // Process 2 doubles at a time using SSE2 \n    for (; i + 1 < rows; i += 2) {\n        __m128d vec1 = _mm_loadu_pd(src + (i * cols + stride));\n        __m128d vec2 = _mm_loadu_pd(src + ((i + 1) * cols + stride));\n        \n        _mm_storeu_pd(dst + i, vec1);\n        _mm_storeu_pd(dst + i + 1, vec2);\n    }\n    \n    // Handle remaining rows if rows is odd\n    if (i < rows) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t i = 0;\n    for (; i + 1 < rows; i += 2) {\n        // Load 2 doubles from src at strided positions\n        __m128d vec1 = _mm_loaddup_pd(&src[i * cols + stride]);\n        __m128d vec2 = _mm_loaddup_pd(&src[(i+1) * cols + stride]);\n\n        // Store 2 doubles to dst\n        _mm_storeu_pd(&dst[i], vec1);\n        _mm_storeu_pd(&dst[i+1], vec2);\n    }\n\n    // Handle remaining row if rows is odd\n    if (i < rows) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Gather operation: Load indices and use them to gather values from source\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 gathered_values = _mm_set_ps(\n            src[_mm_extract_epi32(idx_vec, 3)],\n            src[_mm_extract_epi32(idx_vec, 2)], \n            src[_mm_extract_epi32(idx_vec, 1)], \n            src[_mm_extract_epi32(idx_vec, 0)]\n        );\n        \n        // Store gathered values to destination\n        _mm_storeu_ps(&dst[i], gathered_values);\n    }\n    \n    // Scatter operation: Store source values at indexed locations\n    for (; i + 4 <= length; i += 4) {\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_values = _mm_loadu_ps(&src[i]);\n        \n        // Scatter: Store each value at its corresponding index\n        dst[_mm_extract_epi32(idx_vec, 0)] = _mm_cvtss_f32(src_values);\n        dst[_mm_extract_epi32(idx_vec, 1)] = _mm_cvtss_f32(_mm_shuffle_ps(src_values, src_values, 1));\n        dst[_mm_extract_epi32(idx_vec, 2)] = _mm_cvtss_f32(_mm_shuffle_ps(src_values, src_values, 2));\n        dst[_mm_extract_epi32(idx_vec, 3)] = _mm_cvtss_f32(_mm_shuffle_ps(src_values, src_values, 3));\n    }\n    \n    // Handle remaining elements if length is not multiple of 4\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Gather operation: Load indices and use them to gather values from source\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 gathered_values = _mm_set_ps(\n            src[_mm_extract_epi32(idx_vec, 3)],\n            src[_mm_extract_epi32(idx_vec, 2)],\n            src[_mm_extract_epi32(idx_vec, 1)],\n            src[_mm_extract_epi32(idx_vec, 0)]\n        );\n        \n        // Store gathered values to destination\n        _mm_storeu_ps(&dst[i], gathered_values);\n    }\n    \n    // Scatter operation: Store source values at indexed locations\n    for (; i + 4 <= length; i += 4) {\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        __m128 src_values = _mm_loadu_ps(&src[i]);\n        \n        // Scatter store using individual extractions\n        dst[_mm_extract_epi32(idx_vec, 0)] = _mm_cvtss_f32(src_values);\n        dst[_mm_extract_epi32(idx_vec, 1)] = _mm_cvtss_f32(_mm_shuffle_ps(src_values, src_values, 1));\n        dst[_mm_extract_epi32(idx_vec, 2)] = _mm_cvtss_f32(_mm_shuffle_ps(src_values, src_values, 2));\n        dst[_mm_extract_epi32(idx_vec, 3)] = _mm_cvtss_f32(_mm_shuffle_ps(src_values, src_values, 3));\n    }\n    \n    // Handle remaining elements if length is not multiple of 4\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        \n        // Gather: Load values from source using indices\n        __m128 gathered_values = _mm_set_ps(\n            src[_mm_extract_epi32(idx_vec, 3)],\n            src[_mm_extract_epi32(idx_vec, 2)],\n            src[_mm_extract_epi32(idx_vec, 1)],\n            src[_mm_extract_epi32(idx_vec, 0)]\n        );\n        \n        // Store gathered values to destination\n        _mm_storeu_ps(&dst[i], gathered_values);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        \n        // Gather: Load values from source using indices\n        __m128 gathered_vals = _mm_set_ps(\n            src[_mm_extract_epi32(idx_vec, 3)],\n            src[_mm_extract_epi32(idx_vec, 2)], \n            src[_mm_extract_epi32(idx_vec, 1)],\n            src[_mm_extract_epi32(idx_vec, 0)]\n        );\n        \n        // Scatter: Store gathered values to destination using indices\n        dst[_mm_extract_epi32(idx_vec, 0)] = _mm_cvtss_f32(gathered_vals);\n        dst[_mm_extract_epi32(idx_vec, 1)] = _mm_cvtss_f32(_mm_shuffle_ps(gathered_vals, gathered_vals, 1));\n        dst[_mm_extract_epi32(idx_vec, 2)] = _mm_cvtss_f32(_mm_shuffle_ps(gathered_vals, gathered_vals, 2));\n        dst[_mm_extract_epi32(idx_vec, 3)] = _mm_cvtss_f32(_mm_shuffle_ps(gathered_vals, gathered_vals, 3));\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load indices\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&indices[i]);\n        \n        // Gather: Load values from source using indices\n        __m128 gathered_values = _mm_set_ps(\n            src[_mm_extract_epi32(idx_vec, 3)],\n            src[_mm_extract_epi32(idx_vec, 2)],\n            src[_mm_extract_epi32(idx_vec, 1)],\n            src[_mm_extract_epi32(idx_vec, 0)]\n        );\n        \n        // Store gathered values to destination\n        _mm_storeu_ps(&dst[i], gathered_values);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter: Write back to source locations\n    for (i = 0; i < length; i++) {\n        src[indices[i]] = dst[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t length = end - start + 1;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    uint64_t vectorized_length = length - (length % 8);\n    \n    for (uint64_t i = 0; i < vectorized_length; i += 8) {\n        // Load 8 elements from the start and end of the range\n        __m128i start_vec = _mm_loadu_si128((__m128i*)&arr[start + i]);\n        __m128i end_vec = _mm_loadu_si128((__m128i*)&arr[end - i - 7]);\n        \n        // Shuffle the elements to reverse the order\n        start_vec = _mm_shuffle_epi32(start_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        start_vec = _mm_shufflehi_epi16(start_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        start_vec = _mm_shufflelo_epi16(start_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        end_vec = _mm_shuffle_epi32(end_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        end_vec = _mm_shufflehi_epi16(end_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        end_vec = _mm_shufflelo_epi16(end_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Store the reversed elements back to the array\n        _mm_storeu_si128((__m128i*)&arr[start + i], end_vec);\n        _mm_storeu_si128((__m128i*)&arr[end - i - 7], start_vec);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = vectorized_length; i < length; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If range is invalid or less than 2 elements, no reversal needed\n    if (start >= end) return;\n\n    // Calculate number of elements to reverse\n    uint64_t range_length = end - start + 1;\n\n    // Process 8 elements at a time using SSE2 intrinsics\n    uint64_t simd_end = start + ((range_length / 8) * 8);\n    \n    for (uint64_t i = start; i < simd_end; i += 8) {\n        // Load 8 elements\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Shuffle to reverse order of 8 elements\n        vec = _mm_shuffle_epi32(vec, _MM_SHUFFLE(1, 0, 3, 2));\n        vec = _mm_shufflehi_epi16(vec, _MM_SHUFFLE(0, 1, 2, 3));\n        vec = _mm_shufflelo_epi16(vec, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Store reversed elements back\n        _mm_storeu_si128((__m128i*)&arr[start + end - i - 7], vec);\n    }\n\n    // Handle remaining elements\n    for (uint64_t i = simd_end; i <= end; i++) {\n        int16_t temp = arr[i];\n        arr[i] = arr[start + end - i];\n        arr[start + end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If range is invalid or less than 2 elements, no reversal needed\n    if (start >= end) return;\n\n    // Calculate the number of elements to reverse\n    uint64_t range_length = end - start + 1;\n    uint64_t simd_length = range_length / 8 * 8;  // Number of elements processed by SIMD\n    uint64_t scalar_length = range_length % 8;    // Remaining elements to process scalar\n\n    // SIMD processing\n    for (uint64_t i = 0; i < simd_length; i += 8) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - i - 7]);\n\n        // Shuffle to reverse the 8 elements\n        __m128i reversed_left = _mm_shuffle_epi32(left, _MM_SHUFFLE(0, 1, 2, 3));\n        reversed_left = _mm_shufflehi_epi16(reversed_left, _MM_SHUFFLE(0, 1, 2, 3));\n        reversed_left = _mm_shufflelo_epi16(reversed_left, _MM_SHUFFLE(0, 1, 2, 3));\n\n        __m128i reversed_right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        reversed_right = _mm_shufflehi_epi16(reversed_right, _MM_SHUFFLE(0, 1, 2, 3));\n        reversed_right = _mm_shufflelo_epi16(reversed_right, _MM_SHUFFLE(0, 1, 2, 3));\n\n        // Store reversed elements back\n        _mm_storeu_si128((__m128i*)&arr[start + i], reversed_right);\n        _mm_storeu_si128((__m128i*)&arr[end - i - 7], reversed_left);\n    }\n\n    // Handle remaining elements scalar\n    for (uint64_t i = 0; i < scalar_length; i++) {\n        int16_t temp = arr[start + simd_length + i];\n        arr[start + simd_length + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // If range is invalid or less than 2 elements, no reversal needed\n    if (start >= end) return;\n\n    // Number of elements in the range\n    uint64_t range_length = end - start + 1;\n\n    // Process 8 elements at a time using SSE2 \n    uint64_t simd_end = start + ((range_length / 8) * 8);\n    \n    for (uint64_t i = start, j = end; i < j; i += 8, j -= 8) {\n        // Load 8 elements from start and end of range\n        __m128i start_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i end_vec = _mm_loadu_si128((__m128i*)&arr[j-7]);\n\n        // Reverse elements within each vector\n        start_vec = _mm_shuffle_epi32(start_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        start_vec = _mm_shufflehi_epi16(start_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        start_vec = _mm_shufflelo_epi16(start_vec, _MM_SHUFFLE(0, 1, 2, 3));\n\n        end_vec = _mm_shuffle_epi32(end_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        end_vec = _mm_shufflehi_epi16(end_vec, _MM_SHUFFLE(0, 1, 2, 3));\n        end_vec = _mm_shufflelo_epi16(end_vec, _MM_SHUFFLE(0, 1, 2, 3));\n\n        // Store reversed vectors in swapped positions\n        _mm_storeu_si128((__m128i*)&arr[j-7], start_vec);\n        _mm_storeu_si128((__m128i*)&arr[i], end_vec);\n    }\n\n    // Handle remaining elements if range length is not multiple of 8\n    for (uint64_t i = simd_end; i < end; i++, end--) {\n        int16_t temp = arr[i];\n        arr[i] = arr[end];\n        arr[end] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t count = end - start + 1;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    uint64_t vectorized_count = count & ~7;\n    for (uint64_t i = 0; i < vectorized_count; i += 8) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[start + i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[end - i - 7]);\n        \n        // Shuffle to reverse the order of 16-bit integers\n        left = _mm_shufflehi_epi16(left, _MM_SHUFFLE(0, 1, 2, 3));\n        left = _mm_shufflelo_epi16(left, _MM_SHUFFLE(0, 1, 2, 3));\n        left = _mm_shuffle_epi32(left, _MM_SHUFFLE(1, 0, 3, 2));\n        \n        right = _mm_shufflehi_epi16(right, _MM_SHUFFLE(0, 1, 2, 3));\n        right = _mm_shufflelo_epi16(right, _MM_SHUFFLE(0, 1, 2, 3));\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(1, 0, 3, 2));\n        \n        // Store reversed elements\n        _mm_storeu_si128((__m128i*)&arr[start + i], right);\n        _mm_storeu_si128((__m128i*)&arr[end - i - 7], left);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = vectorized_count; i < count; i++) {\n        int16_t temp = arr[start + i];\n        arr[start + i] = arr[end - i];\n        arr[end - i] = temp;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    \n    // Process 16 bytes (128 bits) at a time using SSE\n    size_t vec_width = 16;\n    size_t vec_iterations = (dim1 * dim2 * sizeof(uint8_t)) / vec_width;\n    \n    for (size_t i = 0; i < vec_iterations; ++i) {\n        // Load 16 bytes from the tensor slice\n        __m128i tensor_vec = _mm_loadu_si128((__m128i*)(tensor + slice_offset + i * vec_width));\n        \n        // Store 16 bytes to the output slice\n        _mm_storeu_si128((__m128i*)(slice + i * vec_width), tensor_vec);\n    }\n    \n    // Handle any remaining elements\n    size_t remaining = (dim1 * dim2 * sizeof(uint8_t)) % vec_width;\n    for (size_t i = vec_iterations * vec_width; i < dim1 * dim2; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    \n    // Process 16 bytes (128 bits) at a time using SSE\n    size_t vec_width = 16;\n    size_t vec_count = (dim1 * dim2) / vec_width;\n    size_t remainder = (dim1 * dim2) % vec_width;\n    \n    // Vectorized copy using SSE intrinsics\n    for (size_t i = 0; i < vec_count; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)(tensor + slice_offset + i * vec_width));\n        _mm_storeu_si128((__m128i*)(slice + i * vec_width), vec);\n    }\n    \n    // Handle any remaining elements\n    for (size_t i = vec_count * vec_width; i < dim1 * dim2; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    \n    // Process 16 bytes (128 bits) at a time using SSE\n    size_t vec_width = 16;\n    size_t vec_count = (dim1 * dim2) / vec_width;\n    size_t remainder = (dim1 * dim2) % vec_width;\n    \n    // Pointer to the start of the slice in the original tensor\n    const uint8_t *slice_start = tensor + slice_offset;\n    \n    // SIMD vectorized copy\n    for (size_t i = 0; i < vec_count; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)(slice_start + i * vec_width));\n        _mm_storeu_si128((__m128i*)(slice + i * vec_width), vec);\n    }\n    \n    // Handle any remaining elements\n    for (size_t i = vec_count * vec_width; i < dim1 * dim2; ++i) {\n        slice[i] = slice_start[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    \n    // Process 16 bytes (128 bits) at a time using SSE\n    size_t vec_width = 16;\n    size_t vec_iterations = (dim1 * dim2 * sizeof(uint8_t)) / vec_width;\n    \n    for (size_t i = 0; i < vec_iterations; ++i) {\n        // Load 16 bytes from the tensor slice\n        __m128i tensor_vec = _mm_loadu_si128((__m128i*)(tensor + slice_offset + i * vec_width));\n        \n        // Store 16 bytes to the output slice\n        _mm_storeu_si128((__m128i*)(slice + i * vec_width), tensor_vec);\n    }\n    \n    // Handle any remaining elements\n    size_t remaining = (dim1 * dim2 * sizeof(uint8_t)) % vec_width;\n    for (size_t i = vec_iterations * vec_width; i < dim1 * dim2; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    \n    // Process 16 bytes (128 bits) at a time using SSE\n    size_t vector_width = 16;\n    size_t vec_iterations = (dim1 * dim2 * sizeof(uint8_t)) / vector_width;\n    \n    for (size_t i = 0; i < vec_iterations; ++i) {\n        // Load 16 bytes from the tensor slice\n        __m128i tensor_data = _mm_loadu_si128((__m128i*)(tensor + slice_offset + i * vector_width));\n        \n        // Store 16 bytes to the output slice\n        _mm_storeu_si128((__m128i*)(slice + i * vector_width), tensor_data);\n    }\n    \n    // Handle any remaining elements\n    size_t remaining_bytes = (dim1 * dim2 * sizeof(uint8_t)) % vector_width;\n    for (size_t i = vec_iterations * vector_width; i < dim1 * dim2; ++i) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t row = block_row; row < std::min(block_row + block_size, rows); row++) {\n                for (size_t col = block_col; col < std::min(block_col + block_size, cols); col += 8) {\n                    // Use SSE2 intrinsics to load and transpose 8 16-bit integers at a time\n                    __m128i src_vec = _mm_loadu_si128((__m128i*)&src[row * cols + col]);\n                    \n                    // Transpose 8 elements\n                    __m128i transpose_vec = _mm_shuffle_epi32(src_vec, _MM_SHUFFLE(1, 0, 3, 2));\n                    \n                    // Store transposed elements\n                    _mm_storeu_si128((__m128i*)&dst[col * rows + row], transpose_vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t row = block_row; row < std::min(block_row + block_size, rows); row++) {\n                for (size_t col = block_col; col < std::min(block_col + block_size, cols); col += 8) {\n                    // Use SSE2 intrinsics to load and transpose 8 elements at a time\n                    __m128i src_vec = _mm_loadu_si128((__m128i*)&src[row * cols + col]);\n                    \n                    // Unpack and transpose\n                    __m128i src_vec_low = _mm_unpacklo_epi16(src_vec, _mm_setzero_si128());\n                    __m128i src_vec_high = _mm_unpackhi_epi16(src_vec, _mm_setzero_si128());\n                    \n                    // Store transposed elements\n                    _mm_storeu_si128((__m128i*)&dst[col * rows + row], src_vec_low);\n                    _mm_storeu_si128((__m128i*)&dst[col * rows + row + 4], src_vec_high);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t i = block_row; i < std::min(block_row + block_size, rows); i++) {\n                for (size_t j = block_col; j < std::min(block_col + block_size, cols); j += 8) {\n                    // Use SSE2 intrinsics to load and transpose 8 elements at a time\n                    __m128i row_vec = _mm_loadu_si128((__m128i*)&src[i * cols + j]);\n                    \n                    // Unpack and transpose\n                    __m128i row_vec_low = _mm_unpacklo_epi16(row_vec, _mm_setzero_si128());\n                    __m128i row_vec_high = _mm_unpackhi_epi16(row_vec, _mm_setzero_si128());\n                    \n                    // Store transposed elements\n                    _mm_storeu_si128((__m128i*)&dst[j * rows + i], row_vec_low);\n                    _mm_storeu_si128((__m128i*)&dst[j * rows + i + 4], row_vec_high);\n                }\n                \n                // Handle remaining elements in the block\n                for (size_t j = block_col + (cols - block_col) / 8 * 8; j < std::min(block_col + block_size, cols); j++) {\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                for (size_t c = block_col; c < std::min(block_col + block_size, cols); c += 8) {\n                    // Use SSE2 intrinsics to load and transpose 8 16-bit integers at a time\n                    __m128i row_data = _mm_loadu_si128((__m128i*)&src[r * cols + c]);\n                    \n                    // Unpack and interleave data\n                    __m128i row_data_low = _mm_unpacklo_epi16(row_data, _mm_setzero_si128());\n                    __m128i row_data_high = _mm_unpackhi_epi16(row_data, _mm_setzero_si128());\n                    \n                    // Store transposed data\n                    _mm_storeu_si128((__m128i*)&dst[c * rows + r], row_data_low);\n                    _mm_storeu_si128((__m128i*)&dst[c * rows + r + 4], row_data_high);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t row = block_row; row < std::min(block_row + block_size, rows); row++) {\n                for (size_t col = block_col; col < std::min(block_col + block_size, cols); col += 8) {\n                    // Use SSE2 intrinsics to load and transpose 8 elements at a time\n                    __m128i src_vec = _mm_loadu_si128((__m128i*)&src[row * cols + col]);\n                    \n                    // Transpose 8 16-bit integers\n                    __m128i tmp1 = _mm_unpacklo_epi16(src_vec, _mm_setzero_si128());\n                    __m128i tmp2 = _mm_unpackhi_epi16(src_vec, _mm_setzero_si128());\n                    \n                    // Store transposed elements\n                    _mm_storeu_si128((__m128i*)&dst[col * rows + row], tmp1);\n                    _mm_storeu_si128((__m128i*)&dst[col * rows + row + 4], tmp2);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vector = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < dim; i += 4) {\n        size_t index = i * dim * dim + i * dim + i;\n        \n        if (i + 4 <= dim) {\n            __m128 diagonal_elements = _mm_loadu_ps(&array[index]);\n            sum_vector = _mm_add_ps(sum_vector, diagonal_elements);\n        } else {\n            // Handle remaining elements\n            for (size_t j = i; j < dim; j++) {\n                sum_vector[j - i] += array[j * dim * dim + j * dim + j];\n            }\n        }\n    }\n    \n    // Horizontal sum of vector\n    __m128 shuffled1 = _mm_movehl_ps(sum_vector, sum_vector);\n    __m128 sum = _mm_add_ps(sum_vector, shuffled1);\n    sum = _mm_add_ss(sum, _mm_shuffle_ps(sum, sum, 1));\n    \n    return _mm_cvtss_f32(sum);\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < dim; i += 4) {\n        size_t index = i * dim * dim + i * dim + i;\n        \n        if (i + 4 <= dim) {\n            __m128 diagonal_vec = _mm_loadu_ps(&array[index]);\n            sum_vec = _mm_add_ps(sum_vec, diagonal_vec);\n        } else {\n            // Handle remaining elements\n            for (size_t j = i; j < dim; ++j) {\n                sum_vec = _mm_add_ss(sum_vec, _mm_load_ss(&array[j * dim * dim + j * dim + j]));\n            }\n            break;\n        }\n    }\n    \n    // Horizontal sum of vector\n    __m128 shuffled1 = _mm_movehl_ps(sum_vec, sum_vec);\n    __m128 sum = _mm_add_ps(sum_vec, shuffled1);\n    sum = _mm_add_ss(sum, _mm_shuffle_ps(sum, sum, 1));\n    \n    float result;\n    _mm_store_ss(&result, sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < dim; i += 4) {\n        size_t index = i * dim * dim + i * dim + i;\n        \n        if (i + 4 <= dim) {\n            __m128 diagonal_vec = _mm_loadu_ps(&array[index]);\n            sum_vec = _mm_add_ps(sum_vec, diagonal_vec);\n        } else {\n            // Handle remaining elements\n            for (size_t j = i; j < dim; ++j) {\n                sum_vec = _mm_add_ss(sum_vec, _mm_load_ss(&array[j * dim * dim + j * dim + j]));\n            }\n            break;\n        }\n    }\n    \n    // Horizontal sum of vector\n    __m128 shuffled1 = _mm_movehl_ps(sum_vec, sum_vec);\n    sum_vec = _mm_add_ps(sum_vec, shuffled1);\n    sum_vec = _mm_add_ss(sum_vec, _mm_shuffle_ps(sum_vec, sum_vec, 1));\n    \n    float result;\n    _mm_store_ss(&result, sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vector = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < dim; i += 4) {\n        size_t index = i * dim * dim + i * dim + i;\n        \n        if (i + 4 <= dim) {\n            __m128 diagonal_elements = _mm_loadu_ps(&array[index]);\n            sum_vector = _mm_add_ps(sum_vector, diagonal_elements);\n        } else {\n            // Handle remaining elements\n            for (size_t j = i; j < dim; j++) {\n                sum_vector = _mm_add_ss(sum_vector, _mm_load_ss(&array[j * dim * dim + j * dim + j]));\n            }\n            break;\n        }\n    }\n    \n    // Horizontal sum\n    __m128 shuffled1 = _mm_movehl_ps(sum_vector, sum_vector);\n    sum_vector = _mm_add_ps(sum_vector, shuffled1);\n    sum_vector = _mm_add_ss(sum_vector, _mm_shuffle_ps(sum_vector, sum_vector, 1));\n    \n    float result;\n    _mm_store_ss(&result, sum_vector);\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum_vec = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < dim; i += 4) {\n        size_t index = i * dim * dim + i * dim + i;\n        \n        if (i + 4 <= dim) {\n            __m128 diagonal_vec = _mm_loadu_ps(&array[index]);\n            sum_vec = _mm_add_ps(sum_vec, diagonal_vec);\n        } else {\n            // Handle remaining elements\n            for (size_t j = i; j < dim; ++j) {\n                sum_vec = _mm_add_ss(sum_vec, _mm_load_ss(&array[j * dim * dim + j * dim + j]));\n            }\n            break;\n        }\n    }\n    \n    // Horizontal sum of vector\n    __m128 shuffled1 = _mm_shuffle_ps(sum_vec, sum_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    sum_vec = _mm_add_ps(sum_vec, shuffled1);\n    __m128 shuffled2 = _mm_shuffle_ps(sum_vec, sum_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    sum_vec = _mm_add_ps(sum_vec, shuffled2);\n    \n    float result;\n    _mm_store_ss(&result, sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // SSE2 processes 2 doubles at a time\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += 2) {\n            // Load 2 doubles at a time\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n            \n            // Compare if values are greater than threshold\n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n            \n            // Scale values above threshold\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n            \n            // Blend original and scaled values based on mask\n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n            \n            // Store result\n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n        \n        // Handle remaining single element if cols is odd\n        if (cols % 2 != 0) {\n            size_t last_idx = i * cols + cols - 1;\n            dst[last_idx] = src[last_idx] > threshold ? src[last_idx] * scale : src[last_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n            \n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n            \n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n            \n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n        \n        // Handle remaining element if cols is odd\n        if (cols % 2 != 0) {\n            size_t last_idx = i * cols + cols - 1;\n            dst[last_idx] = src[last_idx] > threshold ? src[last_idx] * scale : src[last_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // SSE2 processes 2 doubles at a time\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += 2) {\n            // Load 2 doubles at a time\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n\n            // Compare if values are greater than threshold\n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n\n            // Scale values above threshold\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n\n            // Blend original and scaled values based on mask\n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n\n            // Store result\n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n\n        // Handle remaining single element if cols is odd\n        if (cols % 2 != 0) {\n            size_t last_col = cols - 1;\n            double val = src[i * cols + last_col];\n            dst[i * cols + last_col] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += 2) {\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n            \n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n            \n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n            \n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n        \n        // Handle remaining element if cols is odd\n        if (cols % 2 != 0) {\n            size_t last_idx = i * cols + cols - 1;\n            dst[last_idx] = src[last_idx] > threshold ? src[last_idx] * scale : src[last_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // SSE2 processes 2 doubles at a time\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += 2) {\n            // Load 2 doubles at a time\n            __m128d src_vec = _mm_loadu_pd(&src[i * cols + j]);\n            \n            // Compare if values are greater than threshold\n            __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n            \n            // Scale values above threshold\n            __m128d scaled_vec = _mm_mul_pd(src_vec, scale_vec);\n            \n            // Blend original and scaled values based on mask\n            __m128d result_vec = _mm_blendv_pd(src_vec, scaled_vec, mask);\n            \n            // Store result\n            _mm_storeu_pd(&dst[i * cols + j], result_vec);\n        }\n        \n        // Handle remaining single element if cols is odd\n        if (cols % 2 != 0) {\n            size_t last_idx = i * cols + cols - 1;\n            dst[last_idx] = src[last_idx] > threshold ? src[last_idx] * scale : src[last_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t vector_cols = cols - (cols % 2);\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row = src + src_row_index * cols;\n        double *dst_row = dst + i * cols;\n        \n        // Process vectorized part\n        for (size_t j = 0; j < vector_cols; j += 2) {\n            __m128d vec = _mm_loadu_pd(src_row + j);\n            _mm_storeu_pd(dst_row + j, vec);\n        }\n        \n        // Handle remaining elements if cols is odd\n        for (size_t j = vector_cols; j < cols; j++) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t vec_cols = cols - (cols % 2);\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_idx = indices[i];\n        const double *src_row_ptr = src + src_row_idx * cols;\n        double *dst_row_ptr = dst + i * cols;\n        \n        // Process vectorized part\n        for (size_t j = 0; j < vec_cols; j += 2) {\n            __m128d vec_data = _mm_loadu_pd(src_row_ptr + j);\n            _mm_storeu_pd(dst_row_ptr + j, vec_data);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = vec_cols; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t cols_vector = cols - (cols % 2);\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row_ptr = src + src_row_index * cols;\n        double *dst_row_ptr = dst + i * cols;\n        \n        // Process 2 doubles at a time using SSE2\n        for (size_t j = 0; j < cols_vector; j += 2) {\n            __m128d vec = _mm_loadu_pd(src_row_ptr + j);\n            _mm_storeu_pd(dst_row_ptr + j, vec);\n        }\n        \n        // Handle remaining elements if cols is odd\n        for (size_t j = cols_vector; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t vector_cols = cols - (cols % 2);\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row_ptr = src + src_row_index * cols;\n        double *dst_row_ptr = dst + i * cols;\n        \n        // Process vectorized part\n        for (size_t j = 0; j < vector_cols; j += 2) {\n            __m128d vec = _mm_loadu_pd(src_row_ptr + j);\n            _mm_storeu_pd(dst_row_ptr + j, vec);\n        }\n        \n        // Process remaining elements\n        for (size_t j = vector_cols; j < cols; j++) {\n            dst_row_ptr[j] = src_row_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    size_t vector_cols = cols - (cols % 2);\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row = src + src_row_index * cols;\n        double *dst_row = dst + i * cols;\n        \n        // Process 2 doubles at a time\n        for (size_t j = 0; j < vector_cols; j += 2) {\n            __m128d vec = _mm_loadu_pd(src_row + j);\n            _mm_storeu_pd(dst_row + j, vec);\n        }\n        \n        // Handle remaining single elements if cols is odd\n        for (size_t j = vector_cols; j < cols; j++) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    // Load scalar value into SSE register\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    // Process 2 elements at a time using SSE2\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        // Load 2 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n\n        // Add src1 and src2 elements\n        __m128i sum = _mm_add_epi64(vec1, vec2);\n\n        // Add scalar to result\n        sum = _mm_add_epi64(sum, scalar_vec);\n\n        // Divide by 2 (round toward zero)\n        sum = _mm_srai_epi64(sum, 1);\n\n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], sum);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    // Load scalar value into SSE register\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    // Process 2 elements at a time using SSE2\n    size_t i;\n    for (i = 0; i <= length - 2; i += 2) {\n        // Load 2 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n\n        // Add src1 and src2 elements\n        __m128i sum = _mm_add_epi64(vec1, vec2);\n\n        // Add scalar to each element\n        sum = _mm_add_epi64(sum, scalar_vec);\n\n        // Divide by 2 (round toward zero)\n        sum = _mm_srai_epi64(sum, 1);\n\n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], sum);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    \n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        // Load 2 64-bit integers from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Add src1 and src2 elements\n        __m128i sum = _mm_add_epi64(vec1, vec2);\n        \n        // Add scalar to each element\n        sum = _mm_add_epi64(sum, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum = _mm_srai_epi64(sum, 1);\n        \n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], sum);\n    }\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    // Create scalar vector for broadcasting\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    \n    // Process 2 elements at a time using SSE2 intrinsics\n    size_t i;\n    for (i = 0; i < length - 1; i += 2) {\n        // Load 2 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Add src1 and src2 elements\n        __m128i sum_vec = _mm_add_epi64(vec1, vec2);\n        \n        // Add scalar to result\n        sum_vec = _mm_add_epi64(sum_vec, scalar_vec);\n        \n        // Divide by 2 (round toward zero)\n        sum_vec = _mm_srai_epi64(sum_vec, 1);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], sum_vec);\n    }\n    \n    // Handle remaining element if length is odd\n    if (length % 2 != 0) {\n        dst[length - 1] = (src1[length - 1] + src2[length - 1] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    // Load scalar value into SSE register\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n\n    // Process 2 elements at a time using SSE2\n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        // Load 2 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n\n        // Add src1 and src2\n        __m128i sum = _mm_add_epi64(vec1, vec2);\n\n        // Add scalar to result\n        sum = _mm_add_epi64(sum, scalar_vec);\n\n        // Divide by 2 (round toward zero)\n        sum = _mm_srai_epi64(sum, 1);\n\n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], sum);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask = _mm_set_epi32(0xFFFFFFFF, 0, 0xFFFFFFFF, 0);\n        vec = _mm_and_si128(vec, mask);\n        min_vec = _mm_min_epi32(min_vec, vec);\n    }\n\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    \n    int min_val = min_arr[0];\n    for (int j = 2; j < 4; j += 2) {\n        min_val = min(min_val, min_arr[j]);\n    }\n\n    for (; i < length; i += 2) {\n        min_val = min(min_val, src[i]);\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask = _mm_set_epi32(0xFFFFFFFF, 0, 0xFFFFFFFF, 0);\n        vec = _mm_and_si128(vec, mask);\n        min_vec = _mm_min_epi32(min_vec, vec);\n    }\n\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    \n    int min_val = min_arr[0];\n    for (int j = 2; j < 4; j += 2) {\n        min_val = min(min_val, min_arr[j]);\n    }\n\n    for (; i < length; i += 2) {\n        min_val = min(min_val, src[i]);\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask = _mm_set_epi32(0xFFFFFFFF, 0, 0xFFFFFFFF, 0);\n        vec = _mm_and_si128(vec, mask);\n        min_vec = _mm_min_epi32(min_vec, vec);\n    }\n\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    \n    int min_val = min_arr[0];\n    for (int j = 2; j < 4; j += 2) {\n        min_val = min(min_val, min_arr[j]);\n    }\n\n    for (; i < length; i += 2) {\n        min_val = min(min_val, src[i]);\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask = _mm_set_epi32(0xFFFFFFFF, 0, 0xFFFFFFFF, 0);\n        vec = _mm_and_si128(vec, mask);\n        min_vec = _mm_min_epi32(min_vec, vec);\n    }\n\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    \n    int min_val = min_arr[0] < min_arr[2] ? min_arr[0] : min_arr[2];\n\n    for (; i < length; i += 2) {\n        min_val = src[i] < min_val ? src[i] : min_val;\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&src[i]);\n        __m128i mask = _mm_set_epi32(0xFFFFFFFF, 0, 0xFFFFFFFF, 0);\n        vec = _mm_and_si128(vec, mask);\n        min_vec = _mm_min_epi32(min_vec, vec);\n    }\n\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    \n    int min_val = min_arr[0];\n    for (size_t j = 2; j < 4; j += 2) {\n        min_val = min(min_val, min_arr[j]);\n    }\n\n    for (; i < length; i += 2) {\n        min_val = min(min_val, src[i]);\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from source array\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_sra_epi32(vec_src, _mm_cvtsi32_si128(shift));\n        \n        // Convert to unsigned and perform logical right shift\n        __m128i unsigned_src = _mm_srli_epi32(vec_src, shift);\n        \n        // Add arithmetic and logical shifts\n        __m128i result = _mm_add_epi32(arithmetic_shift, unsigned_src);\n        \n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from source array\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_sra_epi32(vec_src, _mm_cvtsi32_si128(shift));\n        \n        // Convert to unsigned and perform logical right shift\n        __m128i unsigned_src = _mm_srli_epi32(vec_src, shift);\n        \n        // Add arithmetic and logical shifts\n        __m128i result = _mm_add_epi32(arithmetic_shift, unsigned_src);\n        \n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from source array\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_sra_epi32(vec_src, _mm_cvtsi32_si128(shift));\n        \n        // Convert to unsigned and perform logical right shift\n        __m128i unsigned_src = _mm_srli_epi32(vec_src, shift);\n        \n        // Add arithmetic and logical shifts\n        __m128i result = _mm_add_epi32(arithmetic_shift, unsigned_src);\n        \n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from source array\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_sra_epi32(vec_src, _mm_cvtsi32_si128(shift));\n        \n        // Convert to unsigned and perform logical right shift\n        __m128i unsigned_src = _mm_srli_epi32(vec_src, shift);\n        \n        // Add arithmetic and logical shifts\n        __m128i result = _mm_add_epi32(arithmetic_shift, unsigned_src);\n        \n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 integers from source\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Arithmetic right shift\n        __m128i arithmetic_shift = _mm_sra_epi32(vec_src, _mm_cvtsi32_si128(shift));\n        \n        // Convert to unsigned and perform logical right shift\n        __m128i unsigned_src = _mm_srli_epi32(vec_src, shift);\n        \n        // Add arithmetic and logical shifts\n        __m128i result = _mm_add_epi32(arithmetic_shift, unsigned_src);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        unsigned int logical_shift = ((unsigned int)src[i]) >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t simd_width = 4; // SSE processes 4 32-bit integers at a time\n\n    // Initialize sum vector to zero\n    __m128i sum_vector = _mm_setzero_si128();\n\n    // Process elements in groups of 4 using SSE\n    size_t i;\n    for (i = 0; i + simd_width <= total_elements; i += simd_width) {\n        __m128i current_vector = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vector = _mm_add_epi32(sum_vector, current_vector);\n    }\n\n    // Horizontal sum of the SIMD vector\n    __m128i high_64 = _mm_srli_si128(sum_vector, 8);\n    __m128i sum_128 = _mm_add_epi32(sum_vector, high_64);\n    __m128i sum_64 = _mm_srli_si128(sum_128, 4);\n    sum_128 = _mm_add_epi32(sum_128, sum_64);\n    int32_t simd_sum = _mm_cvtsi128_si32(sum_128);\n    total_sum += simd_sum;\n\n    // Process remaining elements\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t simd_width = 4; // SSE processes 4 integers at a time\n    \n    __m128i sum_vector = _mm_setzero_si128(); // Initialize sum vector to zero\n    \n    // Process elements in groups of 4 using SSE\n    size_t i;\n    for (i = 0; i + simd_width <= total_elements; i += simd_width) {\n        __m128i current_vector = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vector = _mm_add_epi32(sum_vector, current_vector);\n    }\n    \n    // Horizontal sum of the SSE vector\n    __m128i shuffled1 = _mm_shuffle_epi32(sum_vector, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum_half1 = _mm_add_epi32(sum_vector, shuffled1);\n    __m128i shuffled2 = _mm_shuffle_epi32(sum_half1, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128i final_sum_vector = _mm_add_epi32(sum_half1, shuffled2);\n    \n    // Extract the final sum from the vector\n    int partial_sum = _mm_cvtsi128_si32(final_sum_vector);\n    total_sum += partial_sum;\n    \n    // Process remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_size = total_elements - (total_elements % 4);\n\n    __m128i sum_vector = _mm_setzero_si128();\n\n    // Process 4 integers at a time using SSE\n    for (size_t i = 0; i < vector_size; i += 4) {\n        __m128i current_vector = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vector = _mm_add_epi32(sum_vector, current_vector);\n    }\n\n    // Horizontal sum of the vector\n    __m128i shuffle1 = _mm_shuffle_epi32(sum_vector, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum_half1 = _mm_add_epi32(sum_vector, shuffle1);\n    __m128i shuffle2 = _mm_shufflelo_epi16(sum_half1, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum_final = _mm_add_epi32(sum_half1, shuffle2);\n    \n    total_sum = _mm_cvtsi128_si32(sum_final);\n\n    // Handle remaining elements\n    for (size_t i = vector_size; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t vector_size = total_elements - (total_elements % 4);\n\n    __m128i sum_vector = _mm_setzero_si128();\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < vector_size; i += 4) {\n        __m128i current_vector = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vector = _mm_add_epi32(sum_vector, current_vector);\n    }\n\n    // Horizontal sum of the vector\n    __m128i high_64 = _mm_srli_si128(sum_vector, 8);\n    __m128i sum_128 = _mm_add_epi32(sum_vector, high_64);\n    __m128i sum_64 = _mm_srli_si128(sum_128, 4);\n    sum_128 = _mm_add_epi32(sum_128, sum_64);\n    total_sum += _mm_cvtsi128_si32(sum_128);\n\n    // Handle remaining elements\n    for (size_t i = vector_size; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    size_t simd_width = 4; // SSE processes 4 32-bit integers at a time\n\n    __m128i sum_vector = _mm_setzero_si128(); // Initialize sum vector to zero\n\n    // Process elements in groups of 4 using SSE\n    size_t i;\n    for (i = 0; i + simd_width <= total_elements; i += simd_width) {\n        __m128i current_vector = _mm_loadu_si128((__m128i*)&matrix[i]);\n        sum_vector = _mm_add_epi32(sum_vector, current_vector);\n    }\n\n    // Horizontal sum of the SSE vector\n    __m128i shuffled1 = _mm_shuffle_epi32(sum_vector, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum_half1 = _mm_add_epi32(sum_vector, shuffled1);\n    __m128i shuffled2 = _mm_shuffle_epi32(sum_half1, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128i final_sum = _mm_add_epi32(sum_half1, shuffled2);\n    \n    total_sum = _mm_cvtsi128_si32(final_sum);\n\n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Unpack to 16-bit to handle signed comparison\n        __m128i low = _mm_unpacklo_epi8(current_vec, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi8(current_vec, _mm_setzero_si128());\n        \n        // Find max values\n        __m128i max_low = _mm_max_epi16(low, _mm_setzero_si128());\n        __m128i max_high = _mm_max_epi16(high, _mm_setzero_si128());\n        \n        // Horizontal max and index tracking\n        int16_t max_vals[8];\n        _mm_storeu_si128((__m128i*)max_vals, max_low);\n        _mm_storeu_si128((__m128i*)(max_vals + 4), max_high);\n        \n        for (int j = 0; j < 8; j++) {\n            if (max_vals[j] > max_val) {\n                max_val = max_vals[j];\n                max_index = i + j;\n            }\n        }\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i current = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Unpack to 16-bit integers to handle signed comparisons\n        __m128i low = _mm_unpacklo_epi8(current, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi8(current, _mm_setzero_si128());\n        \n        // Find max values in low and high parts\n        __m128i max_low = _mm_max_epi16(low, _mm_slli_si128(low, 2));\n        __m128i max_high = _mm_max_epi16(high, _mm_slli_si128(high, 2));\n        \n        max_low = _mm_max_epi16(max_low, _mm_srli_si128(max_low, 4));\n        max_high = _mm_max_epi16(max_high, _mm_srli_si128(max_high, 4));\n        \n        int16_t max_low_val = _mm_cvtsi128_si32(max_low);\n        int16_t max_high_val = _mm_cvtsi128_si32(max_high);\n        \n        int16_t current_max = max_low_val > max_high_val ? max_low_val : max_high_val;\n        \n        if (current_max > max_val) {\n            max_val = current_max;\n            max_index = i + (current_max == max_low_val ? \n                _mm_cmpestri(low, 8, _mm_set1_epi16(max_low_val), 1, _mm_SIDD_CMP_EQUAL_ORDERED) :\n                8 + _mm_cmpestri(high, 8, _mm_set1_epi16(max_high_val), 1, _mm_SIDD_CMP_EQUAL_ORDERED));\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Unpack to 16-bit to handle signed comparison\n        __m128i low = _mm_unpacklo_epi8(current_vec, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi8(current_vec, _mm_setzero_si128());\n        \n        // Find max values in low and high parts\n        __m128i max_low = _mm_max_epi16(low, _mm_slli_si128(low, 2));\n        __m128i max_high = _mm_max_epi16(high, _mm_slli_si128(high, 2));\n        \n        max_low = _mm_max_epi16(max_low, _mm_srli_si128(max_low, 4));\n        max_high = _mm_max_epi16(max_high, _mm_srli_si128(max_high, 4));\n        \n        int16_t max_chunk_low = _mm_cvtsi128_si32(max_low);\n        int16_t max_chunk_high = _mm_cvtsi128_si32(max_high);\n        \n        int16_t chunk_max = max_chunk_low > max_chunk_high ? max_chunk_low : max_chunk_high;\n        \n        if (chunk_max > max_val) {\n            max_val = chunk_max;\n            max_index = i + (chunk_max == max_chunk_low ? \n                _mm_cmpestri(low, 8, _mm_set1_epi16(max_chunk_low), 8, _mm_cmpeq_epi16_mask) :\n                8 + _mm_cmpestri(high, 8, _mm_set1_epi16(max_chunk_high), 8, _mm_cmpeq_epi16_mask));\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i current = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Unpack to 16-bit to handle signed comparisons\n        __m128i low = _mm_unpacklo_epi8(current, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi8(current, _mm_setzero_si128());\n        \n        // Find max values in low and high parts\n        __m128i max_low = _mm_max_epi16(low, _mm_slli_si128(low, 2));\n        __m128i max_high = _mm_max_epi16(high, _mm_slli_si128(high, 2));\n        \n        max_low = _mm_max_epi16(max_low, _mm_srli_si128(max_low, 4));\n        max_high = _mm_max_epi16(max_high, _mm_srli_si128(max_high, 4));\n        \n        int16_t max_low_val = _mm_cvtsi128_si32(max_low);\n        int16_t max_high_val = _mm_cvtsi128_si32(max_high);\n        \n        int16_t current_max = max_low_val > max_high_val ? max_low_val : max_high_val;\n        \n        if (current_max > max_val) {\n            max_val = current_max;\n            max_index = i + (current_max == max_low_val ? \n                _mm_cmpestri(low, 8, _mm_set1_epi16(max_low_val), 1, _mm_SIDD_CMP_EQUAL_ORDERED) :\n                8 + _mm_cmpestri(high, 8, _mm_set1_epi16(max_high_val), 1, _mm_SIDD_CMP_EQUAL_ORDERED));\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n\n    // Process 16 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i current = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Unpack to 16-bit to handle signed comparisons\n        __m128i low = _mm_unpacklo_epi8(current, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi8(current, _mm_setzero_si128());\n        \n        // Find max values\n        __m128i max_low = low;\n        __m128i max_high = high;\n        \n        // Compare and extract max indices\n        for (int j = 0; j < 16; j++) {\n            int16_t val_low = _mm_extract_epi16(low, j);\n            int16_t val_high = _mm_extract_epi16(high, j);\n            \n            if (val_low > max_val) {\n                max_val = val_low;\n                max_index = i + j;\n            }\n            \n            if (val_high > max_val) {\n                max_val = val_high;\n                max_index = i + j + 8;\n            }\n        }\n    }\n\n    // Process remaining elements sequentially\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Create a vector of indices\n        __m128i indices = _mm_setr_epi16(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7);\n        \n        // Perform bitwise AND between indices and mask\n        __m128i mask_vec = _mm_set1_epi16(mask);\n        __m128i index_mask = _mm_and_si128(indices, mask_vec);\n        \n        // Compare mask result to zero\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp_mask = _mm_cmpgt_epi16(index_mask, zero);\n        \n        // Blend vectors based on comparison mask\n        __m128i blended = _mm_blendv_epi8(vec2, vec1, cmp_mask);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], blended);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Create a vector of indices\n        __m128i indices = _mm_setr_epi16(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7);\n        \n        // Perform bitwise AND between indices and mask\n        __m128i mask_vec = _mm_set1_epi16(mask);\n        __m128i index_mask = _mm_and_si128(indices, mask_vec);\n        \n        // Compare index_mask with zero\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp_mask = _mm_cmpgt_epi16(index_mask, zero);\n        \n        // Blend the vectors based on the comparison mask\n        __m128i blended = _mm_blendv_epi8(vec2, vec1, cmp_mask);\n        \n        // Store the result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], blended);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Create a mask vector for blending\n        __m128i blend_mask = _mm_setzero_si128();\n        for (int j = 0; j < 8; j++) {\n            if ((((i + j) & mask) != 0)) {\n                blend_mask = _mm_insert_epi16(blend_mask, 0xFFFF, j);\n            }\n        }\n        \n        // Blend the two vectors based on the mask\n        __m128i result = _mm_blendv_epi8(vec2, vec1, blend_mask);\n        \n        // Store the result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Create a vector of indices\n        __m128i indices = _mm_setr_epi16(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7);\n        \n        // Compute mask condition for each element\n        __m128i mask_vec = _mm_set1_epi16(mask);\n        __m128i index_mask = _mm_and_si128(indices, mask_vec);\n        \n        // Compare mask condition to zero\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask_condition = _mm_cmpgt_epi16(index_mask, zero);\n        \n        // Blend elements based on mask condition\n        __m128i blended = _mm_blendv_epi8(vec2, vec1, mask_condition);\n        \n        // Store result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], blended);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 elements from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Create a vector of indices\n        __m128i indices = _mm_setr_epi16(i, i+1, i+2, i+3, i+4, i+5, i+6, i+7);\n        \n        // Perform bitwise AND between indices and mask\n        __m128i mask_vec = _mm_set1_epi16(mask);\n        __m128i index_mask = _mm_and_si128(indices, mask_vec);\n        \n        // Compare mask result to zero\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp_mask = _mm_cmpgt_epi16(index_mask, zero);\n        \n        // Blend elements based on mask comparison\n        __m128i blended = _mm_blendv_epi8(vec2, vec1, cmp_mask);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], blended);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Compute population count using SSE2 bit manipulation\n        __m128i mask1 = _mm_srli_epi32(input, 1);\n        __m128i mask2 = _mm_srli_epi32(input, 2);\n        __m128i mask3 = _mm_srli_epi32(input, 3);\n        \n        input = _mm_sub_epi32(input, _mm_and_si128(mask1, _mm_set1_epi32(0x55555555)));\n        input = _mm_add_epi32(_mm_and_si128(input, _mm_set1_epi32(0x33333333)), \n                               _mm_and_si128(mask2, _mm_set1_epi32(0x33333333)));\n        \n        input = _mm_add_epi32(input, _mm_srli_epi32(input, 4));\n        input = _mm_and_si128(input, _mm_set1_epi32(0x0F0F0F0F));\n        input = _mm_mullo_epi32(input, _mm_set1_epi32(0x01010101));\n        input = _mm_srli_epi32(input, 24);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], input);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x * 0x01010101;\n        dst[i] = x >> 24;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Compute population count for each 32-bit integer\n        __m128i popcount = _mm_setzero_si128();\n        \n        // Bit manipulation to count 1 bits\n        __m128i m1 = _mm_set1_epi32(0x55555555);\n        __m128i m2 = _mm_set1_epi32(0x33333333);\n        __m128i m4 = _mm_set1_epi32(0x0F0F0F0F);\n        \n        input = input - ((input >> 1) & m1);\n        input = (input & m2) + ((input >> 2) & m2);\n        input = (input + (input >> 4)) & m4;\n        input = input + (input >> 8);\n        input = input + (input >> 16);\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], input & _mm_set1_epi32(0x3F));\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        dst[i] = x + (x >> 16) & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2\n    for (; i + 4 <= length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Compute population count for each 32-bit integer\n        __m128i popcount = _mm_setzero_si128();\n        \n        // Bit manipulation method for population count\n        __m128i m1 = _mm_set1_epi32(0x55555555);\n        __m128i m2 = _mm_set1_epi32(0x33333333);\n        __m128i m4 = _mm_set1_epi32(0x0F0F0F0F);\n        \n        input = _mm_sub_epi32(input, (_mm_srli_epi32(input, 1) & m1));\n        input = (_mm_srli_epi32(input, 2) & m2) + (input & m2);\n        input = _mm_add_epi32(_mm_srli_epi32(input, 4), input) & m4;\n        popcount = _mm_add_epi32(popcount, input);\n        \n        popcount = _mm_add_epi32(popcount, _mm_srli_epi32(popcount, 8));\n        popcount = _mm_add_epi32(popcount, _mm_srli_epi32(popcount, 16));\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&dst[i], popcount);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source integers\n        __m128i vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Initialize destination vector\n        __m128i result = _mm_setzero_si128();\n        \n        // Compute population count for each 32-bit integer\n        __m128i m1 = _mm_srli_epi32(vec, 1);\n        __m128i m2 = _mm_and_si128(m1, _mm_set1_epi32(0x55555555));\n        vec = _mm_sub_epi32(vec, m2);\n        \n        m1 = _mm_srli_epi32(vec, 2);\n        m2 = _mm_and_si128(vec, _mm_set1_epi32(0x33333333));\n        vec = _mm_add_epi32(m1, m2);\n        \n        m1 = _mm_srli_epi32(vec, 4);\n        vec = _mm_add_epi32(vec, m1);\n        \n        vec = _mm_and_si128(vec, _mm_set1_epi32(0x0F0F0F0F));\n        \n        m1 = _mm_srli_epi32(vec, 8);\n        vec = _mm_add_epi32(vec, m1);\n        \n        m1 = _mm_srli_epi32(vec, 16);\n        vec = _mm_add_epi32(vec, m1);\n        \n        vec = _mm_and_si128(vec, _mm_set1_epi32(0x3F));\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Compute population count for each 32-bit integer\n        __m128i popcount = _mm_setzero_si128();\n        \n        // Bit manipulation method for population count\n        __m128i m1 = _mm_set1_epi32(0x55555555);\n        __m128i m2 = _mm_set1_epi32(0x33333333);\n        __m128i m4 = _mm_set1_epi32(0x0F0F0F0F);\n        \n        input = _mm_sub_epi32(input, (_mm_srli_epi32(input, 1) & m1));\n        input = (_mm_srli_epi32(input, 2) & m2) + (input & m2);\n        input = _mm_add_epi32(_mm_srli_epi32(input, 4), input) & m4;\n        popcount = _mm_add_epi32(popcount, input);\n        \n        popcount = _mm_add_epi32(popcount, _mm_srli_epi32(popcount, 8));\n        popcount = _mm_add_epi32(popcount, _mm_srli_epi32(popcount, 16));\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&dst[i], popcount);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit integers from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Perform saturating addition\n        __m128i result = _mm_adds_epu16(vec1, vec2);\n        \n        // Store the result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit integers from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Perform saturating addition using SSE2 intrinsics\n        __m128i result = _mm_adds_epu16(vec1, vec2);\n        \n        // Store the result in dst\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit integers from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Perform saturating addition using SSE2 intrinsics\n        __m128i result = _mm_adds_epu16(vec1, vec2);\n        \n        // Store the result in dst\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit integers from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Perform saturating addition\n        __m128i result = _mm_adds_epu16(vec1, vec2);\n        \n        // Store the result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2 intrinsics\n    for (; i + 8 <= length; i += 8) {\n        // Load 8 16-bit unsigned integers from src1 and src2\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        // Perform saturating addition\n        __m128i result = _mm_adds_epu16(vec1, vec2);\n        \n        // Store the result in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                __m128d a_vec = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vec = _mm_loadu_pd(&B[k * p + j]);\n                \n                // Check range condition\n                __m128d mask_a = _mm_and_pd(\n                    _mm_cmpge_pd(a_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(a_vec, _mm_set1_pd(100.0))\n                );\n                __m128d mask_b = _mm_and_pd(\n                    _mm_cmpge_pd(b_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(b_vec, _mm_set1_pd(100.0))\n                );\n                \n                __m128d masked_a = _mm_and_pd(a_vec, mask_a);\n                __m128d masked_b = _mm_and_pd(b_vec, mask_b);\n                \n                sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(masked_a, masked_b));\n            }\n            \n            // Handle remaining elements\n            double sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n            \n            for (; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vec = _mm_loadu_pd(&B[k * p + j]);\n                \n                // Check range condition\n                __m128d mask_a = _mm_and_pd(\n                    _mm_cmpge_pd(a_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(a_vec, _mm_set1_pd(100.0))\n                );\n                __m128d mask_b = _mm_and_pd(\n                    _mm_cmpge_pd(b_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(b_vec, _mm_set1_pd(100.0))\n                );\n                \n                __m128d masked_a = _mm_and_pd(a_vec, mask_a);\n                __m128d masked_b = _mm_and_pd(b_vec, mask_b);\n                \n                __m128d mul_vec = _mm_mul_pd(masked_a, masked_b);\n                sum_vec = _mm_add_pd(sum_vec, mul_vec);\n                \n                // Handle remaining elements if n is odd\n                if (k + 2 >= n) {\n                    double sum_arr[2];\n                    _mm_storeu_pd(sum_arr, sum_vec);\n                    C[i * p + j] = sum_arr[0] + sum_arr[1];\n                }\n            }\n            \n            // Handle odd n case\n            if (n % 2 != 0) {\n                double last_a = A[i * n + n - 1];\n                double last_b = B[(n - 1) * p + j];\n                \n                if (last_a >= -100.0 && last_a <= 100.0 && \n                    last_b >= -100.0 && last_b <= 100.0) {\n                    double sum_arr[2];\n                    _mm_storeu_pd(sum_arr, sum_vec);\n                    C[i * p + j] = sum_arr[0] + sum_arr[1] + last_a * last_b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                __m128d a_vec = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vec = _mm_loadu_pd(&B[k * p + j]);\n                \n                // Check range condition\n                __m128d mask_a = _mm_and_pd(\n                    _mm_cmpge_pd(a_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(a_vec, _mm_set1_pd(100.0))\n                );\n                __m128d mask_b = _mm_and_pd(\n                    _mm_cmpge_pd(b_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(b_vec, _mm_set1_pd(100.0))\n                );\n                \n                __m128d masked_a = _mm_and_pd(a_vec, mask_a);\n                __m128d masked_b = _mm_and_pd(b_vec, mask_b);\n                \n                sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(masked_a, masked_b));\n            }\n            \n            // Handle remaining elements\n            double sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n            \n            for (; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k += 2) {\n                __m128d a_vec = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vec = _mm_loadu_pd(&B[k * p + j]);\n                \n                // Check range condition\n                __m128d mask_a = _mm_and_pd(\n                    _mm_cmpge_pd(a_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(a_vec, _mm_set1_pd(100.0))\n                );\n                __m128d mask_b = _mm_and_pd(\n                    _mm_cmpge_pd(b_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(b_vec, _mm_set1_pd(100.0))\n                );\n                \n                __m128d masked_a = _mm_and_pd(a_vec, mask_a);\n                __m128d masked_b = _mm_and_pd(b_vec, mask_b);\n                \n                __m128d mul_vec = _mm_mul_pd(masked_a, masked_b);\n                sum_vec = _mm_add_pd(sum_vec, mul_vec);\n                \n                // Handle remaining elements if n is odd\n                if (k + 2 >= n) {\n                    double sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n                    C[i * p + j] = sum;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                __m128d a_vec = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b_vec = _mm_loadu_pd(&B[k * p + j]);\n                \n                // Check range condition\n                __m128d mask_a = _mm_and_pd(\n                    _mm_cmpge_pd(a_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(a_vec, _mm_set1_pd(100.0))\n                );\n                __m128d mask_b = _mm_and_pd(\n                    _mm_cmpge_pd(b_vec, _mm_set1_pd(-100.0)),\n                    _mm_cmple_pd(b_vec, _mm_set1_pd(100.0))\n                );\n                \n                __m128d masked_a = _mm_and_pd(a_vec, mask_a);\n                __m128d masked_b = _mm_and_pd(b_vec, mask_b);\n                \n                sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(masked_a, masked_b));\n            }\n            \n            // Handle remaining elements\n            double sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n            \n            for (; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100.0 && a_val <= 100.0 && \n                    b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = sizeof(__m128i) / sizeof(int64_t);\n    size_t simd_elements = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < simd_elements; i += vector_size) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c_vec = _mm_add_epi64(a_vec, b_vec);\n        _mm_storeu_si128((__m128i*)&C[i], c_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_elements; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = sizeof(__m128i) / sizeof(int64_t);\n    size_t vectorized_length = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < vectorized_length; i += vector_size) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c_vec = _mm_add_epi64(a_vec, b_vec);\n        _mm_storeu_si128((__m128i*)&C[i], c_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = sizeof(__m128i) / sizeof(int64_t);\n    size_t simd_elements = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < simd_elements; i += vector_size) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i vc = _mm_add_epi64(va, vb);\n        _mm_storeu_si128((__m128i*)&C[i], vc);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_elements; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = sizeof(__m128i) / sizeof(int64_t);\n    size_t simd_elements = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < simd_elements; i += vector_size) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c_vec = _mm_add_epi64(a_vec, b_vec);\n        _mm_storeu_si128((__m128i*)&C[i], c_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_elements; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 2; // SSE2 can process 2 64-bit integers at a time\n    size_t simd_length = total_elements - (total_elements % vector_size);\n\n    for (size_t i = 0; i < simd_length; i += vector_size) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c_vec = _mm_add_epi64(a_vec, b_vec);\n        _mm_storeu_si128((__m128i*)&C[i], c_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_length; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 floats from src1 and src2 into SSE registers\n        __m128 vec1 = _mm_loadu_ps(src1 + i);\n        __m128 vec2 = _mm_loadu_ps(src2 + i);\n        \n        // Add the two vectors\n        __m128 sum = _mm_add_ps(vec1, vec2);\n        \n        // Round to nearest integer\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT);\n        \n        // Store the result in destination array\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 floats from src1 and src2 into SSE registers\n        __m128 vec1 = _mm_loadu_ps(src1 + i);\n        __m128 vec2 = _mm_loadu_ps(src2 + i);\n        \n        // Add the two vectors\n        __m128 sum = _mm_add_ps(vec1, vec2);\n        \n        // Round to nearest integer\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT);\n        \n        // Store the result in destination array\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 floats from src1 and src2\n        __m128 vec1 = _mm_loadu_ps(src1 + i);\n        __m128 vec2 = _mm_loadu_ps(src2 + i);\n        \n        // Add the vectors\n        __m128 sum = _mm_add_ps(vec1, vec2);\n        \n        // Round to nearest integer\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT);\n        \n        // Store the result in dst\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 floats from src1 and src2 into SSE registers\n        __m128 vec1 = _mm_loadu_ps(src1 + i);\n        __m128 vec2 = _mm_loadu_ps(src2 + i);\n        \n        // Add the two vectors\n        __m128 sum = _mm_add_ps(vec1, vec2);\n        \n        // Round to nearest integer\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT);\n        \n        // Store the result in destination array\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 floats from src1 and src2\n        __m128 a = _mm_loadu_ps(src1 + i);\n        __m128 b = _mm_loadu_ps(src2 + i);\n        \n        // Add the vectors\n        __m128 sum = _mm_add_ps(a, b);\n        \n        // Round to nearest integer\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT);\n        \n        // Store result in destination\n        _mm_storeu_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const __m128 fifty = _mm_set1_ps(50.0f);\n    const __m128 neg_one = _mm_set1_ps(-1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&src1[i]);\n        __m128 vec2 = _mm_loadu_ps(&src2[i]);\n        \n        // Check index multiple of 2\n        __m128 index_mask = _mm_cmpeq_ps(_mm_set_ps(3, 2, 1, 0), \n                                          _mm_and_ps(_mm_set_ps(3, 2, 1, 0), _mm_set1_ps(1.0f)));\n        \n        // Calculate absolute difference\n        __m128 diff = _mm_sub_ps(vec1, vec2);\n        __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n        \n        // Condition check\n        __m128 condition_mask = _mm_and_ps(_mm_cmple_ps(abs_diff, fifty), index_mask);\n        \n        // Multiply and round up\n        __m128 mul_result = _mm_mul_ps(vec1, vec2);\n        __m128 rounded_result = _mm_ceil_ps(mul_result);\n        \n        // Blend results based on conditions\n        __m128 result = _mm_blendv_ps(neg_one, rounded_result, condition_mask);\n        \n        _mm_storeu_ps(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&src1[i]);\n        __m128 vec2 = _mm_loadu_ps(&src2[i]);\n        __m128 diff = _mm_sub_ps(vec1, vec2);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff);\n        \n        __m128 mask1 = _mm_cmplt_ps(abs_diff, _mm_set1_ps(50.0f));\n        __m128 mask2 = _mm_cmpeq_ps(_mm_set1_ps(0.0f), _mm_set1_ps((float)(i % 2)));\n        __m128 combined_mask = _mm_and_ps(mask1, mask2);\n        \n        __m128 mul_result = _mm_mul_ps(vec1, vec2);\n        __m128 rounded_result = _mm_ceil_ps(mul_result);\n        \n        __m128 final_result = _mm_blendv_ps(_mm_set1_ps(-1.0f), rounded_result, combined_mask);\n        \n        _mm_storeu_ps(&dst[i], final_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&src1[i]);\n        __m128 vec2 = _mm_loadu_ps(&src2[i]);\n        __m128 diff = _mm_sub_ps(vec1, vec2);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff);\n        \n        __m128 mask1 = _mm_cmplt_ps(abs_diff, _mm_set1_ps(50.0f));\n        __m128 mask2 = _mm_cmpeq_ps(_mm_set1_ps(0.0f), _mm_set1_ps((float)(i % 2)));\n        __m128 final_mask = _mm_and_ps(mask1, mask2);\n        \n        __m128 mul_result = _mm_mul_ps(vec1, vec2);\n        __m128 rounded_result = _mm_ceil_ps(mul_result);\n        \n        __m128 result = _mm_blendv_ps(_mm_set1_ps(-1.0f), rounded_result, final_mask);\n        _mm_storeu_ps(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&src1[i]);\n        __m128 vec2 = _mm_loadu_ps(&src2[i]);\n        __m128 diff = _mm_sub_ps(vec1, vec2);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff);\n        \n        __m128 mask1 = _mm_cmplt_ps(abs_diff, _mm_set1_ps(50.0f));\n        __m128 mask2 = _mm_cmpeq_ps(_mm_set1_ps(0.0f), _mm_set1_ps((float)(i % 2)));\n        __m128 mask = _mm_and_ps(mask1, mask2);\n        \n        __m128 result = _mm_mul_ps(vec1, vec2);\n        result = _mm_ceil_ps(result);\n        \n        __m128 default_val = _mm_set1_ps(-1.0f);\n        result = _mm_blendv_ps(default_val, result, mask);\n        \n        _mm_storeu_ps(&dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        __m128 vec1 = _mm_loadu_ps(&src1[i]);\n        __m128 vec2 = _mm_loadu_ps(&src2[i]);\n        __m128 diff = _mm_sub_ps(vec1, vec2);\n        __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff);\n        \n        __m128 mask1 = _mm_cmplt_ps(abs_diff, _mm_set1_ps(50.0f));\n        __m128 index_mask = _mm_castsi128_ps(_mm_cmpeq_epi32(\n            _mm_and_si128(_mm_set1_epi32(i), _mm_set1_epi32(1)), \n            _mm_setzero_si128()));\n        \n        __m128 mul_result = _mm_mul_ps(vec1, vec2);\n        __m128 ceil_result = _mm_ceil_ps(mul_result);\n        \n        __m128 final_mask = _mm_and_ps(mask1, index_mask);\n        __m128 result = _mm_blendv_ps(_mm_set1_ps(-1.0f), ceil_result, final_mask);\n        \n        _mm_storeu_ps(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; ++i) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff < 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    size_t total_elements = m * n;\n    size_t simd_width = 2; // SSE processes 2 doubles at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n\n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    size_t total_elements = m * n;\n    size_t simd_width = 2; // SSE processes 2 doubles at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n\n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    size_t total_elements = m * n;\n    size_t simd_width = 2; // SSE processes 2 doubles at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n    \n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    size_t total_elements = m * n;\n    size_t simd_width = 2; // SSE processes 2 doubles at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n    \n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    size_t total_elements = m * n;\n    size_t simd_width = 2; // SSE processes 2 doubles at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n    \n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result_vec = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared sum using SSE\n        __m128 sum_squares = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 squared = _mm_mul_ps(vec, vec);\n            sum_squares = _mm_add_ps(sum_squares, squared);\n        }\n        \n        // Horizontal sum of squares\n        __m128 shuf1 = _mm_shuffle_ps(sum_squares, sum_squares, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128 sum1 = _mm_add_ps(sum_squares, shuf1);\n        __m128 shuf2 = _mm_shuffle_ps(sum1, sum1, _MM_SHUFFLE(0, 1, 0, 1));\n        __m128 final_sum = _mm_add_ps(sum1, shuf2);\n        \n        // Compute reciprocal square root\n        __m128 norm = _mm_sqrt_ps(final_sum);\n        __m128 recip_norm = _mm_div_ps(_mm_set1_ps(1.0f), norm);\n        \n        // Normalize row\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 normalized = _mm_mul_ps(vec, recip_norm);\n            _mm_storeu_ps(row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared sum using SSE\n        __m128 sum_squares = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 squared = _mm_mul_ps(vec, vec);\n            sum_squares = _mm_add_ps(sum_squares, squared);\n        }\n        \n        // Horizontal sum of squares\n        __m128 shuf1 = _mm_shuffle_ps(sum_squares, sum_squares, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128 sum1 = _mm_add_ps(sum_squares, shuf1);\n        __m128 shuf2 = _mm_shuffle_ps(sum1, sum1, _MM_SHUFFLE(0, 1, 0, 1));\n        __m128 final_sum = _mm_add_ps(sum1, shuf2);\n        \n        // Compute reciprocal of square root\n        __m128 norm = _mm_sqrt_ps(final_sum);\n        __m128 norm_recip = _mm_div_ps(_mm_set1_ps(1.0f), norm);\n        \n        // Normalize row\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 normalized = _mm_mul_ps(vec, norm_recip);\n            _mm_storeu_ps(row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using SSE\n        __m128 sum_squares = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 squared = _mm_mul_ps(vec, vec);\n            sum_squares = _mm_add_ps(sum_squares, squared);\n        }\n        \n        // Horizontal sum of squares\n        __m128 shuf1 = _mm_shuffle_ps(sum_squares, sum_squares, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128 sum1 = _mm_add_ps(sum_squares, shuf1);\n        __m128 shuf2 = _mm_shuffle_ps(sum1, sum1, _MM_SHUFFLE(0, 1, 0, 1));\n        __m128 final_sum = _mm_add_ps(sum1, shuf2);\n        \n        // Compute reciprocal square root\n        __m128 norm = _mm_sqrt_ps(final_sum);\n        __m128 recip_norm = _mm_div_ps(_mm_set1_ps(1.0f), norm);\n        \n        // Normalize row\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 normalized = _mm_mul_ps(vec, recip_norm);\n            _mm_storeu_ps(row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared sum using SSE\n        __m128 sum_squares = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 squared = _mm_mul_ps(vec, vec);\n            sum_squares = _mm_add_ps(sum_squares, squared);\n        }\n        \n        // Horizontal sum of squared values\n        __m128 shuf1 = _mm_shuffle_ps(sum_squares, sum_squares, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128 sum1 = _mm_add_ps(sum_squares, shuf1);\n        __m128 shuf2 = _mm_shuffle_ps(sum1, sum1, _MM_SHUFFLE(0, 1, 0, 1));\n        __m128 final_sum = _mm_add_ps(sum1, shuf2);\n        \n        // Compute L2 norm (square root of sum of squares)\n        float norm = _mm_cvtss_f32(_mm_sqrt_ss(final_sum));\n        \n        // Normalize row using reciprocal\n        float inv_norm = 1.0f / norm;\n        __m128 scale = _mm_set1_ps(inv_norm);\n        \n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 normalized = _mm_mul_ps(vec, scale);\n            _mm_storeu_ps(row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute L2 norm using SSE\n        __m128 sum_squares = _mm_setzero_ps();\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            __m128 squared = _mm_mul_ps(vec, vec);\n            sum_squares = _mm_add_ps(sum_squares, squared);\n        }\n        \n        // Horizontal sum of squares\n        __m128 shuf = _mm_shuffle_ps(sum_squares, sum_squares, _MM_SHUFFLE(1, 0, 3, 2));\n        sum_squares = _mm_add_ps(sum_squares, shuf);\n        shuf = _mm_shuffle_ps(sum_squares, sum_squares, _MM_SHUFFLE(0, 1, 0, 1));\n        sum_squares = _mm_add_ps(sum_squares, shuf);\n        \n        // Handle remaining elements if n is not divisible by 4\n        float total_sum = _mm_cvtss_f32(sum_squares);\n        for (size_t j = n - (n % 4); j < n; j++) {\n            total_sum += row[j] * row[j];\n        }\n        \n        // Compute reciprocal of square root\n        float norm = sqrtf(total_sum);\n        __m128 norm_vec = _mm_set1_ps(norm);\n        __m128 recip_norm = _mm_div_ps(_mm_set1_ps(1.0f), norm_vec);\n        \n        // Normalize row using SIMD\n        for (size_t j = 0; j < n; j += 4) {\n            __m128 vec = _mm_loadu_ps(row + j);\n            vec = _mm_mul_ps(vec, recip_norm);\n            _mm_storeu_ps(row + j, vec);\n        }\n        \n        // Handle remaining elements if n is not divisible by 4\n        for (size_t j = n - (n % 4); j < n; j++) {\n            row[j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k++) {\n                __m128d mat1_vec = _mm_set1_pd(mat1[i * n + k]);\n                __m128d mat2_vec = _mm_loadu_pd(&mat2[k * p + j]);\n                \n                sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(mat1_vec, mat2_vec));\n            }\n            \n            __m128d rounded_vec = _mm_round_pd(sum_vec, _MM_FROUND_TO_NEAREST_INT);\n            \n            if (j + 1 < p) {\n                _mm_storeu_pd(&dst[i * p + j], rounded_vec);\n            } else {\n                _mm_store_sd(&dst[i * p + j], rounded_vec);\n            }\n        }\n        \n        // Handle remaining columns if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k++) {\n                __m128d mat1_vec = _mm_set1_pd(mat1[i * n + k]);\n                __m128d mat2_vec = _mm_loadu_pd(&mat2[k * p + j]);\n                \n                sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(mat1_vec, mat2_vec));\n            }\n            \n            __m128d rounded_vec = _mm_round_pd(sum_vec, _MM_FROUND_TO_NEAREST_INT);\n            \n            if (j + 1 < p) {\n                _mm_storeu_pd(&dst[i * p + j], rounded_vec);\n            } else {\n                _mm_store_sd(&dst[i * p + j], rounded_vec);\n            }\n        }\n        \n        // Handle remaining columns if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k += 2) {\n                __m128d mat1_vec = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d mat2_vec = _mm_loadu_pd(&mat2[k * p + j]);\n                \n                __m128d mul_vec = _mm_mul_pd(mat1_vec, mat2_vec);\n                sum_vec = _mm_add_pd(sum_vec, mul_vec);\n            }\n            \n            // Handle remaining elements if n is odd\n            double sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n            for (size_t k = n - (n % 2); k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            \n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k++) {\n                __m128d mat1_vec = _mm_set1_pd(mat1[i * n + k]);\n                __m128d mat2_vec = _mm_loadu_pd(&mat2[k * p + j]);\n                sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(mat1_vec, mat2_vec));\n            }\n            \n            __m128d rounded_vec = _mm_round_pd(sum_vec, _MM_FROUND_TO_NEAREST_INT);\n            _mm_storeu_pd(&dst[i * p + j], rounded_vec);\n        }\n        \n        // Handle remaining columns if p is odd\n        if (p % 2 != 0) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + p - 1];\n            }\n            dst[i * p + p - 1] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n; k += 2) {\n                __m128d mat1_vec = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d mat2_vec = _mm_loadu_pd(&mat2[k * p + j]);\n                \n                __m128d mul_vec = _mm_mul_pd(mat1_vec, mat2_vec);\n                sum_vec = _mm_add_pd(sum_vec, mul_vec);\n            }\n            \n            // Handle remaining single element if n is odd\n            if (n % 2 != 0) {\n                double last_mat1 = mat1[i * n + n - 1];\n                double last_mat2 = mat2[(n - 1) * p + j];\n                sum_vec = _mm_add_sd(sum_vec, _mm_set_sd(last_mat1 * last_mat2));\n            }\n            \n            double sum_arr[2];\n            _mm_storeu_pd(sum_arr, sum_vec);\n            double total_sum = sum_arr[0] + sum_arr[1];\n            \n            dst[i * p + j] = round(total_sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            // Load 4x4 block\n            __m128 row0 = _mm_loadu_ps(src + i * cols + j);\n            __m128 row1 = _mm_loadu_ps(src + (i + 1) * cols + j);\n            __m128 row2 = _mm_loadu_ps(src + (i + 2) * cols + j);\n            __m128 row3 = _mm_loadu_ps(src + (i + 3) * cols + j);\n\n            // Transpose\n            __m128 tmp0 = _mm_shuffle_ps(row0, row1, _MM_SHUFFLE(1, 0, 1, 0));\n            __m128 tmp1 = _mm_shuffle_ps(row0, row1, _MM_SHUFFLE(3, 2, 3, 2));\n            __m128 tmp2 = _mm_shuffle_ps(row2, row3, _MM_SHUFFLE(1, 0, 1, 0));\n            __m128 tmp3 = _mm_shuffle_ps(row2, row3, _MM_SHUFFLE(3, 2, 3, 2));\n\n            row0 = _mm_shuffle_ps(tmp0, tmp2, _MM_SHUFFLE(2, 0, 2, 0));\n            row1 = _mm_shuffle_ps(tmp0, tmp2, _MM_SHUFFLE(3, 1, 3, 1));\n            row2 = _mm_shuffle_ps(tmp1, tmp3, _MM_SHUFFLE(2, 0, 2, 0));\n            row3 = _mm_shuffle_ps(tmp1, tmp3, _MM_SHUFFLE(3, 1, 3, 1));\n\n            // Round to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            row0 = _mm_div_ps(_mm_round_ps(row0 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row1 = _mm_div_ps(_mm_round_ps(row1 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row2 = _mm_div_ps(_mm_round_ps(row2 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row3 = _mm_div_ps(_mm_round_ps(row3 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n\n            // Store transposed and rounded block\n            _mm_storeu_ps(dst + j * rows + i, row0);\n            _mm_storeu_ps(dst + j * rows + i + 1, row1);\n            _mm_storeu_ps(dst + j * rows + i + 2, row2);\n            _mm_storeu_ps(dst + j * rows + i + 3, row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            // Load 4x4 block of source matrix\n            __m128 row0 = _mm_loadu_ps(src + i * cols + j);\n            __m128 row1 = _mm_loadu_ps(src + (i + 1) * cols + j);\n            __m128 row2 = _mm_loadu_ps(src + (i + 2) * cols + j);\n            __m128 row3 = _mm_loadu_ps(src + (i + 3) * cols + j);\n\n            // Round to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            row0 = _mm_div_ps(_mm_round_ps(row0 * _mm_rcp_ps(quarter), _MM_FROUND_TO_NEAREST_INT), _mm_rcp_ps(quarter));\n            row1 = _mm_div_ps(_mm_round_ps(row1 * _mm_rcp_ps(quarter), _MM_FROUND_TO_NEAREST_INT), _mm_rcp_ps(quarter));\n            row2 = _mm_div_ps(_mm_round_ps(row2 * _mm_rcp_ps(quarter), _MM_FROUND_TO_NEAREST_INT), _mm_rcp_ps(quarter));\n            row3 = _mm_div_ps(_mm_round_ps(row3 * _mm_rcp_ps(quarter), _MM_FROUND_TO_NEAREST_INT), _mm_rcp_ps(quarter));\n\n            // Transpose\n            __m128 tmp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 tmp1 = _mm_unpackhi_ps(row0, row1);\n            __m128 tmp2 = _mm_unpacklo_ps(row2, row3);\n            __m128 tmp3 = _mm_unpackhi_ps(row2, row3);\n\n            row0 = _mm_movelh_ps(tmp0, tmp2);\n            row1 = _mm_movehl_ps(tmp2, tmp0);\n            row2 = _mm_movelh_ps(tmp1, tmp3);\n            row3 = _mm_movehl_ps(tmp3, tmp1);\n\n            // Store transposed and rounded matrix\n            _mm_storeu_ps(dst + j * rows + i, row0);\n            _mm_storeu_ps(dst + j * rows + i + 1, row1);\n            _mm_storeu_ps(dst + j * rows + i + 2, row2);\n            _mm_storeu_ps(dst + j * rows + i + 3, row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            // Load 4x4 block of source matrix\n            __m128 row0 = _mm_loadu_ps(src + i * cols + j);\n            __m128 row1 = _mm_loadu_ps(src + (i + 1) * cols + j);\n            __m128 row2 = _mm_loadu_ps(src + (i + 2) * cols + j);\n            __m128 row3 = _mm_loadu_ps(src + (i + 3) * cols + j);\n\n            // Transpose 4x4 block\n            __m128 temp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 temp1 = _mm_unpackhi_ps(row0, row1);\n            __m128 temp2 = _mm_unpacklo_ps(row2, row3);\n            __m128 temp3 = _mm_unpackhi_ps(row2, row3);\n\n            row0 = _mm_movelh_ps(temp0, temp2);\n            row1 = _mm_movehl_ps(temp2, temp0);\n            row2 = _mm_movelh_ps(temp1, temp3);\n            row3 = _mm_movehl_ps(temp3, temp1);\n\n            // Round to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            row0 = _mm_div_ps(_mm_round_ps(row0 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row1 = _mm_div_ps(_mm_round_ps(row1 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row2 = _mm_div_ps(_mm_round_ps(row2 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row3 = _mm_div_ps(_mm_round_ps(row3 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n\n            // Store transposed and rounded block to destination matrix\n            _mm_storeu_ps(dst + j * rows + i, row0);\n            _mm_storeu_ps(dst + j * rows + i + 1, row1);\n            _mm_storeu_ps(dst + j * rows + i + 2, row2);\n            _mm_storeu_ps(dst + j * rows + i + 3, row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            // Load 4x4 block of source matrix\n            __m128 row0 = _mm_loadu_ps(&src[i * cols + j]);\n            __m128 row1 = _mm_loadu_ps(&src[(i + 1) * cols + j]);\n            __m128 row2 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Transpose 4x4 block\n            __m128 tmp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 tmp1 = _mm_unpackhi_ps(row0, row1);\n            __m128 tmp2 = _mm_unpacklo_ps(row2, row3);\n            __m128 tmp3 = _mm_unpackhi_ps(row2, row3);\n\n            row0 = _mm_movelh_ps(tmp0, tmp2);\n            row1 = _mm_movehl_ps(tmp2, tmp0);\n            row2 = _mm_movelh_ps(tmp1, tmp3);\n            row3 = _mm_movehl_ps(tmp3, tmp1);\n\n            // Round to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            row0 = _mm_div_ps(_mm_round_ps(row0 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row1 = _mm_div_ps(_mm_round_ps(row1 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row2 = _mm_div_ps(_mm_round_ps(row2 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n            row3 = _mm_div_ps(_mm_round_ps(row3 * quarter, _MM_FROUND_TO_NEAREST_INT), quarter);\n\n            // Store transposed and rounded block to destination matrix\n            _mm_storeu_ps(&dst[j * rows + i], row0);\n            _mm_storeu_ps(&dst[j * rows + i + 1], row1);\n            _mm_storeu_ps(&dst[j * rows + i + 2], row2);\n            _mm_storeu_ps(&dst[j * rows + i + 3], row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row0 = _mm_loadu_ps(src + i * cols + j);\n            __m128 row1 = _mm_loadu_ps(src + (i + 1) * cols + j);\n            __m128 row2 = _mm_loadu_ps(src + (i + 2) * cols + j);\n            __m128 row3 = _mm_loadu_ps(src + (i + 3) * cols + j);\n\n            // Rounding to nearest quarter\n            __m128 quarter = _mm_set1_ps(0.25f);\n            row0 = _mm_div_ps(_mm_round_ps(row0 * _mm_set1_ps(4.0f), _MM_FROUND_TO_NEAREST_INT), _mm_set1_ps(4.0f));\n            row1 = _mm_div_ps(_mm_round_ps(row1 * _mm_set1_ps(4.0f), _MM_FROUND_TO_NEAREST_INT), _mm_set1_ps(4.0f));\n            row2 = _mm_div_ps(_mm_round_ps(row2 * _mm_set1_ps(4.0f), _MM_FROUND_TO_NEAREST_INT), _mm_set1_ps(4.0f));\n            row3 = _mm_div_ps(_mm_round_ps(row3 * _mm_set1_ps(4.0f), _MM_FROUND_TO_NEAREST_INT), _mm_set1_ps(4.0f));\n\n            // Transpose\n            __m128 tmp0 = _mm_unpacklo_ps(row0, row1);\n            __m128 tmp1 = _mm_unpackhi_ps(row0, row1);\n            __m128 tmp2 = _mm_unpacklo_ps(row2, row3);\n            __m128 tmp3 = _mm_unpackhi_ps(row2, row3);\n\n            row0 = _mm_movelh_ps(tmp0, tmp2);\n            row1 = _mm_movehl_ps(tmp2, tmp0);\n            row2 = _mm_movelh_ps(tmp1, tmp3);\n            row3 = _mm_movehl_ps(tmp3, tmp1);\n\n            _mm_storeu_ps(dst + j * rows + i, row0);\n            _mm_storeu_ps(dst + j * rows + i + 1, row1);\n            _mm_storeu_ps(dst + j * rows + i + 2, row2);\n            _mm_storeu_ps(dst + j * rows + i + 3, row3);\n        }\n    }\n\n    // Handle remaining rows and columns if not divisible by 4\n    for (size_t i = (rows / 4) * 4; i < rows; ++i) {\n        for (size_t j = (cols / 4) * 4; j < cols; ++j) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128 vec1 = _mm_loadu_ps(tensor1);\n        __m128 vec2 = _mm_loadu_ps(tensor2);\n        \n        // Subtract vectors\n        __m128 result = _mm_sub_ps(vec1, vec2);\n        \n        // Round towards zero using truncation\n        __m128 zero = _mm_setzero_ps();\n        __m128 positive_mask = _mm_cmpgt_ps(result, zero);\n        __m128 negative_mask = _mm_cmplt_ps(result, zero);\n        __m128 truncated = _mm_and_ps(_mm_floor_ps(result), positive_mask);\n        __m128 truncated_neg = _mm_and_ps(_mm_ceil_ps(result), negative_mask);\n        __m128 final_result = _mm_or_ps(truncated, truncated_neg);\n        \n        // Store result\n        _mm_storeu_ps(dst, final_result);\n        \n        // Move pointers forward\n        tensor1 += vector_size;\n        tensor2 += vector_size;\n        dst += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        float sub_result = *tensor1 - *tensor2;\n        *dst = (sub_result >= 0) ? floorf(sub_result) : ceilf(sub_result);\n        \n        tensor1++;\n        tensor2++;\n        dst++;\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128 vec1 = _mm_loadu_ps(tensor1);\n        __m128 vec2 = _mm_loadu_ps(tensor2);\n        \n        // Subtract vectors\n        __m128 result = _mm_sub_ps(vec1, vec2);\n        \n        // Round towards zero using truncation\n        __m128 zero = _mm_setzero_ps();\n        __m128 positive_mask = _mm_cmpgt_ps(result, zero);\n        __m128 negative_mask = _mm_cmplt_ps(result, zero);\n        \n        __m128 floor_result = _mm_and_ps(positive_mask, _mm_floor_ps(result));\n        __m128 ceil_result = _mm_and_ps(negative_mask, _mm_ceil_ps(result));\n        \n        __m128 rounded_result = _mm_or_ps(floor_result, ceil_result);\n        \n        // Store result\n        _mm_storeu_ps(dst, rounded_result);\n        \n        // Move pointers forward\n        tensor1 += vector_size;\n        tensor2 += vector_size;\n        dst += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        float sub_result = *tensor1 - *tensor2;\n        *dst = (sub_result >= 0) ? floorf(sub_result) : ceilf(sub_result);\n        \n        tensor1++;\n        tensor2++;\n        dst++;\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128 vec1 = _mm_loadu_ps(tensor1);\n        __m128 vec2 = _mm_loadu_ps(tensor2);\n        \n        // Subtract vectors\n        __m128 result = _mm_sub_ps(vec1, vec2);\n        \n        // Round towards zero using truncation\n        __m128 zero = _mm_setzero_ps();\n        __m128 positive_mask = _mm_cmpgt_ps(result, zero);\n        __m128 negative_mask = _mm_cmplt_ps(result, zero);\n        \n        __m128 floor_result = _mm_and_ps(positive_mask, _mm_floor_ps(result));\n        __m128 ceil_result = _mm_and_ps(negative_mask, _mm_ceil_ps(result));\n        \n        __m128 rounded_result = _mm_or_ps(floor_result, ceil_result);\n        \n        // Store result\n        _mm_storeu_ps(dst, rounded_result);\n        \n        // Move pointers forward\n        tensor1 += vector_size;\n        tensor2 += vector_size;\n        dst += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        float sub_result = *tensor1 - *tensor2;\n        *dst = (sub_result >= 0) ? floorf(sub_result) : ceilf(sub_result);\n        \n        ++tensor1;\n        ++tensor2;\n        ++dst;\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t simd_width = 4; // SSE processes 4 floats at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n\n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        // Load 4 floats from tensor1 and tensor2\n        __m128 vec1 = _mm_loadu_ps(&tensor1[i]);\n        __m128 vec2 = _mm_loadu_ps(&tensor2[i]);\n\n        // Subtract tensor2 from tensor1\n        __m128 result = _mm_sub_ps(vec1, vec2);\n\n        // Round towards zero using truncation\n        __m128 zero = _mm_setzero_ps();\n        __m128 positive_mask = _mm_cmpgt_ps(result, zero);\n        __m128 negative_mask = _mm_cmplt_ps(result, zero);\n        __m128 truncated = _mm_sub_ps(_mm_add_ps(result, _mm_and_ps(positive_mask, _mm_set1_ps(0.5f))), \n                                       _mm_and_ps(negative_mask, _mm_set1_ps(0.5f)));\n\n        // Store result in destination tensor\n        _mm_storeu_ps(&dst[i], truncated);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        dst[i] = (float)((int)(tensor1[i] - tensor2[i]));\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128 vec1 = _mm_loadu_ps(tensor1);\n        __m128 vec2 = _mm_loadu_ps(tensor2);\n        \n        // Subtract vectors\n        __m128 result_vec = _mm_sub_ps(vec1, vec2);\n        \n        // Round towards zero using truncation\n        __m128 rounded_vec = _mm_cvttps_epi32(result_vec);\n        __m128 final_vec = _mm_cvtepi32_ps(rounded_vec);\n        \n        // Store result\n        _mm_storeu_ps(dst, final_vec);\n        \n        // Move pointers forward\n        tensor1 += vector_size;\n        tensor2 += vector_size;\n        dst += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        float subtracted = tensor1[i] - tensor2[i];\n        dst[i] = truncf(subtracted);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += 2) {\n            // Load 2 doubles from mat1 and mat2\n            __m128d vec1 = _mm_loadu_pd(&mat1[i * n + j]);\n            __m128d vec2 = _mm_loadu_pd(&mat2[i * n + j]);\n\n            // Multiply the vectors\n            __m128d result = _mm_mul_pd(vec1, vec2);\n\n            // Store the result in dst\n            _mm_storeu_pd(&dst[i * n + j], result);\n        }\n\n        // Handle any remaining single element if n is odd\n        if (n % 2 != 0) {\n            dst[i * n + n - 1] = mat1[i * n + n - 1] * mat2[i * n + n - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += 2) {\n            // Load 2 doubles from mat1 and mat2\n            __m128d vec1 = _mm_loadu_pd(&mat1[i * n + j]);\n            __m128d vec2 = _mm_loadu_pd(&mat2[i * n + j]);\n            \n            // Multiply the two vectors\n            __m128d result = _mm_mul_pd(vec1, vec2);\n            \n            // Store the result in dst\n            _mm_storeu_pd(&dst[i * n + j], result);\n        }\n        \n        // Handle any remaining single element if n is odd\n        if (n % 2 != 0) {\n            dst[i * n + n - 1] = mat1[i * n + n - 1] * mat2[i * n + n - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += 2) {\n            // Load 2 doubles from mat1 and mat2\n            __m128d vec1 = _mm_loadu_pd(&mat1[i * n + j]);\n            __m128d vec2 = _mm_loadu_pd(&mat2[i * n + j]);\n            \n            // Multiply the vectors\n            __m128d result = _mm_mul_pd(vec1, vec2);\n            \n            // Store the result in dst\n            _mm_storeu_pd(&dst[i * n + j], result);\n        }\n        \n        // Handle any remaining single element if n is odd\n        if (n % 2 != 0) {\n            dst[i * n + n - 1] = mat1[i * n + n - 1] * mat2[i * n + n - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += 2) {\n            // Load 2 doubles from mat1 and mat2\n            __m128d vec1 = _mm_loadu_pd(&mat1[i * n + j]);\n            __m128d vec2 = _mm_loadu_pd(&mat2[i * n + j]);\n\n            // Multiply the vectors\n            __m128d result = _mm_mul_pd(vec1, vec2);\n\n            // Store the result in dst\n            _mm_storeu_pd(&dst[i * n + j], result);\n        }\n\n        // Handle any remaining single element if n is odd\n        if (n % 2 != 0) {\n            dst[i * n + n - 1] = mat1[i * n + n - 1] * mat2[i * n + n - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    // Process 2 doubles at a time using SSE2 intrinsics\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < n; j += 2) {\n            // Load 2 doubles from mat1 and mat2\n            __m128d vec1 = _mm_loadu_pd(&mat1[i * n + j]);\n            __m128d vec2 = _mm_loadu_pd(&mat2[i * n + j]);\n\n            // Multiply the vectors\n            __m128d result = _mm_mul_pd(vec1, vec2);\n\n            // Store the result in dst\n            _mm_storeu_pd(&dst[i * n + j], result);\n        }\n\n        // Handle remaining single element if n is odd\n        if (n % 2 != 0) {\n            dst[i * n + n - 1] = mat1[i * n + n - 1] * mat2[i * n + n - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            \n            __m128 prod = _mm_mul_ps(mat_vec, vec_vec);\n            sum = _mm_add_ps(sum, prod);\n        }\n        \n        float result[4];\n        _mm_storeu_ps(result, sum);\n        \n        float final_sum = result[0] + result[1] + result[2] + result[3];\n        \n        for (; j < n; j++) {\n            final_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = final_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            \n            __m128 mul_vec = _mm_mul_ps(mat_vec, vec_vec);\n            sum = _mm_add_ps(sum, mul_vec);\n        }\n        \n        float temp_sum[4];\n        _mm_storeu_ps(temp_sum, sum);\n        \n        float row_sum = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n        \n        for (; j < n; j++) {\n            row_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = row_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            \n            __m128 mul_vec = _mm_mul_ps(mat_vec, vec_vec);\n            sum = _mm_add_ps(sum, mul_vec);\n        }\n        \n        float temp_sum[4];\n        _mm_storeu_ps(temp_sum, sum);\n        \n        float row_sum = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n        \n        for (; j < n; j++) {\n            row_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = row_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            \n            __m128 mul_vec = _mm_mul_ps(mat_vec, vec_vec);\n            sum = _mm_add_ps(sum, mul_vec);\n        }\n        \n        float temp_sum[4];\n        _mm_storeu_ps(temp_sum, sum);\n        float row_sum = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n        \n        for (; j < n; j++) {\n            row_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = row_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        \n        size_t j;\n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            \n            __m128 mul_vec = _mm_mul_ps(mat_vec, vec_vec);\n            sum = _mm_add_ps(sum, mul_vec);\n        }\n        \n        float temp_sum[4];\n        _mm_storeu_ps(temp_sum, sum);\n        \n        float row_sum = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n        \n        for (; j < n; j++) {\n            row_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = row_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    // Process 2 doubles at a time using SSE2\n    size_t i = 0;\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d current_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, current_vec);\n    }\n    \n    // Handle any remaining single element\n    double sum_scalar = 0.0;\n    for (; i < total_elements; ++i) {\n        sum_scalar += mat[i];\n    }\n    \n    // Horizontal sum of SSE vector\n    double sum_array[2];\n    _mm_storeu_pd(sum_array, sum_vec);\n    double simd_sum = sum_array[0] + sum_array[1] + sum_scalar;\n    \n    return simd_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    // Process 2 doubles at a time using SSE2\n    size_t i = 0;\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d current_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, current_vec);\n    }\n    \n    // Handle any remaining single element\n    double sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n    \n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double total_sum = 0.0;\n    size_t total_elements = m * n;\n    \n    // Process 2 doubles at a time using SSE2\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i = 0;\n    \n    // Vectorized processing\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, vec);\n    }\n    \n    // Horizontal sum of vector\n    __m128d shuffled = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n    sum_vec = _mm_add_pd(sum_vec, shuffled);\n    total_sum = _mm_cvtsd_f64(sum_vec);\n    \n    // Process remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += mat[i];\n    }\n    \n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    // Process 2 doubles at a time using SSE2\n    __m128d sum_vec = _mm_setzero_pd();\n    size_t i;\n    for (i = 0; i < total_elements - 1; i += 2) {\n        __m128d vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, vec);\n    }\n    \n    // Horizontal sum of the vector\n    __m128d sum_high = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n    sum_vec = _mm_add_pd(sum_vec, sum_high);\n    _mm_store_sd(&sum, sum_vec);\n    \n    // Handle any remaining elements\n    for (; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    size_t i = 0;\n    for (; i + 1 < total_elements; i += 2) {\n        __m128d current_vec = _mm_loadu_pd(&mat[i]);\n        sum_vec = _mm_add_pd(sum_vec, current_vec);\n    }\n    \n    double sum_array[2];\n    _mm_storeu_pd(sum_array, sum_vec);\n    double total_sum = sum_array[0] + sum_array[1];\n    \n    // Handle remaining element if total_elements is odd\n    if (i < total_elements) {\n        total_sum += mat[i];\n    }\n    \n    return total_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        bool ascending = directions[r];\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t simd_cols = cols - (cols % 4);\n        for (size_t c = 0; c < simd_cols; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 4]);\n            \n            __m128i compare;\n            if (ascending) {\n                // Check if current <= next for ascending order\n                compare = _mm_cmpgt_epi32(current, next);\n            } else {\n                // Check if current >= next for descending order\n                compare = _mm_cmpgt_epi32(next, current);\n            }\n            \n            if (_mm_movemask_epi8(compare) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = simd_cols; c < cols - 1; c++) {\n            if (ascending && row[c] > row[c + 1]) {\n                return false;\n            }\n            if (!ascending && row[c] < row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        bool ascending = directions[r];\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t simd_cols = cols - (cols % 4);\n        for (size_t c = 0; c < simd_cols; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 4]);\n            \n            __m128i comparison;\n            if (ascending) {\n                // Check if current <= next for ascending order\n                comparison = _mm_cmpgt_epi32(current, next);\n            } else {\n                // Check if current >= next for descending order\n                comparison = _mm_cmpgt_epi32(next, current);\n            }\n            \n            if (_mm_movemask_epi8(comparison) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = simd_cols; c < cols - 1; c++) {\n            if (ascending && row[c] > row[c + 1]) {\n                return false;\n            }\n            if (!ascending && row[c] < row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        bool ascending = directions[r];\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t vec_cols = cols - (cols % 4);\n        for (size_t c = 0; c < vec_cols; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 4]);\n            \n            __m128i compare;\n            if (ascending) {\n                // Check ascending order\n                compare = _mm_cmpgt_epi32(current, next);\n            } else {\n                // Check descending order\n                compare = _mm_cmplt_epi32(current, next);\n            }\n            \n            if (_mm_movemask_epi8(compare) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = vec_cols; c < cols - 1; c++) {\n            if (ascending && row[c] > row[c + 1]) {\n                return false;\n            }\n            if (!ascending && row[c] < row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        bool ascending = directions[r];\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t simd_cols = cols - (cols % 4);\n        for (size_t c = 0; c < simd_cols; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 4]);\n            \n            __m128i compare;\n            if (ascending) {\n                // Check if current <= next for ascending order\n                compare = _mm_cmpgt_epi32(current, next);\n            } else {\n                // Check if current >= next for descending order\n                compare = _mm_cmpgt_epi32(next, current);\n            }\n            \n            if (_mm_movemask_epi8(compare) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = simd_cols; c < cols - 1; c++) {\n            if (ascending && row[c] > row[c + 1]) {\n                return false;\n            }\n            if (!ascending && row[c] < row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        bool ascending = directions[r];\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t vec_cols = cols - (cols % 4);\n        for (size_t c = 0; c < vec_cols; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[c]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[c + 4]);\n            \n            __m128i compare;\n            if (ascending) {\n                // Check if current <= next for ascending order\n                compare = _mm_cmpgt_epi32(current, next);\n            } else {\n                // Check if current >= next for descending order\n                compare = _mm_cmpgt_epi32(next, current);\n            }\n            \n            if (_mm_movemask_epi8(compare) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = vec_cols; c < cols - 1; c++) {\n            if (ascending && row[c] > row[c + 1]) {\n                return false;\n            }\n            if (!ascending && row[c] < row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    // Broadcast base to all elements of a 16-bit vector\n    __m128i base_vec = _mm_set1_epi16(base);\n    \n    // Process 8 elements at a time using SSE2\n    size_t vectorized_length = length - (length % 8);\n    for (size_t i = 0; i < vectorized_length; i += 8) {\n        // Load 8 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Divide each element by base\n        __m128i div_vec = _mm_div_epi16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        __m128i multiple_vec = _mm_mullo_epi16(div_vec, base_vec);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    // Broadcast base to all elements of a 16-bit vector\n    __m128i base_vec = _mm_set1_epi16(base);\n    \n    // Process 8 elements at a time using SSE2\n    size_t i;\n    for (i = 0; i + 7 < length; i += 8) {\n        // Load 8 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Divide each element by base\n        __m128i div_vec = _mm_div_epi16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        __m128i multiple_vec = _mm_mullo_epi16(div_vec, base_vec);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    // Broadcast base to all elements of an SSE register\n    __m128i base_vec = _mm_set1_epi16(base);\n    \n    // Process 8 elements at a time (SSE works with 128-bit vectors)\n    size_t vectorized_length = length - (length % 8);\n    \n    for (size_t i = 0; i < vectorized_length; i += 8) {\n        // Load 8 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Divide each element by base\n        __m128i div_vec = _mm_div_epi16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        __m128i multiple_vec = _mm_mullo_epi16(div_vec, base_vec);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    // Broadcast base to all elements of an SSE register\n    __m128i base_vec = _mm_set1_epi16(base);\n    \n    // Process 8 elements at a time (SSE works with 128-bit vectors)\n    size_t vectorized_length = length - (length % 8);\n    \n    for (size_t i = 0; i < vectorized_length; i += 8) {\n        // Load 8 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Divide each element by base\n        __m128i div_vec = _mm_div_epi16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        __m128i multiple_vec = _mm_mullo_epi16(div_vec, base_vec);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    // Broadcast base to all elements of a 16-bit vector\n    __m128i base_vec = _mm_set1_epi16(base);\n    \n    // Process 8 elements at a time using SSE2\n    size_t i;\n    for (i = 0; i + 7 < length; i += 8) {\n        // Load 8 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Divide each element by base\n        __m128i div_vec = _mm_div_epi16(src_vec, base_vec);\n        \n        // Multiply back to get nearest multiple\n        __m128i multiple_vec = _mm_mullo_epi16(div_vec, base_vec);\n        \n        // Store result in destination\n        _mm_storeu_si128((__m128i*)&dst[i], multiple_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single SSE register\n    const size_t doubles_per_register = 2;\n    \n    // Iterate through each row of the matrix\n    for (size_t row = 0; row < rows; row++) {\n        bool row_match = true;\n        \n        // Process 2 doubles at a time using SSE2\n        size_t simd_cols = cols - (cols % doubles_per_register);\n        for (size_t col = 0; col < simd_cols; col += doubles_per_register) {\n            // Load matrix row and vector values into SSE registers\n            __m128d matrix_vec = _mm_loadu_pd(&matrix[row * cols + col]);\n            __m128d input_vec = _mm_loadu_pd(&vector[col]);\n            \n            // Compare matrix row values with vector values\n            __m128d cmp_result = _mm_cmpeq_pd(matrix_vec, input_vec);\n            \n            // Check if all values match\n            if (_mm_movemask_pd(cmp_result) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        // Handle remaining columns not processed by SIMD\n        if (row_match) {\n            for (size_t col = simd_cols; col < cols; col++) {\n                if (matrix[row * cols + col] != vector[col]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n        \n        // If entire row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single SSE register\n    const size_t SSE_DOUBLES = 2;\n    \n    // Iterate through each row of the matrix\n    for (size_t r = 0; r < rows; r++) {\n        // Pointer to current row\n        const double* current_row = matrix + r * cols;\n        \n        // Track if current row matches vector\n        bool row_match = true;\n        \n        // Process vector in SSE-sized chunks\n        size_t simd_cols = cols - (cols % SSE_DOUBLES);\n        for (size_t c = 0; c < simd_cols; c += SSE_DOUBLES) {\n            // Load vector and matrix row chunks into SSE registers\n            __m128d vec_chunk = _mm_loadu_pd(vector + c);\n            __m128d row_chunk = _mm_loadu_pd(current_row + c);\n            \n            // Compare chunks for equality\n            __m128d cmp_result = _mm_cmpeq_pd(vec_chunk, row_chunk);\n            \n            // Check if all elements match\n            if (_mm_movemask_pd(cmp_result) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        // Handle remaining elements not processed by SSE\n        if (row_match) {\n            for (size_t c = simd_cols; c < cols; c++) {\n                if (vector[c] != current_row[c]) {\n                    row_match = false;\n                    break;\n                }\n            }\n        }\n        \n        // If entire row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Process 2 doubles at a time using SSE2 \n    size_t vec_cols = cols / 2;\n    size_t remaining_cols = cols % 2;\n\n    for (size_t r = 0; r < rows; r++) {\n        // Load vector into SSE register\n        __m128d vec_vec = _mm_loadu_pd(vector);\n\n        bool row_match = true;\n        size_t c;\n\n        // Process 2 columns at a time \n        for (c = 0; c < vec_cols; c++) {\n            __m128d vec_mat = _mm_loadu_pd(&matrix[r * cols + c * 2]);\n            __m128d vec_cmp = _mm_cmpeq_pd(vec_vec, vec_mat);\n            \n            // If any comparison fails, this row doesn't match\n            if (_mm_movemask_pd(vec_cmp) != 3) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // Handle remaining single column if cols is odd\n        if (row_match && remaining_cols) {\n            if (matrix[r * cols + cols - 1] != vector[cols - 1]) {\n                row_match = false;\n            }\n        }\n\n        // If row matches completely, return true\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single SSE register\n    const size_t SIMD_WIDTH = 2;\n\n    // Iterate through each row of the matrix\n    for (size_t row = 0; row < rows; row++) {\n        // Assume row matches until proven otherwise\n        bool row_matches = true;\n\n        // Process 2 doubles at a time using SSE\n        size_t simd_cols = cols - (cols % SIMD_WIDTH);\n        for (size_t col = 0; col < simd_cols; col += SIMD_WIDTH) {\n            // Load matrix row and vector values into SSE registers\n            __m128d matrix_vec = _mm_loadu_pd(&matrix[row * cols + col]);\n            __m128d vector_vec = _mm_loadu_pd(&vector[col]);\n\n            // Compare matrix row values with vector values\n            __m128d cmp = _mm_cmpeq_pd(matrix_vec, vector_vec);\n\n            // Check if all values match\n            if (_mm_movemask_pd(cmp) != 0x3) {\n                row_matches = false;\n                break;\n            }\n        }\n\n        // Handle remaining columns not processed by SIMD\n        for (size_t col = simd_cols; col < cols; col++) {\n            if (matrix[row * cols + col] != vector[col]) {\n                row_matches = false;\n                break;\n            }\n        }\n\n        // If row matches, return true\n        if (row_matches) {\n            return true;\n        }\n    }\n\n    // No matching row found\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    // Number of doubles that can be processed in a single SSE register\n    const size_t SIMD_WIDTH = 2;\n\n    // Iterate through each row of the matrix\n    for (size_t r = 0; r < rows; r++) {\n        bool row_match = true;\n\n        // Process vector in SIMD chunks\n        size_t c = 0;\n        for (; c + SIMD_WIDTH <= cols; c += SIMD_WIDTH) {\n            // Load matrix row and vector chunks into SSE registers\n            __m128d matrix_chunk = _mm_loadu_pd(&matrix[r * cols + c]);\n            __m128d vector_chunk = _mm_loadu_pd(&vector[c]);\n\n            // Compare matrix row chunk with vector chunk\n            __m128d cmp = _mm_cmpeq_pd(matrix_chunk, vector_chunk);\n\n            // Check if all elements match\n            if (_mm_movemask_pd(cmp) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // Handle remaining elements not processed by SIMD\n        for (; c < cols; c++) {\n            if (matrix[r * cols + c] != vector[c]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        // If entire row matches, return true\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 bytes at a time using SSE2\n    size_t vector_size = total_elements - (total_elements % 16);\n    \n    for (size_t i = 0; i < vector_size; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compare bytes for equality\n        __m128i vcmp = _mm_cmpeq_epi8(va, vb);\n        \n        // Create a mask of the comparison results\n        int mask = _mm_movemask_epi8(vcmp);\n        \n        // Count the number of equal bytes\n        equal_count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_size; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            ++equal_count;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 bytes at a time using SSE2 intrinsics\n    size_t vector_size = total_elements - (total_elements % 16);\n    \n    for (size_t i = 0; i < vector_size; i += 16) {\n        __m128i vec_a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vec_b = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compare vectors for equality\n        __m128i equal_mask = _mm_cmpeq_epi8(vec_a, vec_b);\n        \n        // Count equal elements using movemask and popcount\n        int mask = _mm_movemask_epi8(equal_mask);\n        equal_count += __builtin_popcount(mask);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_size; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 bytes at a time using SSE2\n    size_t vector_size = total_elements - (total_elements % 16);\n    \n    for (size_t i = 0; i < vector_size; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compare bytes for equality\n        __m128i veq = _mm_cmpeq_epi8(va, vb);\n        \n        // Create a mask of equal bytes\n        int mask = _mm_movemask_epi8(veq);\n        \n        // Count the number of equal bytes\n        equal_count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_size; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 bytes at a time using SSE2\n    size_t vec_size = total_elements - (total_elements % 16);\n    \n    for (size_t i = 0; i < vec_size; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compare bytes for equality\n        __m128i vcmp = _mm_cmpeq_epi8(va, vb);\n        \n        // Create a mask of equal bytes\n        int mask = _mm_movemask_epi8(vcmp);\n        \n        // Count the number of equal bytes\n        equal_count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process 16 bytes at a time using SSE2\n    size_t vector_size = total_elements - (total_elements % 16);\n    \n    for (size_t i = 0; i < vector_size; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compare bytes for equality\n        __m128i veq = _mm_cmpeq_epi8(va, vb);\n        \n        // Create a mask of equal bytes\n        int mask = _mm_movemask_epi8(veq);\n        \n        // Count the number of equal bytes\n        equal_count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vector_size; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    // Process 2 int64_t elements at a time using SSE2 intrinsics\n    size_t i;\n    __m128i a_vec = _mm_set1_epi64x(a);\n\n    for (i = 0; i < length - 1; i += 2) {\n        // Load x vector\n        __m128i x_vec = _mm_loadu_si128((__m128i*)&x[i]);\n\n        // Multiply a * x\n        __m128i mul_vec = _mm_mul_epi32(a_vec, x_vec);\n\n        // Compute absolute value\n        __m128i abs_vec = _mm_abs_epi64(mul_vec);\n\n        // Store result to y\n        _mm_storeu_si128((__m128i*)&y[i], abs_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = llabs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    // Process 2 int64_t elements at a time using SSE2 intrinsics\n    size_t i = 0;\n    __m128i a_vec = _mm_set1_epi64x(a);\n\n    // Process 2 elements per iteration\n    for (; i + 1 < length; i += 2) {\n        // Load x vector\n        __m128i x_vec = _mm_loadu_si128((__m128i*)&x[i]);\n\n        // Multiply a * x\n        __m128i mul_vec = _mm_mul_epi32(a_vec, x_vec);\n\n        // Compute absolute value\n        __m128i abs_vec = _mm_abs_epi64(mul_vec);\n\n        // Store result to y\n        _mm_storeu_si128((__m128i*)&y[i], abs_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = std::abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    // Process 2 int64_t elements at a time using SSE2 intrinsics\n    size_t i = 0;\n    __m128i scalar_vec = _mm_set1_epi64x(a);\n\n    // Process vectors in groups of 2\n    for (; i + 1 < length; i += 2) {\n        // Load x vector\n        __m128i x_vec = _mm_loadu_si128((__m128i*)&x[i]);\n\n        // Multiply x vector with scalar\n        __m128i ax_vec = _mm_mul_epi32(x_vec, scalar_vec);\n\n        // Take absolute value\n        __m128i abs_vec = _mm_abs_epi64(ax_vec);\n\n        // Store result to y\n        _mm_storeu_si128((__m128i*)&y[i], abs_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = std::abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    // Process 2 int64_t elements at a time using SSE2 intrinsics\n    size_t vec_length = length - (length % 2);\n    \n    // Broadcast scalar 'a' to all lanes of 128-bit vector\n    __m128i a_vec = _mm_set1_epi64x(a);\n    \n    for (size_t i = 0; i < vec_length; i += 2) {\n        // Load 2 elements from x\n        __m128i x_vec = _mm_loadu_si128((__m128i*)&x[i]);\n        \n        // Multiply x by scalar a\n        __m128i ax_vec = _mm_mul_epi32(x_vec, a_vec);\n        \n        // Compute absolute value\n        __m128i abs_vec = _mm_abs_epi64(ax_vec);\n        \n        // Store result to y\n        _mm_storeu_si128((__m128i*)&y[i], abs_vec);\n    }\n    \n    // Handle remaining elements if length is odd\n    for (size_t i = vec_length; i < length; i++) {\n        y[i] = std::abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    // Process 2 int64_t elements at a time using SSE2 intrinsics\n    size_t i = 0;\n    __m128i a_vec = _mm_set1_epi64x(a);\n\n    // Process vectors in groups of 2\n    for (; i + 1 < length; i += 2) {\n        // Load x vector\n        __m128i x_vec = _mm_loadu_si128((__m128i*)&x[i]);\n        \n        // Multiply a * x\n        __m128i mul_vec = _mm_mul_epi32(a_vec, x_vec);\n        \n        // Take absolute value\n        __m128i abs_vec = _mm_abs_epi64(mul_vec);\n        \n        // Store result to y\n        _mm_storeu_si128((__m128i*)&y[i], abs_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = std::abs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time with SSE2\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i current = _mm_loadu_si128((__m128i*)&vec[i]);\n        \n        // Unpack lower and upper halves to compare\n        __m128i low = _mm_unpacklo_epi16(current, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi16(current, _mm_setzero_si128());\n        \n        // Find min and max in lower half\n        __m128i min_low = _mm_min_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        min_low = _mm_min_epi16(min_low, _mm_shuffle_epi32(min_low, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        __m128i max_low = _mm_max_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        max_low = _mm_max_epi16(max_low, _mm_shuffle_epi32(max_low, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        // Update global min and max\n        result.min_num = _mm_cvtsi128_si32(min_low) < result.min_num ? \n                         _mm_cvtsi128_si32(min_low) : result.min_num;\n        result.max_num = _mm_cvtsi128_si32(max_low) > result.max_num ? \n                         _mm_cvtsi128_si32(max_low) : result.max_num;\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = vec[i] < result.min_num ? vec[i] : result.min_num;\n        result.max_num = vec[i] > result.max_num ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        __m128i current = _mm_loadu_si128((__m128i*)&vec[i]);\n        \n        // Shuffle and compare to find min and max\n        __m128i min1 = _mm_min_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        __m128i max1 = _mm_max_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        \n        min1 = _mm_min_epi16(min1, _mm_shuffle_epi32(min1, _MM_SHUFFLE(0, 1, 2, 3)));\n        max1 = _mm_max_epi16(max1, _mm_shuffle_epi32(max1, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        int16_t min_val = _mm_cvtsi128_si32(min1);\n        int16_t max_val = _mm_cvtsi128_si32(max1);\n        \n        result.min_num = (min_val < result.min_num) ? min_val : result.min_num;\n        result.max_num = (max_val > result.max_num) ? max_val : result.max_num;\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = (vec[i] < result.min_num) ? vec[i] : result.min_num;\n        result.max_num = (vec[i] > result.max_num) ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i current = _mm_loadu_si128((__m128i*)&vec[i]);\n        \n        // Unpack lower and upper halves to compare\n        __m128i low = _mm_unpacklo_epi16(current, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi16(current, _mm_setzero_si128());\n        \n        // Find min and max in lower half\n        __m128i min_low = _mm_min_epi16(low, _mm_shuffle_epi32(low, _MM_SHUFFLE(1, 0, 3, 2)));\n        min_low = _mm_min_epi16(min_low, _mm_shuffle_epi32(min_low, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        __m128i max_low = _mm_max_epi16(low, _mm_shuffle_epi32(low, _MM_SHUFFLE(1, 0, 3, 2)));\n        max_low = _mm_max_epi16(max_low, _mm_shuffle_epi32(max_low, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        // Find min and max in upper half\n        __m128i min_high = _mm_min_epi16(high, _mm_shuffle_epi32(high, _MM_SHUFFLE(1, 0, 3, 2)));\n        min_high = _mm_min_epi16(min_high, _mm_shuffle_epi32(min_high, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        __m128i max_high = _mm_max_epi16(high, _mm_shuffle_epi32(high, _MM_SHUFFLE(1, 0, 3, 2)));\n        max_high = _mm_max_epi16(max_high, _mm_shuffle_epi32(max_high, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        // Extract min and max values\n        int16_t current_min = _mm_cvtsi128_si32(min_low) < _mm_cvtsi128_si32(min_high) ? \n                               _mm_cvtsi128_si32(min_low) : _mm_cvtsi128_si32(min_high);\n        int16_t current_max = _mm_cvtsi128_si32(max_low) > _mm_cvtsi128_si32(max_high) ? \n                               _mm_cvtsi128_si32(max_low) : _mm_cvtsi128_si32(max_high);\n        \n        result.min_num = current_min < result.min_num ? current_min : result.min_num;\n        result.max_num = current_max > result.max_num ? current_max : result.max_num;\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        result.min_num = vec[i] < result.min_num ? vec[i] : result.min_num;\n        result.max_num = vec[i] > result.max_num ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time with SSE2\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i current = _mm_loadu_si128((__m128i*)&vec[i]);\n        \n        // Unpack and compare lower and upper halves\n        __m128i low = _mm_unpacklo_epi16(current, _mm_setzero_si128());\n        __m128i high = _mm_unpackhi_epi16(current, _mm_setzero_si128());\n        \n        // Find min and max in lower half\n        __m128i min_low = _mm_min_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        min_low = _mm_min_epi16(min_low, _mm_shuffle_epi32(min_low, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        __m128i max_low = _mm_max_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        max_low = _mm_max_epi16(max_low, _mm_shuffle_epi32(max_low, _MM_SHUFFLE(0, 1, 2, 3)));\n        \n        // Update global min and max\n        result.min_num = _mm_cvtsi128_si32(min_low) < result.min_num ? _mm_cvtsi128_si32(min_low) : result.min_num;\n        result.max_num = _mm_cvtsi128_si32(max_low) > result.max_num ? _mm_cvtsi128_si32(max_low) : result.max_num;\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < length; i++) {\n        result.min_num = vec[i] < result.min_num ? vec[i] : result.min_num;\n        result.max_num = vec[i] > result.max_num ? vec[i] : result.max_num;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    // Process 8 elements at a time using SSE2\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        __m128i current = _mm_loadu_si128((__m128i*)&vec[i]);\n        \n        // Compute minimum\n        __m128i min_vec = _mm_min_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        min_vec = _mm_min_epi16(min_vec, _mm_shuffle_epi32(min_vec, _MM_SHUFFLE(0, 1, 2, 3)));\n        int16_t min_val = _mm_cvtsi128_si32(min_vec);\n        result.min_num = min(result.min_num, min_val);\n        \n        // Compute maximum\n        __m128i max_vec = _mm_max_epi16(current, _mm_shuffle_epi32(current, _MM_SHUFFLE(1, 0, 3, 2)));\n        max_vec = _mm_max_epi16(max_vec, _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(0, 1, 2, 3)));\n        int16_t max_val = _mm_cvtsi128_si32(max_vec);\n        result.max_num = max(result.max_num, max_val);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        result.min_num = min(result.min_num, vec[i]);\n        result.max_num = max(result.max_num, vec[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t i = 0;\n        for (; i + 4 <= cols; i += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[i]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[i+1]);\n            \n            // Compare if each element is less than the next\n            __m128i compare = _mm_cmpgt_epi32(current, next);\n            \n            // If any element is not less than the next, return false\n            if (_mm_movemask_epi8(compare) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (; i < cols - 1; i++) {\n            if (row[i] >= row[i+1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t i = 0;\n        for (; i + 4 <= cols; i += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[i]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[i+1]);\n            \n            // Compare if each element is less than the next\n            __m128i cmp = _mm_cmpgt_epi32(current, next);\n            \n            // If any element is not less than the next, row is not strictly increasing\n            if (_mm_movemask_epi8(cmp) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (; i < cols - 1; i++) {\n            if (row[i] >= row[i+1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        for (size_t c = 0; c + 4 <= cols; c += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)(row + c));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + c + 1));\n            \n            // Compare if each element is less than the next\n            __m128i compare = _mm_cmplt_epi32(current, next);\n            \n            // Check if all comparisons are true\n            if (_mm_movemask_ps(_mm_castsi128_ps(compare)) != 0x0F) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t c = (cols / 4) * 4; c < cols - 1; c++) {\n            if (row[c] >= row[c + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t i = 0;\n        for (; i + 4 <= cols; i += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[i]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[i+1]);\n            \n            // Compare if each element is less than the next\n            __m128i cmp = _mm_cmpgt_epi32(current, next);\n            \n            // If any element is not less than the next, return false\n            if (_mm_movemask_epi8(cmp) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (; i < cols - 1; i++) {\n            if (row[i] >= row[i+1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        \n        // Process 4 elements at a time using SSE\n        size_t i = 0;\n        for (; i + 4 <= cols; i += 4) {\n            __m128i current = _mm_loadu_si128((__m128i*)&row[i]);\n            __m128i next = _mm_loadu_si128((__m128i*)&row[i+1]);\n            \n            // Compare if each element is less than the next\n            __m128i cmp = _mm_cmpgt_epi32(current, next);\n            \n            // If any element is not less than the next, return false\n            if (_mm_movemask_epi8(cmp) != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (; i < cols - 1; i++) {\n            if (row[i] >= row[i+1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for invalid block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Reference block (first block)\n    const int* first_block = matrix;\n\n    // Iterate through blocks\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            // Compare blocks using SSE2 intrinsics\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    // Load 4 integers at a time\n                    __m128i ref_vec = _mm_loadu_si128((__m128i*)(first_block + i * cols + j));\n                    __m128i curr_vec = _mm_loadu_si128((__m128i*)(current_block + i * cols + j));\n\n                    // Compare vectors\n                    __m128i cmp_result = _mm_cmpeq_epi32(ref_vec, curr_vec);\n\n                    // Check if all elements are equal\n                    if (_mm_movemask_epi8(cmp_result) != 0xFFFF) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements if block_size is not multiple of 4\n                for (size_t j = block_size - (block_size % 4); j < block_size; ++j) {\n                    if (first_block[i * cols + j] != current_block[i * cols + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // First block to compare against\n    const int* first_block = matrix;\n\n    // Iterate through blocks\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            // Compare block using SSE2 intrinsics\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    __m128i first_vec = _mm_loadu_si128((__m128i*)(first_block + i * cols + j));\n                    __m128i current_vec = _mm_loadu_si128((__m128i*)(current_block + i * cols + j));\n                    \n                    // Compare 4 integers at a time\n                    __m128i cmp_result = _mm_cmpeq_epi32(first_vec, current_vec);\n                    \n                    // Check if all 4 integers are equal\n                    if (_mm_movemask_epi8(cmp_result) != 0xFFFF) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Iterate through blocks\n    for (size_t block_row = 0; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip first block\n\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            // Compare blocks using SSE2 intrinsics\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    __m128i ref_vec = _mm_loadu_si128((__m128i*)(first_block + i * cols + j));\n                    __m128i curr_vec = _mm_loadu_si128((__m128i*)(current_block + i * cols + j));\n                    \n                    __m128i cmp_result = _mm_cmpeq_epi32(ref_vec, curr_vec);\n                    int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp_result));\n                    \n                    if (mask != 0xF) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Reference block (first block)\n    const int* ref_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Starting point of current block\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            // Compare blocks using SSE2 intrinsics\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    __m128i ref_vec = _mm_loadu_si128((__m128i*)(ref_block + i * cols + j));\n                    __m128i curr_vec = _mm_loadu_si128((__m128i*)(current_block + i * cols + j));\n                    \n                    // Compare 4 integers at a time\n                    __m128i cmp_result = _mm_cmpeq_epi32(ref_vec, curr_vec);\n                    \n                    // Check if all 4 integers are equal\n                    if (_mm_movemask_epi8(cmp_result) != 0xFFFF) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Iterate through blocks\n    for (size_t block_row = 0; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            if (block_row == 0 && block_col == 0) continue; // Skip first block\n\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            // SIMD comparison\n            for (size_t i = 0; i < block_size; ++i) {\n                size_t row_offset = i * cols;\n                \n                // Process 4 integers at a time using SSE\n                for (size_t j = 0; j < block_size; j += 4) {\n                    __m128i ref_vec = _mm_loadu_si128((__m128i*)(first_block + row_offset + j));\n                    __m128i curr_vec = _mm_loadu_si128((__m128i*)(current_block + row_offset + j));\n                    \n                    // Compare vectors\n                    __m128i cmp_result = _mm_cmpeq_epi32(ref_vec, curr_vec);\n                    \n                    // Check if all elements are equal\n                    if (_mm_movemask_epi8(cmp_result) != 0xFFFF) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements if block_size is not multiple of 4\n                for (size_t j = block_size - (block_size % 4); j < block_size; ++j) {\n                    if (first_block[row_offset + j] != current_block[row_offset + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into SSE registers\n    __m128d first_block_low = _mm_loadu_pd(&vec[0]);\n    __m128d first_block_high = _mm_loadu_pd(&vec[2]);\n\n    // Broadcast tolerance to SSE registers\n    __m128d tol_low = _mm_set1_pd(tolerance);\n    __m128d tol_high = _mm_set1_pd(tolerance);\n\n    // Compare each subsequent block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        size_t start_idx = block * block_size;\n\n        // Load current block\n        __m128d curr_block_low = _mm_loadu_pd(&vec[start_idx]);\n        __m128d curr_block_high = _mm_loadu_pd(&vec[start_idx + 2]);\n\n        // Compute absolute differences\n        __m128d diff_low = _mm_sub_pd(first_block_low, curr_block_low);\n        __m128d diff_high = _mm_sub_pd(first_block_high, curr_block_high);\n        __m128d abs_diff_low = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_low);\n        __m128d abs_diff_high = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_high);\n\n        // Check if differences exceed tolerance\n        __m128d cmp_low = _mm_cmpgt_pd(abs_diff_low, tol_low);\n        __m128d cmp_high = _mm_cmpgt_pd(abs_diff_high, tol_high);\n\n        // If any difference exceeds tolerance, return false\n        if (_mm_movemask_pd(cmp_low) || _mm_movemask_pd(cmp_high)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Prepare tolerance vector\n    __m128d tol_vec = _mm_set1_pd(tolerance);\n\n    // Load first block reference values\n    __m128d* first_block = (__m128d*)vec;\n\n    // Iterate through blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        __m128d* current_block = (__m128d*)(vec + block * block_size);\n\n        for (size_t i = 0; i < block_size / 2; ++i) {\n            // Compare current block with first block\n            __m128d diff = _mm_sub_pd(first_block[i], current_block[i]);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmpgt_pd(abs_diff, tol_vec);\n\n            // If any element exceeds tolerance, return false\n            if (_mm_movemask_pd(cmp)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = (length - block_size + 1) / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    // Load first block into SSE registers\n    __m128d first_block_low = _mm_loadu_pd(&vec[0]);\n    __m128d first_block_high = _mm_loadu_pd(&vec[2]);\n\n    // Broadcast tolerance to SSE registers\n    __m128d tol_low = _mm_set1_pd(tolerance);\n    __m128d tol_high = _mm_set1_pd(tolerance);\n\n    // Compare each subsequent block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        size_t start_idx = block * block_size;\n\n        // Load current block\n        __m128d curr_block_low = _mm_loadu_pd(&vec[start_idx]);\n        __m128d curr_block_high = _mm_loadu_pd(&vec[start_idx + 2]);\n\n        // Compute absolute differences\n        __m128d diff_low = _mm_sub_pd(first_block_low, curr_block_low);\n        __m128d diff_high = _mm_sub_pd(first_block_high, curr_block_high);\n        \n        diff_low = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_low); // abs value\n        diff_high = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_high); // abs value\n\n        // Check if differences exceed tolerance\n        __m128d cmp_low = _mm_cmpgt_pd(diff_low, tol_low);\n        __m128d cmp_high = _mm_cmpgt_pd(diff_high, tol_high);\n\n        // If any difference exceeds tolerance, return false\n        if (_mm_movemask_pd(cmp_low) || _mm_movemask_pd(cmp_high)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into SSE registers\n    __m128d first_block[4];\n    for (size_t i = 0; i < block_size; i += 2) {\n        first_block[i/2] = _mm_loadu_pd(&vec[i]);\n    }\n\n    // Tolerance vector\n    __m128d tol_vec = _mm_set1_pd(tolerance);\n\n    // Compare subsequent blocks\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        size_t block_start = block * block_size;\n        \n        for (size_t i = 0; i < block_size; i += 2) {\n            __m128d current_block = _mm_loadu_pd(&vec[block_start + i]);\n            \n            // Compute absolute difference\n            __m128d diff1 = _mm_sub_pd(first_block[i/2], current_block);\n            __m128d abs_diff1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff1);\n            \n            // Check if difference exceeds tolerance\n            __m128d cmp1 = _mm_cmpgt_pd(abs_diff1, tol_vec);\n            \n            // If any element exceeds tolerance, return false\n            if (_mm_movemask_pd(cmp1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Load first block into SSE registers\n    __m128d first_block[4];\n    for (size_t j = 0; j < block_size; j += 2) {\n        first_block[j/2] = _mm_loadu_pd(&vec[j]);\n    }\n\n    // Tolerance vector\n    __m128d tol_vec = _mm_set1_pd(tolerance);\n\n    // Compare each subsequent block with first block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        size_t start = block * block_size;\n        \n        for (size_t j = 0; j < block_size; j += 2) {\n            __m128d current_block = _mm_loadu_pd(&vec[start + j]);\n            \n            // Compute absolute difference\n            __m128d diff1 = _mm_sub_pd(first_block[j/2], current_block);\n            __m128d abs_diff1 = _mm_andnot_pd(_mm_set1_pd(-0.0), diff1);\n            \n            // Check if difference exceeds tolerance\n            __m128d cmp1 = _mm_cmpgt_pd(abs_diff1, tol_vec);\n            \n            // If any element exceeds tolerance, return false\n            if (_mm_movemask_pd(cmp1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t r = 0; r < rows; r++) {\n        __m128d sum_vec = _mm_setzero_pd();\n        \n        // Process 2 columns at a time using SSE2\n        size_t c = 0;\n        for (; c + 1 < cols; c += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[r * cols + c]);\n            __m128d squared_vec = _mm_mul_pd(row_vec, row_vec);\n            sum_vec = _mm_add_pd(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        __m128d sum_high = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n        sum_vec = _mm_add_pd(sum_vec, sum_high);\n        double sum = _mm_cvtsd_f64(sum_vec);\n        \n        // Handle remaining column if cols is odd\n        if (c < cols) {\n            sum += matrix[r * cols + c] * matrix[r * cols + c];\n        }\n        \n        // Compare norm with threshold\n        result[r] = sqrt(sum) > thresholds[r];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum_vec = _mm_setzero_pd();\n        \n        // Process 2 doubles at a time using SSE2\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            __m128d squared_vec = _mm_mul_pd(row_vec, row_vec);\n            sum_vec = _mm_add_pd(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        __m128d sum_high = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n        sum_vec = _mm_add_pd(sum_vec, sum_high);\n        double sum_scalar = _mm_cvtsd_f64(sum_vec);\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            sum_scalar += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = sqrt(sum_scalar) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum_vec = _mm_setzero_pd();\n        \n        // Process 2 columns at a time using SSE2\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            __m128d squared_vec = _mm_mul_pd(row_vec, row_vec);\n            sum_vec = _mm_add_pd(sum_vec, squared_vec);\n        }\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            double last_val = matrix[i * cols + j];\n            sum_vec = _mm_add_pd(sum_vec, _mm_set_pd(0.0, last_val * last_val));\n        }\n        \n        // Horizontal sum of squared values\n        __m128d sum_high = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n        sum_vec = _mm_add_pd(sum_vec, sum_high);\n        \n        // Square root and compare with threshold\n        double norm = _mm_cvtsd_f64(_mm_sqrt_pd(sum_vec));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum_vec = _mm_setzero_pd();\n        \n        // Process 2 doubles at a time using SSE2\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            __m128d squared_vec = _mm_mul_pd(row_vec, row_vec);\n            sum_vec = _mm_add_pd(sum_vec, squared_vec);\n        }\n        \n        // Handle remaining single element if cols is odd\n        if (j < cols) {\n            double last_val = matrix[i * cols + j];\n            sum_vec = _mm_add_pd(sum_vec, _mm_set_pd(0.0, last_val * last_val));\n        }\n        \n        // Horizontal sum of squared values\n        __m128d sum_high = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n        sum_vec = _mm_add_pd(sum_vec, sum_high);\n        \n        // Square root and compare with threshold\n        double norm = sqrt(_mm_cvtsd_f64(sum_vec));\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum_vec = _mm_setzero_pd();\n        \n        // Process 2 doubles at a time using SSE2\n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            __m128d squared_vec = _mm_mul_pd(row_vec, row_vec);\n            sum_vec = _mm_add_pd(sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        __m128d sum_high = _mm_shuffle_pd(sum_vec, sum_vec, 1);\n        sum_vec = _mm_add_pd(sum_vec, sum_high);\n        double sum = _mm_cvtsd_f64(sum_vec);\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            sum += matrix[i * cols + j] * matrix[i * cols + j];\n        }\n        \n        // Compare norm with threshold\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i vc = _mm_or_si128(va, vb);\n        _mm_storeu_si128((__m128i*)&C[i], vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i vc = _mm_or_si128(va, vb);\n        _mm_storeu_si128((__m128i*)&C[i], vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i vc = _mm_or_si128(va, vb);\n        _mm_storeu_si128((__m128i*)&C[i], vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i vc = _mm_or_si128(va, vb);\n        _mm_storeu_si128((__m128i*)&C[i], vc);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= length; i += 4) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i or_result = _mm_or_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], or_result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i squares_low = _mm_mullo_epi16(_mm_cvtepi8_epi16(va), _mm_cvtepi8_epi16(va));\n        __m128i squares_high = _mm_mullo_epi16(_mm_cvtepi8_epi16(_mm_srli_si128(va, 8)), \n                                               _mm_cvtepi8_epi16(_mm_srli_si128(va, 8)));\n        __m128i products_low = _mm_mullo_epi16(_mm_cvtepi8_epi16(va), _mm_cvtepi8_epi16(vb));\n        __m128i products_high = _mm_mullo_epi16(_mm_cvtepi8_epi16(_mm_srli_si128(va, 8)), \n                                                _mm_cvtepi8_epi16(_mm_srli_si128(vb, 8)));\n        \n        sum_squares = _mm_add_epi64(sum_squares, _mm_unpacklo_epi32(squares_low, squares_high));\n        sum_products = _mm_add_epi64(sum_products, _mm_unpacklo_epi32(products_low, products_high));\n    }\n    \n    int64_t result_squares = _mm_cvtsi128_si64(sum_squares) + _mm_cvtsi128_si64(_mm_srli_si128(sum_squares, 8));\n    int64_t result_products = _mm_cvtsi128_si64(sum_products) + _mm_cvtsi128_si64(_mm_srli_si128(sum_products, 8));\n    \n    for (; i < length; i++) {\n        result_squares += A[i] * A[i];\n        result_products += A[i] * B[i];\n    }\n    \n    return result_squares - result_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i vec_a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vec_b = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compute squares\n        __m128i squares_low = _mm_mullo_epi16(_mm_cvtepi8_epi16(vec_a), _mm_cvtepi8_epi16(vec_a));\n        __m128i squares_high = _mm_mullo_epi16(_mm_cvtepi8_epi16(_mm_srli_si128(vec_a, 8)), \n                                               _mm_cvtepi8_epi16(_mm_srli_si128(vec_a, 8)));\n        \n        // Compute products\n        __m128i products_low = _mm_mullo_epi16(_mm_cvtepi8_epi16(vec_a), _mm_cvtepi8_epi16(vec_b));\n        __m128i products_high = _mm_mullo_epi16(_mm_cvtepi8_epi16(_mm_srli_si128(vec_a, 8)), \n                                                _mm_cvtepi8_epi16(_mm_srli_si128(vec_b, 8)));\n        \n        // Accumulate\n        sum_squares = _mm_add_epi64(sum_squares, _mm_add_epi64(squares_low, squares_high));\n        sum_products = _mm_add_epi64(sum_products, _mm_add_epi64(products_low, products_high));\n    }\n    \n    // Handle remaining elements\n    int64_t sum_squares_scalar = 0;\n    int64_t sum_products_scalar = 0;\n    for (; i < length; i++) {\n        sum_squares_scalar += A[i] * A[i];\n        sum_products_scalar += A[i] * B[i];\n    }\n    \n    // Horizontal sum of SIMD vectors\n    int64_t simd_squares = _mm_cvtsi128_si64(sum_squares) + _mm_cvtsi128_si64(_mm_srli_si128(sum_squares, 8));\n    int64_t simd_products = _mm_cvtsi128_si64(sum_products) + _mm_cvtsi128_si64(_mm_srli_si128(sum_products, 8));\n    \n    return (simd_squares + sum_squares_scalar) - 2 * (simd_products + sum_products_scalar);\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compute squares\n        __m128i va_lo = _mm_unpacklo_epi8(va, _mm_setzero_si128());\n        __m128i va_hi = _mm_unpackhi_epi8(va, _mm_setzero_si128());\n        __m128i squares_lo = _mm_mullo_epi16(va_lo, va_lo);\n        __m128i squares_hi = _mm_mullo_epi16(va_hi, va_hi);\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(squares_lo));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(_mm_srli_si128(squares_lo, 8)));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(squares_hi));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(_mm_srli_si128(squares_hi, 8)));\n        \n        // Compute products\n        __m128i vb_lo = _mm_unpacklo_epi8(vb, _mm_setzero_si128());\n        __m128i vb_hi = _mm_unpackhi_epi8(vb, _mm_setzero_si128());\n        __m128i products_lo = _mm_mullo_epi16(va_lo, vb_lo);\n        __m128i products_hi = _mm_mullo_epi16(va_hi, vb_hi);\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(products_lo));\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(_mm_srli_si128(products_lo, 8)));\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(products_hi));\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(_mm_srli_si128(products_hi, 8)));\n    }\n    \n    int32_t squares[4], products[4];\n    _mm_storeu_si128((__m128i*)squares, sum_squares);\n    _mm_storeu_si128((__m128i*)products, sum_products);\n    \n    int64_t total_squares = squares[0] + squares[1] + squares[2] + squares[3];\n    int64_t total_products = products[0] + products[1] + products[2] + products[3];\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        total_squares += A[i] * A[i];\n        total_products += A[i] * B[i];\n    }\n    \n    return total_squares - 2 * total_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i vb = _mm_loadu_si128((__m128i*)(B + i));\n        \n        __m128i va_lo = _mm_unpacklo_epi8(va, _mm_setzero_si128());\n        __m128i va_hi = _mm_unpackhi_epi8(va, _mm_setzero_si128());\n        __m128i vb_lo = _mm_unpacklo_epi8(vb, _mm_setzero_si128());\n        __m128i vb_hi = _mm_unpackhi_epi8(vb, _mm_setzero_si128());\n        \n        __m128i squares_lo = _mm_mullo_epi16(va_lo, va_lo);\n        __m128i squares_hi = _mm_mullo_epi16(va_hi, va_hi);\n        __m128i products_lo = _mm_mullo_epi16(va_lo, vb_lo);\n        __m128i products_hi = _mm_mullo_epi16(va_hi, vb_hi);\n        \n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpacklo_epi16(squares_lo, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpackhi_epi16(squares_lo, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpacklo_epi16(squares_hi, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpackhi_epi16(squares_hi, _mm_setzero_si128()));\n        \n        sum_products = _mm_add_epi32(sum_products, _mm_unpacklo_epi16(products_lo, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpackhi_epi16(products_lo, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpacklo_epi16(products_hi, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpackhi_epi16(products_hi, _mm_setzero_si128()));\n    }\n    \n    int32_t squares_arr[4], products_arr[4];\n    _mm_storeu_si128((__m128i*)squares_arr, sum_squares);\n    _mm_storeu_si128((__m128i*)products_arr, sum_products);\n    \n    int64_t total_squares = squares_arr[0] + squares_arr[1] + squares_arr[2] + squares_arr[3];\n    int64_t total_products = products_arr[0] + products_arr[1] + products_arr[2] + products_arr[3];\n    \n    for (; i < length; i++) {\n        total_squares += A[i] * A[i];\n        total_products += A[i] * B[i];\n    }\n    \n    return total_squares - 2 * total_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Compute squares\n        __m128i va_lo = _mm_unpacklo_epi8(va, _mm_setzero_si128());\n        __m128i va_hi = _mm_unpackhi_epi8(va, _mm_setzero_si128());\n        __m128i squares_lo = _mm_mullo_epi16(va_lo, va_lo);\n        __m128i squares_hi = _mm_mullo_epi16(va_hi, va_hi);\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(squares_lo));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(_mm_srli_si128(squares_lo, 8)));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(squares_hi));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_cvtepi16_epi32(_mm_srli_si128(squares_hi, 8)));\n        \n        // Compute products\n        __m128i vb_lo = _mm_unpacklo_epi8(vb, _mm_setzero_si128());\n        __m128i vb_hi = _mm_unpackhi_epi8(vb, _mm_setzero_si128());\n        __m128i products_lo = _mm_mullo_epi16(va_lo, vb_lo);\n        __m128i products_hi = _mm_mullo_epi16(va_hi, vb_hi);\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(products_lo));\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(_mm_srli_si128(products_lo, 8)));\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(products_hi));\n        sum_products = _mm_add_epi32(sum_products, _mm_cvtepi16_epi32(_mm_srli_si128(products_hi, 8)));\n    }\n    \n    // Horizontal sum\n    __m128i sum_squares_high = _mm_srli_si128(sum_squares, 8);\n    sum_squares = _mm_add_epi32(sum_squares, sum_squares_high);\n    sum_squares_high = _mm_srli_si128(sum_squares, 4);\n    sum_squares = _mm_add_epi32(sum_squares, sum_squares_high);\n    \n    __m128i sum_products_high = _mm_srli_si128(sum_products, 8);\n    sum_products = _mm_add_epi32(sum_products, sum_products_high);\n    sum_products_high = _mm_srli_si128(sum_products, 4);\n    sum_products = _mm_add_epi32(sum_products, sum_products_high);\n    \n    int32_t squares_result = _mm_cvtsi128_si32(sum_squares);\n    int32_t products_result = _mm_cvtsi128_si32(sum_products);\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        squares_result += A[i] * A[i];\n        products_result += A[i] * B[i];\n    }\n    \n    return (int64_t)squares_result - 2 * products_result;\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 uint64_t elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Bitwise NOT of B\n        __m128i not_b_vec = _mm_xor_si128(b_vec, _mm_set1_epi64x(-1));\n        \n        // Bitwise AND between A and NOT(B)\n        __m128i result_vec = _mm_and_si128(a_vec, not_b_vec);\n        \n        // Store result back to C\n        _mm_storeu_si128((__m128i*)&C[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 uint64_t elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 uint64_t values from A and B\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Bitwise NOT of B\n        __m128i not_b_vec = _mm_xor_si128(b_vec, _mm_set1_epi64x(-1));\n        \n        // Bitwise AND between A and NOT(B)\n        __m128i result_vec = _mm_and_si128(a_vec, not_b_vec);\n        \n        // Store result in C\n        _mm_storeu_si128((__m128i*)&C[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 uint64_t elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Bitwise NOT of B\n        __m128i not_b_vec = _mm_xor_si128(b_vec, _mm_set1_epi64x(-1));\n        \n        // Bitwise AND between A and NOT(B)\n        __m128i result_vec = _mm_and_si128(a_vec, not_b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 uint64_t elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        // Load 2 uint64_t values from A and B\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Bitwise NOT of B\n        b_vec = _mm_xor_si128(b_vec, _mm_set1_epi64x(-1));\n        \n        // Bitwise AND between A and NOT(B)\n        __m128i result = _mm_and_si128(a_vec, b_vec);\n        \n        // Store result in C\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    \n    // Process 2 uint64_t elements at a time using SSE2 intrinsics\n    for (; i + 1 < length; i += 2) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Bitwise NOT of B\n        __m128i not_b_vec = _mm_xor_si128(b_vec, _mm_set1_epi64x(-1));\n        \n        // Bitwise AND between A and NOT(B)\n        __m128i result_vec = _mm_and_si128(a_vec, not_b_vec);\n        \n        // Store result back to C\n        _mm_storeu_si128((__m128i*)&C[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Check if both are positive\n        __m128i pos_mask_a = _mm_cmpgt_epi8(a_vec, _mm_setzero_si128());\n        __m128i pos_mask_b = _mm_cmpgt_epi8(b_vec, _mm_setzero_si128());\n        __m128i pos_result = _mm_and_si128(pos_mask_a, pos_mask_b);\n        pos_result = _mm_and_si128(pos_result, _mm_set1_epi8(1));\n        \n        // Check if both are negative\n        __m128i neg_mask_a = _mm_cmplt_epi8(a_vec, _mm_setzero_si128());\n        __m128i neg_mask_b = _mm_cmplt_epi8(b_vec, _mm_setzero_si128());\n        __m128i neg_result = _mm_and_si128(neg_mask_a, neg_mask_b);\n        neg_result = _mm_and_si128(neg_result, _mm_set1_epi8(-1));\n        \n        // Combine results\n        __m128i result = _mm_or_si128(pos_result, neg_result);\n        \n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        // Load 16 bytes from A and B\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Create masks for positive and negative values\n        __m128i zero_vec = _mm_setzero_si128();\n        __m128i pos_mask_a = _mm_cmpgt_epi8(a_vec, zero_vec);\n        __m128i pos_mask_b = _mm_cmpgt_epi8(b_vec, zero_vec);\n        __m128i neg_mask_a = _mm_cmplt_epi8(a_vec, zero_vec);\n        __m128i neg_mask_b = _mm_cmplt_epi8(b_vec, zero_vec);\n        \n        // Compute both positive and both negative conditions\n        __m128i both_pos = _mm_and_si128(pos_mask_a, pos_mask_b);\n        __m128i both_neg = _mm_and_si128(neg_mask_a, neg_mask_b);\n        \n        // Create result vector\n        __m128i result = _mm_setzero_si128();\n        result = _mm_or_si128(result, _mm_and_si128(both_pos, _mm_set1_epi8(1)));\n        result = _mm_or_si128(result, _mm_and_si128(both_neg, _mm_set1_epi8(-1)));\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Check if both are positive\n        __m128i positive_mask = _mm_cmpgt_epi8(a_vec, _mm_setzero_si128());\n        __m128i b_positive_mask = _mm_cmpgt_epi8(b_vec, _mm_setzero_si128());\n        __m128i both_positive = _mm_and_si128(positive_mask, b_positive_mask);\n        \n        // Check if both are negative\n        __m128i negative_mask = _mm_cmplt_epi8(a_vec, _mm_setzero_si128());\n        __m128i b_negative_mask = _mm_cmplt_epi8(b_vec, _mm_setzero_si128());\n        __m128i both_negative = _mm_and_si128(negative_mask, b_negative_mask);\n        \n        // Create result vector\n        __m128i result = _mm_setzero_si128();\n        result = _mm_or_si128(result, _mm_and_si128(both_positive, _mm_set1_epi8(1)));\n        result = _mm_or_si128(result, _mm_and_si128(both_negative, _mm_set1_epi8(-1)));\n        \n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Check if both A and B are positive\n        __m128i positive_mask = _mm_cmpgt_epi8(a_vec, _mm_setzero_si128());\n        __m128i b_positive_mask = _mm_cmpgt_epi8(b_vec, _mm_setzero_si128());\n        __m128i both_positive = _mm_and_si128(positive_mask, b_positive_mask);\n        \n        // Check if both A and B are negative\n        __m128i negative_mask = _mm_cmplt_epi8(a_vec, _mm_setzero_si128());\n        __m128i b_negative_mask = _mm_cmplt_epi8(b_vec, _mm_setzero_si128());\n        __m128i both_negative = _mm_and_si128(negative_mask, b_negative_mask);\n        \n        // Create result vector\n        __m128i result = _mm_setzero_si128();\n        result = _mm_or_si128(result, _mm_and_si128(both_positive, _mm_set1_epi8(1)));\n        result = _mm_or_si128(result, _mm_and_si128(both_negative, _mm_set1_epi8(-1)));\n        \n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // Check if both A and B are positive\n        __m128i pos_mask = _mm_cmpgt_epi8(a_vec, _mm_setzero_si128());\n        __m128i b_pos_mask = _mm_cmpgt_epi8(b_vec, _mm_setzero_si128());\n        __m128i both_pos = _mm_and_si128(pos_mask, b_pos_mask);\n        \n        // Check if both A and B are negative\n        __m128i neg_mask = _mm_cmplt_epi8(a_vec, _mm_setzero_si128());\n        __m128i b_neg_mask = _mm_cmplt_epi8(b_vec, _mm_setzero_si128());\n        __m128i both_neg = _mm_and_si128(neg_mask, b_neg_mask);\n        \n        // Create result vector\n        __m128i result = _mm_setzero_si128();\n        result = _mm_or_si128(result, _mm_and_si128(both_pos, _mm_set1_epi8(1)));\n        result = _mm_or_si128(result, _mm_and_si128(both_neg, _mm_set1_epi8(-1)));\n        \n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0)\n            C[i] = 1;\n        else if (A[i] < 0 && B[i] < 0)\n            C[i] = -1;\n        else\n            C[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t simd_length = midpoint - (midpoint % 8);\n    \n    // Process first half with XOR and AND using SSE2\n    for (size_t i = 0; i < simd_length; i += 8) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i xor_result = _mm_xor_si128(a_vec, b_vec);\n        __m128i and_result = _mm_and_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], xor_result);\n        _mm_storeu_si128((__m128i*)&C[simd_length], and_result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (size_t i = simd_length; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n        C[length - 1 - i] = A[i] & B[i];\n    }\n    \n    // Set midpoint element to original A value\n    C[midpoint] = A[midpoint];\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t simd_length = midpoint - (midpoint % 8);\n    \n    // Process first half with SIMD XOR and AND\n    for (size_t i = 0; i < simd_length; i += 8) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i xor_result = _mm_xor_si128(a_vec, b_vec);\n        __m128i and_result = _mm_and_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], xor_result);\n        _mm_storeu_si128((__m128i*)&C[i + 4], and_result);\n    }\n    \n    // Handle remaining elements before midpoint with scalar operations\n    for (size_t i = simd_length; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Handle remaining elements after midpoint with scalar operations\n    for (size_t i = midpoint + 1; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t simd_length = midpoint - (midpoint % 8);\n    \n    // Process first half with SIMD XOR and AND\n    for (size_t i = 0; i < simd_length; i += 8) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i xor_result = _mm_xor_si128(a_vec, b_vec);\n        __m128i and_result = _mm_and_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], xor_result);\n        _mm_storeu_si128((__m128i*)&C[simd_length + i], and_result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (size_t i = simd_length; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n        C[simd_length + i] = A[i] & B[i];\n    }\n    \n    // Set midpoint element to A's value\n    C[midpoint] = A[midpoint];\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t simd_length = midpoint - (midpoint % 8);\n    \n    // Process first half with SIMD\n    for (size_t i = 0; i < simd_length; i += 8) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // XOR for first half before midpoint\n        __m128i xor_result = _mm_xor_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], xor_result);\n    }\n    \n    // Process second half with SIMD\n    for (size_t i = midpoint; i < length - (length % 8); i += 8) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        // AND for second half after midpoint\n        __m128i and_result = _mm_and_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], and_result);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Handle remaining elements not processed by SIMD\n    for (size_t i = simd_length; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    for (size_t i = midpoint + 1; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t simd_length = midpoint - (midpoint % 8);\n    \n    // Process first half with SIMD XOR and AND\n    for (size_t i = 0; i < simd_length; i += 8) {\n        __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b_vec = _mm_loadu_si128((__m128i*)&B[i]);\n        \n        __m128i xor_result = _mm_xor_si128(a_vec, b_vec);\n        __m128i and_result = _mm_and_si128(a_vec, b_vec);\n        \n        _mm_storeu_si128((__m128i*)&C[i], xor_result);\n        _mm_storeu_si128((__m128i*)&C[i + 4], and_result);\n    }\n    \n    // Handle remaining elements before midpoint with scalar operations\n    for (size_t i = simd_length; i < midpoint; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Handle remaining elements after midpoint with scalar operations\n    for (size_t i = midpoint + 1; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        // Load condition vectors\n        __m128 cond1_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond1));\n        __m128 cond2_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond2));\n\n        // Load input vectors\n        __m128 a_vec = _mm_loadu_ps(A);\n        __m128 b_vec = _mm_loadu_ps(B);\n        __m128 c_vec = _mm_loadu_ps(C);\n        __m128 d_vec = _mm_loadu_ps(D);\n\n        // Create masks for conditions\n        __m128 cond1_mask = _mm_cmpgt_ps(cond1_vec, _mm_setzero_ps());\n        __m128 cond2_mask = _mm_cmpgt_ps(cond2_vec, _mm_setzero_ps());\n\n        // Combine conditions\n        __m128 both_true_mask = _mm_and_ps(cond1_mask, cond2_mask);\n        __m128 cond1_true_cond2_false_mask = _mm_andnot_ps(cond2_mask, cond1_mask);\n        __m128 cond1_false_cond2_true_mask = _mm_andnot_ps(cond1_mask, cond2_mask);\n        __m128 both_false_mask = _mm_andnot_ps(cond1_mask, _mm_andnot_ps(cond2_mask, _mm_cmpeq_ps(_mm_setzero_ps(), _mm_setzero_ps())));\n\n        // Select values based on conditions\n        __m128 result_vec = _mm_add_ps(\n            _mm_add_ps(\n                _mm_and_ps(both_true_mask, a_vec),\n                _mm_and_ps(cond1_true_cond2_false_mask, b_vec)\n            ),\n            _mm_add_ps(\n                _mm_and_ps(cond1_false_cond2_true_mask, c_vec),\n                _mm_and_ps(both_false_mask, d_vec)\n            )\n        );\n\n        // Store result\n        _mm_storeu_ps(out, result_vec);\n\n        // Move pointers\n        A += vector_size;\n        B += vector_size;\n        C += vector_size;\n        D += vector_size;\n        cond1 += vector_size;\n        cond2 += vector_size;\n        out += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        if (*cond1 && *cond2) {\n            *out = *A;\n        } else if (*cond1 && !*cond2) {\n            *out = *B;\n        } else if (!*cond1 && *cond2) {\n            *out = *C;\n        } else {\n            *out = *D;\n        }\n\n        ++A;\n        ++B;\n        ++C;\n        ++D;\n        ++cond1;\n        ++cond2;\n        ++out;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        // Load condition vectors\n        __m128 cond1_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond1));\n        __m128 cond2_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond2));\n\n        // Load input vectors\n        __m128 a_vec = _mm_loadu_ps(A);\n        __m128 b_vec = _mm_loadu_ps(B);\n        __m128 c_vec = _mm_loadu_ps(C);\n        __m128 d_vec = _mm_loadu_ps(D);\n\n        // Create masks for conditions\n        __m128 cond1_mask = _mm_cmpgt_ps(cond1_vec, _mm_setzero_ps());\n        __m128 cond2_mask = _mm_cmpgt_ps(cond2_vec, _mm_setzero_ps());\n\n        // Combine conditions\n        __m128 both_true_mask = _mm_and_ps(cond1_mask, cond2_mask);\n        __m128 cond1_true_cond2_false_mask = _mm_andnot_ps(cond2_mask, cond1_mask);\n        __m128 cond1_false_cond2_true_mask = _mm_andnot_ps(cond1_mask, cond2_mask);\n        __m128 both_false_mask = _mm_andnot_ps(cond1_mask, _mm_andnot_ps(cond2_mask, _mm_cmpeq_ps(_mm_setzero_ps(), _mm_setzero_ps())));\n\n        // Select values based on conditions\n        __m128 result_vec = _mm_add_ps(\n            _mm_add_ps(\n                _mm_and_ps(both_true_mask, a_vec),\n                _mm_and_ps(cond1_true_cond2_false_mask, b_vec)\n            ),\n            _mm_add_ps(\n                _mm_and_ps(cond1_false_cond2_true_mask, c_vec),\n                _mm_and_ps(both_false_mask, d_vec)\n            )\n        );\n\n        // Store result\n        _mm_storeu_ps(out, result_vec);\n\n        // Move pointers forward\n        A += vector_size;\n        B += vector_size;\n        C += vector_size;\n        D += vector_size;\n        cond1 += vector_size;\n        cond2 += vector_size;\n        out += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        if (*cond1 && *cond2) {\n            *out = *A;\n        } else if (*cond1 && !*cond2) {\n            *out = *B;\n        } else if (!*cond1 && *cond2) {\n            *out = *C;\n        } else {\n            *out = *D;\n        }\n\n        ++A;\n        ++B;\n        ++C;\n        ++D;\n        ++cond1;\n        ++cond2;\n        ++out;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        // Load condition vectors\n        __m128 cond1_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond1));\n        __m128 cond2_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond2));\n\n        // Load input vectors\n        __m128 a_vec = _mm_loadu_ps(A);\n        __m128 b_vec = _mm_loadu_ps(B);\n        __m128 c_vec = _mm_loadu_ps(C);\n        __m128 d_vec = _mm_loadu_ps(D);\n\n        // Create masks for conditions\n        __m128 cond1_mask = _mm_cmpneq_ps(cond1_vec, _mm_setzero_ps());\n        __m128 cond2_mask = _mm_cmpneq_ps(cond2_vec, _mm_setzero_ps());\n\n        // Combine conditions\n        __m128 cond_and_mask = _mm_and_ps(cond1_mask, cond2_mask);\n        __m128 cond_or_mask = _mm_or_ps(cond1_mask, cond2_mask);\n\n        // Select values based on conditions\n        __m128 result1 = _mm_and_ps(cond_and_mask, a_vec);\n        __m128 result2 = _mm_andnot_ps(cond2_mask, _mm_and_ps(cond1_mask, b_vec));\n        __m128 result3 = _mm_andnot_ps(cond1_mask, _mm_and_ps(cond2_mask, c_vec));\n        __m128 result4 = _mm_andnot_ps(cond_or_mask, d_vec);\n\n        // Combine results\n        __m128 final_result = _mm_or_ps(_mm_or_ps(result1, result2), _mm_or_ps(result3, result4));\n\n        // Store result\n        _mm_storeu_ps(out, final_result);\n\n        // Advance pointers\n        A += vector_size;\n        B += vector_size;\n        C += vector_size;\n        D += vector_size;\n        cond1 += vector_size;\n        cond2 += vector_size;\n        out += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        out[i] = (cond1[i] && cond2[i]) ? A[i] :\n                 (cond1[i] && !cond2[i]) ? B[i] :\n                 (!cond1[i] && cond2[i]) ? C[i] : D[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // SSE processes 4 floats at a time\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        // Load condition vectors\n        __m128 cond1_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond1));\n        __m128 cond2_vec = _mm_loadu_ps(reinterpret_cast<const float*>(cond2));\n\n        // Load input vectors\n        __m128 a_vec = _mm_loadu_ps(A);\n        __m128 b_vec = _mm_loadu_ps(B);\n        __m128 c_vec = _mm_loadu_ps(C);\n        __m128 d_vec = _mm_loadu_ps(D);\n\n        // Create masks for conditions\n        __m128 cond1_true = _mm_cmpneq_ps(cond1_vec, _mm_setzero_ps());\n        __m128 cond2_true = _mm_cmpneq_ps(cond2_vec, _mm_setzero_ps());\n\n        // Combine conditions\n        __m128 both_true = _mm_and_ps(cond1_true, cond2_true);\n        __m128 cond1_true_cond2_false = _mm_andnot_ps(cond2_true, cond1_true);\n        __m128 cond1_false_cond2_true = _mm_andnot_ps(cond1_true, cond2_true);\n        __m128 both_false = _mm_andnot_ps(cond1_true, _mm_andnot_ps(cond2_true, _mm_set1_ps(1.0f)));\n\n        // Select values based on conditions\n        __m128 result = _mm_add_ps(\n            _mm_add_ps(\n                _mm_and_ps(both_true, a_vec),\n                _mm_and_ps(cond1_true_cond2_false, b_vec)\n            ),\n            _mm_add_ps(\n                _mm_and_ps(cond1_false_cond2_true, c_vec),\n                _mm_and_ps(both_false, d_vec)\n            )\n        );\n\n        // Store result\n        _mm_storeu_ps(out, result);\n\n        // Move pointers forward\n        A += vector_size;\n        B += vector_size;\n        C += vector_size;\n        D += vector_size;\n        cond1 += vector_size;\n        cond2 += vector_size;\n        out += vector_size;\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < remaining_elements; ++i) {\n        if (*cond1 && *cond2) {\n            *out = *A;\n        } else if (*cond1 && !*cond2) {\n            *out = *B;\n        } else if (!*cond1 && *cond2) {\n            *out = *C;\n        } else {\n            *out = *D;\n        }\n\n        ++A;\n        ++B;\n        ++C;\n        ++D;\n        ++cond1;\n        ++cond2;\n        ++out;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t simd_width = 4; // SSE processes 4 floats at a time\n    size_t vectorized_length = total_elements - (total_elements % simd_width);\n\n    for (size_t i = 0; i < vectorized_length; i += simd_width) {\n        // Load condition masks\n        __m128 mask1 = _mm_castsi128_ps(_mm_set_epi32(\n            cond1[i+3] ? 0xFFFFFFFF : 0,\n            cond1[i+2] ? 0xFFFFFFFF : 0,\n            cond1[i+1] ? 0xFFFFFFFF : 0,\n            cond1[i+0] ? 0xFFFFFFFF : 0\n        ));\n\n        __m128 mask2 = _mm_castsi128_ps(_mm_set_epi32(\n            cond2[i+3] ? 0xFFFFFFFF : 0,\n            cond2[i+2] ? 0xFFFFFFFF : 0,\n            cond2[i+1] ? 0xFFFFFFFF : 0,\n            cond2[i+0] ? 0xFFFFFFFF : 0\n        ));\n\n        // Load input tensors\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        __m128 c_vec = _mm_loadu_ps(&C[i]);\n        __m128 d_vec = _mm_loadu_ps(&D[i]);\n\n        // Combine masks\n        __m128 combined_mask1 = _mm_and_ps(mask1, mask2);\n        __m128 combined_mask2 = _mm_andnot_ps(mask1, mask2);\n        __m128 combined_mask3 = _mm_andnot_ps(mask2, mask1);\n        __m128 combined_mask4 = _mm_andnot_ps(_mm_or_ps(mask1, mask2), _mm_set1_ps(1.0f));\n\n        // Select values based on combined masks\n        __m128 result = _mm_add_ps(\n            _mm_add_ps(\n                _mm_and_ps(combined_mask1, a_vec),\n                _mm_and_ps(combined_mask2, b_vec)\n            ),\n            _mm_add_ps(\n                _mm_and_ps(combined_mask3, c_vec),\n                _mm_and_ps(combined_mask4, d_vec)\n            )\n        );\n\n        // Store result\n        _mm_storeu_ps(&out[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 32-bit integers per SSE register\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < vector_count; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&A[i * vector_size]);\n        \n        // Popcount for each 32-bit integer\n        __m128i popcount_mask = _mm_set1_epi32(0x55555555);\n        __m128i low_bits = _mm_and_si128(vec, popcount_mask);\n        __m128i high_bits = _mm_and_si128(_mm_srli_epi32(vec, 1), popcount_mask);\n        \n        vec = _mm_add_epi32(low_bits, high_bits);\n        popcount_mask = _mm_set1_epi32(0x33333333);\n        low_bits = _mm_and_si128(vec, popcount_mask);\n        high_bits = _mm_and_si128(_mm_srli_epi32(vec, 2), popcount_mask);\n        \n        vec = _mm_add_epi32(low_bits, high_bits);\n        popcount_mask = _mm_set1_epi32(0x0F0F0F0F);\n        low_bits = _mm_and_si128(vec, popcount_mask);\n        high_bits = _mm_and_si128(_mm_srli_epi32(vec, 4), popcount_mask);\n        \n        vec = _mm_add_epi32(low_bits, high_bits);\n        vec = _mm_add_epi32(vec, _mm_srli_epi32(vec, 8));\n        vec = _mm_add_epi32(vec, _mm_srli_epi32(vec, 16));\n        \n        // Store results\n        int results[4];\n        _mm_storeu_si128((__m128i*)results, vec);\n        \n        for (size_t j = 0; j < vector_size; ++j) {\n            out[i * vector_size + j] = results[j] & 0xFF;\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        out[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 32-bit integers per SSE register\n    size_t vector_count = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < vector_count; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&A[i * vector_size]);\n        \n        // Popcount for each 32-bit integer\n        __m128i mask1 = _mm_set1_epi32(0x55555555);\n        __m128i mask2 = _mm_set1_epi32(0x33333333);\n        __m128i mask3 = _mm_set1_epi32(0x0F0F0F0F);\n        \n        vec = _mm_sub_epi32(vec, _mm_srli_epi32(vec, 1) & mask1);\n        vec = _mm_add_epi32(_mm_and_si128(vec, mask2), _mm_and_si128(_mm_srli_epi32(vec, 2), mask2));\n        vec = _mm_and_si128(_mm_add_epi32(vec, _mm_srli_epi32(vec, 4)), mask3);\n        vec = _mm_add_epi32(vec, _mm_srli_epi32(vec, 8));\n        vec = _mm_add_epi32(vec, _mm_srli_epi32(vec, 16));\n        vec = _mm_and_si128(vec, _mm_set1_epi32(0x3F));\n\n        // Store results\n        _mm_storeu_si128((__m128i*)&out[i * vector_size], _mm_cvtepi32_epi8(vec));\n    }\n\n    // Handle remaining elements\n    for (size_t i = vector_count * vector_size; i < total_elements; ++i) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        out[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 32-bit integers per SSE register\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&A[i * vector_size]);\n        \n        // Bit count using SSE2 popcount\n        __m128i mask1 = _mm_srli_epi32(vec, 1);\n        __m128i mask2 = _mm_srli_epi32(vec, 2);\n        __m128i mask3 = _mm_srli_epi32(vec, 3);\n        \n        vec = _mm_sub_epi32(vec, _mm_and_si128(mask1, _mm_set1_epi32(0x55555555)));\n        vec = _mm_add_epi32(_mm_and_si128(vec, _mm_set1_epi32(0x33333333)), \n                             _mm_and_si128(mask1, _mm_set1_epi32(0x33333333)));\n        \n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 4), vec);\n        vec = _mm_and_si128(vec, _mm_set1_epi32(0x0F0F0F0F));\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 8), vec);\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 16), vec);\n        vec = _mm_and_si128(vec, _mm_set1_epi32(0x3F));\n\n        // Store results\n        _mm_storeu_si128((__m128i*)&out[i * vector_size], _mm_cvtepi32_epi8(vec));\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * vector_size; i < total_elements; ++i) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        out[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 32-bit integers per SSE register\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // SIMD processing\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&A[i * vector_size]);\n        \n        // Bit counting using SSE2 popcount method\n        __m128i m1 = _mm_set1_epi32(0x55555555);\n        __m128i m2 = _mm_set1_epi32(0x33333333);\n        __m128i m4 = _mm_set1_epi32(0x0F0F0F0F);\n        \n        vec = _mm_sub_epi32(vec, (_mm_srli_epi32(vec, 1) & m1));\n        vec = _mm_add_epi32((_mm_srli_epi32(vec, 2) & m2), (vec & m2));\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 4), vec) & m4;\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 8), vec);\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 16), vec) & _mm_set1_epi32(0x3F);\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&out[i * vector_size], _mm_cvtepi32_epi8(vec));\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * vector_size; i < total_elements; ++i) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        out[i] = (x + (x >> 16)) & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vector_size = 4; // 4 32-bit integers per SSE register\n    size_t simd_iterations = total_elements / vector_size;\n    size_t remaining_elements = total_elements % vector_size;\n\n    // SIMD processing\n    for (size_t i = 0; i < simd_iterations; ++i) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&A[i * vector_size]);\n        \n        // Bit counting using SSE2 popcount\n        __m128i mask_1 = _mm_set1_epi32(0x55555555);\n        __m128i mask_2 = _mm_set1_epi32(0x33333333);\n        __m128i mask_4 = _mm_set1_epi32(0x0F0F0F0F);\n        \n        vec = _mm_sub_epi32(vec, (_mm_srli_epi32(vec, 1) & mask_1));\n        vec = _mm_add_epi32((_mm_srli_epi32(vec, 2) & mask_2), (vec & mask_2));\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 4), (vec & mask_4));\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 8), vec);\n        vec = _mm_add_epi32(_mm_srli_epi32(vec, 16), vec);\n        \n        // Store results\n        out[i * vector_size] = _mm_cvtsi128_si32(vec) & 0xFF;\n        out[i * vector_size + 1] = (_mm_cvtsi128_si32(vec) >> 8) & 0xFF;\n        out[i * vector_size + 2] = (_mm_cvtsi128_si32(vec) >> 16) & 0xFF;\n        out[i * vector_size + 3] = (_mm_cvtsi128_si32(vec) >> 24) & 0xFF;\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_iterations * vector_size; i < total_elements; ++i) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        out[i] = (x + (x >> 16)) & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using SSE\n        for (; j + 4 <= cols; j += 4) {\n            __m128i vec_a = _mm_loadu_si128((__m128i*)&A[i * cols + j]);\n            \n            // Create mask for elements divisible by 3\n            __m128i zero = _mm_setzero_si128();\n            __m128i three = _mm_set1_epi32(3);\n            __m128i mod_mask = _mm_cmpeq_epi32(_mm_mod_epi32(vec_a, three), zero);\n            \n            // Take absolute value of elements divisible by 3\n            __m128i abs_vec_a = _mm_abs_epi32(vec_a);\n            \n            // Blend original and absolute values based on divisibility mask\n            __m128i result = _mm_blendv_epi8(vec_a, abs_vec_a, mod_mask);\n            \n            _mm_storeu_si128((__m128i*)&B[i * cols + j], result);\n        }\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using SSE\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 integers from matrix A\n            __m128i a_vec = _mm_loadu_si128((__m128i*)&A[i * cols + j]);\n            \n            // Create vector of 3 for divisibility check\n            __m128i three_vec = _mm_set1_epi32(3);\n            \n            // Compute remainder when divided by 3\n            __m128i remainder = _mm_rem_epi32(a_vec, three_vec);\n            \n            // Compare remainder to zero\n            __m128i zero_vec = _mm_setzero_si128();\n            __m128i mask = _mm_cmpeq_epi32(remainder, zero_vec);\n            \n            // Compute absolute value\n            __m128i abs_vec = _mm_abs_epi32(a_vec);\n            \n            // Blend original or absolute values based on divisibility\n            __m128i result = _mm_blendv_epi8(a_vec, abs_vec, mask);\n            \n            // Store result in destination matrix\n            _mm_storeu_si128((__m128i*)&B[i * cols + j], result);\n        }\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using SSE\n        for (; j + 4 <= cols; j += 4) {\n            __m128i vec_a = _mm_loadu_si128((__m128i*)&A[i * cols + j]);\n            \n            // Create a vector of 3 for divisibility check\n            __m128i vec_3 = _mm_set1_epi32(3);\n            \n            // Check divisibility by 3\n            __m128i div_check = _mm_cmpeq_epi32(_mm_mod_epi32(vec_a, vec_3), _mm_setzero_si128());\n            \n            // Take absolute value where divisible by 3\n            __m128i abs_vec = _mm_abs_epi32(vec_a);\n            \n            // Blend original or absolute values based on divisibility\n            __m128i result = _mm_blendv_epi8(vec_a, abs_vec, div_check);\n            \n            // Store result\n            _mm_storeu_si128((__m128i*)&B[i * cols + j], result);\n        }\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        \n        // Process 4 elements at a time using SSE\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 integers from matrix A\n            __m128i vec_a = _mm_loadu_si128((__m128i*)&A[i * cols + j]);\n            \n            // Create vector of 3 for divisibility check\n            __m128i vec_3 = _mm_set1_epi32(3);\n            \n            // Compute modulo 3 for each element\n            __m128i vec_mod = _mm_mod_epi32(vec_a, vec_3);\n            \n            // Compare if each element is divisible by 3 (zero remainder)\n            __m128i vec_zero = _mm_setzero_si128();\n            __m128i vec_mask = _mm_cmpeq_epi32(vec_mod, vec_zero);\n            \n            // Take absolute value where divisible by 3\n            __m128i vec_abs = _mm_abs_epi32(vec_a);\n            \n            // Blend original values and absolute values based on mask\n            __m128i vec_result = _mm_blendv_epi8(vec_a, vec_abs, vec_mask);\n            \n            // Store result back to destination matrix\n            _mm_storeu_si128((__m128i*)&B[i * cols + j], vec_result);\n        }\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        // Process 4 elements at a time using SSE\n        for (; j + 4 <= cols; j += 4) {\n            // Load 4 integers from matrix A\n            __m128i vec_a = _mm_loadu_si128((__m128i*)&A[i * cols + j]);\n            \n            // Create vector of 3 for divisibility check\n            __m128i vec_3 = _mm_set1_epi32(3);\n            \n            // Compute modulo 3 for each element\n            __m128i vec_mod = _mm_mod_epi32(vec_a, vec_3);\n            \n            // Compare if each element is divisible by 3 (zero remainder)\n            __m128i vec_zero = _mm_setzero_si128();\n            __m128i vec_mask = _mm_cmpeq_epi32(vec_mod, vec_zero);\n            \n            // Compute absolute value for elements divisible by 3\n            __m128i vec_abs = _mm_abs_epi32(vec_a);\n            \n            // Blend original values and absolute values based on divisibility mask\n            __m128i vec_result = _mm_blendv_epi8(vec_a, vec_abs, vec_mask);\n            \n            // Store result back to destination matrix\n            _mm_storeu_si128((__m128i*)&B[i * cols + j], vec_result);\n        }\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            int val = A[i * cols + j];\n            B[i * cols + j] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Check condition: low 4 bits are all 1\n        __m128i mask_low_4bits = _mm_set1_epi32(0x0000000F);\n        __m128i low_4bits = _mm_and_si128(vec_src, mask_low_4bits);\n        __m128i condition_mask = _mm_cmpeq_epi32(low_4bits, mask_low_4bits);\n        \n        // Rotate elements that meet condition\n        __m128i rotated_vec = _mm_or_si128(\n            _mm_sll_epi32(vec_src, _mm_cvtsi32_si128(rotate_bits)),\n            _mm_srl_epi32(vec_src, _mm_cvtsi32_si128(32 - rotate_bits))\n        );\n        \n        // Bitwise negate elements that don't meet condition\n        __m128i negated_vec = _mm_xor_si128(vec_src, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Blend results based on condition\n        __m128i result = _mm_blendv_epi8(negated_vec, rotated_vec, condition_mask);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0x0000000F) == 0x0000000F) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Check if low 4 bits are all 1\n        __m128i low_mask = _mm_set1_epi32(0xF);\n        __m128i low_bits = _mm_and_si128(src_vec, low_mask);\n        __m128i all_ones_mask = _mm_cmpeq_epi32(low_bits, low_mask);\n        \n        // Rotate elements\n        __m128i rotated_vec = _mm_or_si128(\n            _mm_sll_epi32(src_vec, _mm_cvtsi32_si128(rotate_bits)),\n            _mm_srl_epi32(src_vec, _mm_cvtsi32_si128(32 - rotate_bits))\n        );\n        \n        // Bitwise negate elements\n        __m128i negated_vec = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Blend rotated and negated vectors based on condition\n        __m128i result_vec = _mm_blendv_epi8(negated_vec, rotated_vec, all_ones_mask);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Check if low 4 bits are all 1\n        __m128i mask = _mm_set1_epi32(0x0000000F);\n        __m128i low_bits = _mm_and_si128(src_vec, mask);\n        __m128i all_ones = _mm_cmpeq_epi32(low_bits, mask);\n        \n        // Rotate elements\n        __m128i rotated = _mm_or_si128(\n            _mm_sll_epi32(src_vec, _mm_cvtsi32_si128(rotate_bits)),\n            _mm_srl_epi32(src_vec, _mm_cvtsi32_si128(32 - rotate_bits))\n        );\n        \n        // Bitwise negate elements not meeting condition\n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Blend results based on condition\n        __m128i result = _mm_blendv_epi8(negated, rotated, all_ones);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0x0000000F) == 0x0000000F) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128i vec_src = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Check low 4 bits condition\n        __m128i mask_low_4_bits = _mm_set1_epi32(0x0000000F);\n        __m128i low_4_bits = _mm_and_si128(vec_src, mask_low_4_bits);\n        __m128i condition_mask = _mm_cmpeq_epi32(low_4_bits, mask_low_4_bits);\n        \n        // Rotate elements\n        __m128i rotated_vec = _mm_or_si128(\n            _mm_sll_epi32(vec_src, _mm_cvtsi32_si128(rotate_bits)),\n            _mm_srl_epi32(vec_src, _mm_cvtsi32_si128(32 - rotate_bits))\n        );\n        \n        // Bitwise negate elements\n        __m128i negated_vec = _mm_xor_si128(vec_src, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Blend based on condition\n        __m128i result_vec = _mm_blendv_epi8(negated_vec, rotated_vec, condition_mask);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0x0000000F) == 0x0000000F) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 source elements\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Create mask for low 4 bits\n        __m128i low_bits_mask = _mm_set1_epi32(0x0000000F);\n        \n        // Check if low 4 bits are all 1\n        __m128i low_bits = _mm_and_si128(src_vec, low_bits_mask);\n        __m128i all_ones_mask = _mm_cmpeq_epi32(low_bits, low_bits_mask);\n        \n        // Rotate elements where low 4 bits are all 1\n        __m128i rotated_vec;\n        if (rotate_bits == 1) {\n            rotated_vec = _mm_or_si128(\n                _mm_slli_epi32(src_vec, 1),\n                _mm_srli_epi32(src_vec, 31)\n            );\n        } else {\n            rotated_vec = _mm_or_si128(\n                _mm_slli_epi32(src_vec, rotate_bits),\n                _mm_srli_epi32(src_vec, 32 - rotate_bits)\n            );\n        }\n        \n        // Bitwise negate elements where low 4 bits are not all 1\n        __m128i negated_vec = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Blend rotated and negated vectors based on condition\n        __m128i result_vec = _mm_blendv_epi8(negated_vec, rotated_vec, all_ones_mask);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&dst[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t current = src[i];\n        if ((current & 0x0000000F) == 0x0000000F) {\n            // Rotate bits\n            dst[i] = (current << rotate_bits) | (current >> (32 - rotate_bits));\n        } else {\n            // Bitwise negate\n            dst[i] = ~current;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 eps_vec = _mm_set1_ps(epsilon);\n    __m128 neg_eps_vec = _mm_sub_ps(_mm_setzero_ps(), eps_vec);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        __m128 b_vec = _mm_loadu_ps(B + i);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n\n        __m128 gt_mask = _mm_cmpgt_ps(diff_vec, eps_vec);\n        __m128 lt_mask = _mm_cmplt_ps(diff_vec, neg_eps_vec);\n        __m128 eq_mask = _mm_cmpeq_ps(diff_vec, diff_vec);\n        eq_mask = _mm_andnot_ps(_mm_or_ps(gt_mask, lt_mask), eq_mask);\n\n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(gt_mask), _mm_set1_epi32(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(lt_mask), _mm_set1_epi32(-1)));\n\n        _mm_storeu_si128((__m128i*)(out + i), result_vec);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(epsilon);\n    __m128 neg_epsilon_vec = _mm_sub_ps(_mm_setzero_ps(), epsilon_vec);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        __m128 b_vec = _mm_loadu_ps(B + i);\n        \n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 lt_mask = _mm_cmplt_ps(diff_vec, neg_epsilon_vec);\n        \n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(gt_mask), _mm_set1_epi32(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(lt_mask), _mm_set1_epi32(-1)));\n        \n        _mm_storeu_si128((__m128i*)(out + i), result_vec);\n    }\n    \n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 eps_vec = _mm_set1_ps(epsilon);\n    __m128 neg_eps_vec = _mm_sub_ps(_mm_setzero_ps(), eps_vec);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        __m128 b_vec = _mm_loadu_ps(B + i);\n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n\n        __m128 gt_mask = _mm_cmpgt_ps(diff_vec, eps_vec);\n        __m128 lt_mask = _mm_cmplt_ps(diff_vec, neg_eps_vec);\n        __m128 eq_mask = _mm_cmpeq_ps(_mm_and_ps(_mm_abs_ps(diff_vec), _mm_abs_ps(diff_vec)), _mm_setzero_ps());\n\n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(gt_mask), _mm_set1_epi32(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(lt_mask), _mm_set1_epi32(-1)));\n\n        _mm_storeu_si128((__m128i*)(out + i), result_vec);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon)\n            out[i] = 1;\n        else if (diff < -epsilon)\n            out[i] = -1;\n        else\n            out[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(epsilon);\n    __m128 neg_epsilon_vec = _mm_set1_ps(-epsilon);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        __m128 b_vec = _mm_loadu_ps(B + i);\n        \n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 gt_epsilon = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 lt_neg_epsilon = _mm_cmplt_ps(diff_vec, neg_epsilon_vec);\n        \n        __m128 abs_diff_vec = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec);\n        __m128 within_epsilon = _mm_cmple_ps(abs_diff_vec, epsilon_vec);\n        \n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(gt_epsilon), _mm_set1_epi32(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(lt_neg_epsilon), _mm_set1_epi32(-1)));\n        \n        _mm_storeu_si128((__m128i*)(out + i), result_vec);\n    }\n    \n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 epsilon_vec = _mm_set1_ps(epsilon);\n    __m128 neg_epsilon_vec = _mm_sub_ps(_mm_setzero_ps(), epsilon_vec);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        __m128 b_vec = _mm_loadu_ps(B + i);\n        \n        __m128 diff_vec = _mm_sub_ps(a_vec, b_vec);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff_vec, epsilon_vec);\n        __m128 lt_mask = _mm_cmplt_ps(diff_vec, neg_epsilon_vec);\n        \n        __m128i result_vec = _mm_setzero_si128();\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(gt_mask), _mm_set1_epi32(1)));\n        result_vec = _mm_or_si128(result_vec, _mm_and_si128(_mm_castps_si128(lt_mask), _mm_set1_epi32(-1)));\n        \n        _mm_storeu_si128((__m128i*)(out + i), result_vec);\n    }\n    \n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const __m128 max_val = _mm_set1_ps((float)INT32_MAX);\n    const __m128 min_val = _mm_set1_ps((float)INT32_MIN);\n\n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        __m128 float_vec = _mm_loadu_ps(&A[i]);\n\n        // Clamp values between INT32_MIN and INT32_MAX\n        float_vec = _mm_min_ps(float_vec, max_val);\n        float_vec = _mm_max_ps(float_vec, min_val);\n\n        // Convert to int32_t with saturation\n        __m128i int_vec = _mm_cvttps_epi32(float_vec);\n\n        // Store 4 int32_t values\n        _mm_storeu_si128((__m128i*)&B[i], int_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        __m128 float_vec = _mm_loadu_ps(A + i);\n        \n        // Convert float to int with saturation\n        __m128i int_vec = _mm_cvttps_epi32(float_vec);\n        \n        // Handle values outside INT32_MAX and INT32_MIN\n        __m128 max_mask = _mm_cmpgt_ps(float_vec, _mm_set1_ps((float)INT32_MAX));\n        __m128 min_mask = _mm_cmplt_ps(float_vec, _mm_set1_ps((float)INT32_MIN));\n        \n        __m128i max_vec = _mm_set1_epi32(INT32_MAX);\n        __m128i min_vec = _mm_set1_epi32(INT32_MIN);\n        \n        int_vec = _mm_blendv_epi8(int_vec, max_vec, _mm_castps_si128(max_mask));\n        int_vec = _mm_blendv_epi8(int_vec, min_vec, _mm_castps_si128(min_mask));\n        \n        _mm_storeu_si128((__m128i*)(B + i), int_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from source array\n        __m128 float_vec = _mm_loadu_ps(A + i);\n        \n        // Convert floats to integers with saturation\n        __m128i int_vec = _mm_cvttps_epi32(float_vec);\n        \n        // Store the converted integers to destination array\n        _mm_storeu_si128((__m128i*)(B + i), int_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 float_vec = _mm_loadu_ps(A + i);\n        __m128 max_val = _mm_set1_ps((float)INT32_MAX);\n        __m128 min_val = _mm_set1_ps((float)INT32_MIN);\n        \n        float_vec = _mm_min_ps(float_vec, max_val);\n        float_vec = _mm_max_ps(float_vec, min_val);\n        \n        __m128i int_vec = _mm_cvttps_epi32(float_vec);\n        _mm_storeu_si128((__m128i*)(B + i), int_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 floats at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 float values\n        __m128 float_vec = _mm_loadu_ps(A + i);\n        \n        // Convert floats to integers with saturation\n        __m128i int_vec = _mm_cvttps_epi32(float_vec);\n        \n        // Store the converted integers\n        _mm_storeu_si128((__m128i*)(B + i), int_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Load scale factor into a vector\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    // Process 4 elements at a time\n    size_t i;\n    for (i = 0; i < size - 3; i += 4) {\n        // Load 4 int32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert int32_t to float\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        \n        // Scale the float values\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        \n        // Store the result\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Broadcast the scale factor to all lanes of a vector register\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    // Process 4 elements at a time using SSE\n    size_t i;\n    for (i = 0; i < size - 3; i += 4) {\n        // Load 4 int32_t values from source array\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n\n        // Convert int32_t to float\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n\n        // Scale the float values\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n\n        // Store the scaled float values to destination array\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Load scale factor as a float\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    // Process 4 elements at a time\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        // Load 4 int32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert int32_t to float\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        \n        // Scale the float values\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n        \n        // Store the result\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    // Broadcast scale factor to all lanes of a vector register\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n\n    // Process 4 elements at a time using SSE\n    size_t i;\n    for (i = 0; i < size - 3; i += 4) {\n        // Load 4 int32_t values from source array\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n\n        // Convert int32_t to float\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n\n        // Scale the float values\n        float_vec = _mm_mul_ps(float_vec, scale_vec);\n\n        // Store the scaled float values to destination array\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        \n        __m128 div_result = _mm_div_ps(a_vec, b_vec);\n        \n        __m128 rounded = _mm_cvtps_epi32(_mm_round_ps(div_result, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC));\n        \n        _mm_storeu_si128((__m128i*)&C[i], rounded);\n    }\n    \n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        \n        __m128 div_vec = _mm_div_ps(a_vec, b_vec);\n        __m128 rounded_vec = _mm_cvtps_epi32(_mm_round_ps(div_vec, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC));\n        \n        _mm_storeu_si128((__m128i*)&C[i], rounded_vec);\n    }\n    \n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128 b_vec = _mm_loadu_ps(&B[i]);\n        \n        __m128 div_vec = _mm_div_ps(a_vec, b_vec);\n        __m128 rounded_vec = _mm_cvtps_epi32(_mm_round_ps(div_vec, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC));\n        \n        _mm_storeu_si128((__m128i*)&C[i], rounded_vec);\n    }\n    \n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A and B\n        __m128 va = _mm_loadu_ps(A + i);\n        __m128 vb = _mm_loadu_ps(B + i);\n        \n        // Perform element-wise division\n        __m128 vdiv = _mm_div_ps(va, vb);\n        \n        // Round to nearest integer\n        __m128 vrounded = _mm_round_ps(vdiv, _MM_FROUND_TO_NEAREST_INT);\n        \n        // Convert to 32-bit integers\n        __m128i vint = _mm_cvtps_epi32(vrounded);\n        \n        // Store result in C\n        _mm_storeu_si128((__m128i*)(C + i), vint);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 floats from A and B\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        __m128 b_vec = _mm_loadu_ps(B + i);\n\n        // Perform division\n        __m128 div_vec = _mm_div_ps(a_vec, b_vec);\n\n        // Round to nearest integer\n        __m128 rounded_vec = _mm_round_ps(div_vec, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n\n        // Convert to 32-bit integers\n        __m128i int_vec = _mm_cvtps_epi32(rounded_vec);\n\n        // Store result\n        _mm_storeu_si128((__m128i*)(C + i), int_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 max_val = _mm_set1_ps(FLT_MAX);\n    const __m128 min_val = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        // Load two doubles\n        __m128d double_vec1 = _mm_loadu_pd(&A[i]);\n        __m128d double_vec2 = _mm_loadu_pd(&A[i+1]);\n        \n        // Convert doubles to floats\n        __m128 float_vec1 = _mm_cvtpd_ps(double_vec1);\n        __m128 float_vec2 = _mm_cvtpd_ps(double_vec2);\n        \n        // Saturate values\n        float_vec1 = _mm_min_ps(_mm_max_ps(float_vec1, min_val), max_val);\n        float_vec2 = _mm_min_ps(_mm_max_ps(float_vec2, min_val), max_val);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], float_vec1);\n        _mm_storeu_ps(&B[i+1], float_vec2);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float converted = (float)A[i];\n        B[i] = (converted > FLT_MAX) ? FLT_MAX : \n               (converted < -FLT_MAX) ? -FLT_MAX : converted;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 max_val = _mm_set1_ps(FLT_MAX);\n    const __m128 min_val = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        // Load two double values\n        __m128d double_vec1 = _mm_loadu_pd(&A[i]);\n        __m128d double_vec2 = _mm_loadu_pd(&A[i+1]);\n        \n        // Convert first two doubles to floats\n        __m128 float_vec1 = _mm_cvtpd_ps(double_vec1);\n        __m128 float_vec2 = _mm_cvtpd_ps(double_vec2);\n        \n        // Saturate values\n        float_vec1 = _mm_min_ps(_mm_max_ps(float_vec1, min_val), max_val);\n        float_vec2 = _mm_min_ps(_mm_max_ps(float_vec2, min_val), max_val);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], float_vec1);\n        _mm_storeu_ps(&B[i+1], float_vec2);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float converted = (float)A[i];\n        B[i] = (converted > FLT_MAX) ? FLT_MAX : \n               (converted < -FLT_MAX) ? -FLT_MAX : converted;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 max_val = _mm_set1_ps(FLT_MAX);\n    const __m128 min_val = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        // Load 2 doubles\n        __m128d double_vec1 = _mm_loadu_pd(&A[i]);\n        __m128d double_vec2 = _mm_loadu_pd(&A[i+1]);\n        \n        // Convert doubles to floats\n        __m128 float_vec1 = _mm_cvtpd_ps(double_vec1);\n        __m128 float_vec2 = _mm_cvtpd_ps(double_vec2);\n        \n        // Saturate values\n        float_vec1 = _mm_min_ps(_mm_max_ps(float_vec1, min_val), max_val);\n        float_vec2 = _mm_min_ps(_mm_max_ps(float_vec2, min_val), max_val);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], float_vec1);\n        _mm_storeu_ps(&B[i+1], float_vec2);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float converted = (float)A[i];\n        B[i] = (converted > FLT_MAX) ? FLT_MAX : \n               (converted < -FLT_MAX) ? -FLT_MAX : converted;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 max_float = _mm_set1_ps(FLT_MAX);\n    const __m128 min_float = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        // Load two doubles\n        __m128d double_vec1 = _mm_loadu_pd(&A[i]);\n        \n        // Convert first double to float\n        __m128 float_vec1 = _mm_cvtpd_ps(double_vec1);\n        \n        // Load next two doubles\n        __m128d double_vec2 = _mm_loadu_pd(&A[i+1]);\n        \n        // Convert second double to float\n        __m128 float_vec2 = _mm_cvtpd_ps(double_vec2);\n        \n        // Saturate to FLT_MAX and -FLT_MAX\n        float_vec1 = _mm_min_ps(_mm_max_ps(float_vec1, min_float), max_float);\n        float_vec2 = _mm_min_ps(_mm_max_ps(float_vec2, min_float), max_float);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], float_vec1);\n        _mm_storeu_ps(&B[i+1], float_vec2);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float converted = (float)A[i];\n        B[i] = (converted > FLT_MAX) ? FLT_MAX : \n               (converted < -FLT_MAX) ? -FLT_MAX : converted;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 max_float = _mm_set1_ps(FLT_MAX);\n    const __m128 min_float = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        // Load 2 double values\n        __m128d double_vec1 = _mm_loadu_pd(&A[i]);\n        __m128d double_vec2 = _mm_loadu_pd(&A[i+1]);\n        \n        // Convert first double to float\n        __m128 float_vec1 = _mm_cvtpd_ps(double_vec1);\n        \n        // Convert second double to float\n        __m128 float_vec2 = _mm_cvtpd_ps(double_vec2);\n        \n        // Saturate to FLT_MAX and -FLT_MAX\n        float_vec1 = _mm_min_ps(_mm_max_ps(float_vec1, min_float), max_float);\n        float_vec2 = _mm_min_ps(_mm_max_ps(float_vec2, min_float), max_float);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], float_vec1);\n        _mm_storeu_ps(&B[i+1], float_vec2);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float converted = (float)A[i];\n        B[i] = (converted > FLT_MAX) ? FLT_MAX : \n               (converted < -FLT_MAX) ? -FLT_MAX : converted;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 8 <= size; i += 8) {\n        __m128i input = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert lower 4 int16_t to int32_t\n        __m128i low = _mm_srai_epi32(_mm_unpacklo_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i], low);\n        \n        // Convert upper 4 int16_t to int32_t\n        __m128i high = _mm_srai_epi32(_mm_unpackhi_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i + 4], high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 8 <= size; i += 8) {\n        __m128i input = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert lower 4 int16_t to int32_t\n        __m128i low = _mm_srai_epi32(_mm_unpacklo_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i], low);\n        \n        // Convert upper 4 int16_t to int32_t\n        __m128i high = _mm_srai_epi32(_mm_unpackhi_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i + 4], high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 8 <= size; i += 8) {\n        __m128i input = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert lower 4 int16_t to int32_t\n        __m128i low = _mm_srai_epi32(_mm_unpacklo_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i], low);\n        \n        // Convert upper 4 int16_t to int32_t\n        __m128i high = _mm_srai_epi32(_mm_unpackhi_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i + 4], high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 8 <= size; i += 8) {\n        __m128i input = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert lower 4 int16_t to int32_t\n        __m128i low = _mm_srai_epi32(_mm_unpacklo_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i], low);\n        \n        // Convert upper 4 int16_t to int32_t\n        __m128i high = _mm_srai_epi32(_mm_unpackhi_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i+4], high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 8 <= size; i += 8) {\n        __m128i input = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Convert lower 4 int16_t to int32_t\n        __m128i low = _mm_srai_epi32(_mm_unpacklo_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i], low);\n        \n        // Convert upper 4 int16_t to int32_t\n        __m128i high = _mm_srai_epi32(_mm_unpackhi_epi16(input, input), 16);\n        _mm_storeu_si128((__m128i*)&B[i + 4], high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 zero_vec = _mm_setzero_ps();\n    __m128 one_vec = _mm_set1_ps(1.0f);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128i control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n        \n        __m128 normalized_vec = _mm_sub_ps(a_vec, min_vec);\n        normalized_vec = _mm_div_ps(normalized_vec, range_vec);\n        \n        normalized_vec = _mm_min_ps(normalized_vec, one_vec);\n        normalized_vec = _mm_max_ps(normalized_vec, zero_vec);\n        \n        __m128 mask = _mm_cmpgt_ps(_mm_cvtepi32_ps(control_vec), _mm_setzero_ps());\n        normalized_vec = _mm_blendv_ps(a_vec, normalized_vec, mask);\n        \n        _mm_storeu_ps(&B[i], normalized_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 zero_vec = _mm_setzero_ps();\n    __m128 one_vec = _mm_set1_ps(1.0f);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128i control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n\n        __m128 normalized_vec = _mm_sub_ps(a_vec, min_vec);\n        normalized_vec = _mm_div_ps(normalized_vec, range_vec);\n        normalized_vec = _mm_min_ps(_mm_max_ps(normalized_vec, zero_vec), one_vec);\n\n        __m128 mask = _mm_cmpgt_ps(_mm_cvtepi32_ps(control_vec), zero_vec);\n        __m128 result_vec = _mm_or_ps(_mm_and_ps(mask, normalized_vec), \n                                       _mm_andnot_ps(mask, a_vec));\n\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = size - (size % 4); i < size; ++i) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (normalized < 0.0f) ? 0.0f : (normalized > 1.0f) ? 1.0f : normalized;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 zero_vec = _mm_setzero_ps();\n    __m128 one_vec = _mm_set1_ps(1.0f);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128 control_vec = _mm_loadu_si128((__m128i*)(control + i));\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        \n        __m128 mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n        \n        __m128 normalized_vec = _mm_sub_ps(a_vec, min_vec);\n        normalized_vec = _mm_div_ps(normalized_vec, range_vec);\n        \n        normalized_vec = _mm_max_ps(normalized_vec, zero_vec);\n        normalized_vec = _mm_min_ps(normalized_vec, one_vec);\n        \n        __m128 result_vec = _mm_blendv_ps(a_vec, normalized_vec, _mm_castsi128_ps(mask));\n        \n        _mm_storeu_ps(B + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 zero_vec = _mm_setzero_ps();\n    __m128 one_vec = _mm_set1_ps(1.0f);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128 control_vec = _mm_loadu_si128((__m128i*)(control + i));\n        __m128 a_vec = _mm_loadu_ps(A + i);\n        \n        // Check control values\n        __m128 mask = _mm_cmpgt_ps(_mm_cvtepi32_ps(control_vec), zero_vec);\n        \n        // Normalize values where control > 0\n        __m128 normalized_vec = _mm_div_ps(_mm_sub_ps(a_vec, min_vec), range_vec);\n        normalized_vec = _mm_max_ps(_mm_min_ps(normalized_vec, one_vec), zero_vec);\n        \n        // Blend normalized or original values based on control mask\n        __m128 result_vec = _mm_blendv_ps(a_vec, normalized_vec, mask);\n        \n        _mm_storeu_ps(B + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = size - (size % 4); i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (val < 0.0f) ? 0.0f : (val > 1.0f) ? 1.0f : val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 min_vec = _mm_set1_ps(min_val);\n    __m128 max_vec = _mm_set1_ps(max_val);\n    __m128 zero_vec = _mm_setzero_ps();\n    __m128 one_vec = _mm_set1_ps(1.0f);\n    __m128 range_vec = _mm_sub_ps(max_vec, min_vec);\n\n    for (size_t i = 0; i < size; i += 4) {\n        __m128 a_vec = _mm_loadu_ps(&A[i]);\n        __m128i control_vec = _mm_loadu_si128((__m128i*)&control[i]);\n\n        // Subtract min_val from A\n        __m128 normalized_vec = _mm_sub_ps(a_vec, min_vec);\n        \n        // Divide by range\n        normalized_vec = _mm_div_ps(normalized_vec, range_vec);\n\n        // Clamp between 0 and 1\n        normalized_vec = _mm_max_ps(normalized_vec, zero_vec);\n        normalized_vec = _mm_min_ps(normalized_vec, one_vec);\n\n        // Create mask for control values > 0\n        __m128i mask = _mm_cmpgt_epi32(control_vec, _mm_setzero_si128());\n        \n        // Blend normalized or original values based on control\n        __m128 result_vec = _mm_blendv_ps(a_vec, normalized_vec, _mm_castsi128_ps(mask));\n\n        // Store result\n        _mm_storeu_ps(&B[i], result_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = size - (size % 4); i < size; ++i) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = (normalized < 0.0f) ? 0.0f : (normalized > 1.0f ? 1.0f : normalized);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Shift right by 16 bits to get high 16 bits\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        \n        // Convert to float\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        \n        // Take square root\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Shift right by 16 bits to get high 16 bits\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        \n        // Convert to float\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        \n        // Take square root\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Shift right by 16 bits to get high 16 bits\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        \n        // Convert to float\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        \n        // Compute square root\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Shift right by 16 bits to get high 16 bits\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        \n        // Convert to float\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        \n        // Take square root\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Shift right by 16 bits to get high 16 bits\n        __m128i shifted_vec = _mm_srli_epi32(int_vec, 16);\n        \n        // Convert to float\n        __m128 float_vec = _mm_cvtepi32_ps(shifted_vec);\n        \n        // Take square root\n        __m128 sqrt_vec = _mm_sqrt_ps(float_vec);\n        \n        // Store results\n        _mm_storeu_ps(&B[i], sqrt_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Directly reinterpret the bits as float using SSE intrinsic\n        __m128 float_vec = _mm_castsi128_ps(int_vec);\n        \n        // Store the result in destination array\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128 float_vec = _mm_castsi128_ps(int_vec);\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Directly reinterpret bits as float using SSE intrinsic\n        __m128 float_vec = _mm_castsi128_ps(int_vec);\n        \n        // Store the reinterpreted float values to destination array\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Directly reinterpret the bits as float using SSE intrinsic\n        __m128 float_vec = _mm_castsi128_ps(int_vec);\n        \n        // Store the result in destination array\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= size; i += 4) {\n        // Load 4 uint32_t values from source array\n        __m128i int_vec = _mm_loadu_si128((__m128i*)&A[i]);\n        \n        // Directly reinterpret bits as float using SSE intrinsic\n        __m128 float_vec = _mm_castsi128_ps(int_vec);\n        \n        // Store 4 float values to destination array\n        _mm_storeu_ps(&B[i], float_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load 4 condition values\n        __m128 cond_vec = _mm_loadu_ps(reinterpret_cast<const float*>(&cond[i]));\n        \n        // Load 4 current and previous integer values\n        __m128i curr_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&A[i]));\n        __m128i prev_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&A[i-1]));\n        \n        // Compute differences\n        __m128i diff_vec = _mm_sub_epi32(curr_vec, prev_vec);\n        \n        // Convert to float\n        __m128 diff_float = _mm_cvtepi32_ps(diff_vec);\n        \n        // Mask differences based on condition\n        __m128 masked_diff = _mm_and_ps(diff_float, cond_vec);\n        \n        // Store results\n        _mm_storeu_ps(&diff[i], masked_diff);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load condition flags\n        __m128 cond_vec = _mm_castsi128_ps(_mm_loadu_si128((__m128i*)(cond + i)));\n        \n        // Load current and previous integers \n        __m128i curr_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev_vec = _mm_loadu_si128((__m128i*)(A + i - 1));\n        \n        // Compute differences\n        __m128i diff_vec = _mm_sub_epi32(curr_vec, prev_vec);\n        \n        // Convert to float\n        __m128 diff_float_vec = _mm_cvtepi32_ps(diff_vec);\n        \n        // Mask differences based on condition\n        __m128 masked_diff = _mm_and_ps(diff_float_vec, cond_vec);\n        \n        // Store results\n        _mm_storeu_ps(diff + i, masked_diff);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load condition values\n        __m128 cond_vec = _mm_castsi128_ps(_mm_loadu_si128((__m128i*)(cond + i)));\n        \n        // Load current and previous integer values \n        __m128i curr_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev_vec = _mm_loadu_si128((__m128i*)(A + i - 1));\n        \n        // Compute differences\n        __m128i diff_vec = _mm_sub_epi32(curr_vec, prev_vec);\n        \n        // Convert to float\n        __m128 diff_float = _mm_cvtepi32_ps(diff_vec);\n        \n        // Mask differences based on condition\n        __m128 masked_diff = _mm_and_ps(diff_float, cond_vec);\n        \n        // Store results\n        _mm_storeu_ps(diff + i, masked_diff);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load condition mask\n        __m128 cond_mask = _mm_setr_ps(\n            cond[i] ? 1.0f : 0.0f,\n            cond[i+1] ? 1.0f : 0.0f, \n            cond[i+2] ? 1.0f : 0.0f, \n            cond[i+3] ? 1.0f : 0.0f\n        );\n\n        // Load integers and convert to float\n        __m128 curr_vals = _mm_cvtepi32_ps(_mm_loadu_si128((__m128i*)&A[i]));\n        __m128 prev_vals = _mm_cvtepi32_ps(_mm_loadu_si128((__m128i*)&A[i-1]));\n\n        // Compute differences\n        __m128 diff_vals = _mm_sub_ps(curr_vals, prev_vals);\n\n        // Mask differences based on condition\n        diff_vals = _mm_mul_ps(diff_vals, cond_mask);\n\n        // Store results\n        _mm_storeu_ps(&diff[i], diff_vals);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        // Load condition values\n        __m128 cond_vec = _mm_setr_ps(\n            cond[i], cond[i+1], cond[i+2], cond[i+3]\n        );\n\n        // Load integer values\n        __m128i a_curr = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i a_prev = _mm_loadu_si128((__m128i*)&A[i-1]);\n\n        // Compute differences\n        __m128i diff_int = _mm_sub_epi32(a_curr, a_prev);\n\n        // Convert to float\n        __m128 diff_float = _mm_cvtepi32_ps(diff_int);\n\n        // Mask differences based on condition\n        __m128 masked_diff = _mm_and_ps(diff_float, cond_vec);\n\n        // Store results\n        _mm_storeu_ps(&diff[i], masked_diff);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit unsigned integers \n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Convert lower 2 32-bit integers to 64-bit integers and set high bits\n        __m128i dst_vec_low = _mm_unpacklo_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Convert upper 2 32-bit integers to 64-bit integers and set high bits\n        __m128i dst_vec_high = _mm_unpackhi_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], dst_vec_low);\n        _mm_storeu_si128((__m128i*)&dst[i+2], dst_vec_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit unsigned integers\n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Convert lower 2 32-bit integers to 64-bit integers\n        __m128i low_vec = _mm_unpacklo_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Convert upper 2 32-bit integers to 64-bit integers\n        __m128i high_vec = _mm_unpackhi_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], low_vec);\n        _mm_storeu_si128((__m128i*)&dst[i+2], high_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit unsigned integers \n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Convert lower 2 32-bit integers to 64-bit integers and set high bits\n        __m128i dst_vec_low = _mm_unpacklo_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Convert upper 2 32-bit integers to 64-bit integers and set high bits\n        __m128i dst_vec_high = _mm_unpackhi_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], dst_vec_low);\n        _mm_storeu_si128((__m128i*)&dst[i+2], dst_vec_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit unsigned integers \n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Convert lower 2 32-bit integers to 64-bit integers\n        __m128i low_vec = _mm_unpacklo_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Convert upper 2 32-bit integers to 64-bit integers\n        __m128i high_vec = _mm_unpackhi_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], low_vec);\n        _mm_storeu_si128((__m128i*)&dst[i+2], high_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    \n    // Process 4 elements at a time using SSE2 intrinsics\n    for (; i + 4 <= length; i += 4) {\n        // Load 4 32-bit unsigned integers \n        __m128i src_vec = _mm_loadu_si128((__m128i*)&src[i]);\n        \n        // Convert lower 2 32-bit integers to 64-bit integers\n        __m128i low_vec = _mm_unpacklo_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Convert upper 2 32-bit integers to 64-bit integers  \n        __m128i high_vec = _mm_unpackhi_epi32(src_vec, _mm_set1_epi32(-1));\n        \n        // Store results in destination array\n        _mm_storeu_si128((__m128i*)&dst[i], low_vec);\n        _mm_storeu_si128((__m128i*)&dst[i+2], high_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i idx_vec = _mm_loadl_epi64((__m128i*)&index[i]);\n        idx_vec = _mm_unpacklo_epi16(idx_vec, _mm_setzero_si128());\n        \n        __m128d val1 = _mm_loadh_pd(_mm_load_sd(&vec[index[i]]), &vec[index[i+1]]);\n        sum_vec = _mm_add_pd(sum_vec, val1);\n    }\n    \n    double result = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n    \n    if (i < length) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i indices = _mm_loadl_epi64((__m128i*)&index[i]);\n        indices = _mm_unpacklo_epi16(indices, _mm_setzero_si128());\n        \n        __m128d vec1 = _mm_loadh_pd(_mm_load_sd(&vec[index[i]]), &vec[index[i+1]]);\n        \n        sum_vec = _mm_add_pd(sum_vec, vec1);\n    }\n    \n    double final_sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n    \n    if (i < length) {\n        final_sum += vec[index[i]];\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum_vec = _mm_setzero_pd();\n\n    for (size_t i = 0; i < length; i += 2) {\n        // Load two indices\n        __m128i indices = _mm_loadl_epi64((__m128i*)(index + i));\n        \n        // Convert indices to 32-bit integers\n        __m128i indices_32 = _mm_unpacklo_epi16(indices, _mm_setzero_si128());\n        \n        // Load corresponding double values\n        __m128d val1 = _mm_loadh_pd(_mm_loadl_pd(_mm_setzero_pd(), vec + _mm_cvtsi128_si32(indices_32)), \n                                     vec + _mm_cvtsi128_si32(_mm_srli_si128(indices_32, 4)));\n        \n        // Add to sum vector\n        sum_vec = _mm_add_pd(sum_vec, val1);\n    }\n\n    // Handle any remaining elements\n    double final_sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n    \n    for (size_t i = length - (length % 2); i < length; ++i) {\n        final_sum += vec[index[i]];\n    }\n\n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i indices = _mm_loadl_epi16((__m128i*)&index[i]);\n        indices = _mm_unpacklo_epi16(_mm_setzero_si128(), indices);\n        \n        __m128d vec_values = _mm_setr_pd(\n            vec[_mm_cvtsi128_si32(indices)], \n            vec[_mm_cvtsi128_si32(_mm_srli_si128(indices, 4))]\n        );\n        \n        sum_vec = _mm_add_pd(sum_vec, vec_values);\n    }\n    \n    double final_sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n    \n    if (i < length) {\n        final_sum += vec[index[i]];\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum_vec = _mm_setzero_pd();\n    \n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        __m128i idx_vec = _mm_loadu_si128((__m128i*)&index[i]);\n        \n        __m128d val1 = _mm_loadh_pd(_mm_load_sd(&vec[index[i]]), &vec[index[i+1]]);\n        \n        sum_vec = _mm_add_pd(sum_vec, val1);\n    }\n    \n    double final_sum = _mm_cvtsd_f64(sum_vec) + _mm_cvtsd_f64(_mm_shuffle_pd(sum_vec, sum_vec, 1));\n    \n    if (i < length) {\n        final_sum += vec[index[i]];\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    __m128d input_vec = _mm_set1_pd(input[(i + ki) * input_size + (j + kj)]);\n                    __m128d kernel_vec = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    \n                    sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(input_vec, kernel_vec));\n                }\n            }\n\n            double sum = _mm_cvtsd_f64(sum_vec);\n            output[i * output_size + j] = sum > 0 ? sum : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    __m128d input_vec = _mm_set1_pd(input[(i + ki) * input_size + (j + kj)]);\n                    __m128d kernel_vec = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    \n                    sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(input_vec, kernel_vec));\n                }\n            }\n            \n            double sum = _mm_cvtsd_f64(sum_vec);\n            output[i * output_size + j] = sum > 0 ? sum : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    __m128d input_vec = _mm_set1_pd(input[(i + ki) * input_size + (j + kj)]);\n                    __m128d kernel_vec = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    \n                    sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(input_vec, kernel_vec));\n                }\n            }\n            \n            double conv_result = _mm_cvtsd_f64(sum_vec);\n            output[i * output_size + j] = conv_result > 0 ? conv_result : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    __m128d input_vec = _mm_set1_pd(input[(i + ki) * input_size + (j + kj)]);\n                    __m128d kernel_vec = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    \n                    sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(input_vec, kernel_vec));\n                }\n            }\n            \n            double sum = _mm_cvtsd_f64(sum_vec);\n            output[i * output_size + j] = sum > 0 ? sum : 0; // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            __m128d sum_vec = _mm_setzero_pd();\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    __m128d input_vec = _mm_set1_pd(input[(i + ki) * input_size + (j + kj)]);\n                    __m128d kernel_vec = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    \n                    sum_vec = _mm_add_pd(sum_vec, _mm_mul_pd(input_vec, kernel_vec));\n                }\n            }\n\n            double sum = _mm_cvtsd_f64(sum_vec);\n            output[i * output_size + j] = (sum > 0) ? sum : 0.0;  // ReLU activation\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using SSE2\n    for (int i = 0; i < n; i += 2) {\n        __m128d current = _mm_loadu_pd(&numbers[i]);\n        \n        // Compare with subsequent elements\n        for (int j = i + 2; j < n; j += 2) {\n            __m128d compare = _mm_loadu_pd(&numbers[j]);\n            \n            // Compute absolute difference\n            __m128d diff = _mm_sub_pd(current, compare);\n            diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff); // Take absolute value\n            \n            // Check if difference is less than threshold\n            __m128d mask = _mm_cmplt_pd(diff, _mm_set1_pd(threshold));\n            int result = _mm_movemask_pd(mask);\n            \n            if (result) return true;\n        }\n        \n        // Handle last odd element if vector size is odd\n        if (i + 1 < n) {\n            double current_val = numbers[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_val - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using SSE2 \n    for (int i = 0; i < n; i += 2) {\n        __m128d current = _mm_loadu_pd(&numbers[i]);\n        \n        // Compare with subsequent elements\n        for (int j = i + 2; j < n; j += 2) {\n            __m128d compare = _mm_loadu_pd(&numbers[j]);\n            \n            // Compute absolute difference\n            __m128d diff = _mm_sub_pd(current, compare);\n            diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff); // abs value\n            \n            // Check if difference is less than threshold\n            __m128d threshold_vec = _mm_set1_pd(threshold);\n            __m128d mask = _mm_cmplt_pd(diff, threshold_vec);\n            \n            if (_mm_movemask_pd(mask)) {\n                return true;\n            }\n        }\n        \n        // Handle last odd element if vector size is odd\n        if (i + 1 < n) {\n            double current_val = numbers[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_val - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using SSE2\n    for (int i = 0; i < n; i += 2) {\n        __m128d current = _mm_loadu_pd(&numbers[i]);\n        \n        // Compare with subsequent elements\n        for (int j = i + 2; j < n; j += 2) {\n            __m128d compare = _mm_loadu_pd(&numbers[j]);\n            \n            // Compute absolute difference\n            __m128d diff = _mm_sub_pd(current, compare);\n            diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff); // Take absolute value\n            \n            // Check if difference is less than threshold\n            __m128d threshold_vec = _mm_set1_pd(threshold);\n            __m128d mask = _mm_cmplt_pd(diff, threshold_vec);\n            \n            if (_mm_movemask_pd(mask)) {\n                return true;\n            }\n        }\n        \n        // Handle last odd element if vector size is odd\n        if (i + 1 < n) {\n            double current_val = numbers[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_val - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using SSE2 \n    for (int i = 0; i < n; i += 2) {\n        __m128d current = _mm_loadu_pd(&numbers[i]);\n        \n        // Compare with subsequent elements\n        for (int j = i + 2; j < n; j += 2) {\n            __m128d compare = _mm_loadu_pd(&numbers[j]);\n            \n            // Compute absolute difference\n            __m128d diff = _mm_sub_pd(current, compare);\n            diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff); // abs value\n            \n            // Check if difference is less than threshold\n            __m128d threshold_vec = _mm_set1_pd(threshold);\n            __m128d mask = _mm_cmplt_pd(diff, threshold_vec);\n            \n            if (_mm_movemask_pd(mask)) {\n                return true;\n            }\n        }\n        \n        // Handle last element if odd number of elements\n        if (i + 1 < n) {\n            double current_val = numbers[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_val - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    \n    // Process 2 doubles at a time using SSE2\n    for (int i = 0; i < n; i += 2) {\n        __m128d current = _mm_loadu_pd(&numbers[i]);\n        \n        for (int j = i + 2; j < n; j += 2) {\n            __m128d compare = _mm_loadu_pd(&numbers[j]);\n            \n            // Compute absolute difference\n            __m128d diff = _mm_sub_pd(current, compare);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            \n            // Check if difference is less than threshold\n            __m128d threshold_vec = _mm_set1_pd(threshold);\n            __m128d cmp_result = _mm_cmplt_pd(abs_diff, threshold_vec);\n            \n            // Check if any comparison is true\n            if (_mm_movemask_pd(cmp_result)) {\n                return true;\n            }\n        }\n        \n        // Handle last odd element if vector size is odd\n        if (i + 1 < n) {\n            double current_val = numbers[i + 1];\n            for (int j = i + 2; j < n; j++) {\n                if (std::abs(current_val - numbers[j]) < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int balance = 0;\n    \n    // Process 4 elements at a time using SSE\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        \n        // Accumulate balance\n        balance += _mm_cvtsi128_si32(ops);\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(1, 1, 1, 1)));\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(2, 2, 2, 2)));\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(3, 3, 3, 3)));\n        \n        // Check if balance goes negative\n        if (balance < 0) return true;\n    }\n    \n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int balance = 0;\n\n    // Process 4 elements at a time using SSE\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        __m128i current_balance = _mm_set1_epi32(balance);\n        current_balance = _mm_add_epi32(current_balance, ops);\n        \n        // Check if any element becomes negative\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmplt_epi32(current_balance, zero);\n        if (_mm_movemask_epi8(mask) != 0) {\n            return true;\n        }\n        \n        balance += operations[i] + operations[i+1] + operations[i+2] + operations[i+3];\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int balance = 0;\n    \n    // Process 4 elements at a time using SSE\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        \n        // Compute running sum\n        balance += _mm_cvtsi128_si32(ops);\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(1, 1, 1, 1)));\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(2, 2, 2, 2)));\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(3, 3, 3, 3)));\n        \n        // Check if balance goes negative\n        if (balance < 0) return true;\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        balance += operations[i];\n        if (balance < 0) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int balance = 0;\n    \n    // Process 4 elements at a time using SSE\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        \n        // Compute running sum\n        balance += _mm_cvtsi128_si32(ops);\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(1, 1, 1, 1)));\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(2, 2, 2, 2)));\n        balance += _mm_cvtsi128_si32(_mm_shuffle_epi32(ops, _MM_SHUFFLE(3, 3, 3, 3)));\n        \n        // Check if balance goes negative\n        if (balance < 0) return true;\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        balance += operations[i];\n        if (balance < 0) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    int balance = 0;\n    \n    // Process 4 elements at a time using SSE\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        \n        // Accumulate balance\n        balance += _mm_cvtsi128_si32(ops);\n        balance += _mm_cvtsi128_si32(_mm_srli_si128(ops, 4));\n        balance += _mm_cvtsi128_si32(_mm_srli_si128(ops, 8));\n        balance += _mm_cvtsi128_si32(_mm_srli_si128(ops, 12));\n        \n        // Check if balance goes negative\n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    // Process remaining elements\n    for (; i < n; ++i) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double x : numbers) sum += x;\n    double mean = sum / n;\n\n    // Prepare SIMD processing\n    int simd_size = n - (n % 2);\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d zero_vec = _mm_setzero_pd();\n    __m128d sum_abs_dev = _mm_setzero_pd();\n\n    // Process in pairs using SSE2\n    for (int i = 0; i < simd_size; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d diff_vec = _mm_sub_pd(data_vec, mean_vec);\n        __m128d abs_diff_vec = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec);\n        sum_abs_dev = _mm_add_pd(sum_abs_dev, abs_diff_vec);\n    }\n\n    // Horizontal sum of SIMD vector\n    double abs_dev_array[2];\n    _mm_storeu_pd(abs_dev_array, sum_abs_dev);\n    double total_abs_dev = abs_dev_array[0] + abs_dev_array[1];\n\n    // Handle remaining elements\n    for (int i = simd_size; i < n; ++i) {\n        total_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return total_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double x : numbers) sum += x;\n    double mean = sum / n;\n\n    // Prepare SIMD processing\n    int simd_width = 2; // SSE processes 2 doubles at a time\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d zero_vec = _mm_setzero_pd();\n    __m128d sum_abs_dev = _mm_setzero_pd();\n\n    // Process in SIMD chunks\n    int i;\n    for (i = 0; i + simd_width <= n; i += simd_width) {\n        __m128d data_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d diff_vec = _mm_sub_pd(data_vec, mean_vec);\n        __m128d abs_diff_vec = _mm_andnot_pd(_mm_set1_pd(-0.0), diff_vec);\n        sum_abs_dev = _mm_add_pd(sum_abs_dev, abs_diff_vec);\n    }\n\n    // Horizontal sum of SIMD vector\n    double abs_dev_array[2];\n    _mm_storeu_pd(abs_dev_array, sum_abs_dev);\n    double total_abs_dev = abs_dev_array[0] + abs_dev_array[1];\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        total_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return total_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double x : numbers) sum += x;\n    double mean = sum / n;\n\n    // Prepare mean vector for SIMD\n    __m128d mean_vec = _mm_set1_pd(mean);\n    \n    // Accumulate absolute deviations using SIMD\n    __m128d deviation_sum = _mm_setzero_pd();\n    for (int i = 0; i < n - 1; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d abs_diff = _mm_sub_pd(data_vec, mean_vec);\n        abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), abs_diff); // Take absolute value\n        deviation_sum = _mm_add_pd(deviation_sum, abs_diff);\n    }\n\n    // Horizontal sum of deviation_sum\n    double deviations[2];\n    _mm_storeu_pd(deviations, deviation_sum);\n    double total_deviation = deviations[0] + deviations[1];\n\n    // Handle last element if odd number of elements\n    if (n % 2 != 0) {\n        total_deviation += std::abs(numbers[n-1] - mean);\n    }\n\n    return total_deviation / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double x : numbers) sum += x;\n    double mean = sum / n;\n\n    // Prepare SIMD processing\n    int simd_size = n - (n % 2);\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d zero_vec = _mm_setzero_pd();\n    __m128d sum_abs_dev = _mm_setzero_pd();\n\n    // Process in pairs using SSE2\n    for (int i = 0; i < simd_size; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d diff_vec = _mm_sub_pd(data_vec, mean_vec);\n        __m128d abs_diff_vec = _mm_max_pd(_mm_sub_pd(zero_vec, diff_vec), diff_vec);\n        sum_abs_dev = _mm_add_pd(sum_abs_dev, abs_diff_vec);\n    }\n\n    // Horizontal sum\n    double abs_dev_array[2];\n    _mm_storeu_pd(abs_dev_array, sum_abs_dev);\n    double simd_sum = abs_dev_array[0] + abs_dev_array[1];\n\n    // Handle remaining elements\n    for (int i = simd_size; i < n; ++i) {\n        simd_sum += std::abs(numbers[i] - mean);\n    }\n\n    return simd_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean\n    double sum = 0.0;\n    for (double x : numbers) sum += x;\n    double mean = sum / n;\n\n    // SIMD processing of absolute deviations\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d zero_vec = _mm_setzero_pd();\n    __m128d sum_abs_dev = _mm_setzero_pd();\n\n    int i = 0;\n    for (; i + 1 < n; i += 2) {\n        __m128d data_vec = _mm_loadu_pd(&numbers[i]);\n        __m128d dev_vec = _mm_sub_pd(data_vec, mean_vec);\n        __m128d abs_dev_vec = _mm_max_pd(_mm_sub_pd(zero_vec, dev_vec), dev_vec);\n        sum_abs_dev = _mm_add_pd(sum_abs_dev, abs_dev_vec);\n    }\n\n    // Horizontal sum\n    double abs_dev_array[2];\n    _mm_storeu_pd(abs_dev_array, sum_abs_dev);\n    double total_abs_dev = abs_dev_array[0] + abs_dev_array[1];\n\n    // Handle remaining element if odd length\n    for (; i < n; ++i) {\n        total_abs_dev += std::abs(numbers[i] - mean);\n    }\n\n    return total_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int i = 0;\n    // Process 4 elements at a time using SSE\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Shuffle to interleave with delimiter\n        __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n        __m128i shuffled_vec = _mm_unpacklo_epi32(vec, delimiter_vec);\n        __m128i shuffled_vec2 = _mm_unpackhi_epi32(vec, delimiter_vec);\n\n        // Store results\n        int temp[8];\n        _mm_storeu_si128((__m128i*)temp, shuffled_vec);\n        _mm_storeu_si128((__m128i*)(temp + 4), shuffled_vec2);\n\n        result.insert(result.end(), temp, temp + 8);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int i = 0;\n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Shuffle to interleave with delimiter\n        __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n        __m128i result_vec1 = _mm_unpacklo_epi32(vec, delimiter_vec);\n        __m128i result_vec2 = _mm_unpackhi_epi32(vec, delimiter_vec);\n        \n        // Store results\n        int temp[8];\n        _mm_storeu_si128((__m128i*)temp, result_vec1);\n        _mm_storeu_si128((__m128i*)(temp + 4), result_vec2);\n        \n        result.insert(result.end(), temp, temp + 8);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int i = 0;\n    // Process 4 elements at a time using SSE\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Shuffle to interleave with delimiter\n        __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n        __m128i shuffled_vec = _mm_unpacklo_epi32(vec, delimiter_vec);\n        __m128i shuffled_vec2 = _mm_unpackhi_epi32(vec, delimiter_vec);\n\n        // Store results\n        int temp[8];\n        _mm_storeu_si128((__m128i*)temp, shuffled_vec);\n        _mm_storeu_si128((__m128i*)(temp + 4), shuffled_vec2);\n\n        result.insert(result.end(), temp, temp + 8);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int n = numbers.size();\n    int vectorSize = n - (n % 4);\n\n    for (int i = 0; i < vectorSize; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n        \n        result.push_back(numbers[i]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+1]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+2]);\n        result.push_back(delimeter);\n        result.push_back(numbers[i+3]);\n        result.push_back(delimeter);\n    }\n\n    for (int i = vectorSize; i < n; ++i) {\n        result.push_back(numbers[i]);\n        if (i < n - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int i = 0;\n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Shuffle to interleave with delimiter\n        __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n        __m128i result_vec1 = _mm_unpacklo_epi32(vec, delimiter_vec);\n        __m128i result_vec2 = _mm_unpackhi_epi32(vec, delimiter_vec);\n        \n        // Store results\n        int temp[8];\n        _mm_storeu_si128((__m128i*)temp, result_vec1);\n        _mm_storeu_si128((__m128i*)(temp + 4), result_vec2);\n        \n        result.insert(result.end(), temp, temp + 8);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    int n = numbers.size();\n    int simd_width = 8; // SSE can process 8 int16_t values at once\n    \n    // Process in SIMD blocks\n    for (int i = 0; i <= n - simd_width; i += simd_width) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Horizontal sum\n        __m128i sum_vec = _mm_sad_epu16(vec, _mm_setzero_si128());\n        sum += _mm_cvtsi128_si32(sum_vec) + _mm_cvtsi128_si32(_mm_srli_si128(sum_vec, 8));\n        \n        // Horizontal product\n        __m128i prod_vec = vec;\n        prod_vec = _mm_mullo_epi16(prod_vec, _mm_srli_si128(prod_vec, 2));\n        prod_vec = _mm_mullo_epi16(prod_vec, _mm_srli_si128(prod_vec, 4));\n        prod_vec = _mm_mullo_epi16(prod_vec, _mm_srli_si128(prod_vec, 8));\n        product *= _mm_cvtsi128_si32(prod_vec);\n    }\n    \n    // Process remaining elements\n    for (int i = (n / simd_width) * simd_width; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    int n = numbers.size();\n    int simd_width = 8; // SSE can process 8 int16_t values at once\n    \n    // Process vectors in SIMD chunks\n    for (int i = 0; i <= n - simd_width; i += simd_width) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Sum calculation\n        __m128i zero = _mm_setzero_si128();\n        __m128i sum_vec = _mm_sad_epu16(vec, zero);\n        sum += _mm_cvtsi128_si32(sum_vec) + _mm_cvtsi128_si32(_mm_shuffle_epi32(sum_vec, 1));\n        \n        // Product calculation\n        __m128i prod_vec = _mm_set1_epi16(1);\n        for (int j = 0; j < 8; j++) {\n            prod_vec = _mm_mullo_epi16(prod_vec, vec);\n        }\n        int16_t temp_prod[8];\n        _mm_storeu_si128((__m128i*)temp_prod, prod_vec);\n        for (int j = 0; j < 8; j++) {\n            product *= temp_prod[j];\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n / simd_width) * simd_width; i < n; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    int n = numbers.size();\n    int vectorSize = n - (n % 8);\n    \n    __m128i sumVector = _mm_setzero_si128();\n    __m128i productVector = _mm_set1_epi16(1);\n    \n    for (int i = 0; i < vectorSize; i += 8) {\n        __m128i currentVector = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Sum calculation\n        sumVector = _mm_add_epi16(sumVector, currentVector);\n        \n        // Product calculation\n        productVector = _mm_mullo_epi16(productVector, currentVector);\n    }\n    \n    // Horizontal sum for sum\n    __m128i sumShuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(1, 0, 3, 2));\n    sumVector = _mm_add_epi16(sumVector, sumShuffled);\n    sumShuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(0, 1, 2, 3));\n    sumVector = _mm_add_epi16(sumVector, sumShuffled);\n    sum = _mm_cvtsi128_si32(sumVector) & 0xFFFF;\n    \n    // Horizontal product for product\n    __m128i productShuffled = _mm_shuffle_epi32(productVector, _MM_SHUFFLE(1, 0, 3, 2));\n    productVector = _mm_mullo_epi16(productVector, productShuffled);\n    productShuffled = _mm_shuffle_epi32(productVector, _MM_SHUFFLE(0, 1, 2, 3));\n    productVector = _mm_mullo_epi16(productVector, productShuffled);\n    product = _mm_cvtsi128_si32(productVector) & 0xFFFF;\n    \n    // Process remaining elements\n    for (int i = vectorSize; i < n; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    int n = numbers.size();\n    int vectorSize = n - (n % 8);\n    \n    __m128i sumVector = _mm_setzero_si128();\n    __m128i productVector = _mm_set1_epi16(1);\n    \n    for (int i = 0; i < vectorSize; i += 8) {\n        __m128i currentVector = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Sum calculation\n        sumVector = _mm_add_epi16(sumVector, currentVector);\n        \n        // Product calculation\n        productVector = _mm_mullo_epi16(productVector, currentVector);\n    }\n    \n    // Horizontal sum for sum\n    __m128i sumShuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(1, 0, 3, 2));\n    sumVector = _mm_add_epi16(sumVector, sumShuffled);\n    sumShuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(0, 1, 2, 3));\n    sumVector = _mm_add_epi16(sumVector, sumShuffled);\n    \n    sum = _mm_cvtsi128_si32(sumVector) & 0xFFFF;\n    \n    // Horizontal product for product\n    __m128i productShuffled = _mm_shuffle_epi32(productVector, _MM_SHUFFLE(1, 0, 3, 2));\n    productVector = _mm_mullo_epi16(productVector, productShuffled);\n    productShuffled = _mm_shuffle_epi32(productVector, _MM_SHUFFLE(0, 1, 2, 3));\n    productVector = _mm_mullo_epi16(productVector, productShuffled);\n    \n    product = _mm_cvtsi128_si32(productVector) & 0xFFFF;\n    \n    // Process remaining elements\n    for (int i = vectorSize; i < n; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    int n = numbers.size();\n    int vectorSize = n - (n % 8);\n    \n    __m128i sumVector = _mm_setzero_si128();\n    __m128i productVector = _mm_set1_epi16(1);\n    \n    for (int i = 0; i < vectorSize; i += 8) {\n        __m128i currentVector = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Sum calculation\n        sumVector = _mm_add_epi16(sumVector, currentVector);\n        \n        // Product calculation\n        productVector = _mm_mullo_epi16(productVector, currentVector);\n    }\n    \n    // Horizontal sum for sum\n    __m128i sumShuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(1, 0, 3, 2));\n    sumVector = _mm_add_epi16(sumVector, sumShuffled);\n    sumShuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(0, 1, 2, 3));\n    sumVector = _mm_add_epi16(sumVector, sumShuffled);\n    \n    sum = _mm_cvtsi128_si32(sumVector) & 0xFFFF;\n    \n    // Horizontal product for product\n    __m128i productShuffled = _mm_shuffle_epi32(productVector, _MM_SHUFFLE(1, 0, 3, 2));\n    productVector = _mm_mullo_epi16(productVector, productShuffled);\n    productShuffled = _mm_shuffle_epi32(productVector, _MM_SHUFFLE(0, 1, 2, 3));\n    productVector = _mm_mullo_epi16(productVector, productShuffled);\n    \n    product = _mm_cvtsi128_si32(productVector) & 0xFFFF;\n    \n    // Process remaining elements\n    for (int i = vectorSize; i < n; i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Process first element\n    result[0] = numbers[0];\n    \n    // Use SSE2 intrinsics for parallel processing\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i prev_max = _mm_loadu_si128((__m128i*)&result[i]);\n        \n        __m128i max_vec = _mm_max_epi32(current, prev_max);\n        \n        _mm_storeu_si128((__m128i*)&result[i], max_vec);\n    }\n    \n    // Process remaining elements sequentially\n    int max_so_far = result[0];\n    for (int i = 1; i < n; i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Process first element\n    result[0] = numbers[0];\n    \n    // Use SSE2 intrinsics for parallel processing\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i prev_max = _mm_loadu_si128((__m128i*)&result[i]);\n        \n        // Compute rolling max using SSE max intrinsics\n        __m128i max_vec = _mm_max_epi32(current, prev_max);\n        \n        _mm_storeu_si128((__m128i*)&result[i], max_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    int max_so_far = result[0];\n    for (int i = 1; i < n; i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using SSE\n    int i = 0;\n    __m128i current_max = _mm_setzero_si128();\n    \n    for (; i + 3 < n; i += 4) {\n        // Load 4 integers\n        __m128i vec = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Update maximum\n        current_max = _mm_max_epi32(current_max, vec);\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], current_max);\n    }\n    \n    // Handle remaining elements sequentially\n    int current_seq_max = (i > 0) ? _mm_cvtsi128_si32(current_max) : numbers[0];\n    \n    for (; i < n; ++i) {\n        current_seq_max = std::max(current_seq_max, numbers[i]);\n        result[i] = current_seq_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Process first element\n    result[0] = numbers[0];\n    \n    // Use SSE2 intrinsics for parallel processing\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i prev_max = _mm_loadu_si128((__m128i*)&result[i]);\n        \n        // Compute rolling max using SSE max intrinsic\n        __m128i rolling_max = _mm_max_epi32(current, prev_max);\n        \n        _mm_storeu_si128((__m128i*)&result[i], rolling_max);\n    }\n    \n    // Handle remaining elements sequentially\n    int max_so_far = result[0];\n    for (int i = 1; i < n; i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    \n    // Process first element\n    result[0] = numbers[0];\n    \n    // Use SSE2 intrinsics for parallel processing\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i prev_max = _mm_loadu_si128((__m128i*)&result[i]);\n        \n        // Compute rolling max using SSE max intrinsics\n        __m128i max_vec = _mm_max_epi32(current, prev_max);\n        \n        _mm_storeu_si128((__m128i*)&result[i], max_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    int max_so_far = result[0];\n    for (int i = 1; i < n; i++) {\n        max_so_far = std::max(max_so_far, numbers[i]);\n        result[i] = max_so_far;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure strings are of equal length\n    if (a.length() != b.length()) {\n        return \"\";\n    }\n\n    int len = a.length();\n    std::string result(len, '0');\n\n    // Process 16 bits at a time using SSE2\n    int vectorLen = len / 16;\n    int remainder = len % 16;\n\n    __m128i* aVec = (__m128i*)a.data();\n    __m128i* bVec = (__m128i*)b.data();\n\n    for (int i = 0; i < vectorLen; i++) {\n        __m128i aBlock = _mm_loadu_si128(aVec + i);\n        __m128i bBlock = _mm_loadu_si128(bVec + i);\n        __m128i xorResult = _mm_xor_si128(aBlock, bBlock);\n        _mm_storeu_si128((__m128i*)(result.data() + i * 16), xorResult);\n    }\n\n    // Handle remaining bits\n    for (int i = vectorLen * 16; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    int len = a.length();\n    std::string result(len, '0');\n\n    // Process 16 bits at a time using SSE2\n    int vec_len = len / 16;\n    int remainder = len % 16;\n\n    for (int i = 0; i < vec_len; i++) {\n        __m128i va = _mm_loadu_si128((__m128i*)&a[i * 16]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&b[i * 16]);\n        \n        // Convert characters to integers\n        __m128i mask = _mm_set1_epi8('1');\n        va = _mm_cmpeq_epi8(va, mask);\n        vb = _mm_cmpeq_epi8(vb, mask);\n        \n        // Perform XOR\n        __m128i vxor = _mm_xor_si128(va, vb);\n        \n        // Convert back to characters\n        vxor = _mm_xor_si128(vxor, mask);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&result[i * 16], vxor);\n    }\n\n    // Handle remaining bits\n    for (int i = vec_len * 16; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    std::string result(a.length(), '0');\n    int len = a.length();\n    \n    // Process 16 bytes at a time using SSE2\n    int vectorLen = len - (len % 16);\n    for (int i = 0; i < vectorLen; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&a[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&b[i]);\n        \n        // XOR the 16-byte vectors\n        __m128i vxor = _mm_xor_si128(va, vb);\n        \n        // Store result back\n        _mm_storeu_si128((__m128i*)&result[i], vxor);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorLen; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure strings are of equal length\n    if (a.length() != b.length()) {\n        return \"\";\n    }\n\n    int len = a.length();\n    std::string result(len, '0');\n\n    // Process 128 bits (16 bytes) at a time\n    int vectorLen = len / 16;\n    int i;\n\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&a[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&b[i]);\n        \n        // XOR the 128-bit vectors\n        __m128i vxor = _mm_xor_si128(va, vb);\n        \n        // Store result back\n        _mm_storeu_si128((__m128i*)&result[i], vxor);\n    }\n\n    // Handle remaining bits\n    for (; i < len; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Strings must be of equal length\");\n    }\n\n    int len = a.length();\n    std::string result(len, '0');\n\n    // Process 16 bits at a time using SSE2\n    int vec_len = len / 16;\n    int remainder = len % 16;\n\n    for (int i = 0; i < vec_len; i++) {\n        __m128i va = _mm_loadu_si128((__m128i*)&a[i * 16]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&b[i * 16]);\n        \n        // Convert characters to binary values\n        __m128i zero = _mm_setzero_si128();\n        va = _mm_cmpeq_epi8(va, _mm_set1_epi8('1'));\n        vb = _mm_cmpeq_epi8(vb, _mm_set1_epi8('1'));\n        \n        // Perform XOR\n        __m128i vxor = _mm_xor_si128(va, vb);\n        \n        // Convert back to characters\n        vxor = _mm_add_epi8(vxor, _mm_set1_epi8('0'));\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&result[i * 16], vxor);\n    }\n\n    // Handle remaining bits\n    for (int i = vec_len * 16; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    int n = strings.size();\n    int max_length = 0;\n    int max_index = 0;\n\n    // Process 4 strings at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i length_vec = _mm_setzero_si128();\n        __m128i index_vec = _mm_setzero_si128();\n\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            int len = strings[i + j].length();\n            __m128i current_length = _mm_set1_epi32(len);\n            __m128i current_index = _mm_set1_epi32(i + j);\n\n            // Compare lengths and update max length and index\n            __m128i mask = _mm_cmpgt_epi32(current_length, length_vec);\n            length_vec = _mm_blendv_epi8(length_vec, current_length, mask);\n            index_vec = _mm_blendv_epi8(index_vec, current_index, mask);\n        }\n\n        // Extract max length and index\n        int max_len_simd = _mm_cvtsi128_si32(length_vec);\n        int max_idx_simd = _mm_cvtsi128_si32(index_vec);\n\n        if (max_len_simd > max_length) {\n            max_length = max_len_simd;\n            max_index = max_idx_simd;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Process 4 strings at a time using SSE\n    for (size_t i = 0; i + 4 <= n; i += 4) {\n        __m128i lengths = _mm_setzero_si128();\n        \n        // Load string lengths into vector\n        lengths = _mm_set_epi32(\n            strings[i+3].length(), \n            strings[i+2].length(), \n            strings[i+1].length(), \n            strings[i].length()\n        );\n\n        // Find max length\n        __m128i max_lengths = _mm_max_epu32(lengths, _mm_srli_si128(lengths, 8));\n        max_lengths = _mm_max_epu32(max_lengths, _mm_srli_si128(max_lengths, 4));\n\n        int max_simd_length = _mm_cvtsi128_si32(max_lengths);\n        \n        // Find index of max length\n        for (size_t j = i; j < i + 4; ++j) {\n            if (strings[j].length() > max_length) {\n                max_length = strings[j].length();\n                max_index = j;\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (size_t i = (n / 4) * 4; i < n; ++i) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    int n = strings.size();\n    int max_length = 0;\n    int max_index = 0;\n\n    // Process 4 strings at a time using SSE\n    for (int i = 0; i < n - 3; i += 4) {\n        __m128i length_vec = _mm_set_epi32(\n            strings[i+3].length(),\n            strings[i+2].length(),\n            strings[i+1].length(),\n            strings[i].length()\n        );\n\n        // Find max length in this group of 4\n        __m128i max_length_vec = _mm_max_epi16(length_vec, _mm_srli_si128(length_vec, 8));\n        max_length_vec = _mm_max_epi16(max_length_vec, _mm_srli_si128(max_length_vec, 4));\n\n        int current_max_length = _mm_cvtsi128_si32(max_length_vec);\n        \n        // Find index of max length\n        for (int j = 0; j < 4; j++) {\n            if (strings[i+j].length() > max_length) {\n                max_length = strings[i+j].length();\n                max_index = i+j;\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (int i = n - (n % 4); i < n; i++) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    std::string longest = strings[0];\n    size_t max_length = longest.length();\n\n    // Process 4 strings at a time using SSE\n    for (size_t i = 0; i + 4 <= n; i += 4) {\n        __m128i length_vec = _mm_setzero_si128();\n        __m128i max_length_vec = _mm_setzero_si128();\n        __m128i max_index_vec = _mm_setzero_si128();\n\n        // Load string lengths\n        for (int j = 0; j < 4; ++j) {\n            int len = strings[i + j].length();\n            length_vec = _mm_insert_epi32(length_vec, len, j);\n        }\n\n        // Compare lengths\n        max_length_vec = _mm_max_epi32(length_vec, max_length_vec);\n        max_index_vec = _mm_cmpeq_epi32(length_vec, max_length_vec);\n        int mask = _mm_movemask_epi8(max_index_vec);\n\n        // Find the index of the longest string\n        for (int j = 0; j < 4; ++j) {\n            if (mask & (1 << (j * 4))) {\n                if (strings[i + j].length() > max_length) {\n                    longest = strings[i + j];\n                    max_length = longest.length();\n                }\n                break;\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (size_t i = (n / 4) * 4; i < n; ++i) {\n        if (strings[i].length() > max_length) {\n            longest = strings[i];\n            max_length = longest.length();\n        }\n    }\n\n    return longest;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    int n = strings.size();\n    int max_length = 0;\n    int max_index = 0;\n\n    // Process 4 strings at a time using SSE\n    for (int i = 0; i < n - 3; i += 4) {\n        __m128i length_vec = _mm_set_epi32(\n            strings[i+3].length(),\n            strings[i+2].length(),\n            strings[i+1].length(),\n            strings[i].length()\n        );\n\n        // Find max length in this group of 4\n        __m128i max_length_vec = _mm_max_epi16(length_vec, _mm_srli_si128(length_vec, 8));\n        max_length_vec = _mm_max_epi16(max_length_vec, _mm_srli_si128(max_length_vec, 4));\n\n        int current_max = _mm_cvtsi128_si32(max_length_vec);\n        \n        // Find index of max length\n        for (int j = 0; j < 4; j++) {\n            if (strings[i+j].length() > max_length) {\n                max_length = strings[i+j].length();\n                max_index = i+j;\n            }\n        }\n    }\n\n    // Process remaining strings\n    for (int i = n - (n % 4); i < n; i++) {\n        if (strings[i].length() > max_length) {\n            max_length = strings[i].length();\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = _mm_set1_epi64x(_mm_cvtsi128_si64(va) % _mm_cvtsi128_si64(vb));\n        va = vb;\n        vb = temp;\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = _mm_set1_epi64x(_mm_cvtsi128_si64(va) % _mm_cvtsi128_si64(vb));\n        va = vb;\n        vb = temp;\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n\n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = _mm_set1_epi64x(_mm_cvtsi128_si64(va) % _mm_cvtsi128_si64(vb));\n        va = vb;\n        vb = temp;\n    }\n\n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = _mm_set1_epi64x(_mm_cvtsi128_si64(va) % _mm_cvtsi128_si64(vb));\n        va = vb;\n        vb = temp;\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set1_epi64x(a);\n    __m128i vb = _mm_set1_epi64x(b);\n    \n    while (_mm_cvtsi128_si64(vb) != 0) {\n        __m128i temp = _mm_set1_epi64x(_mm_cvtsi128_si64(va) % _mm_cvtsi128_si64(vb));\n        va = vb;\n        vb = temp;\n    }\n    \n    return _mm_cvtsi128_si64(va);\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0, closest_b = 0;\n\n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128 current = _mm_loadu_ps(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            __m128 diff = _mm_sub_ps(_mm_set1_ps(numbers[j]), current);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n            \n            // Horizontal min of absolute differences\n            abs_diff = _mm_min_ps(abs_diff, _mm_shuffle_ps(abs_diff, abs_diff, _MM_SHUFFLE(1, 0, 3, 2)));\n            abs_diff = _mm_min_ps(abs_diff, _mm_shuffle_ps(abs_diff, abs_diff, _MM_SHUFFLE(0, 1, 2, 3)));\n            \n            float current_min_diff = _mm_cvtss_f32(abs_diff);\n            \n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                \n                // Find the actual elements\n                for (int k = 0; k < 4; k++) {\n                    if (std::abs(numbers[j] - numbers[i + k]) == min_diff) {\n                        closest_a = std::min(numbers[j], numbers[i + k]);\n                        closest_b = std::max(numbers[j], numbers[i + k]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0, closest_b = 0;\n\n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128 current = _mm_loadu_ps(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            __m128 diff = _mm_sub_ps(_mm_set1_ps(numbers[j]), current);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n            \n            // Horizontal min of absolute differences\n            __m128 min1 = _mm_min_ps(abs_diff, _mm_shuffle_ps(abs_diff, abs_diff, _MM_SHUFFLE(1, 0, 3, 2)));\n            __m128 min2 = _mm_min_ps(min1, _mm_shuffle_ps(min1, min1, _MM_SHUFFLE(0, 1, 2, 3)));\n            \n            float current_min = _mm_cvtss_f32(min2);\n            \n            if (current_min < min_diff) {\n                int min_idx = 0;\n                for (int k = 0; k < 4; k++) {\n                    float curr_diff = std::abs(numbers[j] - numbers[i + k]);\n                    if (curr_diff < min_diff) {\n                        min_diff = curr_diff;\n                        closest_a = std::min(numbers[j], numbers[i + k]);\n                        closest_b = std::max(numbers[j], numbers[i + k]);\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float curr_diff = std::abs(numbers[i] - numbers[j]);\n            if (curr_diff < min_diff) {\n                min_diff = curr_diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0, closest_b = 0;\n\n    // Ensure we have at least 4 elements to leverage SSE\n    if (n < 4) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                float diff = std::abs(numbers[i] - numbers[j]);\n                if (diff < min_diff) {\n                    min_diff = diff;\n                    closest_a = std::min(numbers[i], numbers[j]);\n                    closest_b = std::max(numbers[i], numbers[j]);\n                }\n            }\n        }\n        return {closest_a, closest_b};\n    }\n\n    // SSE processing\n    for (int i = 0; i < n; i += 4) {\n        __m128 current = _mm_loadu_ps(&numbers[i]);\n        \n        for (int j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            __m128 compare = _mm_loadu_ps(&numbers[j]);\n            __m128 diff_vec = _mm_sub_ps(current, compare);\n            __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec);\n            \n            // Horizontal min diff\n            float diff_array[4];\n            _mm_storeu_ps(diff_array, abs_diff);\n            \n            for (int k = 0; k < 4; k++) {\n                for (int l = 0; l < 4; l++) {\n                    if (diff_array[k] < min_diff) {\n                        min_diff = diff_array[k];\n                        closest_a = std::min(numbers[i+k], numbers[j+l]);\n                        closest_b = std::max(numbers[i+k], numbers[j+l]);\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements if vector size is not multiple of 4\n    for (int i = (n/4)*4; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            \n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0, closest_b = 0;\n\n    // Ensure we have at least 4 elements to leverage SSE\n    if (n < 4) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                float diff = std::abs(numbers[i] - numbers[j]);\n                if (diff < min_diff) {\n                    min_diff = diff;\n                    closest_a = std::min(numbers[i], numbers[j]);\n                    closest_b = std::max(numbers[i], numbers[j]);\n                }\n            }\n        }\n        return {closest_a, closest_b};\n    }\n\n    // SSE processing\n    for (int i = 0; i < n; i += 4) {\n        __m128 current = _mm_loadu_ps(&numbers[i]);\n        \n        for (int j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            __m128 compare = _mm_loadu_ps(&numbers[j]);\n            __m128 diff_vec = _mm_sub_ps(current, compare);\n            __m128 abs_diff = _mm_andnot_ps(_mm_set1_ps(-0.0f), diff_vec);\n            \n            float diff_array[4];\n            _mm_storeu_ps(diff_array, abs_diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (diff_array[k] < min_diff && i + k < n && j < n) {\n                    min_diff = diff_array[k];\n                    closest_a = std::min(numbers[i + k], numbers[j]);\n                    closest_b = std::max(numbers[i + k], numbers[j]);\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements if vector length is not multiple of 4\n    for (int i = (n / 4) * 4; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i == j) continue;\n            \n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = 0, closest_b = 0;\n\n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128 current = _mm_loadu_ps(&numbers[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            __m128 diff = _mm_sub_ps(_mm_set1_ps(numbers[j]), current);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n            \n            // Horizontal min of absolute differences\n            abs_diff = _mm_min_ps(abs_diff, _mm_shuffle_ps(abs_diff, abs_diff, _MM_SHUFFLE(1, 0, 3, 2)));\n            abs_diff = _mm_min_ps(abs_diff, _mm_shuffle_ps(abs_diff, abs_diff, _MM_SHUFFLE(0, 1, 2, 3)));\n            \n            float current_min_diff = _mm_cvtss_f32(abs_diff);\n            \n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                \n                // Find the actual elements\n                for (int k = 0; k < 4; k++) {\n                    if (std::abs(numbers[j] - numbers[i + k]) == min_diff) {\n                        closest_a = std::min(numbers[j], numbers[i + k]);\n                        closest_b = std::max(numbers[j], numbers[i + k]);\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                closest_a = std::min(numbers[i], numbers[j]);\n                closest_b = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using SSE\n    __m128 min_vec = _mm_set1_ps(numbers[0]);\n    __m128 max_vec = _mm_set1_ps(numbers[0]);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        min_vec = _mm_min_ps(min_vec, curr_vec);\n        max_vec = _mm_max_ps(max_vec, curr_vec);\n    }\n\n    // Horizontal min and max reduction\n    __m128 min_shuf1 = _mm_shuffle_ps(min_vec, min_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 min_shuf2 = _mm_min_ps(min_vec, min_shuf1);\n    __m128 min_shuf3 = _mm_shuffle_ps(min_shuf2, min_shuf2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 global_min = _mm_min_ss(min_shuf2, min_shuf3);\n    float min_val = _mm_cvtss_f32(global_min);\n\n    __m128 max_shuf1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 max_shuf2 = _mm_max_ps(max_vec, max_shuf1);\n    __m128 max_shuf3 = _mm_shuffle_ps(max_shuf2, max_shuf2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 global_max = _mm_max_ss(max_shuf2, max_shuf3);\n    float max_val = _mm_cvtss_f32(global_max);\n\n    // Rescale using SIMD\n    std::vector<float> result(numbers.size());\n    __m128 min_vec_broadcast = _mm_set1_ps(min_val);\n    __m128 scale_vec = _mm_set1_ps(max_val - min_val);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_div_ps(_mm_sub_ps(curr_vec, min_vec_broadcast), scale_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using SSE\n    __m128 min_vec = _mm_set1_ps(numbers[0]);\n    __m128 max_vec = _mm_set1_ps(numbers[0]);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        min_vec = _mm_min_ps(min_vec, curr_vec);\n        max_vec = _mm_max_ps(max_vec, curr_vec);\n    }\n\n    // Horizontal min and max reduction\n    __m128 min_shuffle1 = _mm_shuffle_ps(min_vec, min_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 min_shuffle2 = _mm_min_ps(min_vec, min_shuffle1);\n    __m128 min_shuffle3 = _mm_shuffle_ps(min_shuffle2, min_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 min_final = _mm_min_ps(min_shuffle2, min_shuffle3);\n    float min_val = _mm_cvtss_f32(min_final);\n\n    __m128 max_shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 max_shuffle2 = _mm_max_ps(max_vec, max_shuffle1);\n    __m128 max_shuffle3 = _mm_shuffle_ps(max_shuffle2, max_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 max_final = _mm_max_ps(max_shuffle2, max_shuffle3);\n    float max_val = _mm_cvtss_f32(max_final);\n\n    // Rescale using SIMD\n    std::vector<float> result(numbers.size());\n    __m128 min_vec_broadcast = _mm_set1_ps(min_val);\n    __m128 max_min_diff_vec = _mm_set1_ps(max_val - min_val);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_div_ps(_mm_sub_ps(curr_vec, min_vec_broadcast), max_min_diff_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using SSE\n    __m128 min_vec = _mm_set1_ps(numbers[0]);\n    __m128 max_vec = _mm_set1_ps(numbers[0]);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        min_vec = _mm_min_ps(min_vec, curr_vec);\n        max_vec = _mm_max_ps(max_vec, curr_vec);\n    }\n\n    // Horizontal min and max reduction\n    __m128 min_shuffle1 = _mm_shuffle_ps(min_vec, min_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 min_shuffle2 = _mm_min_ps(min_vec, min_shuffle1);\n    __m128 min_shuffle3 = _mm_shuffle_ps(min_shuffle2, min_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 min_final = _mm_min_ps(min_shuffle2, min_shuffle3);\n    float min_val = _mm_cvtss_f32(min_final);\n\n    __m128 max_shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 max_shuffle2 = _mm_max_ps(max_vec, max_shuffle1);\n    __m128 max_shuffle3 = _mm_shuffle_ps(max_shuffle2, max_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 max_final = _mm_max_ps(max_shuffle2, max_shuffle3);\n    float max_val = _mm_cvtss_f32(max_final);\n\n    // Rescale using SIMD\n    std::vector<float> result(numbers.size());\n    float scale = max_val > min_val ? 1.0f / (max_val - min_val) : 0.0f;\n    __m128 min_vec_scalar = _mm_set1_ps(min_val);\n    __m128 scale_vec = _mm_set1_ps(scale);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_mul_ps(_mm_sub_ps(curr_vec, min_vec_scalar), scale_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using SSE\n    __m128 min_vec = _mm_set1_ps(numbers[0]);\n    __m128 max_vec = _mm_set1_ps(numbers[0]);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        min_vec = _mm_min_ps(min_vec, curr_vec);\n        max_vec = _mm_max_ps(max_vec, curr_vec);\n    }\n\n    // Horizontal min and max reduction\n    __m128 min_shuffle1 = _mm_shuffle_ps(min_vec, min_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 min_shuffle2 = _mm_min_ps(min_vec, min_shuffle1);\n    __m128 min_shuffle3 = _mm_shuffle_ps(min_shuffle2, min_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 min_final = _mm_min_ps(min_shuffle2, min_shuffle3);\n    float min_val = _mm_cvtss_f32(min_final);\n\n    __m128 max_shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 max_shuffle2 = _mm_max_ps(max_vec, max_shuffle1);\n    __m128 max_shuffle3 = _mm_shuffle_ps(max_shuffle2, max_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 max_final = _mm_max_ps(max_shuffle2, max_shuffle3);\n    float max_val = _mm_cvtss_f32(max_final);\n\n    // Rescale vector\n    std::vector<float> result(numbers.size());\n    float scale = (max_val == min_val) ? 1.0f : 1.0f / (max_val - min_val);\n    __m128 min_vec_scalar = _mm_set1_ps(min_val);\n    __m128 scale_vec = _mm_set1_ps(scale);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_mul_ps(_mm_sub_ps(curr_vec, min_vec_scalar), scale_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n\n    // Find min and max using SSE\n    __m128 min_vec = _mm_set1_ps(numbers[0]);\n    __m128 max_vec = _mm_set1_ps(numbers[0]);\n    \n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        min_vec = _mm_min_ps(min_vec, curr_vec);\n        max_vec = _mm_max_ps(max_vec, curr_vec);\n    }\n\n    // Horizontal min and max reduction\n    __m128 min_shuffle1 = _mm_shuffle_ps(min_vec, min_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 min_shuffle2 = _mm_min_ps(min_vec, min_shuffle1);\n    __m128 min_shuffle3 = _mm_shuffle_ps(min_shuffle2, min_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 min_final = _mm_min_ps(min_shuffle2, min_shuffle3);\n    float min_val = _mm_cvtss_f32(min_final);\n\n    __m128 max_shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 max_shuffle2 = _mm_max_ps(max_vec, max_shuffle1);\n    __m128 max_shuffle3 = _mm_shuffle_ps(max_shuffle2, max_shuffle2, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 max_final = _mm_max_ps(max_shuffle2, max_shuffle3);\n    float max_val = _mm_cvtss_f32(max_final);\n\n    // Rescale using SIMD\n    std::vector<float> result(numbers.size());\n    float scale = (max_val == min_val) ? 1.0f : 1.0f / (max_val - min_val);\n    __m128 min_vec_scalar = _mm_set1_ps(min_val);\n    __m128 scale_vec = _mm_set1_ps(scale);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        __m128 curr_vec = _mm_loadu_ps(&numbers[i]);\n        __m128 scaled_vec = _mm_mul_ps(_mm_sub_ps(curr_vec, min_vec_scalar), scale_vec);\n        _mm_storeu_ps(&result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Use SSE2 intrinsics for parallel divisibility checking\n    __m128i target = _mm_set1_epi64x(n);\n    __m128i divisors = _mm_set_epi64x(n/2, n/2);\n    __m128i one = _mm_set1_epi64x(1);\n\n    for (int64_t i = n/2; i > 1; i--) {\n        __m128i current = _mm_set_epi64x(i, i);\n        __m128i mod = _mm_set1_epi64x(0);\n\n        // Parallel modulo operation\n        mod = _mm_rem_epi64(target, current);\n        \n        // Check if either divisor divides evenly\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(mod, zero);\n        \n        if (_mm_movemask_epi8(mask) & 0x0F) {\n            return _mm_cvtsi128_si64(current);\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    __m128i vec_n = _mm_set1_epi64x(n);\n    __m128i vec_range = _mm_set_epi64x(n/2, n/2);\n    __m128i vec_one = _mm_set1_epi64x(1);\n    __m128i vec_zero = _mm_setzero_si128();\n\n    for (uint64_t i = n/2; i > 0; i -= 2) {\n        __m128i vec_i = _mm_set_epi64x(i, i-1);\n        __m128i vec_mod1 = _mm_rem_epi64(vec_n, vec_i);\n        __m128i vec_mod2 = _mm_rem_epi64(vec_n, _mm_add_epi64(vec_i, vec_one));\n        \n        __m128i vec_mask1 = _mm_cmpeq_epi64(vec_mod1, vec_zero);\n        __m128i vec_mask2 = _mm_cmpeq_epi64(vec_mod2, vec_zero);\n        \n        if (_mm_movemask_epi8(vec_mask1) || _mm_movemask_epi8(vec_mask2)) {\n            uint64_t result[2];\n            _mm_storeu_si128((__m128i*)result, vec_i);\n            \n            if (result[0] != 1 && n % result[0] == 0) return result[0];\n            if (result[1] != 1 && n % result[1] == 0) return result[1];\n        }\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i one_vec = _mm_set1_epi64x(1);\n    __m128i result_vec = _mm_set1_epi64x(1);\n\n    for (uint64_t i = n / 2; i > 0; i -= 2) {\n        __m128i i_vec = _mm_set_epi64x(i, i - 1);\n        __m128i mod_vec = _mm_set1_epi64x(0);\n\n        __m128i div_vec = _mm_div_epu64(n_vec, i_vec);\n        __m128i mul_vec = _mm_mul_epu32(div_vec, i_vec);\n        __m128i cmp_vec = _mm_cmpeq_epi64(mul_vec, n_vec);\n\n        mod_vec = _mm_and_si128(cmp_vec, i_vec);\n        result_vec = _mm_max_epu64(result_vec, mod_vec);\n    }\n\n    uint64_t result[2];\n    _mm_storeu_si128((__m128i*)result, result_vec);\n    return result[0] > result[1] ? result[0] : result[1];\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // Handle edge cases\n    if (n <= 1) return 0;\n\n    // Use SSE2 intrinsics to parallelize divisor search\n    __m128i target = _mm_set1_epi64x(n);\n    __m128i divisors = _mm_set_epi64x(n/2, n/2 + 1);\n    __m128i ones = _mm_set1_epi64x(1);\n    __m128i result = _mm_setzero_si128();\n\n    for (int i = 0; i < 2; i++) {\n        __m128i mod = _mm_rem_epi64(target, divisors);\n        __m128i mask = _mm_cmpeq_epi64(mod, _mm_setzero_si128());\n        __m128i valid_divisors = _mm_and_si128(divisors, mask);\n        result = _mm_max_epu64(result, valid_divisors);\n        divisors = _mm_sub_epi64(divisors, ones);\n    }\n\n    // Extract the maximum divisor\n    uint64_t max_divisor1 = _mm_cvtsi128_si64(result);\n    uint64_t max_divisor2 = _mm_cvtsi128_si64(_mm_shuffle_epi32(result, 1));\n    \n    return max(max_divisor1, max_divisor2);\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 0;\n\n    // Use SSE2 intrinsics to parallelize divisor search\n    __m128i n_vec = _mm_set1_epi64x(n);\n    __m128i div_vec = _mm_set_epi64x(n/2, n/2);\n    __m128i one_vec = _mm_set1_epi64x(1);\n    __m128i result_vec = _mm_setzero_si128();\n\n    for (; _mm_movemask_epi8(_mm_cmpgt_epi64(div_vec, one_vec)) != 0; \n           div_vec = _mm_sub_epi64(div_vec, one_vec)) {\n        __m128i mod_vec = _mm_set_epi64x(\n            n % _mm_extract_epi64(div_vec, 1),\n            n % _mm_extract_epi64(div_vec, 0)\n        );\n\n        __m128i zero_vec = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(mod_vec, zero_vec);\n\n        if (_mm_movemask_epi8(mask) != 0) {\n            result_vec = div_vec;\n            break;\n        }\n    }\n\n    return _mm_extract_epi64(result_vec, 0);\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use SSE2 intrinsics for parallel division checks\n    __m128i divisors = _mm_set_epi32(2, 3, 5, 7);\n    __m128i current = _mm_set1_epi32(n);\n    \n    // Unroll division checks for small prime factors\n    for (int i = 0; i < 4; i++) {\n        __m128i div = _mm_set1_epi32(_mm_cvtsi128_si32(_mm_srli_si128(divisors, i * 4)));\n        \n        while (_mm_cvtsi128_si32(_mm_rem_epi32(current, div)) == 0) {\n            factors.push_back(_mm_cvtsi128_si32(div));\n            current = _mm_div_epi32(current, div);\n        }\n    }\n    \n    // Sequential check for larger prime factors\n    for (int d = 11; d * d <= _mm_cvtsi128_si32(current); d += 2) {\n        while (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        }\n    }\n    \n    // Add remaining factor if greater than 1\n    if (_mm_cvtsi128_si32(current) > 1) {\n        factors.push_back(_mm_cvtsi128_si32(current));\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use SSE2 intrinsics for parallel factor extraction\n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisor = _mm_set1_epi32(2);\n    \n    while (_mm_cvtsi128_si32(num) > 1) {\n        __m128i mod = _mm_mod_epi32(num, divisor);\n        \n        if (_mm_cvtsi128_si32(mod) == 0) {\n            factors.push_back(_mm_cvtsi128_si32(divisor));\n            num = _mm_div_epi32(num, divisor);\n        } else {\n            divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1));\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use SSE2 intrinsics for parallel factor extraction\n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisor = _mm_set1_epi32(2);\n    \n    while (_mm_cvtsi128_si32(num) > 1) {\n        __m128i remainder = _mm_div_epi32(num, divisor);\n        __m128i mod = _mm_sub_epi32(num, _mm_mullo_epi32(remainder, divisor));\n        \n        if (_mm_cvtsi128_si32(mod) == 0) {\n            factors.push_back(_mm_cvtsi128_si32(divisor));\n            num = remainder;\n        } else {\n            divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1));\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use SSE2 intrinsics for parallel factor extraction\n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisor = _mm_set1_epi32(2);\n    \n    while (_mm_cvtsi128_si32(num) > 1) {\n        __m128i remainder = _mm_div_epi32(num, divisor);\n        __m128i mod = _mm_sub_epi32(num, _mm_mullo_epi32(remainder, divisor));\n        \n        if (_mm_cvtsi128_si32(mod) == 0) {\n            factors.push_back(_mm_cvtsi128_si32(divisor));\n            num = remainder;\n        } else {\n            divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1));\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Use SSE2 intrinsics for parallel factor checking\n    __m128i current = _mm_set1_epi32(n);\n    __m128i divisor = _mm_set1_epi32(2);\n    \n    while (_mm_cvtsi128_si32(current) > 1) {\n        __m128i mod = _mm_set1_epi32(0);\n        \n        // Parallel division check\n        mod = _mm_rem_epi32(current, divisor);\n        \n        if (_mm_cvtsi128_si32(mod) == 0) {\n            factors.push_back(_mm_cvtsi128_si32(divisor));\n            current = _mm_div_epi32(current, divisor);\n        } else {\n            divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1));\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    size_t i = 0;\n    for (; i + 4 <= l.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        \n        int movemask = _mm_movemask_ps(mask);\n        \n        if (movemask & 1) result.push_back(l[i]);\n        if (movemask & 2) result.push_back(l[i+1]);\n        if (movemask & 4) result.push_back(l[i+2]);\n        if (movemask & 8) result.push_back(l[i+3]);\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > 0) result.push_back(l[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    size_t i = 0;\n    for (; i + 4 <= l.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        __m128 positive = _mm_and_ps(vec, mask);\n\n        float temp[4];\n        _mm_storeu_ps(temp, positive);\n\n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    size_t i = 0;\n    for (; i + 4 <= l.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        \n        int movemask = _mm_movemask_ps(mask);\n        \n        if (movemask & 1) result.push_back(l[i]);\n        if (movemask & 2) result.push_back(l[i+1]);\n        if (movemask & 4) result.push_back(l[i+2]);\n        if (movemask & 8) result.push_back(l[i+3]);\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > 0) result.push_back(l[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    size_t i = 0;\n    for (; i + 4 <= l.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        __m128 positive = _mm_and_ps(vec, mask);\n\n        float temp[4];\n        _mm_storeu_ps(temp, positive);\n\n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    size_t i = 0;\n    for (; i + 4 <= l.size(); i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 zero = _mm_setzero_ps();\n        __m128 mask = _mm_cmpgt_ps(vec, zero);\n        __m128 positive = _mm_and_ps(vec, mask);\n\n        float temp[4];\n        _mm_storeu_ps(temp, positive);\n\n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Use SSE2 to parallelize divisibility checks\n    __m128i target = _mm_set1_epi64x(n);\n    __m128i increment = _mm_set_epi64x(6, 6);\n    __m128i base = _mm_set_epi64x(1, 5);\n\n    for (__m128i i = base; \n         _mm_cvtsi128_si64(i) * _mm_cvtsi128_si64(i) <= n; \n         i = _mm_add_epi64(i, increment)) {\n        \n        __m128i divisors = _mm_set_epi64x(\n            _mm_cvtsi128_si64(i) + 2, \n            _mm_cvtsi128_si64(i)\n        );\n\n        __m128i mod1 = _mm_set1_epi64x(_mm_cvtsi128_si64(target) % _mm_cvtsi128_si64(divisors));\n        __m128i mod2 = _mm_set1_epi64x(_mm_cvtsi128_si64(target) % ((_mm_cvtsi128_si64(divisors) + 2)));\n\n        if (_mm_cvtsi128_si64(mod1) == 0 || _mm_cvtsi128_si64(mod2) == 0) \n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    // Use SSE2 intrinsics for parallel divisibility check\n    __m128i target = _mm_set1_epi64x(n);\n    __m128i increment = _mm_set_epi64x(6, 6);\n    __m128i base = _mm_set_epi64x(1, 5);\n\n    for (__m128i i = base; \n         _mm_cvtsi128_si64(i) * _mm_cvtsi128_si64(i) <= n; \n         i = _mm_add_epi64(i, increment)) {\n        \n        __m128i divisors = _mm_set_epi64x(\n            _mm_cvtsi128_si64(i) + 2, \n            _mm_cvtsi128_si64(i)\n        );\n\n        __m128i mod1 = _mm_set1_epi64x(_mm_cvtsi128_si64(target) % _mm_cvtsi128_si64(divisors));\n        __m128i mod2 = _mm_set1_epi64x(_mm_cvtsi128_si64(target) % ((_mm_cvtsi128_si64(divisors) + 2)));\n\n        if (_mm_cvtsi128_si64(mod1) == 0 || _mm_cvtsi128_si64(mod2) == 0) \n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    __m128i limit = _mm_set1_epi64x(sqrt(n));\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i six = _mm_set1_epi64x(6);\n    __m128i divisor = _mm_set1_epi64x(5);\n\n    while (_mm_comile_epi64(divisor, limit)) {\n        __m128i check1 = _mm_set1_epi64x(divisor[0]);\n        __m128i check2 = _mm_set1_epi64x(divisor[0] + 2);\n\n        __m128i mod1 = _mm_rem_epi64(num, check1);\n        __m128i mod2 = _mm_rem_epi64(num, check2);\n\n        if (_mm_comieq_epi64(mod1, _mm_setzero_si128()) || \n            _mm_comieq_epi64(mod2, _mm_setzero_si128())) {\n            return false;\n        }\n\n        divisor = _mm_add_epi64(divisor, six);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    __m128i limit = _mm_set1_epi64x((long long)sqrt(n));\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i six = _mm_set1_epi64x(6);\n    __m128i increment = _mm_set1_epi64x(1);\n\n    for (__m128i i = _mm_set1_epi64x(5); \n         _mm_cvtsi128_si64(i) <= _mm_cvtsi128_si64(limit); \n         i = _mm_add_epi64(i, six)) {\n        \n        __m128i check1 = _mm_add_epi64(i, two);\n        __m128i check2 = _mm_sub_epi64(i, two);\n\n        if (n % _mm_cvtsi128_si64(check1) == 0 || \n            n % _mm_cvtsi128_si64(check2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2 || n == 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    __m128i limit = _mm_set1_epi64x((long long)sqrt(n));\n    __m128i num = _mm_set1_epi64x(n);\n    __m128i two = _mm_set1_epi64x(2);\n    __m128i six = _mm_set1_epi64x(6);\n    __m128i increment = _mm_set1_epi64x(1);\n\n    for (__m128i i = _mm_set1_epi64x(5); \n         _mm_cvtsi128_si64(i) <= _mm_cvtsi128_si64(limit); \n         i = _mm_add_epi64(i, six)) {\n        \n        __m128i check1 = _mm_add_epi64(i, two);\n        __m128i check2 = _mm_sub_epi64(i, two);\n\n        if (n % _mm_cvtsi128_si64(check1) == 0 || \n            n % _mm_cvtsi128_si64(check2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // If no letters, simply reverse the string\n    bool hasLetter = false;\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string in 16-byte chunks using SSE2\n    int vectorLen = len - (len % 16);\n    for (int i = 0; i < vectorLen; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Lowercase to uppercase conversion mask\n        __m128i lowerToUpperMask = _mm_set1_epi8(0xDF);\n        \n        // Uppercase to lowercase conversion\n        __m128i upperToLowerMask = _mm_set1_epi8(0x20);\n        \n        // Detect lowercase letters\n        __m128i isLowerMask = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_set1_epi8('a' - 1)),\n            _mm_cmpgt_epi8(_mm_set1_epi8('z' + 1), chars)\n        );\n        \n        // Detect uppercase letters\n        __m128i isUpperMask = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_set1_epi8('A' - 1)),\n            _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), chars)\n        );\n        \n        // Convert lowercase to uppercase\n        __m128i lowToUpper = _mm_and_si128(_mm_and_si128(isLowerMask, lowerToUpperMask), chars);\n        \n        // Convert uppercase to lowercase\n        __m128i upToLower = _mm_and_si128(_mm_and_si128(isUpperMask, upperToLowerMask), chars);\n        \n        // Combine converted characters\n        __m128i convertedChars = _mm_or_si128(\n            _mm_andnot_si128(isLowerMask, \n                _mm_andnot_si128(isUpperMask, chars)\n            ),\n            _mm_or_si128(lowToUpper, upToLower)\n        );\n        \n        // Store converted characters back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), convertedChars);\n    }\n    \n    // Process remaining characters\n    for (int i = vectorLen; i < len; ++i) {\n        char c = s[i];\n        if (c >= 'a' && c <= 'z') {\n            result[i] = c - 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            result[i] = c + 32;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // If no letters, just reverse the string\n    bool hasLetter = false;\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string using SSE2 intrinsics\n    for (int i = 0; i < len; i += 16) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Lowercase to uppercase conversion mask\n        __m128i lower_mask = _mm_set1_epi8('a');\n        __m128i upper_mask = _mm_set1_epi8('z');\n        __m128i lower_to_upper_offset = _mm_set1_epi8('A' - 'a');\n        \n        // Uppercase to lowercase conversion mask\n        __m128i upper_case_lower_mask = _mm_set1_epi8('A');\n        __m128i upper_case_upper_mask = _mm_set1_epi8('Z');\n        __m128i upper_to_lower_offset = _mm_set1_epi8('a' - 'A');\n        \n        // Check for lowercase letters\n        __m128i is_lower = _mm_and_si128(\n            _mm_cmpgt_epi8(chunk, _mm_sub_epi8(lower_mask, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(upper_mask, chunk), _mm_set1_epi8(-1))\n        );\n        \n        // Check for uppercase letters\n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chunk, _mm_sub_epi8(upper_case_lower_mask, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(upper_case_upper_mask, chunk), _mm_set1_epi8(-1))\n        );\n        \n        // Convert lowercase to uppercase\n        __m128i lower_to_upper = _mm_and_si128(is_lower, lower_to_upper_offset);\n        __m128i uppercase_chunk = _mm_add_epi8(chunk, lower_to_upper);\n        \n        // Convert uppercase to lowercase\n        __m128i upper_to_lower = _mm_and_si128(is_upper, upper_to_lower_offset);\n        __m128i lowercase_chunk = _mm_sub_epi8(chunk, upper_to_lower);\n        \n        // Combine results\n        __m128i case_converted = _mm_or_si128(\n            _mm_andnot_si128(is_lower, _mm_andnot_si128(is_upper, chunk)),\n            _mm_or_si128(uppercase_chunk, lowercase_chunk)\n        );\n        \n        // Store back to result\n        int remaining = std::min(16, len - i);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), case_converted);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // If no letters, simply reverse the string\n    bool hasLetter = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process 16 characters at a time using SSE2\n    int vectorLen = len - (len % 16);\n    for (int i = 0; i < vectorLen; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Separate lowercase and uppercase letters\n        __m128i lower = _mm_set1_epi8('a');\n        __m128i upper = _mm_set1_epi8('A');\n        __m128i lowerLimit = _mm_set1_epi8('z');\n        __m128i upperLimit = _mm_set1_epi8('Z');\n        \n        // Check for lowercase letters\n        __m128i isLowerMask = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_sub_epi8(lower, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(lowerLimit, chars), _mm_set1_epi8(-1))\n        );\n        \n        // Check for uppercase letters\n        __m128i isUpperMask = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_sub_epi8(upper, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(upperLimit, chars), _mm_set1_epi8(-1))\n        );\n        \n        // Swap case for letters\n        __m128i caseDiff = _mm_set1_epi8(32);\n        __m128i swappedChars = _mm_xor_si128(chars, _mm_and_si128(caseDiff, _mm_or_si128(isLowerMask, isUpperMask)));\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), swappedChars);\n    }\n    \n    // Process remaining characters\n    for (int i = vectorLen; i < len; ++i) {\n        if (std::islower(s[i])) {\n            result[i] = std::toupper(s[i]);\n        } else if (std::isupper(s[i])) {\n            result[i] = std::tolower(s[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // Check if string has no letters\n    bool hasLetters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            hasLetters = true;\n            break;\n        }\n    }\n    \n    if (!hasLetters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process 16 bytes at a time using SSE2\n    int vectorLen = len - (len % 16);\n    __m128i* vec = (__m128i*)result.data();\n    \n    for (int i = 0; i < vectorLen; i += 16) {\n        __m128i chars = _mm_loadu_si128(vec);\n        \n        // Uppercase check\n        __m128i upperMask = _mm_set1_epi8(0xDF);\n        __m128i upperChars = _mm_and_si128(chars, upperMask);\n        __m128i isUpperA = _mm_cmpeq_epi8(upperChars, _mm_set1_epi8('A'));\n        __m128i isUpperZ = _mm_cmpeq_epi8(upperChars, _mm_set1_epi8('Z'));\n        \n        // Lowercase check\n        __m128i lowerMask = _mm_set1_epi8(0xDF);\n        __m128i lowerChars = _mm_and_si128(chars, lowerMask);\n        __m128i isLowerA = _mm_cmpeq_epi8(lowerChars, _mm_set1_epi8('a'));\n        __m128i isLowerZ = _mm_cmpeq_epi8(lowerChars, _mm_set1_epi8('z'));\n        \n        // Combine uppercase and lowercase masks\n        __m128i isAlphaMask = _mm_or_si128(\n            _mm_and_si128(isUpperA, isUpperZ),\n            _mm_and_si128(isLowerA, isLowerZ)\n        );\n        \n        // Flip case for alphabetic characters\n        __m128i caseFlipMask = _mm_set1_epi8(0x20);\n        __m128i flippedChars = _mm_xor_si128(chars, _mm_and_si128(caseFlipMask, isAlphaMask));\n        \n        _mm_storeu_si128(vec, flippedChars);\n        vec++;\n    }\n    \n    // Process remaining characters\n    for (int i = vectorLen; i < len; i++) {\n        if (std::isalpha(result[i])) {\n            result[i] = std::isupper(result[i]) ? std::tolower(result[i]) : std::toupper(result[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // If no letters, simply reverse the string\n    bool hasLetter = false;\n    for (char c : s) {\n        if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n            hasLetter = true;\n            break;\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n    \n    // Process string using SSE2 intrinsics\n    int simdLen = len - (len % 16);\n    \n    for (int i = 0; i < simdLen; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&result[i]);\n        \n        // Lowercase to uppercase conversion mask\n        __m128i lowerToUpper = _mm_set1_epi8(0xDF);\n        \n        // Create masks for lowercase and uppercase letters\n        __m128i lowerMask = _mm_set1_epi8('a');\n        __m128i upperMask = _mm_set1_epi8('z');\n        __m128i lowerUpperMask = _mm_set1_epi8('A');\n        __m128i upperUpperMask = _mm_set1_epi8('Z');\n        \n        // Check for lowercase letters\n        __m128i isLowerMask = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_sub_epi8(lowerMask, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(upperMask, chars), _mm_set1_epi8(-1))\n        );\n        \n        // Check for uppercase letters\n        __m128i isUpperMask = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_sub_epi8(lowerUpperMask, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(upperUpperMask, chars), _mm_set1_epi8(-1))\n        );\n        \n        // Swap case for letters\n        __m128i swappedChars = _mm_xor_si128(chars, _mm_and_si128(isLowerMask, lowerToUpper));\n        swappedChars = _mm_xor_si128(swappedChars, _mm_and_si128(isUpperMask, lowerToUpper));\n        \n        _mm_storeu_si128((__m128i*)&result[i], swappedChars);\n    }\n    \n    // Process remaining characters\n    for (int i = simdLen; i < len; ++i) {\n        if (result[i] >= 'a' && result[i] <= 'z') {\n            result[i] = result[i] - 'a' + 'A';\n        } else if (result[i] >= 'A' && result[i] <= 'Z') {\n            result[i] = result[i] - 'A' + 'a';\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 3) {\n        std::sort(l.begin(), l.end(), [](int a, int b) { return a < b; });\n        return l;\n    }\n\n    std::vector<int> result(l);\n    std::vector<int> to_sort;\n\n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Replace elements at indices divisible by 3 with sorted values\n    int sort_idx = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = to_sort[sort_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector size is less than 3, return original vector\n    if (n < 3) return l;\n    \n    // Create a copy of the input vector\n    std::vector<int> result = l;\n    \n    // Find the number of complete sets of 3 elements\n    int num_sets = n / 3;\n    \n    for (int set = 0; set < num_sets; set++) {\n        int base_idx = set * 3;\n        \n        // Load 3 elements into SSE register\n        __m128i elements = _mm_setr_epi32(l[base_idx], l[base_idx+1], l[base_idx+2], 0);\n        \n        // Sort the 3 elements using SSE comparisons\n        __m128i sorted = _mm_setr_epi32(\n            std::min({l[base_idx], l[base_idx+1], l[base_idx+2]}),\n            std::min({std::max(l[base_idx], l[base_idx+1]), l[base_idx+2]}),\n            std::max({l[base_idx], l[base_idx+1], l[base_idx+2]}),\n            0\n        );\n        \n        // Store sorted elements back into result vector\n        result[base_idx] = _mm_cvtsi128_si32(sorted);\n        result[base_idx+1] = _mm_cvtsi128_si32(_mm_shuffle_epi32(sorted, _MM_SHUFFLE(1,1,1,1)));\n        result[base_idx+2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(sorted, _MM_SHUFFLE(2,2,2,2)));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 3) {\n        std::sort(l.begin(), l.end(), [](int a, int b) { return a < b; });\n        return l;\n    }\n\n    std::vector<int> result(l);\n    std::vector<int> to_sort;\n\n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements using SSE2 sorting\n    int sort_size = to_sort.size();\n    for (int i = 0; i < sort_size - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&to_sort[i]);\n        \n        // Perform bitonic sort for 4 elements\n        __m128i swap1 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128i min1 = _mm_min_epi32(vec, swap1);\n        __m128i max1 = _mm_max_epi32(vec, swap1);\n        \n        __m128i swap2 = _mm_shuffle_epi32(min1, _MM_SHUFFLE(0, 1, 2, 3));\n        __m128i min2 = _mm_min_epi32(min1, swap2);\n        __m128i max2 = _mm_max_epi32(min1, swap2);\n        \n        __m128i swap3 = _mm_shuffle_epi32(min2, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128i sorted = _mm_min_epi32(min2, swap3);\n        \n        _mm_storeu_si128((__m128i*)&to_sort[i], sorted);\n    }\n\n    // Handle remaining elements\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Replace elements at indices divisible by 3 with sorted values\n    int sort_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = to_sort[sort_index++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector size is less than 3, return original vector\n    if (n < 3) return l;\n    \n    // Create a copy of the input vector\n    std::vector<int> result = l;\n    \n    // Find the number of complete sets of 3 elements\n    int num_sets = n / 3;\n    \n    for (int set = 0; set < num_sets; set++) {\n        int base_idx = set * 3;\n        \n        // Load 3 elements into SSE register\n        __m128i vec = _mm_setr_epi32(l[base_idx], l[base_idx+1], l[base_idx+2], 0);\n        \n        // Sort these 3 elements using SSE comparisons\n        __m128i shuffled1 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(0, 1, 2, 3));\n        __m128i shuffled2 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(1, 2, 3, 0));\n        \n        __m128i mask = _mm_cmpgt_epi32(shuffled1, shuffled2);\n        __m128i min = _mm_min_epi32(shuffled1, shuffled2);\n        __m128i max = _mm_max_epi32(shuffled1, shuffled2);\n        \n        vec = _mm_blendv_epi8(min, max, mask);\n        \n        // Store sorted elements back\n        result[base_idx] = _mm_cvtsi128_si32(vec);\n        result[base_idx+1] = _mm_cvtsi128_si32(_mm_shuffle_epi32(vec, 1));\n        result[base_idx+2] = _mm_cvtsi128_si32(_mm_shuffle_epi32(vec, 2));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n <= 3) {\n        std::sort(l.begin(), l.end(), [](int a, int b) { return a < b; });\n        return l;\n    }\n\n    std::vector<int> result(l);\n    std::vector<int> to_sort;\n\n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        to_sort.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(to_sort.begin(), to_sort.end());\n\n    // Replace elements at indices divisible by 3 with sorted values\n    int sort_idx = 0;\n    for (int i = 0; i < n; i += 3) {\n        result[i] = to_sort[sort_idx++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    int simd_width = 4; // SSE processes 4 floats at a time\n    \n    // Handle small vectors with scalar approach\n    if (n <= simd_width) {\n        return *std::max_element(l.begin(), l.end());\n    }\n    \n    // Align to SIMD boundary\n    int i = 0;\n    __m128 max_vec = _mm_set1_ps(l[0]);\n    \n    // Process 4 elements at a time\n    for (; i + simd_width <= n; i += simd_width) {\n        __m128 current_vec = _mm_loadu_ps(&l[i]);\n        max_vec = _mm_max_ps(max_vec, current_vec);\n    }\n    \n    // Horizontal max within the SIMD register\n    __m128 shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    max_vec = _mm_max_ps(max_vec, shuffle1);\n    __m128 shuffle2 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    max_vec = _mm_max_ps(max_vec, shuffle2);\n    \n    float max_val = _mm_cvtss_f32(max_vec);\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    int simd_width = 4; // SSE processes 4 floats at a time\n    \n    // Handle case where vector size is less than SIMD width\n    if (n < simd_width) {\n        return *std::max_element(l.begin(), l.end());\n    }\n    \n    // Initialize max vector with first 4 elements\n    __m128 max_vec = _mm_loadu_ps(&l[0]);\n    \n    // Process 4 elements at a time\n    for (int i = simd_width; i <= n - simd_width; i += simd_width) {\n        __m128 current_vec = _mm_loadu_ps(&l[i]);\n        max_vec = _mm_max_ps(max_vec, current_vec);\n    }\n    \n    // Horizontal max within the SIMD register\n    __m128 max_shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    max_vec = _mm_max_ps(max_vec, max_shuffle1);\n    \n    __m128 max_shuffle2 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    max_vec = _mm_max_ps(max_vec, max_shuffle2);\n    \n    // Extract max value\n    float max_val = _mm_cvtss_f32(max_vec);\n    \n    // Handle remaining elements\n    for (int i = n - (n % simd_width); i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        __m128 max_vec = _mm_max_ps(_mm_set1_ps(max_val), vec);\n        max_val = _mm_cvtss_f32(max_vec);\n    }\n\n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    int simd_width = 4; // SSE processes 4 floats at a time\n    \n    // Handle case where vector is smaller than SIMD width\n    if (n < simd_width) {\n        return *std::max_element(l.begin(), l.end());\n    }\n    \n    // Initialize max vector with first 4 elements\n    __m128 max_vec = _mm_loadu_ps(&l[0]);\n    \n    // Process vector in chunks of 4\n    for (int i = simd_width; i <= n - simd_width; i += simd_width) {\n        __m128 current_vec = _mm_loadu_ps(&l[i]);\n        max_vec = _mm_max_ps(max_vec, current_vec);\n    }\n    \n    // Horizontal max within the SIMD register\n    __m128 max_shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    max_vec = _mm_max_ps(max_vec, max_shuffle1);\n    \n    __m128 max_shuffle2 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    max_vec = _mm_max_ps(max_vec, max_shuffle2);\n    \n    // Extract max value\n    float max_val = _mm_cvtss_f32(max_vec);\n    \n    // Handle remaining elements\n    for (int i = n - (n % simd_width); i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    int simd_width = 4; // SSE processes 4 floats at a time\n    \n    // Handle small vectors with direct comparison\n    if (n <= simd_width) {\n        return *std::max_element(l.begin(), l.end());\n    }\n    \n    // Align the start of processing to 4-float boundary\n    int i = 0;\n    __m128 max_vec = _mm_set1_ps(l[0]);\n    \n    // Process 4 floats at a time using SSE\n    for (; i + simd_width <= n; i += simd_width) {\n        __m128 current_vec = _mm_loadu_ps(&l[i]);\n        max_vec = _mm_max_ps(max_vec, current_vec);\n    }\n    \n    // Horizontal max within the SIMD register\n    __m128 shuffle1 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    max_vec = _mm_max_ps(max_vec, shuffle1);\n    __m128 shuffle2 = _mm_shuffle_ps(max_vec, max_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    max_vec = _mm_max_ps(max_vec, shuffle2);\n    \n    float max_val = _mm_cvtss_f32(max_vec);\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec_nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        // Check divisibility by 11 or 13\n        __m128i div_11 = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_set1_epi32(0));\n        __m128i div_13 = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_set1_epi32(0));\n        \n        for (int j = 0; j < 4; j++) {\n            int curr = _mm_cvtsi128_si32(vec_nums);\n            if (curr < n) {\n                if (curr % 11 == 0 || curr % 13 == 0) {\n                    // Count occurrences of 7\n                    int temp = curr;\n                    while (temp > 0) {\n                        if (temp % 10 == 7) count++;\n                        temp /= 10;\n                    }\n                }\n            }\n            vec_nums = _mm_srli_si128(vec_nums, 4);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 4 numbers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        // Check divisibility by 11 or 13\n        __m128i div11 = _mm_cmpeq_epi32(_mm_setzero_si128(), \n            _mm_set_epi32(\n                (i+3) % 11 == 0 || (i+3) % 13 == 0,\n                (i+2) % 11 == 0 || (i+2) % 13 == 0,\n                (i+1) % 11 == 0 || (i+1) % 13 == 0,\n                i % 11 == 0 || i % 13 == 0\n            )\n        );\n        \n        // Check for digit 7\n        __m128i has_seven = _mm_set_epi32(\n            (i+3 % 10 == 7) || ((i+3 / 10) % 10 == 7) || (i+3 / 100 % 10 == 7),\n            (i+2 % 10 == 7) || ((i+2 / 10) % 10 == 7) || (i+2 / 100 % 10 == 7),\n            (i+1 % 10 == 7) || ((i+1 / 10) % 10 == 7) || (i+1 / 100 % 10 == 7),\n            (i % 10 == 7) || ((i / 10) % 10 == 7) || (i / 100 % 10 == 7)\n        );\n        \n        // Combine conditions\n        __m128i result = _mm_and_si128(div11, has_seven);\n        \n        // Sum the results\n        count += _mm_cvtsi128_si32(result) +\n                 _mm_cvtsi128_si32(_mm_shuffle_epi32(result, 1)) +\n                 _mm_cvtsi128_si32(_mm_shuffle_epi32(result, 2)) +\n                 _mm_cvtsi128_si32(_mm_shuffle_epi32(result, 3));\n    }\n    \n    // Handle remaining numbers\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && \n            ((i % 10 == 7) || ((i / 10) % 10 == 7) || (i / 100 % 10 == 7))) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec_nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        // Check divisibility by 11 or 13\n        __m128i div_11 = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_set1_epi32(0));\n        __m128i div_13 = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_set1_epi32(0));\n        \n        for (int j = 0; j < 4; j++) {\n            int num = _mm_cvtsi128_si32(_mm_srli_si128(vec_nums, j * 4));\n            if (num < n) {\n                if (num % 11 == 0 || num % 13 == 0) {\n                    // Count occurrences of 7\n                    while (num > 0) {\n                        if (num % 10 == 7) count++;\n                        num /= 10;\n                    }\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    \n    // Process 4 numbers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div11 = _mm_set1_epi32(11);\n        __m128i div13 = _mm_set1_epi32(13);\n        \n        // Check divisibility by 11 or 13\n        __m128i mod11 = _mm_rem_epi32(nums, div11);\n        __m128i mod13 = _mm_rem_epi32(nums, div13);\n        __m128i divisible = _mm_or_si128(_mm_cmpeq_epi32(mod11, _mm_setzero_si128()),\n                                         _mm_cmpeq_epi32(mod13, _mm_setzero_si128()));\n        \n        // Count 7s in divisible numbers\n        for (int j = 0; j < 4; j++) {\n            if (_mm_movemask_epi8(divisible) & (1 << (j * 4))) {\n                int num = i + j;\n                while (num > 0) {\n                    if (num % 10 == 7) count++;\n                    num /= 10;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven_vec = _mm_set1_epi32(7);\n    __m128i eleven_vec = _mm_set1_epi32(11);\n    __m128i thirteen_vec = _mm_set1_epi32(13);\n    __m128i zero_vec = _mm_setzero_si128();\n\n    for (int i = 0; i < n; i += 4) {\n        __m128i current_vec = _mm_set_epi32(\n            i + 3, \n            i + 2, \n            i + 1, \n            i\n        );\n\n        __m128i div_eleven = _mm_cmpeq_epi32(_mm_setzero_si128(), \n            _mm_or_si128(\n                _mm_srli_epi32(_mm_mullo_epi32(current_vec, _mm_set1_epi32(10)), 1),\n                _mm_srli_epi32(_mm_mullo_epi32(current_vec, _mm_set1_epi32(10)), 3)\n            )\n        );\n\n        __m128i div_thirteen = _mm_cmpeq_epi32(_mm_setzero_si128(), \n            _mm_or_si128(\n                _mm_srli_epi32(_mm_mullo_epi32(current_vec, _mm_set1_epi32(10)), 2),\n                _mm_srli_epi32(_mm_mullo_epi32(current_vec, _mm_set1_epi32(10)), 3)\n            )\n        );\n\n        __m128i divisible = _mm_or_si128(div_eleven, div_thirteen);\n\n        __m128i has_seven = _mm_cmpeq_epi32(\n            _mm_and_si128(_mm_srli_epi32(current_vec, 1), _mm_set1_epi32(7)),\n            seven_vec\n        );\n\n        __m128i result = _mm_and_si128(divisible, has_seven);\n        \n        int mask = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask) / 4;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 1) return l;\n\n    // Ensure vector size is even\n    if (n % 2 != 0) l.push_back(0.0f);\n    n = l.size();\n\n    // Process 4 floats at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load even indices values\n        __m128 even_vals = _mm_setr_ps(l[i], l[i+2], 0, 0);\n        \n        // Sort even indices values\n        __m128 sorted = _mm_shuffle_ps(even_vals, even_vals, _MM_SHUFFLE(1, 0, 1, 0));\n        sorted = _mm_min_ps(sorted, _mm_shuffle_ps(sorted, sorted, _MM_SHUFFLE(1, 0, 3, 2)));\n\n        // Store sorted values back to even indices\n        l[i] = _mm_cvtss_f32(sorted);\n        l[i+2] = _mm_cvtss_f32(_mm_shuffle_ps(sorted, sorted, 1));\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 1) return l;\n\n    // Ensure vector size is even for SIMD processing\n    if (n % 2 != 0) l.push_back(0.0f);\n    n = l.size();\n\n    std::vector<float> result(l);\n\n    // Process 4 floats at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load even indices values\n        __m128 even_vals = _mm_setr_ps(\n            l[i], l[i+2], \n            (i+4 < n) ? l[i+4] : 0.0f, \n            (i+6 < n) ? l[i+6] : 0.0f\n        );\n\n        // Sort even indices values\n        __m128 sorted = _mm_shuffle_ps(even_vals, even_vals, _MM_SHUFFLE(1, 0, 3, 2));\n        sorted = _mm_min_ps(sorted, _mm_shuffle_ps(sorted, sorted, _MM_SHUFFLE(1, 0, 3, 2)));\n\n        // Store sorted even indices back\n        _mm_storeu_ps(&result[i], \n            _mm_blend_ps(\n                _mm_setr_ps(l[i], l[i+1], l[i+2], l[i+3]), \n                sorted, \n                0b1010\n            )\n        );\n    }\n\n    // Remove extra element if original vector was odd-sized\n    if (l.size() != result.size()) result.pop_back();\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 1) return l;\n\n    // Pad vector to multiple of 4 if needed\n    while (n % 4 != 0) {\n        l.push_back(std::numeric_limits<float>::max());\n        n++;\n    }\n\n    std::vector<float> result(n);\n    \n    // Copy odd indices directly\n    for (int i = 1; i < n; i += 2) {\n        result[i] = l[i];\n    }\n\n    // Process even indices in parallel using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128 vec = _mm_loadu_ps(&l[i]);\n        \n        // Shuffle to extract even indices\n        __m128 even_indices = _mm_shuffle_ps(vec, vec, _MM_SHUFFLE(2, 0, 2, 0));\n        \n        // Sort the even indices\n        __m128 sorted = _mm_min_ps(\n            _mm_shuffle_ps(even_indices, even_indices, _MM_SHUFFLE(1, 0, 3, 2)),\n            even_indices\n        );\n        sorted = _mm_min_ps(\n            _mm_shuffle_ps(sorted, sorted, _MM_SHUFFLE(0, 3, 2, 1)),\n            sorted\n        );\n        \n        // Store back to even indices of result\n        _mm_storeu_ps(&result[i], \n            _mm_blend_ps(vec, sorted, 0b0101)\n        );\n    }\n\n    // Remove any padding\n    while (!result.empty() && result.back() == std::numeric_limits<float>::max()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 1) return l;\n\n    // Ensure we have a multiple of 4 elements\n    while (n % 4 != 0) {\n        l.push_back(std::numeric_limits<float>::max());\n        n++;\n    }\n\n    std::vector<float> result(n);\n    \n    // Copy odd indices directly\n    for (int i = 1; i < n; i += 2) {\n        result[i] = l[i];\n    }\n\n    // Process even indices in parallel using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load 4 even indices\n        __m128 even_vec = _mm_setr_ps(l[i], l[i+2], l[i+4], l[i+6]);\n        \n        // Perform bitonic sort for 4 elements\n        __m128 swap1 = _mm_shuffle_ps(even_vec, even_vec, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128 min1 = _mm_min_ps(even_vec, swap1);\n        __m128 max1 = _mm_max_ps(even_vec, swap1);\n        \n        __m128 swap2 = _mm_shuffle_ps(min1, max1, _MM_SHUFFLE(1, 0, 3, 2));\n        __m128 min2 = _mm_min_ps(swap2, max1);\n        __m128 max2 = _mm_max_ps(swap2, max1);\n        \n        __m128 sorted = _mm_shuffle_ps(min2, max2, _MM_SHUFFLE(1, 0, 3, 2));\n        \n        // Store sorted even indices\n        _mm_storeu_ps(&result[i], sorted);\n    }\n\n    // Remove any extra elements added for padding\n    while (!result.empty() && result.back() == std::numeric_limits<float>::max()) {\n        result.pop_back();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n <= 1) return l;\n\n    // Ensure vector size is even\n    if (n % 2 != 0) l.push_back(0.0f);\n    n = l.size();\n\n    // Create a copy of the original vector\n    std::vector<float> result = l;\n\n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load even indices values\n        __m128 even_vals = _mm_setr_ps(l[i], l[i+2], 0, 0);\n\n        // Sort even indices values\n        __m128 sorted = _mm_shuffle_ps(even_vals, even_vals, _MM_SHUFFLE(1, 0, 1, 0));\n        sorted = _mm_min_ps(sorted, _mm_shuffle_ps(sorted, sorted, _MM_SHUFFLE(1, 0, 3, 2)));\n\n        // Store sorted even indices back\n        result[i] = _mm_cvtss_f32(sorted);\n        result[i+2] = _mm_cvtss_f32(_mm_shuffle_ps(sorted, sorted, 1));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::sort(l.begin(), l.end());\n\n    // Use SSE2 for parallel comparisons\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            // Parallel comparison using SSE2\n            __m128i sum_vec = _mm_set1_epi32(sum);\n            __m128i zero_vec = _mm_setzero_si128();\n            __m128i cmp_result = _mm_cmpeq_epi32(sum_vec, zero_vec);\n\n            // Check if sum is zero\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::sort(l.begin(), l.end());\n\n    // Use SSE2 for parallel comparisons\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            // Use SSE2 comparison intrinsics\n            __m128i sum_vec = _mm_set1_epi32(sum);\n            __m128i zero_vec = _mm_setzero_si128();\n            __m128i cmp_result = _mm_cmpeq_epi32(sum_vec, zero_vec);\n\n            // Check if sum is zero\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first for efficient searching\n    std::sort(l.begin(), l.end());\n\n    // Use SSE2 for parallel comparisons\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        // Use SSE2 to load multiple values for parallel comparison\n        __m128i target_vec = _mm_set1_epi32(-l[i]);\n\n        while (left < right) {\n            __m128i left_vec = _mm_set1_epi32(l[left]);\n            __m128i right_vec = _mm_set1_epi32(l[right]);\n            __m128i sum_vec = _mm_add_epi32(left_vec, right_vec);\n\n            // Parallel comparison of sum with target\n            __m128i compare_vec = _mm_cmpeq_epi32(sum_vec, target_vec);\n            int mask = _mm_movemask_epi8(compare_vec);\n\n            if (mask) return true;\n\n            if (l[left] + l[right] < -l[i])\n                left++;\n            else if (l[left] + l[right] > -l[i])\n                right--;\n            else\n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first to enable efficient searching\n    std::sort(l.begin(), l.end());\n\n    // Use SSE2 intrinsics for parallel processing\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates to avoid repeated checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n\n        // Use two-pointer technique with SIMD-like parallel search\n        int left = i + 1;\n        int right = n - 1;\n\n        // Process 4 elements at a time using SSE2\n        while (left < right) {\n            __m128i a = _mm_set1_epi32(l[i]);\n            __m128i b = _mm_setr_epi32(l[left], l[right], 0, 0);\n            __m128i sum = _mm_add_epi32(a, b);\n            \n            int total = l[i] + l[left] + l[right];\n            \n            if (total == 0) return true;\n            else if (total < 0) left++;\n            else right--;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Sort the vector first\n    std::sort(l.begin(), l.end());\n\n    // Use SSE2 for parallel comparisons\n    for (int i = 0; i < n - 2; i++) {\n        int left = i + 1;\n        int right = n - 1;\n\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n\n            // Use SSE2 comparison intrinsics\n            __m128i sum_vec = _mm_set1_epi32(sum);\n            __m128i zero_vec = _mm_setzero_si128();\n            __m128i cmp_result = _mm_cmpeq_epi32(sum_vec, zero_vec);\n\n            // Check if sum is zero\n            if (sum == 0) return true;\n            else if (sum < 0) left++;\n            else right--;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vectorSize = n - (n % 4);\n\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i incremented = _mm_add_epi32(vec, _mm_set1_epi32(1));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&l[i]), incremented);\n    }\n\n    for (size_t i = vectorSize; i < n; ++i) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // Align to 4-element chunks for SIMD processing\n    int simd_size = n - (n % 4);\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i one = _mm_set1_epi32(1);\n        __m128i result = _mm_add_epi32(vec, one);\n        _mm_storeu_si128((__m128i*)&l[i], result);\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_size; i < n; i++) {\n        l[i]++;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int simd_size = size - (size % 4);\n\n    for (int i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i one = _mm_set1_epi32(1);\n        __m128i result = _mm_add_epi32(vec, one);\n        _mm_storeu_si128((__m128i*)&l[i], result);\n    }\n\n    for (int i = simd_size; i < size; i++) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> result(n);\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i one = _mm_set1_epi32(1);\n        __m128i incremented = _mm_add_epi32(vec, one);\n        _mm_storeu_si128((__m128i*)&result[i], incremented);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t vectorSize = n - (n % 4);\n\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i incremented = _mm_add_epi32(vec, _mm_set1_epi32(1));\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&l[i]), incremented);\n    }\n\n    for (size_t i = vectorSize; i < n; ++i) {\n        l[i]++;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector has less than 2 elements, return false\n    if (n < 2) return false;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            __m128i target = _mm_set1_epi32(-l[j]);\n            __m128i comparison = _mm_cmpeq_epi32(current, target);\n            \n            if (_mm_movemask_epi8(comparison) != 0) {\n                return true;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector has less than 2 elements, return false\n    if (n < 2) return false;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&l[i]);\n        \n        for (int j = i + 4; j < n; j++) {\n            __m128i target = _mm_set1_epi32(-l[j]);\n            __m128i comparison = _mm_cmpeq_epi32(current, target);\n            \n            if (_mm_movemask_epi8(comparison) != 0) {\n                return true;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&l[i]);\n        \n        for (int j = i + 4; j < n; j += 4) {\n            __m128i target = _mm_loadu_si128((__m128i*)&l[j]);\n            __m128i negated = _mm_sub_epi32(_mm_setzero_si128(), target);\n            \n            __m128i comparison = _mm_cmpeq_epi32(current, negated);\n            int mask = _mm_movemask_epi8(comparison);\n            \n            if (mask != 0) return true;\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector is too small, return false\n    if (n < 2) return false;\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n - 1; i++) {\n        __m128i current = _mm_set1_epi32(l[i]);\n        \n        // Process next 4 elements in parallel\n        for (int j = i + 1; j < n; j += 4) {\n            // Load next 4 elements\n            __m128i others = _mm_loadu_si128((__m128i*)&l[j]);\n            \n            // Negate current to find matching pair\n            __m128i negated = _mm_sub_epi32(_mm_setzero_si128(), current);\n            \n            // Compare if any element matches the negation\n            __m128i comparison = _mm_cmpeq_epi32(others, negated);\n            \n            // Check if any comparison is true\n            if (_mm_movemask_epi8(comparison) != 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector is too small, return false\n    if (n < 2) return false;\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n - 1; i++) {\n        __m128i current = _mm_set1_epi32(l[i]);\n        \n        // Process next 4 elements in parallel\n        for (int j = i + 1; j < n; j += 4) {\n            // Load next 4 elements\n            __m128i others = _mm_loadu_si128((__m128i*)&l[j]);\n            \n            // Negate current element\n            __m128i negated = _mm_sub_epi32(_mm_setzero_si128(), current);\n            \n            // Compare if any element matches the negation\n            __m128i compare = _mm_cmpeq_epi32(others, negated);\n            \n            // Check if any comparison is true\n            if (_mm_movemask_epi8(compare) != 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    char result[64];\n    int idx = 63;\n    result[idx] = '\\0';\n    \n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi64x(base);\n    __m128i zero_vec = _mm_setzero_si128();\n    \n    while (_mm_cvtsi128_si32(x_vec) != 0) {\n        __m128i remainder = _mm_rem_epi64(x_vec, base_vec);\n        int rem = _mm_cvtsi128_si32(remainder);\n        \n        result[--idx] = '0' + rem;\n        x_vec = _mm_div_epi64(x_vec, base_vec);\n    }\n    \n    return std::string(result + idx);\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    char result[65] = {0};  // Max 64 bits + null terminator\n    int index = 64;\n    result[index] = '\\0';\n    \n    // Use SSE2 to parallelize division and remainder operations\n    __m128i dividend = _mm_set1_epi64x(x);\n    __m128i divisor = _mm_set1_epi64x(base);\n    \n    while (x > 0) {\n        index--;\n        int remainder = x % base;\n        result[index] = remainder + '0';\n        x /= base;\n    }\n    \n    return std::string(result + index);\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    char result[64];\n    int index = 63;\n    result[index] = '\\0';\n    \n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi64x(base);\n    __m128i zero_vec = _mm_setzero_si128();\n    \n    while (_mm_cvtsi128_si32(x_vec) != 0) {\n        __m128i remainder = _mm_rem_epi64(x_vec, base_vec);\n        int rem = _mm_cvtsi128_si32(remainder);\n        result[--index] = '0' + rem;\n        x_vec = _mm_div_epi64(x_vec, base_vec);\n    }\n    \n    return std::string(result + index);\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    char result[64];\n    int idx = 63;\n    result[idx] = '\\0';\n    \n    __m128i x_vec = _mm_set1_epi64x(x);\n    __m128i base_vec = _mm_set1_epi64x(base);\n    __m128i zero_vec = _mm_setzero_si128();\n    \n    while (_mm_cvtsi128_si32(x_vec) != 0) {\n        __m128i remainder = _mm_rem_epi64(x_vec, base_vec);\n        char digit = _mm_cvtsi128_si32(remainder) + '0';\n        \n        result[--idx] = digit;\n        \n        x_vec = _mm_div_epi64(x_vec, base_vec);\n    }\n    \n    return std::string(result + idx);\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) return \"\";\n    \n    char result[65] = {0};  // Max 64 bits + null terminator\n    int idx = 64;\n    result[idx] = '\\0';\n    \n    // Use SSE2 to parallelize division and remainder operations\n    __m128i dividend = _mm_set1_epi64x(x);\n    __m128i divisor = _mm_set1_epi64x(base);\n    \n    while (x > 0) {\n        idx--;\n        int remainder = x % base;\n        result[idx] = '0' + remainder;\n        x /= base;\n    }\n    \n    return std::string(result + idx);\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_len = len / 16 * 16;\n    __m128i* vec_ptr = (__m128i*)text.data();\n\n    // Compare first and last 16-byte chunks in parallel\n    for (int i = 0; i < vec_len / 16 / 2; i++) {\n        __m128i first = _mm_loadu_si128(vec_ptr + i);\n        __m128i last = _mm_loadu_si128(vec_ptr + (len / 16 - 1 - i));\n        __m128i rev_last = _mm_shuffle_epi32(last, 0x1B);\n\n        if (_mm_movemask_epi8(_mm_cmpeq_epi8(first, rev_last)) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (int i = vec_len / 2; i < (len + 1) / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_len = len / 16 * 16;\n    __m128i* vec_ptr = (__m128i*)text.data();\n\n    // Compare first and last 16-byte chunks in parallel\n    for (int i = 0; i < vec_len / 16 / 2; i++) {\n        __m128i first = _mm_loadu_si128(vec_ptr + i);\n        __m128i last = _mm_loadu_si128(vec_ptr + (len / 16 - 1 - i));\n        __m128i rev_last = _mm_shuffle_epi32(last, _MM_SHUFFLE(0, 1, 2, 3));\n        rev_last = _mm_shufflehi_epi16(rev_last, _MM_SHUFFLE(0, 1, 2, 3));\n        rev_last = _mm_shufflelo_epi16(rev_last, _MM_SHUFFLE(0, 1, 2, 3));\n\n        __m128i cmp = _mm_cmpeq_epi8(first, rev_last);\n        if (_mm_movemask_epi8(cmp) != 0xFFFF) return false;\n    }\n\n    // Handle remaining characters\n    for (int i = vec_len; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_len = len / 16 * 16;\n    __m128i* vec_ptr = (__m128i*)text.data();\n\n    // Compare first and last 16-byte chunks\n    for (int i = 0; i < vec_len / 16 / 2; i++) {\n        __m128i first = _mm_loadu_si128(vec_ptr + i);\n        __m128i last = _mm_loadu_si128(vec_ptr + (len / 16 - 1 - i));\n        __m128i rev_last = _mm_shuffle_epi32(last, _MM_SHUFFLE(0, 1, 2, 3));\n        rev_last = _mm_shufflehi_epi16(rev_last, _MM_SHUFFLE(0, 1, 2, 3));\n        rev_last = _mm_shufflelo_epi16(rev_last, _MM_SHUFFLE(0, 1, 2, 3));\n\n        __m128i cmp = _mm_cmpeq_epi8(first, rev_last);\n        if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (int i = vec_len; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_len = len / 16 * 16;\n    __m128i* vec_ptr = (__m128i*)text.data();\n\n    // Compare first and last 16-byte chunks in parallel\n    for (int i = 0; i < vec_len / 16 / 2; i++) {\n        __m128i first = _mm_loadu_si128(vec_ptr + i);\n        __m128i last = _mm_loadu_si128(vec_ptr + (len / 16 - 1 - i));\n        __m128i rev_last = _mm_shuffle_epi8(last, _mm_setr_epi8(\n            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n        ));\n        \n        if (_mm_movemask_epi8(_mm_cmpeq_epi8(first, rev_last)) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (int i = vec_len; i < len / 2; i++) {\n        if (text[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    int vec_size = len / 16;\n    int remainder = len % 16;\n\n    // Process 16-byte chunks in parallel\n    for (int i = 0; i < vec_size; i++) {\n        __m128i left = _mm_loadu_si128((__m128i*)&text[i * 16]);\n        __m128i right = _mm_loadu_si128((__m128i*)&text[len - (i + 1) * 16]);\n        \n        // Reverse the right vector\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        right = _mm_shufflehi_epi16(right, _MM_SHUFFLE(0, 1, 2, 3));\n        right = _mm_shufflelo_epi16(right, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Compare bytes\n        __m128i cmp = _mm_cmpeq_epi8(left, right);\n        if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    // Handle remaining bytes\n    for (int i = 0; i < remainder; i++) {\n        if (text[vec_size * 16 + i] != text[len - 1 - vec_size * 16 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Subtract 5 from each character\n        __m128i shift = _mm_set1_epi8(-5);\n        __m128i shifted = _mm_add_epi8(chars, shift);\n        \n        // Wrap around for characters below 'a'\n        __m128i a = _mm_set1_epi8('a');\n        __m128i z = _mm_set1_epi8('z');\n        \n        __m128i below_a = _mm_cmplt_epi8(shifted, a);\n        __m128i wrapped = _mm_add_epi8(shifted, _mm_set1_epi8(26));\n        shifted = _mm_blendv_epi8(shifted, wrapped, below_a);\n        \n        // Store back to output string\n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2 intrinsics\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Subtract 5 from each character\n        __m128i sub_5 = _mm_set1_epi8(-5);\n        __m128i shifted = _mm_add_epi8(chars, sub_5);\n        \n        // Adjust characters that go below 'a'\n        __m128i a_val = _mm_set1_epi8('a');\n        __m128i z_val = _mm_set1_epi8('z');\n        \n        __m128i below_a = _mm_cmplt_epi8(shifted, a_val);\n        __m128i wrap_mask = _mm_and_si128(below_a, _mm_set1_epi8(26));\n        shifted = _mm_add_epi8(shifted, wrap_mask);\n        \n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int vectorized_len = len - (len % 16);\n    for (int i = 0; i < vectorized_len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Subtract 5 from each character\n        __m128i sub_5 = _mm_set1_epi8(-5);\n        __m128i shifted = _mm_add_epi8(chars, sub_5);\n        \n        // Wrap around for characters below 'a'\n        __m128i a_val = _mm_set1_epi8('a');\n        __m128i z_val = _mm_set1_epi8('z');\n        \n        __m128i below_a_mask = _mm_cmplt_epi8(shifted, a_val);\n        __m128i wrap_add = _mm_set1_epi8(26);\n        \n        shifted = _mm_add_epi8(shifted, _mm_and_si128(below_a_mask, wrap_add));\n        \n        // Store back to output string\n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (int i = vectorized_len; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Subtract 5 from each character\n        __m128i shift = _mm_set1_epi8(-5);\n        __m128i shifted = _mm_add_epi8(chars, shift);\n        \n        // Wrap around for characters below 'a'\n        __m128i a = _mm_set1_epi8('a');\n        __m128i z = _mm_set1_epi8('z');\n        \n        __m128i below_a = _mm_cmplt_epi8(shifted, a);\n        __m128i wrapped = _mm_add_epi8(shifted, _mm_set1_epi8(26));\n        shifted = _mm_blendv_epi8(shifted, wrapped, below_a);\n        \n        // Store back to output string\n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2 \n    int vectorLen = len - (len % 16);\n    for (int i = 0; i < vectorLen; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Subtract 5 from each character \n        __m128i shift = _mm_set1_epi8(5);\n        __m128i shifted = _mm_sub_epi8(chars, shift);\n        \n        // Adjust characters that go below 'a'\n        __m128i aChar = _mm_set1_epi8('a');\n        __m128i zChar = _mm_set1_epi8('z');\n        \n        __m128i belowA = _mm_cmplt_epi8(shifted, aChar);\n        __m128i wrapAround = _mm_and_si128(belowA, _mm_set1_epi8(26));\n        shifted = _mm_add_epi8(shifted, wrapAround);\n        \n        // Store back to output string\n        _mm_storeu_si128((__m128i*)&out[i], shifted);\n    }\n    \n    // Handle remaining characters sequentially\n    for (int i = vectorLen; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int vec_size = 4;  // SSE processes 4 integers at a time\n    \n    // Handle case where vector size is not multiple of 4\n    for (int i = (n / vec_size) * vec_size; i < n; ++i) {\n        if (l[i] >= t) return false;\n    }\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n - vec_size + 1; i += vec_size) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i threshold = _mm_set1_epi32(t);\n        __m128i comparison = _mm_cmpgt_epi32(vec, threshold);\n        \n        if (_mm_movemask_epi8(comparison) != 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int size = l.size();\n    int vector_size = size - (size % 4);\n\n    // Load threshold into SSE register\n    __m128i threshold = _mm_set1_epi32(t);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        // Load 4 integers at a time\n        __m128i current = _mm_loadu_si128((__m128i*)&l[i]);\n\n        // Compare if any element is greater than threshold\n        __m128i comparison = _mm_cmpgt_epi32(current, threshold);\n\n        // Check if any element is above threshold\n        if (_mm_movemask_epi8(comparison) != 0) {\n            return false;\n        }\n    }\n\n    // Check remaining elements\n    for (int i = vector_size; i < size; i++) {\n        if (l[i] > t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i threshold = _mm_set1_epi32(t);\n        \n        // Compare each integer with threshold\n        __m128i comparison = _mm_cmplt_epi32(vec, threshold);\n        \n        // Check if all elements are less than threshold\n        int mask = _mm_movemask_epi8(comparison);\n        \n        if (mask != 0xFFFF) {\n            return false;\n        }\n        \n        // Handle remaining elements if vector size is not multiple of 4\n        if (i + 4 >= n) {\n            for (int j = i + 4; j < n; j++) {\n                if (l[j] >= t) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) return true;\n\n    size_t vec_size = l.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128i threshold_vec = _mm_set1_epi32(t);\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i current_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i comparison = _mm_cmpgt_epi32(current_vec, threshold_vec);\n        \n        if (_mm_movemask_epi8(comparison) != 0) {\n            return false;\n        }\n    }\n\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        if (l[i] > t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int vec_size = 4; // SSE processes 4 integers at a time\n    \n    // Handle case where vector size is not multiple of 4\n    for (int i = (n / vec_size) * vec_size; i < n; ++i) {\n        if (l[i] >= t) return false;\n    }\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n - vec_size + 1; i += vec_size) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&l[i]));\n        __m128i threshold = _mm_set1_epi32(t);\n        __m128i comparison = _mm_cmpgt_epi32(vec, threshold);\n        \n        if (_mm_movemask_epi8(comparison) != 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    \n    // If empty string, return true\n    if (len == 0) return true;\n    \n    // Use SSE2 to process 16 characters at a time\n    __m128i open_count = _mm_setzero_si128();\n    __m128i close_count = _mm_setzero_si128();\n    \n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        // Load 16 characters\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Create masks for '<' and '>'\n        __m128i open_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        __m128i close_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        // Count open and close brackets\n        open_count = _mm_add_epi8(open_count, _mm_and_si128(open_mask, _mm_set1_epi8(1)));\n        close_count = _mm_add_epi8(close_count, _mm_and_si128(close_mask, _mm_set1_epi8(1)));\n    }\n    \n    // Horizontal sum of open and close counts\n    __m128i open_sum = _mm_sad_epu8(open_count, _mm_setzero_si128());\n    __m128i close_sum = _mm_sad_epu8(close_count, _mm_setzero_si128());\n    \n    int total_open = _mm_cvtsi128_si32(open_sum) + _mm_cvtsi128_si32(_mm_srli_si128(open_sum, 8));\n    int total_close = _mm_cvtsi128_si32(close_sum) + _mm_cvtsi128_si32(_mm_srli_si128(close_sum, 8));\n    \n    // Process remaining characters\n    for (; i < len; i++) {\n        if (brackets[i] == '<') total_open++;\n        else total_close++;\n    }\n    \n    // Track running balance\n    int balance = 0;\n    for (int j = 0; j < len; j++) {\n        if (brackets[j] == '<') balance++;\n        else balance--;\n        \n        // If balance becomes negative, invalid bracketing\n        if (balance < 0) return false;\n    }\n    \n    // Final check: total open and close brackets match, and balance is zero\n    return total_open == total_close && balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    \n    // If empty string, return true\n    if (len == 0) return true;\n    \n    // If odd length, impossible to match\n    if (len % 4 != 0) {\n        // Process remaining elements serially\n        int count = 0;\n        for (char c : brackets) {\n            if (c == '<') count++;\n            else count--;\n            \n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n    \n    // Use SSE2 to process 16 bytes at a time\n    __m128i zero = _mm_setzero_si128();\n    __m128i count_vec = _mm_setzero_si128();\n    \n    for (int i = 0; i < len; i += 16) {\n        // Load 16 bytes\n        __m128i current = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '<'\n        __m128i less_than = _mm_cmpeq_epi8(current, _mm_set1_epi8('<'));\n        \n        // Compare with '>'\n        __m128i greater_than = _mm_cmpeq_epi8(current, _mm_set1_epi8('>'));\n        \n        // Subtract '>' from '<'\n        __m128i diff = _mm_sub_epi8(less_than, greater_than);\n        \n        // Accumulate count\n        count_vec = _mm_add_epi8(count_vec, diff);\n        \n        // Check if count ever goes negative\n        __m128i negative_check = _mm_cmplt_epi8(count_vec, zero);\n        if (_mm_movemask_epi8(negative_check)) {\n            return false;\n        }\n    }\n    \n    // Horizontal sum of count\n    __m128i sum = _mm_sad_epu8(count_vec, zero);\n    int total_count = _mm_cvtsi128_si32(sum);\n    \n    return total_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n\n    // Align data to 16-byte boundary\n    __m128i balance = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i neg_ones = _mm_set1_epi32(-1);\n\n    // Process 16 characters at a time\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '<'\n        __m128i is_open = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        \n        // Compare with '>'\n        __m128i is_close = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        // Increment or decrement balance\n        __m128i delta = _mm_sub_epi8(_mm_and_si128(is_open, ones), \n                                     _mm_and_si128(is_close, ones));\n        \n        balance = _mm_add_epi8(balance, delta);\n    }\n\n    // Horizontal sum of balance\n    __m128i sum = _mm_sad_epu8(balance, _mm_setzero_si128());\n    int total_balance = _mm_cvtsi128_si32(sum);\n\n    // Process remaining characters\n    for (; i < len; i++) {\n        total_balance += (brackets[i] == '<') ? 1 : -1;\n    }\n\n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n\n    // Align data to 16-byte boundary\n    __m128i balance = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i neg_ones = _mm_set1_epi32(-1);\n\n    // Process 16 characters at a time\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '<'\n        __m128i is_open = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        \n        // Compare with '>'\n        __m128i is_close = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        // Add 1 for open, subtract 1 for close\n        __m128i delta = _mm_sub_epi8(_mm_blendv_epi8(neg_ones, ones, is_open), \n                                     _mm_blendv_epi8(neg_ones, ones, is_close));\n        \n        balance = _mm_add_epi8(balance, delta);\n    }\n\n    // Horizontal sum of balance\n    __m128i sum = _mm_sad_epu8(balance, _mm_setzero_si128());\n    int total_balance = _mm_cvtsi128_si32(sum) + _mm_cvtsi128_si32(_mm_srli_si128(sum, 8));\n\n    // Process remaining characters\n    for (; i < len; i++) {\n        total_balance += (brackets[i] == '<' ? 1 : -1);\n    }\n\n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n\n    // Align to 16-byte boundary\n    __m128i balance = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i neg_ones = _mm_set1_epi32(-1);\n\n    // Process 16 characters at a time\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Create masks for '<' and '>'\n        __m128i less_than = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        __m128i greater_than = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        // Accumulate balance\n        __m128i delta = _mm_sub_epi8(_mm_and_si128(less_than, ones), \n                                     _mm_and_si128(greater_than, ones));\n        balance = _mm_add_epi8(balance, delta);\n    }\n\n    // Horizontal sum of balance\n    __m128i sum = _mm_sad_epu8(balance, _mm_setzero_si128());\n    int total_balance = _mm_cvtsi128_si32(sum);\n\n    // Process remaining characters\n    for (; i < len; i++) {\n        total_balance += (brackets[i] == '<') ? 1 : -1;\n    }\n\n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using SSE2\n    int vectorized_length = n - (n % 16);\n    __m128i open_count = _mm_setzero_si128();\n    __m128i close_count = _mm_setzero_si128();\n    \n    for (int i = 0; i < vectorized_length; i += 16) {\n        // Load 16 characters\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '('\n        __m128i is_open = _mm_cmpeq_epi8(chars, _mm_set1_epi8('('));\n        \n        // Compare with ')'\n        __m128i is_close = _mm_cmpeq_epi8(chars, _mm_set1_epi8(')'));\n        \n        // Accumulate open and close counts\n        open_count = _mm_add_epi8(open_count, is_open);\n        close_count = _mm_add_epi8(close_count, is_close);\n    }\n    \n    // Horizontal sum of open and close counts\n    int open_total = _mm_extract_epi16(open_count, 0) +\n                     _mm_extract_epi16(open_count, 1) +\n                     _mm_extract_epi16(open_count, 2) +\n                     _mm_extract_epi16(open_count, 3) +\n                     _mm_extract_epi16(open_count, 4) +\n                     _mm_extract_epi16(open_count, 5) +\n                     _mm_extract_epi16(open_count, 6) +\n                     _mm_extract_epi16(open_count, 7);\n    \n    int close_total = _mm_extract_epi16(close_count, 0) +\n                      _mm_extract_epi16(close_count, 1) +\n                      _mm_extract_epi16(close_count, 2) +\n                      _mm_extract_epi16(close_count, 3) +\n                      _mm_extract_epi16(close_count, 4) +\n                      _mm_extract_epi16(close_count, 5) +\n                      _mm_extract_epi16(close_count, 6) +\n                      _mm_extract_epi16(close_count, 7);\n    \n    // Process remaining characters\n    int balance = 0;\n    for (int i = vectorized_length; i < n; i++) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        \n        if (balance < 0) return false;\n    }\n    \n    // Final check\n    return open_total == close_total && balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using SSE2\n    int vec_size = n - (n % 16);\n    __m128i balance = _mm_setzero_si128();\n    \n    for (int i = 0; i < vec_size; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '('\n        __m128i open_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('('));\n        \n        // Compare with ')'\n        __m128i close_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8(')'));\n        \n        // Subtract closing brackets, add opening brackets\n        balance = _mm_sub_epi8(balance, close_mask);\n        balance = _mm_add_epi8(balance, open_mask);\n        \n        // Check if balance becomes negative\n        __m128i zero = _mm_setzero_si128();\n        if (_mm_movemask_epi8(_mm_cmplt_epi8(balance, zero))) {\n            return false;\n        }\n    }\n    \n    // Horizontal sum of balance\n    int16_t balance_array[8];\n    _mm_storeu_si128((__m128i*)balance_array, balance);\n    \n    int total_balance = 0;\n    for (int i = 0; i < 8; i++) {\n        total_balance += balance_array[i];\n    }\n    \n    // Process remaining characters\n    for (int i = vec_size; i < n; i++) {\n        total_balance += (brackets[i] == '(') ? 1 : -1;\n        if (total_balance < 0) return false;\n    }\n    \n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using SSE2\n    int vectorized_length = n - (n % 16);\n    __m128i balance = _mm_setzero_si128();\n    \n    for (int i = 0; i < vectorized_length; i += 16) {\n        // Load 16 characters\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '('\n        __m128i is_open = _mm_cmpeq_epi8(chars, _mm_set1_epi8('('));\n        \n        // Compare with ')'\n        __m128i is_close = _mm_cmpeq_epi8(chars, _mm_set1_epi8(')'));\n        \n        // Subtract close from open to track balance\n        __m128i delta = _mm_sub_epi8(is_open, is_close);\n        \n        // Accumulate running balance\n        balance = _mm_add_epi8(balance, delta);\n    }\n    \n    // Horizontal sum of balance\n    __m128i sum = _mm_sad_epu8(balance, _mm_setzero_si128());\n    int total_balance = _mm_cvtsi128_si32(sum);\n    \n    // Process remaining characters\n    for (int i = vectorized_length; i < n; i++) {\n        total_balance += (brackets[i] == '(') ? 1 : -1;\n    }\n    \n    return total_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    \n    // Process 16 characters at a time using SSE2\n    int vec_size = 16;\n    int processed_length = n - (n % vec_size);\n    \n    __m128i open_count = _mm_setzero_si128();\n    __m128i close_count = _mm_setzero_si128();\n    \n    // Process 16-byte chunks\n    for (int i = 0; i < processed_length; i += vec_size) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&brackets[i]);\n        \n        // Compare with '('\n        __m128i is_open = _mm_cmpeq_epi8(chars, _mm_set1_epi8('('));\n        \n        // Compare with ')'\n        __m128i is_close = _mm_cmpeq_epi8(chars, _mm_set1_epi8(')'));\n        \n        // Accumulate open and close counts\n        open_count = _mm_add_epi8(open_count, is_open);\n        close_count = _mm_add_epi8(close_count, is_close);\n    }\n    \n    // Horizontal sum of open and close counts\n    int open_total = _mm_extract_epi16(open_count, 0) +\n                     _mm_extract_epi16(open_count, 1) +\n                     _mm_extract_epi16(open_count, 2) +\n                     _mm_extract_epi16(open_count, 3) +\n                     _mm_extract_epi16(open_count, 4) +\n                     _mm_extract_epi16(open_count, 5) +\n                     _mm_extract_epi16(open_count, 6) +\n                     _mm_extract_epi16(open_count, 7);\n    \n    int close_total = _mm_extract_epi16(close_count, 0) +\n                      _mm_extract_epi16(close_count, 1) +\n                      _mm_extract_epi16(close_count, 2) +\n                      _mm_extract_epi16(close_count, 3) +\n                      _mm_extract_epi16(close_count, 4) +\n                      _mm_extract_epi16(close_count, 5) +\n                      _mm_extract_epi16(close_count, 6) +\n                      _mm_extract_epi16(close_count, 7);\n    \n    // Process remaining characters\n    int balance = 0;\n    for (int i = processed_length; i < n; ++i) {\n        if (brackets[i] == '(') {\n            balance++;\n        } else {\n            balance--;\n        }\n        \n        if (balance < 0) return false;\n    }\n    \n    // Final check\n    return open_total == close_total && balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    \n    // Process 16 characters at a time using SSE2\n    int vector_size = 16;\n    int processed_length = n - (n % vector_size);\n    \n    __m128i open_count = _mm_setzero_si128();\n    __m128i close_count = _mm_setzero_si128();\n    \n    // Process 16-byte chunks\n    for (int i = 0; i < processed_length; i += vector_size) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&brackets[i]));\n        \n        // Create masks for open and close brackets\n        __m128i open_mask = _mm_cmpeq_epi8(chunk, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(chunk, _mm_set1_epi8(')'));\n        \n        // Count open and close brackets\n        open_count = _mm_add_epi8(open_count, _mm_and_si128(open_mask, _mm_set1_epi8(1)));\n        close_count = _mm_add_epi8(close_count, _mm_and_si128(close_mask, _mm_set1_epi8(1)));\n    }\n    \n    // Horizontal sum of open and close counts\n    int open_total = 0, close_total = 0;\n    int open_array[16], close_array[16];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(open_array), open_count);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(close_array), close_count);\n    \n    for (int i = 0; i < 16; i++) {\n        open_total += open_array[i];\n        close_total += close_array[i];\n    }\n    \n    // Process remaining characters\n    for (int i = processed_length; i < n; i++) {\n        if (brackets[i] == '(') open_total++;\n        else close_total++;\n    }\n    \n    // Check remaining characters\n    int running_balance = 0;\n    for (int i = 0; i < n; i++) {\n        if (brackets[i] == '(') running_balance++;\n        else running_balance--;\n        \n        if (running_balance < 0) return false;\n    }\n    \n    return running_balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n    \n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    \n    // Process 4 elements at a time using SSE\n    int vectorized_length = (n - 1) / 4 * 4;\n    \n    for (int i = 0; i < vectorized_length; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 multipliers = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);\n        \n        __m128 derivatives = _mm_mul_ps(coeffs, multipliers);\n        _mm_storeu_ps(&result[i], derivatives);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorized_length; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    int simd_size = 4;\n\n    // Process 4 elements at a time using SSE\n    for (int i = 0; i + simd_size <= n - 1; i += simd_size) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 multipliers = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);\n        __m128 derivatives = _mm_mul_ps(coeffs, multipliers);\n        _mm_storeu_ps(&result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (int i = ((n - 1) / simd_size) * simd_size; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n    \n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 4 <= n - 1; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i+1]);\n        __m128 multipliers = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);\n        __m128 derivatives = _mm_mul_ps(coeffs, multipliers);\n        _mm_storeu_ps(&result[i], derivatives);\n    }\n    \n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        result[i] = xs[i+1] * (i+1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n    \n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 4 <= n - 1; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i+1]);\n        __m128 multipliers = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);\n        __m128 derivatives = _mm_mul_ps(coeffs, multipliers);\n        _mm_storeu_ps(&result[i], derivatives);\n    }\n    \n    // Handle remaining elements\n    for (; i < n - 1; ++i) {\n        result[i] = xs[i+1] * (i+1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n    \n    std::vector<float> result(xs.size() - 1);\n    int n = xs.size();\n    \n    // Process 4 elements at a time using SSE\n    int vectorized_length = (n - 1) / 4 * 4;\n    \n    for (int i = 0; i < vectorized_length; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 multipliers = _mm_set_ps(4.0f, 3.0f, 2.0f, 1.0f);\n        __m128 derivatives = _mm_mul_ps(coeffs, multipliers);\n        _mm_storeu_ps(&result[i], derivatives);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorized_length; i < n - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Convert to lowercase\n        __m128i lower_a = _mm_set1_epi8('a');\n        __m128i lower_z = _mm_set1_epi8('z');\n        __m128i upper_a = _mm_set1_epi8('A');\n        __m128i upper_z = _mm_set1_epi8('Z');\n        \n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_a - 1),\n            _mm_cmpgt_epi8(upper_z + 1, chars)\n        );\n        \n        __m128i lowercase_mask = _mm_set1_epi8(32);\n        chars = _mm_or_si128(chars, _mm_and_si128(is_upper, lowercase_mask));\n        \n        // Check for vowels\n        __m128i vowels_a = _mm_cmpeq_epi8(chars, _mm_set1_epi8('a'));\n        __m128i vowels_e = _mm_cmpeq_epi8(chars, _mm_set1_epi8('e'));\n        __m128i vowels_i = _mm_cmpeq_epi8(chars, _mm_set1_epi8('i'));\n        __m128i vowels_o = _mm_cmpeq_epi8(chars, _mm_set1_epi8('o'));\n        __m128i vowels_u = _mm_cmpeq_epi8(chars, _mm_set1_epi8('u'));\n        \n        // Special case for 'y' at the end of the word\n        __m128i vowels_y = _mm_cmpeq_epi8(chars, _mm_set1_epi8('y'));\n        \n        __m128i vowel_mask = _mm_or_si128(\n            _mm_or_si128(vowels_a, vowels_e),\n            _mm_or_si128(\n                _mm_or_si128(vowels_i, vowels_o),\n                _mm_or_si128(vowels_u, \n                    _mm_and_si128(vowels_y, \n                        _mm_cmpeq_epi8(chars, _mm_set1_epi8(s[len-1]))\n                    )\n                )\n            )\n        );\n        \n        // Count vowels\n        vowel_count += _mm_popcnt_u32(_mm_movemask_epi8(vowel_mask));\n    }\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == len - 1)) {\n            ++vowel_count;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Convert to lowercase\n        __m128i lower_a = _mm_set1_epi8('a');\n        __m128i lower_z = _mm_set1_epi8('z');\n        __m128i upper_a = _mm_set1_epi8('A');\n        __m128i upper_z = _mm_set1_epi8('Z');\n        \n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_a - 1),\n            _mm_cmplt_epi8(chars, upper_z + 1)\n        );\n        \n        __m128i lowercase_mask = _mm_set1_epi8(32);\n        chars = _mm_or_si128(chars, _mm_and_si128(is_upper, lowercase_mask));\n        \n        // Check for vowels\n        __m128i vowels_a = _mm_cmpeq_epi8(chars, _mm_set1_epi8('a'));\n        __m128i vowels_e = _mm_cmpeq_epi8(chars, _mm_set1_epi8('e'));\n        __m128i vowels_i = _mm_cmpeq_epi8(chars, _mm_set1_epi8('i'));\n        __m128i vowels_o = _mm_cmpeq_epi8(chars, _mm_set1_epi8('o'));\n        __m128i vowels_u = _mm_cmpeq_epi8(chars, _mm_set1_epi8('u'));\n        \n        // Special case for 'y' at the end of the word\n        __m128i vowels_y = _mm_cmpeq_epi8(chars, _mm_set1_epi8('y'));\n        \n        __m128i vowel_mask = _mm_or_si128(\n            _mm_or_si128(vowels_a, vowels_e),\n            _mm_or_si128(\n                _mm_or_si128(vowels_i, vowels_o),\n                _mm_or_si128(vowels_u, \n                    _mm_and_si128(vowels_y, _mm_set1_epi8((i + 16 == len) ? 0xFF : 0x00))\n                )\n            )\n        );\n        \n        // Count vowels\n        vowel_count += _mm_popcnt_u32(_mm_movemask_epi8(vowel_mask));\n    }\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == len - 1)) {\n            ++vowel_count;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Convert to lowercase\n        __m128i lower_a = _mm_set1_epi8('a');\n        __m128i lower_z = _mm_set1_epi8('z');\n        __m128i upper_a = _mm_set1_epi8('A');\n        __m128i upper_z = _mm_set1_epi8('Z');\n        \n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_a - 1),\n            _mm_cmpgt_epi8(upper_z + 1, chars)\n        );\n        \n        __m128i lowercase_mask = _mm_or_si128(chars, _mm_and_si128(is_upper, _mm_set1_epi8(32)));\n        \n        // Check for vowels\n        __m128i vowels_a = _mm_cmpeq_epi8(lowercase_mask, _mm_set1_epi8('a'));\n        __m128i vowels_e = _mm_cmpeq_epi8(lowercase_mask, _mm_set1_epi8('e'));\n        __m128i vowels_i = _mm_cmpeq_epi8(lowercase_mask, _mm_set1_epi8('i'));\n        __m128i vowels_o = _mm_cmpeq_epi8(lowercase_mask, _mm_set1_epi8('o'));\n        __m128i vowels_u = _mm_cmpeq_epi8(lowercase_mask, _mm_set1_epi8('u'));\n        \n        // Special case for 'y' at the end of the word\n        __m128i vowels_y = _mm_cmpeq_epi8(lowercase_mask, _mm_set1_epi8('y'));\n        __m128i last_char_mask = _mm_setzero_si128();\n        if (i + 16 == len) {\n            last_char_mask = _mm_set1_epi8(0xFF);\n        }\n        vowels_y = _mm_and_si128(vowels_y, last_char_mask);\n        \n        // Combine vowel checks\n        __m128i vowel_mask = _mm_or_si128(\n            _mm_or_si128(vowels_a, vowels_e),\n            _mm_or_si128(\n                _mm_or_si128(vowels_i, vowels_o),\n                _mm_or_si128(vowels_u, vowels_y)\n            )\n        );\n        \n        // Count vowels\n        vowel_count += _mm_popcnt_u32(_mm_movemask_epi8(vowel_mask));\n    }\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == len - 1)) {\n            ++vowel_count;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Convert to lowercase\n        __m128i lower_a = _mm_set1_epi8('a');\n        __m128i lower_z = _mm_set1_epi8('z');\n        __m128i upper_a = _mm_set1_epi8('A');\n        __m128i upper_z = _mm_set1_epi8('Z');\n        \n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_a - 1),\n            _mm_cmplt_epi8(chars, upper_z + 1)\n        );\n        \n        __m128i offset = _mm_set1_epi8(32);\n        __m128i lowercase = _mm_add_epi8(chars, _mm_and_si128(is_upper, offset));\n        \n        // Check for vowels\n        __m128i vowels_a = _mm_cmpeq_epi8(lowercase, _mm_set1_epi8('a'));\n        __m128i vowels_e = _mm_cmpeq_epi8(lowercase, _mm_set1_epi8('e'));\n        __m128i vowels_i = _mm_cmpeq_epi8(lowercase, _mm_set1_epi8('i'));\n        __m128i vowels_o = _mm_cmpeq_epi8(lowercase, _mm_set1_epi8('o'));\n        __m128i vowels_u = _mm_cmpeq_epi8(lowercase, _mm_set1_epi8('u'));\n        \n        // Special case for 'y' at the end of the word\n        __m128i vowels_y = _mm_cmpeq_epi8(lowercase, _mm_set1_epi8('y'));\n        __m128i is_last_char = _mm_setzero_si128();\n        if (i + 15 == len - 1) {\n            is_last_char = _mm_set1_epi8(0xFF);\n        }\n        vowels_y = _mm_and_si128(vowels_y, is_last_char);\n        \n        // Combine vowel checks\n        __m128i vowel_mask = _mm_or_si128(\n            _mm_or_si128(\n                _mm_or_si128(vowels_a, vowels_e),\n                _mm_or_si128(vowels_i, vowels_o)\n            ),\n            _mm_or_si128(vowels_u, vowels_y)\n        );\n        \n        // Count vowels\n        int mask = _mm_movemask_epi8(vowel_mask);\n        vowel_count += __builtin_popcount(mask);\n    }\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == len - 1)) {\n            ++vowel_count;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int vowel_count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Convert to lowercase\n        __m128i lower_a = _mm_set1_epi8('a');\n        __m128i lower_z = _mm_set1_epi8('z');\n        __m128i upper_mask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('Z'));\n        __m128i lower_mask = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_set1_epi8('A') - 1), \n                                           _mm_cmpgt_epi8(_mm_set1_epi8('Z') + 1, chars));\n        __m128i case_mask = _mm_or_si128(lower_mask, upper_mask);\n        chars = _mm_or_si128(chars, _mm_and_si128(case_mask, _mm_set1_epi8(32)));\n        \n        // Check for vowels\n        __m128i vowels_a = _mm_cmpeq_epi8(chars, _mm_set1_epi8('a'));\n        __m128i vowels_e = _mm_cmpeq_epi8(chars, _mm_set1_epi8('e'));\n        __m128i vowels_i = _mm_cmpeq_epi8(chars, _mm_set1_epi8('i'));\n        __m128i vowels_o = _mm_cmpeq_epi8(chars, _mm_set1_epi8('o'));\n        __m128i vowels_u = _mm_cmpeq_epi8(chars, _mm_set1_epi8('u'));\n        \n        // Special case for 'y' at the end of the word\n        __m128i vowels_y = _mm_cmpeq_epi8(chars, _mm_set1_epi8('y'));\n        if (i + 16 == len) {\n            vowels_y = _mm_and_si128(vowels_y, _mm_set1_epi8(0xFF));\n        }\n        \n        // Combine vowel checks\n        __m128i vowels = _mm_or_si128(_mm_or_si128(_mm_or_si128(vowels_a, vowels_e), \n                                      _mm_or_si128(vowels_i, vowels_o)), \n                                      _mm_or_si128(vowels_u, vowels_y));\n        \n        // Count vowels\n        vowel_count += _mm_popcnt_u32(_mm_movemask_epi8(vowels));\n    }\n    \n    // Process remaining characters\n    for (; i < len; i++) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n            (c == 'y' && i == len - 1)) {\n            vowel_count++;\n        }\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    size_t vectorized_len = len - (len % 16);\n    \n    __m128i sum_vector = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < vectorized_len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Create mask for uppercase characters (A-Z)\n        __m128i upper_mask = _mm_set1_epi8(0);\n        __m128i A = _mm_set1_epi8('A');\n        __m128i Z = _mm_set1_epi8('Z');\n        \n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, _mm_sub_epi8(A, _mm_set1_epi8(1))),\n            _mm_cmpgt_epi8(_mm_sub_epi8(Z, chars), _mm_set1_epi8(-1))\n        );\n        \n        // Zero out non-uppercase characters\n        __m128i upper_chars = _mm_and_si128(chars, is_upper);\n        \n        // Sum the ASCII values of uppercase characters\n        sum_vector = _mm_add_epi32(sum_vector, _mm_sad_epu8(upper_chars, _mm_setzero_si128()));\n    }\n    \n    // Horizontal sum of vector\n    __m128i sum_high = _mm_srli_si128(sum_vector, 8);\n    sum_vector = _mm_add_epi32(sum_vector, sum_high);\n    sum_high = _mm_srli_si128(sum_vector, 4);\n    sum_vector = _mm_add_epi32(sum_vector, sum_high);\n    \n    result += _mm_cvtsi128_si32(sum_vector);\n    \n    // Process remaining characters\n    for (size_t i = vectorized_len; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Create mask for uppercase characters\n        __m128i upper_mask = _mm_set1_epi8('A' - 1);\n        __m128i upper_compare = _mm_set1_epi8('Z' + 1);\n        \n        // Check which characters are uppercase\n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_mask),\n            _mm_cmplt_epi8(chars, upper_compare)\n        );\n        \n        // Zero out non-uppercase characters\n        __m128i masked_chars = _mm_and_si128(chars, is_upper);\n        \n        // Horizontal sum of bytes\n        __m128i sum_low = _mm_unpacklo_epi8(masked_chars, _mm_setzero_si128());\n        __m128i sum_high = _mm_unpackhi_epi8(masked_chars, _mm_setzero_si128());\n        \n        sum_low = _mm_add_epi16(sum_low, sum_high);\n        sum_low = _mm_add_epi16(sum_low, _mm_srli_epi16(sum_low, 8));\n        sum_low = _mm_add_epi16(sum_low, _mm_srli_epi16(sum_low, 4));\n        \n        result += _mm_cvtsi128_si32(sum_low) & 0xFFFF;\n    }\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Create mask for uppercase characters\n        __m128i upper_mask = _mm_set1_epi8('A' - 1);\n        __m128i upper_compare = _mm_set1_epi8('Z' + 1);\n        \n        // Check which characters are uppercase\n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_mask),\n            _mm_cmplt_epi8(chars, upper_compare)\n        );\n        \n        // Zero out non-uppercase characters\n        __m128i masked_chars = _mm_and_si128(chars, is_upper);\n        \n        // Horizontal sum of ASCII values\n        __m128i sum_lo = _mm_unpacklo_epi8(masked_chars, _mm_setzero_si128());\n        __m128i sum_hi = _mm_unpackhi_epi8(masked_chars, _mm_setzero_si128());\n        \n        sum_lo = _mm_add_epi16(sum_lo, sum_hi);\n        sum_lo = _mm_add_epi16(sum_lo, _mm_srli_epi16(sum_lo, 8));\n        sum_lo = _mm_add_epi16(sum_lo, _mm_srli_epi16(sum_lo, 4));\n        sum_lo = _mm_add_epi16(sum_lo, _mm_srli_epi16(sum_lo, 2));\n        \n        result += _mm_cvtsi128_si32(sum_lo) & 0xFFFF;\n    }\n    \n    // Handle remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Create masks for uppercase characters\n        __m128i upper_mask = _mm_set1_epi8('A' - 1);\n        __m128i lower_mask = _mm_set1_epi8('Z' + 1);\n        \n        // Check if characters are uppercase\n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_mask),\n            _mm_cmplt_epi8(chars, lower_mask)\n        );\n        \n        // Zero out non-uppercase characters\n        __m128i masked_chars = _mm_and_si128(chars, is_upper);\n        \n        // Horizontal sum of bytes\n        __m128i sum_low = _mm_unpacklo_epi8(masked_chars, _mm_setzero_si128());\n        __m128i sum_high = _mm_unpackhi_epi8(masked_chars, _mm_setzero_si128());\n        \n        sum_low = _mm_add_epi16(sum_low, sum_high);\n        sum_low = _mm_add_epi16(sum_low, _mm_srli_epi16(sum_low, 8));\n        sum_low = _mm_add_epi16(sum_low, _mm_srli_epi16(sum_low, 4));\n        \n        result += _mm_cvtsi128_si32(sum_low) & 0xFFFF;\n    }\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (isupper(s[i])) {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Create masks for uppercase characters\n        __m128i upper_mask = _mm_set1_epi8('A' - 1);\n        __m128i lower_mask = _mm_set1_epi8('Z' + 1);\n        \n        // Check if characters are uppercase\n        __m128i is_upper_a = _mm_cmpgt_epi8(chars, upper_mask);\n        __m128i is_upper_b = _mm_cmplt_epi8(chars, lower_mask);\n        __m128i is_upper = _mm_and_si128(is_upper_a, is_upper_b);\n        \n        // Zero out non-uppercase characters\n        __m128i masked_chars = _mm_and_si128(chars, is_upper);\n        \n        // Horizontal sum of ASCII values\n        __m128i zero = _mm_setzero_si128();\n        __m128i sum_low = _mm_unpacklo_epi8(masked_chars, zero);\n        __m128i sum_high = _mm_unpackhi_epi8(masked_chars, zero);\n        \n        sum_low = _mm_add_epi16(sum_low, sum_high);\n        sum_low = _mm_add_epi16(sum_low, _mm_srli_epi16(sum_low, 8));\n        sum_low = _mm_add_epi16(sum_low, _mm_srli_epi16(sum_low, 4));\n        \n        result += _mm_cvtsi128_si32(sum_low) & 0xFFFF;\n    }\n    \n    // Process remaining characters\n    for (; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    // Align input to 16-byte boundary for SSE\n    int aligned_size = (n + 3) / 4 * 4;\n    std::vector<int> aligned_arr(aligned_size, INT_MAX);\n    std::copy(arr.begin(), arr.end(), aligned_arr.begin());\n\n    __m128i smallest_even = _mm_set1_epi32(INT_MAX);\n    __m128i smallest_index = _mm_set1_epi32(-1);\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i current = _mm_load_si128((__m128i*)&aligned_arr[i]);\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n\n        // Create mask for even values\n        __m128i even_mask = _mm_cmpeq_epi32(_mm_and_si128(current, _mm_set1_epi32(1)), _mm_setzero_si128());\n\n        // Replace non-even values with INT_MAX\n        __m128i masked_current = _mm_or_si128(\n            _mm_and_si128(current, even_mask),\n            _mm_andnot_si128(even_mask, _mm_set1_epi32(INT_MAX))\n        );\n\n        // Compare and update smallest even value and index\n        __m128i cmp_mask = _mm_cmplt_epi32(masked_current, smallest_even);\n        smallest_even = _mm_blendv_epi8(smallest_even, masked_current, cmp_mask);\n        smallest_index = _mm_blendv_epi8(smallest_index, indices, cmp_mask);\n    }\n\n    // Horizontal min reduction\n    __m128i shuffled1 = _mm_shuffle_epi32(smallest_even, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i shuffled2 = _mm_shuffle_epi32(smallest_index, _MM_SHUFFLE(1, 0, 3, 2));\n    \n    __m128i min1 = _mm_min_epi32(smallest_even, shuffled1);\n    __m128i index1 = _mm_blendv_epi8(smallest_index, shuffled2, \n        _mm_cmpeq_epi32(min1, shuffled1));\n    \n    __m128i min2 = _mm_shuffle_epi32(min1, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i index2 = _mm_shuffle_epi32(index1, _MM_SHUFFLE(1, 0, 3, 2));\n    \n    __m128i final_min = _mm_min_epi32(min1, min2);\n    __m128i final_index = _mm_blendv_epi8(index1, index2, \n        _mm_cmpeq_epi32(final_min, min2));\n\n    int result_value = _mm_cvtsi128_si32(final_min);\n    int result_index = _mm_cvtsi128_si32(final_index);\n\n    // Check if a valid even value was found\n    if (result_value == INT_MAX) return {};\n    return {result_value, result_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    // Align to 16-byte boundary for SSE\n    int aligned_size = (n + 3) / 4 * 4;\n    std::vector<int> padded_arr(aligned_size, INT_MAX);\n    std::copy(arr.begin(), arr.end(), padded_arr.begin());\n\n    __m128i smallest_even_val = _mm_set1_epi32(INT_MAX);\n    __m128i smallest_even_idx = _mm_set1_epi32(-1);\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i current_vals = _mm_load_si128((__m128i*)&padded_arr[i]);\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n\n        // Check for even values\n        __m128i even_mask = _mm_cmpeq_epi32(_mm_and_si128(current_vals, _mm_set1_epi32(1)), _mm_setzero_si128());\n        \n        // Replace non-even values with INT_MAX\n        current_vals = _mm_blendv_epi8(current_vals, _mm_set1_epi32(INT_MAX), _mm_cmpeq_epi32(even_mask, _mm_setzero_si128()));\n        \n        // Compare and update smallest even value and index\n        __m128i cmp_mask = _mm_cmplt_epi32(current_vals, smallest_even_val);\n        smallest_even_val = _mm_blendv_epi8(smallest_even_val, current_vals, cmp_mask);\n        smallest_even_idx = _mm_blendv_epi8(smallest_even_idx, indices, cmp_mask);\n    }\n\n    // Horizontal reduction to find the final smallest even value and index\n    int vals[4], idxs[4];\n    _mm_storeu_si128((__m128i*)vals, smallest_even_val);\n    _mm_storeu_si128((__m128i*)idxs, smallest_even_idx);\n\n    int min_val = INT_MAX;\n    int min_idx = -1;\n    for (int i = 0; i < 4; i++) {\n        if (vals[i] < min_val) {\n            min_val = vals[i];\n            min_idx = idxs[i];\n        }\n    }\n\n    return (min_idx != -1 && min_val != INT_MAX) ? std::vector<int>{min_val, min_idx} : std::vector<int>{};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    // Align data to 16-byte boundary for SSE\n    __attribute__((aligned(16))) int smallest_even = INT_MAX;\n    __attribute__((aligned(16))) int smallest_index = -1;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for even numbers\n        __m128i zero = _mm_setzero_si128();\n        __m128i even_mask = _mm_cmpeq_epi32(_mm_and_si128(vec, _mm_set1_epi32(1)), zero);\n        \n        // If no even numbers in this chunk, continue\n        if (_mm_movemask_epi8(even_mask) == 0) continue;\n\n        // Mask out odd numbers\n        __m128i masked_vec = _mm_and_si128(vec, even_mask);\n        \n        // Find minimum even value and its index\n        for (int j = 0; j < 4; j++) {\n            int val = _mm_cvtsi128_si32(_mm_srli_si128(masked_vec, j * 4));\n            if (val != 0 && val < smallest_even) {\n                smallest_even = val;\n                smallest_index = i + j;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    // Return result\n    if (smallest_index == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    // Align data to 16-byte boundary for SSE\n    alignas(16) int smallest_even = INT_MAX;\n    alignas(16) int smallest_index = -1;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for even numbers\n        __m128i zero = _mm_setzero_si128();\n        __m128i two = _mm_set1_epi32(2);\n        __m128i mod_mask = _mm_cmpeq_epi32(_mm_and_si128(vec, _mm_sub_epi32(two, _mm_set1_epi32(1))), zero);\n        \n        // Mask out odd numbers\n        __m128i even_vec = _mm_and_si128(vec, mod_mask);\n        \n        // Find minimum even value and its index\n        for (int j = 0; j < 4; j++) {\n            int val = _mm_cvtsi128_si32(_mm_srli_si128(even_vec, j * 4));\n            if (val != 0 && val < smallest_even) {\n                smallest_even = val;\n                smallest_index = i + j;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    // Return result\n    if (smallest_index == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    // Align data to 16-byte boundary for SSE\n    __attribute__((aligned(16))) int smallest_even = INT_MAX;\n    __attribute__((aligned(16))) int smallest_index = -1;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for even numbers\n        __m128i zero = _mm_setzero_si128();\n        __m128i two = _mm_set1_epi32(2);\n        __m128i mod2 = _mm_cmpeq_epi32(_mm_and_si128(vec, _mm_sub_epi32(two, _mm_set1_epi32(1))), zero);\n        \n        // Mask out odd numbers\n        __m128i even_vec = _mm_and_si128(vec, mod2);\n        \n        // Find minimum even value and its index\n        for (int j = 0; j < 4; j++) {\n            int val = _mm_cvtsi128_si32(_mm_srli_si128(even_vec, j * 4));\n            int index = i + j;\n            \n            if (val != 0 && val < smallest_even) {\n                smallest_even = val;\n                smallest_index = index;\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    // Return result\n    if (smallest_index == -1) return {};\n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    \n    // Count frequencies using SSE2 intrinsics\n    std::vector<int> freq(n + 1, 0);\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i count = _mm_setzero_si128();\n        \n        for (int j = 0; j < n; j++) {\n            __m128i current = _mm_set1_epi32(lst[j]);\n            __m128i elements = _mm_loadu_si128((__m128i*)&lst[i]);\n            \n            __m128i comparison = _mm_cmpeq_epi32(current, elements);\n            count = _mm_add_epi32(count, _mm_srli_epi32(comparison, 31));\n        }\n        \n        _mm_storeu_si128((__m128i*)&freq[lst[i]], count);\n    }\n    \n    // Find the result using scalar processing\n    int result = -1;\n    for (int i = n; i > 0; i--) {\n        if (freq[i] >= i) {\n            result = i;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Count frequencies using SSE\n    std::vector<int> freq(n + 1, 0);\n    \n    // Use SSE to count frequencies\n    for (int i = 0; i < n; i += 4) {\n        __m128i count_vec = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4 && i + j < n; j++) {\n            int val = lst[i + j];\n            if (val > 0 && val <= n) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Check conditions in parallel\n    for (int x = n; x > 0; x--) {\n        if (freq[x] >= x) {\n            return x;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Count frequencies using SSE2 intrinsics\n    std::vector<int> freq(n + 1, 0);\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i count_vec = _mm_setzero_si128();\n        \n        for (int j = 0; j < n; j++) {\n            __m128i current = _mm_set1_epi32(lst[j]);\n            __m128i input = _mm_loadu_si128((__m128i*)&lst[i]);\n            \n            __m128i compare = _mm_cmpeq_epi32(current, input);\n            count_vec = _mm_add_epi32(count_vec, _mm_srli_epi32(compare, 31));\n        }\n        \n        _mm_storeu_si128((__m128i*)&freq[lst[i]], count_vec);\n    }\n\n    // Find the result\n    int result = -1;\n    for (int x = 1; x <= n; x++) {\n        if (freq[x] >= x) {\n            result = std::max(result, x);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Count frequencies using SSE2 intrinsics\n    std::vector<int> freq(n + 1, 0);\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i count_vec = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4 && i + j < n; j++) {\n            int val = lst[i + j];\n            if (val > 0 && val <= n) {\n                freq[val]++;\n            }\n        }\n    }\n\n    // Check for values satisfying the condition\n    for (int x = n; x > 0; x--) {\n        if (freq[x] >= x) {\n            return x;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    // Count frequencies using SSE\n    std::vector<int> freq(n + 1, 0);\n    \n    // Process 4 integers at a time using SSE\n    int i = 0;\n    for (; i + 3 < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Broadcast each integer and compare\n        __m128i a0 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(0, 0, 0, 0));\n        __m128i a1 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(1, 1, 1, 1));\n        __m128i a2 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(2, 2, 2, 2));\n        __m128i a3 = _mm_shuffle_epi32(vec, _MM_SHUFFLE(3, 3, 3, 3));\n        \n        freq[_mm_cvtsi128_si32(a0)]++;\n        freq[_mm_cvtsi128_si32(a1)]++;\n        freq[_mm_cvtsi128_si32(a2)]++;\n        freq[_mm_cvtsi128_si32(a3)]++;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        freq[lst[i]]++;\n    }\n    \n    // Find the result\n    for (int j = n; j > 0; j--) {\n        if (freq[j] >= j) {\n            return j;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if sum exceeds max weight\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i < n; i += 4) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&q[i]));\n        sum_vec = _mm_add_epi32(sum_vec, chunk);\n    }\n    \n    // Horizontal sum\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 4);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    int total_sum = _mm_cvtsi128_si32(sum_vec);\n    \n    if (total_sum > w) return false;\n    \n    // Check palindrome\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if sum exceeds max weight\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i < n; i += 4) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&q[i]));\n        sum_vec = _mm_add_epi32(sum_vec, chunk);\n    }\n    \n    // Horizontal sum\n    __m128i shuffled = _mm_shuffle_epi32(sum_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    sum_vec = _mm_add_epi32(sum_vec, shuffled);\n    shuffled = _mm_shuffle_epi32(sum_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    sum_vec = _mm_add_epi32(sum_vec, shuffled);\n    \n    int total_sum = _mm_cvtsi128_si32(sum_vec);\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        total_sum += q[i];\n    }\n    \n    // Check weight constraint\n    if (total_sum > w) return false;\n    \n    // Check palindrome\n    for (int i = 0; i < n/2; i++) {\n        if (q[i] != q[n-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if sum exceeds weight\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i < n; i += 4) {\n        __m128i chunk = _mm_loadu_si128((__m128i*)&q[i]);\n        sum_vec = _mm_add_epi32(sum_vec, chunk);\n    }\n    \n    // Horizontal sum\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 4);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    int total_sum = _mm_cvtsi128_si32(sum_vec);\n    \n    if (total_sum > w) return false;\n    \n    // Check palindromic condition\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if vector is balanced (palindromic)\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    \n    // Calculate sum of elements using SSE2\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i + 4 <= n; i += 4) {\n        __m128i curr_vec = _mm_loadu_si128((__m128i*)&q[i]);\n        sum_vec = _mm_add_epi32(sum_vec, curr_vec);\n    }\n    \n    // Horizontal sum\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 4);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    \n    // Handle remaining elements\n    int sum = _mm_cvtsi128_si32(sum_vec);\n    for (int i = (n / 4) * 4; i < n; i++) {\n        sum += q[i];\n    }\n    \n    // Check if sum is less than or equal to max weight\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check if sum of elements exceeds max weight\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i < n; i += 4) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&q[i]));\n        sum_vec = _mm_add_epi32(sum_vec, chunk);\n    }\n    \n    // Horizontal sum of vector elements\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 4);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    int total_sum = _mm_cvtsi128_si32(sum_vec);\n    \n    // Check weight constraint\n    if (total_sum > w) return false;\n    \n    // Check palindromic condition\n    for (int i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 4 - i]);\n        \n        // Reverse the right vector\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Compare left and right vectors\n        __m128i compare = _mm_cmpeq_epi32(left, right);\n        \n        // Count mismatches\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(compare));\n        changes += (4 - __builtin_popcount(mask));\n    }\n    \n    // Handle remaining elements\n    for (int i = n / 2; i < n - i - 1; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 4 - i]);\n        \n        // Reverse the right vector\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Compare left and right vectors\n        __m128i compare = _mm_cmpeq_epi32(left, right);\n        \n        // Count mismatches\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(compare));\n        changes += (4 - __builtin_popcount(mask));\n    }\n    \n    // Handle remaining elements if vector size is odd\n    for (int i = n / 2; i < n - i - 1; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 4 - i]);\n        \n        // Reverse the right side vector\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Compare left and right vectors\n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        \n        // Count mismatches\n        int mask = _mm_movemask_ps((__m128)cmp);\n        changes += (4 - __builtin_popcount(mask));\n    }\n    \n    // Handle remaining elements if vector size is odd\n    for (int i = n / 2; i < n - i - 1; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 4 - i]);\n        \n        // Reverse the right vector\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Compare left and right vectors\n        __m128i compare = _mm_cmpeq_epi32(left, right);\n        \n        // Count mismatches\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(compare));\n        changes += (4 - __builtin_popcount(mask));\n    }\n    \n    // Handle remaining elements if vector size is odd\n    for (int i = n / 2; i < n - i - 1; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n / 2; i += 4) {\n        __m128i left = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i right = _mm_loadu_si128((__m128i*)&arr[n - 4 - i]);\n        \n        // Reverse the right vector\n        right = _mm_shuffle_epi32(right, _MM_SHUFFLE(0, 1, 2, 3));\n        \n        // Compare elements\n        __m128i cmp = _mm_cmpeq_epi32(left, right);\n        \n        // Count mismatches\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        changes += (4 - __builtin_popcount(mask));\n    }\n    \n    // Handle remaining elements if vector size is odd\n    for (int i = n / 2; i < n - i - 1; i++) {\n        if (arr[i] != arr[n - i - 1]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters for first vector using SSE\n    __m128i total_chars1 = _mm_setzero_si128();\n    for (const auto& str : lst1) {\n        __m128i chars = _mm_set1_epi32(str.length());\n        total_chars1 = _mm_add_epi32(total_chars1, chars);\n    }\n\n    // Calculate total characters for second vector using SSE\n    __m128i total_chars2 = _mm_setzero_si128();\n    for (const auto& str : lst2) {\n        __m128i chars = _mm_set1_epi32(str.length());\n        total_chars2 = _mm_add_epi32(total_chars2, chars);\n    }\n\n    // Extract total character count\n    int total1 = _mm_cvtsi128_si32(total_chars1);\n    int total2 = _mm_cvtsi128_si32(total_chars2);\n\n    // Return vector with fewer total characters\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters in lst1\n    int total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters in lst2\n    int total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // If total_chars2 is less than or equal to total_chars1, return lst2\n    // Otherwise return lst1\n    return (total_chars2 <= total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters for first vector using SSE\n    __m128i total_chars1 = _mm_setzero_si128();\n    for (const auto& str : lst1) {\n        __m128i chars = _mm_set1_epi32(str.length());\n        total_chars1 = _mm_add_epi32(total_chars1, chars);\n    }\n\n    // Calculate total characters for second vector using SSE\n    __m128i total_chars2 = _mm_setzero_si128();\n    for (const auto& str : lst2) {\n        __m128i chars = _mm_set1_epi32(str.length());\n        total_chars2 = _mm_add_epi32(total_chars2, chars);\n    }\n\n    // Extract total character count\n    int total1 = _mm_cvtsi128_si32(total_chars1);\n    int total2 = _mm_cvtsi128_si32(total_chars2);\n\n    // Return vector with fewer total characters\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters for first vector\n    int total_chars1 = 0;\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Calculate total characters for second vector\n    int total_chars2 = 0;\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // If total chars are equal or first vector has less chars, return first vector\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    }\n\n    // Otherwise return second vector\n    return lst2;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total character count for each vector using SIMD\n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    // Use SSE2 to parallelize character counting\n    __m128i zero = _mm_setzero_si128();\n    \n    // Count chars for lst1\n    for (size_t i = 0; i < lst1.size(); i += 4) {\n        __m128i char_counts = _mm_setzero_si128();\n        \n        for (size_t j = i; j < std::min(i + 4, lst1.size()); ++j) {\n            total_chars1 += lst1[j].length();\n        }\n    }\n\n    // Count chars for lst2\n    for (size_t i = 0; i < lst2.size(); i += 4) {\n        __m128i char_counts = _mm_setzero_si128();\n        \n        for (size_t j = i; j < std::min(i + 4, lst2.size()); ++j) {\n            total_chars2 += lst2[j].length();\n        }\n    }\n\n    // Return vector with fewer total characters\n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (x == 1 && n > 1) return true;\n    if (n <= 1 || x == 0) return false;\n\n    // Use SSE2 to compute powers efficiently\n    __m128d power_vec = _mm_set1_pd(1.0);\n    __m128d base_vec = _mm_set1_pd(static_cast<double>(n));\n    __m128d target_vec = _mm_set1_pd(static_cast<double>(x));\n\n    // Compute powers using SSE2 vector operations\n    for (int i = 0; i < 64; ++i) {\n        power_vec = _mm_mul_pd(power_vec, base_vec);\n        \n        // Check if current power matches target\n        __m128d compare = _mm_cmpeq_pd(power_vec, target_vec);\n        int mask = _mm_movemask_pd(compare);\n        \n        if (mask) return true;\n        \n        // Break if power exceeds target\n        if (_mm_comigt_sd(power_vec, target_vec)) break;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n\n    __m128d x_vec = _mm_set1_pd(static_cast<double>(x));\n    __m128d n_vec = _mm_set1_pd(static_cast<double>(n));\n    \n    double result = 1.0;\n    for (int i = 0; i < 64; i++) {\n        __m128d result_vec = _mm_set1_pd(result);\n        __m128d compare = _mm_cmpeq_pd(result_vec, x_vec);\n        \n        if (_mm_movemask_pd(compare)) return true;\n        \n        result *= n;\n        if (result > x) break;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Handle special cases first\n    if (x == 1 && n > 1) return true;\n    if (n <= 1 || x == 0) return false;\n\n    // Use SSE2 intrinsics to compute powers efficiently\n    __m128d power_vec = _mm_set1_pd(1.0);\n    __m128d base_vec = _mm_set1_pd((double)n);\n    __m128d target_vec = _mm_set1_pd((double)x);\n\n    // Perform repeated multiplication using SSE\n    for (int i = 0; i < 64; i++) {\n        power_vec = _mm_mul_pd(power_vec, base_vec);\n        \n        // Check if current power matches target\n        __m128d compare = _mm_cmpeq_pd(power_vec, target_vec);\n        int mask = _mm_movemask_pd(compare);\n        \n        if (mask) return true;\n        \n        // Break if power exceeds target\n        if (_mm_comigt_sd(power_vec, target_vec)) break;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Handle special cases\n    if (n <= 1 || x == 1) return false;\n    if (x == n) return true;\n\n    // Use SSE2 intrinsics for parallel computation\n    __m128d x_vec = _mm_set1_pd(static_cast<double>(x));\n    __m128d n_vec = _mm_set1_pd(static_cast<double>(n));\n    \n    double current = n;\n    while (current <= x) {\n        __m128d current_vec = _mm_set1_pd(current);\n        \n        // Compare current^k with x\n        if (_mm_comieq_sd(current_vec, x_vec)) {\n            return true;\n        }\n        \n        current *= n;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Handle special cases\n    if (n <= 1 || x == 1) return false;\n    if (x == n) return true;\n\n    // Use SSE2 intrinsics to perform parallel comparisons\n    __m128d x_vec = _mm_set1_pd(static_cast<double>(x));\n    __m128d n_vec = _mm_set1_pd(static_cast<double>(n));\n    \n    double current = n;\n    while (current <= x) {\n        // Parallel comparison of current and x\n        __m128d current_vec = _mm_set1_pd(current);\n        __m128d compare_vec = _mm_cmpeq_pd(current_vec, x_vec);\n        \n        // Extract comparison result\n        int mask = _mm_movemask_pd(compare_vec);\n        if (mask & 1) return true;\n        \n        // Multiply current by n\n        current *= n;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B, D\n    const __m128i prime_digits = _mm_set_epi8(\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 13, 11, 7, 5\n    );\n\n    int prime_count = 0;\n    int len = num.length();\n    int vec_len = len - (len % 16);\n\n    // Process 16 characters at a time using SSE\n    for (int i = 0; i < vec_len; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&num[i]));\n        \n        // Convert ASCII hex to numeric values\n        __m128i zero = _mm_setzero_si128();\n        __m128i is_alpha = _mm_cmpgt_epi8(input, _mm_set1_epi8('9'));\n        __m128i alpha_adjust = _mm_and_si128(is_alpha, _mm_set1_epi8(7));\n        __m128i numeric_input = _mm_sub_epi8(_mm_sub_epi8(input, zero), alpha_adjust);\n\n        // Compare with prime digits\n        __m128i match = _mm_cmpeq_epi8(numeric_input, prime_digits);\n        int mask = _mm_movemask_epi8(match);\n        \n        // Count prime digits\n        prime_count += _mm_popcnt_u32(mask);\n    }\n\n    // Process remaining characters\n    for (int i = vec_len; i < len; ++i) {\n        int digit = (num[i] <= '9') ? (num[i] - '0') : (num[i] - 'A' + 10);\n        if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || \n            digit == 11 || digit == 13) {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const __m128i prime_digits = _mm_set_epi8(\n        0, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 13, 11, 7, 5, 3\n    );\n\n    int prime_count = 0;\n    int vec_size = 16;\n    size_t i = 0;\n\n    // Process 16 characters at a time using SSE\n    for (; i + vec_size <= num.length(); i += vec_size) {\n        __m128i input_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&num[i]));\n        \n        // Convert characters to their hex values\n        __m128i hex_values = _mm_set_epi8(\n            num[i+15] >= 'A' ? num[i+15] - 'A' + 10 : num[i+15] - '0',\n            num[i+14] >= 'A' ? num[i+14] - 'A' + 10 : num[i+14] - '0',\n            num[i+13] >= 'A' ? num[i+13] - 'A' + 10 : num[i+13] - '0',\n            num[i+12] >= 'A' ? num[i+12] - 'A' + 10 : num[i+12] - '0',\n            num[i+11] >= 'A' ? num[i+11] - 'A' + 10 : num[i+11] - '0',\n            num[i+10] >= 'A' ? num[i+10] - 'A' + 10 : num[i+10] - '0',\n            num[i+9] >= 'A' ? num[i+9] - 'A' + 10 : num[i+9] - '0',\n            num[i+8] >= 'A' ? num[i+8] - 'A' + 10 : num[i+8] - '0',\n            num[i+7] >= 'A' ? num[i+7] - 'A' + 10 : num[i+7] - '0',\n            num[i+6] >= 'A' ? num[i+6] - 'A' + 10 : num[i+6] - '0',\n            num[i+5] >= 'A' ? num[i+5] - 'A' + 10 : num[i+5] - '0',\n            num[i+4] >= 'A' ? num[i+4] - 'A' + 10 : num[i+4] - '0',\n            num[i+3] >= 'A' ? num[i+3] - 'A' + 10 : num[i+3] - '0',\n            num[i+2] >= 'A' ? num[i+2] - 'A' + 10 : num[i+2] - '0',\n            num[i+1] >= 'A' ? num[i+1] - 'A' + 10 : num[i+1] - '0',\n            num[i] >= 'A' ? num[i] - 'A' + 10 : num[i] - '0'\n        );\n\n        // Compare hex values with prime digits\n        __m128i match_mask = _mm_cmpeq_epi8(hex_values, prime_digits);\n        \n        // Count matching prime digits\n        int mask = _mm_movemask_epi8(match_mask);\n        prime_count += __builtin_popcount(mask);\n    }\n\n    // Process remaining characters\n    for (; i < num.length(); ++i) {\n        int hex_val = num[i] >= 'A' ? num[i] - 'A' + 10 : num[i] - '0';\n        if (hex_val == 2 || hex_val == 3 || hex_val == 5 || \n            hex_val == 7 || hex_val == 11 || hex_val == 13) {\n            prime_count++;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const __m128i prime_digits = _mm_setr_epi8(\n        '2', '3', '5', '7', 'B', 'D', 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    );\n\n    int prime_count = 0;\n    int len = num.length();\n    int i = 0;\n\n    // Process 16 characters at a time using SSE\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&num[i]));\n        \n        // Compare input with prime digits\n        __m128i comparison = _mm_cmpeq_epi8(input, prime_digits);\n        \n        // Create a mask of matching digits\n        int mask = _mm_movemask_epi8(comparison);\n        \n        // Count set bits in the mask\n        prime_count += _mm_popcnt_u32(mask);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || \n            c == 'B' || c == 'D') {\n            ++prime_count;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const __m128i prime_digits = _mm_setr_epi8(\n        '2', '3', '5', '7', 'B', 'D', 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    );\n\n    int prime_count = 0;\n    int len = num.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&num[i]));\n        \n        // Compare input with prime digits\n        __m128i compare = _mm_cmpeq_epi8(input, prime_digits);\n        \n        // Create a mask of matching digits\n        int mask = _mm_movemask_epi8(compare);\n        \n        // Count set bits in the mask\n        prime_count += _mm_popcnt_u32(mask);\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || \n            c == 'B' || c == 'D') {\n            ++prime_count;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const __m128i prime_digits = _mm_setr_epi8(\n        '2', '3', '5', '7', 'B', 'D', 0, 0,\n        0, 0, 0, 0, 0, 0, 0, 0\n    );\n\n    int prime_count = 0;\n    int len = num.length();\n    int i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 15 < len; i += 16) {\n        __m128i input = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&num[i]));\n        \n        // Compare input with prime digits\n        __m128i match = _mm_cmpeq_epi8(input, prime_digits);\n        \n        // Count matching bytes\n        prime_count += _mm_popcnt_u32(_mm_movemask_epi8(match));\n    }\n\n    // Process remaining characters\n    for (; i < len; ++i) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || \n            c == 'B' || c == 'D') {\n            ++prime_count;\n        }\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    int n = s.length();\n    int simd_length = n - (n % 4);\n\n    for (int i = 0; i <= simd_length - 4; i += 4) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        __m128i shifted1 = _mm_srli_si128(chars, 1);\n        __m128i shifted2 = _mm_srli_si128(chars, 2);\n        \n        __m128i compare1 = _mm_cmpeq_epi8(chars, shifted1);\n        __m128i compare2 = _mm_cmpeq_epi8(chars, shifted2);\n        __m128i compare3 = _mm_cmpeq_epi8(shifted1, shifted2);\n        \n        __m128i result = _mm_or_si128(_mm_or_si128(compare1, compare2), compare3);\n        \n        if (_mm_movemask_epi8(result) != 0) {\n            return false;\n        }\n    }\n\n    for (int i = simd_length; i < n - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    int n = s.length();\n    int vectorSize = 16;  // SSE register width in bytes\n    int processedLength = n - (n % vectorSize);\n\n    // Process 16 characters at a time using SSE\n    for (int i = 0; i <= processedLength - vectorSize; i += vectorSize) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Compare each character with its neighbors\n        for (int j = 0; j <= vectorSize - 3; ++j) {\n            __m128i first = _mm_srli_si128(chars, j);\n            __m128i second = _mm_srli_si128(chars, j + 1);\n            __m128i third = _mm_srli_si128(chars, j + 2);\n\n            // Check if any 3 consecutive characters are the same\n            __m128i eq1 = _mm_cmpeq_epi8(first, second);\n            __m128i eq2 = _mm_cmpeq_epi8(first, third);\n            __m128i eq3 = _mm_cmpeq_epi8(second, third);\n\n            __m128i anyEqual = _mm_or_si128(_mm_or_si128(eq1, eq2), eq3);\n            if (_mm_movemask_epi8(anyEqual) != 0) {\n                return false;\n            }\n        }\n    }\n\n    // Process remaining characters sequentially\n    for (int i = processedLength; i < n - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    int n = s.length();\n    int vectorSize = 16;  // SSE processes 16 bytes at a time\n    \n    // Process 16-byte chunks\n    for (int i = 0; i + vectorSize <= n; i += vectorSize) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Check for consecutive duplicates\n        __m128i shifted1 = _mm_srli_si128(chunk, 1);\n        __m128i shifted2 = _mm_srli_si128(chunk, 2);\n        \n        __m128i eq1 = _mm_cmpeq_epi8(chunk, shifted1);\n        __m128i eq2 = _mm_cmpeq_epi8(chunk, shifted2);\n        __m128i eq3 = _mm_cmpeq_epi8(shifted1, shifted2);\n        \n        __m128i anyDuplicates = _mm_or_si128(_mm_or_si128(eq1, eq2), eq3);\n        \n        if (_mm_movemask_epi8(anyDuplicates) != 0) {\n            return false;\n        }\n    }\n    \n    // Handle remaining characters\n    for (int i = std::max(0, n - vectorSize); i < n - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    int len = s.length();\n    if (len < 3) return false;\n\n    // Process 16 bytes at a time using SSE2\n    int vectorLen = len - (len % 16);\n    for (int i = 0; i <= vectorLen - 16; i += 16) {\n        __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Check for duplicate bytes within 16-byte chunk\n        __m128i duplicateCheck = _mm_set1_epi8(0);\n        for (int j = 0; j < 16; j++) {\n            __m128i shifted = _mm_srli_si128(chunk, j + 1);\n            __m128i comparison = _mm_cmpeq_epi8(chunk, shifted);\n            duplicateCheck = _mm_or_si128(duplicateCheck, comparison);\n        }\n        \n        if (_mm_movemask_epi8(duplicateCheck) != 0) {\n            return false;\n        }\n    }\n\n    // Process remaining bytes\n    for (int i = vectorLen; i < len - 2; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) return false;\n\n    int n = s.length();\n    int vectorSize = 16;  // SSE processes 16 bytes at a time\n    \n    // Check first few elements before SIMD processing\n    for (int i = 0; i < std::min(3, n); i++) {\n        for (int j = i + 1; j < std::min(3, n); j++) {\n            if (s[i] == s[j]) return false;\n        }\n    }\n\n    // Process remaining string with SIMD\n    for (int i = 0; i + vectorSize <= n; i += vectorSize) {\n        __m128i chunk1 = _mm_loadu_si128((__m128i*)&s[i]);\n        __m128i chunk2 = _mm_loadu_si128((__m128i*)&s[i+1]);\n        __m128i chunk3 = _mm_loadu_si128((__m128i*)&s[i+2]);\n\n        // Compare each chunk for duplicates\n        __m128i cmp1 = _mm_cmpeq_epi8(chunk1, chunk2);\n        __m128i cmp2 = _mm_cmpeq_epi8(chunk1, chunk3);\n        __m128i cmp3 = _mm_cmpeq_epi8(chunk2, chunk3);\n\n        // Check if any comparisons are non-zero\n        if (_mm_movemask_epi8(cmp1) || \n            _mm_movemask_epi8(cmp2) || \n            _mm_movemask_epi8(cmp3)) {\n            return false;\n        }\n    }\n\n    // Check remaining elements\n    for (int i = (n / vectorSize) * vectorSize; i + 2 < n; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Handle small lengths directly\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // Use SSE2 to parallelize primality check\n    __m128i divisors = _mm_set_epi32(5, 5, 5, 5);\n    __m128i increments = _mm_set_epi32(2, 2, 2, 2);\n    __m128i max_check = _mm_set_epi32(len, len, len, len);\n\n    for (;;) {\n        // Check if divisors exceed sqrt(len)\n        __m128i compare = _mm_cmpgt_epi32(divisors, max_check);\n        int mask = _mm_movemask_epi8(compare);\n        if (mask == 0xFFFF) return true;\n\n        // Check divisibility\n        __m128i remainder1 = _mm_set_epi32(\n            len % _mm_cvtsi128_si32(divisors),\n            len % _mm_cvtsi128_si32(_mm_shuffle_epi32(divisors, _MM_SHUFFLE(1,1,1,1))),\n            len % _mm_cvtsi128_si32(_mm_shuffle_epi32(divisors, _MM_SHUFFLE(2,2,2,2))),\n            len % _mm_cvtsi128_si32(_mm_shuffle_epi32(divisors, _MM_SHUFFLE(3,3,3,3)))\n        );\n\n        __m128i zero = _mm_setzero_si128();\n        __m128i is_divisible = _mm_cmpeq_epi32(remainder1, zero);\n        if (_mm_movemask_epi8(is_divisible)) return false;\n\n        // Update divisors\n        divisors = _mm_add_epi32(divisors, increments);\n        divisors = _mm_add_epi32(divisors, increments);\n    }\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Handle small lengths directly\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0) return false;\n    \n    // Use SSE2 to parallelize primality check\n    __m128i divisors = _mm_set_epi32(3, 5, 7, 11);\n    __m128i length_vec = _mm_set1_epi32(len);\n    \n    // Check divisibility in parallel\n    __m128i compare = _mm_set1_epi32(0);\n    __m128i mod_results = _mm_set1_epi32(0);\n    \n    for (int i = 0; i < 4; i++) {\n        __m128i div = _mm_shuffle_epi32(divisors, _MM_SHUFFLE(i, i, i, i));\n        \n        // Skip if divisor is larger than length\n        if (_mm_cvtsi128_si32(div) > len) break;\n        \n        // Compute modulo\n        __m128i mod = _mm_set1_epi32(len % _mm_cvtsi128_si32(div));\n        \n        // Check if remainder is zero\n        compare = _mm_cmpeq_epi32(mod, _mm_setzero_si128());\n        mod_results = _mm_or_si128(mod_results, compare);\n    }\n    \n    // Horizontal OR to check if any divisor divides length\n    int mask = _mm_movemask_epi8(mod_results);\n    \n    return mask == 0;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    // Use SSE2 intrinsics for parallel primality check\n    __m128i divisors = _mm_setr_epi32(3, 5, 7, 11);\n    __m128i length_vec = _mm_set1_epi32(len);\n    \n    // Parallel division checks\n    __m128i zero = _mm_setzero_si128();\n    __m128i mod_results = _mm_setzero_si128();\n    \n    for (int i = 0; i < 4; i++) {\n        __m128i div = _mm_shuffle_epi32(divisors, _MM_SHUFFLE(i, i, i, i));\n        __m128i mod = _mm_rem_epi32(length_vec, div);\n        mod_results = _mm_or_si128(mod_results, mod);\n    }\n    \n    // Check if any modulo is zero\n    return _mm_movemask_epi8(_mm_cmpeq_epi32(mod_results, zero)) == 0;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // Use SSE2 to parallelize primality check\n    __m128i divisors = _mm_set_epi32(5, 5, 5, 5);\n    __m128i lengths = _mm_set1_epi32(len);\n    __m128i increments = _mm_set_epi32(2, 4, 2, 4);\n    \n    __m128i max_divisor = _mm_cvtsi32_si128((int)std::sqrt(len) + 1);\n    \n    while (_mm_cvtsi128_si32(_mm_cmpgt_epi32(max_divisor, divisors)) > 0) {\n        // Parallel modulo checks\n        __m128i mod_results = _mm_set1_epi32(0);\n        mod_results = _mm_or_si128(mod_results, _mm_cmpeq_epi32(_mm_set1_epi32(0), \n            _mm_set1_epi32(len % _mm_cvtsi128_si32(divisors))));\n        \n        // If any division results in zero remainder, not prime\n        if (_mm_movemask_epi8(mod_results) != 0) {\n            return false;\n        }\n        \n        // Increment divisors\n        divisors = _mm_add_epi32(divisors, increments);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3 || len == 5 || len == 7) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // Use SSE2 intrinsics for parallel primality check\n    __m128i limit = _mm_set1_epi32(len);\n    __m128i divisors = _mm_setr_epi32(5, 7, 11, 13);\n    __m128i increment = _mm_set1_epi32(6);\n    __m128i zero = _mm_setzero_si128();\n    __m128i match = _mm_setzero_si128();\n\n    for (int i = 0; i < 4; i++) {\n        __m128i current_div = divisors;\n        __m128i squared_div = _mm_mul_epi32(current_div, current_div);\n        \n        while (_mm_cvtsi128_si32(_mm_cmpgt_epi32(limit, squared_div)) != 0) {\n            __m128i remainder = _mm_setzero_si128();\n            \n            // Parallel modulo operation\n            for (int j = 0; j < 4; j++) {\n                __m128i mod = _mm_div_epi32(limit, current_div);\n                mod = _mm_mul_epi32(mod, current_div);\n                mod = _mm_sub_epi32(limit, mod);\n                \n                remainder = _mm_or_si128(remainder, _mm_cmpeq_epi32(mod, zero));\n                current_div = _mm_add_epi32(current_div, increment);\n                squared_div = _mm_mul_epi32(current_div, current_div);\n            }\n            \n            match = _mm_or_si128(match, remainder);\n        }\n    }\n\n    // Check if any divisor was found\n    return _mm_movemask_epi8(match) == 0;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Initialize sum of digits\n    int digit_sum = 0;\n    \n    // Extract digits using SSE parallel processing\n    while (N > 0) {\n        // Use SSE to process multiple digits simultaneously\n        __m128i digits = _mm_set_epi64x(0, N);\n        __m128i mod_10 = _mm_set1_epi64x(10);\n        \n        // Extract last digit using modulo operation\n        __m128i last_digit = _mm_rem_epi64(digits, mod_10);\n        \n        // Add last digit to sum\n        digit_sum += _mm_cvtsi128_si32(last_digit);\n        \n        // Integer division by 10\n        N /= 10;\n    }\n    \n    // Convert digit sum to binary string\n    std::string binary;\n    while (digit_sum > 0) {\n        binary = std::to_string(digit_sum % 2) + binary;\n        digit_sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Initialize sum of digits\n    uint64_t digit_sum = 0;\n\n    // Use SSE2 intrinsics to parallelize digit extraction\n    __m128i zero = _mm_setzero_si128();\n    __m128i num = _mm_set1_epi64x(N);\n\n    // Extract and sum digits\n    while (N > 0) {\n        // Extract last digit using modulo 10\n        __m128i digit = _mm_and_si128(num, _mm_set1_epi64x(9));\n        digit_sum += _mm_cvtsi128_si32(digit);\n\n        // Integer division by 10\n        N /= 10;\n        num = _mm_set1_epi64x(N);\n    }\n\n    // Convert digit sum to binary string\n    std::string binary;\n    while (digit_sum > 0) {\n        binary = std::to_string(digit_sum % 2) + binary;\n        digit_sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Initialize sum of digits\n    uint64_t digit_sum = 0;\n\n    // Use SSE2 intrinsics to parallelize digit extraction\n    __m128i zero = _mm_setzero_si128();\n    __m128i num = _mm_set1_epi64x(N);\n\n    // Extract and sum digits\n    while (N > 0) {\n        // Extract last digit using modulo 10\n        __m128i digit = _mm_and_si128(num, _mm_set1_epi64x(9));\n        \n        // Add digit to sum\n        digit_sum += _mm_cvtsi128_si32(digit);\n\n        // Divide number by 10\n        N /= 10;\n        num = _mm_set1_epi64x(N);\n    }\n\n    // Convert sum to binary string\n    std::string binary;\n    while (digit_sum > 0) {\n        binary = std::to_string(digit_sum % 2) + binary;\n        digit_sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Initialize sum of digits\n    int digit_sum = 0;\n\n    // Use SSE2 to parallelize digit extraction\n    __m128i zero = _mm_setzero_si128();\n    __m128i num = _mm_set1_epi64x(N);\n\n    // Extract and sum digits\n    while (N > 0) {\n        // Extract last digit using modulo 10\n        int digit = N % 10;\n        digit_sum += digit;\n        N /= 10;\n    }\n\n    // Convert sum to binary string\n    std::string binary;\n    while (digit_sum > 0) {\n        binary = std::to_string(digit_sum % 2) + binary;\n        digit_sum /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Initialize sum of digits\n    uint64_t digit_sum = 0;\n    \n    // Extract digits using SSE2 parallel division and modulo operations\n    __m128i zero = _mm_setzero_si128();\n    __m128i ten = _mm_set1_epi64x(10);\n    \n    while (N > 0) {\n        // Extract digit using parallel division\n        __m128i n_vec = _mm_set1_epi64x(N);\n        __m128i div_result = _mm_div_epu64(n_vec, ten);\n        __m128i mod_result = _mm_sub_epi64(n_vec, _mm_mul_epu32(div_result, ten));\n        \n        // Add digit to sum\n        uint64_t digit = _mm_cvtsi128_si64(mod_result);\n        digit_sum += digit;\n        \n        // Update N for next iteration\n        N /= 10;\n    }\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (digit_sum > 0) {\n        binary = std::to_string(digit_sum % 2) + binary;\n        digit_sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 1; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Mask to select odd indices\n        __m128i mask = _mm_set_epi32(0x0, 0xFFFFFFFF, 0x0, 0xFFFFFFFF);\n        vec = _mm_and_si128(vec, mask);\n        \n        // Check for even elements\n        __m128i evenMask = _mm_set1_epi32(0x1);\n        vec = _mm_and_si128(vec, evenMask);\n        \n        // Horizontal sum\n        vec = _mm_hadd_epi32(vec, vec);\n        vec = _mm_hadd_epi32(vec, vec);\n        \n        result += _mm_cvtsi128_si32(vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 1; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for odd indices and even elements\n        __m128i mask_indices = _mm_set_epi32(0, -1, 0, -1);\n        __m128i mask_even = _mm_set_epi32(0, 0xFFFFFFFF, 0, 0xFFFFFFFF);\n        \n        // Apply masks\n        __m128i filtered = _mm_and_si128(vec, mask_indices);\n        filtered = _mm_and_si128(filtered, mask_even);\n        \n        // Horizontal sum\n        __m128i sum = _mm_hadd_epi32(filtered, filtered);\n        sum = _mm_hadd_epi32(sum, sum);\n        \n        result += _mm_cvtsi128_si32(sum);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 1; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Mask to select elements at odd indices\n        __m128i mask = _mm_set_epi32(0x0, 0xFFFFFFFF, 0x0, 0xFFFFFFFF);\n        vec = _mm_and_si128(vec, mask);\n        \n        // Check for even elements\n        __m128i zero = _mm_setzero_si128();\n        __m128i even_mask = _mm_cmpeq_epi32(_mm_and_si128(vec, _mm_set1_epi32(1)), zero);\n        vec = _mm_and_si128(vec, even_mask);\n        \n        // Horizontal sum\n        vec = _mm_hadd_epi32(vec, vec);\n        vec = _mm_hadd_epi32(vec, vec);\n        \n        result += _mm_cvtsi128_si32(vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using SSE\n    int simd_size = size - (size % 4);\n    __m128i sum_vec = _mm_setzero_si128();\n\n    for (int i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for odd indices\n        __m128i indices = _mm_setr_epi32(1, 3, 5, 7);\n        __m128i mask = _mm_cmpeq_epi32(_mm_and_si128(indices, _mm_set1_epi32(1)), _mm_set1_epi32(1));\n        \n        // Select elements at odd indices\n        __m128i odd_indices_vec = _mm_blendv_epi8(_mm_setzero_si128(), vec, mask);\n        \n        // Keep only even elements\n        __m128i even_mask = _mm_cmpeq_epi32(_mm_and_si128(odd_indices_vec, _mm_set1_epi32(1)), _mm_setzero_si128());\n        __m128i even_vec = _mm_and_si128(odd_indices_vec, even_mask);\n        \n        sum_vec = _mm_add_epi32(sum_vec, even_vec);\n    }\n\n    // Horizontal sum of vector\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    __m128i sum_low = _mm_add_epi32(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_low, 4);\n    sum_low = _mm_add_epi32(sum_low, sum_high);\n    \n    result += _mm_cvtsi128_si32(sum_low);\n\n    // Process remaining elements\n    for (int i = simd_size; i < size; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n\n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 1; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for odd indices and even elements\n        __m128i mask_indices = _mm_set_epi32(0, -1, 0, -1);\n        __m128i mask_even = _mm_set_epi32(0, 0xFFFFFFFF, 0, 0xFFFFFFFF);\n        \n        // Apply masks\n        vec = _mm_and_si128(vec, mask_indices);\n        vec = _mm_and_si128(vec, mask_even);\n        \n        // Horizontal sum\n        vec = _mm_hadd_epi32(vec, vec);\n        vec = _mm_hadd_epi32(vec, vec);\n        \n        result += _mm_cvtsi128_si32(vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Separate lowercase and uppercase letters\n        __m128i lowercase_mask = _mm_set1_epi8(0x20);\n        __m128i is_lowercase = _mm_and_si128(chars, lowercase_mask);\n        \n        // Remove case information\n        __m128i base_chars = _mm_and_si128(chars, _mm_set1_epi8(0xDF));\n        \n        // Check if character is a letter (A-Z)\n        __m128i is_letter_mask = _mm_and_si128(\n            _mm_cmpgt_epi8(base_chars, _mm_set1_epi8('A' - 1)),\n            _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), base_chars)\n        );\n        \n        // Rotate letters by 4 (2 * 2)\n        __m128i rotated = _mm_add_epi8(base_chars, _mm_set1_epi8(4));\n        \n        // Wrap around if past 'Z'\n        __m128i wrap_mask = _mm_cmpgt_epi8(rotated, _mm_set1_epi8('Z'));\n        __m128i wrapped = _mm_sub_epi8(rotated, _mm_and_si128(wrap_mask, _mm_set1_epi8(26)));\n        \n        // Restore original case\n        __m128i final_chars = _mm_or_si128(wrapped, is_lowercase);\n        \n        // Apply letter mask\n        final_chars = _mm_or_si128(\n            _mm_and_si128(final_chars, is_letter_mask),\n            _mm_andnot_si128(is_letter_mask, chars)\n        );\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), final_chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Separate lowercase and uppercase processing\n        __m128i lowercase_mask = _mm_set1_epi8(0x7F);\n        __m128i lowercase_base = _mm_set1_epi8('a');\n        __m128i uppercase_base = _mm_set1_epi8('A');\n        \n        // Shift lowercase letters\n        __m128i shifted_lowercase = _mm_add_epi8(chars, _mm_set1_epi8(4));\n        shifted_lowercase = _mm_and_si128(shifted_lowercase, lowercase_mask);\n        \n        // Wrap around if shifted beyond 'z'\n        __m128i wrap_mask = _mm_cmpgt_epi8(shifted_lowercase, _mm_set1_epi8('z'));\n        __m128i wrapped_lowercase = _mm_sub_epi8(shifted_lowercase, _mm_and_si128(wrap_mask, _mm_set1_epi8(26)));\n        \n        // Combine shifted lowercase with non-letter characters\n        __m128i is_lowercase = _mm_and_si128(_mm_cmpge_epi8(chars, lowercase_base), _mm_cmpgt_epi8(_mm_set1_epi8('z'), chars));\n        __m128i encrypted_chars = _mm_blendv_epi8(chars, wrapped_lowercase, is_lowercase);\n        \n        // Store encrypted characters back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), encrypted_chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Separate lowercase and uppercase letters\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i is_lower = _mm_and_si128(chars, lower_mask);\n        \n        // Remove case information\n        __m128i base_chars = _mm_and_si128(chars, _mm_set1_epi8(0xDF));\n        \n        // Check if character is a letter (A-Z or a-z)\n        __m128i is_letter = _mm_and_si128(\n            _mm_cmpgt_epi8(base_chars, _mm_set1_epi8('A' - 1)),\n            _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), base_chars)\n        );\n        \n        // Rotate letters by 4 (2 * 2)\n        __m128i rotated = _mm_add_epi8(base_chars, _mm_set1_epi8(4));\n        \n        // Wrap around if past 'Z'\n        __m128i wrap_mask = _mm_cmpgt_epi8(rotated, _mm_set1_epi8('Z'));\n        __m128i wrapped = _mm_sub_epi8(rotated, _mm_and_si128(wrap_mask, _mm_set1_epi8(26)));\n        \n        // Restore original case\n        __m128i final_chars = _mm_or_si128(wrapped, is_lower);\n        \n        // Mask with original letter check\n        final_chars = _mm_or_si128(\n            _mm_and_si128(final_chars, is_letter),\n            _mm_andnot_si128(is_letter, chars)\n        );\n        \n        // Store back to result\n        int processChars = std::min(16, len - i);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), final_chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Separate lowercase and uppercase letters\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i is_lowercase = _mm_and_si128(chars, lower_mask);\n        \n        // Remove case information\n        __m128i base_chars = _mm_and_si128(chars, _mm_set1_epi8(0xDF));\n        \n        // Check if character is a letter (A-Z)\n        __m128i is_letter = _mm_and_si128(\n            _mm_cmpgt_epi8(base_chars, _mm_set1_epi8('A' - 1)),\n            _mm_cmpgt_epi8(_mm_set1_epi8('Z' + 1), base_chars)\n        );\n        \n        // Rotate letters by 4 (2 * 2)\n        __m128i rotated = _mm_add_epi8(base_chars, _mm_set1_epi8(4));\n        \n        // Wrap around Z to A\n        __m128i wrap_mask = _mm_cmpgt_epi8(rotated, _mm_set1_epi8('Z'));\n        __m128i wrapped = _mm_sub_epi8(rotated, _mm_and_si128(wrap_mask, _mm_set1_epi8(26)));\n        \n        // Restore case\n        __m128i final_chars = _mm_or_si128(wrapped, is_lowercase);\n        \n        // Mask with original letter check\n        final_chars = _mm_or_si128(\n            _mm_and_si128(final_chars, is_letter),\n            _mm_andnot_si128(is_letter, chars)\n        );\n        \n        // Store back to result\n        int processCount = std::min(16, len - i);\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), final_chars);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Shift lowercase letters by 4 (2 * 2)\n        __m128i lower_mask = _mm_set1_epi8(0x7F);\n        __m128i a_mask = _mm_set1_epi8('a');\n        __m128i z_mask = _mm_set1_epi8('z');\n        \n        // Check if character is lowercase\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_sub_epi8(a_mask, _mm_set1_epi8(1))), \n                                          _mm_cmpgt_epi8(_mm_sub_epi8(z_mask, _mm_set1_epi8(1)), chars));\n        \n        // Rotate lowercase letters\n        __m128i rotated = _mm_add_epi8(chars, _mm_and_si128(is_lower, _mm_set1_epi8(4)));\n        \n        // Wrap around if past 'z'\n        __m128i wrap_mask = _mm_cmpgt_epi8(rotated, z_mask);\n        __m128i wrapped = _mm_sub_epi8(rotated, _mm_and_si128(wrap_mask, _mm_set1_epi8(26)));\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), wrapped);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        if (result[i] >= 'a' && result[i] <= 'z') {\n            result[i] += 4;\n            if (result[i] > 'z') {\n                result[i] -= 26;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    int len = message.length();\n    \n    // Process 16 bytes at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&message[i]));\n        \n        // Swap case\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i case_swapped = _mm_xor_si128(chars, lower_mask);\n        \n        // Replace vowels\n        __m128i a_mask = _mm_cmpeq_epi8(case_swapped, _mm_set1_epi8('a'));\n        __m128i e_mask = _mm_cmpeq_epi8(case_swapped, _mm_set1_epi8('e'));\n        __m128i i_mask = _mm_cmpeq_epi8(case_swapped, _mm_set1_epi8('i'));\n        __m128i o_mask = _mm_cmpeq_epi8(case_swapped, _mm_set1_epi8('o'));\n        __m128i u_mask = _mm_cmpeq_epi8(case_swapped, _mm_set1_epi8('u'));\n        \n        __m128i vowel_mask = _mm_or_si128(_mm_or_si128(_mm_or_si128(a_mask, e_mask), _mm_or_si128(i_mask, o_mask)), u_mask);\n        \n        __m128i replacement = _mm_add_epi8(case_swapped, _mm_and_si128(vowel_mask, _mm_set1_epi8(2)));\n        \n        // Blend original and replaced characters\n        __m128i encoded = _mm_blendv_epi8(case_swapped, replacement, vowel_mask);\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), encoded);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = result[i];\n        if (islower(c)) {\n            result[i] = toupper(c);\n        } else if (isupper(c)) {\n            result[i] = tolower(c);\n        }\n        \n        c = toupper(result[i]);\n        if (c == 'A') result[i] = 'C';\n        else if (c == 'E') result[i] = 'G';\n        else if (c == 'I') result[i] = 'K';\n        else if (c == 'O') result[i] = 'Q';\n        else if (c == 'U') result[i] = 'W';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    int len = message.length();\n    \n    // Process 16 bytes at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&message[i]));\n        \n        // Swap case\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i swapped_case = _mm_xor_si128(chars, lower_mask);\n        \n        // Replace vowels\n        __m128i vowels_a = _mm_set1_epi8('a');\n        __m128i vowels_e = _mm_set1_epi8('e');\n        __m128i vowels_i = _mm_set1_epi8('i');\n        __m128i vowels_o = _mm_set1_epi8('o');\n        __m128i vowels_u = _mm_set1_epi8('u');\n        \n        __m128i vowel_replace_a = _mm_set1_epi8('c');\n        __m128i vowel_replace_e = _mm_set1_epi8('g');\n        __m128i vowel_replace_i = _mm_set1_epi8('k');\n        __m128i vowel_replace_o = _mm_set1_epi8('q');\n        __m128i vowel_replace_u = _mm_set1_epi8('w');\n        \n        __m128i is_vowel_a = _mm_cmpeq_epi8(swapped_case, vowels_a);\n        __m128i is_vowel_e = _mm_cmpeq_epi8(swapped_case, vowels_e);\n        __m128i is_vowel_i = _mm_cmpeq_epi8(swapped_case, vowels_i);\n        __m128i is_vowel_o = _mm_cmpeq_epi8(swapped_case, vowels_o);\n        __m128i is_vowel_u = _mm_cmpeq_epi8(swapped_case, vowels_u);\n        \n        swapped_case = _mm_blendv_epi8(swapped_case, vowel_replace_a, is_vowel_a);\n        swapped_case = _mm_blendv_epi8(swapped_case, vowel_replace_e, is_vowel_e);\n        swapped_case = _mm_blendv_epi8(swapped_case, vowel_replace_i, is_vowel_i);\n        swapped_case = _mm_blendv_epi8(swapped_case, vowel_replace_o, is_vowel_o);\n        swapped_case = _mm_blendv_epi8(swapped_case, vowel_replace_u, is_vowel_u);\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), swapped_case);\n    }\n    \n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; ++i) {\n        char c = result[i];\n        if (islower(c)) {\n            result[i] = toupper(c);\n        } else if (isupper(c)) {\n            result[i] = tolower(c);\n        }\n        \n        switch (tolower(c)) {\n            case 'a': result[i] = 'c'; break;\n            case 'e': result[i] = 'g'; break;\n            case 'i': result[i] = 'k'; break;\n            case 'o': result[i] = 'q'; break;\n            case 'u': result[i] = 'w'; break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    int len = message.length();\n    \n    // Process 16 bytes at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&message[i]));\n        \n        // Swap case\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i swapped_case = _mm_xor_si128(chars, lower_mask);\n        \n        // Replace vowels\n        __m128i vowels_a = _mm_set1_epi8('a');\n        __m128i vowels_e = _mm_set1_epi8('e');\n        __m128i vowels_i = _mm_set1_epi8('i');\n        __m128i vowels_o = _mm_set1_epi8('o');\n        __m128i vowels_u = _mm_set1_epi8('u');\n        \n        __m128i vowel_mask = _mm_or_si128(\n            _mm_or_si128(\n                _mm_or_si128(\n                    _mm_or_si128(\n                        _mm_cmpeq_epi8(swapped_case, vowels_a),\n                        _mm_cmpeq_epi8(swapped_case, vowels_e)\n                    ),\n                    _mm_cmpeq_epi8(swapped_case, vowels_i)\n                ),\n                _mm_cmpeq_epi8(swapped_case, vowels_o)\n            ),\n            _mm_cmpeq_epi8(swapped_case, vowels_u)\n        );\n        \n        __m128i replacement = _mm_add_epi8(swapped_case, _mm_set1_epi8(2));\n        \n        swapped_case = _mm_blendv_epi8(swapped_case, replacement, vowel_mask);\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), swapped_case);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = result[i];\n        \n        // Swap case\n        if (islower(c)) {\n            result[i] = toupper(c);\n        } else if (isupper(c)) {\n            result[i] = tolower(c);\n        }\n        \n        // Replace vowels\n        if (strchr(\"aeiouAEIOU\", c)) {\n            result[i] += 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    int len = message.length();\n    \n    // Process 16 bytes at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&message[i]));\n        \n        // Swap case\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i swapped_case = _mm_xor_si128(chars, lower_mask);\n        \n        // Replace vowels\n        __m128i a_mask = _mm_cmpeq_epi8(swapped_case, _mm_set1_epi8('a'));\n        __m128i e_mask = _mm_cmpeq_epi8(swapped_case, _mm_set1_epi8('e'));\n        __m128i i_mask = _mm_cmpeq_epi8(swapped_case, _mm_set1_epi8('i'));\n        __m128i o_mask = _mm_cmpeq_epi8(swapped_case, _mm_set1_epi8('o'));\n        __m128i u_mask = _mm_cmpeq_epi8(swapped_case, _mm_set1_epi8('u'));\n        \n        __m128i a_replace = _mm_and_si128(a_mask, _mm_set1_epi8('c'));\n        __m128i e_replace = _mm_and_si128(e_mask, _mm_set1_epi8('g'));\n        __m128i i_replace = _mm_and_si128(i_mask, _mm_set1_epi8('k'));\n        __m128i o_replace = _mm_and_si128(o_mask, _mm_set1_epi8('q'));\n        __m128i u_replace = _mm_and_si128(u_mask, _mm_set1_epi8('w'));\n        \n        __m128i vowel_replace = _mm_or_si128(_mm_or_si128(_mm_or_si128(_mm_or_si128(a_replace, e_replace), i_replace), o_replace), u_replace);\n        \n        __m128i final_chars = _mm_or_si128(_mm_andnot_si128(_mm_or_si128(_mm_or_si128(_mm_or_si128(_mm_or_si128(a_mask, e_mask), i_mask), o_mask), u_mask), swapped_case), vowel_replace);\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), final_chars);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = result[i];\n        if (islower(c)) {\n            result[i] = toupper(c);\n        } else if (isupper(c)) {\n            result[i] = tolower(c);\n        }\n        \n        switch (tolower(c)) {\n            case 'a': result[i] = 'c'; break;\n            case 'e': result[i] = 'g'; break;\n            case 'i': result[i] = 'k'; break;\n            case 'o': result[i] = 'q'; break;\n            case 'u': result[i] = 'w'; break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    int len = message.length();\n    \n    // Process 16 bytes at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&message[i]));\n        \n        // Swap case\n        __m128i lower_mask = _mm_set1_epi8(0x20);\n        __m128i swapped_case = _mm_xor_si128(chars, lower_mask);\n        \n        // Replace vowels\n        __m128i vowels_a = _mm_set1_epi8('a');\n        __m128i vowels_e = _mm_set1_epi8('e');\n        __m128i vowels_i = _mm_set1_epi8('i');\n        __m128i vowels_o = _mm_set1_epi8('o');\n        __m128i vowels_u = _mm_set1_epi8('u');\n        \n        __m128i vowel_mask = _mm_or_si128(\n            _mm_or_si128(\n                _mm_or_si128(\n                    _mm_or_si128(\n                        _mm_cmpeq_epi8(swapped_case, vowels_a),\n                        _mm_cmpeq_epi8(swapped_case, vowels_e)\n                    ),\n                    _mm_cmpeq_epi8(swapped_case, vowels_i)\n                ),\n                _mm_cmpeq_epi8(swapped_case, vowels_o)\n            ),\n            _mm_cmpeq_epi8(swapped_case, vowels_u)\n        );\n        \n        __m128i replacement = _mm_add_epi8(swapped_case, _mm_set1_epi8(2));\n        \n        swapped_case = _mm_blendv_epi8(swapped_case, replacement, vowel_mask);\n        \n        // Store back to result\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), swapped_case);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        char c = result[i];\n        \n        // Swap case\n        if (islower(c)) {\n            result[i] = toupper(c);\n        } else if (isupper(c)) {\n            result[i] = tolower(c);\n        }\n        \n        // Replace vowels\n        c = result[i];\n        if (strchr(\"aeiouAEIOU\", c)) {\n            result[i] += 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Use SSE2 intrinsics to process multiple characters in parallel\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 bytes at a time using SSE2\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&key[i]));\n            \n            // Check for lowercase\n            __m128i lower_mask = _mm_set1_epi8('a');\n            __m128i upper_mask = _mm_set1_epi8('z');\n            __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chars, lower_mask - 1), \n                                              _mm_cmpgt_epi8(upper_mask + 1, chars));\n            \n            // Check for uppercase\n            lower_mask = _mm_set1_epi8('A');\n            upper_mask = _mm_set1_epi8('Z');\n            __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(chars, lower_mask - 1), \n                                              _mm_cmpgt_epi8(upper_mask + 1, chars));\n            \n            // Horizontal OR to check if all are lowercase or uppercase\n            int lower_mask_int = _mm_movemask_epi8(is_lower);\n            int upper_mask_int = _mm_movemask_epi8(is_upper);\n            \n            if (lower_mask_int != 0xFFFF) all_lower = false;\n            if (upper_mask_int != 0xFFFF) all_upper = false;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!(c >= 'a' && c <= 'z')) all_lower = false;\n            if (!(c >= 'A' && c <= 'Z')) all_upper = false;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Prepare SSE registers\n    __m128i lower_mask = _mm_set1_epi8(0x20);  // Bit mask to convert to lowercase\n    __m128i zero_mask = _mm_setzero_si128();   // Zero mask for comparison\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in 16-byte chunks using SSE\n        for (size_t i = 0; i < key.length(); i += 16) {\n            size_t chunk_size = std::min(size_t(16), key.length() - i);\n            \n            // Load 16 bytes of key\n            __m128i key_chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(key.data() + i));\n            \n            // Check lowercase\n            __m128i lower_key = _mm_or_si128(key_chunk, lower_mask);\n            __m128i is_lower = _mm_cmpeq_epi8(key_chunk, lower_key);\n            if (_mm_movemask_epi8(is_lower) != 0xFFFF) {\n                all_lower = false;\n            }\n            \n            // Check uppercase \n            __m128i upper_key = _mm_andnot_si128(lower_mask, key_chunk);\n            __m128i is_upper = _mm_cmpeq_epi8(key_chunk, upper_key);\n            if (_mm_movemask_epi8(is_upper) != 0xFFFF) {\n                all_upper = false;\n            }\n            \n            // Early exit if not all lower or upper\n            if (!all_lower && !all_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Prepare SSE registers for parallel processing\n    __m128i lower_mask = _mm_set1_epi8(0x20);  // Bit mask to convert to lowercase\n    __m128i zero_mask = _mm_setzero_si128();   // Zero mask for comparison\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in 16-byte chunks using SSE\n        for (size_t i = 0; i < key.length(); i += 16) {\n            __m128i chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&key[i]));\n            \n            // Check if any character is not lowercase\n            __m128i lowercase_chunk = _mm_or_si128(chunk, lower_mask);\n            __m128i is_not_lowercase = _mm_cmpgt_epi8(chunk, lowercase_chunk);\n            if (_mm_movemask_epi8(is_not_lowercase) != 0) {\n                all_lower = false;\n            }\n\n            // Check if any character is not uppercase\n            __m128i uppercase_chunk = _mm_andnot_si128(lower_mask, chunk);\n            __m128i is_not_uppercase = _mm_cmpgt_epi8(uppercase_chunk, zero_mask);\n            if (_mm_movemask_epi8(is_not_uppercase) != 0) {\n                all_upper = false;\n            }\n\n            // Early exit if both conditions are false\n            if (!all_lower && !all_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Prepare SSE registers for parallel processing\n    __m128i lower_mask = _mm_set1_epi8(0x20);  // Bit mask to convert to lowercase\n    __m128i zero_mask = _mm_setzero_si128();   // Zero mask for comparison\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in 16-byte chunks using SSE\n        for (size_t i = 0; i < key.length(); i += 16) {\n            size_t chunk_size = std::min(size_t(16), key.length() - i);\n            \n            // Load 16 bytes of key into SSE register\n            __m128i key_chunk = _mm_loadu_si128(reinterpret_cast<const __m128i*>(key.data() + i));\n            \n            // Check lowercase\n            __m128i lower_key = _mm_or_si128(key_chunk, lower_mask);\n            __m128i is_lower = _mm_cmpeq_epi8(lower_key, key_chunk);\n            if (_mm_movemask_epi8(is_lower) != 0xFFFF) {\n                all_lower = false;\n            }\n            \n            // Check uppercase\n            __m128i upper_key = _mm_andnot_si128(lower_mask, key_chunk);\n            __m128i is_upper = _mm_cmpeq_epi8(upper_key, key_chunk);\n            if (_mm_movemask_epi8(is_upper) != 0xFFFF) {\n                all_upper = false;\n            }\n            \n            // Early exit if not all lower or upper\n            if (!all_lower && !all_upper) return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Use SSE2 to process multiple characters in parallel\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process 16 characters at a time using SSE2\n        size_t i = 0;\n        for (; i + 16 <= key.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&key[i]));\n            \n            // Check for lowercase\n            __m128i lower_mask = _mm_set1_epi8('a');\n            __m128i upper_mask = _mm_set1_epi8('z');\n            __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chars, lower_mask - 1), \n                                             _mm_cmpgt_epi8(upper_mask + 1, chars));\n            \n            // Check for uppercase\n            lower_mask = _mm_set1_epi8('A');\n            upper_mask = _mm_set1_epi8('Z');\n            __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(chars, lower_mask - 1), \n                                             _mm_cmpgt_epi8(upper_mask + 1, chars));\n            \n            // Horizontal OR to check if all are lowercase or uppercase\n            int lower_result = _mm_movemask_epi8(is_lower);\n            int upper_result = _mm_movemask_epi8(is_upper);\n            \n            if (lower_result != 0xFFFF) all_lower = false;\n            if (upper_result != 0xFFFF) all_upper = false;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            if (!((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'))) return false;\n            \n            if (c >= 'a' && c <= 'z') all_upper = false;\n            if (c >= 'A' && c <= 'Z') all_lower = false;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SSE2 for parallel sieving\n    for (int i = 2; i * i < n; i += 4) {\n        __m128i vec_i = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        for (int j = 2; j * j < n; j++) {\n            __m128i vec_j = _mm_set1_epi32(j);\n            __m128i vec_multiples = _mm_mullo_epi32(vec_j, vec_i);\n            \n            for (int k = 0; k < 4; k++) {\n                int multiple = _mm_cvtsi128_si32(_mm_srli_si128(vec_multiples, k * 4));\n                if (multiple < n) {\n                    is_prime[multiple] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SSE2 for parallel boolean marking\n    for (int i = 2; i * i < n; i += 4) {\n        __m128i vec_i = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        for (int j = 2; j * j < n; j++) {\n            __m128i vec_j = _mm_set1_epi32(j);\n            __m128i vec_multiples = _mm_mullo_epi32(vec_j, vec_i);\n            \n            for (int k = 0; k < 4; k++) {\n                int multiple = _mm_cvtsi128_si32(_mm_srli_si128(vec_multiples, k * 4));\n                if (multiple < n) {\n                    is_prime[multiple] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SSE2 intrinsics for parallel sieving\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            // Parallel marking of non-primes\n            __m128i vec_i = _mm_set1_epi32(i);\n            for (int j = i * i; j < n; j += 4 * i) {\n                __m128i vec_j = _mm_set_epi32(j + 3*i, j + 2*i, j + i, j);\n                __m128i mask = _mm_cmpgt_epi32(vec_j, _mm_set1_epi32(n-1));\n                vec_j = _mm_andnot_si128(mask, vec_j);\n\n                for (int k = 0; k < 4; k++) {\n                    int idx = _mm_cvtsi128_si32(_mm_srli_si128(vec_j, k * 4));\n                    if (idx < n) is_prime[idx] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) primes.push_back(i);\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SSE2 for parallel boolean marking\n    for (int i = 2; i * i < n; i += 4) {\n        __m128i vec_i = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        for (int j = 2; j * j < n; j++) {\n            __m128i vec_j = _mm_set1_epi32(j);\n            __m128i vec_multiples = _mm_mullo_epi32(vec_i, vec_j);\n            \n            int multiples[4];\n            _mm_storeu_si128((__m128i*)multiples, vec_multiples);\n            \n            for (int k = 0; k < 4; k++) {\n                if (multiples[k] < n) {\n                    is_prime[multiples[k]] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    // Use SSE2 for parallel boolean marking\n    for (int i = 2; i * i < n; i += 4) {\n        __m128i vec_i = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        for (int j = 2; j * j < n; j++) {\n            __m128i vec_j = _mm_set1_epi32(j);\n            __m128i vec_multiples = _mm_mullo_epi32(vec_j, vec_i);\n            \n            for (int k = 0; k < 4; k++) {\n                int multiple = _mm_cvtsi128_si32(_mm_srli_si128(vec_multiples, k * 4));\n                if (multiple < n) {\n                    is_prime[multiple] = false;\n                }\n            }\n        }\n    }\n\n    // Collect primes\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Check even indices\n        __m128i mask = _mm_set1_epi8(0x01);\n        __m128i even_indices = _mm_cmpeq_epi8(_mm_and_si128(_mm_set1_epi8(i), mask), _mm_setzero_si128());\n        \n        // Mask for uppercase vowels: A(65), E(69), I(73), O(79), U(85)\n        __m128i upper_vowels = _mm_or_si128(\n            _mm_or_si128(\n                _mm_or_si128(\n                    _mm_cmpeq_epi8(chars, _mm_set1_epi8('A')),\n                    _mm_cmpeq_epi8(chars, _mm_set1_epi8('E'))\n                ),\n                _mm_or_si128(\n                    _mm_cmpeq_epi8(chars, _mm_set1_epi8('I')),\n                    _mm_cmpeq_epi8(chars, _mm_set1_epi8('O'))\n                )\n            ),\n            _mm_cmpeq_epi8(chars, _mm_set1_epi8('U'))\n        );\n        \n        // Combine masks\n        __m128i combined_mask = _mm_and_si128(even_indices, upper_vowels);\n        \n        // Count matching bytes\n        combined_mask = _mm_and_si128(combined_mask, _mm_cmpgt_epi8(chars, _mm_set1_epi8(64)));\n        combined_mask = _mm_and_si128(combined_mask, _mm_cmplt_epi8(chars, _mm_set1_epi8(91)));\n        \n        // Horizontal sum\n        __m128i sum = _mm_sad_epu8(combined_mask, _mm_setzero_si128());\n        result += _mm_cvtsi128_si32(sum) + _mm_cvtsi128_si32(_mm_srli_si128(sum, 8));\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i += 2) {\n        if (i < len && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Create masks for even indices\n        __m128i indices = _mm_set_epi8(\n            0x80, 14, 0x80, 12, 0x80, 10, 0x80, 8,\n            0x80, 6, 0x80, 4, 0x80, 2, 0x80, 0\n        );\n        \n        __m128i evenChars = _mm_shuffle_epi8(chars, indices);\n        \n        // Check for uppercase vowels: A, E, I, O, U\n        __m128i vowels = _mm_set_epi8(\n            'U', 'O', 'I', 'E', 'A', 0, 0, 0,\n            'U', 'O', 'I', 'E', 'A', 0, 0, 0\n        );\n        \n        __m128i upperMask = _mm_set1_epi8(0xDF); // Mask to convert to uppercase\n        evenChars = _mm_and_si128(evenChars, upperMask);\n        \n        __m128i matchMask = _mm_cmpeq_epi8(evenChars, vowels);\n        int mask = _mm_movemask_epi8(matchMask);\n        \n        result += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining characters\n    for (int i = 0; i < len; i += 2) {\n        if (i < len && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Create masks for even indices\n        __m128i indices = _mm_set_epi8(\n            0x0F, 0x0D, 0x0B, 0x09, 0x07, 0x05, 0x03, 0x01,\n            0x0E, 0x0C, 0x0A, 0x08, 0x06, 0x04, 0x02, 0x00\n        );\n        \n        __m128i even_chars = _mm_shuffle_epi8(chars, indices);\n        \n        // Check for uppercase vowels (A, E, I, O, U)\n        __m128i vowels_a = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8('A'));\n        __m128i vowels_e = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8('E'));\n        __m128i vowels_i = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8('I'));\n        __m128i vowels_o = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8('O'));\n        __m128i vowels_u = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8('U'));\n        \n        __m128i vowels = _mm_or_si128(\n            _mm_or_si128(vowels_a, vowels_e),\n            _mm_or_si128(\n                _mm_or_si128(vowels_i, vowels_o),\n                vowels_u\n            )\n        );\n        \n        // Count the number of uppercase vowels\n        int mask = _mm_movemask_epi8(vowels);\n        result += __builtin_popcount(mask);\n        \n        // Break if we've processed all characters\n        if (i + 16 >= len) break;\n    }\n    \n    // Handle remaining characters\n    for (int i = 0; i < len; i += 2) {\n        if (i < len && s[i] >= 'A' && s[i] <= 'Z' && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    int i;\n    for (i = 0; i <= len - 16; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(s.data() + i));\n        \n        // Create masks for even indices\n        __m128i even_indices = _mm_set_epi8(\n            0, 14, 0, 12, 0, 10, 0, 8, \n            0, 6, 0, 4, 0, 2, 0, 0\n        );\n        \n        // Shuffle to get only even index characters\n        __m128i even_chars = _mm_shuffle_epi8(chars, even_indices);\n        \n        // Check for uppercase vowels: A(65), E(69), I(73), O(79), U(85)\n        __m128i vowel_mask = _mm_set_epi8(\n            0, 0, 0, 0, 0, 0, 0, 0,\n            0, 0, 0, 0, 0, 0, 0, 0\n        );\n        \n        // Check for A\n        __m128i a_mask = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8(65));\n        vowel_mask = _mm_or_si128(vowel_mask, a_mask);\n        \n        // Check for E\n        __m128i e_mask = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8(69));\n        vowel_mask = _mm_or_si128(vowel_mask, e_mask);\n        \n        // Check for I\n        __m128i i_mask = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8(73));\n        vowel_mask = _mm_or_si128(vowel_mask, i_mask);\n        \n        // Check for O\n        __m128i o_mask = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8(79));\n        vowel_mask = _mm_or_si128(vowel_mask, o_mask);\n        \n        // Check for U\n        __m128i u_mask = _mm_cmpeq_epi8(even_chars, _mm_set1_epi8(85));\n        vowel_mask = _mm_or_si128(vowel_mask, u_mask);\n        \n        // Count the number of set bits\n        result += _mm_popcnt_u32(_mm_movemask_epi8(vowel_mask));\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i += 2) {\n        if (i < len && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            result++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time using SSE2\n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&s[i]));\n        \n        // Create masks for even indices\n        __m128i indices = _mm_set_epi8(\n            15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n        );\n        __m128i even_mask = _mm_cmpeq_epi8(_mm_and_si128(indices, _mm_set1_epi8(1)), _mm_setzero_si128());\n        \n        // Mask characters at even indices\n        chars = _mm_and_si128(chars, even_mask);\n        \n        // Check for uppercase vowels (A, E, I, O, U)\n        __m128i vowels_upper = _mm_set_epi8(\n            'U', 'O', 'I', 'E', 'A', 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        );\n        \n        __m128i is_vowel = _mm_cmpeq_epi8(chars, _mm_set1_epi8('A')) |\n                           _mm_cmpeq_epi8(chars, _mm_set1_epi8('E')) |\n                           _mm_cmpeq_epi8(chars, _mm_set1_epi8('I')) |\n                           _mm_cmpeq_epi8(chars, _mm_set1_epi8('O')) |\n                           _mm_cmpeq_epi8(chars, _mm_set1_epi8('U'));\n        \n        // Horizontal sum of the mask\n        is_vowel = _mm_and_si128(is_vowel, even_mask);\n        int mask = _mm_movemask_epi8(is_vowel);\n        \n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining characters\n    for (int i = 0; i < len; i += 2) {\n        if (i < len && \n            (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U')) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use SSE2 intrinsics to parallelize the computation\n    __m128i current = _mm_set1_epi32(n);\n    __m128i increment = _mm_set1_epi32(n % 2 == 0 ? 2 : 1);\n    \n    for (int i = 0; i < n; i += 4) {\n        _mm_storeu_si128((__m128i*)&result[i], current);\n        \n        // Increment for next levels\n        current = _mm_add_epi32(current, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use SSE2 intrinsics to parallelize level calculation\n    __m128i current_level = _mm_set1_epi32(n);\n    \n    for (int i = 0; i < n; i += 4) {\n        // Store current level stones\n        _mm_storeu_si128((__m128i*)&result[i], current_level);\n        \n        // Compute next level stones using SSE2 arithmetic and bitwise operations\n        __m128i is_odd = _mm_and_si128(current_level, _mm_set1_epi32(1));\n        __m128i increment = _mm_add_epi32(is_odd, _mm_set1_epi32(2));\n        current_level = _mm_add_epi32(current_level, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use SSE2 intrinsics to set initial values\n    __m128i current = _mm_set1_epi32(n);\n    \n    for (int i = 0; i < n; i += 4) {\n        // Store 4 values at a time\n        _mm_storeu_si128((__m128i*)&result[i], current);\n        \n        // Increment values based on even/odd rules\n        __m128i increment = _mm_set_epi32(\n            (n + i + 3) % 2 == 0 ? 2 : 1,\n            (n + i + 2) % 2 == 0 ? 2 : 1,\n            (n + i + 1) % 2 == 0 ? 2 : 1,\n            (n + i) % 2 == 0 ? 2 : 1\n        );\n        \n        current = _mm_add_epi32(current, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use SSE2 intrinsics to parallelize the computation\n    __m128i current = _mm_set1_epi32(n);\n    \n    for (int i = 0; i < n; i += 4) {\n        // Store the current level stones\n        _mm_storeu_si128((__m128i*)&result[i], current);\n        \n        // Compute next level stones using SSE2 arithmetic and bitwise operations\n        __m128i is_even = _mm_and_si128(current, _mm_set1_epi32(1));\n        __m128i increment = _mm_sub_epi32(_mm_set1_epi32(2), is_even);\n        current = _mm_add_epi32(current, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Use SSE2 intrinsics to parallelize the computation\n    __m128i current = _mm_set1_epi32(n);\n    \n    for (int i = 0; i < n; i += 4) {\n        // Store the current level stones\n        _mm_storeu_si128((__m128i*)&result[i], current);\n        \n        // Compute next level stones using SSE2 arithmetic and bitwise operations\n        __m128i is_even = _mm_and_si128(current, _mm_set1_epi32(1));\n        __m128i increment = _mm_sub_epi32(_mm_set1_epi32(2), is_even);\n        current = _mm_add_epi32(current, increment);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using SSE2 intrinsics\n    __m128i sum_vec = _mm_setzero_si128();\n    int64_t chunk_size = 2;\n    \n    // Process numbers in chunks of 2\n    for (int64_t i = n; i <= m; i += chunk_size) {\n        __m128i current_vec = _mm_set_epi64x(i + 1, i);\n        sum_vec = _mm_add_epi64(sum_vec, current_vec);\n    }\n    \n    // Handle remaining numbers if m - n + 1 is odd\n    int64_t sum = _mm_cvtsi128_si64(sum_vec) + _mm_cvtsi128_si64(_mm_srli_si128(sum_vec, 8));\n    if ((m - n + 1) % 2 != 0) {\n        sum += m;\n    }\n    \n    // Compute rounded average\n    int64_t avg = sum / (m - n + 1);\n    \n    // Convert to binary string\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using SSE2 intrinsics\n    __m128i sum_vec = _mm_setzero_si128();\n    int64_t chunk_size = 2;\n    \n    // Process numbers in chunks of 2\n    for (int64_t i = n; i <= m; i += chunk_size) {\n        __m128i current_vec = _mm_set_epi64x(i + 1, i);\n        sum_vec = _mm_add_epi64(sum_vec, current_vec);\n    }\n    \n    // Handle remaining numbers if m - n + 1 is odd\n    int64_t sum = _mm_cvtsi128_si64(sum_vec) + _mm_cvtsi128_si64(_mm_shuffle_epi32(sum_vec, 1));\n    \n    // Add remaining number if necessary\n    if ((m - n + 1) % 2 != 0) {\n        sum += m;\n    }\n    \n    // Compute rounded average\n    int64_t avg = sum / (m - n + 1);\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using SSE2 intrinsics\n    __m128i sum_vec = _mm_setzero_si128();\n    int64_t sum = 0;\n    \n    // Process 2 integers at a time using SSE2\n    for (int64_t i = n; i <= m; i += 2) {\n        __m128i current_vec = _mm_set_epi64x(i, (i+1 <= m) ? i+1 : 0);\n        sum_vec = _mm_add_epi64(sum_vec, current_vec);\n        \n        if (i+1 > m) break;\n    }\n    \n    // Horizontal sum of vector\n    __m128i high64 = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi64(sum_vec, high64);\n    sum = _mm_cvtsi128_si64(sum_vec);\n    \n    // Compute average and round down\n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using SSE2 intrinsics\n    __m128i sum_vec = _mm_setzero_si128();\n    int64_t chunk_size = 2;\n    \n    // Process two integers at a time using SSE2\n    for (int64_t i = n; i <= m - chunk_size; i += chunk_size) {\n        __m128i current_vec = _mm_set_epi64x(i + 1, i);\n        sum_vec = _mm_add_epi64(sum_vec, current_vec);\n    }\n    \n    // Horizontal sum of SSE vector\n    int64_t sum_arr[2];\n    _mm_storeu_si128((__m128i*)sum_arr, sum_vec);\n    int64_t sum = sum_arr[0] + sum_arr[1];\n    \n    // Handle remaining integers\n    for (int64_t i = n + ((m - n + 1) / chunk_size) * chunk_size; i <= m; ++i) {\n        sum += i;\n    }\n    \n    // Compute rounded average\n    int64_t avg = (sum + (m - n + 1) / 2) / (m - n + 1);\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Compute sum using SSE2 intrinsics\n    __m128i sum_vec = _mm_setzero_si128();\n    int64_t chunk_size = 2;\n    \n    // Process pairs of numbers in parallel\n    for (int64_t i = n; i <= m; i += chunk_size) {\n        __m128i current_vec = _mm_set_epi64x(i + 1, i);\n        sum_vec = _mm_add_epi64(sum_vec, current_vec);\n    }\n    \n    // Handle remaining single number if m - n is odd\n    int64_t sum = _mm_cvtsi128_si64(sum_vec) + _mm_cvtsi128_si64(_mm_srli_si128(sum_vec, 8));\n    if ((m - n + 1) % 2 != 0) {\n        sum += m;\n    }\n    \n    // Compute rounded average\n    int64_t avg = sum / (m - n + 1);\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i+4, i+3, i+2, i+1);\n        __m128i values = _mm_setzero_si128();\n        \n        // Compute values for 4 elements simultaneously\n        for (int j = 0; j < 4; j++) {\n            int idx = _mm_cvtsi128_si32(_mm_srli_si128(indices, j * 4));\n            \n            if (idx % 2 == 0) {\n                // Factorial modulo 10000 for even indices\n                int factorial = 1;\n                for (int k = 2; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                values = _mm_insert_epi32(values, factorial, j);\n            } else {\n                // Sum of numbers from 1 to index for odd indices\n                int sum = (idx * (idx + 1)) / 2;\n                values = _mm_insert_epi32(values, sum, j);\n            }\n        }\n        \n        // Store results back to vector\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int k = 2; k <= i; k++) {\n                factorial = (factorial * k) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using SSE\n    int vectorized_size = n - (n % 4);\n    \n    for (int i = 0; i < vectorized_size; i += 4) {\n        // Load indices\n        __m128i indices = _mm_set_epi32(i+4, i+3, i+2, i+1);\n        \n        // Compute values for 4 elements simultaneously\n        __m128i values = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; ++j) {\n            int current_index = _mm_cvtsi128_si32(_mm_srli_si128(indices, j * 4));\n            \n            if (current_index % 2 == 0) {\n                // Factorial modulo 10000 for even indices\n                int factorial = 1;\n                for (int k = 2; k <= current_index; ++k) {\n                    factorial = (factorial * k) % 10000;\n                }\n                _mm_insert_epi32(values, factorial, j);\n            } else {\n                // Sum of numbers from 1 to index for odd indices\n                int sum = (current_index * (current_index + 1)) / 2;\n                _mm_insert_epi32(values, sum, j);\n            }\n        }\n        \n        // Store results back to vector\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n    \n    // Handle remaining elements sequentially\n    for (int i = vectorized_size; i < n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int k = 2; k <= i; ++k) {\n                factorial = (factorial * k) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i+4, i+3, i+2, i+1);\n        __m128i values = _mm_setzero_si128();\n        \n        // Compute values for 4 indices simultaneously\n        for (int j = 0; j < 4; j++) {\n            int idx = _mm_cvtsi128_si32(_mm_srli_si128(indices, j * 4));\n            \n            if (idx % 2 == 0) {\n                // Factorial modulo 10000 for even indices\n                int factorial = 1;\n                for (int k = 2; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                values = _mm_insert_epi32(values, factorial, j);\n            } else {\n                // Sum of numbers from 1 to index for odd indices\n                int sum = (idx * (idx + 1)) / 2;\n                values = _mm_insert_epi32(values, sum, j);\n            }\n        }\n        \n        // Store results back to vector\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int k = 2; k <= i; k++) {\n                factorial = (factorial * k) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        // Create SSE vectors for indices\n        __m128i indices = _mm_setr_epi32(i+1, i+2, i+3, i+4);\n        \n        // Compute values for 4 elements simultaneously\n        __m128i values = _mm_setzero_si128();\n        \n        // Even indices: factorial mod 10000\n        __m128i even_mask = _mm_set1_epi32(0x1);\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(indices, even_mask), _mm_setzero_si128());\n        \n        // Factorial computation\n        __m128i factorial = _mm_set1_epi32(1);\n        __m128i current_mult = _mm_set1_epi32(1);\n        \n        for (int j = 1; j <= 4; j++) {\n            current_mult = _mm_mullo_epi32(current_mult, indices);\n            current_mult = _mm_mod_epi32(current_mult, _mm_set1_epi32(10000));\n            factorial = _mm_mullo_epi32(factorial, current_mult);\n            factorial = _mm_mod_epi32(factorial, _mm_set1_epi32(10000));\n        }\n        \n        // Sum computation\n        __m128i sum = _mm_set1_epi32(0);\n        __m128i one = _mm_set1_epi32(1);\n        __m128i current_sum = one;\n        \n        for (int j = 1; j <= 4; j++) {\n            sum = _mm_add_epi32(sum, current_sum);\n            current_sum = _mm_add_epi32(current_sum, one);\n        }\n        \n        // Blend factorial and sum based on even/odd\n        values = _mm_blendv_epi8(sum, factorial, is_even);\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            // Factorial mod 10000\n            int factorial = 1;\n            for (int j = 1; j <= i+1; j++) {\n                factorial = (factorial * j) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            // Sum of numbers from 1 to i\n            int sum = 0;\n            for (int j = 1; j <= i+1; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        __m128i indices = _mm_setr_epi32(i+1, i+2, i+3, i+4);\n        __m128i values = _mm_setzero_si128();\n        \n        // Compute values for each index\n        for (int j = 0; j < 4; j++) {\n            int idx = _mm_cvtsi128_si32(_mm_srli_si128(indices, j * 4));\n            \n            if (idx % 2 == 0) {\n                // Factorial modulo 10000 for even indices\n                int factorial = 1;\n                for (int k = 2; k <= idx; k++) {\n                    factorial = (factorial * k) % 10000;\n                }\n                values = _mm_insert_epi32(values, factorial, j);\n            } else {\n                // Sum of numbers from 1 to index for odd indices\n                int sum = (idx * (idx + 1)) / 2;\n                values = _mm_insert_epi32(values, sum, j);\n            }\n        }\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int k = 2; k <= i + 1; k++) {\n                factorial = (factorial * k) % 10000;\n            }\n            result[i] = factorial;\n        } else {\n            result[i] = ((i + 1) * (i + 2)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Use SSE2 to process multiple numbers in parallel\n    __m128i zero = _mm_setzero_si128();\n    __m128i two = _mm_set1_epi32(2);\n    __m128i count_even = _mm_setzero_si128();\n    __m128i count_odd = _mm_setzero_si128();\n    \n    for (int i = 1; i <= n; i += 4) {\n        __m128i current = _mm_set_epi32(\n            (i+3 <= n) ? i+3 : 0,\n            (i+2 <= n) ? i+2 : 0,\n            (i+1 <= n) ? i+1 : 0,\n            i\n        );\n        \n        // Check palindrome\n        __m128i palindrome_mask = _mm_setzero_si128();\n        for (int j = 0; j < 4; j++) {\n            int num = _mm_cvtsi128_si32(current);\n            int reversed = 0;\n            int original = num;\n            \n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed && original != 0) {\n                // Set corresponding bit in mask\n                palindrome_mask = _mm_insert_epi32(palindrome_mask, 1 << j, j);\n                \n                // Check even/odd\n                __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(current, two), zero);\n                count_even = _mm_add_epi32(count_even, _mm_and_si128(is_even, _mm_set1_epi32(1)));\n                count_odd = _mm_add_epi32(count_odd, _mm_andnot_si128(is_even, _mm_set1_epi32(1)));\n            }\n            \n            current = _mm_srli_si128(current, 4);\n        }\n    }\n    \n    // Horizontal sum of even and odd counts\n    __m128i shuffle_mask = _mm_set_epi8(\n        15, 14, 13, 12, 11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n    );\n    \n    __m128i even_sum = _mm_sad_epu8(count_even, zero);\n    __m128i odd_sum = _mm_sad_epu8(count_odd, zero);\n    \n    even_count = _mm_cvtsi128_si32(even_sum);\n    odd_count = _mm_cvtsi128_si32(odd_sum);\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Use SSE2 intrinsics for parallel processing\n    __m128i zero = _mm_setzero_si128();\n    __m128i count_vec = _mm_setzero_si128();\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        __m128i current = _mm_set_epi32(\n            (i+3 <= n) ? i+3 : 0,\n            (i+2 <= n) ? i+2 : 0,\n            (i+1 <= n) ? i+1 : 0,\n            i\n        );\n        \n        // Palindrome check using SSE2 shuffling and comparison\n        __m128i reversed = _mm_set_epi32(\n            (i+3 <= n) ? _mm_cvtsi32_si128(((i+3)/1000 + ((i+3)%1000/100)*10 + ((i+3)%100/10)*100 + (i+3)%10*1000)) : 0,\n            (i+2 <= n) ? _mm_cvtsi32_si128(((i+2)/1000 + ((i+2)%1000/100)*10 + ((i+2)%100/10)*100 + (i+2)%10*1000)) : 0,\n            (i+1 <= n) ? _mm_cvtsi32_si128(((i+1)/1000 + ((i+1)%1000/100)*10 + ((i+1)%100/10)*100 + (i+1)%10*1000)) : 0,\n            _mm_cvtsi32_si128((i/1000 + (i%1000/100)*10 + (i%100/10)*100 + (i%10)*1000))\n        );\n        \n        // Compare original and reversed numbers\n        __m128i is_palindrome = _mm_cmpeq_epi32(current, reversed);\n        \n        // Count even and odd palindromes\n        __m128i is_even = _mm_and_si128(current, _mm_set1_epi32(1));\n        is_even = _mm_cmpeq_epi32(is_even, zero);\n        \n        // Combine palindrome and even/odd checks\n        __m128i valid_even = _mm_and_si128(is_palindrome, is_even);\n        __m128i valid_odd = _mm_and_si128(is_palindrome, _mm_andnot_si128(is_even, _mm_set1_epi32(0xFFFFFFFF)));\n        \n        // Horizontal sum of valid counts\n        __m128i even_mask = _mm_srli_epi32(valid_even, 31);\n        __m128i odd_mask = _mm_srli_epi32(valid_odd, 31);\n        \n        even_count += _mm_cvtsi128_si32(even_mask) +\n                      _mm_cvtsi128_si32(_mm_srli_si128(even_mask, 4)) +\n                      _mm_cvtsi128_si32(_mm_srli_si128(even_mask, 8)) +\n                      _mm_cvtsi128_si32(_mm_srli_si128(even_mask, 12));\n        \n        odd_count += _mm_cvtsi128_si32(odd_mask) +\n                     _mm_cvtsi128_si32(_mm_srli_si128(odd_mask, 4)) +\n                     _mm_cvtsi128_si32(_mm_srli_si128(odd_mask, 8)) +\n                     _mm_cvtsi128_si32(_mm_srli_si128(odd_mask, 12));\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Use SSE2 intrinsics for parallel processing\n    __m128i zero = _mm_setzero_si128();\n    __m128i count_vec = _mm_setzero_si128();\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        __m128i current = _mm_set_epi32(\n            (i+3 <= n) ? i+3 : 0,\n            (i+2 <= n) ? i+2 : 0, \n            (i+1 <= n) ? i+1 : 0, \n            i\n        );\n        \n        __m128i palindrome_mask = _mm_setzero_si128();\n        \n        // Check palindrome for each number\n        for (int j = 0; j < 4; j++) {\n            int num = _mm_cvtsi128_si32(current);\n            int reversed = 0;\n            int original = num;\n            \n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed && original != 0) {\n                // Set corresponding bit in mask\n                palindrome_mask = _mm_insert_epi32(palindrome_mask, 1, j);\n                \n                // Check even/odd\n                if (original % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n            \n            // Shift vector right\n            current = _mm_srli_si128(current, 4);\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0, odd_count = 0;\n    \n    // Use SSE2 intrinsics for parallel processing\n    __m128i zero = _mm_setzero_si128();\n    __m128i count_vec = _mm_setzero_si128();\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        __m128i current = _mm_set_epi32(\n            (i+3 <= n) ? i+3 : 0,\n            (i+2 <= n) ? i+2 : 0,\n            (i+1 <= n) ? i+1 : 0,\n            i\n        );\n        \n        // Palindrome check using SSE2 shuffle and comparison\n        __m128i reversed = _mm_set_epi32(\n            (i+3 <= n) ? ((i+3 % 10) * 100 + (i+3 / 10 % 10) * 10 + (i+3 % 10)) : 0,\n            (i+2 <= n) ? ((i+2 % 10) * 100 + (i+2 / 10 % 10) * 10 + (i+2 % 10)) : 0,\n            (i+1 <= n) ? ((i+1 % 10) * 100 + (i+1 / 10 % 10) * 10 + (i+1 % 10)) : 0,\n            (i % 10) * 100 + (i / 10 % 10) * 10 + (i % 10)\n        );\n        \n        // Compare if number is palindrome\n        __m128i is_palindrome = _mm_cmpeq_epi32(current, reversed);\n        \n        // Check even/odd for palindromes\n        __m128i is_even = _mm_and_si128(is_palindrome, _mm_set_epi32(\n            ((i+3 <= n) && ((i+3) % 2 == 0)) ? 0xFFFFFFFF : 0,\n            ((i+2 <= n) && ((i+2) % 2 == 0)) ? 0xFFFFFFFF : 0,\n            ((i+1 <= n) && ((i+1) % 2 == 0)) ? 0xFFFFFFFF : 0,\n            (i % 2 == 0) ? 0xFFFFFFFF : 0\n        ));\n        \n        // Horizontal add to count\n        __m128i even_mask = _mm_and_si128(is_palindrome, is_even);\n        __m128i odd_mask = _mm_andnot_si128(is_even, is_palindrome);\n        \n        // Extract and sum\n        int even_mask_arr[4], odd_mask_arr[4];\n        _mm_storeu_si128((__m128i*)even_mask_arr, even_mask);\n        _mm_storeu_si128((__m128i*)odd_mask_arr, odd_mask);\n        \n        for (int j = 0; j < 4; j++) {\n            even_count += (even_mask_arr[j] != 0);\n            odd_count += (odd_mask_arr[j] != 0);\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i even_count = _mm_setzero_si128();\n    __m128i odd_count = _mm_setzero_si128();\n    \n    // Process 4 numbers at a time using SSE\n    for (int i = 1; i <= n; i += 4) {\n        __m128i current = _mm_set_epi32(\n            (i+3 <= n) ? i+3 : 0, \n            (i+2 <= n) ? i+2 : 0, \n            (i+1 <= n) ? i+1 : 0, \n            i\n        );\n        \n        __m128i is_palindrome = _mm_setzero_si128();\n        \n        // Check palindrome for each number\n        for (int j = 0; j < 4; j++) {\n            int num = _mm_cvtsi128_si32(current);\n            int reversed = 0;\n            int original = num;\n            \n            while (num > 0) {\n                reversed = reversed * 10 + num % 10;\n                num /= 10;\n            }\n            \n            if (original == reversed && original != 0) {\n                // Set corresponding bit if palindrome\n                is_palindrome = _mm_insert_epi32(is_palindrome, 1, j);\n            }\n            \n            // Shift right to process next number\n            current = _mm_srli_si128(current, 4);\n        }\n        \n        // Count even and odd palindromes\n        __m128i even_mask = _mm_set1_epi32(0x1);\n        __m128i is_even = _mm_and_si128(is_palindrome, even_mask);\n        __m128i is_odd = _mm_andnot_si128(even_mask, is_palindrome);\n        \n        even_count = _mm_add_epi32(even_count, _mm_srli_epi32(is_even, 0));\n        odd_count = _mm_add_epi32(odd_count, _mm_srli_epi32(is_odd, 0));\n    }\n    \n    // Horizontal sum of even and odd counts\n    __m128i even_sum = _mm_add_epi32(even_count, _mm_srli_si128(even_count, 8));\n    even_sum = _mm_add_epi32(even_sum, _mm_srli_si128(even_sum, 4));\n    \n    __m128i odd_sum = _mm_add_epi32(odd_count, _mm_srli_si128(odd_count, 8));\n    odd_sum = _mm_add_epi32(odd_sum, _mm_srli_si128(odd_sum, 4));\n    \n    return {_mm_cvtsi128_si32(even_sum), _mm_cvtsi128_si32(odd_sum)};\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        \n        // Compute absolute values\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        \n        // Extract digits and compute sum\n        __m128i sum_digits = _mm_setzero_si128();\n        for (int shift = 0; shift < 32; shift += 8) {\n            __m128i digit_mask = _mm_set1_epi32(0xFF << shift);\n            __m128i digits = _mm_and_si128(_mm_srli_epi32(abs_nums, shift), digit_mask);\n            sum_digits = _mm_add_epi32(sum_digits, _mm_srli_epi32(digits, shift));\n        }\n        \n        // Compare sum of digits > 0\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpgt_epi32(sum_digits, zero);\n        int result = _mm_movemask_ps(_mm_castsi128_ps(mask));\n        \n        // Count numbers with sum of digits > 0\n        count += __builtin_popcount(result);\n    }\n    \n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = std::abs(n[i]);\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        \n        // Compute absolute values\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        \n        // Extract digits and compute sum of digits\n        __m128i digit_sums = _mm_setzero_si128();\n        for (int shift = 0; shift < 32; shift += 8) {\n            __m128i digits = _mm_srli_epi32(abs_nums, shift);\n            digits = _mm_and_si128(digits, _mm_set1_epi32(0xFF));\n            digit_sums = _mm_add_epi32(digit_sums, digits);\n        }\n        \n        // Compare digit sums > 0\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpgt_epi32(digit_sums, zero);\n        \n        // Count numbers with digit sum > 0\n        int mask_bits = _mm_movemask_ps((__m128)mask);\n        count += __builtin_popcount(mask_bits);\n    }\n    \n    // Process remaining elements\n    for (; i < size; i++) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        if (digit_sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        \n        // Compute absolute values\n        __m128i abs_mask = _mm_set1_epi32(0x7FFFFFFF);\n        __m128i abs_nums = _mm_and_si128(nums, abs_mask);\n        \n        // Compute digit sums\n        __m128i digit_sums = _mm_setzero_si128();\n        for (int shift = 0; shift < 32; shift += 8) {\n            __m128i digits = _mm_srli_epi32(abs_nums, shift);\n            digits = _mm_and_si128(digits, _mm_set1_epi32(0xFF));\n            digit_sums = _mm_add_epi32(digit_sums, digits);\n        }\n        \n        // Horizontal sum of digit sums\n        __m128i sum_lo = _mm_unpacklo_epi32(digit_sums, _mm_setzero_si128());\n        __m128i sum_hi = _mm_unpackhi_epi32(digit_sums, _mm_setzero_si128());\n        digit_sums = _mm_add_epi32(sum_lo, sum_hi);\n        \n        // Compare digit sums > 0\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpgt_epi32(digit_sums, zero);\n        int result = _mm_movemask_ps((__m128)mask);\n        \n        // Count numbers with digit sum > 0\n        count += (result & 1) + ((result >> 1) & 1) + \n                 ((result >> 2) & 1) + ((result >> 3) & 1);\n    }\n    \n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        \n        // Compute absolute values\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        \n        // Extract digits and compute digit sums\n        __m128i digit_sums = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; j++) {\n            int num = _mm_cvtsi128_si32(abs_nums);\n            int digit_sum = 0;\n            \n            while (num > 0) {\n                digit_sum += num % 10;\n                num /= 10;\n            }\n            \n            // Set corresponding bit if digit sum > 0\n            if (digit_sum > 0) {\n                digit_sums = _mm_insert_epi32(digit_sums, 1, j);\n            }\n            \n            abs_nums = _mm_srli_si128(abs_nums, 4);\n        }\n        \n        // Count number of set bits\n        count += _mm_popcnt_u32(_mm_cvtsi128_si32(digit_sums));\n    }\n    \n    // Process remaining elements\n    for (; i < size; i++) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        \n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    for (i = 0; i <= size - 4; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        \n        // Compute absolute values\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        \n        // Extract digits and compute sum of digits\n        __m128i digit_sums = _mm_setzero_si128();\n        for (int shift = 0; shift < 32; shift += 8) {\n            __m128i digits = _mm_srli_epi32(abs_nums, shift);\n            digits = _mm_and_si128(digits, _mm_set1_epi32(0xFF));\n            digit_sums = _mm_add_epi32(digit_sums, digits);\n        }\n        \n        // Compare digit sums > 0\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpgt_epi32(digit_sums, zero);\n        \n        // Count numbers with digit sum > 0\n        int mask_bits = _mm_movemask_ps((__m128)mask);\n        count += __builtin_popcount(mask_bits);\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < size; i++) {\n        int num = std::abs(n[i]);\n        int digit_sum = 0;\n        while (num > 0) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element and its index\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i compare = _mm_cmplt_epi32(current, min_vec);\n        int mask = _mm_movemask_ps((__m128)compare);\n        \n        if (mask) {\n            for (int j = 0; j < 4 && i + j < n; j++) {\n                if (mask & (1 << j)) {\n                    min_vec = _mm_set1_epi32(arr[i + j]);\n                    min_idx = i + j;\n                }\n            }\n        }\n    }\n\n    // Check if the array can be sorted by right shifts\n    for (int shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        for (int i = 0; i < n - 1; i++) {\n            if (arr[(min_idx + i + shift) % n] > arr[(min_idx + i + shift + 1) % n]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element's index\n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n\n    // Use SSE2 intrinsics to check if array can be sorted by right shifts\n    __m128i zero = _mm_setzero_si128();\n    __m128i is_sorted = _mm_set1_epi32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int remaining = std::min(4, n - i);\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i shifted = _mm_slli_si128(current, 4);\n\n        for (int j = 0; j < remaining; j++) {\n            __m128i rotated = _mm_or_si128(_mm_srli_si128(current, 4), \n                                            _mm_slli_si128(current, 12));\n            \n            // Check if rotated sequence is sorted\n            __m128i compare = _mm_cmpgt_epi32(rotated, _mm_slli_si128(rotated, 4));\n            is_sorted = _mm_and_si128(is_sorted, _mm_cmpeq_epi32(compare, zero));\n            \n            current = rotated;\n        }\n    }\n\n    // Check if the entire array can be sorted by right shifts\n    int sorted_check = _mm_movemask_epi8(is_sorted);\n    return sorted_check == 0xFFFF;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element and its index\n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i compare = _mm_cmplt_epi32(current, min_vec);\n        int mask = _mm_movemask_ps((__m128)compare);\n        \n        if (mask) {\n            for (int j = 0; j < 4 && i + j < n; j++) {\n                if (mask & (1 << j)) {\n                    min_vec = _mm_set1_epi32(arr[i + j]);\n                    min_idx = i + j;\n                }\n            }\n        }\n    }\n\n    // Rotate the array and check if it's sorted\n    std::vector<int> rotated(n);\n    for (int i = 0; i < n; i++) {\n        rotated[i] = arr[(i + n - min_idx) % n];\n    }\n\n    // Check if rotated array is sorted using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&rotated[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&rotated[i + 4]);\n        __m128i compare = _mm_cmpgt_epi32(current, next);\n        \n        if (_mm_movemask_ps((__m128)compare)) {\n            return false;\n        }\n    }\n\n    // Check remaining elements\n    for (int i = n - 4; i < n - 1; i++) {\n        if (rotated[i] > rotated[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element's index\n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n\n    // Use SSE2 to check if the array can be sorted by right shifts\n    __m128i prev_vec = _mm_setzero_si128();\n    __m128i curr_vec;\n\n    for (int shift = 0; shift < n; shift++) {\n        bool is_sorted = true;\n        \n        // Process 4 elements at a time using SSE2\n        for (int i = 0; i < n - 4 + 1; i += 4) {\n            int start_idx = (min_idx + shift) % n;\n            \n            // Load 4 consecutive elements\n            curr_vec = _mm_loadu_si128((__m128i*)&arr[(start_idx + i) % n]);\n            \n            // Compare with previous vector\n            if (i > 0) {\n                __m128i cmp = _mm_cmpgt_epi32(prev_vec, curr_vec);\n                if (_mm_movemask_epi8(cmp) != 0) {\n                    is_sorted = false;\n                    break;\n                }\n            }\n            \n            prev_vec = curr_vec;\n        }\n\n        // Check remaining elements\n        for (int i = (n / 4) * 4; i < n; i++) {\n            int prev_idx = (min_idx + shift + i - 1) % n;\n            int curr_idx = (min_idx + shift + i) % n;\n            \n            if (arr[prev_idx] > arr[curr_idx]) {\n                is_sorted = false;\n                break;\n            }\n        }\n\n        if (is_sorted) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find the minimum element's index\n    int min_idx = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n\n    // Use SSE2 to check if array can be sorted by right shifts\n    __m128i prev_vec = _mm_setzero_si128();\n    __m128i curr_vec = _mm_setzero_si128();\n\n    for (int shift = 0; shift < n; shift++) {\n        // Reset comparison flags\n        int valid = 1;\n\n        // Process 4 elements at a time using SSE2\n        for (int i = 0; i < n; i += 4) {\n            // Load 4 consecutive elements\n            int remaining = std::min(4, n - i);\n            if (remaining == 4) {\n                curr_vec = _mm_loadu_si128((__m128i*)&arr[(i + min_idx + shift) % n]);\n                prev_vec = _mm_loadu_si128((__m128i*)&arr[(i + min_idx + shift - 1) % n]);\n\n                // Check if current elements are greater or equal to previous\n                __m128i cmp = _mm_cmpgt_epi32(curr_vec, prev_vec);\n                if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                    valid = 0;\n                    break;\n                }\n            } else {\n                // Handle remaining elements with scalar comparison\n                for (int j = 0; j < remaining; j++) {\n                    if (arr[(i + j + min_idx + shift) % n] < \n                        arr[(i + j + min_idx + shift - 1) % n]) {\n                        valid = 0;\n                        break;\n                    }\n                }\n                if (!valid) break;\n            }\n        }\n\n        // If all elements are in non-decreasing order, return true\n        if (valid) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, odd_count2 = 0;\n    int even_count2 = 0;\n    \n    // Use SSE2 intrinsics to count odd/even numbers in parallel\n    int n = lst1.size();\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Check odd/even for lst1\n        __m128i odd_mask1 = _mm_and_si128(vec1, _mm_set1_epi32(1));\n        odd_count1 += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask1));\n        \n        // Check odd/even for lst2\n        __m128i odd_mask2 = _mm_and_si128(vec2, _mm_set1_epi32(1));\n        int odd_mask_val2 = _mm_movemask_epi8(odd_mask2);\n        odd_count2 += _mm_popcnt_u32(odd_mask_val2);\n        even_count2 += 4 - _mm_popcnt_u32(odd_mask_val2);\n    }\n    \n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; i++) {\n        if (lst1[i] % 2 == 1) odd_count1++;\n        if (lst2[i] % 2 == 1) odd_count2++;\n        else even_count2++;\n    }\n    \n    // If even_count2 >= odd_count1, we can replace all odd numbers in lst1\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, odd_count2 = 0;\n    int even_count2 = 0;\n    \n    // Use SSE2 intrinsics for parallel processing\n    int n = lst1.size();\n    \n    // Process 4 elements at a time using SSE2\n    for (int i = 0; i <= n - 4; i += 4) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Check odd/even for lst1\n        __m128i mask1 = _mm_set1_epi32(1);\n        __m128i odd_mask1 = _mm_and_si128(vec1, mask1);\n        odd_count1 += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask1));\n        \n        // Check odd/even for lst2\n        __m128i odd_mask2 = _mm_and_si128(vec2, mask1);\n        odd_count2 += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask2));\n        \n        // Count even numbers in lst2\n        __m128i even_mask2 = _mm_xor_si128(odd_mask2, mask1);\n        even_count2 += _mm_popcnt_u32(_mm_movemask_epi8(even_mask2));\n    }\n    \n    // Process remaining elements\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (lst1[i] % 2 == 1) odd_count1++;\n        if (lst2[i] % 2 == 1) odd_count2++;\n        if (lst2[i] % 2 == 0) even_count2++;\n    }\n    \n    // Check if we can exchange to make lst1 all even\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, odd_count2 = 0;\n    int even_count2 = 0;\n    \n    // Use SSE2 intrinsics for parallel processing\n    int n = lst1.size();\n    for (int i = 0; i < n; i += 4) {\n        __m128i vec1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst1[i]));\n        __m128i vec2 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst2[i]));\n        \n        // Check odd/even for vec1\n        __m128i mask1 = _mm_set1_epi32(1);\n        __m128i odd_mask1 = _mm_and_si128(vec1, mask1);\n        __m128i odd_count_vec1 = _mm_cmpeq_epi32(odd_mask1, mask1);\n        odd_count1 += _mm_popcnt_u32(_mm_movemask_epi8(odd_count_vec1));\n        \n        // Check odd/even for vec2\n        __m128i odd_mask2 = _mm_and_si128(vec2, mask1);\n        __m128i odd_count_vec2 = _mm_cmpeq_epi32(odd_mask2, mask1);\n        odd_count2 += _mm_popcnt_u32(_mm_movemask_epi8(odd_count_vec2));\n        \n        // Count even numbers in vec2\n        __m128i even_mask2 = _mm_cmpeq_epi32(_mm_and_si128(vec2, mask1), _mm_setzero_si128());\n        even_count2 += _mm_popcnt_u32(_mm_movemask_epi8(even_mask2));\n    }\n    \n    // Handle remaining elements\n    for (int i = (n / 4) * 4; i < n; ++i) {\n        if (lst1[i] % 2 == 1) odd_count1++;\n        if (lst2[i] % 2 == 1) odd_count2++;\n        if (lst2[i] % 2 == 0) even_count2++;\n    }\n    \n    // Check if we can exchange to make lst1 even\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, odd_count2 = 0;\n    int even_count2 = 0;\n    \n    // Use SSE2 intrinsics for parallel processing\n    int n = lst1.size();\n    \n    // Process 4 elements at a time using SSE2\n    for (int i = 0; i <= n - 4; i += 4) {\n        __m128i vec1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        __m128i vec2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Check odd/even for lst1\n        __m128i odd_mask1 = _mm_and_si128(vec1, _mm_set1_epi32(1));\n        odd_count1 += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask1));\n        \n        // Check odd/even for lst2\n        __m128i odd_mask2 = _mm_and_si128(vec2, _mm_set1_epi32(1));\n        odd_count2 += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask2));\n        \n        // Count even elements in lst2\n        __m128i even_mask2 = _mm_xor_si128(odd_mask2, _mm_set1_epi32(1));\n        even_count2 += _mm_popcnt_u32(_mm_movemask_epi8(even_mask2));\n    }\n    \n    // Process remaining elements\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (lst1[i] % 2 == 1) odd_count1++;\n        if (lst2[i] % 2 == 1) odd_count2++;\n        if (lst2[i] % 2 == 0) even_count2++;\n    }\n    \n    // Check if we can exchange to make lst1 all even\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count1 = 0, odd_count2 = 0;\n    int even_count2 = 0;\n\n    // Use SSE2 intrinsics for parallel processing\n    int n = lst1.size();\n    for (int i = 0; i < n; i += 4) {\n        // Load 4 integers at a time\n        __m128i vec1 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst1[i]));\n        __m128i vec2 = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst2[i]));\n\n        // Create mask for odd numbers\n        __m128i mask_odd = _mm_set1_epi32(1);\n        __m128i vec1_odd = _mm_and_si128(vec1, mask_odd);\n        __m128i vec2_odd = _mm_and_si128(vec2, mask_odd);\n\n        // Count odd numbers\n        odd_count1 += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(vec1_odd)));\n        odd_count2 += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(vec2_odd)));\n\n        // Count even numbers in vec2\n        __m128i vec2_even = _mm_xor_si128(vec2_odd, vec2);\n        even_count2 += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(vec2_even)));\n    }\n\n    // Handle remaining elements if vector size is not multiple of 4\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (lst1[i] % 2 == 1) odd_count1++;\n        if (lst2[i] % 2 == 1) odd_count2++;\n        if (lst2[i] % 2 == 0) even_count2++;\n    }\n\n    // If we can exchange odd numbers from lst1 with even numbers from lst2\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using SSE2\n        int i = 0;\n        for (; i + 15 < str.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.data() + i));\n            \n            // Subtract '0' to convert chars to numeric values\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i numeric_chars = _mm_sub_epi8(chars, zero);\n            \n            // Check which digits are odd\n            __m128i ones = _mm_set1_epi8(1);\n            __m128i is_odd = _mm_and_si128(numeric_chars, ones);\n            \n            // Count odd digits\n            __m128i mask = _mm_cmpgt_epi8(is_odd, _mm_setzero_si128());\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(mask));\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using SSE2\n        int i = 0;\n        for (; i + 15 < str.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.data() + i));\n            \n            // Subtract '0' to convert chars to numeric values\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i numeric_vals = _mm_sub_epi8(chars, zero);\n            \n            // Check which digits are odd\n            __m128i ones = _mm_set1_epi8(1);\n            __m128i odd_mask = _mm_and_si128(numeric_vals, ones);\n            \n            // Count odd digits\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask));\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using SSE2\n        int i = 0;\n        for (; i + 15 < str.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.data() + i));\n            \n            // Subtract '0' to convert chars to numeric values\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i numeric_chars = _mm_sub_epi8(chars, zero);\n            \n            // Check which digits are odd\n            __m128i ones = _mm_set1_epi8(1);\n            __m128i odd_mask = _mm_and_si128(numeric_chars, ones);\n            \n            // Count odd digits\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask));\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using SSE2\n        int i = 0;\n        for (; i + 15 < str.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.data() + i));\n            \n            // Subtract '0' to convert chars to numeric values\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i numeric_vals = _mm_sub_epi8(chars, zero);\n            \n            // Check which digits are odd\n            __m128i ones = _mm_set1_epi8(1);\n            __m128i odd_mask = _mm_and_si128(numeric_vals, ones);\n            \n            // Count odd digits\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask));\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using SSE2\n        int i = 0;\n        for (; i + 15 < str.length(); i += 16) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(str.data() + i));\n            \n            // Subtract '0' to convert chars to numeric values\n            __m128i zero = _mm_set1_epi8('0');\n            __m128i numeric_chars = _mm_sub_epi8(chars, zero);\n            \n            // Check which digits are odd\n            __m128i ones = _mm_set1_epi8(1);\n            __m128i odd_mask = _mm_and_si128(numeric_chars, ones);\n            \n            // Count odd digits\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask));\n        }\n        \n        // Process remaining characters\n        for (; i < str.length(); ++i) {\n            if ((str[i] - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        // Create result string\n        std::string result_str = \"the number of odd elements \" + \n                                  std::to_string(odd_count) + \n                                  \"n the str\" + \n                                  std::to_string(odd_count) + \n                                  \"ng \" + \n                                  std::to_string(odd_count) + \n                                  \" of the \" + \n                                  std::to_string(odd_count) + \n                                  \"nput.\";\n        \n        result.push_back(result_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    // Process 2 elements at a time using SSE2\n    for (int i = 1; i < n - 1; i += 2) {\n        // Load 2 consecutive elements\n        __m128i a = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compute cumulative sums\n        __m128i current_sum = _mm_set_epi64x(currentSum + nums[i], currentSum + nums[i+1]);\n        \n        // Update current sum\n        currentSum += nums[i] + nums[i+1];\n        \n        // Compute minimum sum\n        __m128i min_sum = _mm_set_epi64x(minSum, minSum);\n        min_sum = _mm_min_epi64(min_sum, current_sum);\n        \n        // Extract minimum values\n        minSum = std::min(minSum, _mm_cvtsi128_si64(min_sum));\n        minSum = std::min(minSum, _mm_cvtsi128_si64(_mm_srli_si128(min_sum, 8)));\n    }\n    \n    // Handle remaining elements\n    for (int i = (n % 2 == 0 ? n-2 : n-1); i < n; i++) {\n        currentSum += nums[i];\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    // Process 2 elements at a time using SSE\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        // Load 4 elements into SSE register\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compute cumulative sums\n        __m128i cumSum1 = _mm_add_epi64(_mm_set1_epi64x(currentSum), _mm_set_epi64x(nums[i+1], nums[i]));\n        __m128i cumSum2 = _mm_add_epi64(cumSum1, _mm_set_epi64x(nums[i+3], nums[i+2]));\n        \n        // Extract values\n        int64_t sum1 = _mm_cvtsi128_si64(cumSum1);\n        int64_t sum2 = _mm_cvtsi128_si64(_mm_srli_si128(cumSum1, 8));\n        int64_t sum3 = _mm_cvtsi128_si64(cumSum2);\n        int64_t sum4 = _mm_cvtsi128_si64(_mm_srli_si128(cumSum2, 8));\n        \n        // Update min sum\n        minSum = std::min({minSum, sum1, sum2, sum3, sum4});\n        \n        // Update current sum\n        currentSum = sum4;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        currentSum += nums[i];\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    \n    // Process 2 elements at a time using SSE2\n    for (int i = 1; i < n; i += 2) {\n        // Load 2 consecutive elements\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compute current sum for first element\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        \n        // If another element exists\n        if (i + 1 < n) {\n            current_sum += nums[i + 1];\n            min_sum = std::min(min_sum, current_sum);\n        }\n        \n        // Reset current sum if it becomes positive\n        current_sum = std::min(current_sum, (int64_t)0);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n    \n    // Process 4 elements at a time using SSE2\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        // Load 4 elements into SSE register\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compute horizontal sum using SSE2 instructions\n        __m128i sum1 = _mm_add_epi64(_mm_srli_si128(vec, 8), vec);\n        int64_t partial_sum = _mm_cvtsi128_si64(sum1);\n        \n        current_sum += partial_sum;\n        min_sum = std::min(min_sum, current_sum);\n        \n        // Reset current sum if it becomes positive\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < n; i++) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        \n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    // Initialize min sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = nums[0];\n    \n    // Process 2 elements at a time using SSE2\n    for (int i = 1; i < n; i += 2) {\n        // Load 2 consecutive elements\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compute current sum for both elements\n        __m128i current_sum_vec = _mm_set1_epi64x(current_sum);\n        __m128i sum_vec = _mm_add_epi64(current_sum_vec, vec);\n        \n        // Extract individual sums\n        int64_t sum1 = _mm_cvtsi128_si64(sum_vec);\n        int64_t sum2 = _mm_cvtsi128_si64(_mm_srli_si128(sum_vec, 8));\n        \n        // Update min sum and current sum\n        min_sum = std::min({min_sum, sum1, sum2});\n        current_sum = std::min(sum2, std::min(sum1, current_sum + nums[i]));\n        \n        // Handle last element if odd length\n        if (i + 1 == n - 1) {\n            current_sum = std::min(current_sum + nums[i + 1], nums[i + 1]);\n            min_sum = std::min(min_sum, current_sum);\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n    \n    // Use SSE2 to parallelize water counting\n    for (int i = 0; i < rows; i += 4) {\n        __m128i water_sum = _mm_setzero_si128();\n        \n        for (int j = 0; j < cols; j++) {\n            __m128i row_water = _mm_setzero_si128();\n            \n            // Process 4 rows at a time if possible\n            for (int k = 0; k < 4 && (i + k) < rows; k++) {\n                int water_in_row = grid[i + k][j];\n                row_water = _mm_insert_epi32(row_water, water_in_row, k);\n            }\n            \n            water_sum = _mm_add_epi32(water_sum, row_water);\n        }\n        \n        // Horizontal sum of water\n        __m128i sum_high = _mm_srli_si128(water_sum, 8);\n        water_sum = _mm_add_epi32(water_sum, sum_high);\n        sum_high = _mm_srli_si128(water_sum, 4);\n        water_sum = _mm_add_epi32(water_sum, sum_high);\n        \n        total_water += _mm_cvtsi128_si32(water_sum);\n    }\n    \n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use SSE2 to parallelize water counting\n    for (int i = 0; i < rows; i += 4) {\n        __m128i water_sum = _mm_setzero_si128();\n\n        // Process 4 rows at a time using SSE2\n        for (int j = 0; j < cols; j += 4) {\n            // Load 4x4 grid section\n            __m128i row1 = _mm_loadu_si128((__m128i*)&grid[std::min(i, rows-1)][j]);\n            __m128i row2 = _mm_loadu_si128((__m128i*)&grid[std::min(i+1, rows-1)][j]);\n            __m128i row3 = _mm_loadu_si128((__m128i*)&grid[std::min(i+2, rows-1)][j]);\n            __m128i row4 = _mm_loadu_si128((__m128i*)&grid[std::min(i+3, rows-1)][j]);\n\n            // Horizontal sum of water in 4 rows\n            __m128i water_row1 = _mm_sad_epu8(row1, _mm_setzero_si128());\n            __m128i water_row2 = _mm_sad_epu8(row2, _mm_setzero_si128());\n            __m128i water_row3 = _mm_sad_epu8(row3, _mm_setzero_si128());\n            __m128i water_row4 = _mm_sad_epu8(row4, _mm_setzero_si128());\n\n            // Accumulate water sum\n            water_sum = _mm_add_epi32(water_sum, water_row1);\n            water_sum = _mm_add_epi32(water_sum, water_row2);\n            water_sum = _mm_add_epi32(water_sum, water_row3);\n            water_sum = _mm_add_epi32(water_sum, water_row4);\n        }\n\n        // Extract total water from SSE register\n        int water_values[4];\n        _mm_storeu_si128((__m128i*)water_values, water_sum);\n        total_water += water_values[0] + water_values[2];\n    }\n\n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use SSE2 to parallelize water counting\n    for (int i = 0; i < rows; i += 4) {\n        __m128i water_sum = _mm_setzero_si128();\n\n        // Process 4 rows at a time using SSE2\n        for (int j = 0; j < cols; j += 4) {\n            // Load 4x4 grid section\n            __m128i row1 = _mm_loadu_si128((__m128i*)&grid[std::min(i, rows-1)][j]);\n            __m128i row2 = _mm_loadu_si128((__m128i*)&grid[std::min(i+1, rows-1)][j]);\n            __m128i row3 = _mm_loadu_si128((__m128i*)&grid[std::min(i+2, rows-1)][j]);\n            __m128i row4 = _mm_loadu_si128((__m128i*)&grid[std::min(i+3, rows-1)][j]);\n\n            // Horizontal sum of water in each row\n            __m128i row_sum = _mm_add_epi32(\n                _mm_add_epi32(_mm_add_epi32(row1, row2), \n                               _mm_add_epi32(row3, row4))\n            );\n\n            water_sum = _mm_add_epi32(water_sum, row_sum);\n        }\n\n        // Horizontal sum of water across 4 rows\n        int water_array[4];\n        _mm_storeu_si128((__m128i*)water_array, water_sum);\n        \n        int row_water = water_array[0] + water_array[1] + water_array[2] + water_array[3];\n        total_water += row_water;\n    }\n\n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use SSE2 to parallelize water counting\n    for (int i = 0; i < rows; i += 4) {\n        __m128i water_sum = _mm_setzero_si128();\n\n        // Process 4 rows at a time using SSE2\n        for (int j = 0; j < cols; j += 4) {\n            // Load 4x4 grid section\n            __m128i row1 = _mm_loadu_si128((__m128i*)&grid[std::min(i, rows-1)][j]);\n            __m128i row2 = _mm_loadu_si128((__m128i*)&grid[std::min(i+1, rows-1)][j]);\n            __m128i row3 = _mm_loadu_si128((__m128i*)&grid[std::min(i+2, rows-1)][j]);\n            __m128i row4 = _mm_loadu_si128((__m128i*)&grid[std::min(i+3, rows-1)][j]);\n\n            // Horizontal sum of water in each row\n            __m128i row_water = _mm_set_epi32(\n                _mm_popcnt_u32(_mm_movemask_epi8(row4)),\n                _mm_popcnt_u32(_mm_movemask_epi8(row3)),\n                _mm_popcnt_u32(_mm_movemask_epi8(row2)),\n                _mm_popcnt_u32(_mm_movemask_epi8(row1))\n            );\n\n            water_sum = _mm_add_epi32(water_sum, row_water);\n        }\n\n        // Horizontal sum of water across rows\n        int water_array[4];\n        _mm_storeu_si128((__m128i*)water_array, water_sum);\n        total_water += water_array[0] + water_array[1] + water_array[2] + water_array[3];\n    }\n\n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use SSE2 to parallelize water counting\n    for (int i = 0; i < rows; i += 4) {\n        __m128i water_sum = _mm_setzero_si128();\n\n        // Process 4 rows at a time using SSE2\n        for (int j = 0; j < cols; j += 4) {\n            // Load 4x4 grid section\n            __m128i row1 = _mm_loadu_si128((__m128i*)&grid[std::min(i, rows-1)][j]);\n            __m128i row2 = _mm_loadu_si128((__m128i*)&grid[std::min(i+1, rows-1)][j]);\n            __m128i row3 = _mm_loadu_si128((__m128i*)&grid[std::min(i+2, rows-1)][j]);\n            __m128i row4 = _mm_loadu_si128((__m128i*)&grid[std::min(i+3, rows-1)][j]);\n\n            // Horizontal sum of water in each row\n            __m128i row_water = _mm_add_epi32(\n                _mm_add_epi32(_mm_add_epi32(row1, row2), \n                               _mm_add_epi32(row3, row4))\n            );\n\n            water_sum = _mm_add_epi32(water_sum, row_water);\n        }\n\n        // Horizontal sum of water across vector\n        int water_array[4];\n        _mm_storeu_si128((__m128i*)water_array, water_sum);\n        \n        int row_water = water_array[0] + water_array[1] + water_array[2] + water_array[3];\n        total_water += row_water;\n    }\n\n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    int64_t result = 0;\n\n    // Process 8 elements at a time using SSE2\n    int vectorSize = size - (size % 8);\n    __m128i sumVector = _mm_setzero_si128();\n\n    for (int i = 0; i < vectorSize; i += 8) {\n        // Load 8 elements\n        __m128i loadedVector = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create mask for even positions\n        __m128i evenPosMask = _mm_set_epi16(0, -1, 0, -1, 0, -1, 0, -1);\n        \n        // Mask out elements in even positions\n        __m128i evenPosElements = _mm_and_si128(loadedVector, evenPosMask);\n        \n        // Shift right to get actual values\n        __m128i shiftedElements = _mm_srai_epi16(evenPosElements, 15);\n        \n        // Check for odd values\n        __m128i oddMask = _mm_cmpgt_epi16(evenPosElements, shiftedElements);\n        \n        // Mask odd elements in even positions\n        __m128i oddEvenPosElements = _mm_and_si128(evenPosElements, oddMask);\n        \n        // Sum the elements\n        sumVector = _mm_add_epi16(sumVector, oddEvenPosElements);\n    }\n\n    // Horizontal sum\n    __m128i sum = _mm_add_epi16(sumVector, _mm_srli_si128(sumVector, 8));\n    sum = _mm_add_epi16(sum, _mm_srli_si128(sum, 4));\n    sum = _mm_add_epi16(sum, _mm_srli_si128(sum, 2));\n    \n    // Extract final sum\n    result = _mm_cvtsi128_si32(sum) & 0xFFFF;\n\n    // Handle remaining elements\n    for (int i = vectorSize; i < size; i += 2) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    __m128i sum_vec = _mm_setzero_si128();\n\n    // Process 8 elements at a time\n    int i;\n    for (i = 0; i <= size - 8; i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create mask for even positions\n        __m128i even_mask = _mm_set_epi16(\n            0, -1, 0, -1, 0, -1, 0, -1\n        );\n        \n        // Mask to keep only elements in even positions\n        vec = _mm_and_si128(vec, even_mask);\n        \n        // Create mask for odd elements\n        __m128i odd_mask = _mm_set_epi16(\n            0, (vec.m128i_i16[1] % 2 == 1) ? -1 : 0,\n            0, (vec.m128i_i16[3] % 2 == 1) ? -1 : 0,\n            0, (vec.m128i_i16[5] % 2 == 1) ? -1 : 0,\n            0, (vec.m128i_i16[7] % 2 == 1) ? -1 : 0\n        );\n        \n        // Mask to keep only odd elements\n        vec = _mm_and_si128(vec, odd_mask);\n        \n        // Add to sum vector\n        sum_vec = _mm_add_epi16(sum_vec, vec);\n    }\n    \n    // Horizontal sum\n    __m128i sum_high = _mm_unpackhi_epi16(sum_vec, _mm_setzero_si128());\n    __m128i sum_low = _mm_unpacklo_epi16(sum_vec, _mm_setzero_si128());\n    sum_vec = _mm_add_epi32(sum_high, sum_low);\n    \n    int64_t sum = _mm_cvtsi128_si32(sum_vec);\n    sum += _mm_extract_epi32(sum_vec, 1);\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 1) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    __m128i sum_vec = _mm_setzero_si128();\n\n    // Process 8 elements at a time using SSE2\n    for (int i = 0; i < size - (size % 8); i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create mask for even positions (0, 2, 4, 6)\n        __m128i even_mask = _mm_set_epi16(0, -1, 0, -1, 0, -1, 0, -1);\n        \n        // Blend to keep only elements in even positions\n        __m128i even_pos_vec = _mm_blendv_epi8(_mm_setzero_si128(), vec, even_mask);\n        \n        // Create mask for odd elements\n        __m128i odd_mask = _mm_set_epi16(0, 0, 0, 0, 0, 0, 0, 0);\n        for (int j = 0; j < 8; j++) {\n            int16_t val = lst[i + j];\n            if (j % 2 == 0 && val % 2 == 1) {\n                odd_mask = _mm_insert_epi16(odd_mask, -1, j);\n            }\n        }\n        \n        // Blend to keep only odd elements in even positions\n        __m128i result = _mm_blendv_epi8(_mm_setzero_si128(), even_pos_vec, odd_mask);\n        \n        // Sum the elements\n        sum_vec = _mm_add_epi16(sum_vec, result);\n    }\n    \n    // Horizontal sum\n    __m128i sum_high = _mm_unpackhi_epi16(sum_vec, _mm_setzero_si128());\n    __m128i sum_low = _mm_unpacklo_epi16(sum_vec, _mm_setzero_si128());\n    sum_vec = _mm_add_epi32(sum_low, sum_high);\n    \n    sum_high = _mm_shuffle_epi32(sum_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    \n    sum_high = _mm_shuffle_epi32(sum_vec, _MM_SHUFFLE(0, 1, 0, 1));\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    \n    int64_t total_sum = _mm_cvtsi128_si32(sum_vec);\n    \n    // Handle remaining elements\n    for (int i = size - (size % 8); i < size; i++) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            total_sum += lst[i];\n        }\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    __m128i sum_vec = _mm_setzero_si128();\n\n    // Process 8 elements at a time using SSE2\n    for (int i = 0; i < size - (size % 8); i += 8) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create mask for even positions (0, 2, 4, 6)\n        __m128i even_pos_mask = _mm_set_epi16(0, -1, 0, -1, 0, -1, 0, -1);\n        \n        // Mask to keep only elements in even positions\n        __m128i masked_vec = _mm_and_si128(vec, even_pos_mask);\n        \n        // Shift right to extract even position elements\n        __m128i shifted_vec = _mm_srli_epi16(masked_vec, 1);\n        \n        // Check for odd elements\n        __m128i odd_mask = _mm_set1_epi16(1);\n        __m128i is_odd = _mm_and_si128(shifted_vec, odd_mask);\n        \n        // Keep only odd elements in even positions\n        __m128i odd_elements = _mm_and_si128(shifted_vec, is_odd);\n        \n        // Sum the odd elements\n        sum_vec = _mm_add_epi16(sum_vec, odd_elements);\n    }\n\n    // Horizontal sum\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi16(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 4);\n    sum_vec = _mm_add_epi16(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 2);\n    sum_vec = _mm_add_epi16(sum_vec, sum_high);\n\n    // Handle remaining elements\n    int64_t total_sum = _mm_cvtsi128_si32(sum_vec);\n    for (int i = size - (size % 8); i < size; i++) {\n        if (i % 2 == 0 && lst[i] % 2 == 1) {\n            total_sum += lst[i];\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int size = lst.size();\n    int64_t result = 0;\n\n    // Process 8 elements at a time using SSE2\n    int vectorSize = size - (size % 8);\n    __m128i sumVector = _mm_setzero_si128();\n\n    for (int i = 0; i < vectorSize; i += 8) {\n        // Load 8 elements\n        __m128i loadedVector = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create mask for even positions (0, 2, 4, 6)\n        __m128i evenPosMask = _mm_set_epi16(\n            0, -1, 0, -1, 0, -1, 0, -1\n        );\n        \n        // Mask to keep only elements at even positions\n        __m128i evenPosElements = _mm_and_si128(loadedVector, evenPosMask);\n        \n        // Shift right to get the actual values\n        __m128i shiftedElements = _mm_srai_epi16(evenPosElements, 15);\n        \n        // Check for odd elements\n        __m128i oddMask = _mm_cmpgt_epi16(evenPosElements, shiftedElements);\n        \n        // Combine odd and even position mask\n        __m128i result_vector = _mm_and_si128(evenPosElements, oddMask);\n        \n        // Sum the elements\n        sumVector = _mm_add_epi16(sumVector, result_vector);\n    }\n\n    // Horizontal sum\n    __m128i sum_high = _mm_unpackhi_epi64(sumVector, sumVector);\n    sumVector = _mm_add_epi16(sumVector, sum_high);\n    \n    sum_high = _mm_shufflelo_epi16(sumVector, _MM_SHUFFLE(1, 0, 3, 2));\n    sumVector = _mm_add_epi16(sumVector, sum_high);\n    \n    sum_high = _mm_shufflelo_epi16(sumVector, _MM_SHUFFLE(0, 1, 2, 3));\n    sumVector = _mm_add_epi16(sumVector, sum_high);\n\n    // Extract final sum\n    int16_t finalSum = _mm_cvtsi128_si32(sumVector) & 0xFFFF;\n    result += finalSum;\n\n    // Handle remaining elements\n    for (int i = vectorSize; i < size; i += 2) {\n        if (i < size && lst[i] % 2 == 1) {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= k; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for two-digit numbers (10 <= x <= 99)\n        __m128i mask_low = _mm_set1_epi32(10);\n        __m128i mask_high = _mm_set1_epi32(99);\n        \n        __m128i cmp_low = _mm_cmpgt_epi32(vec, mask_low);\n        __m128i cmp_high = _mm_cmpgt_epi32(mask_high, vec);\n        \n        __m128i mask = _mm_and_si128(cmp_low, cmp_high);\n        \n        // Mask the original vector to keep only two-digit numbers\n        vec = _mm_and_si128(vec, mask);\n        \n        // Horizontal sum of masked vector\n        __m128i sum_vec = _mm_hadd_epi32(vec, vec);\n        sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n        \n        sum += _mm_cvtsi128_si32(sum_vec);\n    }\n    \n    // Process remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= k; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for numbers with at most 2 digits\n        __m128i mask = _mm_set1_epi32(99);\n        __m128i compare = _mm_cmpgt_epi32(vec, mask);\n        \n        // Zero out numbers > 99\n        vec = _mm_andnot_si128(compare, vec);\n        \n        // Horizontal sum of valid elements\n        __m128i sum_vec = _mm_hadd_epi32(vec, vec);\n        sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n        \n        sum += _mm_cvtsi128_si32(sum_vec);\n    }\n    \n    // Process remaining elements\n    for (; i < k; i++) {\n        if (arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= k; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for numbers with at most 2 digits\n        __m128i mask = _mm_set1_epi32(99);\n        __m128i compare = _mm_cmpgt_epi32(vec, mask);\n        \n        // Zero out numbers > 99\n        vec = _mm_andnot_si128(compare, vec);\n        \n        // Horizontal sum of valid elements\n        __m128i sum_vec = _mm_hadd_epi32(vec, vec);\n        sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n        \n        sum += _mm_cvtsi128_si32(sum_vec);\n    }\n    \n    // Process remaining elements\n    for (; i < k; i++) {\n        if (arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= k; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for two-digit numbers\n        __m128i mask = _mm_set1_epi32(99);\n        __m128i two_digit_mask = _mm_and_si128(_mm_cmpgt_epi32(vec, _mm_setzero_si128()), \n                                               _mm_cmplt_epi32(vec, _mm_add_epi32(mask, _mm_set1_epi32(1))));\n        \n        // Mask the vector to zero out numbers not meeting condition\n        vec = _mm_and_si128(vec, two_digit_mask);\n        \n        // Horizontal sum of masked vector\n        __m128i sum_vec = _mm_hadd_epi32(vec, vec);\n        sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n        \n        sum += _mm_cvtsi128_si32(sum_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE\n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (; i + 4 <= k; i += 4) {\n        __m128i elements = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create mask for elements with at most 2 digits\n        __m128i abs_mask = _mm_set1_epi32(0x7FFFFFFF);\n        __m128i abs_elements = _mm_and_si128(elements, abs_mask);\n        \n        __m128i two_digit_mask = _mm_set1_epi32(99);\n        __m128i two_digit_cmp = _mm_cmpgt_epi32(abs_elements, two_digit_mask);\n        \n        // Zero out elements > 99\n        __m128i filtered_elements = _mm_andnot_si128(two_digit_cmp, elements);\n        \n        sum_vec = _mm_add_epi32(sum_vec, filtered_elements);\n    }\n    \n    // Horizontal sum of vector\n    __m128i sum_high = _mm_srli_si128(sum_vec, 8);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    sum_high = _mm_srli_si128(sum_vec, 4);\n    sum_vec = _mm_add_epi32(sum_vec, sum_high);\n    \n    sum += _mm_cvtsi128_si32(sum_vec);\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    int n = lst.size();\n    int vec_size = n - (n % 4);\n\n    // Check sorted order and uniqueness using SSE\n    for (int i = 0; i < vec_size; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i + 1]);\n\n        // Check if current elements are less than or equal to next elements\n        __m128i cmp_gt = _mm_cmpgt_epi32(current, next);\n        if (_mm_movemask_epi8(cmp_gt) != 0) return false;\n\n        // Check for duplicates\n        __m128i unique_check = _mm_cmpeq_epi32(current, next);\n        if (_mm_movemask_epi8(unique_check) != 0) return false;\n    }\n\n    // Handle remaining elements\n    for (int i = vec_size; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    \n    // Handle trivial cases\n    if (n <= 1) return true;\n    \n    // Process 4 integers at a time using SSE\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i+1]);\n        \n        // Check if current is less than or equal to next\n        __m128i cmp = _mm_cmpgt_epi32(current, next);\n        if (_mm_movemask_epi8(cmp) != 0) return false;\n        \n        // Check for duplicates\n        __m128i unique_check = _mm_cmpeq_epi32(current, next);\n        if (_mm_movemask_epi8(unique_check) != 0) return false;\n    }\n    \n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (lst[i] > lst[i+1]) return false;\n        if (lst[i] == lst[i+1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 integers at a time using SSE2\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i+1]);\n\n        // Check ascending order\n        __m128i cmp = _mm_cmpgt_epi32(current, next);\n        if (_mm_movemask_epi8(cmp) != 0) return false;\n\n        // Check for duplicates\n        __m128i eq = _mm_cmpeq_epi32(current, next);\n        if (_mm_movemask_epi8(eq) != 0) return false;\n    }\n\n    // Handle remaining elements\n    for (; i < n - 1; i++) {\n        if (lst[i] > lst[i+1] || lst[i] == lst[i+1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 integers at a time using SSE2\n    int vectorSize = n - (n % 4);\n    __m128i prevVector = _mm_set1_epi32(0);\n    __m128i dupCheckVector = _mm_set1_epi32(0);\n\n    for (int i = 0; i < vectorSize; i += 4) {\n        __m128i currentVector = _mm_loadu_si128((__m128i*)&lst[i]);\n\n        // Check if current vector is sorted\n        __m128i shiftedVector = _mm_slli_si128(currentVector, 4);\n        __m128i compareResult = _mm_cmpgt_epi32(shiftedVector, currentVector);\n        if (_mm_movemask_epi8(compareResult) != 0) return false;\n\n        // Check for duplicates\n        __m128i dupMask = _mm_cmpeq_epi32(currentVector, prevVector);\n        if (_mm_movemask_epi8(dupMask) != 0) return false;\n\n        prevVector = currentVector;\n        dupCheckVector = _mm_or_si128(dupCheckVector, dupMask);\n    }\n\n    // Process remaining elements\n    for (int i = vectorSize; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i - 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) return true;\n\n    // Process 4 integers at a time using SSE2\n    int vectorSize = n - (n % 4);\n    __m128i prevVector = _mm_set1_epi32(0);\n    __m128i dupCheckVector = _mm_set1_epi32(0);\n\n    for (int i = 0; i < vectorSize; i += 4) {\n        __m128i currentVector = _mm_loadu_si128((__m128i*)&lst[i]);\n\n        // Check if current vector is sorted\n        __m128i shiftedVector = _mm_slli_si128(currentVector, 4);\n        __m128i compareResult = _mm_cmpgt_epi32(shiftedVector, currentVector);\n        if (_mm_movemask_epi8(compareResult) != 0) return false;\n\n        // Check for duplicates\n        __m128i dupResult = _mm_cmpeq_epi32(currentVector, dupCheckVector);\n        if (_mm_movemask_epi8(dupResult) != 0) return false;\n\n        // Update previous and duplicate check vectors\n        prevVector = currentVector;\n        dupCheckVector = currentVector;\n    }\n\n    // Handle remaining elements\n    for (int i = vectorSize; i < n - 1; ++i) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int total_magnitude = 0;\n    \n    // Process 4 integers at a time using SSE\n    int i = 0;\n    __m128i sign_vec = _mm_setzero_si128();\n    __m128i magnitude_vec = _mm_setzero_si128();\n    \n    for (; i + 3 < arr.size(); i += 4) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Extract signs\n        __m128i sign_mask = _mm_srai_epi32(current_vec, 31);\n        __m128i sign_vec_part = _mm_xor_si128(_mm_set1_epi32(1), sign_mask);\n        sign_vec = _mm_add_epi32(sign_vec, sign_vec_part);\n        \n        // Calculate absolute values (magnitudes)\n        __m128i abs_vec = _mm_abs_epi32(current_vec);\n        magnitude_vec = _mm_add_epi32(magnitude_vec, abs_vec);\n    }\n    \n    // Horizontal sum of sign_vec and magnitude_vec\n    __m128i sign_sum = _mm_hadd_epi32(sign_vec, sign_vec);\n    sign_sum = _mm_hadd_epi32(sign_sum, sign_sum);\n    int sign_total = _mm_cvtsi128_si32(sign_sum);\n    \n    __m128i magnitude_sum = _mm_hadd_epi32(magnitude_vec, magnitude_vec);\n    magnitude_sum = _mm_hadd_epi32(magnitude_sum, magnitude_sum);\n    int magnitude_total = _mm_cvtsi128_si32(magnitude_sum);\n    \n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        sign_total += (arr[i] >= 0) ? 1 : -1;\n        magnitude_total += std::abs(arr[i]);\n    }\n    \n    // Determine final sign product\n    if (sign_total == arr.size()) sign_product = 1;\n    else if (sign_total == -arr.size()) sign_product = -1;\n    else sign_product = 0;\n    \n    return sign_product * magnitude_total;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int n = arr.size();\n    int sign_product = 1;\n    int total_magnitude = 0;\n    \n    // Process 4 integers at a time using SSE\n    int i;\n    __m128i sign_vec = _mm_setzero_si128();\n    __m128i magnitude_vec = _mm_setzero_si128();\n    \n    for (i = 0; i <= n - 4; i += 4) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Extract signs\n        __m128i sign_mask = _mm_srai_epi32(current_vec, 31);\n        __m128i zero_mask = _mm_cmpeq_epi32(current_vec, _mm_setzero_si128());\n        sign_mask = _mm_or_si128(sign_mask, zero_mask);\n        sign_vec = _mm_xor_si128(sign_vec, sign_mask);\n        \n        // Compute absolute values (magnitudes)\n        __m128i abs_vec = _mm_abs_epi32(current_vec);\n        magnitude_vec = _mm_add_epi32(magnitude_vec, abs_vec);\n    }\n    \n    // Horizontal sum for sign and magnitude\n    __m128i sign_shuffle = _mm_shuffle_epi32(sign_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    sign_vec = _mm_xor_si128(sign_vec, sign_shuffle);\n    sign_shuffle = _mm_shuffle_epi32(sign_vec, _MM_SHUFFLE(0, 1, 2, 3));\n    sign_vec = _mm_xor_si128(sign_vec, sign_shuffle);\n    \n    __m128i magnitude_shuffle = _mm_shuffle_epi32(magnitude_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    magnitude_vec = _mm_add_epi32(magnitude_vec, magnitude_shuffle);\n    magnitude_shuffle = _mm_shuffle_epi32(magnitude_vec, _MM_SHUFFLE(0, 1, 2, 3));\n    magnitude_vec = _mm_add_epi32(magnitude_vec, magnitude_shuffle);\n    \n    // Extract final sign and magnitude\n    int final_sign = _mm_cvtsi128_si32(sign_vec) & 1 ? -1 : 1;\n    int final_magnitude = _mm_cvtsi128_si32(magnitude_vec);\n    \n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (arr[i] == 0) final_sign = 0;\n        else if (arr[i] < 0) final_sign *= -1;\n        final_magnitude += std::abs(arr[i]);\n    }\n    \n    return final_sign * final_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int n = arr.size();\n    int sign_product = 1;\n    int total_magnitude = 0;\n\n    // Process 4 integers at a time using SSE\n    __m128i sign_vec = _mm_setzero_si128();\n    __m128i magnitude_vec = _mm_setzero_si128();\n\n    int i;\n    for (i = 0; i + 3 < n; i += 4) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Extract signs\n        __m128i sign_mask = _mm_srai_epi32(current_vec, 31);\n        sign_vec = _mm_xor_si128(sign_vec, sign_mask);\n\n        // Take absolute values for magnitude\n        __m128i abs_vec = _mm_abs_epi32(current_vec);\n        magnitude_vec = _mm_add_epi32(magnitude_vec, abs_vec);\n    }\n\n    // Horizontal sum for signs and magnitudes\n    __m128i sign_shuffle = _mm_shuffle_epi32(sign_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    sign_vec = _mm_xor_si128(sign_vec, sign_shuffle);\n    sign_shuffle = _mm_shuffle_epi32(sign_vec, _MM_SHUFFLE(0, 1, 2, 3));\n    sign_vec = _mm_xor_si128(sign_vec, sign_shuffle);\n\n    __m128i magnitude_shuffle = _mm_shuffle_epi32(magnitude_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    magnitude_vec = _mm_add_epi32(magnitude_vec, magnitude_shuffle);\n    magnitude_shuffle = _mm_shuffle_epi32(magnitude_vec, _MM_SHUFFLE(0, 1, 2, 3));\n    magnitude_vec = _mm_add_epi32(magnitude_vec, magnitude_shuffle);\n\n    // Extract final sign and magnitude\n    int final_sign = _mm_cvtsi128_si32(sign_vec) & 1 ? -1 : 1;\n    int total_magnitude_simd = _mm_cvtsi128_si32(magnitude_vec);\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (arr[i] == 0) return 0;\n        sign_product *= (arr[i] > 0) ? 1 : -1;\n        total_magnitude += std::abs(arr[i]);\n    }\n\n    return final_sign * total_magnitude_simd * sign_product;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int sign_product = 1;\n    int total_magnitude = 0;\n    \n    // Process 4 integers at a time using SSE\n    int i = 0;\n    __m128i sign_vec = _mm_setzero_si128();\n    __m128i magnitude_vec = _mm_setzero_si128();\n    \n    for (; i + 3 < arr.size(); i += 4) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Extract signs\n        __m128i signs = _mm_srai_epi32(current_vec, 31);\n        signs = _mm_or_si128(signs, _mm_cmpneq_epi32(current_vec, _mm_setzero_si128()));\n        \n        // Accumulate sign product\n        sign_vec = _mm_xor_si128(sign_vec, signs);\n        \n        // Compute absolute values (magnitudes)\n        __m128i abs_vec = _mm_abs_epi32(current_vec);\n        magnitude_vec = _mm_add_epi32(magnitude_vec, abs_vec);\n    }\n    \n    // Horizontal sum of sign_vec and magnitude_vec\n    __m128i sign_shuffle = _mm_shuffle_epi32(sign_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    sign_vec = _mm_xor_si128(sign_vec, sign_shuffle);\n    sign_shuffle = _mm_shuffle_epi32(sign_vec, _MM_SHUFFLE(0, 1, 2, 3));\n    sign_vec = _mm_xor_si128(sign_vec, sign_shuffle);\n    \n    __m128i magnitude_shuffle = _mm_shuffle_epi32(magnitude_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    magnitude_vec = _mm_add_epi32(magnitude_vec, magnitude_shuffle);\n    magnitude_shuffle = _mm_shuffle_epi32(magnitude_vec, _MM_SHUFFLE(0, 1, 2, 3));\n    magnitude_vec = _mm_add_epi32(magnitude_vec, magnitude_shuffle);\n    \n    // Extract final sign and magnitude\n    int final_sign = _mm_cvtsi128_si32(sign_vec) & 1 ? -1 : 1;\n    int total_magnitude_simd = _mm_cvtsi128_si32(magnitude_vec);\n    \n    // Process remaining elements\n    for (; i < arr.size(); ++i) {\n        if (arr[i] == 0) return 0;\n        sign_product *= (arr[i] > 0) ? 1 : -1;\n        total_magnitude += std::abs(arr[i]);\n    }\n    \n    // Combine SIMD and remaining results\n    sign_product *= final_sign;\n    total_magnitude += total_magnitude_simd;\n    \n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int n = arr.size();\n    int sign_product = 1;\n    int total_magnitude = 0;\n\n    // Process 4 integers at a time using SSE\n    int i;\n    __m128i sign_vec = _mm_setzero_si128();\n    __m128i magnitude_vec = _mm_setzero_si128();\n\n    for (i = 0; i <= n - 4; i += 4) {\n        __m128i current_vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Extract signs\n        __m128i sign_mask = _mm_srai_epi32(current_vec, 31);\n        __m128i is_zero_mask = _mm_cmpeq_epi32(current_vec, _mm_setzero_si128());\n        \n        // Combine sign and zero masks\n        __m128i combined_mask = _mm_or_si128(sign_mask, is_zero_mask);\n        sign_vec = _mm_or_si128(sign_vec, combined_mask);\n\n        // Calculate absolute magnitudes\n        __m128i abs_vec = _mm_abs_epi32(current_vec);\n        magnitude_vec = _mm_add_epi32(magnitude_vec, abs_vec);\n    }\n\n    // Horizontal sum for sign and magnitude\n    int sign_arr[4], magnitude_arr[4];\n    _mm_storeu_si128((__m128i*)sign_arr, sign_vec);\n    _mm_storeu_si128((__m128i*)magnitude_arr, magnitude_vec);\n\n    for (int j = 0; j < 4; j++) {\n        if (sign_arr[j] != 0) sign_product = 0;\n    }\n\n    total_magnitude = magnitude_arr[0] + magnitude_arr[1] + magnitude_arr[2] + magnitude_arr[3];\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] == 0) sign_product = 0;\n        else if (arr[i] < 0) sign_product *= -1;\n        total_magnitude += std::abs(arr[i]);\n    }\n\n    return sign_product * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    __m128i min_path_vec = _mm_set1_epi32(INT_MAX);\n    __m128i current_path_vec;\n\n    // Parallel search for minimum path using SSE\n    for (int start_row = 0; start_row < N; start_row++) {\n        for (int start_col = 0; start_col < N; start_col++) {\n            std::vector<int> current_path(k);\n            current_path[0] = grid[start_row][start_col];\n            \n            // Recursive DFS with SSE path tracking\n            std::function<void(int, int, int)> dfs = [&](int row, int col, int depth) {\n                if (depth == k) {\n                    current_path_vec = _mm_loadu_si128((__m128i*)current_path.data());\n                    \n                    // Compare current path with minimum path using SSE comparison\n                    __m128i compare_mask = _mm_cmplt_epi32(current_path_vec, min_path_vec);\n                    if (_mm_movemask_epi8(compare_mask)) {\n                        min_path_vec = current_path_vec;\n                        std::copy(current_path.begin(), current_path.end(), result.begin());\n                    }\n                    return;\n                }\n\n                // Parallel exploration of 4 neighbor directions using SSE\n                int dx[4] = {0, 0, 1, -1};\n                int dy[4] = {1, -1, 0, 0};\n                \n                __m128i dir_x = _mm_loadu_si128((__m128i*)dx);\n                __m128i dir_y = _mm_loadu_si128((__m128i*)dy);\n\n                for (int i = 0; i < 4; i++) {\n                    int new_row = row + dx[i];\n                    int new_col = col + dy[i];\n\n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                        current_path[depth] = grid[new_row][new_col];\n                        dfs(new_row, new_col, depth + 1);\n                    }\n                }\n            };\n\n            dfs(start_row, start_col, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    \n    // Flatten the grid into a 1D vector for easier SIMD processing\n    std::vector<int> flatGrid(N * N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            flatGrid[i * N + j] = grid[i][j];\n        }\n    }\n    \n    // Use SSE2 to find the minimum value and its position\n    __m128i minVal = _mm_set1_epi32(INT_MAX);\n    __m128i minPos = _mm_setzero_si128();\n    \n    for (int i = 0; i < N * N; i += 4) {\n        __m128i currentVals = _mm_loadu_si128((__m128i*)&flatGrid[i]);\n        __m128i mask = _mm_cmplt_epi32(currentVals, minVal);\n        minVal = _mm_blendv_epi8(minVal, currentVals, mask);\n        minPos = _mm_blendv_epi8(minPos, _mm_set1_epi32(i), mask);\n    }\n    \n    // Extract the minimum value and its position\n    alignas(16) int minValues[4];\n    alignas(16) int minPositions[4];\n    _mm_store_si128((__m128i*)minValues, minVal);\n    _mm_store_si128((__m128i*)minPositions, minPos);\n    \n    int minValue = minValues[0];\n    int startPos = minPositions[0];\n    \n    // Reconstruct the path\n    result[0] = minValue;\n    int currentPos = startPos;\n    \n    for (int step = 1; step < k; step++) {\n        // Define possible neighbor positions\n        int neighbors[] = {\n            currentPos - N,  // Up\n            currentPos + N,  // Down\n            currentPos - 1,  // Left\n            currentPos + 1   // Right\n        };\n        \n        // Use SSE2 to find the minimum neighbor\n        __m128i neighborVals = _mm_loadu_si128((__m128i*)&flatGrid[neighbors[0]]);\n        __m128i validMask = _mm_set_epi32(\n            neighbors[3] < N * N,\n            neighbors[2] >= 0 && neighbors[2] < N * N,\n            neighbors[1] < N * N,\n            neighbors[0] >= 0 && neighbors[0] < N * N\n        );\n        \n        neighborVals = _mm_blendv_epi8(_mm_set1_epi32(INT_MAX), neighborVals, validMask);\n        \n        __m128i minNeighborVal = _mm_min_epi32(neighborVals, _mm_srli_si128(neighborVals, 8));\n        minNeighborVal = _mm_min_epi32(minNeighborVal, _mm_srli_si128(minNeighborVal, 4));\n        \n        // Find the index of the minimum neighbor\n        int minNeighborIndex = 0;\n        for (int i = 0; i < 4; i++) {\n            if (flatGrid[neighbors[i]] == _mm_cvtsi128_si32(minNeighborVal)) {\n                minNeighborIndex = i;\n                break;\n            }\n        }\n        \n        currentPos = neighbors[minNeighborIndex];\n        result[step] = flatGrid[currentPos];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    __m128i min_path_vec = _mm_set1_epi32(INT_MAX);\n    __m128i current_path_vec;\n\n    // Parallel search for minimum path using SSE\n    for (int start_row = 0; start_row < N; start_row++) {\n        for (int start_col = 0; start_col < N; start_col++) {\n            std::vector<int> current_path(k);\n            current_path[0] = grid[start_row][start_col];\n\n            // DFS with backtracking and SIMD path comparison\n            std::function<bool(int, int, int)> dfs = [&](int row, int col, int depth) {\n                if (depth == k) {\n                    current_path_vec = _mm_loadu_si128((__m128i*)current_path.data());\n                    __m128i min_path_compare = _mm_cmplt_epi32(current_path_vec, min_path_vec);\n                    \n                    if (_mm_movemask_epi8(min_path_compare)) {\n                        min_path_vec = current_path_vec;\n                        result = current_path;\n                    }\n                    return true;\n                }\n\n                int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n                for (auto& dir : directions) {\n                    int new_row = row + dir[0];\n                    int new_col = col + dir[1];\n\n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                        current_path[depth] = grid[new_row][new_col];\n                        dfs(new_row, new_col, depth + 1);\n                    }\n                }\n                return false;\n            };\n\n            dfs(start_row, start_col, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize first cell paths\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // SIMD directions: up, down, left, right\n    __m128i directions = _mm_set_epi32(-N, N, -1, 1);\n\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                int minVal = INT_MAX;\n                std::vector<int> minPath;\n\n                // SIMD parallel neighbor exploration\n                for (int d = 0; d < 4; d++) {\n                    int di = _mm_extract_epi32(directions, d) / N;\n                    int dj = _mm_extract_epi32(directions, d) % N;\n                    int ni = i + di, nj = j + dj;\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        int prevPathVal = dp[ni][nj][len - 1];\n                        std::vector<int> prevPath = paths[ni][nj][len - 1];\n                        \n                        int currentPathVal = prevPathVal * 10 + grid[i][j];\n                        std::vector<int> currentPath = prevPath;\n                        currentPath.push_back(grid[i][j]);\n\n                        if (currentPathVal < minVal || \n                            (currentPathVal == minVal && currentPath < minPath)) {\n                            minVal = currentPathVal;\n                            minPath = currentPath;\n                        }\n                    }\n                }\n\n                dp[i][j][len] = minVal;\n                paths[i][j][len] = minPath;\n            }\n        }\n    }\n\n    // Find minimum path of length k\n    std::vector<int> result;\n    int minVal = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < minVal || \n                (dp[i][j][k] == minVal && paths[i][j][k] < result)) {\n                minVal = dp[i][j][k];\n                result = paths[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    __m128i min_path_vec = _mm_set1_epi32(INT_MAX);\n    __m128i current_path_vec;\n\n    // Parallel search for minimum path using SSE\n    for (int start_row = 0; start_row < N; start_row++) {\n        for (int start_col = 0; start_col < N; start_col++) {\n            std::vector<int> current_path(k);\n            current_path[0] = grid[start_row][start_col];\n            \n            // Recursive DFS with backtracking\n            std::function<bool(int, int, int)> dfs = [&](int row, int col, int depth) {\n                if (depth == k - 1) {\n                    current_path_vec = _mm_loadu_si128((__m128i*)current_path.data());\n                    \n                    // Compare current path with minimum path using SSE comparison\n                    __m128i cmp = _mm_cmplt_epi32(current_path_vec, min_path_vec);\n                    if (_mm_movemask_epi8(cmp)) {\n                        min_path_vec = current_path_vec;\n                        result = current_path;\n                    }\n                    return true;\n                }\n\n                int dx[] = {0, 0, 1, -1};\n                int dy[] = {1, -1, 0, 0};\n\n                for (int i = 0; i < 4; i++) {\n                    int new_row = row + dx[i];\n                    int new_col = col + dy[i];\n\n                    if (new_row >= 0 && new_row < N && new_col >= 0 && new_col < N) {\n                        current_path[depth + 1] = grid[new_row][new_col];\n                        dfs(new_row, new_col, depth + 1);\n                    }\n                }\n                return false;\n            };\n\n            dfs(start_row, start_col, 0);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = sprintf(digits, \"%llu\", n);\n    \n    // Pad with zeros if needed to align to 16-byte boundary\n    while (len % 16 != 0) {\n        digits[len++] = '0';\n    }\n    \n    // Initialize product to 1\n    uint64_t product = 1;\n    \n    // Process 16 digits at a time using SSE\n    for (int i = 0; i < len; i += 16) {\n        // Load 16 digits into SSE register\n        __m128i digit_vec = _mm_loadu_si128((__m128i*)&digits[i]);\n        \n        // Convert characters to integers\n        __m128i zero_vec = _mm_setzero_si128();\n        __m128i digit_ints = _mm_sub_epi8(digit_vec, _mm_set1_epi8('0'));\n        \n        // Create mask for odd digits\n        __m128i odd_mask = _mm_and_si128(digit_ints, _mm_set1_epi8(1));\n        \n        // Multiply odd digits\n        for (int j = 0; j < 16; j++) {\n            int digit = _mm_extract_epi8(digit_ints, j);\n            int is_odd = _mm_extract_epi8(odd_mask, j);\n            \n            if (is_odd && digit != 0) {\n                product *= digit;\n            }\n        }\n    }\n    \n    // Return 0 if no odd digits found\n    return (product == 1) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = sprintf(digits, \"%llu\", n);\n    \n    // Pad with zeros if needed to align to 16-byte boundary\n    while (len % 16 != 0) {\n        digits[len++] = '0';\n    }\n    \n    // Initialize product to 1\n    uint64_t product = 1;\n    \n    // Process 16 digits at a time using SSE\n    for (int i = 0; i < len; i += 16) {\n        // Load 16 digits into SSE register\n        __m128i vec = _mm_loadu_si128((__m128i*)&digits[i]);\n        \n        // Convert characters to integers\n        __m128i zero = _mm_setzero_si128();\n        __m128i digit_vec = _mm_sub_epi8(vec, _mm_set1_epi8('0'));\n        \n        // Create mask for odd digits\n        __m128i odd_mask = _mm_and_si128(digit_vec, _mm_set1_epi8(1));\n        \n        // Multiply odd digits\n        for (int j = 0; j < 16; j++) {\n            int digit = _mm_extract_epi8(digit_vec, j);\n            int is_odd = _mm_extract_epi8(odd_mask, j);\n            \n            if (is_odd && digit != 0) {\n                product *= digit;\n            }\n        }\n    }\n    \n    // If all digits were even, return 0\n    return (product == 1) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = sprintf(digits, \"%llu\", n);\n    \n    // Pad with zeros if needed to align to 16-byte boundary\n    int padded_len = (len + 15) & ~15;\n    \n    // Align input to 16-byte boundary\n    __attribute__((aligned(16))) char padded_digits[16] = {0};\n    memcpy(padded_digits, digits, len);\n    \n    // Convert characters to integers\n    __m128i zero = _mm_setzero_si128();\n    __m128i digit_vec = _mm_loadu_si128((__m128i*)padded_digits);\n    \n    // Subtract ASCII offset '0'\n    __m128i ascii_offset = _mm_set1_epi8('0');\n    digit_vec = _mm_sub_epi8(digit_vec, ascii_offset);\n    \n    // Create mask for odd digits\n    __m128i one = _mm_set1_epi8(1);\n    __m128i odd_mask = _mm_and_si128(digit_vec, one);\n    odd_mask = _mm_cmpeq_epi8(odd_mask, one);\n    \n    // Blend odd digits\n    __m128i blended_digits = _mm_and_si128(digit_vec, odd_mask);\n    \n    // Horizontal sum of odd digits\n    int16_t result_array[8];\n    _mm_storeu_si128((__m128i*)result_array, blended_digits);\n    \n    uint64_t product = 1;\n    bool has_odd_digit = false;\n    \n    for (int i = 0; i < 8; i++) {\n        if (result_array[i] > 0) {\n            product *= result_array[i];\n            has_odd_digit = true;\n        }\n    }\n    \n    return has_odd_digit ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = sprintf(digits, \"%llu\", n);\n    \n    // Pad with zeros if needed to align to 16-byte boundary\n    int padded_len = ((len + 15) / 16) * 16;\n    \n    // Load digits into SSE register\n    __m128i zero = _mm_setzero_si128();\n    __m128i digit_vec = _mm_loadu_si128((__m128i*)digits);\n    \n    // Subtract '0' to convert char to integer\n    __m128i ascii_offset = _mm_set1_epi8('0');\n    digit_vec = _mm_sub_epi8(digit_vec, ascii_offset);\n    \n    // Create mask for odd digits\n    __m128i one = _mm_set1_epi8(1);\n    __m128i odd_mask = _mm_and_si128(digit_vec, one);\n    odd_mask = _mm_cmpeq_epi8(odd_mask, one);\n    \n    // Blend odd digits\n    __m128i odd_digits = _mm_and_si128(digit_vec, odd_mask);\n    \n    // Horizontal multiply\n    int product = 1;\n    for (int i = 0; i < len; i++) {\n        uint8_t digit = _mm_extract_epi8(odd_digits, i);\n        if (digit != 0) {\n            product *= digit;\n        }\n    }\n    \n    return product == 1 ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = sprintf(digits, \"%llu\", n);\n    \n    // Pad with zeros if needed to align to 16-byte boundary\n    while (len % 16 != 0) {\n        digits[len++] = '0';\n    }\n    \n    // Initialize product to 1\n    uint64_t product = 1;\n    \n    // Process 16 digits at a time using SSE\n    for (int i = 0; i < len; i += 16) {\n        // Load 16 digits into SSE register\n        __m128i digit_vec = _mm_loadu_si128((__m128i*)&digits[i]);\n        \n        // Convert characters to integers\n        __m128i zero_vec = _mm_setzero_si128();\n        __m128i digit_ints = _mm_sub_epi8(digit_vec, _mm_set1_epi8('0'));\n        \n        // Create mask for odd digits\n        __m128i odd_mask = _mm_and_si128(digit_ints, _mm_set1_epi8(1));\n        odd_mask = _mm_cmpeq_epi8(odd_mask, _mm_set1_epi8(1));\n        \n        // Extract odd digits\n        __m128i odd_digits = _mm_and_si128(digit_ints, odd_mask);\n        \n        // Horizontal multiply of odd digits\n        for (int j = 0; j < 16; j++) {\n            int digit = _mm_extract_epi8(odd_digits, j);\n            if (digit > 0) {\n                product *= digit;\n            }\n        }\n    }\n    \n    // If no odd digits found, return 0\n    return (product == 1) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vectorSize = n - (n % 4);\n\n    __m128 sumSquares = _mm_setzero_ps();\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        // Load 4 float values\n        __m128 values = _mm_loadu_ps(&lst[i]);\n\n        // Round up to ceiling using SSE intrinsics\n        __m128 roundedValues = _mm_ceil_ps(values);\n\n        // Square the rounded values\n        __m128 squaredValues = _mm_mul_ps(roundedValues, roundedValues);\n\n        // Accumulate squared values\n        sumSquares = _mm_add_ps(sumSquares, squaredValues);\n    }\n\n    // Horizontal sum of squared values\n    __m128 shuffled1 = _mm_shuffle_ps(sumSquares, sumSquares, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 sumHalf1 = _mm_add_ps(sumSquares, shuffled1);\n    __m128 shuffled2 = _mm_shuffle_ps(sumHalf1, sumHalf1, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 sumTotal = _mm_add_ps(sumHalf1, shuffled2);\n\n    // Store the result\n    float finalSum[4];\n    _mm_storeu_ps(finalSum, sumTotal);\n    result += static_cast<uint64_t>(finalSum[0]);\n\n    // Process remaining elements\n    for (size_t i = vectorSize; i < n; ++i) {\n        int ceiledValue = std::ceil(lst[i]);\n        result += ceiledValue * ceiledValue;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vectorSize = n - (n % 4);\n\n    __m128 accumulator = _mm_setzero_ps();\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        // Load 4 float values\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        \n        // Round up to ceiling using SSE intrinsics\n        __m128 roundedValues = _mm_ceil_ps(values);\n        \n        // Square the rounded values\n        __m128 squaredValues = _mm_mul_ps(roundedValues, roundedValues);\n        \n        // Accumulate squared values\n        accumulator = _mm_add_ps(accumulator, squaredValues);\n    }\n\n    // Horizontal sum of accumulated values\n    __m128 shuffled1 = _mm_shuffle_ps(accumulator, accumulator, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 sum1 = _mm_add_ps(accumulator, shuffled1);\n    __m128 shuffled2 = _mm_shuffle_ps(sum1, sum1, _MM_SHUFFLE(0, 1, 0, 1));\n    __m128 finalSum = _mm_add_ps(sum1, shuffled2);\n\n    // Store final sum and convert to uint64_t\n    float sumArray[4];\n    _mm_storeu_ps(sumArray, finalSum);\n    result = static_cast<uint64_t>(sumArray[0]);\n\n    // Handle remaining elements\n    for (size_t i = vectorSize; i < n; ++i) {\n        float ceiledValue = std::ceil(lst[i]);\n        result += static_cast<uint64_t>(ceiledValue * ceiledValue);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vectorSize = n - (n % 4);\n\n    __m128 sumSquares = _mm_setzero_ps();\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        // Load 4 float values\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        \n        // Round up to ceiling using SSE intrinsics\n        __m128 roundedValues = _mm_ceil_ps(values);\n        \n        // Square the rounded values\n        __m128 squaredValues = _mm_mul_ps(roundedValues, roundedValues);\n        \n        // Accumulate squared values\n        sumSquares = _mm_add_ps(sumSquares, squaredValues);\n    }\n\n    // Horizontal sum of squared values\n    __m128 shuffled1 = _mm_shuffle_ps(sumSquares, sumSquares, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 sumHalf1 = _mm_add_ps(sumSquares, shuffled1);\n    __m128 shuffled2 = _mm_shuffle_ps(sumHalf1, sumHalf1, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 finalSum = _mm_add_ps(sumHalf1, shuffled2);\n\n    // Convert to uint64_t\n    result = static_cast<uint64_t>(_mm_cvtss_f32(finalSum));\n\n    // Handle remaining elements\n    for (size_t i = vectorSize; i < n; ++i) {\n        int ceiledValue = std::ceil(lst[i]);\n        result += ceiledValue * ceiledValue;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t vec_size = lst.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128 sum_vec = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 input_vec = _mm_loadu_ps(&lst[i]);\n        __m128 ceil_vec = _mm_ceil_ps(input_vec);\n        __m128 squared_vec = _mm_mul_ps(ceil_vec, ceil_vec);\n        sum_vec = _mm_add_ps(sum_vec, squared_vec);\n    }\n\n    float sum_array[4];\n    _mm_storeu_ps(sum_array, sum_vec);\n    result = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        int ceil_val = std::ceil(lst[i]);\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t n = lst.size();\n    size_t vectorSize = n - (n % 4);\n\n    __m128 sumSquares = _mm_setzero_ps();\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        // Load 4 float values\n        __m128 values = _mm_loadu_ps(&lst[i]);\n        \n        // Round up to ceiling using SSE intrinsics\n        __m128 roundedValues = _mm_ceil_ps(values);\n        \n        // Square the rounded values\n        __m128 squaredValues = _mm_mul_ps(roundedValues, roundedValues);\n        \n        // Accumulate squared values\n        sumSquares = _mm_add_ps(sumSquares, squaredValues);\n    }\n\n    // Horizontal sum of squared values\n    __m128 shuffled1 = _mm_shuffle_ps(sumSquares, sumSquares, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128 sumHalf1 = _mm_add_ps(sumSquares, shuffled1);\n    __m128 shuffled2 = _mm_shuffle_ps(sumHalf1, sumHalf1, _MM_SHUFFLE(0, 1, 2, 3));\n    __m128 finalSum = _mm_add_ps(sumHalf1, shuffled2);\n\n    // Convert to uint64_t\n    result = static_cast<uint64_t>(_mm_cvtss_f32(finalSum));\n\n    // Handle remaining elements\n    for (size_t i = vectorSize; i < n; ++i) {\n        int ceiledValue = std::ceil(lst[i]);\n        result += ceiledValue * ceiledValue;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Align data to 16-byte boundary for SSE\n    alignas(16) int result[4] = {-1, -1, -1, -1};\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        // Compare if current elements are not less than next elements\n        __m128i compare = _mm_cmpgt_epi32(current, next);\n        \n        // Store comparison results\n        _mm_store_si128((__m128i*)result, compare);\n        \n        // Check if any element violates the condition\n        for (int j = 0; j < 4; j++) {\n            if (result[j] != 0) {\n                return i + j;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Align to 16-byte boundary for SSE\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        __m128i compare = _mm_cmpgt_epi32(current, next);\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(compare));\n        \n        if (mask) {\n            for (int j = 0; j < 4; j++) {\n                if (arr[i+j] >= arr[i+j+1]) {\n                    return i+j;\n                }\n            }\n        }\n    }\n\n    for (int i = n - (n % 4); i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Align data to 16-byte boundary for SSE\n    alignas(16) int temp[4];\n\n    for (int i = 0; i < n - 4; i += 4) {\n        // Load 4 consecutive elements\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n\n        // Compare if current elements are not less than next elements\n        __m128i comparison = _mm_cmpge_epi32(current, next);\n\n        // Store comparison result\n        _mm_store_si128((__m128i*)temp, comparison);\n\n        // Check if any element violates the condition\n        for (int j = 0; j < 4; j++) {\n            if (temp[j] != 0) {\n                return i + j;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = (n - 4 < 0 ? 0 : n - 4); i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Align data to 16-byte boundary for SSE\n    alignas(16) int result[4] = {-1, -1, -1, -1};\n    \n    // Process 4 elements at a time\n    for (int i = 0; i < n - 4; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        // Compare if current elements are not less than next elements\n        __m128i compare = _mm_cmpgt_epi32(current, next);\n        \n        // Store comparison results\n        _mm_store_si128((__m128i*)result, compare);\n        \n        // Check if any element violates the condition\n        for (int j = 0; j < 4; j++) {\n            if (result[j] != 0) {\n                return i + j;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n - 4 > 0 ? n - 4 : 0); i < n - 1; i++) {\n        if (arr[i] >= arr[i+1]) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int size = lst.size();\n    int vec_size = size - (size % 4);\n\n    __m128i max_neg = _mm_set1_epi32(INT_MIN);\n    __m128i min_pos = _mm_set1_epi32(INT_MAX);\n\n    for (int i = 0; i < vec_size; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Mask for negative numbers\n        __m128i neg_mask = _mm_cmplt_epi32(current, _mm_setzero_si128());\n        \n        // Update max negative\n        __m128i masked_neg = _mm_and_si128(current, neg_mask);\n        max_neg = _mm_max_epi32(max_neg, masked_neg);\n        \n        // Mask for positive numbers\n        __m128i pos_mask = _mm_cmpgt_epi32(current, _mm_setzero_si128());\n        \n        // Update min positive\n        __m128i masked_pos = _mm_and_si128(current, pos_mask);\n        min_pos = _mm_min_epi32(min_pos, _mm_or_si128(masked_pos, _mm_cmpeq_epi32(masked_pos, _mm_setzero_si128())));\n    }\n\n    // Handle remaining elements\n    int max_neg_scalar = INT_MIN;\n    int min_pos_scalar = INT_MAX;\n    \n    for (int i = vec_size; i < size; i++) {\n        if (lst[i] < 0) {\n            max_neg_scalar = std::max(max_neg_scalar, lst[i]);\n        }\n        if (lst[i] > 0) {\n            min_pos_scalar = std::min(min_pos_scalar, lst[i]);\n        }\n    }\n\n    // Horizontal max/min for SIMD results\n    int max_neg_arr[4], min_pos_arr[4];\n    _mm_storeu_si128((__m128i*)max_neg_arr, max_neg);\n    _mm_storeu_si128((__m128i*)min_pos_arr, min_pos);\n\n    int max_neg_simd = std::max({max_neg_arr[0], max_neg_arr[1], max_neg_arr[2], max_neg_arr[3], max_neg_scalar});\n    int min_pos_simd = min_pos_arr[0] == 0 && min_pos_arr[1] == 0 && min_pos_arr[2] == 0 && min_pos_arr[3] == 0 ? \n                       (min_pos_scalar == INT_MAX ? 0 : min_pos_scalar) :\n                       std::min({min_pos_arr[0], min_pos_arr[1], min_pos_arr[2], min_pos_arr[3], min_pos_scalar});\n\n    max_neg_simd = max_neg_simd == INT_MIN ? 0 : max_neg_simd;\n    min_pos_simd = min_pos_simd == INT_MAX ? 0 : min_pos_simd;\n\n    return {max_neg_simd, min_pos_simd};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int size = lst.size();\n    int vector_size = size - (size % 4);\n\n    __m128i largest_negative = _mm_set1_epi32(INT_MIN);\n    __m128i smallest_positive = _mm_set1_epi32(INT_MAX);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        __m128i current = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n\n        // Find negative numbers\n        __m128i negative_mask = _mm_cmplt_epi32(current, _mm_setzero_si128());\n        __m128i negative_nums = _mm_and_si128(current, negative_mask);\n        largest_negative = _mm_max_epi32(largest_negative, negative_nums);\n\n        // Find positive numbers\n        __m128i positive_mask = _mm_cmpgt_epi32(current, _mm_setzero_si128());\n        __m128i positive_nums = _mm_and_si128(current, positive_mask);\n        smallest_positive = _mm_min_epi32(smallest_positive, _mm_or_si128(positive_nums, _mm_cmpeq_epi32(positive_nums, _mm_setzero_si128())));\n    }\n\n    // Handle remaining elements\n    int largest_neg = INT_MIN;\n    int smallest_pos = INT_MAX;\n\n    for (int i = vector_size; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_neg) {\n            largest_neg = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < smallest_pos) {\n            smallest_pos = lst[i];\n        }\n    }\n\n    // Horizontal max/min for SIMD results\n    int neg_array[4], pos_array[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(neg_array), largest_negative);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(pos_array), smallest_positive);\n\n    for (int i = 0; i < 4; ++i) {\n        if (neg_array[i] > largest_neg && neg_array[i] != 0) {\n            largest_neg = neg_array[i];\n        }\n        if (pos_array[i] < smallest_pos && pos_array[i] != 0) {\n            smallest_pos = pos_array[i];\n        }\n    }\n\n    if (largest_neg == INT_MIN) largest_neg = 0;\n    if (smallest_pos == INT_MAX) smallest_pos = 0;\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int size = lst.size();\n    int vector_size = size - (size % 4);\n\n    __m128i largest_negative = _mm_set1_epi32(INT_MIN);\n    __m128i smallest_positive = _mm_set1_epi32(INT_MAX);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        __m128i current = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n\n        // Find largest negative\n        __m128i negative_mask = _mm_cmplt_epi32(current, _mm_setzero_si128());\n        __m128i masked_negative = _mm_and_si128(current, negative_mask);\n        largest_negative = _mm_max_epi32(largest_negative, masked_negative);\n\n        // Find smallest positive\n        __m128i positive_mask = _mm_cmpgt_epi32(current, _mm_setzero_si128());\n        __m128i masked_positive = _mm_and_si128(current, positive_mask);\n        smallest_positive = _mm_min_epi32(smallest_positive, _mm_or_si128(masked_positive, _mm_cmpeq_epi32(masked_positive, _mm_setzero_si128())));\n    }\n\n    // Handle remaining elements\n    int largest_neg = INT_MIN;\n    int smallest_pos = INT_MAX;\n\n    for (int i = vector_size; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_neg) {\n            largest_neg = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < smallest_pos) {\n            smallest_pos = lst[i];\n        }\n    }\n\n    int neg_array[4], pos_array[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(neg_array), largest_negative);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(pos_array), smallest_positive);\n\n    for (int i = 0; i < 4; ++i) {\n        largest_neg = std::max(largest_neg, neg_array[i]);\n        smallest_pos = std::min(smallest_pos, pos_array[i] == 0 ? INT_MAX : pos_array[i]);\n    }\n\n    if (largest_neg == INT_MIN) largest_neg = 0;\n    if (smallest_pos == INT_MAX) smallest_pos = 0;\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int size = lst.size();\n    int vector_size = size - (size % 4);\n\n    __m128i largest_negative = _mm_set1_epi32(INT_MIN);\n    __m128i smallest_positive = _mm_set1_epi32(INT_MAX);\n\n    for (int i = 0; i < vector_size; i += 4) {\n        __m128i current = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n\n        // Mask for negative numbers\n        __m128i negative_mask = _mm_cmplt_epi32(current, _mm_setzero_si128());\n        \n        // Mask for positive numbers\n        __m128i positive_mask = _mm_cmpgt_epi32(current, _mm_setzero_si128());\n\n        // Update largest negative\n        __m128i masked_negative = _mm_and_si128(current, negative_mask);\n        largest_negative = _mm_max_epi32(largest_negative, masked_negative);\n\n        // Update smallest positive\n        __m128i masked_positive = _mm_and_si128(current, positive_mask);\n        smallest_positive = _mm_min_epi32(smallest_positive, \n            _mm_or_si128(masked_positive, _mm_cmpeq_epi32(masked_positive, _mm_setzero_si128())));\n    }\n\n    // Handle remaining elements\n    int largest_neg = INT_MIN;\n    int smallest_pos = INT_MAX;\n\n    for (int i = vector_size; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > largest_neg) {\n            largest_neg = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < smallest_pos) {\n            smallest_pos = lst[i];\n        }\n    }\n\n    // Horizontal max/min for SIMD results\n    int simd_largest_neg[4];\n    int simd_smallest_pos[4];\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(simd_largest_neg), largest_negative);\n    _mm_storeu_si128(reinterpret_cast<__m128i*>(simd_smallest_pos), smallest_positive);\n\n    for (int i = 0; i < 4; ++i) {\n        if (simd_largest_neg[i] > largest_neg && simd_largest_neg[i] < 0) {\n            largest_neg = simd_largest_neg[i];\n        }\n        if (simd_smallest_pos[i] < smallest_pos && simd_smallest_pos[i] > 0) {\n            smallest_pos = simd_smallest_pos[i];\n        }\n    }\n\n    // Final check\n    if (largest_neg == INT_MIN) largest_neg = 0;\n    if (smallest_pos == INT_MAX) smallest_pos = 0;\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int n = lst.size();\n    int vec_size = (n + 3) / 4 * 4;  // Round up to nearest multiple of 4\n    \n    // Pad the input vector with zeros if needed\n    std::vector<int> padded_lst(vec_size, 0);\n    std::copy(lst.begin(), lst.end(), padded_lst.begin());\n\n    __m128i max_negative = _mm_set1_epi32(INT_MIN);\n    __m128i min_positive = _mm_set1_epi32(INT_MAX);\n\n    for (int i = 0; i < vec_size; i += 4) {\n        __m128i current = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&padded_lst[i]));\n        \n        // Mask for negative numbers\n        __m128i negative_mask = _mm_cmplt_epi32(current, _mm_setzero_si128());\n        \n        // Mask for positive numbers (excluding zero)\n        __m128i positive_mask = _mm_cmpgt_epi32(current, _mm_setzero_si128());\n        \n        // Update max negative\n        __m128i masked_negative = _mm_and_si128(current, negative_mask);\n        max_negative = _mm_max_epi32(max_negative, masked_negative);\n        \n        // Update min positive\n        __m128i masked_positive = _mm_and_si128(current, positive_mask);\n        min_positive = _mm_min_epi32(min_positive, \n            _mm_or_si128(masked_positive, _mm_cmpeq_epi32(masked_positive, _mm_setzero_si128())));\n    }\n\n    // Horizontal max/min\n    __m128i max_negative_shifted = _mm_shuffle_epi32(max_negative, _MM_SHUFFLE(1, 0, 3, 2));\n    max_negative = _mm_max_epi32(max_negative, max_negative_shifted);\n    max_negative_shifted = _mm_shuffle_epi32(max_negative, _MM_SHUFFLE(0, 1, 2, 3));\n    max_negative = _mm_max_epi32(max_negative, max_negative_shifted);\n\n    __m128i min_positive_shifted = _mm_shuffle_epi32(min_positive, _MM_SHUFFLE(1, 0, 3, 2));\n    min_positive = _mm_min_epi32(min_positive, min_positive_shifted);\n    min_positive_shifted = _mm_shuffle_epi32(min_positive, _MM_SHUFFLE(0, 1, 2, 3));\n    min_positive = _mm_min_epi32(min_positive, min_positive_shifted);\n\n    int max_neg_val = _mm_cvtsi128_si32(max_negative);\n    int min_pos_val = _mm_cvtsi128_si32(min_positive);\n\n    // If no negative or positive numbers found\n    if (max_neg_val == 0) max_neg_val = 0;\n    if (min_pos_val == INT_MAX) min_pos_val = 0;\n\n    return {max_neg_val, min_pos_val};\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute factorials in parallel using SSE2 intrinsics\n    __m128i result_low = _mm_set1_epi64x(1);\n    __m128i result_high = _mm_set1_epi64x(1);\n    \n    uint64_t factorial = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial *= i;\n        \n        // Use SSE2 multiplication for parallel computation\n        __m128i current = _mm_set1_epi64x(i);\n        __m128i prod_low = _mm_mul_epu32(result_low, current);\n        __m128i prod_high = _mm_mul_epu32(result_high, current);\n        \n        result_low = prod_low;\n        result_high = prod_high;\n    }\n    \n    // Combine results\n    uint64_t final_result = factorial;\n    for (uint64_t j = 1; j < n; ++j) {\n        final_result *= factorial / j;\n    }\n    \n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute factorials in parallel using SSE2 intrinsics\n    __m128i result_low = _mm_set1_epi64x(1);\n    __m128i result_high = _mm_set1_epi64x(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial of current number\n        uint64_t current_factorial = 1;\n        for (uint64_t j = 1; j <= i; ++j) {\n            current_factorial *= j;\n        }\n\n        // Use SSE2 to multiply parallel 64-bit integers\n        __m128i current_val = _mm_set1_epi64x(current_factorial);\n        \n        // Multiply low and high parts separately\n        result_low = _mm_mul_epu32(result_low, current_val);\n        result_high = _mm_mul_epu32(result_high, current_val);\n    }\n\n    // Combine low and high results\n    uint64_t final_result = _mm_cvtsi128_si64(result_low) * _mm_cvtsi128_si64(result_high);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute initial factorials using scalar method\n    uint64_t result = 1;\n    uint64_t* factorials = new uint64_t[n + 1];\n    factorials[0] = 1;\n\n    for (uint64_t i = 1; i <= n; i++) {\n        factorials[i] = factorials[i-1] * i;\n    }\n\n    // Use SSE2 to parallelize multiplication\n    __m128i acc = _mm_set1_epi64x(1);\n    for (uint64_t i = 0; i <= n; i += 2) {\n        __m128i fact1 = _mm_set1_epi64x(factorials[i]);\n        __m128i fact2 = _mm_set1_epi64x(i + 1 <= n ? factorials[i+1] : 1);\n        __m128i prod = _mm_mul_epu32(fact1, fact2);\n        acc = _mm_mul_epu32(acc, prod);\n    }\n\n    // Horizontal add to get final result\n    __m128i high = _mm_srli_si128(acc, 8);\n    acc = _mm_add_epi64(acc, high);\n    result = _mm_cvtsi128_si64(acc);\n\n    delete[] factorials;\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute factorials in parallel using SSE2 intrinsics\n    __m128i result_low = _mm_set1_epi64x(1);\n    __m128i result_high = _mm_set1_epi64x(1);\n    \n    uint64_t factorial = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial *= i;\n        \n        // Parallel multiplication using SSE2\n        __m128i current = _mm_set1_epi64x(i);\n        __m128i factor_low = _mm_mul_epu32(result_low, current);\n        __m128i factor_high = _mm_mul_epu32(result_high, current);\n        \n        result_low = factor_low;\n        result_high = factor_high;\n    }\n    \n    // Extract and combine results\n    uint64_t result_array[2];\n    _mm_storeu_si128((__m128i*)result_array, result_low);\n    \n    return factorial * result_array[0];\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute individual factorials using SSE2 intrinsics\n    __m128i result_vec = _mm_set1_epi64x(1);\n    __m128i current_vec = _mm_set1_epi64x(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial of current number\n        __m128i factorial_vec = _mm_set1_epi64x(1);\n        __m128i counter_vec = _mm_set1_epi64x(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial_vec = _mm_mul_epi32(factorial_vec, counter_vec);\n            counter_vec = _mm_add_epi64(counter_vec, _mm_set1_epi64x(1));\n        }\n\n        // Multiply result with current factorial\n        result_vec = _mm_mul_epi32(result_vec, factorial_vec);\n    }\n\n    // Extract final result\n    uint64_t result;\n    _mm_storel_epi64((__m128i*)&result, result_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    \n    // Process 4 integers at a time using SSE\n    size_t i = 0;\n    for (; i + 3 < n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create masks for indices divisible by 3 and 4\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div3_mask = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_mod_epi32(indices, _mm_set1_epi32(3)));\n        __m128i div4_mask = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_mod_epi32(indices, _mm_set1_epi32(4)));\n        \n        // Square values at indices divisible by 3\n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i squared_masked = _mm_and_si128(squared, div3_mask);\n        \n        // Cube values at indices divisible by 4 but not 3\n        __m128i cubed_mask = _mm_andnot_si128(div3_mask, div4_mask);\n        __m128i cubed = _mm_mullo_epi32(vec, _mm_mullo_epi32(vec, vec));\n        __m128i cubed_masked = _mm_and_si128(cubed, cubed_mask);\n        \n        // Combine results\n        __m128i result = _mm_or_si128(squared_masked, cubed_masked);\n        result = _mm_or_si128(result, _mm_andnot_si128(_mm_or_si128(div3_mask, div4_mask), vec));\n        \n        // Horizontal sum\n        __m128i sum_vec = _mm_hadd_epi32(result, result);\n        sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n        sum += _mm_cvtsi128_si32(sum_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    \n    // Process 4 integers at a time using SSE2\n    size_t vectorized_length = n - (n % 4);\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < vectorized_length; i += 4) {\n        __m128i current = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create masks for indices divisible by 3 and 4\n        __m128i index_vec = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div3_mask = _mm_cmpeq_epi32(_mm_set_epi32(0, 0, 0, 0), \n                                             _mm_set_epi32((i+3)%3, (i+2)%3, (i+1)%3, i%3));\n        __m128i div4_mask = _mm_cmpeq_epi32(_mm_set_epi32(0, 0, 0, 0), \n                                             _mm_set_epi32((i+3)%4, (i+2)%4, (i+1)%4, i%4));\n        \n        // Compute squares for indices divisible by 3\n        __m128i squared = _mm_mullo_epi32(current, current);\n        squared = _mm_and_si128(squared, div3_mask);\n        \n        // Compute cubes for indices divisible by 4 but not 3\n        __m128i cubed = _mm_mullo_epi32(current, _mm_mullo_epi32(current, current));\n        cubed = _mm_and_si128(cubed, _mm_andnot_si128(div3_mask, div4_mask));\n        \n        // Combine results\n        __m128i result = _mm_or_si128(squared, cubed);\n        result = _mm_or_si128(result, _mm_andnot_si128(_mm_or_si128(div3_mask, div4_mask), current));\n        \n        sum_vec = _mm_add_epi32(sum_vec, result);\n    }\n    \n    // Horizontal sum\n    __m128i shuffle1 = _mm_shuffle_epi32(sum_vec, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum_half1 = _mm_add_epi32(sum_vec, shuffle1);\n    __m128i shuffle2 = _mm_shufflelo_epi16(sum_half1, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum_final = _mm_add_epi32(sum_half1, shuffle2);\n    \n    sum += _mm_cvtsi128_si32(sum_final);\n    \n    // Handle remaining elements\n    for (size_t i = vectorized_length; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int size = lst.size();\n    if (size == 0) return 0;\n\n    // Align the size to process 4 integers at a time\n    int aligned_size = size - (size % 4);\n    __m128i sum_vector = _mm_setzero_si128();\n\n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i current = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create masks for indices divisible by 3 and 4\n        __m128i index_vec = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div3_mask = _mm_cmpeq_epi32(_mm_setzero_si128(), \n                            _mm_or_si128(_mm_or_si128(_mm_slli_epi32(index_vec, 30), \n                                          _mm_slli_epi32(index_vec, 31)), \n                                          _mm_slli_epi32(index_vec, 29)));\n        __m128i div4_mask = _mm_cmpeq_epi32(_mm_setzero_si128(), \n                            _mm_or_si128(_mm_slli_epi32(index_vec, 30), \n                                          _mm_slli_epi32(index_vec, 28)));\n        \n        // Compute squares for indices divisible by 3\n        __m128i squared = _mm_mullo_epi32(current, current);\n        squared = _mm_and_si128(squared, div3_mask);\n        \n        // Compute cubes for indices divisible by 4 but not 3\n        __m128i cubed = _mm_mullo_epi32(current, _mm_mullo_epi32(current, current));\n        cubed = _mm_and_si128(cubed, _mm_andnot_si128(div3_mask, div4_mask));\n        \n        // Combine results\n        __m128i result = _mm_or_si128(squared, cubed);\n        result = _mm_or_si128(result, _mm_andnot_si128(_mm_or_si128(div3_mask, div4_mask), current));\n        \n        // Add to sum\n        sum_vector = _mm_add_epi32(sum_vector, result);\n    }\n\n    // Horizontal sum of vector\n    __m128i shuffle1 = _mm_shuffle_epi32(sum_vector, _MM_SHUFFLE(1, 0, 3, 2));\n    __m128i sum1 = _mm_add_epi32(sum_vector, shuffle1);\n    __m128i shuffle2 = _mm_shuffle_epi32(sum1, _MM_SHUFFLE(0, 1, 0, 1));\n    __m128i final_sum = _mm_add_epi32(sum1, shuffle2);\n    \n    int result = _mm_cvtsi128_si32(final_sum);\n\n    // Process remaining elements\n    for (int i = aligned_size; i < size; ++i) {\n        if (i % 3 == 0) {\n            result += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            result += lst[i] * lst[i] * lst[i];\n        } else {\n            result += lst[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    \n    // Process 4 integers at a time using SSE\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create masks for indices divisible by 3 and 4\n        __m128i index_vec = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div3_mask = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_mullo_epi32(index_vec, _mm_set1_epi32(1/3)));\n        __m128i div4_mask = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_mullo_epi32(index_vec, _mm_set1_epi32(1/4)));\n        \n        // Square values at indices divisible by 3\n        __m128i squared = _mm_mullo_epi32(vec, vec);\n        __m128i squared_masked = _mm_and_si128(squared, div3_mask);\n        \n        // Cube values at indices divisible by 4 but not 3\n        __m128i cubed_mask = _mm_andnot_si128(div3_mask, div4_mask);\n        __m128i cubed = _mm_mullo_epi32(_mm_mullo_epi32(vec, vec), vec);\n        __m128i cubed_masked = _mm_and_si128(cubed, cubed_mask);\n        \n        // Combine squared and cubed values\n        __m128i result = _mm_or_si128(squared_masked, cubed_masked);\n        \n        // Horizontal sum\n        __m128i sum_vec = _mm_hadd_epi32(result, result);\n        sum_vec = _mm_hadd_epi32(sum_vec, sum_vec);\n        sum += _mm_cvtsi128_si32(sum_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int sum = 0;\n    size_t n = lst.size();\n    size_t vectorSize = n - (n % 4);\n\n    // Process 4 integers at a time using SSE\n    __m128i sumVector = _mm_setzero_si128();\n\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        __m128i currentVector = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&lst[i]));\n        \n        // Create masks for indices multiples of 3 and 4\n        __m128i indexVector = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i multipleOf3Mask = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_mod_epi32(indexVector, _mm_set1_epi32(3)));\n        __m128i multipleOf4Mask = _mm_cmpeq_epi32(_mm_set1_epi32(0), _mm_mod_epi32(indexVector, _mm_set1_epi32(4)));\n        \n        // Square values for indices multiple of 3\n        __m128i squaredVector = _mm_mullo_epi32(currentVector, currentVector);\n        squaredVector = _mm_and_si128(squaredVector, multipleOf3Mask);\n        \n        // Cube values for indices multiple of 4 but not 3\n        __m128i cubedVector = _mm_mullo_epi32(currentVector, _mm_mullo_epi32(currentVector, currentVector));\n        cubedVector = _mm_and_si128(cubedVector, _mm_andnot_si128(multipleOf3Mask, multipleOf4Mask));\n        \n        // Combine squared and cubed values\n        __m128i processedVector = _mm_or_si128(squaredVector, cubedVector);\n        \n        // Add original values for non-multiple indices\n        __m128i originalMask = _mm_andnot_si128(_mm_or_si128(multipleOf3Mask, multipleOf4Mask), _mm_set1_epi32(0xFFFFFFFF));\n        processedVector = _mm_or_si128(processedVector, _mm_and_si128(currentVector, originalMask));\n        \n        // Accumulate sum\n        sumVector = _mm_add_epi32(sumVector, processedVector);\n    }\n\n    // Horizontal sum of vector\n    __m128i shuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(1, 0, 3, 2));\n    sumVector = _mm_add_epi32(sumVector, shuffled);\n    shuffled = _mm_shuffle_epi32(sumVector, _MM_SHUFFLE(0, 1, 0, 1));\n    sumVector = _mm_add_epi32(sumVector, shuffled);\n    \n    sum = _mm_cvtsi128_si32(sumVector);\n\n    // Process remaining elements\n    for (size_t i = vectorSize; i < n; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        \n        // Check > 10\n        __m128i compare_gt10 = _mm_cmpgt_epi32(vec, _mm_set1_epi32(10));\n        \n        // Extract first and last digits\n        __m128i abs_vec = _mm_abs_epi32(vec);\n        __m128i first_digit = abs_vec;\n        __m128i last_digit = _mm_mod_epi32(abs_vec, _mm_set1_epi32(10));\n        \n        // Check if first and last digits are odd\n        __m128i first_odd = _mm_cmpeq_epi32(_mm_mod_epi32(first_digit, _mm_set1_epi32(10)), _mm_set1_epi32(1));\n        __m128i last_odd = _mm_cmpeq_epi32(_mm_mod_epi32(last_digit, _mm_set1_epi32(2)), _mm_set1_epi32(1));\n        \n        // Combine conditions\n        __m128i result = _mm_and_si128(compare_gt10, _mm_and_si128(first_odd, last_odd));\n        \n        // Count matching elements\n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    // Process remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        int num = nums[i];\n        int abs_num = std::abs(num);\n        int first_digit = abs_num;\n        while (first_digit >= 10) first_digit /= 10;\n        int last_digit = abs_num % 10;\n        \n        if (num > 10 && first_digit % 2 == 1 && last_digit % 2 == 1) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vec_size = nums.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    // SSE processing for 4 elements at a time\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        \n        // Check > 10\n        __m128i ten = _mm_set1_epi32(10);\n        __m128i mask_gt_ten = _mm_cmpgt_epi32(vec, ten);\n        \n        // First digit check (absolute value)\n        __m128i abs_vec = _mm_abs_epi32(vec);\n        __m128i first_digit_mask = _mm_set1_epi32(0);\n        \n        for (int j = 0; j < 4; j++) {\n            int num = abs_vec.m128i_i32[j];\n            while (num >= 10) num /= 10;\n            \n            if (num % 2 == 1) {\n                first_digit_mask.m128i_i32[j] = 0xFFFFFFFF;\n            }\n        }\n        \n        // Last digit check\n        __m128i last_digit_mask = _mm_set1_epi32(0);\n        \n        for (int j = 0; j < 4; j++) {\n            int num = std::abs(nums[i + j]);\n            if (num % 10 % 2 == 1) {\n                last_digit_mask.m128i_i32[j] = 0xFFFFFFFF;\n            }\n        }\n        \n        // Combine masks\n        __m128i combined_mask = _mm_and_si128(mask_gt_ten, first_digit_mask);\n        combined_mask = _mm_and_si128(combined_mask, last_digit_mask);\n        \n        // Count matching elements\n        for (int j = 0; j < 4; j++) {\n            if (combined_mask.m128i_i32[j] != 0) {\n                count++;\n            }\n        }\n    }\n    \n    // Process remaining elements\n    for (size_t i = simd_size; i < vec_size; i++) {\n        int num = std::abs(nums[i]);\n        int first_digit = num;\n        while (first_digit >= 10) first_digit /= 10;\n        \n        if (nums[i] > 10 && first_digit % 2 == 1 && num % 10 % 2 == 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Check > 10\n        __m128i gt10_mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(10));\n        \n        // First digit odd check\n        __m128i first_digit_mask = _mm_set_epi32(\n            (std::abs(nums[i+3]) % 10) % 2 == 1,\n            (std::abs(nums[i+2]) % 10) % 2 == 1,\n            (std::abs(nums[i+1]) % 10) % 2 == 1,\n            (std::abs(nums[i]) % 10) % 2 == 1\n        );\n        \n        // Last digit odd check\n        __m128i last_digit_mask = _mm_set_epi32(\n            (nums[i+3] / std::abs(std::pow(10, std::floor(std::log10(std::abs(nums[i+3]))) + 1))) % 2 == 1,\n            (nums[i+2] / std::abs(std::pow(10, std::floor(std::log10(std::abs(nums[i+2]))) + 1))) % 2 == 1,\n            (nums[i+1] / std::abs(std::pow(10, std::floor(std::log10(std::abs(nums[i+1]))) + 1))) % 2 == 1,\n            (nums[i] / std::abs(std::pow(10, std::floor(std::log10(std::abs(nums[i]))) + 1))) % 2 == 1\n        );\n        \n        // Combine masks\n        __m128i combined_mask = _mm_and_si128(gt10_mask, _mm_and_si128(first_digit_mask, last_digit_mask));\n        \n        // Count matching elements\n        count += _mm_popcnt_u32(_mm_movemask_epi8(combined_mask));\n    }\n    \n    // Handle remaining elements\n    for (int i = size - (size % 4); i < size; ++i) {\n        if (std::abs(nums[i]) > 10 && \n            (std::abs(nums[i]) % 10) % 2 == 1 && \n            (nums[i] / std::abs(std::pow(10, std::floor(std::log10(std::abs(nums[i]))) + 1))) % 2 == 1) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        \n        // Check if elements are greater than 10\n        __m128i gt10_mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(10));\n        \n        // Extract first and last digits\n        __m128i abs_vec = _mm_abs_epi32(vec);\n        __m128i first_digit = _mm_div_epi32(abs_vec, _mm_set1_epi32(pow(10, floor(log10(INT_MAX)))));\n        __m128i last_digit = _mm_mod_epi32(abs_vec, _mm_set1_epi32(10));\n        \n        // Check if first and last digits are odd\n        __m128i first_odd_mask = _mm_cmpeq_epi32(_mm_mod_epi32(first_digit, _mm_set1_epi32(2)), _mm_set1_epi32(1));\n        __m128i last_odd_mask = _mm_cmpeq_epi32(_mm_mod_epi32(last_digit, _mm_set1_epi32(2)), _mm_set1_epi32(1));\n        \n        // Combine masks\n        __m128i combined_mask = _mm_and_si128(gt10_mask, _mm_and_si128(first_odd_mask, last_odd_mask));\n        \n        // Count matching elements\n        count += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(combined_mask)));\n    }\n    \n    // Handle remaining elements\n    for (int i = size - (size % 4); i < size; ++i) {\n        if (nums[i] > 10) {\n            int abs_num = std::abs(nums[i]);\n            int first_digit = abs_num / static_cast<int>(pow(10, floor(log10(abs_num))));\n            int last_digit = abs_num % 10;\n            \n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                ++count;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < size - 3; i += 4) {\n        __m128i vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&nums[i]));\n        \n        // Check > 10\n        __m128i gt10_mask = _mm_cmpgt_epi32(vec, _mm_set1_epi32(10));\n        \n        // Check first digit is odd\n        __m128i first_digit_mask = _mm_set_epi32(\n            (std::abs(nums[i+3]) % 10) % 2 == 1,\n            (std::abs(nums[i+2]) % 10) % 2 == 1,\n            (std::abs(nums[i+1]) % 10) % 2 == 1,\n            (std::abs(nums[i]) % 10) % 2 == 1\n        );\n        \n        // Check last digit is odd\n        __m128i last_digit_mask = _mm_set_epi32(\n            (std::abs(nums[i+3]) / std::pow(10, std::floor(std::log10(std::abs(nums[i+3])))) % 2 == 1),\n            (std::abs(nums[i+2]) / std::pow(10, std::floor(std::log10(std::abs(nums[i+2])))) % 2 == 1),\n            (std::abs(nums[i+1]) / std::pow(10, std::floor(std::log10(std::abs(nums[i+1])))) % 2 == 1),\n            (std::abs(nums[i]) / std::pow(10, std::floor(std::log10(std::abs(nums[i])))) % 2 == 1)\n        );\n        \n        // Combine masks\n        __m128i combined_mask = _mm_and_si128(gt10_mask, _mm_and_si128(first_digit_mask, last_digit_mask));\n        \n        // Count matching elements\n        count += _mm_popcnt_u32(_mm_movemask_epi8(combined_mask));\n    }\n    \n    // Handle remaining elements\n    for (int i = size - (size % 4); i < size; ++i) {\n        if (std::abs(nums[i]) > 10 && \n            (std::abs(nums[i]) % 10) % 2 == 1 && \n            (std::abs(nums[i]) / std::pow(10, std::floor(std::log10(std::abs(nums[i]))))) % 2 == 1) {\n            ++count;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate aligned memory for vector\n    __attribute__((aligned(16))) uint64_t* a = new uint64_t[n];\n    \n    // Compute vector values using SSE2 intrinsics\n    for (uint64_t i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i+1, i);\n        __m128i indices_next = _mm_set_epi64x(i+3, i+2);\n        \n        __m128i squared = _mm_mul_epi32(indices, indices);\n        __m128i squared_next = _mm_mul_epi32(indices_next, indices_next);\n        \n        __m128i subtracted = _mm_sub_epi32(squared, indices);\n        __m128i subtracted_next = _mm_sub_epi32(squared_next, indices_next);\n        \n        __m128i result = _mm_add_epi32(subtracted, _mm_set1_epi32(1));\n        __m128i result_next = _mm_add_epi32(subtracted_next, _mm_set1_epi32(1));\n        \n        _mm_storeu_si128((__m128i*)&a[i], result);\n        _mm_storeu_si128((__m128i*)&a[i+2], result_next);\n    }\n    \n    // Count valid triples\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate aligned memory for vector a\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Compute vector a using SSE2 intrinsics\n    for (uint64_t i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i+1, i);\n        __m128i indices2 = _mm_set_epi64x(i+3, i+2);\n        \n        __m128i squared1 = _mm_mul_epi32(indices, indices);\n        __m128i squared2 = _mm_mul_epi32(indices2, indices2);\n        \n        __m128i result1 = _mm_sub_epi32(squared1, indices);\n        __m128i result2 = _mm_sub_epi32(squared2, indices2);\n        \n        _mm_storeu_si128((__m128i*)(a + i), _mm_add_epi32(result1, _mm_set1_epi32(1)));\n        _mm_storeu_si128((__m128i*)(a + i + 2), _mm_add_epi32(result2, _mm_set1_epi32(1)));\n    }\n    \n    uint64_t triples_count = 0;\n    \n    // Compute triples using nested loops\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    triples_count++;\n                }\n            }\n        }\n    }\n    \n    // Free aligned memory\n    _mm_free(a);\n    \n    return triples_count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate aligned memory for vector\n    __attribute__((aligned(16))) uint64_t* a = new uint64_t[n];\n    \n    // Compute vector a using SSE2 intrinsics\n    for (uint64_t i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i+1, i);\n        __m128i indices2 = _mm_set_epi64x(i+3, i+2);\n        \n        __m128i squared1 = _mm_mul_epi32(indices, indices);\n        __m128i squared2 = _mm_mul_epi32(indices2, indices2);\n        \n        __m128i result1 = _mm_sub_epi32(_mm_add_epi32(squared1, _mm_set1_epi32(1)), indices);\n        __m128i result2 = _mm_sub_epi32(_mm_add_epi32(squared2, _mm_set1_epi32(1)), indices2);\n        \n        _mm_storeu_si128((__m128i*)&a[i], result1);\n        _mm_storeu_si128((__m128i*)&a[i+2], result2);\n    }\n    \n    // Count triples\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate aligned memory for vector\n    __attribute__((aligned(16))) uint64_t* a = new uint64_t[n];\n    \n    // Compute vector values using SSE2 intrinsics\n    for (uint64_t i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i+1, i);\n        __m128i indices2 = _mm_set_epi64x(i+3, i+2);\n        \n        __m128i squared1 = _mm_mul_epi32(indices, indices);\n        __m128i squared2 = _mm_mul_epi32(indices2, indices2);\n        \n        __m128i result1 = _mm_sub_epi32(_mm_add_epi32(squared1, _mm_set1_epi32(1)), indices);\n        __m128i result2 = _mm_sub_epi32(_mm_add_epi32(squared2, _mm_set1_epi32(1)), indices2);\n        \n        _mm_storeu_si128((__m128i*)&a[i], result1);\n        _mm_storeu_si128((__m128i*)&a[i+2], result2);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = (n/4)*4; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    \n    uint64_t count = 0;\n    \n    // Parallel triple counting\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate aligned memory for vector\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Compute vector elements using SSE\n    for (uint64_t i = 0; i < n; i += 4) {\n        __m128i indices = _mm_set_epi64x(i+1, i);\n        __m128i indices2 = _mm_set_epi64x(i+3, i+2);\n        \n        __m128i squared1 = _mm_mul_epi32(indices, indices);\n        __m128i squared2 = _mm_mul_epi32(indices2, indices2);\n        \n        __m128i result1 = _mm_sub_epi32(squared1, indices);\n        __m128i result2 = _mm_sub_epi32(squared2, indices2);\n        \n        _mm_storeu_si128((__m128i*)(a + i), _mm_add_epi32(result1, _mm_set1_epi32(1)));\n        _mm_storeu_si128((__m128i*)(a + i + 2), _mm_add_epi32(result2, _mm_set1_epi32(1)));\n    }\n    \n    // Count triples\n    uint64_t triples = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    triples++;\n                }\n            }\n        }\n    }\n    \n    _mm_free(a);\n    return triples;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SSE2 intrinsics\n    if (n <= 1) return y;\n    \n    __m128i divisor = _mm_set1_epi32(2);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i max = _mm_set1_epi32((int)sqrt(n));\n    __m128i result = _mm_set1_epi32(1);\n\n    while (_mm_cvtsi128_si32(_mm_cmpgt_epi32(max, divisor))) {\n        __m128i mod = _mm_set1_epi32(n % _mm_cvtsi128_si32(divisor));\n        result = _mm_and_si128(result, _mm_cmpneq_epi32(mod, _mm_setzero_si128()));\n        divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1));\n    }\n\n    return (_mm_cvtsi128_si32(result) && n > 1) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SSE2 intrinsics\n    if (n <= 1) return y;\n    \n    __m128i divisor = _mm_set1_epi32(2);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i result = _mm_set1_epi32(1);\n    \n    // Parallel primality check up to sqrt(n)\n    for (; _mm_cvtsi128_si32(divisor) * _mm_cvtsi128_si32(divisor) <= n; \n           divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1))) {\n        \n        __m128i mod = _mm_set1_epi32(n % _mm_cvtsi128_si32(divisor));\n        result = _mm_and_si128(result, _mm_cmpgt_epi32(mod, _mm_setzero_si128()));\n    }\n    \n    // If result is non-zero, n is prime\n    return (_mm_cvtsi128_si32(result) != 0) ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check primality using SSE2 intrinsics\n    __m128i num = _mm_set1_epi32(n);\n    __m128i two = _mm_set1_epi32(2);\n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    // Early exit for small numbers\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n    \n    // Check divisibility up to sqrt(n)\n    for (int i = 3; i * i <= n; i += 2) {\n        __m128i divisor = _mm_set1_epi32(i);\n        __m128i mod = _mm_setzero_si128();\n        \n        // Compute modulo using SSE2 division\n        __m128i quotient = _mm_div_epi32(num, divisor);\n        __m128i product = _mm_mullo_epi32(quotient, divisor);\n        mod = _mm_sub_epi32(num, product);\n        \n        // If remainder is zero, not prime\n        if (_mm_movemask_epi8(_mm_cmpeq_epi32(mod, zero)) & 0xFFFF) {\n            return y;\n        }\n    }\n    \n    // If no divisors found, it's prime\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SSE2 intrinsics\n    if (n <= 1) return y;\n    \n    __m128i divisor = _mm_set1_epi32(2);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i result = _mm_set1_epi32(1);\n    \n    // Parallel division check up to sqrt(n)\n    for (int i = 2; i * i <= n; i += 4) {\n        __m128i current = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i mod = _mm_set1_epi32(0);\n        \n        // Parallel modulo computation\n        __m128i div = _mm_div_epi32(num, current);\n        __m128i mul = _mm_mullo_epi32(div, current);\n        __m128i diff = _mm_sub_epi32(num, mul);\n        \n        // Check if any division results in zero remainder\n        __m128i zero = _mm_cmpeq_epi32(diff, _mm_setzero_si128());\n        int mask = _mm_movemask_epi8(zero);\n        \n        if (mask != 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SSE2 intrinsics\n    if (n <= 1) return y;\n    \n    __m128i divisor = _mm_set1_epi32(2);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i result = _mm_set1_epi32(1);\n    \n    // Parallel division checks\n    for (; _mm_cvtsi128_si32(divisor) <= __builtin_sqrt(n); \n           divisor = _mm_add_epi32(divisor, _mm_set1_epi32(1))) {\n        \n        __m128i mod = _mm_set1_epi32(n % _mm_cvtsi128_si32(divisor));\n        result = _mm_and_si128(result, \n                   _mm_cmpgt_epi32(_mm_set1_epi32(1), \n                     _mm_cmpeq_epi32(mod, _mm_setzero_si128())));\n    }\n    \n    // Return x if prime, y otherwise\n    return (_mm_cvtsi128_si32(result) == 1) ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t vec_size = lst.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128 sum_squares = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 vec_data = _mm_loadu_ps(&lst[i]);\n        \n        // Check for odd integers\n        __m128 is_odd = _mm_and_ps(\n            _mm_cmpneq_ps(_mm_mod_ps(vec_data, _mm_set1_ps(2.0f)), _mm_setzero_ps()),\n            _mm_cmpge_ps(vec_data, _mm_setzero_ps())\n        );\n\n        // Square the odd integers\n        __m128 squared_odds = _mm_and_ps(_mm_mul_ps(vec_data, vec_data), is_odd);\n        \n        sum_squares = _mm_add_ps(sum_squares, squared_odds);\n    }\n\n    // Horizontal sum\n    __m128 sum_high = _mm_movehl_ps(sum_squares, sum_squares);\n    sum_squares = _mm_add_ps(sum_squares, sum_high);\n    sum_squares = _mm_add_ss(sum_squares, _mm_shuffle_ps(sum_squares, sum_squares, 1));\n\n    float final_sum = _mm_cvtss_f32(sum_squares);\n\n    // Handle remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && static_cast<int>(val) == val && static_cast<int>(val) % 2 != 0) {\n            final_sum += val * val;\n        }\n    }\n\n    return static_cast<uint64_t>(final_sum);\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t vec_size = lst.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128 sum_squares = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 vec_data = _mm_loadu_ps(&lst[i]);\n        \n        // Check for odd integers\n        __m128 is_odd = _mm_and_ps(\n            _mm_cmpneq_ps(_mm_mod_ps(vec_data, _mm_set1_ps(2.0f)), _mm_setzero_ps()),\n            _mm_cmpge_ps(vec_data, _mm_setzero_ps())\n        );\n\n        // Square the odd integers\n        __m128 squared_odds = _mm_and_ps(_mm_mul_ps(vec_data, vec_data), is_odd);\n        \n        sum_squares = _mm_add_ps(sum_squares, squared_odds);\n    }\n\n    // Horizontal sum\n    __m128 sum_high = _mm_movehl_ps(sum_squares, sum_squares);\n    sum_squares = _mm_add_ps(sum_squares, sum_high);\n    sum_squares = _mm_add_ss(sum_squares, _mm_shuffle_ps(sum_squares, sum_squares, 1));\n\n    float final_sum = _mm_cvtss_f32(sum_squares);\n\n    // Handle remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && static_cast<int>(val) == val && static_cast<int>(val) % 2 == 1) {\n            final_sum += val * val;\n        }\n    }\n\n    return static_cast<uint64_t>(final_sum);\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t vec_size = lst.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128 sum_squares = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 vec_data = _mm_loadu_ps(&lst[i]);\n        \n        // Check for odd integers\n        __m128 is_odd = _mm_and_ps(\n            _mm_cmpneq_ps(_mm_mod_ps(vec_data, _mm_set1_ps(2.0f)), _mm_setzero_ps()),\n            _mm_cmpge_ps(vec_data, _mm_setzero_ps())\n        );\n\n        // Square the odd numbers\n        __m128 squared = _mm_mul_ps(vec_data, vec_data);\n        squared = _mm_and_ps(squared, is_odd);\n\n        sum_squares = _mm_add_ps(sum_squares, squared);\n    }\n\n    // Horizontal sum\n    __m128 sum_high = _mm_movehl_ps(sum_squares, sum_squares);\n    sum_squares = _mm_add_ps(sum_squares, sum_high);\n    sum_squares = _mm_add_ss(sum_squares, _mm_shuffle_ps(sum_squares, sum_squares, 1));\n\n    float final_sum = _mm_cvtss_f32(sum_squares);\n\n    // Handle remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && static_cast<int>(val) == val && static_cast<int>(val) % 2 != 0) {\n            final_sum += val * val;\n        }\n    }\n\n    return static_cast<uint64_t>(final_sum);\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t vec_size = lst.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128 sum_vec = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 input_vec = _mm_loadu_ps(&lst[i]);\n        \n        // Check for odd integers\n        __m128 is_odd_mask = _mm_and_ps(\n            _mm_cmpneq_ps(_mm_mod_ps(input_vec, _mm_set1_ps(2.0f)), _mm_setzero_ps()),\n            _mm_cmpge_ps(input_vec, _mm_setzero_ps())\n        );\n\n        // Square the odd integers\n        __m128 squared_vec = _mm_mul_ps(input_vec, input_vec);\n        \n        // Mask the squared values\n        __m128 masked_squared_vec = _mm_and_ps(squared_vec, is_odd_mask);\n        \n        // Accumulate\n        sum_vec = _mm_add_ps(sum_vec, masked_squared_vec);\n    }\n\n    // Horizontal sum\n    __m128 sum_high = _mm_movehl_ps(sum_vec, sum_vec);\n    sum_vec = _mm_add_ps(sum_vec, sum_high);\n    sum_vec = _mm_add_ss(sum_vec, _mm_shuffle_ps(sum_vec, sum_vec, 1));\n\n    float final_sum = _mm_cvtss_f32(sum_vec);\n\n    // Handle remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && static_cast<int>(val) == val && static_cast<int>(val) % 2 != 0) {\n            final_sum += val * val;\n        }\n    }\n\n    return static_cast<uint64_t>(final_sum);\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    size_t vec_size = lst.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n\n    __m128 sum_vec = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 input_vec = _mm_loadu_ps(&lst[i]);\n        \n        // Check for odd integers\n        __m128 is_odd_mask = _mm_and_ps(\n            _mm_cmpneq_ps(_mm_mod_ps(input_vec, _mm_set1_ps(2.0f)), _mm_setzero_ps()),\n            _mm_cmpge_ps(input_vec, _mm_setzero_ps())\n        );\n\n        // Square the odd integers\n        __m128 squared_vec = _mm_mul_ps(input_vec, input_vec);\n        \n        // Mask the squared values\n        __m128 masked_squared_vec = _mm_and_ps(squared_vec, is_odd_mask);\n        \n        // Accumulate\n        sum_vec = _mm_add_ps(sum_vec, masked_squared_vec);\n    }\n\n    // Horizontal sum\n    __m128 sum_high = _mm_movehl_ps(sum_vec, sum_vec);\n    sum_vec = _mm_add_ps(sum_vec, sum_high);\n    sum_vec = _mm_add_ss(sum_vec, _mm_shuffle_ps(sum_vec, sum_vec, 1));\n\n    float final_sum = _mm_cvtss_f32(sum_vec);\n\n    // Handle remaining elements\n    for (size_t i = simd_size; i < vec_size; ++i) {\n        if (lst[i] > 0 && static_cast<int>(lst[i]) == lst[i] && static_cast<int>(lst[i]) % 2 == 1) {\n            final_sum += lst[i] * lst[i];\n        }\n    }\n\n    return static_cast<uint64_t>(final_sum);\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load 4 game scores and 4 guesses into SSE registers\n        __m128i game_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&game[i]));\n        __m128i guess_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&guess[i]));\n        \n        // Subtract guesses from scores\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        \n        // Take absolute value using sign bit manipulation\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        // Store results back to result vector\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), abs_diff_vec);\n    }\n    \n    // Handle remaining elements if vector length is not multiple of 4\n    for (int i = n - (n % 4); i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load 4 game scores and 4 guesses into SSE registers\n        __m128i game_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&game[i]));\n        __m128i guess_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&guess[i]));\n        \n        // Subtract guesses from game scores\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        \n        // Take absolute value using sign bit manipulation\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        // Store results back to result vector\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), abs_diff_vec);\n    }\n    \n    // Handle remaining elements if vector length is not multiple of 4\n    for (int i = n - (n % 4); i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        // Subtract guess from game\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        \n        // Take absolute value\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], abs_diff_vec);\n    }\n    \n    // Handle remaining elements\n    for (int i = n - (n % 4); i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load 4 game scores and 4 guesses into SSE registers\n        __m128i game_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&game[i]));\n        __m128i guess_vec = _mm_loadu_si128(reinterpret_cast<const __m128i*>(&guess[i]));\n        \n        // Subtract guesses from game scores\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        \n        // Take absolute value using sign bit manipulation\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        // Store results back to result vector\n        _mm_storeu_si128(reinterpret_cast<__m128i*>(&result[i]), abs_diff_vec);\n    }\n    \n    // Handle remaining elements if vector length is not multiple of 4\n    for (int i = n - (n % 4); i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n    \n    // Process 4 integers at a time using SSE\n    for (int i = 0; i < n; i += 4) {\n        // Load 4 game scores and 4 guesses into SSE registers\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        // Subtract guesses from game scores\n        __m128i diff_vec = _mm_sub_epi32(game_vec, guess_vec);\n        \n        // Take absolute value using sign manipulation\n        __m128i abs_diff_vec = _mm_abs_epi32(diff_vec);\n        \n        // Store results back to result vector\n        _mm_storeu_si128((__m128i*)&result[i], abs_diff_vec);\n    }\n    \n    // Handle remaining elements if vector length is not multiple of 4\n    for (int i = n - (n % 4); i < n; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}

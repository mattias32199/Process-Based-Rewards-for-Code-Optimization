{"task_id": "SimdBench_0_SVE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svint64_t mask_vec = svreinterpret_s64_u8(svld1_u8(pg, (const uint8_t*)(mask + i)));\n        \n        svint64_t dst_vec = svsel_s64(pg, src_vec, svld1_s64(pg, dst + i));\n        \n        svst1_s64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svint64_t dst_vec = svld1_s64(pg, dst + i);\n        svbool_t mask_vec = svld1_b_s64(pg, mask + i);\n        \n        svint64_t result = svsel_s64(mask_vec, src_vec, dst_vec);\n        \n        svst1_s64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load source vector\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        \n        // Load mask vector\n        svbool_t mask_vec = svld1_b_s64(pg, mask + i);\n        \n        // Conditionally move elements based on mask\n        svint64_t dst_vec = svsel_s64(mask_vec, src_vec, svld1_s64(pg, dst + i));\n        \n        // Store result back to destination\n        svst1_s64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load source vector elements\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        \n        // Load mask vector elements\n        svbool_t mask_vec = svld1_b_s64(pg, mask + i);\n        \n        // Conditionally move elements based on mask\n        svint64_t dst_vec = svsel_s64(mask_vec, src_vec, svld1_s64(pg, dst + i));\n        \n        // Store result back to destination\n        svst1_s64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load source vector elements\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        \n        // Load mask vector elements\n        svbool_t mask_vec = svld1_b_s64(pg, mask + i);\n        \n        // Conditionally select elements based on mask\n        svint64_t result = svsel_s64(mask_vec, src_vec, svdup_s64(0));\n        \n        // Store result in destination\n        svst1_s64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = svcntw(); // Get number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_z(pg, src + i);\n        \n        // Multiply source vector by scale\n        svint32_t scaled_vec = svmul_z(pg, src_vec, scale);\n        \n        // Calculate tmp1: right shift by 3\n        svint32_t tmp1 = svasr_z(pg, scaled_vec, 3);\n        \n        // Calculate tmp2: left shift by 3\n        svint32_t tmp2 = svlsl_z(pg, scaled_vec, 3);\n        \n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        svint32_t tmp1_scaled = svmul_z(pg, tmp1, tmp2);\n        svint32_t result = svdiv_z(pg, svadd_z(pg, scaled_vec, tmp1_scaled), 7);\n        \n        // Store result in destination vector\n        svst1_z(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = svcntw(); // Get number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_z(pg, src + i);\n        \n        // Multiply source vector by scale\n        svint32_t scaled_vec = svmul_z(pg, src_vec, scale);\n        \n        // Calculate tmp1: right shift by 3\n        svint32_t tmp1 = svasr_z(pg, scaled_vec, 3);\n        \n        // Calculate tmp2: left shift by 3\n        svint32_t tmp2 = svlsl_z(pg, scaled_vec, 3);\n        \n        // Compute final result: (element * scale + tmp1 * tmp2) / 7\n        svint32_t tmp1_mul_tmp2 = svmul_z(pg, tmp1, tmp2);\n        svint32_t result = svdiv_z(pg, svadd_z(pg, scaled_vec, tmp1_mul_tmp2), 7);\n        \n        // Store result in destination vector\n        svst1_z(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_z(pg, src + i);\n        \n        // Multiply source vector by scale\n        svint32_t scaled_vec = svmul_z(pg, src_vec, scale);\n        \n        // Calculate tmp1: right shift by 3\n        svint32_t tmp1 = svasr_z(pg, scaled_vec, 3);\n        \n        // Calculate tmp2: left shift by 3\n        svint32_t tmp2 = svlsl_z(pg, scaled_vec, 3);\n        \n        // Compute (element * scale + tmp1 * tmp2) / 7\n        svint32_t tmp1_scaled = svmul_z(pg, tmp1, tmp2);\n        svint32_t result_vec = svdiv_z(pg, svadd_z(pg, scaled_vec, tmp1_scaled), 7);\n        \n        // Store result vector\n        svst1_z(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svint32_t src_vec = svld1_z(pg, src + i);\n        \n        svint32_t scaled_vec = svmul_z(pg, src_vec, scale);\n        \n        svint32_t tmp1_vec = svasr_z(pg, scaled_vec, 3);\n        svint32_t tmp2_vec = svlsl_z(pg, scaled_vec, 3);\n        \n        svint32_t product_vec = svmul_z(pg, tmp1_vec, tmp2_vec);\n        svint32_t sum_vec = svadd_z(pg, scaled_vec, product_vec);\n        \n        svint32_t result_vec = svdiv_z(pg, sum_vec, 7);\n        \n        svst1_z(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vector of source elements\n        svint32_t src_vec = svld1_z(pg, src + i);\n        \n        // Multiply each element by scale\n        svint32_t scaled_vec = svmul_z(pg, src_vec, scale);\n        \n        // Right shift by 3 bits\n        svint32_t tmp1_vec = svasr_z(pg, scaled_vec, 3);\n        \n        // Left shift by 3 bits\n        svint32_t tmp2_vec = svlsl_z(pg, scaled_vec, 3);\n        \n        // Multiply tmp1 and tmp2\n        svint32_t tmp_product_vec = svmul_z(pg, tmp1_vec, tmp2_vec);\n        \n        // Add scaled_vec to tmp_product_vec\n        svint32_t result_vec = svadd_z(pg, scaled_vec, tmp_product_vec);\n        \n        // Divide by 7\n        svint32_t final_vec = svdiv_z(pg, result_vec, 7);\n        \n        // Store results\n        svst1_z(pg, dst + i, final_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n    \n    // Process rows in vector-sized chunks\n    for (size_t r = 0; r < rows; r += vec_len) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(r, rows);\n        \n        // Calculate the source index for this row\n        size_t src_idx = r * cols + stride;\n        \n        // Load the strided elements using SVE load intrinsics\n        svfloat64_t vec_data = svld1_gather_index(pg, src, src_idx, cols);\n        \n        // Store the loaded vector to destination using SVE store intrinsics\n        svst1(pg, dst + r, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n\n    // Process rows in vector-sized chunks\n    for (size_t r = 0; r < rows; r += vec_len) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(r, rows);\n\n        // Calculate the source index for the strided load\n        size_t src_idx = r * cols + stride;\n\n        // Load the strided elements using SVE load intrinsics\n        svfloat64_t vec_data = svld1_gather_index(pg, src, src_idx);\n\n        // Store the loaded vector to the destination array\n        svst1(pg, dst + r, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n    \n    // Process rows in vector-sized chunks\n    for (size_t r = 0; r < rows; r += vec_len) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(r, rows);\n        \n        // Calculate the source index for this row\n        size_t src_idx = r * cols + stride;\n        \n        // Load the strided elements using SVE load intrinsics\n        svfloat64_t vec_data = svld1_gather_index(pg, src, src_idx);\n        \n        // Store the loaded vector to destination\n        svst1(pg, dst + r, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n\n    // Process rows in vector-sized chunks\n    for (size_t r = 0; r < rows; r += vec_len) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(r, rows);\n\n        // Calculate the source index for the current row\n        size_t src_idx = r * cols + stride;\n\n        // Load the strided elements using SVE load intrinsic\n        svfloat64_t vec_data = svld1_gather_index(pg, src, svindex_u64(src_idx, cols));\n\n        // Store the loaded data to destination array\n        svst1(pg, dst + r, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n    \n    // Process rows in vector-sized chunks\n    for (size_t r = 0; r < rows; r += vec_len) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(r, rows);\n        \n        // Calculate the source indices for this vector\n        svuint64_t indices = svadd_x(pg, \n            svmul_x(pg, svindex_u64(0, 1), cols), \n            stride);\n        \n        // Gather load from source array using the calculated indices\n        svfloat64_t vec_data = svgather_load_x(pg, (const double *)src, indices);\n        \n        // Store the gathered data to destination array\n        svst1_x(pg, dst + r, vec_data);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Gather operation: Load values from src using indices\n        svint32_t index_vec = svld1_gather_s32index_u32(pg, indices, src);\n        \n        // Scatter operation: Store values to dst using indices\n        svst1_scatter_s32index_u32(pg, dst, indices, index_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load indices vector\n        svint32_t index_vec = svld1_s32(pg, indices + i);\n        \n        // Gather operation: Load values from source using indices\n        svfloat32_t gathered_values = svld1_gather_s32index_f32(pg, src, index_vec);\n        \n        // Scatter operation: Store gathered values to destination using indices\n        svst1_scatter_s32index_f32(pg, dst, index_vec, gathered_values);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Gather operation: Load values from src using indices\n        svint32_t index_vec = svld1_gather_index_s32(pg, indices + i);\n        svfloat32_t gathered_values = svld1_gather_s32index_f32(pg, src, index_vec);\n        \n        // Scatter operation: Store values to dst using indices\n        svst1_scatter_s32index_f32(pg, dst, index_vec, gathered_values);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vector_length = svcntw();\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t p = svwhilelt_b32(i, length);\n\n        // Gather operation: Load values from src using indices\n        svint32_t idx_vec = svld1_gather_index(p, indices + i, src);\n        \n        // Scatter operation: Store values to dst using indices\n        svst1_scatter_index(p, indices + i, dst + i, idx_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Gather operation: Load values from src using indices\n        svint32_t index_vec = svld1_gather_index_s32(pg, indices + i);\n        svfloat32_t gathered_values = svld1_gather_s32index_f32(pg, src, index_vec);\n        \n        // Scatter operation: Store values to dst using indices\n        svst1_scatter_s32index_f32(pg, dst, index_vec, gathered_values);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the range length\n    uint64_t range_length = end - start + 1;\n    \n    // If range is too small for vectorization, do scalar reversal\n    if (range_length <= 16) {\n        while (start < end) {\n            int16_t temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n        return;\n    }\n\n    // Number of full vector operations\n    uint64_t vector_ops = range_length / svcntw();\n    \n    // Pointer to start of range\n    int16_t *range_start = arr + start;\n    \n    // Predicate for full vector operations\n    svbool_t pg = svptrue_b16();\n    \n    for (uint64_t i = 0; i < vector_ops / 2; i++) {\n        // Load from front and back of range\n        svint16_t front_vec = svld1_b16(pg, range_start + i * svcntw());\n        svint16_t back_vec = svld1_b16(pg, range_start + range_length - (i + 1) * svcntw());\n        \n        // Reverse each vector\n        front_vec = svrevb_s16_z(pg, front_vec);\n        back_vec = svrevb_s16_z(pg, back_vec);\n        \n        // Swap vectors\n        svst1_b16(pg, range_start + i * svcntw(), back_vec);\n        svst1_b16(pg, range_start + range_length - (i + 1) * svcntw(), front_vec);\n    }\n    \n    // Handle remaining elements if range length is not perfectly divisible\n    uint64_t remaining = range_length % svcntw();\n    if (remaining > 0) {\n        svbool_t pred = svwhilelt_b16(0, remaining);\n        \n        svint16_t front_vec = svld1_b16(pred, range_start + vector_ops * svcntw());\n        svint16_t back_vec = svld1_b16(pred, range_start + range_length - (vector_ops + 1) * svcntw());\n        \n        front_vec = svrevb_s16_z(pred, front_vec);\n        back_vec = svrevb_s16_z(pred, back_vec);\n        \n        svst1_b16(pred, range_start + range_length - (vector_ops + 1) * svcntw(), front_vec);\n        svst1_b16(pred, range_start + vector_ops * svcntw(), back_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t range_length = end - start + 1;\n    \n    // Determine vector length for 16-bit elements\n    size_t vec_len = svcntb() / sizeof(int16_t);\n    \n    // Reverse elements in vector-sized chunks\n    for (uint64_t i = 0; i < range_length / vec_len; i++) {\n        svbool_t pg = svwhilelt_b16_u64(0, range_length - i * vec_len);\n        \n        // Load vector from start + i * vec_len\n        svint16_t vec1 = svld1_s16(pg, arr + start + i * vec_len);\n        \n        // Load vector from end - i * vec_len\n        svint16_t vec2 = svld1_s16(pg, arr + end - i * vec_len - vec_len + 1);\n        \n        // Reverse the loaded vectors\n        vec1 = svrevb_s16_z(pg, vec1);\n        vec2 = svrevb_s16_z(pg, vec2);\n        \n        // Swap the vectors\n        svst1_s16(pg, arr + start + i * vec_len, vec2);\n        svst1_s16(pg, arr + end - i * vec_len - vec_len + 1, vec1);\n    }\n    \n    // Handle remaining elements\n    uint64_t remaining = range_length % vec_len;\n    if (remaining > 0) {\n        svbool_t pg = svwhilelt_b16_u64(0, remaining);\n        \n        // Load vector from start + (range_length / vec_len) * vec_len\n        svint16_t vec1 = svld1_s16(pg, arr + start + (range_length / vec_len) * vec_len);\n        \n        // Load vector from end - remaining + 1\n        svint16_t vec2 = svld1_s16(pg, arr + end - remaining + 1);\n        \n        // Reverse the loaded vectors\n        vec1 = svrevb_s16_z(pg, vec1);\n        vec2 = svrevb_s16_z(pg, vec2);\n        \n        // Swap the vectors\n        svst1_s16(pg, arr + start + (range_length / vec_len) * vec_len, vec2);\n        svst1_s16(pg, arr + end - remaining + 1, vec1);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the range length\n    uint64_t range_length = end - start + 1;\n    \n    // Determine vector length\n    size_t vec_len = svcntb() / sizeof(int16_t);\n    \n    // Perform vector-based reversal\n    for (uint64_t i = 0; i < range_length / 2; i += vec_len) {\n        // Calculate remaining elements\n        uint64_t remaining = range_length - 2 * i;\n        uint64_t vec_elements = (remaining < vec_len) ? remaining : vec_len;\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b16_u64(0, vec_elements);\n        \n        // Load elements from start and end of range\n        svint16_t left_vec = svld1_gather_index_s16(pg, arr + start + i, svincp_s16(svptrue_b16(), 1));\n        svint16_t right_vec = svld1_gather_index_s16(pg, arr + end - i - vec_elements + 1, svincp_s16(svptrue_b16(), 1));\n        \n        // Reverse the loaded vectors\n        right_vec = svreverse_s16(right_vec);\n        left_vec = svreverse_s16(left_vec);\n        \n        // Store back to original positions\n        svst1_scatter_index_s16(pg, arr + start + i, svincp_s16(svptrue_b16(), 1), right_vec);\n        svst1_scatter_index_s16(pg, arr + end - i - vec_elements + 1, svincp_s16(svptrue_b16(), 1), left_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    // Calculate the number of elements to reverse\n    uint64_t range_length = end - start + 1;\n    \n    // Determine vector length for 16-bit elements\n    uint64_t vec_length = svcntb() / sizeof(int16_t);\n    \n    // Reverse elements in vector-sized chunks\n    for (uint64_t i = 0; i < range_length / vec_length; i++) {\n        // Load vector from the start of the range\n        svint16_t vec1 = svld1_s16(svptrue_b16(), arr + start + i * vec_length);\n        \n        // Load vector from the end of the range\n        svint16_t vec2 = svld1_s16(svptrue_b16(), arr + end - i * vec_length - vec_length + 1);\n        \n        // Reverse the loaded vectors\n        vec1 = svrevb_s16(vec1);\n        vec2 = svrevb_s16(vec2);\n        \n        // Store reversed vectors back to their swapped positions\n        svst1_s16(svptrue_b16(), arr + start + i * vec_length, vec2);\n        svst1_s16(svptrue_b16(), arr + end - i * vec_length - vec_length + 1, vec1);\n    }\n    \n    // Handle remaining elements that don't fit in full vectors\n    uint64_t remaining = range_length % vec_length;\n    if (remaining > 0) {\n        // Create predicate for remaining elements\n        svbool_t pg = svwhilelt_b16_u64(0, remaining);\n        \n        // Load vector from the start of the range\n        svint16_t vec1 = svld1_s16(pg, arr + start + (range_length / vec_length) * vec_length);\n        \n        // Load vector from the end of the range\n        svint16_t vec2 = svld1_s16(pg, arr + end - remaining + 1);\n        \n        // Reverse the loaded vectors\n        vec1 = svrevb_s16(vec1);\n        vec2 = svrevb_s16(vec2);\n        \n        // Store reversed vectors back to their swapped positions\n        svst1_s16(pg, arr + start + (range_length / vec_length) * vec_length, vec2);\n        svst1_s16(pg, arr + end - remaining + 1, vec1);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t length = end - start + 1;\n    uint64_t vector_length = svcntb() / sizeof(int16_t);\n    \n    // Reverse the range using SVE vector operations\n    for (uint64_t i = 0; i < length / 2; i += vector_length) {\n        uint64_t remaining = length - 2 * i;\n        svbool_t pg = svwhilelt_b16_u64(0, remaining);\n        \n        // Load vectors from start and end of range\n        svint16_t vec_start = svld1_s16(pg, arr + start + i);\n        svint16_t vec_end = svld1_s16(pg, arr + end - i - vector_length + 1);\n        \n        // Reverse the vectors\n        vec_start = svrevb_s16_z(pg, vec_start);\n        vec_end = svrevb_s16_z(pg, vec_end);\n        \n        // Swap the vectors\n        svst1_s16(pg, arr + start + i, vec_end);\n        svst1_s16(pg, arr + end - i - vector_length + 1, vec_start);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the starting offset for the slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Determine vector length\n    size_t vec_len = svcntb();\n\n    // Process slice in vector chunks\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; j += vec_len) {\n            // Compute remaining elements\n            size_t remaining = dim2 - j;\n            svbool_t pg = svwhilelt_b8(j, dim2);\n\n            // Load vector from tensor slice\n            svuint8_t vec = svld1_u8(pg, tensor + slice_offset + i * dim2 + j);\n\n            // Store vector to slice\n            svst1_u8(pg, slice + i * dim2 + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset for the specific slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Get the SVE vector length for uint8_t\n    size_t vec_len = svcntb();\n\n    // Iterate through rows of the slice\n    for (size_t row = 0; row < dim1; row++) {\n        // Iterate through columns with SVE vector processing\n        size_t col = 0;\n        for (; col + vec_len <= dim2; col += vec_len) {\n            // Create predicate for full vector load/store\n            svbool_t pg = svwhilelt_b8(col, dim2);\n\n            // Load vector from tensor slice\n            svuint8_t vec = svld1_u8(pg, tensor + slice_offset + row * dim2 + col);\n\n            // Store vector to output slice\n            svst1_u8(pg, slice + row * dim2 + col, vec);\n        }\n\n        // Handle remaining elements with scalar processing\n        for (; col < dim2; col++) {\n            slice[row * dim2 + col] = tensor[slice_offset + row * dim2 + col];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset for the specific slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Get the vector length for SVE\n    size_t vector_length = svcntb();\n\n    // Iterate over rows\n    for (size_t row = 0; row < dim1; ++row) {\n        // Iterate over columns with SVE vector processing\n        size_t col = 0;\n        for (; col + vector_length <= dim2; col += vector_length) {\n            // Load vector of bytes\n            svbool_t pg = svwhilelt_b8(col, dim2);\n            svuint8_t vec = svld1_u8(pg, slice_start + row * dim2 + col);\n            \n            // Store vector of bytes\n            svst1_u8(pg, slice + row * dim2 + col, vec);\n        }\n\n        // Handle remaining elements\n        for (; col < dim2; ++col) {\n            slice[row * dim2 + col] = slice_start[row * dim2 + col];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset for the specific slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Determine vector length\n    size_t vec_len = svcntb();\n\n    // Process slice in vector chunks\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; j += vec_len) {\n            // Determine how many elements to process in this iteration\n            svbool_t pg = svwhilelt_b8(j, dim2);\n            \n            // Load vector from tensor slice\n            svuint8_t vec = svld1_u8(pg, tensor + slice_offset + i * dim2 + j);\n            \n            // Store vector to output slice\n            svst1_u8(pg, slice + i * dim2 + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Calculate the offset for the specific slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n    const uint8_t *slice_start = tensor + slice_offset;\n\n    // Get the vector length for SVE\n    size_t vector_length = svcntb();\n\n    // Iterate through rows of the slice\n    for (size_t row = 0; row < dim1; ++row) {\n        // Pointer to the start of the current row in the slice\n        const uint8_t *row_start = slice_start + row * dim2;\n        uint8_t *slice_row = slice + row * dim2;\n\n        // Process the slice using SVE vector operations\n        for (size_t col = 0; col < dim2; col += vector_length) {\n            // Create predicate for handling vector length and remaining elements\n            svbool_t pg = svwhilelt_b8(col, dim2);\n\n            // Load vector of elements from the tensor slice\n            svuint8_t vec = svld1_u8(pg, row_start + col);\n\n            // Store the vector to the output slice\n            svst1_u8(pg, slice_row + col, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Determine SVE vector length for int16_t\n    const size_t sve_vector_length = svcntb() / sizeof(int16_t);\n\n    // Iterate through blocks\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t local_row = block_row; local_row < std::min(block_row + block_size, rows); local_row++) {\n                size_t col = block_col;\n                \n                // Use SVE for vectorized processing\n                for (; col + sve_vector_length <= std::min(block_col + block_size, cols); col += sve_vector_length) {\n                    svbool_t pg = svwhilelt_b16_u64(col, std::min(block_col + block_size, cols));\n                    \n                    // Load source vector\n                    svint16_t src_vec = svld1_gather_index_s16(pg, \n                        src + local_row * cols + col, \n                        svindex_s16(0, 1));\n                    \n                    // Store transposed vector\n                    svst1_scatter_index_s16(pg, \n                        dst + col * rows + local_row, \n                        svindex_s16(0, 1), \n                        src_vec);\n                }\n\n                // Handle remaining elements\n                for (; col < std::min(block_col + block_size, cols); col++) {\n                    dst[col * rows + local_row] = src[local_row * cols + col];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Determine SVE vector length for int16_t\n    const size_t sve_vector_length = svcntb() / sizeof(int16_t);\n\n    // Iterate through blocks\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t local_row = block_row; local_row < (block_row + block_size) && local_row < rows; local_row++) {\n                size_t col_start = block_col;\n                \n                // Use SVE for vectorized processing\n                for (; col_start + sve_vector_length <= block_col + block_size && col_start + sve_vector_length <= cols; \n                     col_start += sve_vector_length) {\n                    \n                    // Create predicate for safe vector load\n                    svbool_t pg = svwhilelt_b16_u64(col_start, block_col + block_size);\n                    \n                    // Load source vector\n                    svint16_t src_vec = svld1_gather_index_s16(pg, \n                        (const int16_t*)(src + local_row * cols + col_start), \n                        sveor_s16_x(pg, svindex_s16(0, 1), svindex_s16(0, 1)));\n                    \n                    // Store transposed vector\n                    svst1_scatter_index_s16(pg, \n                        (int16_t*)(dst + col_start * rows + local_row), \n                        sveor_s16_x(pg, svindex_s16(0, 1), svindex_s16(0, 1)), \n                        src_vec);\n                }\n                \n                // Handle remaining elements in the block\n                for (; col_start < block_col + block_size && col_start < cols; col_start++) {\n                    dst[col_start * rows + local_row] = src[local_row * cols + col_start];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Determine SVE vector length for int16_t\n    const size_t vec_len = svcntb() / sizeof(int16_t);\n\n    // Iterate over blocks\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                size_t c = block_col;\n                \n                // Vectorized processing of columns\n                for (; c + vec_len <= std::min(block_col + block_size, cols); c += vec_len) {\n                    svbool_t pg = svwhilelt_b16_u64(c, std::min(block_col + block_size, cols));\n                    svint16_t vec = svld1_gather_index_s16(pg, src + r * cols + c, 1);\n                    svst1_scatter_index_s16(pg, dst + c * rows + r, 1, vec);\n                }\n\n                // Handle remaining columns\n                for (; c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Determine SVE vector length for int16_t\n    const size_t vec_len = svcntb() / sizeof(int16_t);\n\n    // Iterate over blocks\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                size_t c = block_col;\n                \n                // Vectorized processing of columns within the block\n                for (; c + vec_len <= std::min(block_col + block_size, cols); c += vec_len) {\n                    svbool_t pg = svwhilelt_b16_u64(c, std::min(block_col + block_size, cols));\n                    svint16_t vec = svld1_gather_index_s16(pg, src + r * cols + c, 1);\n                    svst1_scatter_index_s16(pg, dst + c * rows + r, 1, vec);\n                }\n\n                // Handle remaining elements in the block\n                for (; c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    // Determine SVE vector length for int16_t\n    size_t vec_len = svcntb() / sizeof(int16_t);\n\n    // Iterate over blocks\n    for (size_t block_row = 0; block_row < rows; block_row += block_size) {\n        for (size_t block_col = 0; block_col < cols; block_col += block_size) {\n            // Process each block\n            for (size_t r = block_row; r < std::min(block_row + block_size, rows); r++) {\n                size_t c = block_col;\n                \n                // Vectorized processing within the block\n                for (; c + vec_len <= std::min(block_col + block_size, cols); c += vec_len) {\n                    svbool_t pg = svwhilelt_b16_u64(c, std::min(block_col + block_size, cols));\n                    svint16_t vec = svld1_gather_index_s16(pg, src + r * cols + c, 1);\n                    svst1_scatter_index_s16(pg, dst + c * rows + r, 1, vec);\n                }\n\n                // Handle remaining elements in the block\n                for (; c < std::min(block_col + block_size, cols); c++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_n_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32_u64(i, dim);\n        size_t index = i * dim * dim + i * dim + i;\n        svfloat32_t diagonal_vec = svld1_f32(pg, &array[index]);\n        sum_vec = svadd_f32_m(pg, sum_vec, diagonal_vec);\n    }\n    \n    float sum = svaddv_f32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_n_f32(0.0f);\n    size_t vector_length = svcntw();\n\n    for (size_t i = 0; i < dim; i += vector_length) {\n        size_t remaining = dim - i;\n        svbool_t pg = svwhilelt_b32_u64(i, dim);\n\n        // Calculate diagonal index\n        svuint32_t indices = svadd_n_u32_x(pg, svindex_u32(0, 1), i * dim + i);\n        \n        // Load diagonal elements\n        svfloat32_t diagonal_elements = svld1_gather_index_f32(pg, array, indices);\n        \n        // Accumulate sum\n        sum_vec = svadd_f32_m(pg, sum_vec, diagonal_elements);\n    }\n\n    // Reduce vector sum to scalar\n    return svaddv_f32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_n_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32_u64(i, dim);\n        size_t index = i * dim * dim + i * dim + i;\n        svfloat32_t diagonal_vec = svld1_f32(pg, &array[index]);\n        sum_vec = svadd_f32_m(pg, sum_vec, diagonal_vec);\n    }\n    \n    float sum = svaddv_f32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        size_t index = i * dim + i * dim + i;\n        svbool_t pg = svwhilelt_b32_u64(i, dim);\n        svfloat32_t diagonal_vec = svld1_f32(pg, &array[index]);\n        sum_vec = svadd_f32_m(pg, sum_vec, diagonal_vec);\n    }\n    \n    float sum = svaddv_f32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32_u64(i, dim);\n        size_t diagonal_index = i * dim + i;\n        svfloat32_t diagonal_elements = svld1_f32(pg, &array[diagonal_index]);\n        sum_vec = svadd_f32_m(pg, sum_vec, diagonal_elements);\n    }\n    \n    float total_sum = svaddv_f32(svptrue_b32(), sum_vec);\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t col = 0;\n        svbool_t pg = svwhilelt_b64(col, cols);\n        \n        do {\n            // Load vector of source values\n            svfloat64_t vec_src = svld1_f64(pg, src + r * cols + col);\n            \n            // Create predicate for values > threshold\n            svbool_t mask = svcmpgt_f64(pg, vec_src, threshold);\n            \n            // Scale values above threshold\n            svfloat64_t vec_scaled = svmul_f64_z(mask, vec_src, scale);\n            svfloat64_t vec_result = svsel_f64(mask, vec_scaled, vec_src);\n            \n            // Store result vector\n            svst1_f64(pg, dst + r * cols + col, vec_result);\n            \n            // Update column and predicate\n            col += svcntd();\n            pg = svwhilelt_b64(col, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        svbool_t pg = svwhilelt_b64(c, cols);\n        \n        do {\n            // Load vector of doubles\n            svfloat64_t vec = svld1_z(pg, src + r * cols + c);\n            \n            // Create predicate for values > threshold \n            svbool_t mask = svcmpgt_z(pg, vec, threshold);\n            \n            // Scale values where predicate is true\n            svfloat64_t scaled_vec = svmul_z(mask, vec, scale);\n            \n            // Merge scaled and original values\n            svfloat64_t result = svsel_z(mask, scaled_vec, vec);\n            \n            // Store result\n            svst1_z(pg, dst + r * cols + c, result);\n            \n            // Update loop control\n            c += svcntd();\n            pg = svwhilelt_b64(c, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        svbool_t pg = svwhilelt_b64(c, cols);\n        \n        do {\n            // Load vector of source values\n            svfloat64_t vec_src = svld1_z(pg, src + r * cols + c);\n            \n            // Create predicate for values above threshold \n            svbool_t mask = svcmpgt_z(pg, vec_src, threshold);\n            \n            // Scale values above threshold\n            svfloat64_t vec_scaled = svmul_z(mask, vec_src, scale);\n            \n            // Merge scaled and original values\n            svfloat64_t vec_result = svsel_z(mask, vec_scaled, vec_src);\n            \n            // Store result\n            svst1_z(pg, dst + r * cols + c, vec_result);\n            \n            // Update loop counters\n            c += svcntd();\n            pg = svwhilelt_b64(c, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t col = 0;\n        svbool_t pg = svwhilelt_b64(col, cols);\n        \n        do {\n            // Load vector of doubles\n            svfloat64_t vec = svld1_z(pg, src + r * cols + col);\n            \n            // Create predicate for values above threshold \n            svbool_t mask = svcmpgt_z(pg, vec, threshold);\n            \n            // Scale values above threshold\n            svfloat64_t scaled_vec = svmul_z(mask, vec, scale);\n            \n            // Store result, preserving values below threshold\n            svst1_z(pg, dst + r * cols + col, svsel_z(mask, scaled_vec, vec));\n            \n            // Move to next vector\n            col += svcntd();\n            pg = svwhilelt_b64(col, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        svbool_t pg = svwhilelt_b64(c, cols);\n        \n        do {\n            // Load vector of doubles\n            svfloat64_t vec = svld1_f64(pg, src + r * cols + c);\n            \n            // Compare values against threshold\n            svbool_t mask = svcmpgt_f64(pg, vec, threshold);\n            \n            // Scale values above threshold\n            svfloat64_t scaled_vec = svmul_f64_z(mask, vec, scale);\n            \n            // Store result, preserving values below threshold\n            svst1_f64(pg, dst + r * cols + c, svsel_f64(mask, scaled_vec, vec));\n            \n            // Move to next vector\n            c += svcntd();\n            pg = svwhilelt_b64(c, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Get the SVE vector length for doubles\n    size_t vec_len = svcntd();\n\n    // Iterate through rows\n    for (size_t r = 0; r < rows; r++) {\n        // Get the source row index from the indices array\n        size_t src_row = indices[r];\n\n        // Process columns in SVE vector chunks\n        for (size_t c = 0; c < cols; c += vec_len) {\n            // Create predicate for handling partial vector at the end\n            svbool_t pg = svwhilelt_b64(c, cols);\n\n            // Load source row vector\n            svfloat64_t vec_src = svld1_f64(pg, src + src_row * cols + c);\n\n            // Store to destination row\n            svst1_f64(pg, dst + r * cols + c, vec_src);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n\n    // Iterate through rows\n    for (size_t i = 0; i < rows; i++) {\n        // Get the source row index from indices\n        size_t src_row_idx = indices[i];\n\n        // Process columns using SVE vector operations\n        for (size_t j = 0; j < cols; j += vec_len) {\n            // Determine the number of active elements for this vector\n            svbool_t pg = svwhilelt_b64(j, cols);\n\n            // Load source row vector\n            svfloat64_t src_vec = svld1_f64(pg, src + src_row_idx * cols + j);\n\n            // Store to destination row\n            svst1_f64(pg, dst + i * cols + j, src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Get the SVE vector length for double precision\n    size_t vec_len = svcntd();\n\n    // Iterate through rows\n    for (size_t r = 0; r < rows; r++) {\n        // Get the source row index from the indices array\n        size_t src_row_idx = indices[r];\n\n        // Process columns in vector-sized chunks\n        for (size_t c = 0; c < cols; c += vec_len) {\n            // Create predicate for handling partial vector loads/stores\n            svbool_t pg = svwhilelt_b64(c, cols);\n\n            // Load source row vector\n            svfloat64_t src_vec = svld1_f64(pg, src + src_row_idx * cols + c);\n\n            // Store to destination row\n            svst1_f64(pg, dst + r * cols + c, src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Get the SVE vector length for double precision\n    size_t vector_length = svcntd();\n\n    // Iterate through rows\n    for (size_t row = 0; row < rows; ++row) {\n        // Get the source row index from the indices array\n        size_t src_row_index = indices[row];\n\n        // Process columns in vector-sized chunks\n        for (size_t col = 0; col < cols; col += vector_length) {\n            // Determine the number of elements to process in this iteration\n            svbool_t pg = svwhilelt_b64(col, cols);\n\n            // Load source row vector\n            svfloat64_t src_vec = svld1_f64(pg, src + src_row_index * cols + col);\n\n            // Store to destination row\n            svst1_f64(pg, dst + row * cols + col, src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    // Get the SVE vector length for doubles\n    size_t vec_len = svcntd();\n\n    // Iterate through rows\n    for (size_t r = 0; r < rows; r++) {\n        // Get the source row index from the indices array\n        size_t src_row = indices[r];\n\n        // Process columns using SVE vector operations\n        for (size_t c = 0; c < cols; c += vec_len) {\n            // Create predicate for handling partial vector loads/stores\n            svbool_t pg = svwhilelt_b64(c, cols);\n\n            // Load source row vector\n            svfloat64_t vec = svld1_f64(pg, src + src_row * cols + c);\n\n            // Store to destination row\n            svst1_f64(pg, dst + r * cols + c, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        svint64_t vec1 = svld1_z(pg, src1 + i);\n        svint64_t vec2 = svld1_z(pg, src2 + i);\n        \n        svint64_t sum = svadd_z(pg, vec1, vec2);\n        svint64_t scalar_vec = svdup_n_s64(scalar);\n        \n        svint64_t result = svadd_z(pg, sum, scalar_vec);\n        svint64_t divided = svdiv_z(pg, result, 2);\n        \n        svst1_z(pg, dst + i, divided);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load vectors from src1 and src2\n        svint64_t vec1 = svld1_z(pg, src1 + i);\n        svint64_t vec2 = svld1_z(pg, src2 + i);\n        \n        // Add vectors\n        svint64_t result_vec = svadd_z(pg, vec1, vec2);\n        \n        // Add scalar to each element\n        result_vec = svadd_z(pg, result_vec, svdup_n_s64(scalar));\n        \n        // Divide by 2 (round toward zero)\n        result_vec = svdiv_z(pg, result_vec, svdup_n_s64(2));\n        \n        // Store result in destination array\n        svst1_z(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        svint64_t vec1 = svld1_s64(pg, src1 + i);\n        svint64_t vec2 = svld1_s64(pg, src2 + i);\n        \n        svint64_t sum = svadd_s64_z(pg, vec1, vec2);\n        svint64_t scalar_vec = svdup_s64(scalar);\n        \n        svint64_t result = svadd_s64_z(pg, sum, scalar_vec);\n        svint64_t divided = svdiv_s64_z(pg, result, 2);\n        \n        svst1_s64(pg, dst + i, divided);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vector_length = svcntd();  // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of active elements for this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load vectors from src1 and src2\n        svint64_t vec1 = svld1_z(pg, src1 + i);\n        svint64_t vec2 = svld1_z(pg, src2 + i);\n        \n        // Add vectors\n        svint64_t result = svadd_z(pg, vec1, vec2);\n        \n        // Add scalar to each element\n        result = svadd_z(pg, result, svdup_n_s64(scalar));\n        \n        // Divide by 2 (round toward zero)\n        result = svdiv_z(pg, result, svdup_n_s64(2));\n        \n        // Store result in destination array\n        svst1_z(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load vectors from src1 and src2\n        svint64_t vec1 = svld1_s64(pg, src1 + i);\n        svint64_t vec2 = svld1_s64(pg, src2 + i);\n        \n        // Add vectors\n        svint64_t result = svadd_s64_z(pg, vec1, vec2);\n        \n        // Add scalar to each element\n        result = svadd_s64_z(pg, result, svdup_s64(scalar));\n        \n        // Divide by 2 (round toward zero)\n        result = svdiv_s64_z(pg, result, svdup_s64(2));\n        \n        // Store result in destination array\n        svst1_s64(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32_u32(i, length);\n        svbool_t even_mask = svzip1_b_b(svpfalse_b(), svptrue_b32());\n        p = svand_b_z(pg, p, even_mask);\n\n        svint32_t vec = svld1_s32(p, src + i);\n        min_vec = svmin_s32_z(p, min_vec, vec);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32_u64(i, length);\n        svbool_t even_mask = svzip1_b32(svpfalse_b(), svptrue_b32());\n        p = svand_b_z(pg, p, even_mask);\n\n        svint32_t vec = svld1_s32(p, src + i);\n        min_vec = svmin_s32_z(p, min_vec, vec);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32_u32(i, length);\n        svbool_t even_mask = svzip1_b_b(svpfalse_b(), svptrue_b32());\n        p = svand_b_z(pg, p, even_mask);\n\n        svint32_t vec = svld1_s32(p, src + i);\n        min_vec = svmin_s32_z(p, min_vec, vec);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32_u32(i, length);\n        svbool_t even_mask = svzip1_b_b(svpfalse_b(), svptrue_b32());\n        p = svand_b_z(p, even_mask);\n\n        svint32_t vec = svld1_s32(p, src + i);\n        min_vec = svmin_s32_z(p, min_vec, vec);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svptrue_b32();\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32_u32(i, length);\n        svbool_t even_mask = svzip1_b_b(svpfalse_b(), svptrue_b32());\n        p = svand_b_z(pg, p, even_mask);\n\n        svint32_t vec = svld1_s32(p, src + i);\n        min_vec = svmin_s32_z(p, min_vec, vec);\n    }\n\n    int min_val = svminv_s32(pg, min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_s32(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svashr_s32_z(pg, src_vec, shift);\n        \n        // Logical right shift (convert to unsigned, shift, convert back)\n        svuint32_t unsigned_vec = svreinterpret_u32_s32(src_vec);\n        svuint32_t logical_shift = svlsr_u32_z(pg, unsigned_vec, shift);\n        svint32_t logical_shift_int = svreinterpret_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_int);\n        \n        // Store result\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_s32(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svashr_s32_z(pg, src_vec, shift);\n        \n        // Convert to unsigned and perform logical right shift\n        svuint32_t unsigned_vec = svreinterpret_u32_s32(src_vec);\n        svuint32_t logical_shift = svlsr_u32_z(pg, unsigned_vec, shift);\n        \n        // Convert logical shift back to signed\n        svint32_t logical_shift_signed = svreinterpret_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_signed);\n        \n        // Store result\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_s32(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svashr_s32_z(pg, src_vec, shift);\n        \n        // Logical right shift (convert to unsigned, shift, convert back)\n        svuint32_t unsigned_vec = svreinterpret_u32_s32(src_vec);\n        svuint32_t logical_shift = svlsr_u32_z(pg, unsigned_vec, shift);\n        svint32_t logical_shift_int = svreinterpret_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_int);\n        \n        // Store result\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_s32(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svashr_s32_z(pg, src_vec, shift);\n        \n        // Logical right shift (convert to unsigned, shift, convert back)\n        svuint32_t unsigned_vec = svreinterpret_u32_s32(src_vec);\n        svuint32_t logical_shift = svlsr_u32_z(pg, unsigned_vec, shift);\n        svint32_t logical_shift_int = svreinterpret_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_int);\n        \n        // Store result\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svint32_t src_vec = svld1_s32(pg, src + i);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svashr_s32_z(pg, src_vec, shift);\n        \n        // Logical right shift (convert to unsigned, shift, convert back)\n        svuint32_t unsigned_vec = svreinterpret_u32_s32(src_vec);\n        svuint32_t logical_shift = svlsr_u32_z(pg, unsigned_vec, shift);\n        svint32_t logical_shift_int = svreinterpret_s32_u32(logical_shift);\n        \n        // Add arithmetic and logical shifts\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_int);\n        \n        // Store result\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    \n    // Use SVE vector length for processing\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize sum vector\n    svint64_t sum_vec = svdup_n_s64(0);\n    \n    // Process elements in SVE vector chunks\n    size_t vector_length = svcntw();\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        \n        // Convert 32-bit integers to 64-bit integers and accumulate\n        svint64_t vec_low = svconv_f64_f32(svget_low_s32(vec));\n        svint64_t vec_high = svconv_f64_f32(svget_high_s32(vec));\n        \n        sum_vec = svadd_s64_z(pg, sum_vec, vec_low);\n        sum_vec = svadd_s64_z(pg, sum_vec, vec_high);\n    }\n    \n    // Horizontal sum of vector\n    total_sum = svaddv_s64(pg, sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    \n    // Use SVE predicate to handle vector processing\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize sum vector to zero\n    svint64_t sum_vec = svdup_n_s64(0);\n    \n    // Process elements in vector-sized chunks\n    size_t vector_stride = svcntw();\n    size_t i;\n    \n    for (i = 0; i + vector_stride <= total_elements; i += vector_stride) {\n        // Load vector of 32-bit integers and convert to 64-bit\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        svint64_t vec_64 = svcvt_s64_s32_x(pg, vec);\n        \n        // Accumulate sum\n        sum_vec = svadd_s64_x(pg, sum_vec, vec_64);\n    }\n    \n    // Reduce vector sum to scalar\n    total_sum = svaddv_s64(pg, sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    \n    // Use SVE vector length for processing\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize sum vector\n    svint64_t sum_vec = svdup_n_s64(0);\n    \n    // Process elements in vector-sized chunks\n    size_t vector_stride = svcntw();\n    size_t i;\n    for (i = 0; i + vector_stride <= total_elements; i += vector_stride) {\n        // Load vector of 32-bit integers\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        \n        // Convert 32-bit integers to 64-bit integers and accumulate\n        sum_vec = svadd_s64_z(pg, sum_vec, svconv_s64_s32(vec));\n    }\n    \n    // Horizontal sum of vector\n    total_sum = svaddv_s64(pg, sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    \n    // Use SVE vector length for processing\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize sum vector\n    svint64_t sum_vec = svdup_n_s64(0);\n    \n    // Process elements in vector-sized chunks\n    size_t vector_stride = svcntw();\n    size_t i;\n    \n    for (i = 0; i + vector_stride <= total_elements; i += vector_stride) {\n        // Load vector of 32-bit integers\n        svint32_t vec = svld1_s32(pg, matrix + i);\n        \n        // Convert 32-bit integers to 64-bit integers and accumulate\n        sum_vec = svadd_s64_z(pg, sum_vec, svconv_s64_s32(vec));\n    }\n    \n    // Horizontal sum of vector\n    total_sum = svaddv_s64(pg, sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total_sum = 0;\n    size_t total_elements = rows * cols;\n    \n    // Use SVE vector length\n    size_t vector_length = svcntw();\n    \n    // Process elements in vector chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Load vector of integers\n        svint32_t vec = svld1_s32(svptrue_b32(), matrix + i);\n        \n        // Convert 32-bit integers to 64-bit integers\n        svint64_t vec_64 = svcvt_s64_s32_x(svptrue_b32(), vec);\n        \n        // Sum vector elements\n        int64_t chunk_sum = svaddv_s64(svptrue_b64(), vec_64);\n        \n        total_sum += chunk_sum;\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    size_t vector_length = svcntb();\n    svbool_t pg = svwhilelt_b8_u64(0, length);\n    \n    svint8_t current_max = svdup_n_s8(-128);  // Start with minimum possible int8_t value\n    svuint64_t current_max_indices = svdup_n_u64(0);\n    \n    size_t i = 0;\n    for (; i + vector_length <= length; i += vector_length) {\n        svint8_t vec = svld1_s8(pg, src + i);\n        svuint64_t indices = svindex_u64(i, 1);\n        \n        svbool_t mask = svcmpgt_s8(pg, vec, current_max);\n        current_max = svsel_s8(mask, vec, current_max);\n        current_max_indices = svsel_u64(mask, indices, current_max_indices);\n        \n        pg = svwhilelt_b8_u64(i + vector_length, length);\n    }\n    \n    // Horizontal max reduction\n    int8_t lane_max[16];\n    uint64_t lane_indices[16];\n    svst1_s8(svptrue_b8(), lane_max, current_max);\n    svst1_u64(svptrue_b8(), lane_indices, current_max_indices);\n    \n    for (size_t j = 0; j < vector_length; j++) {\n        if (lane_max[j] > max_value) {\n            max_value = lane_max[j];\n            max_index = lane_indices[j];\n        }\n    }\n    \n    // Check remaining elements\n    for (; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n    \n    size_t vector_length = svcntb();\n    svbool_t pg = svwhilelt_b8_u64(0, length);\n    \n    svint8_t current_vec = svld1_s8(pg, src);\n    svint8_t max_vec = current_vec;\n    \n    for (size_t i = vector_length; i < length; i += vector_length) {\n        pg = svwhilelt_b8_u64(i, length);\n        current_vec = svld1_s8(pg, src + i);\n        \n        svbool_t mask = svcmpgt_s8(pg, current_vec, max_vec);\n        max_vec = svsel_s8(mask, current_vec, max_vec);\n    }\n    \n    int8_t max_elements[vector_length];\n    svst1_s8(svptrue_b8(), max_elements, max_vec);\n    \n    for (size_t j = 0; j < vector_length; j++) {\n        if (max_elements[j] > max_val) {\n            max_val = max_elements[j];\n            max_index = j;\n        }\n    }\n    \n    for (size_t i = max_index; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    size_t vector_length = svcntb();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t active_mask = svwhilelt_b8(i, length);\n        \n        svint8_t vec_data = svld1_s8(active_mask, src + i);\n        \n        svint8_t current_max = svmax_s8_z(active_mask, vec_data, max_value);\n        \n        svbool_t max_mask = svcmpgt_s8(active_mask, current_max, max_value);\n        \n        if (svptest_any(pg, max_mask)) {\n            max_value = svsel_s8(max_mask, current_max, max_value);\n            max_index = i + svindex_s8(0, 1)[svfirstit_b8(max_mask)];\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_val = src[0];\n    \n    size_t vector_length = svcntb();\n    size_t i = 0;\n\n    // Process vector chunks\n    for (; i + vector_length <= length; i += vector_length) {\n        svint8_t current_vec = svld1_s8(svptrue_b8(), src + i);\n        svbool_t pred = svptrue_b8();\n        \n        // Find max value in current vector\n        svint8_t max_vec = svmax_s8_z(pred, current_vec, max_val);\n        \n        // Check if max value changed\n        svbool_t max_mask = svcmpgt_s8(pred, max_vec, max_val);\n        if (svptest_any(pred, max_mask)) {\n            max_val = svsel_s8(max_mask, max_vec, max_val);\n            max_index = i + svindex_s8(0, 1)[svfirstid_b8(max_mask)];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    size_t vector_length = svcntb();\n    svbool_t pg = svwhilelt_b8_u64(0, length);\n    \n    svint8_t current_vector = svld1_z(pg, src);\n    svint8_t max_vector = current_vector;\n    \n    size_t i = 0;\n    while (i < length) {\n        // Load next vector\n        pg = svwhilelt_b8_u64(i, length);\n        current_vector = svld1_z(pg, src + i);\n        \n        // Compare current vector with max vector\n        svbool_t mask = svcmpgt_s8(pg, current_vector, max_vector);\n        max_vector = svsel_s8(mask, current_vector, max_vector);\n        \n        i += vector_length;\n    }\n    \n    // Reduce vector to find max value\n    int8_t max_lane_value = svmaxv_s8(svptrue_b8(), max_vector);\n    \n    // Find index of max value\n    for (size_t j = 0; j < length; j++) {\n        if (src[j] == max_lane_value) {\n            max_index = j;\n            break;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vector_size = svcntb() / sizeof(uint16_t);\n    \n    for (size_t i = 0; i < length; i += vector_size) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        // Load source vectors\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        // Create index vector\n        svuint16_t index_vec = svindex_u16(i, 1);\n        \n        // Compute mask condition\n        svbool_t blend_mask = svcmpne_n_u32(pg, svand_u32_z(pg, index_vec, mask), 0);\n        \n        // Blend vectors based on mask\n        svuint16_t result = svsel_u16(blend_mask, vec1, vec2);\n        \n        // Store result\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vector_size = svcntb() / sizeof(uint16_t);\n    \n    for (size_t i = 0; i < length; i += vector_size) {\n        svbool_t pg = svwhilelt_b16_u32(i, length);\n        \n        svuint16_t vec_src1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec_src2 = svld1_u16(pg, src2 + i);\n        \n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t blend_mask = svcmpne_n_u32(pg, svand_n_u32_x(pg, indices, mask), 0);\n        \n        svuint16_t result = svsel_u16(blend_mask, vec_src1, vec_src2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vector_size = svcntb() / sizeof(uint16_t);\n    \n    for (size_t i = 0; i < length; i += vector_size) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        // Load source arrays\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        // Create index vector\n        svuint16_t index_vec = svindex_u16(i, 1);\n        \n        // Compute mask condition\n        svbool_t blend_mask = svcmpne_n_u32(pg, svand_u32_x(pg, svcast_u32_u16(index_vec), mask), 0);\n        \n        // Blend vectors based on mask\n        svuint16_t result = svsel_u16(blend_mask, vec1, vec2);\n        \n        // Store result\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vector_size = svcntb() / sizeof(uint16_t);\n    \n    for (size_t i = 0; i < length; i += vector_size) {\n        svbool_t pg = svwhilelt_b16_u32(i, length);\n        \n        // Load source vectors\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        // Create index vector\n        svuint16_t index_vec = svadd_u16_x(pg, svindex_u16(0, 1), i);\n        \n        // Compute mask condition\n        svbool_t blend_mask = svcmpne_u32_x(pg, svand_u32_x(pg, index_vec, mask), 0);\n        \n        // Blend vectors based on mask\n        svuint16_t result = svsel_u16(blend_mask, vec1, vec2);\n        \n        // Store result\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vector_size = svcntb() / sizeof(uint16_t);\n    \n    for (size_t i = 0; i < length; i += vector_size) {\n        svbool_t pg = svwhilelt_b16_u32(i, length);\n        \n        // Load source vectors\n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        // Create index vector\n        svuint16_t index_vec = svadd_n_u16_x(pg, svindex_u16(0, 1), i);\n        \n        // Compute mask condition\n        svbool_t blend_mask = svcmpne_n_u32_x(pg, svand_n_u32_x(pg, index_vec, mask), 0);\n        \n        // Blend vectors based on mask\n        svuint16_t result = svsel_u16(blend_mask, vec1, vec2);\n        \n        // Store result\n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svuint32_t input_vec = svld1_u32(pg, src + i);\n        svuint32_t popcount_vec = svcnt_u32_z(pg, input_vec);\n        \n        svst1_u32(pg, dst + i, popcount_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        svuint32_t input_vec = svld1_u32(pg, src + i);\n        svuint32_t popcount_vec = svcnt_u32_z(pg, input_vec);\n        svst1_u32(pg, dst + i, popcount_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcount = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcount);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svuint32_t input_vec = svld1_u32(pg, src + i);\n        svuint32_t popcount_vec = svcnt_u32_z(pg, input_vec);\n        \n        svst1_u32(pg, dst + i, popcount_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t popcount = svcnt_u32_z(pg, vec);\n        svst1_u32(pg, dst + i, popcount);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vector_length = svcntb() / sizeof(uint16_t);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svadd_u16_z(pg, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svadd_u16_z(pg, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svadd_u16_z(pg, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svadd_u16_z(pg, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        svuint16_t vec1 = svld1_u16(pg, src1 + i);\n        svuint16_t vec2 = svld1_u16(pg, src2 + i);\n        \n        svuint16_t result = svadd_u16_z(pg, vec1, vec2);\n        \n        svst1_u16(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // SVE vector length in doubles\n    const size_t sve_vec_len = svcntd();\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += sve_vec_len) {\n            // Determine the number of elements to process in this vector\n            svbool_t pg = svwhilelt_b64(j, p);\n            \n            // Initialize destination vector to zero\n            svfloat64_t sum_vec = svdup_f64(0.0);\n\n            for (size_t k = 0; k < n; k++) {\n                // Load A[i*n + k]\n                double a_val = A[i*n + k];\n\n                // Check if a_val is in range [-100, 100]\n                if (a_val >= -100 && a_val <= 100) {\n                    // Load B[k*p + j] vector\n                    svfloat64_t b_vec = svld1_f64(pg, &B[k*p + j]);\n\n                    // Multiply and accumulate\n                    sum_vec = svmla_f64_m(pg, sum_vec, svdup_f64(a_val), b_vec);\n                }\n            }\n\n            // Store result in C\n            svst1_f64(pg, &C[i*p + j], sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Iterate over rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate over columns of B\n        for (size_t j = 0; j < p; j++) {\n            // Use SVE vector length\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            \n            // Iterate over columns of A / rows of B with SVE vectorization\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b64(k, n);\n            do {\n                // Load A and B elements\n                svfloat64_t a_vec = svld1_f64(pg, &A[i*n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k*p + j]);\n                \n                // Check range condition\n                svbool_t range_mask_a = svcmple_f64(pg, svabs_f64_z(pg, a_vec), svdup_f64(100.0));\n                svbool_t range_mask_b = svcmple_f64(pg, svabs_f64_z(pg, b_vec), svdup_f64(100.0));\n                svbool_t range_mask = svand_b_z(pg, range_mask_a, range_mask_b);\n                \n                // Multiply and accumulate with range check\n                sum_vec = svmad_f64_z(range_mask, a_vec, b_vec, sum_vec);\n                \n                // Move to next vector\n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            } while (svptest_any(svptrue_b64(), pg));\n            \n            // Reduce sum vector to scalar\n            double sum = svaddv_f64(svptrue_b64(), sum_vec);\n            \n            // Store result\n            C[i*p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Iterate over rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate over columns of B\n        for (size_t j = 0; j < p; j++) {\n            // Use SVE vector length\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            \n            // Compute vector length\n            size_t vec_len = svcntd();\n            \n            // Iterate over columns of A / rows of B with SVE vectorization\n            for (size_t k = 0; k < n; k += vec_len) {\n                // Compute remaining elements\n                size_t remaining = (n - k < vec_len) ? (n - k) : vec_len;\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                // Load A and B elements\n                svfloat64_t a_vec = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b_vec = svld1_f64(pg, &B[k * p + j]);\n                \n                // Check range constraint\n                svbool_t range_mask_a = svcmpge_f64(pg, a_vec, svdup_f64(-100.0));\n                range_mask_a = svcmple_f64(range_mask_a, a_vec, svdup_f64(100.0));\n                \n                svbool_t range_mask_b = svcmpge_f64(pg, b_vec, svdup_f64(-100.0));\n                range_mask_b = svcmple_f64(range_mask_b, b_vec, svdup_f64(100.0));\n                \n                // Combine range masks\n                svbool_t range_mask = svand_b_z(pg, range_mask_a, range_mask_b);\n                \n                // Multiply and accumulate with range constraint\n                sum_vec = svmad_f64_m(range_mask, sum_vec, a_vec, b_vec);\n            }\n            \n            // Reduce vector sum\n            double sum = svaddv_f64(svptrue_b64(), sum_vec);\n            \n            // Store result\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Determine SVE vector length for doubles\n    const size_t sve_vec_len = svcntd();\n\n    // Iterate through rows of A\n    for (size_t i = 0; i < m; ++i) {\n        // Iterate through columns of B\n        for (size_t j = 0; j < p; j += sve_vec_len) {\n            // Determine active vector predicate\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            // Initialize result vector for this row-column combination\n            svfloat64_t result = svdup_f64(0.0);\n\n            // Iterate through columns of A / rows of B\n            for (size_t k = 0; k < n; ++k) {\n                // Load A[i*n + k]\n                double a_val = A[i*n + k];\n\n                // Check if A value is in range\n                if (a_val >= -100.0 && a_val <= 100.0) {\n                    // Load vector of B values\n                    svfloat64_t b_vec = svld1_f64(pg, &B[k*p + j]);\n\n                    // Check B values are in range\n                    svbool_t b_range_pred = svcmpge_f64(pg, b_vec, svdup_f64(-100.0));\n                    b_range_pred = svcmple_f64(b_range_pred, b_vec, svdup_f64(100.0));\n\n                    // Multiply and accumulate with range check\n                    result = svmad_f64_z(b_range_pred, svdup_f64(a_val), b_vec, result);\n                }\n            }\n\n            // Store result vector\n            svst1_f64(pg, &C[i*p + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // SVE vector length for double precision\n    const size_t sve_vector_length = svcntd();\n\n    // Iterate through rows of A\n    for (size_t i = 0; i < m; i++) {\n        // Iterate through columns of B\n        for (size_t j = 0; j < p; j += sve_vector_length) {\n            // Determine the number of elements to process in this vector\n            svbool_t pg = svwhilelt_b64(j, p);\n            \n            // Initialize result vector to zero\n            svfloat64_t result_vec = svdup_f64(0.0);\n\n            // Iterate through columns of A / rows of B\n            for (size_t k = 0; k < n; k++) {\n                // Load A[i*n + k]\n                double a_val = A[i*n + k];\n\n                // Check if A[i*n + k] is in range [-100, 100]\n                if (a_val >= -100 && a_val <= 100) {\n                    // Load vector of B[k*p + j]\n                    svfloat64_t b_vec = svld1_f64(pg, &B[k*p + j]);\n\n                    // Multiply and accumulate\n                    result_vec = svmla_f64_m(pg, result_vec, \n                                             svdup_f64(a_val), \n                                             b_vec);\n                }\n            }\n\n            // Store result vector in C\n            svst1_f64(pg, &C[i*p + j], result_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for int64_t\n    size_t vector_length = svcntd();\n    \n    // Process elements in SVE vector chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vectors from A and B\n        svint64_t va = svld1_z(pg, A + i);\n        svint64_t vb = svld1_z(pg, B + i);\n        \n        // Perform element-wise addition\n        svint64_t vc = svadd_z(pg, va, vb);\n        \n        // Store result vector to C\n        svst1_z(pg, C + i, vc);\n    }\n    \n    // Handle any remaining elements\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for int64_t\n    size_t vector_length = svcntd();\n    \n    // Process vector-sized chunks\n    size_t i = 0;\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vectors from A and B\n        svint64_t va = svld1_z(pg, A + i);\n        svint64_t vb = svld1_z(pg, B + i);\n        \n        // Perform element-wise addition\n        svint64_t vc = svadd_z(pg, va, vb);\n        \n        // Store result in C\n        svst1_z(pg, C + i, vc);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Get the SVE vector length for 64-bit elements\n    size_t vector_length = svcntd();\n    \n    // Process elements using SVE vector operations\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vectors from A and B\n        svint64_t va = svld1_s64(pg, A + i);\n        svint64_t vb = svld1_s64(pg, B + i);\n        \n        // Perform element-wise addition\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        \n        // Store result in C\n        svst1_s64(pg, C + i, vc);\n    }\n    \n    // Handle any remaining elements\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for int64_t\n    size_t vector_length = svcntd();\n    \n    // Process vector-sized chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vectors from A and B\n        svint64_t va = svld1_z(pg, A + i);\n        svint64_t vb = svld1_z(pg, B + i);\n        \n        // Perform element-wise addition\n        svint64_t vc = svadd_z(pg, va, vb);\n        \n        // Store result in C\n        svst1_z(pg, C + i, vc);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for int64_t\n    size_t vector_length = svcntd();\n    \n    // Process vector-sized chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vectors from A and B\n        svint64_t va = svld1_z(pg, A + i);\n        svint64_t vb = svld1_z(pg, B + i);\n        \n        // Perform element-wise addition\n        svint64_t vc = svadd_z(pg, va, vb);\n        \n        // Store result vector to C\n        svst1_z(pg, C + i, vc);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Number of floats in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load vectors from source arrays\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Add vectors\n        svfloat32_t result_vec = svadd_f32_m(pg, vec1, vec2);\n        \n        // Round to nearest integer\n        svfloat32_t rounded_vec = svrintn_f32_m(pg, result_vec);\n        \n        // Store result in destination array\n        svst1_f32(pg, dst + i, rounded_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Get SVE vector length in 32-bit elements\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of active elements for this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vectors from src1 and src2 with predication\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Perform element-wise addition\n        svfloat32_t result_vec = svadd_f32_z(pg, vec1, vec2);\n        \n        // Round to nearest integer\n        svfloat32_t rounded_vec = svrinta_f32_z(pg, result_vec);\n        \n        // Store the result in destination array\n        svst1_f32(pg, dst + i, rounded_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of active elements for this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load vectors from source arrays\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Add the vectors\n        svfloat32_t result_vec = svadd_f32_m(pg, vec1, vec2);\n        \n        // Round to nearest integer\n        svfloat32_t rounded_vec = svrintn_f32_m(pg, result_vec);\n        \n        // Store the result vector\n        svst1_f32(pg, dst + i, rounded_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load vectors from source arrays\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Perform element-wise addition\n        svfloat32_t result_vec = svadd_f32_m(pg, vec1, vec2);\n        \n        // Round to nearest integer\n        svfloat32_t rounded_vec = svrintn_f32_m(pg, result_vec);\n        \n        // Store result in destination array\n        svst1_f32(pg, dst + i, rounded_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Number of float elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load vectors from src1 and src2\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Add the vectors\n        svfloat32_t result_vec = svadd_f32_m(pg, vec1, vec2);\n        \n        // Round to nearest integer\n        svfloat32_t rounded_vec = svrinta_f32_m(pg, result_vec);\n        \n        // Store the result in destination array\n        svst1_f32(pg, dst + i, rounded_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Number of float elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vectors\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Create mask for index multiple of 2\n        svbool_t index_mask = svcmpge_n_u64(pg, i, 0);\n        index_mask = svand_b_z(pg, index_mask, svcmpeq_n_u64(svuunpk_u64(svptrue_b32()), 0));\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, vec1, vec2));\n        \n        // Create mask for difference within 50\n        svbool_t diff_mask = svcmple_n_f32(pg, diff, 50.0f);\n        \n        // Combine masks\n        svbool_t final_mask = svand_b_z(pg, index_mask, diff_mask);\n        \n        // Multiply where mask is true, otherwise set to -1\n        svfloat32_t result = svmul_f32_z(final_mask, vec1, vec2);\n        result = svsel_f32(final_mask, svrintp_f32_z(pg, result), svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw(); // Number of float elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vectors\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Create vector of indices\n        svint32_t indices = svadd_n_s32_x(pg, svindex_s32(0, 1), i);\n        \n        // Check index condition (multiple of 2)\n        svbool_t index_mask = svcmpeq_n_s32(pg, svmod_n_s32_x(pg, indices, 2), 0);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n        \n        // Check absolute difference condition\n        svbool_t diff_mask = svcmple_n_f32(pg, diff, 50.0f);\n        \n        // Combine masks\n        svbool_t final_mask = svand_b_z(pg, index_mask, diff_mask);\n        \n        // Multiply and round up where conditions are met\n        svfloat32_t result = svsel_f32(final_mask, \n                                       svrintp_f32_x(pg, svmul_f32_x(pg, vec1, vec2)), \n                                       svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_size = svcntw(); // Number of float elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_size) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vectors\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        // Create vector of indices\n        svint32_t indices = svadd_n_s32_x(pg, svindex_s32(0, 1), i);\n        \n        // Check index is multiple of 2\n        svbool_t index_mask = svcmpeq_n_s32(pg, svmod_n_s32_x(pg, indices, 2), 0);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n        svbool_t diff_mask = svcmple_n_f32(pg, diff, 50.0f);\n        \n        // Combine masks\n        svbool_t final_mask = svand_b_z(pg, index_mask, diff_mask);\n        \n        // Multiply and round up where mask is true\n        svfloat32_t result = svsel_f32(final_mask, \n                                       svceil_f32_x(pg, svmul_f32_x(pg, vec1, vec2)), \n                                       svdup_n_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, vec1, vec2));\n        svbool_t condition_mask = svcmple_f32(pg, diff, svdup_f32(50.0f));\n        \n        svbool_t index_mask = svpnext_b32(pg, svpfalse_b());\n        svbool_t final_mask = svand_b_z(pg, condition_mask, index_mask);\n        \n        svfloat32_t result = svdup_f32(-1.0f);\n        result = svsel_f32(final_mask, svceil_f32_z(pg, svmul_f32_z(pg, vec1, vec2)), result);\n        \n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        \n        svbool_t index_mask = svcmpge_n_u32(pg, svindex_u32(0, 1), 2);\n        svbool_t diff_mask = svcmplt_f32(pg, svabs_f32_z(pg, svsub_f32_z(pg, vec1, vec2)), svcreate_f32(50.0f));\n        \n        svbool_t combined_mask = svand_b_z(pg, index_mask, diff_mask);\n        \n        svfloat32_t result = svsel_f32(combined_mask, \n                                       svceil_f32_z(pg, svmul_f32_z(pg, vec1, vec2)), \n                                       svcreate_f32(-1.0f));\n        \n        svst1_f32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Total number of elements in the matrix\n    size_t total_elements = m * n;\n    \n    // Get the SVE vector length for double precision\n    size_t vector_length = svcntd();\n    \n    // Process elements in vector-sized chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vector of doubles from source matrix\n        svfloat64_t vec_mat = svld1_f64(pg, mat + i);\n        \n        // Broadcast scalar to vector\n        svfloat64_t vec_scalar = svdup_f64(scalar);\n        \n        // Multiply matrix vector with scalar vector\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat, vec_scalar);\n        \n        // Store result vector to destination matrix\n        svst1_f64(pg, dst + i, vec_result);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Total number of elements in the matrix\n    size_t total_elements = m * n;\n    \n    // SVE vector length for double precision\n    size_t vec_len = svcntd();\n    \n    // Process vector-sized chunks\n    size_t i;\n    for (i = 0; i + vec_len <= total_elements; i += vec_len) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vector of doubles from source matrix\n        svfloat64_t vec_mat = svld1_f64(pg, mat + i);\n        \n        // Multiply vector by scalar \n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, scalar);\n        \n        // Store result vector to destination matrix\n        svst1_f64(pg, dst + i, vec_result);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Total number of elements in the matrix\n    size_t total_elements = m * n;\n    \n    // SVE vector length for double precision\n    size_t vector_length = svcntd();\n    \n    // Process elements in vector-sized chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vector of doubles from source matrix\n        svfloat64_t vec_mat = svld1_f64(pg, mat + i);\n        \n        // Broadcast scalar to vector\n        svfloat64_t vec_scalar = svdup_f64(scalar);\n        \n        // Multiply matrix vector with scalar vector\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat, vec_scalar);\n        \n        // Store result vector to destination matrix\n        svst1_f64(pg, dst + i, vec_result);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Total number of elements in the matrix\n    size_t total_elements = m * n;\n    \n    // Get the SVE vector length for double precision\n    size_t vector_length = svcntd();\n    \n    // Process elements in vector-sized chunks\n    size_t i;\n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        // Load vector of doubles from source matrix\n        svfloat64_t vec_mat = svld1_f64(pg, mat + i);\n        \n        // Broadcast scalar to vector\n        svfloat64_t vec_scalar = svdup_f64(scalar);\n        \n        // Multiply matrix vector with scalar vector\n        svfloat64_t vec_result = svmul_f64_x(pg, vec_mat, vec_scalar);\n        \n        // Store result vector to destination matrix\n        svst1_f64(pg, dst + i, vec_result);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    // Total number of elements in the matrix\n    size_t total_elements = m * n;\n    \n    // Create a vector with the scalar value\n    svfloat64_t scalar_vec = svdup_n_f64(scalar);\n    \n    // Process elements in vector-sized chunks\n    size_t vector_length = svcntd(); // Number of double elements in a vector\n    size_t i;\n    \n    for (i = 0; i + vector_length <= total_elements; i += vector_length) {\n        // Load vector of doubles from source matrix\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pg, mat + i);\n        \n        // Multiply vector by scalar\n        svfloat64_t result_vec = svmul_f64_x(pg, mat_vec, scalar_vec);\n        \n        // Store result vector to destination matrix\n        svst1_f64(pg, dst + i, result_vec);\n    }\n    \n    // Handle any remaining elements\n    for (; i < total_elements; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Compute squared values and sum\n        svfloat32_t sum_squares = svdup_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t squared = svmul_f32_z(pg, vec, vec);\n            sum_squares = svadd_f32_z(pg, sum_squares, squared);\n        }\n        \n        // Horizontal sum of squared values\n        float norm_squared = svaddv_f32(svptrue_b32(), sum_squares);\n        float norm = sqrtf(norm_squared);\n        \n        // Normalize row\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t normalized = svdiv_f32_z(pg, vec, svdup_n_f32(norm));\n            svst1_f32(pg, row + j, normalized);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t row = 0; row < m; row++) {\n        float* row_ptr = mat + row * n;\n        \n        // Compute squared sum using SVE\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + j);\n            svfloat32_t squared_vec = svmul_f32_z(pg, vec, vec);\n            sum_vec = svadd_f32_z(pg, sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        float sum_squared = svaddv_f32(svptrue_b32(), sum_vec);\n        \n        // Compute L2 norm (square root of sum of squares)\n        float norm = sqrtf(sum_squared);\n        \n        // Normalize row using SVE\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + j);\n            svfloat32_t normalized_vec = svdiv_f32_z(pg, vec, svdup_n_f32(norm));\n            svst1_f32(pg, row_ptr + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t row = 0; row < m; row++) {\n        float* row_ptr = mat + row * n;\n        \n        // Compute squared sum using SVE\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + j);\n            svfloat32_t squared_vec = svmul_f32_z(pg, vec, vec);\n            sum_vec = svadd_f32_z(pg, sum_vec, squared_vec);\n        }\n        \n        // Horizontal sum of squared values\n        float sum_squared = svaddv_f32(svptrue_b32(), sum_vec);\n        \n        // Compute L2 norm (square root of sum of squares)\n        float norm = sqrtf(sum_squared);\n        \n        // Normalize row using SVE\n        for (size_t j = 0; j < n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + j);\n            svfloat32_t normalized_vec = svdiv_f32_z(pg, vec, svdup_n_f32(norm));\n            svst1_f32(pg, row_ptr + j, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t row = 0; row < m; row++) {\n        float* row_ptr = mat + row * n;\n        \n        // Compute squared sum using SVE\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        for (size_t col = 0; col < n; col += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(col, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + col);\n            svfloat32_t squared_vec = svmul_f32_z(pg, vec, vec);\n            sum_vec = svadd_f32_z(pg, sum_vec, squared_vec);\n        }\n        \n        // Reduce sum vector to scalar\n        float sum_squared = svaddv_f32(svptrue_b32(), sum_vec);\n        float norm = sqrtf(sum_squared);\n        \n        // Normalize row using SVE\n        for (size_t col = 0; col < n; col += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(col, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + col);\n            svfloat32_t normalized_vec = svdiv_f32_z(pg, vec, svdup_n_f32(norm));\n            svst1_f32(pg, row_ptr + col, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t row = 0; row < m; row++) {\n        float* row_ptr = mat + row * n;\n        \n        // Compute squared sum using SVE\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        for (size_t col = 0; col < n; col += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(col, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + col);\n            svfloat32_t squared_vec = svmul_f32_z(pg, vec, vec);\n            sum_vec = svadd_f32_z(pg, sum_vec, squared_vec);\n        }\n        \n        // Reduce sum vector to scalar\n        float sum_squared = svaddv_f32(svptrue_b32(), sum_vec);\n        float norm = sqrtf(sum_squared);\n        \n        // Normalize row using SVE\n        for (size_t col = 0; col < n; col += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(col, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + col);\n            svfloat32_t normalized_vec = svdiv_f32_z(pg, vec, svdup_n_f32(norm));\n            svst1_f32(pg, row_ptr + col, normalized_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += svcntd()) {\n            svfloat64_t sum = svdup_f64(0.0);\n            svbool_t pg = svwhilelt_b64(j, p);\n\n            for (size_t k = 0; k < n; k++) {\n                svfloat64_t a = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &mat2[k * p + j]);\n                sum = svmla_f64_x(pg, sum, a, b);\n            }\n\n            svfloat64_t rounded = svrinta_f64_x(pg, sum);\n            svst1_f64(pg, &dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_n_f64(0.0);\n            \n            size_t k = 0;\n            svbool_t pg = svwhilelt_b64(k, n);\n            \n            do {\n                svfloat64_t vec1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmla_f64_m(pg, sum, vec1, vec2);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            } while (svptest_any(svptrue_b64(), pg));\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_n_f64(0.0);\n            \n            size_t k = 0;\n            svbool_t pg = svwhilelt_b64(k, n);\n            \n            do {\n                svfloat64_t vec1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmla_f64_m(pg, sum, vec1, vec2);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            } while (svptest_any(svptrue_b64(), pg));\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_n_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t vec1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmla_f64_m(pg, sum, vec1, vec2);\n            }\n            \n            svfloat64_t rounded = svrintn_f64_z(svptrue_b64(), sum);\n            svst1_f64(svptrue_b64(), &dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_n_f64(0.0);\n            \n            size_t k = 0;\n            svbool_t pg = svwhilelt_b64(k, n);\n            \n            do {\n                svfloat64_t vec1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t vec2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmla_f64_m(pg, sum, vec1, vec2);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            } while (svptest_any(svptrue_b64(), pg));\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Iterate through each row of the source matrix\n    for (size_t r = 0; r < rows; r++) {\n        // Determine the SVE vector length for floats\n        size_t vec_len = svcntw();\n        \n        // Process matrix in vector-sized chunks\n        for (size_t c = 0; c < cols; c += vec_len) {\n            // Create predicate for handling edge cases\n            svbool_t pg = svwhilelt_b32_u64(c, cols);\n            \n            // Load vector of source matrix elements\n            svfloat32_t vec = svld1_f32(pg, src + r * cols + c);\n            \n            // Round to nearest quarter\n            svfloat32_t rounded = svmul_f32_z(pg, \n                                   svrint_f32_z(pg, \n                                   svmul_f32_z(pg, vec, 4.0f)), \n                                   0.25f);\n            \n            // Store transposed and rounded elements\n            svst1_f32(pg, dst + c * rows + r, rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Iterate through rows with SVE vector processing\n    for (size_t r = 0; r < rows; r += svcntw()) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(r, rows);\n        \n        // Process columns\n        for (size_t c = 0; c < cols; ++c) {\n            // Load source matrix elements\n            svfloat32_t vec = svld1_gather_index_f32(pg, src + c * rows + r, \n                                                     svindex_u32(0, 1));\n            \n            // Round to nearest quarter\n            svfloat32_t rounded = svrinta_f32_z(pg, svmul_f32_z(pg, \n                                                 svrinta_f32_z(pg, \n                                                 svmul_f32_z(pg, vec, 4.0f), \n                                                 pg), \n                                                 0.25f));\n            \n            // Store transposed and rounded elements\n            svst1_scatter_index_f32(pg, dst + r * cols + c, \n                                    svindex_u32(0, 1), rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Iterate through each column of the source matrix\n    for (size_t col = 0; col < cols; col++) {\n        // Determine the maximum vector length for this column\n        size_t vec_len = svcntw();\n        \n        // Process the column in vector chunks\n        for (size_t row = 0; row < rows; row += vec_len) {\n            // Determine the number of elements to process in this iteration\n            svbool_t pg = svwhilelt_b32(row, rows);\n            \n            // Load vector of floats from the source matrix\n            svfloat32_t vec = svld1_f32(pg, src + row * cols + col);\n            \n            // Round to nearest quarter\n            svfloat32_t rounded = svrinta_f32_z(pg, vec * 4.0f) / 4.0f;\n            \n            // Store the rounded vector in the destination matrix\n            svst1_f32(pg, dst + col * rows + row, rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Iterate through each row of the source matrix\n    for (size_t r = 0; r < rows; r++) {\n        // Determine the maximum vector length for this row\n        size_t vec_len = svcntw();\n        \n        // Process the matrix in vector-sized chunks\n        for (size_t c = 0; c < cols; c += vec_len) {\n            // Create predicate to handle edge cases\n            svbool_t pg = svwhilelt_b32_u64(c, cols);\n            \n            // Load vector of source matrix elements\n            svfloat32_t vec = svld1_f32(pg, src + r * cols + c);\n            \n            // Round to nearest quarter\n            svfloat32_t rounded = svmul_f32_z(pg, \n                                   svrint_f32_z(pg, \n                                   svmul_f32_z(pg, vec, 4.0f)), \n                                   0.25f);\n            \n            // Store transposed and rounded elements in destination matrix\n            svst1_f32(pg, dst + c * rows + r, rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    // Iterate through each row of the source matrix\n    for (size_t r = 0; r < rows; r++) {\n        // Determine the maximum vector length for this iteration\n        size_t vec_len = svcntw();\n        \n        // Process columns in vector-sized chunks\n        for (size_t c = 0; c < cols; c += vec_len) {\n            // Create predicate to handle edge cases\n            svbool_t pg = svwhilelt_b32(c, cols);\n            \n            // Load vector of source matrix elements\n            svfloat32_t vec_src = svld1_f32(pg, src + r * cols + c);\n            \n            // Round to nearest quarter\n            svfloat32_t vec_rounded = svrinta_f32_z(pg, svdiv_f32_z(pg, vec_src, svdup_f32(0.25f)));\n            vec_rounded = svmul_f32_z(pg, vec_rounded, svdup_f32(0.25f));\n            \n            // Store transposed and rounded elements in destination matrix\n            svst1_f32(pg, dst + c * rows + r, vec_rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Process vector elements\n    size_t vector_length = svcntw(); // Number of float elements in a vector\n    size_t i = 0;\n    \n    // Iterate through elements using SVE vectors\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        // Load vector elements from tensor1 and tensor2\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        \n        // Perform element-wise subtraction\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        \n        // Round towards zero\n        svfloat32_t rounded = svrinta_f32_z(pg, result);\n        \n        // Store result in destination tensor\n        svst1_f32(pg, dst + i, rounded);\n    }\n    \n    // Handle remaining scalar elements\n    for (; i < total_elements; i++) {\n        dst[i] = floorf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Process vector elements\n    size_t vector_length = svcntw(); // Number of float elements in a vector\n    size_t i = 0;\n    \n    // Use SVE predicate to handle vector processing\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector elements with predicate\n        svfloat32_t vec1 = svld1_z(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_z(pg, tensor2 + i);\n        \n        // Perform subtraction\n        svfloat32_t result = svsub_z(pg, vec1, vec2);\n        \n        // Round towards zero\n        svfloat32_t rounded = svrinta_z(pg, result);\n        \n        // Store result with predicate\n        svst1_z(pg, dst + i, rounded);\n        \n        // Update indices and predicate\n        i += vector_length;\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Process vector elements using SVE\n    for (size_t i = 0; i < total_elements; i += svcntw()) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b32_u64(i, total_elements);\n        \n        // Load vector elements from tensor1 and tensor2\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        \n        // Perform element-wise subtraction\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        \n        // Round towards zero\n        svfloat32_t rounded_result = svrintz_f32_z(pg, result);\n        \n        // Store result in destination tensor\n        svst1_f32(pg, dst + i, rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Process vector elements\n    size_t vector_length = svcntw(); // Number of float elements in a vector\n    size_t i = 0;\n    \n    // Use SVE predicate to handle vector processing\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector elements with predicate\n        svfloat32_t vec1 = svld1_z(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_z(pg, tensor2 + i);\n        \n        // Subtract vectors\n        svfloat32_t result_vec = svsub_z(pg, vec1, vec2);\n        \n        // Round towards zero\n        svfloat32_t rounded_vec = svrintz_z(pg, result_vec);\n        \n        // Store result vector\n        svst1_z(pg, dst + i, rounded_vec);\n        \n        // Update indices and predicate\n        i += vector_length;\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Process vector-sized chunks\n    size_t vector_length = svcntw(); // Number of float elements in an SVE vector\n    size_t i = 0;\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        // Load vector elements from tensor1 and tensor2\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + i);\n        \n        // Perform element-wise subtraction\n        svfloat32_t result = svsub_f32_z(pg, vec1, vec2);\n        \n        // Round towards zero\n        svfloat32_t rounded = svrinta_f32_z(pg, result);\n        \n        // Store result in destination tensor\n        svst1_f32(pg, dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        dst[i] = floorf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, n);\n        \n        do {\n            // Load vectors of doubles from mat1 and mat2\n            svfloat64_t vec1 = svld1_f64(pg, mat1 + i*n + j);\n            svfloat64_t vec2 = svld1_f64(pg, mat2 + i*n + j);\n            \n            // Perform element-wise multiplication\n            svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n            \n            // Store result in destination matrix\n            svst1_f64(pg, dst + i*n + j, result);\n            \n            // Update loop variables\n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, n);\n        \n        do {\n            // Load vectors of mat1 and mat2\n            svfloat64_t vec1 = svld1_f64(pg, mat1 + i * n + j);\n            svfloat64_t vec2 = svld1_f64(pg, mat2 + i * n + j);\n            \n            // Perform element-wise multiplication\n            svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n            \n            // Store result in destination matrix\n            svst1_f64(pg, dst + i * n + j, result);\n            \n            // Move to next vector\n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, n);\n        \n        do {\n            // Load vectors of doubles from mat1 and mat2\n            svfloat64_t vec1 = svld1_z(pg, mat1 + i*n + j);\n            svfloat64_t vec2 = svld1_z(pg, mat2 + i*n + j);\n            \n            // Perform element-wise multiplication\n            svfloat64_t result = svmul_z(pg, vec1, vec2);\n            \n            // Store result in destination matrix\n            svst1_z(pg, dst + i*n + j, result);\n            \n            // Move to next vector\n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, n);\n        \n        do {\n            // Load vectors of mat1 and mat2\n            svfloat64_t vec1 = svld1_f64(pg, mat1 + i*n + j);\n            svfloat64_t vec2 = svld1_f64(pg, mat2 + i*n + j);\n            \n            // Perform element-wise multiplication\n            svfloat64_t result = svmul_f64_z(pg, vec1, vec2);\n            \n            // Store result in destination matrix\n            svst1_f64(pg, dst + i*n + j, result);\n            \n            // Move to next vector\n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, n);\n        \n        do {\n            // Load vectors of doubles from mat1 and mat2\n            svfloat64_t vec1 = svld1_z(pg, mat1 + i*n + j);\n            svfloat64_t vec2 = svld1_z(pg, mat2 + i*n + j);\n            \n            // Perform element-wise multiplication\n            svfloat64_t result = svmul_z(pg, vec1, vec2);\n            \n            // Store result in destination matrix\n            svst1_z(pg, dst + i*n + j, result);\n            \n            // Move to next vector\n            j += svcntd();\n            pg = svwhilelt_b64(j, n);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_n_f32(0.0f);\n        \n        size_t j = 0;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t mat_vec = svld1_f32(pg, mat + i * n + j);\n            svfloat32_t vec_vec = svld1_f32(pg, vec + j);\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec);\n        }\n        \n        float total_sum = svaddv_f32(svptrue_b32(), sum);\n        \n        for (; j < n; j++) {\n            total_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = total_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_n_f32(0.0f);\n        \n        size_t j = 0;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t mat_vec = svld1_f32(pg, mat + i * n + j);\n            svfloat32_t vec_vec = svld1_f32(pg, vec + j);\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec);\n        }\n        \n        float total_sum = svaddv_f32(svptrue_b32(), sum);\n        \n        for (; j < n; j++) {\n            total_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = total_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_n_f32(0.0f);\n        \n        size_t j = 0;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t mat_vec = svld1_f32(pg, mat + i * n + j);\n            svfloat32_t vec_vec = svld1_f32(pg, vec + j);\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec);\n        }\n        \n        float total_sum = svaddv_f32(svptrue_b32(), sum);\n        \n        for (; j < n; j++) {\n            total_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = total_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_n_f32(0.0f);\n        \n        size_t j = 0;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t mat_vec = svld1_f32(pg, mat + i * n + j);\n            svfloat32_t vec_vec = svld1_f32(pg, vec + j);\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec);\n        }\n        \n        float total_sum = svaddv_f32(svptrue_b32(), sum);\n        \n        for (; j < n; j++) {\n            total_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = total_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_n_f32(0.0f);\n        \n        size_t j = 0;\n        for (; j + svcntw() <= n; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32_u64(j, n);\n            svfloat32_t mat_vec = svld1_f32(pg, mat + i * n + j);\n            svfloat32_t vec_vec = svld1_f32(pg, vec + j);\n            sum = svmla_f32_m(pg, sum, mat_vec, vec_vec);\n        }\n        \n        float total_sum = svaddv_f32(svptrue_b32(), sum);\n        \n        for (; j < n; j++) {\n            total_sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = total_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t vector_length = svcntd();\n    \n    size_t i = 0;\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        svfloat64_t current_vec = svld1_f64(svptrue_b64(), mat + i);\n        sum_vec = svadd_f64_x(svptrue_b64(), sum_vec, current_vec);\n    }\n    \n    double scalar_sum = svaddv_f64(svptrue_b64(), sum_vec);\n    \n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n    \n    return scalar_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t vector_length = svcntd();\n    \n    size_t i = 0;\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        svfloat64_t current_vec = svld1_f64(svptrue_b64(), mat + i);\n        sum_vec = svadd_f64_x(svptrue_b64(), sum_vec, current_vec);\n    }\n    \n    double scalar_sum = svaddv_f64(svptrue_b64(), sum_vec);\n    \n    for (; i < total_elements; ++i) {\n        scalar_sum += mat[i];\n    }\n    \n    return scalar_sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n    size_t total_elements = m * n;\n    size_t vec_len = svcntd();\n    \n    size_t i = 0;\n    for (; i + vec_len <= total_elements; i += vec_len) {\n        svbool_t pg = svwhilelt_b64_u64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n    }\n    \n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t total_elements = m * n;\n    size_t vec_len = svcntd();\n    \n    size_t i = 0;\n    for (; i + vec_len <= total_elements; i += vec_len) {\n        svfloat64_t vec = svld1_f64(svptrue_b64(), mat + i);\n        sum_vec = svadd_f64_m(svptrue_b64(), sum_vec, vec);\n    }\n    \n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n    size_t total_elements = m * n;\n    size_t vec_len = svcntd();\n    \n    size_t i = 0;\n    for (; i + vec_len <= total_elements; i += vec_len) {\n        svbool_t pg = svwhilelt_b64_u64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        sum_vec = svadd_f64_m(pg, sum_vec, vec);\n    }\n    \n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    \n    // Handle remaining elements\n    for (; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* current_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        // Use SVE predicate and vector length\n        svbool_t pg = svptrue_b32();\n        size_t vector_length = svcntw();\n        \n        for (size_t col = 0; col < cols - vector_length; col += vector_length) {\n            // Load current and next vector segments\n            svint32_t current_vec = svld1_z(pg, current_row + col);\n            svint32_t next_vec = svld1_z(pg, current_row + col + vector_length);\n            \n            // Compare vectors based on sort direction\n            svbool_t comparison;\n            if (ascending) {\n                // Check if current vector is less than or equal to next vector\n                comparison = svcmpge_s32(pg, current_vec, next_vec);\n            } else {\n                // Check if current vector is greater than or equal to next vector\n                comparison = svcmple_s32(pg, current_vec, next_vec);\n            }\n            \n            // If any comparison fails, row is not sorted\n            if (svptest_any(pg, comparison)) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - vector_length; col < cols - 1; col++) {\n            if (ascending && current_row[col] > current_row[col + 1]) {\n                return false;\n            }\n            if (!ascending && current_row[col] < current_row[col + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* row_ptr = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svptrue_b32();\n        size_t vector_cols = svcntw();\n        \n        for (size_t col = 0; col < cols - vector_cols; col += vector_cols) {\n            svint32_t current = svld1_z(pg, row_ptr + col);\n            svint32_t next = svld1_z(pg, row_ptr + col + vector_cols);\n            \n            svbool_t comparison;\n            if (ascending) {\n                comparison = svcmpgt_z(pg, current, next);\n            } else {\n                comparison = svcmplt_z(pg, current, next);\n            }\n            \n            if (svptest_any(pg, comparison)) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - vector_cols; col < cols - 1; col++) {\n            if (ascending && row_ptr[col] > row_ptr[col + 1]) {\n                return false;\n            }\n            if (!ascending && row_ptr[col] < row_ptr[col + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* row_ptr = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svptrue_b32();\n        svint32_t prev_vec = svld1_z(pg, row_ptr);\n        \n        for (size_t col = 1; col < cols; col += svcntw()) {\n            svbool_t mask = svwhilelt_b32_u64(col, cols);\n            svint32_t curr_vec = svld1_z(mask, row_ptr + col);\n            \n            svbool_t cmp_mask;\n            if (ascending) {\n                cmp_mask = svcmpgt_s32(pg, curr_vec, prev_vec);\n            } else {\n                cmp_mask = svcmplt_s32(pg, curr_vec, prev_vec);\n            }\n            \n            if (svptest_any(pg, cmp_mask)) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* row_ptr = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svptrue_b32();\n        svint32_t prev_vec = svld1_z(pg, row_ptr);\n        \n        for (size_t vec_start = svcntw(); vec_start < cols; vec_start += svcntw()) {\n            svint32_t curr_vec = svld1_z(pg, row_ptr + vec_start);\n            \n            svbool_t cmp_mask = ascending ? \n                svcmpgt_z(pg, prev_vec, curr_vec) : \n                svcmplt_z(pg, prev_vec, curr_vec);\n            \n            if (svptest_any(pg, cmp_mask)) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n        }\n        \n        // Handle remaining elements\n        for (size_t i = (cols / svcntw()) * svcntw(); i < cols - 1; i++) {\n            if (ascending && row_ptr[i] > row_ptr[i+1]) {\n                return false;\n            }\n            if (!ascending && row_ptr[i] < row_ptr[i+1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* row_ptr = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svwhilelt_b32_u64(0, cols);\n        svint32_t prev_vec = svld1_z(pg, row_ptr);\n        size_t vec_index = svcntw();\n        \n        while (vec_index < cols) {\n            svint32_t curr_vec = svld1_z(pg, row_ptr + vec_index);\n            \n            svbool_t cmp_mask = ascending ? \n                svcmpgt_z(pg, prev_vec, curr_vec) : \n                svcmplt_z(pg, prev_vec, curr_vec);\n            \n            if (svptest_any(pg, cmp_mask)) {\n                return false;\n            }\n            \n            prev_vec = curr_vec;\n            vec_index += svcntw();\n            pg = svwhilelt_b32_u64(vec_index, cols);\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        // Load source vector\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        \n        // Perform division and multiplication to find nearest multiple\n        svint16_t base_vec = svdup_n_s16(base);\n        svint16_t quotient = svdiv_s16_z(pg, src_vec, base_vec);\n        svint16_t multiple = svmul_s16_z(pg, quotient, base_vec);\n        \n        // Store result in destination vector\n        svst1_s16(pg, dst + i, multiple);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        svint16_t src_vec = svld1_s16(pg, src + i);\n        \n        svint16_t base_vec = svdup_n_s16(base);\n        \n        svint16_t quotient = svdiv_s16_z(pg, src_vec, base_vec);\n        \n        svint16_t multiple = svmul_s16_z(pg, quotient, base_vec);\n        \n        svst1_s16(pg, dst + i, multiple);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        // Load source vector\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        \n        // Compute division and multiply back to get nearest multiple\n        svint16_t base_vec = svdup_n_s16(base);\n        svint16_t div_vec = svdiv_s16_z(pg, src_vec, base_vec);\n        svint16_t multiple_vec = svmul_s16_z(pg, div_vec, base_vec);\n        \n        // Store result\n        svst1_s16(pg, dst + i, multiple_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        // Load source vector\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        \n        // Compute division and multiply back to get nearest multiple\n        svint16_t base_vec = svdup_n_s16(base);\n        svint16_t div_vec = svsub_s16_z(pg, src_vec, svmod_s16_z(pg, src_vec, base_vec));\n        \n        // Store result in destination vector\n        svst1_s16(pg, dst + i, div_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        \n        // Load source vector\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        \n        // Compute the nearest multiple\n        svint16_t base_vec = svdup_n_s16(base);\n        svint16_t div_vec = svsub_s16_z(pg, src_vec, base_vec);\n        svint16_t div_result = svdiv_s16_z(pg, div_vec, base_vec);\n        svint16_t multiple_vec = svmul_s16_z(pg, div_result, base_vec);\n        \n        // Store result\n        svst1_s16(pg, dst + i, multiple_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t match = svptrue_b64();\n        \n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t matrix_vec = svld1_f64(match, matrix + r * cols + c);\n            svfloat64_t vector_vec = svld1_f64(match, vector + c);\n            \n            match = svcmpeq_f64(match, matrix_vec, vector_vec);\n            \n            if (!svptest_any(svptrue_b64(), match)) {\n                break;\n            }\n        }\n        \n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t match = svptrue_b64();\n        \n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t matrix_vec = svld1_f64(match, matrix + r * cols + c);\n            svfloat64_t vector_vec = svld1_f64(match, vector + c);\n            \n            match = svcmpeq_f64(match, matrix_vec, vector_vec);\n            \n            if (!svptest_any(svptrue_b64(), match)) {\n                break;\n            }\n        }\n        \n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t match = svptrue_b64();\n        \n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t matrix_vec = svld1_f64(match, matrix + r * cols + c);\n            svfloat64_t vector_vec = svld1_f64(match, vector + c);\n            \n            match = svcmpeq_f64(match, matrix_vec, vector_vec);\n            \n            if (!svptest_any(svptrue_b64(), match)) {\n                break;\n            }\n        }\n        \n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t match = svptrue_b64();\n        \n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t matrix_vec = svld1_f64(match, matrix + r * cols + c);\n            svfloat64_t vector_vec = svld1_f64(match, vector + c);\n            \n            match = svcmpeq_f64(match, matrix_vec, vector_vec);\n            \n            if (!svptest_any(svptrue_b64(), match)) {\n                break;\n            }\n        }\n        \n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t match = svptrue_b64();\n        \n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t matrix_vec = svld1_f64(match, matrix + r * cols + c);\n            svfloat64_t vector_vec = svld1_f64(match, vector + c);\n            \n            match = svcmpeq_f64(match, matrix_vec, vector_vec);\n            \n            if (!svptest_any(svptrue_b64(), match)) {\n                break;\n            }\n        }\n        \n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Compute total number of vector operations needed\n    size_t vector_length = svcntb();\n    size_t num_vectors = total_elements / vector_length;\n    size_t remainder = total_elements % vector_length;\n    \n    // Process full vector chunks\n    for (size_t i = 0; i < num_vectors; ++i) {\n        svbool_t pg = svwhilelt_b8_u64(0, vector_length);\n        svuint8_t vec_a = svld1_u8(pg, A + i * vector_length);\n        svuint8_t vec_b = svld1_u8(pg, B + i * vector_length);\n        \n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, equal_mask);\n    }\n    \n    // Handle remaining elements\n    if (remainder > 0) {\n        svbool_t pg = svwhilelt_b8_u64(0, remainder);\n        svuint8_t vec_a = svld1_u8(pg, A + num_vectors * vector_length);\n        svuint8_t vec_b = svld1_u8(pg, B + num_vectors * vector_length);\n        \n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, equal_mask);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Compute total number of vector operations needed\n    size_t vector_length = svcntb();\n    size_t num_vectors = total_elements / vector_length;\n    size_t remainder = total_elements % vector_length;\n    \n    // Create predicate for full vector operations\n    svbool_t pg = svptrue_b8();\n    \n    // Accumulate equal count using vector operations\n    for (size_t i = 0; i < num_vectors; ++i) {\n        svuint8_t vec_a = svld1_u8(pg, A + i * vector_length);\n        svuint8_t vec_b = svld1_u8(pg, B + i * vector_length);\n        \n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        size_t vector_equal_count = svcntp_b8(pg, equal_mask);\n        \n        equal_count += vector_equal_count;\n    }\n    \n    // Handle remainder elements\n    if (remainder > 0) {\n        svbool_t pg_remainder = svwhilelt_b8_u64(0, remainder);\n        svuint8_t vec_a = svld1_u8(pg_remainder, A + num_vectors * vector_length);\n        svuint8_t vec_b = svld1_u8(pg_remainder, B + num_vectors * vector_length);\n        \n        svbool_t equal_mask = svcmpeq_u8(pg_remainder, vec_a, vec_b);\n        size_t vector_equal_count = svcntp_b8(pg_remainder, equal_mask);\n        \n        equal_count += vector_equal_count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Process elements in SVE vector lanes\n    size_t vector_size = svcntb();\n    \n    for (size_t i = 0; i < total_elements; i += vector_size) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b8_u64(i, total_elements);\n        \n        // Load vectors from A and B\n        svuint8_t vec_a = svld1_u8(pg, A + i);\n        svuint8_t vec_b = svld1_u8(pg, B + i);\n        \n        // Compare vectors for equality\n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        \n        // Count equal elements in this vector\n        size_t vector_equal_count = svcntp_b8(pg, equal_mask);\n        equal_count += vector_equal_count;\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Predicate and vector length\n    svbool_t pg = svptrue_b8();\n    size_t vec_length = svcntb();\n    \n    // Process elements in vector chunks\n    size_t i;\n    for (i = 0; i + vec_length <= total_elements; i += vec_length) {\n        // Load vectors\n        svuint8_t vec_a = svld1_u8(pg, A + i);\n        svuint8_t vec_b = svld1_u8(pg, B + i);\n        \n        // Compare vectors\n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        \n        // Count equal elements\n        equal_count += svcntp_b8(pg, equal_mask);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n    \n    // Compute total number of vector operations needed\n    size_t vector_size = svcntb();\n    size_t num_vectors = total_elements / vector_size;\n    size_t remainder = total_elements % vector_size;\n    \n    // Process full vector chunks\n    for (size_t i = 0; i < num_vectors; ++i) {\n        svbool_t pg = svwhilelt_b8_u64(0, vector_size);\n        svuint8_t vec_a = svld1_u8(pg, A + i * vector_size);\n        svuint8_t vec_b = svld1_u8(pg, B + i * vector_size);\n        \n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, equal_mask);\n    }\n    \n    // Handle remaining elements\n    if (remainder > 0) {\n        svbool_t pg = svwhilelt_b8_u64(0, remainder);\n        svuint8_t vec_a = svld1_u8(pg, A + num_vectors * vector_size);\n        svuint8_t vec_b = svld1_u8(pg, B + num_vectors * vector_size);\n        \n        svbool_t equal_mask = svcmpeq_u8(pg, vec_a, vec_b);\n        equal_count += svcntp_b8(pg, equal_mask);\n    }\n    \n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load x vector\n        svint64_t x_vec = svld1_s64(pg, x + i);\n        \n        // Scalar-vector multiplication\n        svint64_t ax_vec = svmul_s64_z(pg, x_vec, a);\n        \n        // Absolute value\n        svint64_t abs_vec = svabs_s64_z(pg, ax_vec);\n        \n        // Store result to y\n        svst1_s64(pg, y + i, abs_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load x vector\n        svint64_t x_vec = svld1_s64(pg, x + i);\n        \n        // Scalar-vector multiplication\n        svint64_t ax_vec = svmul_s64_z(pg, x_vec, a);\n        \n        // Absolute value\n        svint64_t abs_vec = svabs_s64_z(pg, ax_vec);\n        \n        // Store result to y\n        svst1_s64(pg, y + i, abs_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load x vector\n        svint64_t x_vec = svld1_s64(pg, x + i);\n        \n        // Scalar-vector multiplication\n        svint64_t ax_vec = svmul_s64_z(pg, x_vec, a);\n        \n        // Absolute value\n        svint64_t abs_vec = svabs_s64_z(pg, ax_vec);\n        \n        // Store result to y\n        svst1_s64(pg, y + i, abs_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load x vector\n        svint64_t x_vec = svld1_s64(pg, x + i);\n        \n        // Scalar-vector multiplication\n        svint64_t ax_vec = svmul_s64_z(pg, x_vec, a);\n        \n        // Absolute value\n        svint64_t abs_vec = svabs_s64_z(pg, ax_vec);\n        \n        // Store result to y\n        svst1_s64(pg, y + i, abs_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load x vector\n        svint64_t x_vec = svld1_s64(pg, x + i);\n        \n        // Scalar-vector multiplication\n        svint64_t ax_vec = svmul_s64_z(pg, x_vec, a);\n        \n        // Absolute value\n        svint64_t abs_vec = svabs_s64_z(pg, ax_vec);\n        \n        // Store result to y\n        svst1_s64(pg, y + i, abs_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t vector_length = svcntb() / sizeof(int16_t);\n    svbool_t pg = svwhilelt_b16_u64(0, length);\n    \n    svint16_t current_min = svdup_n_s16(INT16_MAX);\n    svint16_t current_max = svdup_n_s16(INT16_MIN);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        \n        current_min = svmin_s16_z(pg, current_min, data);\n        current_max = svmax_s16_z(pg, current_max, data);\n        \n        pg = svwhilelt_b16_u64(i + vector_length, length);\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), current_min);\n    result.max_num = svmaxv_s16(svptrue_b16(), current_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t vector_length = svcntb() / sizeof(int16_t);\n    svbool_t pg = svwhilelt_b16_u64(0, length);\n    \n    svint16_t current_min = svdup_n_s16(INT16_MAX);\n    svint16_t current_max = svdup_n_s16(INT16_MIN);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        \n        current_min = svmin_s16_z(pg, current_min, data);\n        current_max = svmax_s16_z(pg, current_max, data);\n        \n        pg = svwhilelt_b16_u64(i + vector_length, length);\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), current_min);\n    result.max_num = svmaxv_s16(svptrue_b16(), current_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t vector_length = svcntb() / sizeof(int16_t);\n    svbool_t pg = svwhilelt_b16_u64(0, length);\n    \n    svint16_t current_min = svdup_n_s16(INT16_MAX);\n    svint16_t current_max = svdup_n_s16(INT16_MIN);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        \n        current_min = svmin_s16_z(pg, current_min, data);\n        current_max = svmax_s16_z(pg, current_max, data);\n        \n        pg = svwhilelt_b16_u64(i + vector_length, length);\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), current_min);\n    result.max_num = svmaxv_s16(svptrue_b16(), current_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t vector_length = svcntb() / sizeof(int16_t);\n    svbool_t pg = svwhilelt_b16_u64(0, length);\n    \n    svint16_t current_min = svdup_n_s16(INT16_MAX);\n    svint16_t current_max = svdup_n_s16(INT16_MIN);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        \n        current_min = svmin_s16_z(pg, current_min, data);\n        current_max = svmax_s16_z(pg, current_max, data);\n        \n        pg = svwhilelt_b16_u64(i + vector_length, length);\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), current_min);\n    result.max_num = svmaxv_s16(svptrue_b16(), current_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result = {INT16_MAX, INT16_MIN};\n    \n    size_t vector_length = svcntb() / sizeof(int16_t);\n    svbool_t pg = svwhilelt_b16_u64(0, length);\n    \n    svint16_t current_min = svdup_n_s16(INT16_MAX);\n    svint16_t current_max = svdup_n_s16(INT16_MIN);\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svint16_t data = svld1_s16(pg, vec + i);\n        \n        current_min = svmin_s16_z(pg, current_min, data);\n        current_max = svmax_s16_z(pg, current_max, data);\n        \n        pg = svwhilelt_b16_u64(i + vector_length, length);\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), current_min);\n    result.max_num = svmaxv_s16(svptrue_b16(), current_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svwhilelt_b32_u64(0, cols);\n        svint32_t prev = svld1_z(pg, row);\n        size_t offset = svcntw();\n\n        while (offset < cols) {\n            svbool_t next_pg = svwhilelt_b32_u64(offset, cols);\n            svint32_t curr = svld1_z(next_pg, row + offset);\n            svbool_t is_increasing = svcmpgt_s32(pg, curr, prev);\n\n            if (!svptest_any(pg, is_increasing)) {\n                return false;\n            }\n\n            prev = curr;\n            pg = next_pg;\n            offset += svcntw();\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svwhilelt_b32_u64(0, cols);\n        svint32_t prev = svld1_z(pg, row);\n        size_t offset = svcntw();\n\n        while (offset < cols) {\n            svbool_t next_pg = svwhilelt_b32_u64(offset, cols);\n            svint32_t curr = svld1_z(next_pg, row + offset);\n            svbool_t is_increasing = svcmpgt_s32(pg, curr, prev);\n\n            if (!svptest_any(pg, is_increasing)) {\n                return false;\n            }\n\n            prev = curr;\n            pg = next_pg;\n            offset += svcntw();\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svwhilelt_b32_u64(0, cols);\n        svint32_t prev = svld1_z(pg, row);\n        size_t offset = svcntw();\n\n        while (offset < cols) {\n            svbool_t pg_next = svwhilelt_b32_u64(offset, cols);\n            svint32_t curr = svld1_z(pg_next, row + offset);\n            \n            svbool_t is_increasing = svcmpgt_s32(pg_next, curr, prev);\n            if (!svptest_any(pg_next, is_increasing)) return false;\n\n            prev = curr;\n            offset += svcntw();\n            pg = pg_next;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svwhilelt_b32_u64(0, cols);\n        svint32_t prev = svld1_z(pg, row);\n        size_t offset = svcntw();\n\n        while (offset < cols) {\n            svbool_t pg_next = svwhilelt_b32_u64(offset, cols);\n            svint32_t curr = svld1_z(pg_next, row + offset);\n            \n            svbool_t is_increasing = svcmpgt_s32(pg_next, curr, prev);\n            if (!svptest_any(pg_next, is_increasing)) return false;\n\n            prev = curr;\n            offset += svcntw();\n            pg = pg_next;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row = matrix + r * cols;\n        svbool_t pg = svwhilelt_b32_u64(0, cols);\n        svint32_t prev = svld1_z(pg, row);\n        size_t offset = svcntw();\n\n        while (offset < cols) {\n            svbool_t next_pg = svwhilelt_b32_u64(offset, cols);\n            svint32_t curr = svld1_z(next_pg, row + offset);\n            svbool_t is_increasing = svcmpgt_s32(pg, curr, prev);\n\n            if (!svptest_any(pg, is_increasing)) {\n                return false;\n            }\n\n            prev = curr;\n            pg = next_pg;\n            offset += svcntw();\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for invalid block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Pointer to the current block\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            // SVE vector comparison\n            svbool_t pg = svptrue_b32();\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += svcntw()) {\n                    svint32_t first_vec = svld1_s32(pg, first_block + i * cols + j);\n                    svint32_t current_vec = svld1_s32(pg, current_block + i * cols + j);\n                    \n                    // Compare vectors\n                    svbool_t comparison = svcmpeq_s32(pg, first_vec, current_vec);\n                    \n                    // If any elements are not equal, return false\n                    if (!svptest_any(pg, comparison)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 1; block_row < block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < block_cols; ++block_col) {\n            // Pointer to the current block\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Process block using SVE\n            svbool_t pg = svptrue_b32();\n            size_t block_elements = block_size * block_size;\n            \n            for (size_t i = 0; i < block_elements; i += svcntw()) {\n                // Load vectors from first and current blocks\n                svint32_t first_vec = svld1(pg, first_block + i);\n                svint32_t current_vec = svld1(pg, current_block + i);\n\n                // Compare vectors\n                svbool_t cmp = svcmpeq_z(pg, first_vec, current_vec);\n                \n                // If any elements are different, return false\n                if (!svptest_any(pg, cmp)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            // Pointer to the current block\n            const int* current_block = matrix + (block_row * cols + block_col) * block_size;\n\n            // Compare blocks using SVE\n            for (size_t row = 0; row < block_size; ++row) {\n                svbool_t pg = svwhilelt_b32(0, block_size);\n                \n                // Load first block row\n                svint32_t first_vec = svld1_z(pg, first_block + row * cols);\n                \n                // Load current block row\n                svint32_t current_vec = svld1_z(pg, current_block + row * cols);\n                \n                // Compare vectors\n                svbool_t eq_mask = svcmpeq_z(pg, first_vec, current_vec);\n                \n                // If any elements are not equal, return false\n                if (!svptest_any(pg, eq_mask)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size or matrix dimensions\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Pointer to the first block\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 1; block_row < block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < block_cols; ++block_col) {\n            // Pointer to the current block\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // SVE vector comparison\n            svbool_t pg = svptrue_b32();\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += svcntw()) {\n                    svint32_t first_vec = svld1(pg, first_block + i * block_size + j);\n                    svint32_t current_vec = svld1(pg, current_block + i * block_size + j);\n                    \n                    // Compare vectors\n                    svbool_t comparison = svcmpeq(pg, first_vec, current_vec);\n                    \n                    // If any elements are not equal, return false\n                    if (!svptest_any(pg, comparison)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    // Get first block as reference\n    const int* first_block = matrix;\n\n    // Iterate through all blocks and compare with first block\n    for (size_t block_row = 1; block_row < num_block_rows; ++block_row) {\n        for (size_t block_col = 0; block_col < num_block_cols; ++block_col) {\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            // Use SVE to compare blocks\n            svbool_t pg = svptrue_b32();\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += svcntw()) {\n                    svint32_t first_vec = svld1_s32(pg, first_block + i * cols + j);\n                    svint32_t current_vec = svld1_s32(pg, current_block + i * cols + j);\n                    \n                    svbool_t eq_mask = svcmpeq_s32(pg, first_vec, current_vec);\n                    if (!svptest_any(pg, eq_mask)) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Get SVE vector length for doubles\n    size_t sve_vec_len = svcntd();\n\n    // Load first block as reference\n    svbool_t pg = svptrue_b64();\n    svfloat64_t ref_block = svld1_f64(pg, vec);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        svfloat64_t current_block = svld1_f64(pg, vec + block * block_size);\n        \n        // Compare absolute difference against tolerance\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, current_block, ref_block));\n        svbool_t tolerance_mask = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n        \n        // If any element exceeds tolerance, return false\n        if (svptest_any(pg, tolerance_mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // SVE vector length in doubles\n    size_t vec_len = svcntd();\n\n    // Load first block as reference\n    svbool_t pg = svptrue_b64();\n    svfloat64_t ref_block = svld1_f64(pg, vec);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_blocks; ++block) {\n        const double* current_block = vec + block * block_size;\n        \n        // Compare each vector-sized chunk within the block\n        for (size_t i = 0; i + vec_len <= block_size; i += vec_len) {\n            svfloat64_t current_vec = svld1_f64(pg, current_block + i);\n            \n            // Compute absolute difference\n            svfloat64_t abs_diff = svabs_f64_z(pg, svsub_f64_z(pg, current_vec, ref_block));\n            \n            // Check if any difference exceeds tolerance\n            svbool_t tolerance_mask = svcmpgt_f64(pg, abs_diff, svdup_f64(tolerance));\n            \n            // If any element differs beyond tolerance, return false\n            if (svptest_any(pg, tolerance_mask)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Get SVE vector length for doubles\n    size_t vec_len = svcntd();\n\n    // Load first block as reference\n    svbool_t pg = svptrue_b64();\n    svfloat64_t ref_block = svld1_f64(pg, vec);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        const double* current_block_ptr = vec + block * block_size;\n        \n        // Compare each vector-sized chunk within the block\n        for (size_t offset = 0; offset < block_size; offset += vec_len) {\n            size_t remaining = block_size - offset;\n            svbool_t pred = svwhilelt_b64_u64(0, remaining);\n            \n            svfloat64_t current_vec = svld1_f64(pred, current_block_ptr + offset);\n            svfloat64_t diff = svabs_f64_z(pred, svsub_f64_z(pred, current_vec, ref_block));\n            \n            // Check if any element exceeds tolerance\n            if (svptest_any(pred, svcmpgt_f64(pred, diff, tolerance))) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Get SVE vector length for doubles\n    size_t vec_len = svcntd();\n\n    // Load first block as reference\n    svbool_t pg = svptrue_b64();\n    svfloat64_t ref_block = svld1_f64(pg, vec);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        svfloat64_t current_block = svld1_f64(pg, vec + block * block_size);\n        \n        // Compare absolute difference against tolerance\n        svfloat64_t diff = svabs_f64_z(pg, svfsub_f64_z(pg, current_block, ref_block));\n        svbool_t tolerance_mask = svcmpgt_f64(pg, diff, tolerance);\n        \n        // If any element exceeds tolerance, return false\n        if (svptest_any(pg, tolerance_mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Get SVE vector length for doubles\n    size_t vec_len = svcntd();\n\n    // Load first block as reference\n    svbool_t pg = svptrue_b64();\n    svfloat64_t ref_block = svld1_f64(pg, vec);\n\n    // Iterate through subsequent blocks\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        svfloat64_t current_block = svld1_f64(pg, vec + block * block_size);\n        \n        // Compare absolute difference against tolerance\n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, ref_block, current_block));\n        svbool_t tolerance_mask = svcmpgt_f64(pg, diff, tolerance);\n        \n        // If any element exceeds tolerance, return false\n        if (svptest_any(pg, tolerance_mask)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t r = 0; r < rows; r++) {\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t row_sum_sq = svdup_f64(0.0);\n\n        for (size_t c = 0; c < cols; c += svcntd()) {\n            svfloat64_t vec_data = svld1_f64(pg, matrix + r * cols + c);\n            svfloat64_t sq_vec = svmul_f64_z(pg, vec_data, vec_data);\n            row_sum_sq = svadd_f64_z(pg, row_sum_sq, sq_vec);\n            pg = svwhilelt_b64(c + svcntd(), cols);\n        }\n\n        float64_t row_norm = svqadd_f64(svreduce_f64(row_sum_sq));\n        result[r] = (sqrt(row_norm) > thresholds[r]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t row = 0; row < rows; ++row) {\n        svfloat64_t row_sum_sq = svdup_f64(0.0);\n        const double* row_ptr = matrix + row * cols;\n\n        // Process matrix row in SVE vector chunks\n        for (size_t col = 0; col < cols; col += svcntd()) {\n            svbool_t pg = svwhilelt_b64(col, cols);\n            svfloat64_t vec_data = svld1_f64(pg, row_ptr + col);\n            svfloat64_t vec_sq = svmul_f64_z(pg, vec_data, vec_data);\n            row_sum_sq = svadd_f64_z(pg, row_sum_sq, vec_sq);\n        }\n\n        // Reduce vector sum of squares to scalar\n        double norm = sqrt(svaddv_f64(svptrue_b64(), row_sum_sq));\n\n        // Compare norm with threshold\n        result[row] = norm > thresholds[row];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t row = 0; row < rows; row++) {\n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t row_norm_sq = svdup_f64(0.0);\n\n        for (size_t col = 0; col < cols; col += svcntd()) {\n            svfloat64_t vec = svld1_f64(pg, matrix + row * cols + col);\n            svfloat64_t squared = svmul_f64_z(pg, vec, vec);\n            row_norm_sq = svadd_f64_z(pg, row_norm_sq, squared);\n            pg = svwhilelt_b64(col + svcntd(), cols);\n        }\n\n        svfloat64_t row_norm = svsqrt_f64_z(svptrue_b64(), row_norm_sq);\n        svfloat64_t threshold = svld1_f64(svptrue_b64(), thresholds + row);\n        svbool_t compare = svcmpgt_f64(svptrue_b64(), row_norm, threshold);\n        result[row] = svptest_any(svptrue_b64(), compare);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t row = 0; row < rows; ++row) {\n        svfloat64_t row_sum_sq = svdup_f64(0.0);\n        const double* row_ptr = matrix + row * cols;\n\n        // Process matrix row in SVE vector chunks\n        for (size_t col = 0; col < cols; col += svcntd()) {\n            svbool_t pg = svwhilelt_b64(col, cols);\n            svfloat64_t vec_data = svld1_f64(pg, row_ptr + col);\n            svfloat64_t squared_vec = svmul_f64_z(pg, vec_data, vec_data);\n            row_sum_sq = svadd_f64_z(pg, row_sum_sq, squared_vec);\n        }\n\n        // Reduce vector sum of squares to scalar\n        double row_norm = sqrt(svaddv_f64(svptrue_b64(), row_sum_sq));\n\n        // Compare with threshold\n        result[row] = row_norm > thresholds[row];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t row = 0; row < rows; ++row) {\n        svfloat64_t row_sum_vec = svdup_f64(0.0);\n        \n        // Process matrix row in SVE vector chunks\n        for (size_t col = 0; col < cols; col += svcntd()) {\n            svbool_t pg = svwhilelt_b64(col, cols);\n            svfloat64_t vec = svld1_f64(pg, matrix + row * cols + col);\n            svfloat64_t squared_vec = svmul_f64_z(pg, vec, vec);\n            row_sum_vec = svadd_f64_z(pg, row_sum_vec, squared_vec);\n        }\n        \n        // Reduce vector sum to scalar\n        double row_norm = sqrt(svaddv_f64(svptrue_b64(), row_sum_vec));\n        \n        // Compare with threshold\n        result[row] = row_norm > thresholds[row];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of active elements for this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vectors from A and B with predication\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        \n        // Perform bitwise OR operation\n        svuint32_t vc = svorr_u32(pg, va, vb);\n        \n        // Store the result in C with predication\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vectors from A and B\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        \n        // Perform bitwise OR operation\n        svuint32_t vc = svorr_u32(pg, va, vb);\n        \n        // Store result in C\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vectors from A and B\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        \n        // Perform bitwise OR operation\n        svuint32_t vc = svorr_u32(pg, va, vb);\n        \n        // Store result in C\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Create predicate for handling vector and potential partial vector at end\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vector elements from A and B\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        \n        // Perform bitwise OR operation\n        svuint32_t vc = svorr_u32(pg, va, vb);\n        \n        // Store result in C\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load vectors from A and B\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        \n        // Perform bitwise OR\n        svuint32_t vc = svorr_u32(pg, va, vb);\n        \n        // Store result in C\n        svst1_u32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    svbool_t pg = svptrue_b8();\n    \n    for (size_t i = 0; i < length; i += svcntb()) {\n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svint16_t va_wide = svreinterpret_s16_s8(va);\n        svint16_t vb_wide = svreinterpret_s16_s8(vb);\n        \n        svint16_t squares = svmul_s16_z(pg, va_wide, va_wide);\n        svint16_t products = svmul_s16_z(pg, va_wide, vb_wide);\n        \n        sum_squares += svaddv_s16(pg, squares);\n        sum_products += svaddv_s16(pg, products);\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svint16_t va_wide = svreinterpret_s16_s8(va);\n        svint16_t vb_wide = svreinterpret_s16_s8(vb);\n        \n        svint16_t squares = svmul_s16_z(pg, va_wide, va_wide);\n        svint16_t products = svmul_s16_z(pg, va_wide, vb_wide);\n        \n        sum_squares += svaddv_s16(pg, squares);\n        sum_products += svaddv_s16(pg, products);\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svint16_t va_wide = svmovl_s8(va);\n        svint16_t vb_wide = svmovl_s8(vb);\n        \n        svint16_t squares = svmul_s16_z(pg, va_wide, va_wide);\n        svint16_t products = svmul_s16_z(pg, va_wide, vb_wide);\n        \n        sum_squares += svaddv_s16(pg, squares);\n        sum_products += svaddv_s16(pg, products);\n    }\n    \n    return sum_squares - (2 * sum_products);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svint16_t va_wide = svwiden_s8(va);\n        svint16_t vb_wide = svwiden_s8(vb);\n        \n        svint16_t squares = svmul_s16_z(pg, va_wide, va_wide);\n        svint16_t products = svmul_s16_z(pg, va_wide, vb_wide);\n        \n        sum_squares += svaddv_s16(pg, squares);\n        sum_products += svaddv_s16(pg, products);\n    }\n    \n    return sum_squares - (2 * sum_products);\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    // Determine SVE vector length for int8_t\n    size_t vector_length = svcntb();\n    \n    // Process vectors in SVE chunks\n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        // Load vectors with predication\n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        // Compute squares\n        svint16_t va_squared = svmul_s16_z(pg, va, va);\n        svint16_t vb_squared = svmul_s16_z(pg, vb, vb);\n        \n        // Compute products\n        svint16_t vproducts = svmul_s16_z(pg, va, vb);\n        \n        // Reduce squares\n        sum_squares += svaddv_s16(pg, va_squared);\n        sum_squares += svaddv_s16(pg, vb_squared);\n        \n        // Reduce products\n        sum_products += svaddv_s16(pg, vproducts);\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        \n        svuint64_t vb_negated = svnot_u64_z(pg, vb);\n        svuint64_t vc = svand_u64_z(pg, va, vb_negated);\n        \n        svst1_u64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load vectors from A and B\n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        \n        // Perform bitwise NOT on B and then bitwise AND with A\n        svuint64_t vb_not = svnot_u64_z(pg, vb);\n        svuint64_t vc = svand_u64_z(pg, va, vb_not);\n        \n        // Store the result in C\n        svst1_u64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        \n        svuint64_t vb_negated = svnot_u64_z(pg, vb);\n        svuint64_t vc = svand_u64_z(pg, va, vb_negated);\n        \n        svst1_u64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load vectors from A and B\n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        \n        // Perform bitwise NOT on B\n        svuint64_t vb_not = svnot_u64_z(pg, vb);\n        \n        // Perform bitwise AND between A and NOT(B)\n        svuint64_t vc = svand_u64_z(pg, va, vb_not);\n        \n        // Store the result in C\n        svst1_u64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vector_length = svcntd(); // Number of 64-bit elements in a vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, length);\n        \n        // Load vectors from A and B\n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        \n        // Perform bitwise NOT on B and then bitwise AND with A\n        svuint64_t vb_not = svnot_u64_z(pg, vb);\n        svuint64_t vc = svand_u64_z(pg, va, vb_not);\n        \n        // Store the result in C\n        svst1_u64(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svbool_t both_positive = svcmpgt_s8(pg, va, 0) & svcmpgt_s8(pg, vb, 0);\n        svbool_t both_negative = svcmplt_s8(pg, va, 0) & svcmplt_s8(pg, vb, 0);\n        \n        svint8_t result = svdup_s8_z(pg, 0);\n        result = svsel_s8(both_positive, svdup_s8_z(pg, 1), result);\n        result = svsel_s8(both_negative, svdup_s8_z(pg, -1), result);\n        \n        svst1_s8(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svbool_t pos_a = svcmpgt_s8(pg, va, svdup_s8(0));\n        svbool_t pos_b = svcmpgt_s8(pg, vb, svdup_s8(0));\n        \n        svbool_t neg_a = svcmplt_s8(pg, va, svdup_s8(0));\n        svbool_t neg_b = svcmplt_s8(pg, vb, svdup_s8(0));\n        \n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(sveor_b_z(pg, pos_a, pos_b), svdup_s8(1), result);\n        result = svsel_s8(sveor_b_z(pg, neg_a, neg_b), svdup_s8(-1), result);\n        \n        svst1_s8(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svbool_t both_positive = svcmpgt_s8(pg, va, 0) & svcmpgt_s8(pg, vb, 0);\n        svbool_t both_negative = svcmplt_s8(pg, va, 0) & svcmplt_s8(pg, vb, 0);\n        \n        svint8_t result = svdup_s8_z(pg, 0);\n        result = svsel_s8(both_positive, svdup_s8_z(pg, 1), result);\n        result = svsel_s8(both_negative, svdup_s8_z(pg, -1), result);\n        \n        svst1_s8(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svbool_t positive_a = svcmpgt_s8(pg, va, svdup_s8(0));\n        svbool_t positive_b = svcmpgt_s8(pg, vb, svdup_s8(0));\n        \n        svbool_t both_positive = svand_z(pg, positive_a, positive_b);\n        svbool_t both_negative = svand_z(pg, svcmple_s8(pg, va, svdup_s8(0)), \n                                         svcmple_s8(pg, vb, svdup_s8(0)));\n        \n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_positive, svdup_s8(1), result);\n        result = svsel_s8(both_negative, svdup_s8(-1), result);\n        \n        svst1_s8(pg, C + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n        \n        svbool_t pos_a = svcmpgt_s8(pg, va, svdup_s8(0));\n        svbool_t pos_b = svcmpgt_s8(pg, vb, svdup_s8(0));\n        svbool_t neg_a = svcmplt_s8(pg, va, svdup_s8(0));\n        svbool_t neg_b = svcmplt_s8(pg, vb, svdup_s8(0));\n        \n        svbool_t both_pos = svand_z(pg, pos_a, pos_b);\n        svbool_t both_neg = svand_z(pg, neg_a, neg_b);\n        \n        svint8_t vc = svdup_s8(0);\n        vc = svsel_s8(both_pos, svdup_s8(1), vc);\n        vc = svsel_s8(both_neg, svdup_s8(-1), vc);\n        \n        svst1_s8(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements using SVE vector operations\n    svbool_t pg = svptrue_b16();\n    size_t vector_length = svcntw();\n    \n    // Process elements before midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vector_length) {\n        size_t remaining = midpoint - i;\n        svbool_t p = svwhilelt_b16(i, midpoint);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vxor = sveor_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vxor);\n    }\n    \n    // Process midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t p = svwhilelt_b16(i, length);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vand = svand_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vand);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements before midpoint using SVE vector operations\n    for (size_t i = 0; i < midpoint; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16_u64(i, midpoint);\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n        \n        // Bitwise XOR for elements before midpoint\n        svuint16_t vxor = svxor_u16_z(pg, va, vb);\n        svst1_u16(pg, C + i, vxor);\n    }\n    \n    // Process midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint using SVE vector operations\n    for (size_t i = midpoint + 1; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b16_u64(i, length);\n        svuint16_t va = svld1_u16(pg, A + i);\n        svuint16_t vb = svld1_u16(pg, B + i);\n        \n        // Bitwise AND for elements after midpoint\n        svuint16_t vand = svand_u16_z(pg, va, vb);\n        svst1_u16(pg, C + i, vand);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements using SVE vector operations\n    svbool_t pg = svptrue_b16();\n    size_t vector_length = svcntw();\n    \n    // Process elements before midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vector_length) {\n        size_t remaining = midpoint - i;\n        svbool_t p = svwhilelt_b16_u32(i, midpoint);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vxor = sveor_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vxor);\n    }\n    \n    // Handle midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + (length % 2); i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t p = svwhilelt_b16_u32(i, length);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vand = svand_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vand);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements using SVE vector operations\n    svbool_t pg = svptrue_b16();\n    size_t vector_length = svcntw();\n    \n    // Process elements before midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vector_length) {\n        size_t remaining = midpoint - i;\n        svbool_t p = svwhilelt_b16_u64(i, midpoint);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vxor = sveor_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vxor);\n    }\n    \n    // Handle midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + 1; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t p = svwhilelt_b16_u64(i, length);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vand = svand_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vand);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Process elements using SVE vector operations\n    svbool_t pg = svptrue_b16();\n    size_t vector_length = svcntw();\n    \n    // Process elements before midpoint with XOR\n    for (size_t i = 0; i < midpoint; i += vector_length) {\n        size_t remaining = midpoint - i;\n        svbool_t p = svwhilelt_b16(i, midpoint);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vxor = sveor_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vxor);\n    }\n    \n    // Handle midpoint element\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n    \n    // Process elements after midpoint with AND\n    for (size_t i = midpoint + 1; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t p = svwhilelt_b16(i, length);\n        \n        svuint16_t va = svld1_u16(p, A + i);\n        svuint16_t vb = svld1_u16(p, B + i);\n        \n        svuint16_t vand = svand_u16_m(p, va, vb);\n        \n        svst1_u16(p, C + i, vand);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b32(k, dim3);\n            \n            do {\n                size_t base_idx = (i * dim2 + j) * dim3 + k;\n                \n                // Load condition vectors\n                svbool_t cond1_vec = svcmpne_n_u32(pg, svldnf1_u32(pg, (const uint32_t*)(cond1 + base_idx)), 0);\n                svbool_t cond2_vec = svcmpne_n_u32(pg, svldnf1_u32(pg, (const uint32_t*)(cond2 + base_idx)), 0);\n                \n                // Load input vectors\n                svfloat32_t a_vec = svldnf1_f32(pg, A + base_idx);\n                svfloat32_t b_vec = svldnf1_f32(pg, B + base_idx);\n                svfloat32_t c_vec = svldnf1_f32(pg, C + base_idx);\n                svfloat32_t d_vec = svldnf1_f32(pg, D + base_idx);\n                \n                // Combine conditions\n                svbool_t cond1_true_cond2_true = svand_z(pg, cond1_vec, cond2_vec);\n                svbool_t cond1_true_cond2_false = svand_z(pg, cond1_vec, svnot_z(pg, cond2_vec));\n                svbool_t cond1_false_cond2_true = svand_z(pg, svnot_z(pg, cond1_vec), cond2_vec);\n                svbool_t cond1_false_cond2_false = svand_z(pg, svnot_z(pg, cond1_vec), svnot_z(pg, cond2_vec));\n                \n                // Select based on conditions\n                svfloat32_t result_vec = svsel_f32(cond1_true_cond2_true, a_vec,\n                    svsel_f32(cond1_true_cond2_false, b_vec,\n                    svsel_f32(cond1_false_cond2_true, c_vec, d_vec)));\n                \n                // Store result\n                svstf1_f32(pg, out + base_idx, result_vec);\n                \n                // Update loop variables\n                k += svcntw();\n                pg = svwhilelt_b32(k, dim3);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b32(k, dim3);\n            \n            while (svptest_any(svptrue_b32(), pg)) {\n                size_t vec_size = svcntw();\n                \n                // Load condition vectors\n                svbool_t cond1_vec = svld1_b32(pg, cond1 + i * dim2 * dim3 + j * dim3 + k);\n                svbool_t cond2_vec = svld1_b32(pg, cond2 + i * dim2 * dim3 + j * dim3 + k);\n                \n                // Load input vectors\n                svfloat32_t a_vec = svld1_f32(pg, A + i * dim2 * dim3 + j * dim3 + k);\n                svfloat32_t b_vec = svld1_f32(pg, B + i * dim2 * dim3 + j * dim3 + k);\n                svfloat32_t c_vec = svld1_f32(pg, C + i * dim2 * dim3 + j * dim3 + k);\n                svfloat32_t d_vec = svld1_f32(pg, D + i * dim2 * dim3 + j * dim3 + k);\n                \n                // Combine conditions\n                svbool_t cond1_true = cond1_vec;\n                svbool_t cond2_true = cond2_vec;\n                svbool_t cond1_false = svnot_b_z(pg, cond1_vec);\n                svbool_t cond2_false = svnot_b_z(pg, cond2_vec);\n                \n                // Select based on conditions\n                svfloat32_t result_vec = \n                    svsel_f32(svcmpeq_b_z(pg, cond1_true, cond2_true), a_vec,\n                    svsel_f32(svcmpeq_b_z(pg, cond1_true, cond2_false), b_vec,\n                    svsel_f32(svcmpeq_b_z(pg, cond1_false, cond2_true), c_vec, \n                    d_vec)));\n                \n                // Store result\n                svst1_f32(pg, out + i * dim2 * dim3 + j * dim3 + k, result_vec);\n                \n                // Update loop variables\n                k += vec_size;\n                pg = svwhilelt_b32(k, dim3);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b32(k, dim3);\n            \n            while (svptest_any(svptrue_b32(), pg)) {\n                size_t vec_size = svcntw();\n                \n                // Load condition vectors\n                svbool_t cond1_vec = svld1ub_z(pg, cond1 + i * dim2 * dim3 + j * dim3 + k);\n                svbool_t cond2_vec = svld1ub_z(pg, cond2 + i * dim2 * dim3 + j * dim3 + k);\n                \n                // Load input vectors\n                svfloat32_t a_vec = svld1_z(pg, A + i * dim2 * dim3 + j * dim3 + k, vec_size);\n                svfloat32_t b_vec = svld1_z(pg, B + i * dim2 * dim3 + j * dim3 + k, vec_size);\n                svfloat32_t c_vec = svld1_z(pg, C + i * dim2 * dim3 + j * dim3 + k, vec_size);\n                svfloat32_t d_vec = svld1_z(pg, D + i * dim2 * dim3 + j * dim3 + k, vec_size);\n                \n                // Combine conditions\n                svbool_t cond1_and_cond2 = svand_z(pg, cond1_vec, cond2_vec);\n                svbool_t not_cond1_and_cond2 = svand_z(pg, svnot_z(pg, cond1_vec), cond2_vec);\n                svbool_t cond1_and_not_cond2 = svand_z(pg, cond1_vec, svnot_z(pg, cond2_vec));\n                svbool_t not_cond1_and_not_cond2 = svand_z(pg, svnot_z(pg, cond1_vec), svnot_z(pg, cond2_vec));\n                \n                // Select values based on conditions\n                svfloat32_t result_vec = \n                    svorr_z(pg, \n                        svorr_z(pg, \n                            svsel_f32(cond1_and_cond2, a_vec, b_vec),\n                            svsel_f32(not_cond1_and_cond2, c_vec, d_vec)\n                        )\n                    );\n                \n                // Store result\n                svst1_z(pg, out + i * dim2 * dim3 + j * dim3 + k, result_vec);\n                \n                // Update loop variables\n                k += vec_size;\n                pg = svwhilelt_b32(k, dim3);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b32(k, dim3);\n            \n            while (svptest_any(svptrue_b32(), pg)) {\n                size_t vec_size = svcntw();\n                \n                // Load condition vectors\n                svbool_t cond1_vec = svld1ub_z(pg, cond1 + i*dim2*dim3 + j*dim3 + k);\n                svbool_t cond2_vec = svld1ub_z(pg, cond2 + i*dim2*dim3 + j*dim3 + k);\n                \n                // Load input vectors\n                svfloat32_t a_vec = svld1_z(pg, A + i*dim2*dim3 + j*dim3 + k, vec_size);\n                svfloat32_t b_vec = svld1_z(pg, B + i*dim2*dim3 + j*dim3 + k, vec_size);\n                svfloat32_t c_vec = svld1_z(pg, C + i*dim2*dim3 + j*dim3 + k, vec_size);\n                svfloat32_t d_vec = svld1_z(pg, D + i*dim2*dim3 + j*dim3 + k, vec_size);\n                \n                // Combine conditions\n                svbool_t cond1_true = cond1_vec;\n                svbool_t cond2_true = cond2_vec;\n                \n                // Select based on conditions\n                svfloat32_t result_vec = svsel(sveor_z(pg, cond1_true, cond2_true), \n                                               svsel(cond1_true, a_vec, c_vec),\n                                               svsel(cond1_true, b_vec, d_vec));\n                \n                // Store result\n                svst1_z(pg, out + i*dim2*dim3 + j*dim3 + k, result_vec);\n                \n                // Update loop variables\n                k += vec_size;\n                pg = svwhilelt_b32(k, dim3);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            size_t k = 0;\n            svbool_t pg = svwhilelt_b32(k, dim3);\n            \n            do {\n                size_t base_idx = (i * dim2 + j) * dim3 + k;\n                \n                // Load condition masks\n                svbool_t cond1_mask = svcmpne_n_u32(pg, svldnf1_u32(pg, (const uint32_t*)(cond1 + base_idx)), 0);\n                svbool_t cond2_mask = svcmpne_n_u32(pg, svldnf1_u32(pg, (const uint32_t*)(cond2 + base_idx)), 0);\n                \n                // Load input tensors\n                svfloat32_t a_vec = svldnf1_f32(pg, A + base_idx);\n                svfloat32_t b_vec = svldnf1_f32(pg, B + base_idx);\n                svfloat32_t c_vec = svldnf1_f32(pg, C + base_idx);\n                svfloat32_t d_vec = svldnf1_f32(pg, D + base_idx);\n                \n                // Combine conditions\n                svbool_t cond1_true_cond2_true = svand_z(pg, cond1_mask, cond2_mask);\n                svbool_t cond1_true_cond2_false = svand_z(pg, cond1_mask, svnot_z(pg, cond2_mask));\n                svbool_t cond1_false_cond2_true = svand_z(pg, svnot_z(pg, cond1_mask), cond2_mask);\n                svbool_t cond1_false_cond2_false = svand_z(pg, svnot_z(pg, cond1_mask), svnot_z(pg, cond2_mask));\n                \n                // Select based on conditions\n                svfloat32_t result = svsel_f32(cond1_true_cond2_true, a_vec,\n                    svsel_f32(cond1_true_cond2_false, b_vec,\n                        svsel_f32(cond1_false_cond2_true, c_vec, d_vec)));\n                \n                // Store result\n                svstf1_f32(pg, out + base_idx, result);\n                \n                // Update loop variables\n                k += svcntw();\n                pg = svwhilelt_b32(k, dim3);\n            } while (svptest_any(svptrue_b32(), pg));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for uint32_t\n    size_t vec_len = svcntw();\n    \n    size_t i = 0;\n    // Process vector-sized chunks\n    for (; i + vec_len <= total_elements; i += vec_len) {\n        // Load vector of uint32_t\n        svuint32_t vec_a = svld1_u32(svptrue_b32(), A + i);\n        \n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b32_u64(i, total_elements);\n        \n        // Count bits set in each element\n        svuint32_t bit_counts = svcnt_u32_z(pg, vec_a);\n        \n        // Convert to uint8_t and store\n        svst1_u8(pg, out + i, svqmovn_u32(bit_counts));\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        uint32_t val = A[i];\n        out[i] = __builtin_popcount(val);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for uint32_t\n    size_t vec_len = svcntw();\n    \n    size_t i = 0;\n    // Process vector-sized chunks\n    for (; i + vec_len <= total_elements; i += vec_len) {\n        // Load vector of uint32_t\n        svuint32_t vec = svld1_u32(svptrue_b32(), A + i);\n        \n        // Create predicate for active lanes\n        svbool_t pg = svwhilelt_b32_u64(i, total_elements);\n        \n        // Count bits set in each element\n        svuint32_t bit_counts = svcnt_u32_z(pg, vec);\n        \n        // Convert to uint8_t and store\n        svst1_u8(pg, out + i, svqmovn_u32(bit_counts));\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        uint32_t val = A[i];\n        out[i] = __builtin_popcount(val);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for 32-bit elements\n    size_t vector_length = svcntw();\n    \n    size_t i = 0;\n    // Process elements in SVE vector chunks\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        // Load vector of 32-bit unsigned integers\n        svuint32_t vec_a = svld1_u32(svptrue_b32(), A + i);\n        \n        // Create vector to store bit count results\n        svuint8_t vec_out = svdup_u8(0);\n        \n        // Iterate through each bit position\n        for (int bit = 0; bit < 32; bit++) {\n            // Create mask for current bit\n            svbool_t bit_mask = svcmpeq_n_u32(svand_u32_z(svptrue_b32(), vec_a, 1U << bit), 1U << bit);\n            \n            // Increment bit count where bit is set\n            vec_out = svadd_u8_z(svptrue_b8(), vec_out, svreinterpret_u8_u32(svcntp_b32_u32(bit_mask)));\n        }\n        \n        // Store results back to output tensor\n        svst1_u8(svptrue_b8(), out + i, vec_out);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t bit_count = 0;\n        \n        while (value) {\n            bit_count += value & 1;\n            value >>= 1;\n        }\n        \n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for 32-bit elements\n    size_t vector_length = svcntw();\n    \n    size_t i = 0;\n    // Process elements in SVE vector chunks\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        // Load vector of 32-bit unsigned integers\n        svuint32_t vec_a = svld1_u32(svptrue_b32(), A + i);\n        \n        // Initialize vector to store bit counts\n        svuint32_t bit_counts = svdup_u32(0);\n        \n        // Iterate through each bit position\n        for (int bit = 0; bit < 32; bit++) {\n            // Create mask for current bit\n            svuint32_t bit_mask = svdup_u32(1U << bit);\n            \n            // Check if bit is set\n            svbool_t bit_set = svcmpeq_u32(svptrue_b32(), \n                                            svand_u32_z(svptrue_b32(), vec_a, bit_mask), \n                                            bit_mask);\n            \n            // Increment bit count for set bits\n            bit_counts = svAdd_u32_z(bit_set, bit_counts, svdup_u32(1));\n        }\n        \n        // Convert 32-bit bit counts to 8-bit\n        svuint8_t bit_counts_8 = svqmovn_u32(bit_counts);\n        \n        // Store results\n        svst1_u8(svptrue_b8(), out + i, bit_counts_8);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        uint32_t num = A[i];\n        uint8_t count = 0;\n        \n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        \n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    // Determine SVE vector length for 32-bit elements\n    size_t vector_length = svcntw();\n    \n    size_t i = 0;\n    // Process vector-sized chunks\n    for (; i + vector_length <= total_elements; i += vector_length) {\n        // Load vector of 32-bit integers\n        svuint32_t vec = svld1_u32(svptrue_b32(), A + i);\n        \n        // Initialize output vector\n        svuint8_t bit_count_vec = svdup_u8(0);\n        \n        // Iterate through bits (0-31)\n        for (int bit = 0; bit < 32; bit++) {\n            // Check if each bit is set\n            svbool_t bit_mask = svcmpeq_n_u32(svptrue_b32(), \n                                               svand_u32_z(svptrue_b32(), \n                                                          vec, \n                                                          svdup_u32(1U << bit)), \n                                               svdup_u32(1U << bit));\n            \n            // Add 1 to bit count where bit is set\n            bit_count_vec = svadd_u8_z(svptrue_b8(), \n                                        bit_count_vec, \n                                        svreinterpret_u8_u32(svsel_u32(bit_mask, \n                                                                       svdup_u32(1), \n                                                                       svdup_u32(0))));\n        }\n        \n        // Store bit count results\n        svst1_u8(svptrue_b8(), out + i, bit_count_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < total_elements; i++) {\n        uint32_t val = A[i];\n        uint8_t bit_count = 0;\n        for (int bit = 0; bit < 32; bit++) {\n            if (val & (1U << bit)) {\n                bit_count++;\n            }\n        }\n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process vector-width chunks\n        for (; c + svcntw() <= cols; c += svcntw()) {\n            // Load vector of integers from input matrix\n            svint32_t vec_a = svld1_s32(svptrue_b32(), A + r * cols + c);\n            \n            // Create predicate for elements divisible by 3\n            svbool_t pred = svcmpeq_s32(svptrue_b32(), \n                                        svmod_s32_z(svptrue_b32(), vec_a, 3), \n                                        svdup_s32(0));\n            \n            // Take absolute value where divisible by 3, keep original otherwise\n            svint32_t vec_b = svabs_s32_z(pred, vec_a);\n            \n            // Store result back to destination matrix\n            svst1_s32(svptrue_b32(), B + r * cols + c, vec_b);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            int val = A[r * cols + c];\n            B[r * cols + c] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process vector-width chunks\n        for (; c + svcntw() <= cols; c += svcntw()) {\n            // Load vector of integers from input matrix\n            svint32_t vec_a = svld1_s32(svptrue_b32(), A + r * cols + c);\n            \n            // Create predicate for elements divisible by 3\n            svbool_t pred = svcmpeq_n_s32(svptrue_b32(), svmod_n_s32_z(svptrue_b32(), vec_a, 3), 0);\n            \n            // Compute absolute values for elements divisible by 3\n            svint32_t vec_abs = svabs_s32_z(pred, vec_a);\n            \n            // Blend original values and absolute values based on predicate\n            svint32_t result = svsel_s32(pred, vec_abs, vec_a);\n            \n            // Store result back to destination matrix\n            svst1_s32(svptrue_b32(), B + r * cols + c, result);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            int val = A[r * cols + c];\n            B[r * cols + c] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process vector-width chunks\n        for (; c + svcntw() <= cols; c += svcntw()) {\n            // Load vector of integers\n            svint32_t vec_a = svld1_s32(svptrue_b32(), A + r * cols + c);\n            \n            // Create predicate for elements divisible by 3\n            svbool_t pred = svcmpeq_s32(svptrue_b32(), \n                                        svmod_s32_z(svptrue_b32(), vec_a, 3), \n                                        svdup_s32(0));\n            \n            // Take absolute value where divisible by 3\n            svint32_t vec_b = svabs_s32_z(pred, vec_a);\n            \n            // Where not divisible by 3, keep original value\n            vec_b = svsel_s32(svnot_b_z(pred), vec_a, vec_b);\n            \n            // Store result vector\n            svst1_s32(svptrue_b32(), B + r * cols + c, vec_b);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            int val = A[r * cols + c];\n            B[r * cols + c] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process vector-length chunks\n        for (; c + svcntw() <= cols; c += svcntw()) {\n            // Load vector of integers from input matrix\n            svint32_t vec_a = svld1_s32(svptrue_b32(), A + r * cols + c);\n            \n            // Create predicate for elements divisible by 3\n            svbool_t pred = svcmpeq_s32(svptrue_b32(), \n                                        svmod_s32_z(svptrue_b32(), vec_a, 3), \n                                        svdup_s32(0));\n            \n            // Take absolute value where divisible by 3, otherwise keep original\n            svint32_t vec_b = svsel_s32(pred, \n                                        svabs_s32_z(pred, vec_a), \n                                        vec_a);\n            \n            // Store result vector to destination matrix\n            svst1_s32(svptrue_b32(), B + r * cols + c, vec_b);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            int val = A[r * cols + c];\n            B[r * cols + c] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        size_t c = 0;\n        \n        // Process vector-sized chunks\n        for (; c + svcntw() <= cols; c += svcntw()) {\n            // Load vector of integers from input matrix\n            svint32_t vec_a = svld1_s32(svptrue_b32(), A + r * cols + c);\n            \n            // Create predicate for elements divisible by 3\n            svbool_t pred = svcmpeq_n_s32(svptrue_b32(), svmod_n_s32_z(svptrue_b32(), vec_a, 3), 0);\n            \n            // Compute absolute values for elements divisible by 3\n            svint32_t abs_vec = svabs_s32_z(pred, vec_a);\n            \n            // Blend original and absolute values based on predicate\n            svint32_t result = svsel_s32(pred, abs_vec, vec_a);\n            \n            // Store result back to destination matrix\n            svst1_s32(svptrue_b32(), B + r * cols + c, result);\n        }\n        \n        // Handle remaining elements\n        for (; c < cols; c++) {\n            int val = A[r * cols + c];\n            B[r * cols + c] = (val % 3 == 0) ? abs(val) : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Check condition: low 4 bits are all 1\n        svuint32_t low_bits_mask = svdup_u32_z(pg, 0x0000000F);\n        svuint32_t low_bits = svand_u32_z(pg, src_vec, low_bits_mask);\n        svbool_t condition = svcmpeq_u32(pg, low_bits, low_bits_mask);\n        \n        // Rotate elements where condition is true\n        svuint32_t rotated_vec = svror_u32_z(condition, src_vec, rotate_bits);\n        \n        // Bitwise negate elements where condition is false\n        svuint32_t negated_vec = svbic_u32_z(svnot_u32_z(pg, src_vec), condition);\n        \n        // Combine rotated and negated vectors\n        svuint32_t result_vec = svsel_u32(condition, rotated_vec, negated_vec);\n        \n        // Store result\n        svst1_u32(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Check if low 4 bits are all 1\n        svuint32_t low_4_bits_mask = svdup_u32(0xF);\n        svuint32_t low_4_bits = svand_u32_x(pg, src_vec, low_4_bits_mask);\n        svbool_t condition = svcmpeq_u32(pg, low_4_bits, low_4_bits_mask);\n        \n        // Rotate elements where condition is true\n        svuint32_t rotated_vec = svror_u32_x(pg, src_vec, rotate_bits);\n        \n        // Bitwise negate elements where condition is false\n        svuint32_t negated_vec = svnot_u32_x(pg, src_vec);\n        \n        // Select between rotated and negated based on condition\n        svuint32_t result_vec = svsel_u32(condition, rotated_vec, negated_vec);\n        \n        // Store result\n        svst1_u32(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load source vector\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Check condition: low 4 bits are all 1\n        svuint32_t low_4_bits_mask = svdup_u32_z(pg, 0xF);\n        svuint32_t low_4_bits = svand_u32_z(pg, src_vec, low_4_bits_mask);\n        svbool_t condition = svcmpeq_u32(pg, low_4_bits, low_4_bits_mask);\n        \n        // Rotate elements that meet the condition\n        svuint32_t rotated_vec = svror_u32_z(pg, src_vec, rotate_bits);\n        \n        // Bitwise negate elements that do not meet the condition\n        svuint32_t negated_vec = svnot_u32_z(pg, src_vec);\n        \n        // Select between rotated and negated based on condition\n        svuint32_t result_vec = svsel_u32(condition, rotated_vec, negated_vec);\n        \n        // Store result\n        svst1_u32(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Check condition: low 4 bits are all 1\n        svuint32_t low_4_bits_mask = svdup_u32_z(pg, 0xF);\n        svuint32_t low_4_bits = svand_u32_z(pg, src_vec, low_4_bits_mask);\n        svbool_t condition = svcmpeq_u32(pg, low_4_bits, low_4_bits_mask);\n        \n        // Rotate elements where condition is true\n        svuint32_t rotated_vec = svror_u32_z(condition, src_vec, rotate_bits);\n        \n        // Bitwise negate elements where condition is false\n        svuint32_t negated_vec = svnot_u32_z(svnot_b_z(pg, condition), src_vec);\n        \n        // Combine results based on condition\n        svuint32_t result_vec = svsel_u32(condition, rotated_vec, negated_vec);\n        \n        // Store result vector\n        svst1_u32(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Check condition: low 4 bits are all 1\n        svuint32_t low_4_bits_mask = svdup_u32_z(pg, 0xF);\n        svuint32_t low_4_bits = svand_u32_z(pg, src_vec, low_4_bits_mask);\n        svbool_t condition = svcmpeq_u32(pg, low_4_bits, low_4_bits_mask);\n        \n        // Rotate elements that meet the condition\n        svuint32_t rotated_vec = svror_u32_z(condition, src_vec, rotate_bits);\n        \n        // Bitwise negate elements that do not meet the condition\n        svuint32_t negated_vec = svnot_u32_z(svnot_b_z(pg, condition), src_vec);\n        \n        // Combine results based on condition\n        svuint32_t result_vec = svsel_u32(condition, rotated_vec, negated_vec);\n        \n        // Store result vector\n        svst1_u32(pg, dst + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pred = svwhilelt_b32_u64(i, length);\n        \n        svfloat32_t va = svld1_f32(pred, A + i);\n        svfloat32_t vb = svld1_f32(pred, B + i);\n        \n        svfloat32_t diff = svsub_f32_x(pred, va, vb);\n        svfloat32_t abs_diff = svabs_f32_x(pred, diff);\n        svfloat32_t abs_eps = svdup_f32(fabsf(epsilon));\n        \n        svint8_t result = svdup_s8(0);\n        \n        svbool_t gt_mask = svcmpgt_f32(pred, diff, abs_eps);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        \n        svbool_t lt_mask = svcmplt_f32(pred, diff, svneg_f32_x(pred, abs_eps));\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pred, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vector_length = svcntw();\n\n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine active lanes\n        svbool_t active_lanes = svwhilelt_b32(i, length);\n\n        // Load vectors from A and B\n        svfloat32_t va = svld1_f32(active_lanes, A + i);\n        svfloat32_t vb = svld1_f32(active_lanes, B + i);\n\n        // Compute absolute difference\n        svfloat32_t vdiff = svsub_f32_z(active_lanes, va, vb);\n        svfloat32_t vabs_diff = svabs_f32_z(active_lanes, vdiff);\n\n        // Compare with epsilon\n        svbool_t gt_epsilon = svcmpgt_f32(active_lanes, vabs_diff, svdup_f32(fabsf(epsilon)));\n        svbool_t lt_neg_epsilon = svcmplt_f32(active_lanes, vdiff, svdup_f32(-fabsf(epsilon)));\n        svbool_t within_epsilon = svnot_b_z(pg, svorr_b_z(pg, gt_epsilon, lt_neg_epsilon));\n\n        // Create result vector\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(gt_epsilon, svdup_s8(1), result);\n        result = svsel_s8(lt_neg_epsilon, svdup_s8(-1), result);\n\n        // Store result\n        svst1_s8(active_lanes, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        // Determine active lanes\n        svbool_t active_lanes = svwhilelt_b32(i, length);\n        \n        // Load vectors from A and B\n        svfloat32_t vec_A = svld1_f32(active_lanes, A + i);\n        svfloat32_t vec_B = svld1_f32(active_lanes, B + i);\n        \n        // Compute A - B\n        svfloat32_t diff = svsub_f32_z(active_lanes, vec_A, vec_B);\n        \n        // Compute absolute epsilon\n        svfloat32_t abs_epsilon = svdup_f32(fabsf(epsilon));\n        \n        // Compare diff > abs(epsilon)\n        svbool_t gt_mask = svcmpgt_f32(active_lanes, diff, abs_epsilon);\n        \n        // Compare diff < -abs(epsilon)\n        svbool_t lt_mask = svcmplt_f32(active_lanes, diff, svneg_f32_z(active_lanes, abs_epsilon));\n        \n        // Create result vector\n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n        \n        // Store result\n        svst1_s8(active_lanes, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t pred = svwhilelt_b32_u32(i, length);\n        \n        svfloat32_t va = svld1_f32(pred, A + i);\n        svfloat32_t vb = svld1_f32(pred, B + i);\n        \n        svfloat32_t diff = svsub_f32_x(pred, va, vb);\n        svfloat32_t abs_diff = svabs_f32_x(pred, diff);\n        svfloat32_t abs_eps = svdup_f32(fabsf(epsilon));\n        \n        svint8_t result = svdup_s8(0);\n        \n        svbool_t gt_mask = svcmpgt_f32(pred, diff, abs_eps);\n        result = svsel_s8(gt_mask, svdup_s8(1), result);\n        \n        svbool_t lt_mask = svcmplt_f32(pred, diff, svneg_f32_x(pred, abs_eps));\n        result = svsel_s8(lt_mask, svdup_s8(-1), result);\n        \n        svst1_s8(pred, out + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg = svptrue_b32();\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        size_t remaining = length - i;\n        svbool_t p = svwhilelt_b32_u32(i, length);\n        \n        svfloat32_t va = svld1_f32(p, A + i);\n        svfloat32_t vb = svld1_f32(p, B + i);\n        \n        svfloat32_t vdiff = svsub_f32_x(p, va, vb);\n        svfloat32_t vabs_diff = svabs_f32_x(p, vdiff);\n        svfloat32_t vabs_eps = svdup_f32(fabsf(epsilon));\n        \n        svint8_t vout = svdup_s8(0);\n        \n        svbool_t gt_mask = svcmpgt_f32(p, vdiff, vabs_eps);\n        svbool_t lt_mask = svcmplt_f32(p, vdiff, svneg_f32_x(p, vabs_eps));\n        \n        vout = svsel_s8(gt_mask, svdup_s8(1), vout);\n        vout = svsel_s8(lt_mask, svdup_s8(-1), vout);\n        \n        svst1_s8(p, out + i, vout);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load float vector\n        svfloat32_t float_vec = svld1_f32(pg, A + i);\n        \n        // Convert float to int32 with saturation\n        svint32_t int_vec = svcvt_s32_f32_z(pg, float_vec);\n        \n        // Store result\n        svst1_s32(pg, B + i, int_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load float vector\n        svfloat32_t float_vec = svld1_f32(pg, A + i);\n        \n        // Convert float to int32 with saturation\n        svint32_t int_vec = svcvt_s32_f32_z(pg, float_vec);\n        \n        // Store result vector\n        svst1_s32(pg, B + i, int_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load float vector\n        svfloat32_t float_vec = svld1_f32(pg, A + i);\n        \n        // Convert float to int with saturation\n        svint32_t int_vec = svcvt_s32_f32_z(pg, float_vec);\n        \n        // Store the converted vector\n        svst1_s32(pg, B + i, int_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load float vector\n        svfloat32_t float_vec = svld1_f32(pg, A + i);\n        \n        // Convert float to int with saturation\n        svint32_t int_vec = svcvt_s32_f32_z(pg, float_vec);\n        \n        // Store result\n        svst1_s32(pg, B + i, int_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load float vector\n        svfloat32_t float_vec = svld1_f32(pg, A + i);\n        \n        // Convert float to int with saturation\n        svint32_t int_vec = svcvt_s32_f32_z(pg, float_vec);\n        \n        // Store result vector\n        svst1_s32(pg, B + i, int_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_size = svcntw(); // Number of float elements in an SVE vector\n    \n    // Broadcast the scale factor to a vector\n    svfloat32_t scale_vec = svdup_n_f32((float)scale);\n    \n    for (size_t i = 0; i < size; i += vector_size) {\n        // Create predicate to handle partial vector at the end\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load int32_t vector\n        svint32_t int_vec = svld1_s32(pg, A + i);\n        \n        // Convert int32_t to float\n        svfloat32_t float_vec = svcvt_f32_s32_z(pg, int_vec);\n        \n        // Scale the float vector\n        svfloat32_t scaled_vec = svmul_f32_z(pg, float_vec, scale_vec);\n        \n        // Store the result\n        svst1_f32(pg, B + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_size = svcntw();\n    svfloat32_t scale_vec = svdup_n_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += vector_size) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        svint32_t int_vec = svld1_s32(pg, A + i);\n        svfloat32_t float_vec = svcvt_f32_s32_z(pg, int_vec);\n        svfloat32_t scaled_vec = svmul_f32_z(pg, float_vec, scale_vec);\n        svst1_f32(pg, B + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_size = svcntw(); // Number of float elements in an SVE vector\n    \n    // Broadcast the scale factor to a vector\n    svfloat32_t scale_vec = svdup_n_f32((float)scale);\n    \n    // Process vector-sized chunks\n    for (size_t i = 0; i < size; i += vector_size) {\n        // Create predicate to handle partial vector at the end\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load int32_t values from source array\n        svint32_t int_vec = svld1_s32(pg, A + i);\n        \n        // Convert int32_t to float\n        svfloat32_t float_vec = svcvt_f32_s32_z(pg, int_vec);\n        \n        // Scale the float values\n        svfloat32_t scaled_vec = svmul_f32_z(pg, float_vec, scale_vec);\n        \n        // Store scaled float values to destination array\n        svst1_f32(pg, B + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_size = svcntw();\n    svfloat32_t scale_vec = svdup_n_f32((float)scale);\n\n    for (size_t i = 0; i < size; i += vector_size) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        svint32_t int_vec = svld1_s32(pg, A + i);\n        svfloat32_t float_vec = svcvt_f32_s32_m(svptrue_b32(), int_vec);\n        svfloat32_t scaled_vec = svmul_f32_m(pg, float_vec, scale_vec);\n        svst1_f32(pg, B + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vector_size = svcntw(); // Number of 32-bit elements in a vector\n    svfloat32_t scale_vec = svdup_n_f32((float)scale); // Broadcast scale factor to vector\n\n    for (size_t i = 0; i < size; i += vector_size) {\n        // Create predicate to handle vector length and remaining elements\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n\n        // Load int32_t vector from source array\n        svint32_t int_vec = svld1_s32(pg, A + i);\n\n        // Convert int32_t vector to float vector\n        svfloat32_t float_vec = svcvt_f32_s32_x(pg, int_vec);\n\n        // Scale the float vector\n        svfloat32_t scaled_vec = svmul_f32_x(pg, float_vec, scale_vec);\n\n        // Store the scaled float vector to destination array\n        svst1_f32(pg, B + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vround = svcvt_roundeven_s32_f32_z(pg, vdiv);\n        \n        svst1_s32(pg, C + i, vround);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vector_length = svcntw(); // Get SVE vector length for 32-bit elements\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load vectors from input arrays\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_x(pg, va, vb);\n        \n        // Round to nearest integer\n        svint32_t vround = svcvt_roundeven_s32_f32_x(pg, vdiv);\n        \n        // Store result in destination array\n        svst1_s32(pg, C + i, vround);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        \n        svint32_t vround = svcvt_roundz_s32_f32(vdiv);\n        \n        svst1_s32(pg, C + i, vround);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vector_length = svcntw(); // Get SVE vector length for 32-bit elements\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        // Load vectors from input arrays A and B\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        // Perform element-wise division\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        \n        // Round to nearest integer\n        svint32_t vround = svcvt_roundeven_s32_f32_z(pg, vdiv);\n        \n        // Store result in destination array\n        svst1_s32(pg, C + i, vround);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        \n        svfloat32_t vrounded = svrinta_f32_z(pg, vdiv);\n        \n        svst1_s32(pg, C + i, svcvt_s32_f32_z(pg, vrounded));\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vector_length = svcntd(); // Number of doubles per SVE vector\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64_u64(i, size);\n        \n        // Load double vector\n        svfloat64_t vec_doubles = svld1_f64(pg, A + i);\n        \n        // Convert doubles to floats with saturation\n        svfloat32_t vec_floats = svcvt_f32_f64_z(pg, vec_doubles);\n        \n        // Store converted vector to destination\n        svst1_f32(pg, B + i, vec_floats);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vector_length = svcntd(); // Number of double elements in a vector\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64_u64(i, size);\n        \n        // Load double vector\n        svfloat64_t vec_double = svld1_f64(pg, A + i);\n        \n        // Convert double to float with saturation\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, vec_double);\n        \n        // Store the converted vector\n        svst1_f32(pg, B + i, vec_float);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vector_length = svcntd(); // Number of doubles per SVE vector\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64_u64(i, size);\n        \n        // Load double vector from source array\n        svfloat64_t vec_double = svld1_f64(pg, A + i);\n        \n        // Convert double to float with saturation\n        svfloat32_t vec_float = svcvt_f32_f64_z(pg, vec_double);\n        \n        // Store converted vector to destination array\n        svst1_f32(pg, B + i, vec_float);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vector_length = svcntd(); // Number of doubles per SVE vector\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64_u64(i, size);\n        \n        // Load double vector\n        svfloat64_t vec_doubles = svld1_f64(pg, A + i);\n        \n        // Convert doubles to floats with saturation\n        svfloat32_t vec_floats = svcvt_f32_f64_z(pg, vec_doubles);\n        \n        // Store converted vector\n        svst1_f32(pg, B + i, vec_floats);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vector_length = svcntd(); // Number of doubles per SVE vector\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b64_u64(i, size);\n        \n        // Load double vector from source array\n        svfloat64_t vec_doubles = svld1_f64(pg, A + i);\n        \n        // Convert doubles to floats with saturation\n        svfloat32_t vec_floats = svcvt_f32_f64_z(pg, vec_doubles);\n        \n        // Store converted vector to destination array\n        svst1_f32(pg, B + i, vec_floats);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vector_size = svcntw() * sizeof(int32_t);\n    \n    for (size_t i = 0; i < size; i += vector_size) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        svint16_t input_vec = svld1_s16(pg, A + i);\n        svint32_t converted_vec = svmovlb_s32(input_vec);\n        svst1_s32(pg, B + i, converted_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vector_size = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_size) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        svint16_t input_vec = svld1_s16(pg, A + i);\n        svint32_t converted_vec = svmovlb_s32(input_vec);\n        svst1_s32(pg, B + i, converted_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vector_size = svcntw();  // Number of 32-bit elements in an SVE vector\n    \n    size_t i = 0;\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load 16-bit vector\n        svint16_t input_vec = svld1_s16(svptrue_b16(), A + i);\n        \n        // Sign-extend 16-bit vector to 32-bit vector\n        svint32_t result_vec = svext_s32(input_vec);\n        \n        // Store result vector\n        svst1_s32(svptrue_b32(), B + i, result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        svint16_t input_vec = svld1_s16(pg, A + i);\n        svint32_t converted_vec = svmovlb_s32(input_vec);\n        svst1_s32(pg, B + i, converted_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        svint16_t input_vec = svld1_s16(pg, A + i);\n        svint32_t converted_vec = svconv_s32_s16_z(pg, input_vec);\n        \n        svst1_s32(pg, B + i, converted_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg_local = svwhilelt_b32(i, size);\n        \n        svint32_t control_vec = svld1_s32(pg_local, control + i);\n        svfloat32_t a_vec = svld1_f32(pg_local, A + i);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg_local, control_vec, 0);\n        \n        svfloat32_t normalized_vec = svsel_f32(normalize_mask, \n            svmin_f32_z(pg_local, \n                svmax_f32_z(pg_local, \n                    svdiv_f32_z(pg_local, \n                        svsub_f32_z(pg_local, a_vec, min_vec), \n                        svsub_f32_z(pg_local, max_vec, min_vec)\n                    ), \n                    zero_vec\n                ), \n                one_vec\n            ),\n            a_vec\n        );\n        \n        svst1_f32(pg_local, B + i, normalized_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg_local = svwhilelt_b32(i, size);\n        \n        svint32_t control_vec = svld1_s32(pg_local, control + i);\n        svfloat32_t a_vec = svld1_f32(pg_local, A + i);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg_local, control_vec, 0);\n        \n        svfloat32_t normalized_vec = svsel_f32(normalize_mask, \n            svmin_f32_z(pg_local, \n                svmax_f32_z(pg_local, \n                    svdiv_f32_z(pg_local, \n                        svsub_f32_z(pg_local, a_vec, min_vec), \n                        svsub_f32_z(pg_local, max_vec, min_vec)\n                    ), \n                    zero_vec\n                ), \n                one_vec\n            ),\n            a_vec\n        );\n        \n        svst1_f32(pg_local, B + i, normalized_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t active_mask = svwhilelt_b32(i, size);\n        \n        svint32_t control_vec = svld1_s32(active_mask, control + i);\n        svfloat32_t a_vec = svld1_f32(active_mask, A + i);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg, control_vec, 0);\n        \n        svfloat32_t normalized_vec = svsel_f32(normalize_mask, \n            svmin_f32_z(normalize_mask, \n                svmax_f32_z(normalize_mask, \n                    svdiv_f32_z(normalize_mask, \n                        svsub_f32_z(normalize_mask, a_vec, min_vec), \n                        svsub_f32_z(normalize_mask, max_vec, min_vec)), \n                    zero_vec), \n                one_vec), \n            a_vec);\n        \n        svst1_f32(active_mask, B + i, normalized_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t active_mask = svwhilelt_b32(i, size);\n        \n        // Load control and A values\n        svint32_t control_vec = svld1_s32(active_mask, control + i);\n        svfloat32_t a_vec = svld1_f32(active_mask, A + i);\n        \n        // Check control condition\n        svbool_t normalize_mask = svcmpgt_s32(pg, control_vec, 0);\n        \n        // Normalize values where control > 0\n        svfloat32_t normalized_vec = svdiv_f32_z(normalize_mask, \n            svsub_f32_z(normalize_mask, a_vec, min_vec),\n            svsub_f32_z(normalize_mask, max_vec, min_vec)\n        );\n        \n        // Clamp normalized values between 0 and 1\n        normalized_vec = svmin_f32_z(normalize_mask, \n            svmax_f32_z(normalize_mask, normalized_vec, zero_vec), \n            one_vec\n        );\n        \n        // Where control <= 0, copy original values\n        svfloat32_t result_vec = svsel_f32(normalize_mask, normalized_vec, a_vec);\n        \n        // Store results\n        svst1_f32(active_mask, B + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    svbool_t pg = svptrue_b32();\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    \n    size_t vector_size = svcntw();\n    size_t i = 0;\n    \n    for (; i + vector_size <= size; i += vector_size) {\n        svint32_t control_vec = svld1_s32(pg, control + i);\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg, control_vec, 0);\n        \n        svfloat32_t normalized_vec = svdiv_f32_z(normalize_mask, \n            svsub_f32_z(normalize_mask, a_vec, min_vec),\n            svsub_f32_z(pg, max_vec, min_vec)\n        );\n        \n        normalized_vec = svmin_f32_z(normalize_mask, normalized_vec, one_vec);\n        normalized_vec = svmax_f32_z(normalize_mask, normalized_vec, zero_vec);\n        \n        svfloat32_t result_vec = svsel_f32(normalize_mask, normalized_vec, a_vec);\n        \n        svst1_f32(pg, B + i, result_vec);\n    }\n    \n    for (; i < size; ++i) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = fminf(fmaxf(val, 0.0f), 1.0f);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        svuint32_t high_bits = svshr_n_u32_z(pg, vec_a, 16);\n        \n        // Convert uint32_t to float\n        svfloat32_t float_values = svcvt_f32_u32_z(pg, high_bits);\n        \n        // Compute square root\n        svfloat32_t sqrt_values = svsqrt_f32_z(pg, float_values);\n        \n        // Store results\n        svst1_f32(pg, B + i, sqrt_values);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t vector\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        svuint32_t high_bits = svlsr_n_u32_z(pg, vec_a, 16);\n        \n        // Convert uint32_t to float\n        svfloat32_t float_vec = svcvt_f32_u32_z(pg, high_bits);\n        \n        // Compute square root\n        svfloat32_t sqrt_vec = svsqrt_f32_z(pg, float_vec);\n        \n        // Store result\n        svst1_f32(pg, B + i, sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        svuint32_t high_bits = svshr_n_u32_z(pg, vec_a, 16);\n        \n        // Convert uint32_t to float\n        svfloat32_t float_vals = svcvt_f32_u32_z(pg, high_bits);\n        \n        // Calculate square root\n        svfloat32_t sqrt_vals = svsqrt_f32_z(pg, float_vals);\n        \n        // Store results\n        svst1_f32(pg, B + i, sqrt_vals);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        svuint32_t high_bits = svshr_n_u32_z(pg, vec_a, 16);\n        \n        // Convert uint32_t to float\n        svfloat32_t float_values = svcvt_f32_u32_z(pg, high_bits);\n        \n        // Compute square root\n        svfloat32_t sqrt_values = svsqrt_f32_z(pg, float_values);\n        \n        // Store results\n        svst1_f32(pg, B + i, sqrt_values);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t vector\n        svuint32_t vec_a = svld1_u32(pg, A + i);\n        \n        // Shift right by 16 bits to extract high 16 bits\n        svuint32_t high_bits = svlsr_n_u32_z(pg, vec_a, 16);\n        \n        // Convert uint32_t to float\n        svfloat32_t float_vec = svcvt_f32_u32_z(pg, high_bits);\n        \n        // Compute square root\n        svfloat32_t sqrt_vec = svsqrt_f32_z(pg, float_vec);\n        \n        // Store result\n        svst1_f32(pg, B + i, sqrt_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values from source array\n        svuint32_t int_vec = svld1_u32(pg, A + i);\n        \n        // Reinterpret bits directly as float using type-punning\n        svfloat32_t float_vec = svreinterpret_f32_u32(int_vec);\n        \n        // Store float values to destination array\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values from source array\n        svuint32_t int_vec = svld1_u32(pg, A + i);\n        \n        // Reinterpret the bits directly as float using type-punning\n        svfloat32_t float_vec = svreinterpret_f32_u32(int_vec);\n        \n        // Store the reinterpreted float values to destination array\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values from source array\n        svuint32_t int_vec = svld1_u32(pg, A + i);\n        \n        // Reinterpret bits directly as float using type-punning\n        svfloat32_t float_vec = svreinterpret_f32_u32(int_vec);\n        \n        // Store float values to destination array\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t vector\n        svuint32_t int_vec = svld1_u32(pg, A + i);\n        \n        // Reinterpret bits directly as float vector\n        svfloat32_t float_vec = svreinterpret_f32_u32(int_vec);\n        \n        // Store float vector\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < size; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, size);\n        \n        // Load uint32_t values from source array\n        svuint32_t int_vec = svld1_u32(pg, A + i);\n        \n        // Reinterpret the bits directly as float using type-punning\n        svfloat32_t float_vec = *(svfloat32_t*)&int_vec;\n        \n        // Store the float values to destination array\n        svst1_f32(pg, B + i, float_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process remaining elements using SVE\n    size_t vector_size = svcntw();\n    for (size_t i = 1; i < size; i += vector_size) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, size);\n\n        // Load condition vector\n        svbool_t cond_vec = svld1_b32(pg, cond + i);\n\n        // Load current and previous integer vectors\n        svint32_t curr_vec = svld1_s32(pg, A + i);\n        svint32_t prev_vec = svld1_s32(pg, A + i - 1);\n\n        // Compute differences\n        svint32_t diff_vec = svsub_s32_z(pg, curr_vec, prev_vec);\n\n        // Convert differences to float\n        svfloat32_t float_diff_vec = svcvt_f32_s32_z(pg, diff_vec);\n\n        // Zero out differences where condition is false\n        svfloat32_t result_vec = svsel_f32(cond_vec, float_diff_vec, svdup_f32(0.0f));\n\n        // Store results\n        svst1_f32(pg, diff + i, result_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process remaining elements using SVE\n    size_t vector_size = svcntw(); // Number of 32-bit elements in a vector\n    size_t i = 1;\n\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load vectors\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svint32_t a_prev_vec = svld1_s32(pg, A + i - 1);\n        svbool_t cond_vec = svldnf1ub_b32(pg, cond + i);\n\n        // Compute differences\n        svint32_t diff_vec = svsub_s32_z(pg, a_vec, a_prev_vec);\n        \n        // Convert to float and conditionally set to 0.0f\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, diff_vec);\n        svfloat32_t zero_vec = svdup_f32(0.0f);\n        svfloat32_t result_vec = svsel_f32(cond_vec, diff_float, zero_vec);\n\n        // Store results\n        svst1_f32(pg, diff + i, result_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the array using SVE\n    size_t vector_size = svcntw();  // Number of 32-bit elements in a vector\n    size_t i = 1;\n\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load vectors of input data\n        svint32_t a_vec = svld1_s32(svptrue_b32(), A + i);\n        svint32_t a_prev_vec = svld1_s32(svptrue_b32(), A + i - 1);\n        svbool_t cond_vec = svld1_b_s32(svptrue_b32(), cond + i);\n\n        // Compute differences\n        svint32_t diff_vec = svsub_s32_z(cond_vec, a_vec, a_prev_vec);\n\n        // Convert to float and apply condition\n        svfloat32_t diff_float_vec = svcvt_f32_s32_z(cond_vec, diff_vec);\n\n        // Store results\n        svst1_f32(svptrue_b32(), diff + i, diff_float_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process the rest of the array using SVE\n    size_t vector_size = svcntw(); // Number of 32-bit elements in a vector\n    size_t i = 1;\n\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load condition vector\n        svbool_t pg = svwhilelt_b32(i, size);\n        svbool_t cond_vec = svld1ub_b_z(pg, cond + i);\n\n        // Load input vectors\n        svint32_t a_curr = svld1_s32(pg, A + i);\n        svint32_t a_prev = svld1_s32(pg, A + i - 1);\n\n        // Compute differences\n        svint32_t diff_int = svsub_s32_z(pg, a_curr, a_prev);\n\n        // Convert to float\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, diff_int);\n\n        // Set to 0.0f where condition is false\n        svfloat32_t result = svsel_f32(cond_vec, diff_float, svdup_f32(0.0f));\n\n        // Store result\n        svst1_f32(pg, diff + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process remaining elements using SVE\n    size_t vector_size = svcntw();\n    size_t i = 1;\n\n    for (; i + vector_size <= size; i += vector_size) {\n        // Load vectors\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t vec_A = svld1_s32(pg, A + i);\n        svint32_t vec_A_prev = svld1_s32(pg, A + i - 1);\n        svbool_t vec_cond = svld1_b_s32(pg, cond + i);\n\n        // Compute differences\n        svint32_t vec_diff_int = svsub_s32_z(pg, vec_A, vec_A_prev);\n        svfloat32_t vec_diff_float = svcvt_f32_s32_z(pg, vec_diff_int);\n\n        // Conditionally set to 0.0f\n        svfloat32_t vec_result = svsel_f32(vec_cond, vec_diff_float, svdup_f32(0.0f));\n\n        // Store results\n        svst1_f32(pg, diff + i, vec_result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector of 32-bit unsigned integers\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Zero-extend 32-bit integers to 64-bit integers \n        svuint64_t dst_vec = svzxtb_u64_x(pg, src_vec);\n        \n        // Set high 32 bits to 1\n        dst_vec = svorr_u64_x(pg, dst_vec, 0xFFFFFFFF00000000ULL);\n        \n        // Store result vector\n        svst1_u64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load 32-bit unsigned integers\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Zero-extend 32-bit integers to 64-bit integers\n        svuint64_t dst_vec = svzxtb_u64_x(pg, src_vec);\n        \n        // Set high 32 bits to 1\n        dst_vec = svorr_u64_x(pg, dst_vec, 0xFFFFFFFF00000000ULL);\n        \n        // Store results\n        svst1_u64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector of 32-bit unsigned integers\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Zero-extend 32-bit integers to 64-bit integers\n        svuint64_t dst_vec = svzxtb_u64_x(pg, src_vec);\n        \n        // Set high 32 bits to 1\n        dst_vec = svorr_u64_x(pg, dst_vec, 0xFFFFFFFF00000000ULL);\n        \n        // Store result to destination\n        svst1_u64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        // Load source vector of 32-bit unsigned integers\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Zero-extend 32-bit integers to 64-bit integers\n        svuint64_t dst_vec = svzxtb_u64_x(pg, src_vec);\n        \n        // Set high 32 bits to 1\n        dst_vec = svorr_u64_x(pg, dst_vec, 0xFFFFFFFF00000000ULL);\n        \n        // Store result to destination\n        svst1_u64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vector_length = svcntw();\n    \n    for (size_t i = 0; i < length; i += vector_length) {\n        svbool_t pg = svwhilelt_b32_u64(i, length);\n        \n        // Load source vector of 32-bit unsigned integers\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        \n        // Zero-extend 32-bit integers to 64-bit integers \n        svuint64_t dst_vec = svzxtb_u64_x(pg, src_vec);\n        \n        // Set high 32 bits to 1 \n        dst_vec = svorr_u64_x(pg, dst_vec, 0xFFFFFFFF00000000ULL);\n        \n        // Store result vector\n        svst1_u64(pg, dst + i, dst_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64_u64(0, length);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        // Load indices and mask\n        svint16_t idx_vec = svld1_s16(pg, index + i);\n        svbool_t valid_mask = svcmplt_s16(pg, idx_vec, (int16_t)length);\n\n        // Convert indices to 64-bit \n        svint64_t idx64_vec = svconv_s64_s16(idx_vec);\n\n        // Gather elements from vec using indices\n        svfloat64_t gathered_vec = svld1_gather_s64index_f64(valid_mask, vec, idx64_vec);\n\n        // Accumulate sum\n        sum_vec = svadd_f64_m(valid_mask, sum_vec, gathered_vec);\n\n        // Update predicate for next iteration\n        pg = svwhilelt_b64_u64(i + svcntd(), length);\n    }\n\n    // Reduce sum vector to scalar\n    result = svaddv_f64(svptrue_b64(), sum_vec);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        svint16_t idx_vec = svld1_s16(pg, index + i);\n        svbool_t valid_idx = svcmplt_s16(pg, idx_vec, (int16_t)length);\n        \n        svfloat64_t gathered_values = svmad_f64_z(valid_idx, \n            svdup_f64(0.0), \n            svld1_gather_s16index_f64(valid_idx, vec, idx_vec), \n            svdup_f64(0.0)\n        );\n        \n        result += svaddv_f64(pg, gathered_values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svwhilelt_b64_u64(0, length);\n    \n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t i = 0;\n    \n    do {\n        svint16_t idx_vec = svld1_s16(pg, index + i);\n        svfloat64_t gathered_vec = svld1_gather_s16index_f64(pg, vec, idx_vec);\n        sum_vec = svadd_f64_m(pg, sum_vec, gathered_vec);\n        \n        i += svcntd();\n        pg = svwhilelt_b64_u64(i, length);\n    } while (svptest_any_z(svptrue_b64(), pg));\n    \n    result = svaddv_f64(svptrue_b64(), sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svptrue_b64();\n    \n    size_t vector_length = svcntd();\n    size_t i = 0;\n    \n    for (; i + vector_length <= length; i += vector_length) {\n        // Load indices\n        svint16_t idx_vec = svld1_s16(pg, index + i);\n        \n        // Convert indices to 64-bit \n        svint64_t idx_vec_64 = svcvt_s64_s16_x(pg, idx_vec);\n        \n        // Gather elements from vec using indices\n        svfloat64_t gathered_vec = svld1_gather_s64index_f64(pg, vec, idx_vec_64);\n        \n        // Sum the gathered elements\n        result += svaddv_f64(pg, gathered_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; ++i) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    svbool_t pg = svptrue_b64();\n    svfloat64_t sum = svdup_f64(0.0);\n\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svint16_t idx = svld1_s16(pg, index + i);\n        svbool_t valid_indices = svcmple_s16(pg, idx, length - 1);\n        \n        svfloat64_t gathered_values = svmad_f64_z(valid_indices, \n            svdup_f64(0.0), \n            svld1_gather_s16index_f64(valid_indices, vec, idx), \n            svdup_f64(0.0)\n        );\n        \n        sum = svadd_f64_m(pg, sum, gathered_values);\n    }\n\n    result = svaddv_f64(pg, sum);\n    return result;\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    // Determine SVE vector length for doubles\n    size_t vec_len = svcntd();\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vec_len) {\n            // Determine active vector length for this iteration\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            \n            // Initialize output vector to zero\n            svfloat64_t acc = svdup_f64(0.0);\n            \n            // Perform convolution for each kernel element\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    // Load input values\n                    svfloat64_t input_vec = svld1_f64(pg, \n                        &input[(i + ki) * input_size + j + kj]);\n                    \n                    // Load kernel value\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n                    \n                    // Multiply and accumulate\n                    acc = svmla_f64_x(pg, acc, input_vec, kernel_vec);\n                }\n            }\n            \n            // Apply ReLU activation\n            acc = svmax_f64_x(pg, acc, svdup_f64(0.0));\n            \n            // Store results\n            svst1_f64(pg, &output[i * output_size + j], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    // Determine SVE vector length for doubles\n    size_t vec_len = svcntd();\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vec_len) {\n            // Determine number of elements to process in this iteration\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            \n            // Initialize output vector to zero\n            svfloat64_t acc = svdup_f64(0.0);\n            \n            // Perform convolution\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    // Load input slice\n                    svfloat64_t input_vec = svld1_f64(pg, \n                        &input[(i + ki) * input_size + j + kj]);\n                    \n                    // Load kernel value\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n                    \n                    // Multiply and accumulate\n                    acc = svmla_f64_m(pg, acc, input_vec, kernel_vec);\n                }\n            }\n            \n            // Apply ReLU\n            acc = svmax_f64_m(pg, acc, svdup_f64(0.0));\n            \n            // Store result\n            svst1_f64(pg, &output[i * output_size + j], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    // Determine SVE vector length for doubles\n    size_t vec_len = svcntd();\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vec_len) {\n            // Determine active vector predicate\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            \n            // Initialize output vector to zero\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            \n            // Perform convolution for each kernel element\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    // Load input slice\n                    svfloat64_t input_vec = svld1_f64(pg, \n                        &input[(i + ki) * input_size + j + kj]);\n                    \n                    // Load kernel element\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n                    \n                    // Multiply and accumulate\n                    sum_vec = svmla_f64_m(pg, sum_vec, input_vec, kernel_vec);\n                }\n            }\n            \n            // Apply ReLU\n            sum_vec = svmax_f64_m(pg, sum_vec, svdup_f64(0.0));\n            \n            // Store result\n            svst1_f64(pg, &output[i * output_size + j], sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    // Determine SVE vector length for doubles\n    size_t vec_len = svcntd();\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vec_len) {\n            // Determine how many elements to process in this vector\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            \n            // Initialize output vector to zero\n            svfloat64_t sum_vec = svdup_f64(0.0);\n            \n            // Perform convolution for this vector\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    // Load input values\n                    svfloat64_t input_vec = svld1_f64(pg, \n                        &input[(i + ki) * input_size + j + kj]);\n                    \n                    // Load kernel value\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n                    \n                    // Multiply and accumulate\n                    sum_vec = svmla_f64_m(pg, sum_vec, input_vec, kernel_vec);\n                }\n            }\n            \n            // Apply ReLU\n            sum_vec = svmax_f64_m(pg, sum_vec, svdup_f64(0.0));\n            \n            // Store results\n            svst1_f64(pg, &output[i * output_size + j], sum_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    // Determine SVE vector length for doubles\n    size_t vec_len = svcntd();\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; j += vec_len) {\n            // Determine number of elements to process in this vector\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            \n            // Initialize output vector to zero\n            svfloat64_t acc = svdup_f64(0.0);\n            \n            // Perform convolution for each kernel element\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    // Load input elements\n                    svfloat64_t input_vec = svld1_f64(pg, \n                        &input[(i + ki) * input_size + j + kj]);\n                    \n                    // Load kernel element\n                    double kernel_val = kernel[ki * kernel_size + kj];\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n                    \n                    // Multiply and accumulate\n                    acc = svmla_f64_m(pg, acc, input_vec, kernel_vec);\n                }\n            }\n            \n            // Apply ReLU\n            acc = svmax_f64_m(pg, acc, svdup_f64(0.0));\n            \n            // Store results\n            svst1_f64(pg, &output[i * output_size + j], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n        size_t remaining = std::min(svcntd(), n - i);\n        \n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svfloat64_t compare_vec = svld1_f64(pg, &numbers[j]);\n            size_t compare_remaining = std::min(svcntd(), n - j);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svfsub_f64_z(pg, current_vec, compare_vec));\n            svbool_t close_mask = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, close_mask)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svfloat64_t compare_vec = svld1_f64(pg, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svfsub_f64_z(pg, current_vec, compare_vec));\n            svbool_t close_mask = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, close_mask)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svfloat64_t compare_vec = svld1_f64(pg, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svfsub_f64_z(pg, current_vec, compare_vec));\n            svbool_t close_mask = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, close_mask)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svfloat64_t compare_vec = svld1_f64(pg, &numbers[j]);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svfsub_f64_z(pg, current_vec, compare_vec));\n            svbool_t close_mask = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, close_mask)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t current_vec = svld1_f64(pg, &numbers[i]);\n        size_t remaining = std::min(svcntd(), n - i);\n        \n        for (size_t j = i + 1; j < n; j += svcntd()) {\n            svfloat64_t compare_vec = svld1_f64(pg, &numbers[j]);\n            size_t compare_remaining = std::min(svcntd(), n - j);\n            \n            svfloat64_t diff = svabs_f64_z(pg, svfsub_f64_z(pg, current_vec, compare_vec));\n            svbool_t close_mask = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, close_mask)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vector_size = operations.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize running balance vector\n    svint32_t running_balance = svdup_n_s32(0);\n    \n    // Process operations in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Load next chunk of operations\n        svint32_t chunk = svld1_s32(pg, operations.data() + i);\n        \n        // Update running balance\n        running_balance = svadd_s32_z(pg, running_balance, chunk);\n        \n        // Check if any lane becomes negative\n        svbool_t negative_mask = svcmplt_s32(pg, running_balance, svdup_n_s32(0));\n        \n        // If any lane is negative, return true\n        if (svptest_any(pg, negative_mask)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vector_size = operations.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize running balance vector\n    svint32_t running_balance = svdup_n_s32(0);\n    \n    // Process operations in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Load next chunk of operations\n        svint32_t chunk = svld1_s32(pg, operations.data() + i);\n        \n        // Update running balance\n        running_balance = svadd_s32_z(pg, running_balance, chunk);\n        \n        // Check if any lane becomes negative\n        svbool_t negative_mask = svcmplt_s32(pg, running_balance, svdup_n_s32(0));\n        \n        // If any lane is negative, return true\n        if (svptest_any(pg, negative_mask)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vector_size = operations.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize running balance to zero\n    svint32_t running_balance = svdup_n_s32(0);\n    \n    // Process operations in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Load next chunk of operations\n        svint32_t chunk = svld1_s32(pg, operations.data() + i);\n        \n        // Update running balance\n        running_balance = svadd_s32_z(pg, running_balance, chunk);\n        \n        // Check if any lane in the vector is negative\n        svbool_t negative_mask = svcmplt_s32(pg, running_balance, svdup_n_s32(0));\n        \n        // If any lane is negative, return true\n        if (svptest_any(pg, negative_mask)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vector_size = operations.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize running balance vector\n    svint32_t running_balance = svdup_n_s32(0);\n    \n    // Process operations in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Load next chunk of operations\n        svint32_t chunk = svld1_s32(pg, operations.data() + i);\n        \n        // Update running balance\n        running_balance = svadd_s32_z(pg, running_balance, chunk);\n        \n        // Check if any lane becomes negative\n        svbool_t negative_mask = svcmplt_s32(pg, running_balance, svdup_n_s32(0));\n        \n        // If any lane is negative, return true\n        if (svptest_any(pg, negative_mask)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vector_size = operations.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize running balance vector\n    svint32_t running_balance = svdup_n_s32(0);\n    \n    // Process operations in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Load next chunk of operations\n        svint32_t chunk = svld1_s32(pg, operations.data() + i);\n        \n        // Update running balance\n        running_balance = svadd_s32_m(pg, running_balance, chunk);\n        \n        // Check if any lane becomes negative\n        svbool_t negative_mask = svcmplt_s32(pg, running_balance, svdup_n_s32(0));\n        \n        // If any lane is negative, return true\n        if (svptest_any(pg, negative_mask)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean using SVE\n    svfloat64_t mean_vec = svdup_n_f64(0.0);\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t data_vec = svld1_f64(pg, numbers.data() + i);\n        mean_vec = svadd_f64_m(pg, mean_vec, data_vec);\n    }\n\n    // Horizontal sum of mean vector\n    double mean = svaddv_f64(svptrue_b64(), mean_vec) / n;\n\n    // Calculate absolute deviations\n    svfloat64_t mad_vec = svdup_n_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t data_vec = svld1_f64(pg, numbers.data() + i);\n        \n        // Calculate absolute deviation\n        svfloat64_t dev_vec = svabs_f64_m(pg, svsub_f64_m(pg, data_vec, svdup_n_f64(mean)));\n        mad_vec = svadd_f64_m(pg, mad_vec, dev_vec);\n    }\n\n    // Horizontal sum of MAD vector\n    double mad = svaddv_f64(svptrue_b64(), mad_vec) / n;\n\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    svbool_t pg = svptrue_b64();\n    \n    // Calculate mean\n    svfloat64_t sum_vec = svdup_n_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t data_vec = svld1_f64(pg, numbers.data() + i);\n        sum_vec = svadd_f64_m(pg, sum_vec, data_vec);\n    }\n    double total_sum = svaddv_f64(pg, sum_vec);\n    double mean = total_sum / n;\n\n    // Calculate absolute deviations\n    svfloat64_t mean_vec = svdup_n_f64(mean);\n    svfloat64_t mad_sum_vec = svdup_n_f64(0.0);\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svfloat64_t data_vec = svld1_f64(pg, numbers.data() + i);\n        svfloat64_t diff_vec = svabs_f64_m(pg, svfsub_f64_m(pg, data_vec, mean_vec));\n        mad_sum_vec = svadd_f64_m(pg, mad_sum_vec, diff_vec);\n    }\n    double mad_sum = svaddv_f64(pg, mad_sum_vec);\n    \n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean using SVE\n    svfloat64_t mean_vec = svdup_n_f64(0.0);\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg, numbers.data() + i);\n        mean_vec = svadd_f64_m(pg, mean_vec, vec);\n    }\n    \n    // Horizontal sum and divide by n\n    double mean = svadda_f64(svptrue_b64(), 0.0, mean_vec) / n;\n\n    // Calculate absolute deviations\n    svfloat64_t mad_vec = svdup_n_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg, numbers.data() + i);\n        \n        // Calculate absolute deviation\n        svfloat64_t abs_dev = svabs_f64_m(pg, svsub_f64_z(pg, vec, mean));\n        mad_vec = svadd_f64_m(pg, mad_vec, abs_dev);\n    }\n\n    // Horizontal sum and divide by n\n    double mad = svadda_f64(svptrue_b64(), 0.0, mad_vec) / n;\n    \n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean using SVE\n    svfloat64_t mean_vec = svdup_n_f64(0.0);\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t data_vec = svld1_f64(pg, numbers.data() + i);\n        mean_vec = svadd_f64_m(pg, mean_vec, data_vec);\n    }\n    \n    // Horizontal sum to get total\n    double total = svaddv_f64(svptrue_b64(), mean_vec);\n    double mean = total / n;\n\n    // Calculate absolute deviations\n    svfloat64_t mean_vec_broadcast = svdup_n_f64(mean);\n    svfloat64_t mad_vec = svdup_n_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t data_vec = svld1_f64(pg, numbers.data() + i);\n        \n        // Absolute difference from mean\n        svfloat64_t abs_diff = svabs_f64_m(pg, svsub_f64_m(pg, data_vec, mean_vec_broadcast));\n        mad_vec = svadd_f64_m(pg, mad_vec, abs_diff);\n    }\n\n    // Horizontal sum of absolute deviations\n    double mad_total = svaddv_f64(svptrue_b64(), mad_vec);\n    return mad_total / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean using SVE\n    svfloat64_t mean_vec = svdup_n_f64(0.0);\n    size_t vector_length = svcntd();\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        size_t remaining = n - i;\n        svbool_t pred = svwhilelt_b64(i, n);\n        svfloat64_t data_vec = svld1_f64(pred, numbers.data() + i);\n        mean_vec = svadd_f64_m(pred, mean_vec, data_vec);\n    }\n    \n    // Horizontal sum to get total\n    double total = svaddv_f64(svptrue_b64(), mean_vec);\n    double mean = total / n;\n\n    // Calculate absolute deviations using SVE\n    svfloat64_t mean_vec_broadcast = svdup_n_f64(mean);\n    svfloat64_t mad_vec = svdup_n_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        size_t remaining = n - i;\n        svbool_t pred = svwhilelt_b64(i, n);\n        \n        svfloat64_t data_vec = svld1_f64(pred, numbers.data() + i);\n        svfloat64_t diff_vec = svsub_f64_m(pred, data_vec, mean_vec_broadcast);\n        svfloat64_t abs_diff_vec = svabs_f64_m(pred, diff_vec);\n        \n        mad_vec = svadd_f64_m(pred, mad_vec, abs_diff_vec);\n    }\n    \n    // Horizontal sum to get total absolute deviation\n    double total_abs_dev = svaddv_f64(svptrue_b64(), mad_vec);\n    \n    return total_abs_dev / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    size_t original_size = numbers.size();\n    size_t result_size = original_size * 2 - 1;\n    std::vector<int> result(result_size);\n\n    // Determine SVE vector length for integers\n    size_t vec_len = svcntw();\n    \n    size_t i = 0;\n    for (; i + vec_len < original_size; i += vec_len) {\n        // Load original vector\n        svint32_t orig_vec = svld1_s32(svptrue_b32(), &numbers[i]);\n        \n        // Create delimiter vector\n        svint32_t delim_vec = svdup_s32(delimeter);\n        \n        // Interleave original and delimiter vectors\n        for (size_t j = 0; j < vec_len; ++j) {\n            result[2*i + 2*j] = numbers[i + j];\n            result[2*i + 2*j + 1] = delimeter;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < original_size; ++i) {\n        result[2*i] = numbers[i];\n        if (i < original_size - 1) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    size_t vector_size = svcntw(); // Number of int elements in an SVE vector\n    size_t i = 0;\n\n    // Process vectors in parallel\n    for (; i + vector_size <= numbers.size(); i += vector_size) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &numbers[i]);\n        \n        // Interleave vector with delimiter\n        for (size_t j = 0; j < vector_size; ++j) {\n            result.push_back(svgetele_s32(vec, j));\n            if (j < vector_size - 1 || i + vector_size < numbers.size()) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t original_size = numbers.size();\n    size_t result_size = original_size * 2 - 1;\n    std::vector<int> result(result_size);\n\n    // Determine SVE vector length for integers\n    size_t vec_len = svcntw();\n\n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < original_size; i += vec_len) {\n        // Determine number of elements to process in this iteration\n        size_t remaining = std::min(vec_len, original_size - i);\n        svbool_t pg = svwhilelt_b32(i, original_size);\n\n        // Load original vector elements\n        svint32_t orig_vec = svld1_z(pg, numbers.data() + i);\n\n        // Store original elements and delimiters alternately\n        for (size_t j = 0; j < remaining; ++j) {\n            result[2*i + 2*j] = numbers[i + j];\n            if (2*i + 2*j + 1 < result_size) {\n                result[2*i + 2*j + 1] = delimeter;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    size_t vector_size = svcntw(); // Number of int elements in an SVE vector\n    size_t i = 0;\n\n    // Process vectors in parallel\n    for (; i + vector_size <= numbers.size(); i += vector_size) {\n        svint32_t vec = svld1_s32(svptrue_b32(), &numbers[i]);\n        \n        // Interleave with delimiter\n        for (size_t j = 0; j < vector_size; ++j) {\n            result.push_back(svget_s32(vec, j));\n            if (j < vector_size - 1 || i + vector_size < numbers.size()) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return numbers;\n\n    size_t original_size = numbers.size();\n    size_t result_size = original_size * 2 - 1;\n    std::vector<int> result(result_size);\n\n    // Determine SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vectors in chunks\n    size_t i = 0;\n    for (; i + vec_len < original_size; i += vec_len) {\n        // Load original vector\n        svint32_t orig_vec = svld1_s32(svptrue_b32(), numbers.data() + i);\n        \n        // Create delimiter vector\n        svint32_t delim_vec = svdup_s32(delimeter);\n        \n        // Interleave original and delimiter vectors\n        for (size_t j = 0; j < vec_len; ++j) {\n            result[2*i + 2*j] = numbers[i + j];\n            result[2*i + 2*j + 1] = delimeter;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < original_size; ++i) {\n        result[2*i] = numbers[i];\n        if (i < original_size - 1) {\n            result[2*i + 1] = delimeter;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    // Get the SVE vector length for int16_t\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Determine the number of active elements in this iteration\n        svbool_t pg = svwhilelt_b16_u64(i, numbers.size());\n        \n        // Load vector of int16_t\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        \n        // Convert int16_t to int64_t for sum and product\n        svint64_t vec_wide = svmovlb_s16(vec);\n        \n        // Compute sum\n        sum += svaddv_s64(pg, vec_wide);\n        \n        // Compute product\n        svint64_t prod_vec = svmul_s64_z(pg, vec_wide, svdup_s64(product));\n        product = svaddv_s64(pg, prod_vec);\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    // Get the SVE vector length for int16_t\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    // Process vector in SVE vector-sized chunks\n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vector_length, numbers.size() - i);\n        \n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b16_u64(i, numbers.size());\n        \n        // Load vector of int16_t\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        \n        // Convert int16_t to int64_t for sum and product\n        svint64_t vec_wide = svmovlb_s16(vec);\n        \n        // Compute sum using SVE reduction\n        sum += svaddv_s64(pg, vec_wide);\n        \n        // Compute product using SVE reduction\n        svint64_t prod_vec = svmul_s64_z(pg, vec_wide, vec_wide);\n        product *= svmaxv_s64(pg, prod_vec);\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    // Get SVE vector length for int16_t\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    // Process vector in SVE vector-sized chunks\n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Determine number of active elements in current vector\n        svbool_t pg = svwhilelt_b16_u64(i, numbers.size());\n        \n        // Load vector of int16_t\n        svint16_t vec = svld1_s16(pg, &numbers[i]);\n        \n        // Extend int16_t to int64_t for computation\n        svint64_t vec_wide = svconv_s64_s16(vec);\n        \n        // Compute sum using SVE reduction\n        sum += svaddv_s64(pg, vec_wide);\n        \n        // Compute product using SVE reduction\n        product *= svmulv_s64(pg, vec_wide);\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    // If vector is empty, return {0, 1}\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n    \n    // Get SVE vector length for int16_t\n    size_t vector_length = svcntb() / sizeof(int16_t);\n    \n    // Initialize SVE vectors for sum and product\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint64_t sum_wide = svdup_n_s64(0);\n    svint16_t prod_vec = svdup_n_s16(1);\n    svint64_t prod_wide = svdup_n_s64(1);\n    \n    // Predicate for active elements\n    svbool_t pg = svwhilelt_b16_u64(0, numbers.size());\n    \n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Load vector of integers\n        svint16_t curr_vec = svld1_s16(pg, &numbers[i]);\n        \n        // Accumulate sum\n        sum_vec = svadd_s16_m(pg, sum_vec, curr_vec);\n        \n        // Accumulate product\n        prod_vec = svmul_s16_m(pg, prod_vec, curr_vec);\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b16_u64(i + vector_length, numbers.size());\n    }\n    \n    // Reduce sum vector to scalar\n    sum_wide = svaddv_s16(svptrue_b16(), sum_vec);\n    sum = svaddv_s64(svptrue_b64(), sum_wide);\n    \n    // Reduce product vector to scalar\n    svint64_t prod_wide_curr = svmovl_s16(prod_vec);\n    product = svaddv_s64(svptrue_b64(), prod_wide_curr);\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    // If vector is empty, return {0, 1}\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n    \n    // Determine vector length\n    size_t vector_size = numbers.size();\n    \n    // Initialize SVE vector registers\n    svint16_t sum_vec = svdup_n_s16(0);\n    svint16_t product_vec = svdup_n_s16(1);\n    \n    // Process vector in SVE vector chunks\n    size_t vec_len = svcntw();\n    for (size_t i = 0; i < vector_size; i += vec_len) {\n        // Determine active elements for this iteration\n        svbool_t pg = svwhilelt_b16_u64(i, vector_size);\n        \n        // Load vector chunk\n        svint16_t current_vec = svld1_s16(pg, numbers.data() + i);\n        \n        // Compute sum\n        sum_vec = svadd_s16_m(pg, sum_vec, current_vec);\n        \n        // Compute product\n        product_vec = svmul_s16_m(pg, product_vec, current_vec);\n    }\n    \n    // Reduce sum and product across vector lanes\n    sum = svaddv_s16(svptrue_b16(), sum_vec);\n    product = svmulv_s16(svptrue_b16(), product_vec);\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    \n    // Get the SVE vector length for integers\n    size_t vector_length = svcntw();\n    \n    // Process the input in SVE vector-sized chunks\n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        size_t remaining = std::min(vector_length, numbers.size() - i);\n        \n        // Create SVE predicates and load vectors\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        svint32_t current_vec = svld1_z(pg, &numbers[i]);\n        \n        // If this is the first chunk, initialize the max vector\n        if (i == 0) {\n            svst1_z(pg, &result[i], current_vec);\n        } else {\n            // Load previous max vector\n            svint32_t prev_max_vec = svld1_z(pg, &result[i - vector_length]);\n            \n            // Compute rolling maximum\n            svint32_t max_vec = svmax_z(pg, prev_max_vec, current_vec);\n            \n            // Store the result\n            svst1_z(pg, &result[i], max_vec);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    \n    // Get the SVE vector length for integers\n    size_t vector_length = svcntw();\n    \n    // Process the first element\n    result[0] = numbers[0];\n    \n    // Process the rest of the vector using SVE\n    for (size_t i = 1; i < numbers.size(); i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        size_t elements_left = std::min(vector_length, numbers.size() - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        // Load previous max and current vector\n        svint32_t prev_max = svdup_n_s32(result[i-1]);\n        svint32_t current = svld1_s32(pg, &numbers[i]);\n        \n        // Compute element-wise max\n        svint32_t max_vec = svmax_s32_z(pg, prev_max, current);\n        \n        // Store results\n        svst1_s32(pg, &result[i], max_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    \n    // Get SVE vector length for integers\n    size_t vector_length = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    size_t i = 0;\n    for (; i + vector_length <= numbers.size(); i += vector_length) {\n        // Load current chunk of input vector\n        svint32_t current_chunk = svld1_s32(svptrue_b32(), &numbers[i]);\n        \n        // Compute rolling maximum for current chunk\n        svint32_t rolling_max = current_chunk;\n        for (size_t j = 1; j < vector_length; ++j) {\n            svbool_t mask = svwhilelt_b32_u64(j, vector_length);\n            rolling_max = svmax_s32_z(mask, rolling_max, current_chunk);\n            current_chunk = svext_s32(current_chunk, current_chunk, 1);\n        }\n        \n        // Store result back to output vector\n        svst1_s32(svptrue_b32(), &result[i], rolling_max);\n    }\n    \n    // Handle remaining elements sequentially\n    int current_max = numbers[0];\n    result[0] = current_max;\n    for (size_t j = i + 1; j < numbers.size(); ++j) {\n        current_max = std::max(current_max, numbers[j]);\n        result[j] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    \n    // Get SVE vector length for integers\n    size_t vector_length = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Determine number of elements to process in this iteration\n        size_t remaining = std::min(vector_length, numbers.size() - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        // Load current chunk of data\n        svint32_t current_vec = svld1_z(pg, &numbers[i], remaining);\n        \n        // Compute rolling max for current chunk\n        svint32_t rolling_max_vec = current_vec;\n        for (size_t j = 1; j < remaining; ++j) {\n            svint32_t prev_max = svmax_z(pg, rolling_max_vec, svdup_s32(svgetlane_s32(rolling_max_vec, j-1)));\n            rolling_max_vec = prev_max;\n        }\n        \n        // Store results back to output vector\n        svst1_z(pg, &result[i], rolling_max_vec, remaining);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    \n    // Get SVE vector length for integers\n    size_t vector_length = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    for (size_t i = 0; i < numbers.size(); i += vector_length) {\n        // Determine number of elements to process in this iteration\n        size_t remaining = std::min(vector_length, numbers.size() - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        // Load current chunk of data\n        svint32_t current_vec = svld1_z(pg, &numbers[i], remaining);\n        \n        // Initialize max vector with first load\n        svint32_t max_vec = current_vec;\n        \n        // Store max values\n        svst1_z(pg, &result[i], max_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure input strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(a.length(), '0');\n    size_t n = a.length();\n\n    // Process vector-sized chunks\n    size_t vec_size = svcntb();\n    size_t i = 0;\n    for (; i + vec_size <= n; i += vec_size) {\n        // Load input strings into SVE vectors\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t va = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vb = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        // Perform bitwise XOR\n        svuint8_t vxor = sveor_u8_x(pg, va, vb);\n\n        // Store result back\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure input strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(a.length(), '0');\n    size_t vector_size = svcntb();  // Get vector length in bytes\n\n    // Process vector-sized chunks\n    for (size_t i = 0; i < a.length(); i += vector_size) {\n        size_t remaining = std::min(vector_size, a.length() - i);\n        \n        // Load input strings into SVE vectors\n        svbool_t pg = svwhilelt_b8(i, a.length());\n        svint8_t vec_a = svld1_s8(pg, reinterpret_cast<const int8_t*>(a.data() + i));\n        svint8_t vec_b = svld1_s8(pg, reinterpret_cast<const int8_t*>(b.data() + i));\n\n        // Perform bitwise XOR\n        svint8_t vec_result = sveor_s8_x(pg, vec_a, vec_b);\n\n        // Store result back to string\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure input strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(a.length(), '0');\n    size_t vector_size = svcntb();  // Get number of bytes in SVE vector\n\n    // Process vector-sized chunks\n    for (size_t i = 0; i < a.length(); i += vector_size) {\n        size_t remaining = std::min(vector_size, a.length() - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b8(i, a.length());\n        \n        // Load input vectors\n        svint8_t va = svld1_s8(pg, reinterpret_cast<const int8_t*>(a.data() + i));\n        svint8_t vb = svld1_s8(pg, reinterpret_cast<const int8_t*>(b.data() + i));\n        \n        // Perform XOR\n        svint8_t vresult = sveor_s8_z(pg, va, vb);\n        \n        // Store result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), vresult);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure input strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(a.length(), '0');\n    size_t vector_size = svcntb();  // Get SVE vector size in bytes\n\n    // Process vector-sized chunks\n    for (size_t i = 0; i < a.length(); i += vector_size) {\n        size_t remaining = std::min(vector_size, a.length() - i);\n        svbool_t pg = svwhilelt_b8(i, a.length());\n\n        // Load input strings into SVE vectors\n        svint8_t vec_a = svld1_s8(pg, reinterpret_cast<const int8_t*>(a.data() + i));\n        svint8_t vec_b = svld1_s8(pg, reinterpret_cast<const int8_t*>(b.data() + i));\n\n        // Perform bitwise XOR\n        svint8_t vec_result = sveor_s8_z(pg, vec_a, vec_b);\n\n        // Convert SVE vector back to characters\n        for (size_t j = 0; j < remaining; ++j) {\n            result[i + j] = (vec_result[j] == 1) ? '1' : '0';\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    // Ensure input strings are of equal length\n    if (a.length() != b.length()) {\n        throw std::invalid_argument(\"Input strings must be of equal length\");\n    }\n\n    std::string result(a.length(), '0');\n    size_t n = a.length();\n\n    // Process vector-sized chunks\n    size_t vec_size = svcntb();\n    size_t i = 0;\n    for (; i + vec_size <= n; i += vec_size) {\n        // Load input strings into SVE vectors\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t va = svld1_u8(pg, reinterpret_cast<const uint8_t*>(a.data() + i));\n        svuint8_t vb = svld1_u8(pg, reinterpret_cast<const uint8_t*>(b.data() + i));\n\n        // Perform bitwise XOR\n        svuint8_t vxor = sveor_u8_x(pg, va, vb);\n\n        // Store result back\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), vxor);\n    }\n\n    // Handle remaining elements\n    for (; i < n; ++i) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b64();\n    svint64_t max_length_vec = svdup_n_s64(0);\n    svint64_t max_index_vec = svdup_n_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svint64_t indices = svindex_s64(i, 1);\n        svint64_t lengths = svdup_n_s64(0);\n\n        // Compute lengths for current vector chunk\n        for (size_t j = i; j < std::min(i + svcntd(), n); ++j) {\n            svint64_t curr_length = svdup_n_s64(strings[j].length());\n            svbool_t mask = svcmplt_n_s64(pg, indices, svdup_n_s64(n));\n            lengths = svsel_s64(mask, curr_length, lengths);\n            indices = svadd_n_s64_x(pg, indices, 1);\n        }\n\n        // Compare and update max length and index\n        svbool_t mask = svcmpgt_s64(pg, lengths, max_length_vec);\n        max_length_vec = svsel_s64(mask, lengths, max_length_vec);\n        max_index_vec = svsel_s64(mask, svindex_s64(i, 1), max_index_vec);\n    }\n\n    // Find the maximum index\n    int64_t max_index = svaddv_s64(pg, max_index_vec);\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine vector length\n    size_t vec_len = svcntw();\n\n    // Process strings in vector chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine active elements\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        \n        // Load string lengths\n        svint32_t lengths = svld1_gather_index_s32(pg, strings.data(), \n            [](const std::string& s) { return static_cast<int32_t>(s.length()); });\n        \n        // Find max length in current vector chunk\n        svint32_t max_vec_lengths = svmaxv_s32(pg, lengths);\n        int32_t chunk_max_length = svlasta_s32(pg, max_vec_lengths);\n        \n        // Update global max if needed\n        if (chunk_max_length > max_length) {\n            // Find index of max length string in this chunk\n            svbool_t max_mask = svcmpeq_s32(pg, lengths, svdup_s32(chunk_max_length));\n            size_t local_max_index = svfirst_u32(max_mask, pg);\n            max_length = chunk_max_length;\n            max_index = i + local_max_index;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b64();\n    svint64_t max_length = svdup_n_s64(0);\n    svint64_t max_index = svdup_n_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        svint64_t indices = svindex_s64(i, 1);\n        svbool_t mask = svcmplt_n_s64(pg, indices, n);\n        \n        svint64_t lengths = svdup_n_s64(0);\n        for (size_t j = 0; j < svcntd(); ++j) {\n            if (i + j < n) {\n                lengths = svsel_s64(svptrue_b64(), \n                                    svdup_n_s64(strings[i + j].length()), \n                                    lengths);\n            }\n        }\n\n        svbool_t longer_mask = svcmpgt_s64(pg, lengths, max_length);\n        max_length = svsel_s64(longer_mask, lengths, max_length);\n        max_index = svsel_s64(longer_mask, indices, max_index);\n    }\n\n    int64_t result_index = svaddv_s64(pg, max_index);\n    return strings[result_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    svbool_t pg = svptrue_b64();\n    \n    // Initialize max length and index\n    svint64_t max_lengths = svdup_n_s64(0);\n    svint64_t max_indices = svdup_n_s64(0);\n\n    for (size_t i = 0; i < n; i += svcntd()) {\n        // Determine active lanes\n        svbool_t p = svwhilelt_b64_u64(i, n);\n        \n        // Load string lengths\n        svint64_t lengths = svdup_n_s64(0);\n        for (size_t j = i; j < std::min(i + svcntd(), n); ++j) {\n            svint64_t lane_length = svdup_n_s64(strings[j].length());\n            svsel_s64(svptrue_b64(), lane_length, lengths);\n        }\n\n        // Compare lengths and update max\n        svbool_t mask = svcmpgt_s64(pg, lengths, max_lengths);\n        max_lengths = svsel_s64(mask, lengths, max_lengths);\n        max_indices = svsel_s64(mask, svdup_n_s64(i), max_indices);\n    }\n\n    // Find the index of the maximum length\n    int64_t max_index = svaddv_s64(pg, max_indices);\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    // Determine vector length\n    size_t vec_len = svcntw();\n\n    // Process strings in vector chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine number of elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load string lengths\n        svint32_t lengths = svdup_n_s32(0);\n        for (size_t j = 0; j < remaining; ++j) {\n            lengths = svset_s32(lengths, svptrue_b32(), j, strings[i + j].length());\n        }\n\n        // Find max length in current vector\n        svint32_t max_vec_lengths = svmaxv_s32(pg, lengths);\n        int32_t current_max_length = svlastb_s32(pg, max_vec_lengths);\n\n        // Update global max if needed\n        if (current_max_length > max_length) {\n            max_length = current_max_length;\n            \n            // Find index of first string with max length\n            for (size_t j = 0; j < remaining; ++j) {\n                if (strings[i + j].length() == max_length) {\n                    max_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    while (svptest_any(pg, svcmpne_u64(pg, va, vb))) {\n        svbool_t gt_mask = svcmpgt_u64(pg, va, vb);\n        va = svsel_u64(gt_mask, \n                       svsub_u64_z(pg, va, vb), \n                       va);\n        vb = svsel_u64(gt_mask, \n                       vb, \n                       svsub_u64_z(pg, vb, va));\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    while (svptest_any(pg, svcmpne_u64(pg, va, vb))) {\n        svbool_t gt_mask = svcmpgt_u64(pg, va, vb);\n        va = svsel_u64(gt_mask, \n                       svsub_u64_z(pg, va, vb), \n                       va);\n        vb = svsel_u64(gt_mask, \n                       vb, \n                       svsub_u64_z(pg, vb, va));\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    while (svptest_any(pg, svcmpne_u64(pg, va, vb))) {\n        svbool_t gt_mask = svcmpgt_u64(pg, va, vb);\n        va = svsel_u64(gt_mask, \n                       svsub_u64_z(pg, va, vb), \n                       va);\n        vb = svsel_u64(gt_mask, \n                       vb, \n                       svsub_u64_z(pg, vb, va));\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    while (svptest_any(pg, svcmpne_u64(pg, va, vb))) {\n        svbool_t gt_mask = svcmpgt_u64(pg, va, vb);\n        va = svsel_u64(gt_mask, \n                       svsub_u64_z(pg, va, vb), \n                       va);\n        vb = svsel_u64(gt_mask, \n                       vb, \n                       svsub_u64_z(pg, vb, va));\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    while (svptest_any(pg, svcmpne_u64(pg, va, vb))) {\n        svbool_t cmp = svcmpgt_u64(pg, va, vb);\n        va = svsel_u64(cmp, svsub_u64_x(pg, va, vb), va);\n        vb = svsel_cond_u64(cmp, vb, svsub_u64_x(pg, vb, va));\n    }\n\n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remain = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load current vector\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            size_t remain_j = std::min(vec_len, n - j);\n            svbool_t pg_j = svwhilelt_b32(j, n);\n\n            // Load comparison vector\n            svfloat32_t compare_vec = svld1_f32(pg_j, &numbers[j]);\n\n            // Compute absolute differences\n            svfloat32_t diffs = svabs_f32_z(pg, svrsub_f32_z(pg, current_vec, compare_vec));\n\n            // Find minimum difference in vector\n            float local_min_diff = svminval_f32(pg, diffs, NULL);\n\n            // Update global minimum if needed\n            if (local_min_diff < min_diff) {\n                // Find indices of minimum difference elements\n                for (size_t k = 0; k < remain; ++k) {\n                    for (size_t l = 0; l < remain_j; ++l) {\n                        float diff = std::abs(numbers[i + k] - numbers[j + l]);\n                        if (diff < min_diff) {\n                            min_diff = diff;\n                            closest_a = std::min(numbers[i + k], numbers[j + l]);\n                            closest_b = std::max(numbers[i + k], numbers[j + l]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n\n        // Load current vector\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            size_t remaining_inner = std::min(vec_len, n - j);\n            svbool_t pg_inner = svwhilelt_b32_u64(j, n);\n\n            // Load comparison vector\n            svfloat32_t compare_vec = svld1_f32(pg_inner, &numbers[j]);\n\n            // Compute absolute differences\n            svfloat32_t diff_vec = svabs_f32_z(pg, svfsub_f32_z(pg, current_vec, compare_vec));\n\n            // Find minimum difference\n            svfloat32_t min_diff_vec = svminv_f32(pg, diff_vec);\n            float current_min_diff = svfminv_f32(pg, diff_vec);\n\n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                \n                // Find indices of closest elements\n                for (size_t k = 0; k < remaining; ++k) {\n                    for (size_t l = 0; l < remaining_inner; ++l) {\n                        float a = numbers[i + k];\n                        float b = numbers[j + l];\n                        if (std::abs(a - b) == min_diff) {\n                            closest_a = std::min(a, b);\n                            closest_b = std::max(a, b);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load current vector\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            size_t remaining_j = std::min(vec_len, n - j);\n            svbool_t pg_j = svwhilelt_b32(j, n);\n\n            // Load comparison vector\n            svfloat32_t compare_vec = svld1_f32(pg_j, &numbers[j]);\n\n            // Compute absolute differences\n            svfloat32_t diff_vec = svabs_f32_z(pg, svsub_f32_z(pg, current_vec, compare_vec));\n\n            // Find minimum difference in vector\n            float local_min_diff = svminval_f32(pg, diff_vec);\n\n            // Update global minimum if needed\n            if (local_min_diff < min_diff) {\n                min_diff = local_min_diff;\n\n                // Find indices of closest elements\n                for (size_t k = 0; k < remaining; ++k) {\n                    for (size_t l = 0; l < remaining_j; ++l) {\n                        float diff = std::abs(numbers[i + k] - numbers[j + l]);\n                        if (diff == min_diff) {\n                            closest_a = std::min(numbers[i + k], numbers[j + l]);\n                            closest_b = std::max(numbers[i + k], numbers[j + l]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n\n        // Load current vector\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            size_t remaining_inner = std::min(vec_len, n - j);\n            svbool_t pg_inner = svwhilelt_b32_u64(j, n);\n\n            // Load comparison vector\n            svfloat32_t compare_vec = svld1_f32(pg_inner, &numbers[j]);\n\n            // Compute absolute differences\n            svfloat32_t diff_vec = svabs_f32_z(pg, svfsub_f32_z(pg, current_vec, compare_vec));\n\n            // Find minimum difference\n            svfloat32_t min_diff_vec = svminv_f32(pg, diff_vec);\n            float current_min_diff = svgetflt(min_diff_vec);\n\n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                \n                // Find indices of closest elements\n                for (size_t k = 0; k < remaining; ++k) {\n                    for (size_t l = 0; l < remaining_inner; ++l) {\n                        float a = numbers[i + k];\n                        float b = numbers[j + l];\n                        if (std::abs(a - b) == min_diff) {\n                            closest_a = std::min(a, b);\n                            closest_b = std::max(a, b);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float closest_a = numbers[0], closest_b = numbers[1];\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load current vector\n        svfloat32_t current_vec = svld1_f32(pg, &numbers[i]);\n\n        for (size_t j = i + 1; j < n; j += vec_len) {\n            size_t remaining_inner = std::min(vec_len, n - j);\n            svbool_t pg_inner = svwhilelt_b32(j, n);\n\n            // Load comparison vector\n            svfloat32_t compare_vec = svld1_f32(pg_inner, &numbers[j]);\n\n            // Compute absolute differences\n            svfloat32_t diff_vec = svabs_f32_z(pg, svfsub_f32_z(pg, current_vec, compare_vec));\n\n            // Find minimum difference\n            svfloat32_t min_diff_vec = svminv_f32(pg, diff_vec);\n            float current_min_diff = svlastb_f32(pg, min_diff_vec);\n\n            // Update if smaller difference found\n            if (current_min_diff < min_diff) {\n                min_diff = current_min_diff;\n                \n                // Find indices of closest elements\n                for (size_t k = 0; k < remaining; ++k) {\n                    for (size_t l = 0; l < remaining_inner; ++l) {\n                        float diff = std::abs(numbers[i + k] - numbers[j + l]);\n                        if (diff == min_diff) {\n                            closest_a = std::min(numbers[i + k], numbers[j + l]);\n                            closest_b = std::max(numbers[i + k], numbers[j + l]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {closest_a, closest_b};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t vector_size = numbers.size();\n    std::vector<float> result(vector_size);\n\n    // Find vector length for SVE\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        size_t remaining = vector_size - i;\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n        \n        // Find min and max in the chunk\n        svfloat32_t chunk_min = svminv_f32(pg, vec);\n        svfloat32_t chunk_max = svmaxv_f32(pg, vec);\n        \n        // Compute scaling factor\n        svfloat32_t scale = svsub_f32_z(pg, chunk_max, chunk_min);\n        \n        // Linear transform: (x - min) / (max - min)\n        svfloat32_t transformed = sfdiv_f32_z(pg, \n            svsub_f32_z(pg, vec, chunk_min), \n            scale\n        );\n        \n        // Store result\n        svst1_f32(pg, &result[i], transformed);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t vector_size = numbers.size();\n    std::vector<float> result(vector_size);\n\n    // Determine vector length for SVE\n    size_t sve_vector_length = svcntw();\n\n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        size_t remaining = vector_size - i;\n        size_t current_chunk_size = std::min(remaining, sve_vector_length);\n\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n\n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n\n        // Find min and max values in the chunk\n        svfloat32_t min_val = svminv_f32(pg, vec);\n        svfloat32_t max_val = svmaxv_f32(pg, vec);\n\n        // Compute scaling factor\n        svfloat32_t scale = svdiv_f32_z(pg, svdup_f32(1.0f), svfsub_f32_z(pg, max_val, min_val));\n\n        // Apply linear transformation\n        svfloat32_t transformed = svmul_f32_z(pg, svfsub_f32_z(pg, vec, min_val), scale);\n\n        // Store results back to output vector\n        svst1_f32(pg, &result[i], transformed);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t vector_size = numbers.size();\n    std::vector<float> result(vector_size);\n\n    // Find vector length for SVE\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(sve_vector_length, vector_size - i);\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n\n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n\n        // Find min and max in the chunk\n        svfloat32_t min_vec = svminv_f32(pg, vec);\n        svfloat32_t max_vec = svmaxv_f32(pg, vec);\n        float min_val = svfminv_f32(pg, vec);\n        float max_val = svfmaxv_f32(pg, vec);\n\n        // Compute scaling factor\n        float scale = max_val - min_val;\n        svfloat32_t scaled_vec = svdiv_f32_z(pg, svsubr_f32_z(pg, vec, svdup_f32(min_val)), svdup_f32(scale));\n\n        // Store result\n        svst1_f32(pg, &result[i], scaled_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t vector_size = numbers.size();\n    std::vector<float> result(vector_size);\n\n    // Find vector length for SVE\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(sve_vector_length, vector_size - i);\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n\n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n\n        // Find min and max values in the chunk\n        svfloat32_t min_val = svmin_f32_z(pg, vec, vec);\n        svfloat32_t max_val = svmax_f32_z(pg, vec, vec);\n\n        // Broadcast min and max to all lanes\n        min_val = svdup_f32_z(pg, svfirst_f32(min_val, pg));\n        max_val = svdup_f32_z(pg, svfirst_f32(max_val, pg));\n\n        // Compute range\n        svfloat32_t range = svsub_f32_z(pg, max_val, min_val);\n\n        // Rescale vector\n        svfloat32_t rescaled = svdiv_f32_z(pg, \n            svsub_f32_z(pg, vec, min_val), \n            range\n        );\n\n        // Store result\n        svst1_f32(pg, &result[i], rescaled);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t vector_size = numbers.size();\n    std::vector<float> result(vector_size);\n\n    // Determine vector length for SVE\n    size_t sve_vector_length = svcntw();\n\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        \n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n\n        // Load vector segment\n        svfloat32_t vec = svld1_f32(pg, &numbers[i]);\n\n        // Find min and max values\n        svfloat32_t min_val = svminv_f32(pg, vec);\n        svfloat32_t max_val = svmaxv_f32(pg, vec);\n\n        // Compute scaling factor\n        svfloat32_t scale = svdiv_f32_z(pg, svdup_f32_z(pg, 1.0f), svfsub_f32_z(pg, max_val, min_val));\n\n        // Apply linear transformation\n        svfloat32_t transformed = svmul_f32_z(pg, \n            svfsub_f32_z(pg, vec, min_val), \n            scale\n        );\n\n        // Store result back\n        svst1_f32(pg, &result[i], transformed);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // If n is 1, return 1\n    if (n <= 1) return 1;\n\n    // Get the vector length for uint64_t\n    size_t vec_len = svcntd();\n\n    // Create a vector of indices from 1 to vec_len\n    svbool_t pg = svptrue_b64();\n    svuint64_t indices = svindex_u64(1, 1);\n\n    // Find the largest divisor in parallel\n    for (uint64_t i = 1; i < n; i += vec_len) {\n        // Create a predicate to mask out values beyond n\n        svbool_t p = svcmple_n_u64(pg, indices, n);\n\n        // Check divisibility in parallel\n        svuint64_t remainder = svmod_n_u64_z(p, indices, n);\n        svbool_t divisible = svcmpeq_n_u64_z(p, remainder, 0);\n\n        // If any divisors found, update indices\n        if (svptest_any(pg, divisible)) {\n            indices = svsel_u64(divisible, indices, svdup_n_u64(0));\n        }\n    }\n\n    // Find the maximum divisor\n    svuint64_t max_divisor = svmaxv_u64(pg, indices);\n    return svlastb_u64(pg, max_divisor);\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // If n is 1, return 1\n    if (n <= 1) return 1;\n\n    // Determine vector length\n    size_t vec_len = svcntd();\n    \n    // Create predicate for active lanes\n    svbool_t pg = svptrue_b64();\n    \n    // Initialize vector with candidate divisors\n    svuint64_t candidates = svindex_u64(1, 1);\n    \n    // Mask to track valid divisors\n    svbool_t divisor_mask = svcmpeq_n_u64(pg, svmod_u64_z(pg, candidates, n), 0);\n    \n    // Find largest divisor using vector comparison\n    svuint64_t max_divisors = svmax_u64_z(pg, candidates, svsel_u64(divisor_mask, candidates, svdup_u64(0)));\n    \n    // Reduce to find the maximum divisor\n    uint64_t result = svmaxv_u64(pg, max_divisors);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // If n is 1, return 1\n    if (n <= 1) return 1;\n\n    // Get the vector length for SVE\n    size_t vec_len = svcntd();\n    \n    // Create predicate for active elements\n    svbool_t pg = svptrue_b64();\n    \n    // Initialize vector with sequence 1, 2, 3, ...\n    svint64_t vec_divisors = svindex_s64(1, 1);\n    \n    // Mask to track valid divisors\n    svbool_t valid_mask = svcmple_n_s64(pg, vec_divisors, n);\n    \n    // Mask to track divisors that divide n evenly\n    svbool_t divisible_mask = svreinterpret_b64_u64(\n        svcmpeq_n_u64(\n            svreinterpret_u64_s64(\n                svmod_n_s64_z(valid_mask, vec_divisors, n)\n            ), \n            0\n        )\n    );\n    \n    // Combine masks\n    svbool_t result_mask = svand_b_z(pg, valid_mask, divisible_mask);\n    \n    // Find the maximum valid divisor\n    svint64_t max_divisors = svmax_s64_z(result_mask, vec_divisors, vec_divisors);\n    \n    // Reduce to scalar max\n    uint64_t result = svmaxv_s64(pg, max_divisors);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // If n is 1, return 1\n    if (n <= 1) return 1;\n\n    // Get the vector length\n    size_t vec_len = svcntd();\n    \n    // Create predicate for active elements\n    svbool_t pg = svptrue_b64();\n    \n    // Initialize vector with sequence from 1 to vector length\n    svuint64_t vec_divisors = svindex_u64(1, 1);\n    \n    // Mask to track valid divisors\n    svbool_t valid_mask = svcmple_n_u64(pg, vec_divisors, n);\n    \n    // Find divisors in vector\n    svuint64_t divisors = svcompact_u64(valid_mask, vec_divisors);\n    \n    // Compute modulo for each potential divisor\n    svuint64_t modulo = svmod_n_u64_z(pg, n, divisors);\n    \n    // Find indices where modulo is zero (exact divisors)\n    svbool_t divisor_mask = svcmpeq_n_u64_z(pg, modulo, 0);\n    \n    // Compact divisors\n    svuint64_t exact_divisors = svcompact_u64(divisor_mask, divisors);\n    \n    // Find max divisor\n    uint64_t max_divisor = svmaxv_u64(pg, exact_divisors);\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    // If n is 1, return 1\n    if (n <= 1) return 1;\n\n    // Predicate vector to track active lanes\n    svbool_t pg = svptrue_b64();\n    \n    // Create vector of indices from 1 to n-1\n    svuint64_t indices = svindex_u64(1, 1);\n    \n    // Create vector of n values\n    svuint64_t n_vec = svdup_u64_z(pg, n);\n    \n    // Compute modulo using SVE intrinsics\n    svuint64_t mod_results = svmod_u64_z(pg, n_vec, indices);\n    \n    // Compare mod results to zero (divisibility check)\n    svbool_t divisible_mask = svcmpeq_u64(pg, mod_results, svdup_u64_z(pg, 0));\n    \n    // Find the maximum divisor\n    svuint64_t divisors = svsel_u64(divisible_mask, indices, svdup_u64_z(pg, 0));\n    \n    // Reduce to find the largest divisor\n    uint64_t largest = svredmax_u64(pg, divisors);\n    \n    return largest;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // SVE vector predicate and length\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n    \n    // Start with smallest prime factor 2\n    int factor = 2;\n    \n    while (n > 1) {\n        // Create SVE vector of current factor\n        svint32_t factor_vec = svdup_n_s32(factor);\n        \n        // Check if factor divides n\n        while (n % factor == 0) {\n            // Append factor to result vector\n            factors.push_back(factor);\n            n /= factor;\n        }\n        \n        // Move to next potential factor\n        factor++;\n        \n        // Optional optimization: skip even numbers after 2\n        if (factor == 4) factor++;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Get vector length\n    size_t vec_len = svcntw();\n    \n    // Predicate for active lanes\n    svbool_t pg = svptrue_b32();\n    \n    // Initial divisor\n    int divisor = 2;\n    \n    while (n > 1) {\n        // Vectorized divisibility check\n        svint32_t vec_divisor = svdup_n_s32(divisor);\n        svint32_t vec_n = svdup_n_s32(n);\n        \n        // Check if divisor divides n\n        svbool_t div_mask = svcmpeq_n_s32(pg, svmod_s32_z(pg, vec_n, vec_divisor), 0);\n        \n        if (svptest_any(pg, div_mask)) {\n            // Divide n by divisor\n            n /= divisor;\n            factors.push_back(divisor);\n        } else {\n            // Increment divisor\n            divisor++;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Get vector length\n    size_t vec_len = svcntw();\n    \n    // Create predicate vector\n    svbool_t pg = svptrue_b32();\n    \n    // Initialize divisor\n    int divisor = 2;\n    \n    while (n > 1) {\n        // Create vector of divisors\n        svint32_t divisor_vec = svdup_n_s32(divisor);\n        \n        // Check if divisor divides n\n        while (n % divisor == 0) {\n            // Add divisor to factors\n            factors.push_back(divisor);\n            n /= divisor;\n        }\n        \n        // Increment divisor\n        divisor++;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Get vector length\n    size_t vec_len = svcntw();\n    \n    // Create predicate vector for active lanes\n    svbool_t pg = svptrue_b32();\n    \n    // Start with smallest prime factor 2\n    int factor = 2;\n    \n    while (n > 1) {\n        // Create vector of current factor\n        svint32_t factor_vec = svdup_n_s32(factor);\n        \n        // Check if factor divides n\n        while (n % factor == 0) {\n            // Predicated store of factor into result vector\n            factors.push_back(factor);\n            n /= factor;\n        }\n        \n        // Move to next potential factor\n        factor++;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Get vector length\n    size_t vec_len = svcntw();\n    \n    // Create predicate for active lanes\n    svbool_t pg = svptrue_b32();\n    \n    // Start with smallest prime factor 2\n    int factor = 2;\n    \n    while (n > 1) {\n        // Create vector of current factor\n        svint32_t factor_vec = svdup_n_s32(factor);\n        \n        // Check divisibility in parallel\n        while (n % factor == 0) {\n            // Scatter factor into result vector\n            factors.push_back(factor);\n            n /= factor;\n        }\n        \n        // Move to next potential factor\n        factor++;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    \n    // Get the SVE vector length for float\n    size_t vector_length = svcntw();\n    \n    // Process input vector in SVE vector-sized chunks\n    for (size_t i = 0; i < l.size(); i += vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vector_length, l.size() - i);\n        \n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        \n        // Load input vector chunk\n        svfloat32_t input_vec = svld1_f32(pg, &l[i]);\n        \n        // Create predicate for positive numbers\n        svbool_t positive_pred = svcmpgt_f32(pg, input_vec, svdup_f32(0.0f));\n        \n        // Select only positive numbers\n        svfloat32_t positive_vec = svsel_f32(positive_pred, input_vec, svdup_f32(0.0f));\n        \n        // Compress positive numbers\n        svfloat32_t compressed_vec = svcompact_f32(positive_pred, positive_vec);\n        \n        // Store compressed positive numbers\n        float temp_buffer[vector_length];\n        svst1_f32(pg, temp_buffer, compressed_vec);\n        \n        // Count number of positive elements\n        uint64_t count = svcntp_b32(pg, positive_pred);\n        \n        // Add positive elements to result\n        for (size_t j = 0; j < count; ++j) {\n            if (temp_buffer[j] > 0) {\n                result.push_back(temp_buffer[j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    \n    // Process the input vector in SVE vector chunks\n    for (size_t i = 0; i < l.size(); i += svcntw()) {\n        // Determine the number of active elements in this chunk\n        svbool_t pg = svwhilelt_b32_u64(i, l.size());\n        \n        // Load the vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create a predicate for positive numbers\n        svbool_t positive_pred = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Select only positive numbers\n        svfloat32_t positive_vec = svsel_f32(positive_pred, vec, svdup_f32(0.0f));\n        \n        // Compress the vector to only positive numbers\n        svfloat32_t compressed_vec = svcompact_f32(positive_pred, positive_vec);\n        \n        // Store the positive numbers\n        size_t num_positive = svcntp_b32(pg, positive_pred);\n        float temp_buffer[svcntw()];\n        svst1_f32(pg, temp_buffer, compressed_vec);\n        \n        // Add positive numbers to result\n        for (size_t j = 0; j < num_positive; ++j) {\n            if (temp_buffer[j] > 0) {\n                result.push_back(temp_buffer[j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    \n    // Determine the SVE vector length for float\n    const int vector_bytes = svcntw() * sizeof(float);\n    \n    // Process vector in SVE vector-sized chunks\n    for (size_t i = 0; i < l.size(); i += vector_bytes) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create predicate for positive numbers\n        svbool_t positive_pred = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Select only positive numbers\n        svfloat32_t positive_vec = svsel_f32(positive_pred, vec, svdup_f32(0.0f));\n        \n        // Store and append positive numbers to result\n        float temp[vector_bytes];\n        svst1_f32(pg, temp, positive_vec);\n        \n        for (int j = 0; j < vector_bytes; ++j) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    \n    // Determine the SVE vector length for float\n    const int vector_bytes = svcntw() * sizeof(float);\n    \n    for (size_t i = 0; i < l.size(); i += vector_bytes) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, l.size());\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create predicate for positive numbers\n        svbool_t positive_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Select only positive numbers\n        svfloat32_t positive_vec = svsel_f32(positive_mask, vec, svdup_f32(0.0f));\n        \n        // Store and compress non-zero elements\n        float temp[vector_bytes];\n        svst1_f32(pg, temp, positive_vec);\n        \n        // Add non-zero elements to result\n        for (int j = 0; j < vector_bytes; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    \n    // Determine the SVE vector length for float\n    const int vector_bytes = svcntw() * sizeof(float);\n    \n    // Process vector in SVE vector-sized chunks\n    for (size_t i = 0; i < l.size(); i += vector_bytes) {\n        // Determine the number of active elements in this iteration\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create predicate for positive numbers (> 0)\n        svbool_t positive_pred = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Compress only positive numbers\n        svfloat32_t positive_vec = svcompact_f32(positive_pred, vec);\n        \n        // Store positive numbers\n        size_t num_positive = svcntp_b32(pg, positive_pred);\n        for (size_t j = 0; j < num_positive; ++j) {\n            result.push_back(svgetlane_f32(positive_vec, j));\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    \n    svint64_t divisors = svindex_s64(3, 2);\n    \n    do {\n        svint64_t remainder = svrmod_s64_z(pg, svdup_s64(n), divisors);\n        svbool_t is_divisible = svcmpeq_s64(pg, remainder, svdup_s64(0));\n        \n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n        \n        divisors = svadd_s64_z(pg, divisors, svdup_s64(2));\n        pg = svwhilelt_b64(svpnext_b64(pg), sqrt_n + 1);\n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    \n    svint64_t divisors = svindex_s64(3, 2);\n    \n    do {\n        svint64_t remainder = svrmod_s64_z(pg, svdup_s64(n), divisors);\n        svbool_t is_divisible = svcmpeq_s64(pg, remainder, svdup_s64(0));\n        \n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n        \n        divisors = svadd_s64_z(pg, divisors, svdup_s64(2));\n        pg = svwhilelt_b64(svpnext_b64(pg), sqrt_n + 1);\n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    \n    svint64_t divisors = svindex_s64(3, 2);\n    \n    do {\n        svint64_t remainder = svrmod_s64_z(pg, svdup_s64(n), divisors);\n        svbool_t is_divisible = svcmpeq_s64(pg, remainder, svdup_s64(0));\n        \n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n        \n        divisors = svadd_s64_z(pg, divisors, svdup_s64(2));\n        pg = svwhilelt_b64(svpnext_b64(pg), sqrt_n + 1);\n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    \n    svint64_t divisors = svindex_s64(3, 2);\n    \n    do {\n        svint64_t remainder = svrems_s64_z(pg, n, divisors);\n        svbool_t zero_mask = svcmpeq_s64(pg, remainder, 0);\n        \n        if (svptest_any(pg, zero_mask)) {\n            return false;\n        }\n        \n        divisors = svadd_s64_z(pg, divisors, 2);\n        pg = svwhilelt_b64(svpnext_s64(pg), sqrt_n + 1);\n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n));\n    svbool_t pg = svwhilelt_b64(3, sqrt_n + 1);\n    \n    svint64_t divisors = svindex_s64(3, 2);\n    \n    do {\n        svint64_t remainder = svrem_s64_z(pg, svdup_s64(n), divisors);\n        svbool_t is_divisible = svcmpeq_s64(pg, remainder, svdup_s64(0));\n        \n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n        \n        divisors = svadd_s64_z(pg, divisors, svdup_s64(2));\n        pg = svwhilelt_b64(svpnext_b64(pg), sqrt_n + 1);\n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if the string contains any letters\n    bool has_letters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        // Reverse the entire string if no letters\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Use SVE to process the string\n    size_t vector_size = svcntb(); // Get SVE vector size in bytes\n    \n    for (size_t i = 0; i < n; i += vector_size) {\n        size_t remaining = std::min(vector_size, n - i);\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n\n        // Check for uppercase letters\n        svbool_t is_upper = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_upper_end = svcmple_n_s8(pg, chars, 'Z');\n        svbool_t is_upper_letter = svand_z(pg, is_upper, is_upper_end);\n\n        // Check for lowercase letters\n        svbool_t is_lower = svcmpge_n_s8(pg, chars, 'a');\n        svbool_t is_lower_end = svcmple_n_s8(pg, chars, 'z');\n        svbool_t is_lower_letter = svand_z(pg, is_lower, is_lower_end);\n\n        // Swap case for letters\n        svint8_t case_swap = svdup_n_s8(32);\n        svint8_t swapped_chars = svsel_s8(is_upper_letter, svadd_s8_z(pg, chars, case_swap), \n                                          svsel_s8(is_lower_letter, svsub_s8_z(pg, chars, case_swap), chars));\n\n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), swapped_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t len = s.length();\n    bool has_letter = false;\n\n    // Check if string contains any letters\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    // If no letters, reverse the entire string\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Process string using SVE\n    size_t vector_size = svcntb();\n    for (size_t i = 0; i < len; i += vector_size) {\n        size_t remaining = std::min(vector_size, len - i);\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n\n        // Check for lowercase letters\n        svbool_t is_lower = svcmple_n_s8(pg, chars, 'z');\n        svbool_t is_lower_range = svcmpge_n_s8(pg, chars, 'a');\n        svbool_t is_lower_letter = svand_z(pg, is_lower, is_lower_range);\n\n        // Check for uppercase letters\n        svbool_t is_upper = svcmple_n_s8(pg, chars, 'Z');\n        svbool_t is_upper_range = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_upper_letter = svand_z(pg, is_upper, is_upper_range);\n\n        // Swap case\n        svint8_t swapped_chars = chars;\n        swapped_chars = svsel_s8(is_lower_letter, svsub_n_s8_z(pg, chars, 32), swapped_chars);\n        swapped_chars = svsel_s8(is_upper_letter, svadd_n_s8_z(pg, chars, 32), swapped_chars);\n\n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), swapped_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if the string contains no letters\n    bool has_letters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Use SVE to process the string in parallel\n    size_t vector_size = svcntb();\n    for (size_t i = 0; i < n; i += vector_size) {\n        size_t remaining = std::min(vector_size, n - i);\n        svbool_t pg = svwhilelt_b8(i, n);\n\n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n\n        // Check for alphabetic characters\n        svbool_t is_alpha = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_lower = svcmpge_n_s8(pg, chars, 'a');\n        svbool_t is_upper = svcmplt_n_s8(pg, chars, 'a');\n\n        // Swap case for alphabetic characters\n        svint8_t swapped_chars = chars;\n        svint8_t case_diff = svdup_n_s8(32);\n        swapped_chars = svsel_s8(svand_z(pg, is_lower, is_alpha), svAdd_s8(pg, chars, case_diff), swapped_chars);\n        swapped_chars = svsel_s8(svand_z(pg, is_upper, is_alpha), svSub_s8(pg, chars, case_diff), swapped_chars);\n\n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), swapped_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t len = s.length();\n    \n    // Check if any letters exist\n    bool has_letters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    // If no letters, reverse the entire string\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Use SVE to process characters in parallel\n    size_t vector_size = svcntb();\n    for (size_t i = 0; i < len; i += vector_size) {\n        svbool_t pg = svwhilelt_b8_u64(i, len);\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n\n        // Check for alphabetic characters\n        svbool_t is_alpha = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_lower_upper = svcmpge_n_s8(pg, chars, 'a');\n        svbool_t is_letter = svand_z(pg, is_alpha, svbool_t_or(svcmple_n_s8(pg, chars, 'Z'), is_lower_upper));\n\n        // Swap case for letters\n        svint8_t case_swapped = svxor_s8_z(is_letter, chars, 32);\n\n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), case_swapped);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) return s;\n\n    std::string result = s;\n    size_t n = s.length();\n    \n    // Check if the string contains no letters\n    bool has_letters = false;\n    for (char c : s) {\n        if (std::isalpha(c)) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    // If no letters, simply reverse the string\n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n        return result;\n    }\n\n    // Use SVE to process the string\n    size_t vector_size = svcntb(); // Get SVE vector size in bytes\n    \n    for (size_t i = 0; i < n; i += vector_size) {\n        size_t remaining = std::min(vector_size, n - i);\n        svbool_t pg = svwhilelt_b8(i, n);\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Check for lowercase letters\n        svbool_t is_lower = svcmpge_n_s8(pg, chars, 'a');\n        svbool_t is_lower_mask = svcmplt_n_s8(pg, chars, '{');\n        svbool_t is_lower_letter = svand_b_z(pg, is_lower, is_lower_mask);\n        \n        // Check for uppercase letters\n        svbool_t is_upper = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_upper_mask = svcmplt_n_s8(pg, chars, '[');\n        svbool_t is_upper_letter = svand_b_z(pg, is_upper, is_upper_mask);\n        \n        // Swap case for lowercase letters\n        svint8_t lower_swap = svsubr_n_s8_z(is_lower_letter, chars, 'A' - 'a');\n        \n        // Swap case for uppercase letters\n        svint8_t upper_swap = svsubr_n_s8_z(is_upper_letter, chars, 'a' - 'A');\n        \n        // Combine swapped characters\n        svint8_t swapped_chars = svsel_s8(is_lower_letter, lower_swap, \n                                          svsel_s8(is_upper_letter, upper_swap, chars));\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), swapped_chars);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n    \n    // Determine the SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine the number of elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        \n        // Create SVE predicates\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load the current vector segment\n        svint32_t current_vec = svld1_z(pg, l.data() + i);\n        \n        // Create a predicate for indices divisible by 3\n        svbool_t divisible_by_3_pred = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, current_vec, 3), 0);\n        \n        // Extract elements divisible by 3\n        svint32_t divisible_by_3_vec = svcompact_s32(divisible_by_3_pred, current_vec);\n        \n        // Sort the extracted elements\n        svint32_t sorted_vec = svsort_s32(divisible_by_3_vec);\n        \n        // Scatter sorted elements back to original indices\n        svint32_t result_vec = svsel_s32(divisible_by_3_pred, sorted_vec, current_vec);\n        \n        // Store the result back to the output vector\n        svst1_z(pg, result.data() + i, result_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(sve_vector_length, vector_size - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector\n        svint32_t vec = svld1_z(pg, l.data() + i);\n        \n        // Create mask for indices divisible by 3\n        svbool_t divisible_by_3_mask = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, vec, 3), 0);\n        \n        // Extract elements divisible by 3\n        svint32_t divisible_by_3_elements = svcompress_s32(pg, vec, divisible_by_3_mask);\n        \n        // Sort these elements\n        svint32_t sorted_elements = svsort_s32(divisible_by_3_elements);\n        \n        // Reconstruct vector with sorted elements at divisible by 3 indices\n        svint32_t result_vec = svsel_s32(divisible_by_3_mask, sorted_elements, vec);\n        \n        // Store result back\n        svst1_z(pg, result.data() + i, result_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        size_t remaining = std::min(sve_vector_length, vector_size - i);\n        \n        // Create predicate for elements divisible by 3\n        svbool_t divisible_by_3_pred = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector segment\n        svint32_t current_vec = svld1_u32(divisible_by_3_pred, l.data() + i);\n        \n        // Create mask for indices divisible by 3\n        svbool_t divisible_mask = svcmpeq_n_u32(divisible_by_3_pred, (svuint32_t)current_vec, 0);\n        divisible_mask = svand_z(divisible_by_3_pred, divisible_mask, \n                                 svcmpeq_n_u32(divisible_by_3_pred, (svuint32_t)current_vec, 0));\n        \n        // Extract elements divisible by 3\n        svint32_t divisible_elements = svcompress_u32(current_vec, divisible_mask);\n        \n        // Sort divisible elements\n        svint32_t sorted_divisible = svsort_u32(divisible_elements);\n        \n        // Merge sorted elements back\n        current_vec = svcompact_u32(divisible_mask, current_vec, sorted_divisible);\n        \n        // Store result\n        svst1_u32(divisible_by_3_pred, result.data() + i, current_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(l);\n\n    // Determine the SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n\n    // Process in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine the number of elements to process in this chunk\n        size_t chunk_size = std::min(sve_vector_length, vector_size - i);\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n\n        // Load the current chunk\n        svint32_t current_chunk = svld1_z(pg, &l[i]);\n\n        // Create a predicate for indices divisible by 3\n        svbool_t divisible_by_3_pred = svdup_b32(false);\n        for (size_t j = 0; j < chunk_size; ++j) {\n            if ((i + j) % 3 == 0) {\n                divisible_by_3_pred = svset_b32(divisible_by_3_pred, j, true);\n            }\n        }\n\n        // Extract elements divisible by 3\n        svint32_t divisible_elements = svcompact_s32(pg, current_chunk, divisible_by_3_pred);\n\n        // Sort the divisible elements\n        svint32_t sorted_divisible = svsort_s32(divisible_elements);\n\n        // Reconstruct the chunk with sorted elements at divisible indices\n        svint32_t result_chunk = current_chunk;\n        result_chunk = svsel_s32(divisible_by_3_pred, sorted_divisible, result_chunk);\n\n        // Store the result back\n        svst1_z(pg, &result[i], result_chunk);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n    \n    // Determine the SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        size_t remaining = std::min(sve_vector_length, vector_size - i);\n        \n        // Create SVE predicates to identify indices divisible by 3\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        svbool_t divisible_by_3_pred = svdup_b_z(pg, 0);\n        \n        for (size_t j = 0; j < remaining; ++j) {\n            if ((i + j) % 3 == 0) {\n                divisible_by_3_pred = svset_b(divisible_by_3_pred, j, 1);\n            }\n        }\n        \n        // Load vector elements\n        svint32_t vec = svld1_z(pg, l.data() + i, remaining);\n        \n        // Extract elements divisible by 3\n        svint32_t divisible_elements = svcompact_s32(divisible_by_3_pred, vec);\n        \n        // Sort the extracted elements\n        svint32_t sorted_elements = svsort_s32(divisible_elements);\n        \n        // Scatter sorted elements back to original indices\n        svst1_scatter_u32index_z(divisible_by_3_pred, result.data() + i, svindex_s32(0, 1), sorted_elements);\n        \n        // Copy non-divisible elements as-is\n        svbool_t non_divisible_pred = svnot_b_z(pg, divisible_by_3_pred);\n        svint32_t non_divisible_elements = svcompress_s32(non_divisible_pred, vec);\n        svst1_scatter_u32index_z(non_divisible_pred, result.data() + i, svindex_s32(0, 1), non_divisible_elements);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    // Determine the vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine the number of active elements\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Reduce max within the vector\n        svfloat32_t max_vec = svmaxv_f32(pg, vec);\n        \n        // Update max value\n        max_val = std::max(max_val, svlastb_f32(pg, max_vec));\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    // Determine the SVE vector length for floats\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    size_t i;\n    for (i = 0; i + vec_len <= n; i += vec_len) {\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Reduce max within the vector chunk\n        svfloat32_t max_vec = svmaxv_f32(pg, vec);\n        \n        // Update max_val if needed\n        max_val = std::max(max_val, svlastb_f32(pg, max_vec));\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    // Determine the SVE vector length for floats\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector chunks\n    size_t i;\n    for (i = 0; i + vec_len <= n; i += vec_len) {\n        // Create predicate for active vector lanes\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Compute max within vector chunk\n        svfloat32_t max_vec = svmax_f32_z(pg, vec, vec);\n        \n        // Reduce max to scalar\n        float chunk_max = svmaxv_f32(pg, vec);\n        \n        // Update global max\n        max_val = std::max(max_val, chunk_max);\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < n; ++i) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    // Determine the SVE vector length for floats\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine the number of active elements in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        \n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Reduce max within the vector chunk\n        svfloat32_t max_vec = svmax_f32_x(pg, vec, vec);\n        \n        // Get the maximum value in the chunk\n        float chunk_max = svmaxv_f32(pg, max_vec);\n        \n        // Update overall maximum\n        max_val = std::max(max_val, chunk_max);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    \n    // Determine the vector length dynamically\n    size_t vec_len = svcntw();\n    \n    // Process vector chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Compute remaining elements\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Load vector chunk\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Reduce max within vector\n        svfloat32_t max_vec = svmaxv_f32(pg, vec);\n        \n        // Update max value\n        max_val = std::max(max_val, svlastb_f32(pg, max_vec));\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec_indices = svindex_s32(i, 1);\n        svbool_t divisible_by_11 = svcmpeq_n_s32(pg, svmod_n_s32(pg, vec_indices, 11), 0);\n        svbool_t divisible_by_13 = svcmpeq_n_s32(pg, svmod_n_s32(pg, vec_indices, 13), 0);\n        svbool_t divisible_mask = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n        \n        svint32_t filtered_nums = svcompact_s32(pg, divisible_mask, vec_indices);\n        \n        svbool_t has_seven = svcmpeq_n_s32(pg, svdiv_n_s32(pg, filtered_nums, 10), 7);\n        svbool_t has_seven_ones = svcmpeq_n_s32(pg, svmod_n_s32(pg, filtered_nums, 10), 7);\n        svbool_t seven_mask = svorr_b_z(pg, has_seven, has_seven_ones);\n        \n        count += svcnt_b32(pg, seven_mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t divisible_by_11 = svcmpeq_n_s32(pg, svmod_n_s32(pg, indices, 11), 0);\n        svbool_t divisible_by_13 = svcmpeq_n_s32(pg, svmod_n_s32(pg, indices, 13), 0);\n        svbool_t divisible_mask = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n        \n        svint32_t filtered_nums = svcompact_s32(pg, divisible_mask, indices);\n        svint32_t digit_7_mask = svcmpeq_n_s32(pg, svmod_n_s32(pg, filtered_nums, 10), 7);\n        \n        count += svcntp_b32(pg, digit_7_mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t divisible_by_11 = svcmpeq_n_s32(pg, svmod_n_s32(pg, indices, 11), 0);\n        svbool_t divisible_by_13 = svcmpeq_n_s32(pg, svmod_n_s32(pg, indices, 13), 0);\n        svbool_t divisible_mask = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n        \n        svint32_t digits = svdiv_n_s32_z(pg, indices, 10);\n        svint32_t ones = svsub_n_s32_z(pg, indices, svmul_n_s32_z(pg, digits, 10));\n        \n        svbool_t has_seven_ones = svcmpeq_n_s32(pg, ones, 7);\n        svbool_t has_seven_tens = svcmpeq_n_s32(pg, digits, 7);\n        \n        svbool_t has_seven = svorr_b_z(pg, has_seven_ones, has_seven_tens);\n        svbool_t result_mask = svand_b_z(pg, divisible_mask, has_seven);\n        \n        count += svcntp_b32(pg, result_mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t divisible_by_11 = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, indices, 11), 0);\n        svbool_t divisible_by_13 = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, indices, 13), 0);\n        svbool_t divisible_mask = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n        \n        svint32_t filtered_nums = svcompact_s32(pg, divisible_mask, indices);\n        \n        svbool_t has_seven = svcmpeq_n_s32(pg, svdiv_n_s32_z(pg, filtered_nums, 10), 7);\n        svbool_t has_seven_ones = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, filtered_nums, 10), 7);\n        svbool_t seven_mask = svorr_b_z(pg, has_seven, has_seven_ones);\n        \n        count += svcntp_b32(pg, seven_mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t divisible_by_11 = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, indices, 11), 0);\n        svbool_t divisible_by_13 = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, indices, 13), 0);\n        svbool_t divisible_mask = svorr_b_z(pg, divisible_by_11, divisible_by_13);\n        \n        svint32_t filtered_nums = svcompact_s32(pg, divisible_mask, indices);\n        \n        svbool_t has_seven = svcmpeq_n_s32(pg, svdiv_n_s32_z(pg, filtered_nums, 10), 7);\n        svbool_t has_seven_ones = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, filtered_nums, 10), 7);\n        svbool_t seven_mask = svorr_b_z(pg, has_seven, has_seven_ones);\n        \n        count += svcntp_b32(pg, seven_mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Determine vector length\n    size_t vec_len = svcntw();\n    \n    // Allocate result vector\n    std::vector<float> result(n);\n    \n    // Process even indices\n    for (size_t i = 0; i < n; i += 2 * vec_len) {\n        size_t remaining = std::min(vec_len, (n - i) / 2);\n        \n        // Create predicate for even indices\n        svbool_t pg = svwhilelt_b32(0, remaining);\n        \n        // Load even indices\n        svfloat32_t even_vec = svld1_gather_index_f32(pg, l.data() + i, 2);\n        \n        // Sort even indices\n        svfloat32_t sorted_even = svsort_f32(even_vec);\n        \n        // Store sorted even indices back to result\n        svst1_scatter_index_f32(pg, result.data() + i, 2, sorted_even);\n        \n        // Copy odd indices\n        for (size_t j = 0; j < remaining * 2; j += 2) {\n            if (i + j + 1 < n) {\n                result[i + j + 1] = l[i + j + 1];\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n    \n    // Allocate result vector\n    std::vector<float> result(l);\n\n    // Process even indices in parallel\n    for (size_t start = 0; start < n; start += 2 * vec_len) {\n        size_t end = std::min(start + 2 * vec_len, n);\n        \n        // Create predicate for even indices\n        svbool_t pg = svwhilelt_b32_u64(start, end);\n        \n        // Load even indices\n        svfloat32_t even_vec = svld1_gather_index_f32(pg, result.data(), \n            svindex_u32(start + 1, 2));\n        \n        // Sort even indices\n        svfloat32_t sorted_even = svSort_f32(even_vec);\n        \n        // Store sorted even indices back\n        svst1_scatter_index_f32(pg, result.data(), \n            svindex_u32(start + 1, 2), sorted_even);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n    \n    // Allocate result vector\n    std::vector<float> result(l);\n\n    // Process even indices in chunks\n    for (size_t start = 0; start < n; start += 2 * vec_len) {\n        size_t end = std::min(start + 2 * vec_len, n);\n        \n        // Create predicate for even indices in this chunk\n        svbool_t pg = svwhilelt_b32_u64(start, end);\n        \n        // Load even indices\n        svfloat32_t even_vec = svld1_gather_index_f32(pg, l.data(), \n            svindex_u32(start + 1, 2));\n        \n        // Sort even indices\n        svfloat32_t sorted_even = svSort_f32(even_vec);\n        \n        // Store sorted even indices back to result\n        svst1_scatter_index_f32(pg, result.data(), \n            svindex_u32(start + 1, 2), sorted_even);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t vector_size = l.size();\n    \n    // If vector size is less than 2, return original vector\n    if (vector_size < 2) return l;\n    \n    // Determine SVE vector length for floats\n    size_t sve_vector_length = svcntw();\n    \n    // Allocate result vector\n    std::vector<float> result(l);\n    \n    // Process even indices in parallel\n    for (size_t start = 0; start < vector_size; start += 2 * sve_vector_length) {\n        size_t end = std::min(start + 2 * sve_vector_length, vector_size);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32_u64(start, end);\n        \n        // Load even indices\n        svfloat32_t even_vec = svld1_gather_index_f32(pg, l.data(), \n            svindex_u32(start + 1, 2));\n        \n        // Sort even indices\n        svfloat32_t sorted_even = svsort_f32(even_vec);\n        \n        // Store sorted even indices back\n        svst1_scatter_index_f32(pg, result.data(), \n            svindex_u32(start + 1, 2), sorted_even);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Determine vector length for SVE\n    size_t vec_len = svcntw();\n    \n    // Allocate result vector\n    std::vector<float> result(l);\n\n    // Create predicate for even indices\n    svbool_t pg = svptrue_pat_b32(SV_VL2);\n    pg = svbrkb_b_z(svptrue_b32(), pg);\n\n    // Load even elements\n    svfloat32_t even_vec = svld1_gather_index_f32(pg, l.data(), 2);\n\n    // Sort even elements\n    svfloat32_t sorted_even = svsort_f32(even_vec);\n\n    // Store sorted even elements back to even indices\n    svst1_scatter_index_f32(pg, result.data(), 2, sorted_even);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Use SVE vector length\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    // Outer loop with SVE vectorization\n    for (int i = 0; i < n - 2; i++) {\n        // Load first element\n        svint32_t a_vec = svdup_n_s32(l[i]);\n\n        // Inner loop with SVE\n        for (int j = i + 1; j < n - 1; j++) {\n            // Load second element\n            svint32_t b_vec = svdup_n_s32(l[j]);\n\n            // Vectorized search for third element\n            for (int k = j + 1; k < n; k += vec_len) {\n                // Load vector of potential third elements\n                svint32_t c_vec = svld1_s32(pg, &l[k]);\n\n                // Compute sum of first two elements\n                svint32_t sum_ab = svadd_s32_x(pg, a_vec, b_vec);\n\n                // Check if any element in c_vec negates sum_ab\n                svint32_t neg_sum_ab = svneg_s32_x(pg, sum_ab);\n                svbool_t match = svcmpeq_s32(pg, c_vec, neg_sum_ab);\n\n                // If any match found, return true\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Create SVE predicate and vector registers\n    svbool_t pg = svptrue_b32();\n    \n    // Iterate through all possible triples\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Load current vector\n            svint32_t vec = svld1_s32(pg, l.data() + j + 1);\n            \n            // Compute target value needed to sum to zero\n            int target = -(l[i] + l[j]);\n            \n            // Broadcast target value\n            svint32_t target_vec = svdup_s32(pg, target);\n            \n            // Compare vector elements with target\n            svbool_t match = svcmpeq_s32(pg, vec, target_vec);\n            \n            // Check if any element matches\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return false;\n\n    // SVE vector length determination\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    // Outer loop with SVE vectorization\n    for (size_t i = 0; i < n - 2; ++i) {\n        for (size_t j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n\n            // Vectorized search for third element\n            for (size_t k = j + 1; k < n; k += vec_len) {\n                // Load vector of potential third elements\n                svint32_t vec_k = svld1_s32(pg, &l[k]);\n                \n                // Compare if any element equals target\n                svbool_t match = svcmpeq_s32(pg, vec_k, target);\n                \n                // Check if any element matches\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Load vector into SVE register\n    svbool_t pg = svptrue_b32();\n    svint32_t vec = svld1_z(pg, l.data(), n);\n\n    // Nested loop to check all possible triples\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            // Broadcast first two elements\n            svint32_t a = svdup_n_s32(l[i]);\n            svint32_t b = svdup_n_s32(l[j]);\n\n            // Compute complementary value needed to sum to zero\n            svint32_t complement = svneg_s32_z(pg, svadd_s32_z(pg, a, b));\n\n            // Check if complement exists in remaining vector\n            svbool_t match = svcmpeq_s32(pg, vec, complement);\n            uint64_t result = svcntp_b32(pg, match);\n\n            if (result > 0) return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    // Predicate and vector length\n    svbool_t pg = svptrue_b32();\n    size_t vec_len = svcntw();\n\n    // Process vector in chunks\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = -(l[i] + l[j]);\n\n            // Load vector of remaining elements\n            svint32_t vec_k = svld1_gather_index(pg, l.data() + j + 1, svindex_s32(0, 1));\n            \n            // Compare vector elements with target\n            svbool_t match_pred = svcmpeq_n_s32(pg, vec_k, target);\n            \n            // Check if any element matches\n            if (svptest_any(pg, match_pred)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n\n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, vector_size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector chunk\n        svint32_t vec = svld1_z(pg, l.data() + i);\n        \n        // Increment vector chunk\n        svint32_t incremented = svadd_z(pg, vec, svdup_n_s32(1));\n        \n        // Store incremented vector chunk\n        svst1_z(pg, result.data() + i, incremented);\n        \n        // Move to next chunk\n        i += svcntw();\n        pg = svwhilelt_b32(i, vector_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n\n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        \n        // Increment vector elements\n        svint32_t incremented = svadd_s32_z(pg, vec, svdup_s32(1));\n        \n        // Store incremented vector chunk\n        svst1_s32(pg, result.data() + i, incremented);\n        \n        // Update loop variables\n        i += svcntw();\n        pg = svwhilelt_b32_u64(i, vector_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n\n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        \n        // Increment vector chunk\n        svint32_t incremented = svadd_s32_z(pg, vec, svdup_n_s32(1));\n        \n        // Store incremented vector chunk\n        svst1_s32(pg, result.data() + i, incremented);\n        \n        // Move to next chunk\n        i += svcntw();\n        pg = svwhilelt_b32_u64(i, vector_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n\n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector chunk\n        svint32_t vec = svld1_z(pg, l.data() + i);\n        \n        // Increment vector elements\n        svint32_t incremented = svadd_z(pg, vec, svdup_n_s32(1));\n        \n        // Store incremented vector chunk\n        svst1_z(pg, result.data() + i, incremented);\n        \n        // Move to next chunk\n        i += svcntw();\n        pg = svwhilelt_b32_u64(i, vector_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    std::vector<int> result(vector_size);\n\n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        \n        // Increment vector elements\n        svint32_t incremented = svadd_s32_z(pg, vec, svdup_s32(1));\n        \n        // Store incremented vector chunk\n        svst1_s32(pg, result.data() + i, incremented);\n        \n        // Move to next chunk\n        i += svcntw();\n        pg = svwhilelt_b32_u64(i, vector_size);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Determine SVE vector length for integers\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine number of elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load current vector\n        svint32_t current_vec = svld1_z(pg, l.data() + i);\n\n        // Negate current vector\n        svint32_t negated_vec = svneg_z(pg, current_vec);\n\n        // Check remaining vector for matching negated values\n        for (size_t j = i + vec_len; j < n; j += vec_len) {\n            size_t remaining_j = std::min(vec_len, n - j);\n            svbool_t pg_j = svwhilelt_b32(j, n);\n\n            svint32_t compare_vec = svld1_z(pg_j, l.data() + j);\n            svbool_t match_mask = svcmpeq_z(pg_j, compare_vec, negated_vec);\n\n            if (svptest_any(pg_j, match_mask)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Determine SVE vector length for integers\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load current vector\n        svint32_t current_vec = svld1_s32(pg, l.data() + i);\n\n        // For each element in current vector, check if its negation exists\n        for (size_t j = 0; j < remaining; ++j) {\n            int target = -l[i + j];\n            \n            // Create vector with target value\n            svint32_t target_vec = svdup_s32(target);\n\n            // Compare current vector with target vector\n            svbool_t match_mask = svcmpeq_s32(pg, current_vec, target_vec);\n\n            // Check if any match exists and it's not the same element\n            if (svptest_any_b32(pg, match_mask)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    if (vector_size < 2) return false;\n\n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n\n        // Load current vector segment\n        svint32_t current_vec = svld1_z(pg, l.data() + i, elements_to_process);\n\n        // Check for pairs summing to zero within the current vector segment\n        for (size_t j = 0; j < elements_to_process; ++j) {\n            int current_element = svget_z(pg, current_vec, j);\n            svint32_t negated_vec = svneg_z(pg, current_vec);\n            svbool_t match_mask = svcmpeq_z(pg, negated_vec, current_element);\n\n            if (svptest_any(pg, match_mask)) {\n                return true;\n            }\n        }\n    }\n\n    // Check pairs across vector segments\n    for (size_t i = 0; i < vector_size; ++i) {\n        for (size_t j = i + 1; j < vector_size; ++j) {\n            if (l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    // Determine SVE vector length for integers\n    size_t vec_len = svcntw();\n    \n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load current vector\n        svint32_t current_vec = svld1_s32(pg, l.data() + i);\n\n        // Negate current vector\n        svint32_t negated_vec = svneg_s32_z(pg, current_vec);\n\n        // Check for remaining elements after current vector\n        for (size_t j = i + vec_len; j < n; ++j) {\n            // Check if negated current vector contains any element from remaining vector\n            svbool_t match = svcmpeq_s32(pg, current_vec, l[j]);\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n\n        // Check within current vector for pairs summing to zero\n        for (size_t k = 0; k < remaining; ++k) {\n            svbool_t match = svcmpeq_s32(pg, negated_vec, svdup_s32(l[i + k]));\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t vector_size = l.size();\n    \n    // If vector size is less than 2, no pair can sum to zero\n    if (vector_size < 2) return false;\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        \n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load current vector segment\n        svint32_t current_vec = svld1_z(pg, l.data() + i, elements_to_process);\n        \n        // Negate current vector\n        svint32_t negated_vec = svneg_z(pg, current_vec);\n        \n        // Check for each element if its negation exists in the remaining vector\n        for (size_t j = i + 1; j < vector_size; j += sve_vector_length) {\n            size_t remaining_elements = std::min(sve_vector_length, vector_size - j);\n            svbool_t pg_remaining = svwhilelt_b32(j, vector_size);\n            \n            // Load remaining vector segment\n            svint32_t remaining_vec = svld1_z(pg_remaining, l.data() + j, remaining_elements);\n            \n            // Compare if any element in remaining vector matches negated current vector\n            svbool_t match_mask = svcmpeq_z(pg_remaining, remaining_vec, negated_vec);\n            \n            // If any match is found, return true\n            if (svptest_any(pg_remaining, match_mask)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    // Handle zero as a special case\n    if (x == 0) return \"0\";\n\n    // Determine maximum vector length\n    const int vector_bytes = svcntb();\n    \n    // Allocate vector to store digits\n    int8_t* digits = new int8_t[vector_bytes];\n    svbool_t pg = svptrue_b8();\n    \n    // Index for tracking digit position\n    int digit_count = 0;\n    \n    // Convert number to specified base\n    while (x > 0) {\n        // Compute remainder using vector division\n        svint64_t x_vec = svdup_n_s64(x);\n        svint64_t base_vec = svdup_n_s64(base);\n        \n        // Compute remainder\n        svint64_t remainder_vec = svrmod_s64(pg, x_vec, base_vec);\n        \n        // Store digit\n        int64_t remainder = svlasta_s64(pg, remainder_vec);\n        digits[digit_count++] = remainder;\n        \n        // Update x by integer division\n        x /= base;\n    }\n    \n    // Reverse digits to get correct order\n    std::string result;\n    for (int i = digit_count - 1; i >= 0; --i) {\n        result += std::to_string(digits[i]);\n    }\n    \n    delete[] digits;\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate maximum possible digits (64-bit number in base 2)\n    char digits[65] = {0};\n    int idx = 64;\n    \n    // Use SVE predicate to handle conversion\n    svbool_t pg = svptrue_b64();\n    \n    // Convert to base using SVE division\n    while (x > 0) {\n        svint64_t x_vec = svdup_n_s64(x);\n        svint64_t base_vec = svdup_n_s64(base);\n        \n        // Perform parallel division\n        svint64_t remainder = svrmod_s64(pg, x_vec, base_vec);\n        \n        // Convert remainder to digit\n        int64_t digit = svlastb_s64(pg, remainder);\n        digits[--idx] = '0' + digit;\n        \n        // Update x by integer division\n        x /= base;\n    }\n    \n    return std::string(digits + idx);\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate maximum possible digits (64-bit number)\n    char digits[65] = {0};\n    int idx = 64;\n    \n    // Use SVE to parallelize digit extraction\n    svbool_t pg = svptrue_b64();\n    svint64_t x_vec = svdup_n_s64(x);\n    svint64_t base_vec = svdup_n_s64(base);\n    \n    while (svptest_any(pg, svcmpne_n_s64(pg, x_vec, 0))) {\n        // Parallel modulo operation\n        svint64_t remainder = svrmod_n_s64_z(pg, x_vec, base_vec);\n        \n        // Convert remainder to character\n        svint64_t char_remainder = svadd_n_s64_z(pg, remainder, '0');\n        \n        // Store digit\n        digits[--idx] = (char)svlastb_s64(char_remainder);\n        \n        // Parallel division\n        x_vec = svdiv_n_s64_z(pg, x_vec, base_vec);\n    }\n    \n    return std::string(digits + idx);\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Determine max vector length\n    const int vector_bytes = svcntb();\n    \n    // Allocate vector to store digits\n    int8_t* digits = new int8_t[vector_bytes];\n    svbool_t pg = svptrue_b8();\n    \n    // Index for tracking digit position\n    int count = 0;\n    \n    // Convert to base using vector operations\n    while (x > 0) {\n        int8_t digit = x % base;\n        digits[count++] = digit;\n        x /= base;\n    }\n    \n    // Reverse the digits\n    std::string result;\n    for (int i = count - 1; i >= 0; i--) {\n        result += std::to_string(digits[i]);\n    }\n    \n    delete[] digits;\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    // Allocate maximum possible digits (64-bit number in base 2)\n    char digits[65] = {0};\n    int idx = 64;\n    \n    // Use SVE predicate to handle conversion\n    svbool_t pg = svptrue_b64();\n    \n    // Convert number to base using SVE\n    while (x > 0) {\n        // Perform parallel division\n        int64_t remainder = x % base;\n        \n        // Store digit in reverse order\n        digits[--idx] = '0' + remainder;\n        \n        // Integer division\n        x /= base;\n    }\n    \n    // Return string from first non-zero digit\n    return std::string(digits + idx);\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    size_t len = text.length();\n    size_t vec_size = svcntb();\n    \n    for (size_t i = 0; i < len / 2; i += vec_size) {\n        svbool_t pg = svwhilelt_b8_u64(i, len / 2);\n        svint8_t left = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + i));\n        svint8_t right = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + len - 1 - i));\n        \n        right = svrev_s8(right);\n        \n        svbool_t cmp = svcmpeq_s8(pg, left, right);\n        \n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vec_size = svcntb();\n    svbool_t pg = svwhilelt_b8_u64(0, len);\n\n    for (size_t i = 0; i < len / 2; i += vec_size) {\n        svuint8_t left = svld1_u8(pg, reinterpret_cast<const uint8_t*>(text.data() + i));\n        svuint8_t right = svld1_u8(pg, reinterpret_cast<const uint8_t*>(text.data() + len - i - vec_size));\n        \n        right = svrevb_u8_z(pg, right);\n        \n        svbool_t cmp = svcmpeq_u8(pg, left, right);\n        \n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n        \n        pg = svwhilelt_b8_u64(i + vec_size, len);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    size_t len = text.length();\n    size_t vec_len = svcntb();\n    \n    for (size_t i = 0; i < len / 2; i += vec_len) {\n        svbool_t pg = svwhilelt_b8_u64(i, len / 2);\n        svint8_t left = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + i));\n        svint8_t right = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + len - 1 - i));\n        \n        right = svrev_s8(right);\n        \n        svbool_t cmp = svcmpeq_s8(pg, left, right);\n        \n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    size_t vec_size = svcntb();\n    svbool_t pg = svptrue_b8();\n\n    for (size_t i = 0; i < len / 2; i += vec_size) {\n        size_t remaining = len - 2 * i;\n        size_t curr_vec_size = std::min(vec_size, remaining);\n\n        svint8_t left = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + i));\n        svint8_t right = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + len - i - curr_vec_size));\n        right = svrevb_s8(right);\n\n        svbool_t compare = svcmpeq_s8(pg, left, right);\n        if (!svptest_any(pg, compare)) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    size_t len = text.length();\n    size_t vec_len = svcntb();\n    \n    for (size_t i = 0; i < len / 2; i += vec_len) {\n        svbool_t pg = svwhilelt_b8_u64(i, len / 2);\n        svint8_t left = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + i));\n        svint8_t right = svld1_s8(pg, reinterpret_cast<const int8_t*>(text.data() + len - 1 - i));\n        \n        right = svrevb_s8(right);\n        \n        svbool_t cmp = svcmpeq_s8(pg, left, right);\n        \n        if (!svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Subtract 5 and handle wrap-around\n        svint8_t decoded = svsub_s8_z(pg, chars, 5);\n        decoded = svadd_s8_z(pg, decoded, 26);\n        decoded = svmod_s8_z(pg, decoded, 26);\n        \n        // Store decoded characters\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&out[i]), decoded);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Subtract 5 and wrap around alphabet\n        svint8_t decoded = svsub_s8_z(pg, chars, 5);\n        decoded = svadd_s8_z(pg, decoded, (int8_t)'a');\n        decoded = svmod_s8_z(pg, decoded, 26);\n        decoded = svadd_s8_z(pg, decoded, (int8_t)'a');\n        \n        // Store decoded characters\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&out[i]), decoded);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Subtract 5 and adjust for alphabet wrap-around\n        svint8_t decoded = svsub_s8_x(pg, chars, 5);\n        decoded = svadd_s8_x(pg, decoded, 26);\n        decoded = svmod_s8_x(pg, decoded, 26);\n        \n        // Store decoded characters\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&out[i]), decoded);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Subtract 5 and adjust for alphabet wrap-around\n        svint8_t decoded = svsub_s8_x(pg, chars, 5);\n        decoded = svadd_s8_x(pg, decoded, 26);\n        decoded = svmod_s8_x(pg, decoded, 26);\n        \n        // Store back to output string\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&out[i]), decoded);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Subtract 5 and wrap around alphabet\n        svint8_t decoded = svsub_s8_x(pg, chars, 5);\n        decoded = svadd_s8_x(pg, decoded, (int8_t)'a');\n        decoded = svmod_s8_x(pg, decoded, 26);\n        decoded = svadd_s8_x(pg, decoded, (int8_t)'a');\n        \n        // Store decoded characters\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&out[i]), decoded);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vector_size = l.size();\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        svbool_t mask = svcmplt_s32(pg, vec, t);\n        \n        if (!svptest_any(pg, mask)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vector_size = l.size();\n    svbool_t pg = svwhilelt_b32_u32(0, vector_size);\n    \n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        svbool_t mask = svcmplt_s32(pg, vec, t);\n        \n        if (!svptest_any(pg, mask)) {\n            return false;\n        }\n        \n        pg = svwhilelt_b32_u32(i + svcntw(), vector_size);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vector_size = l.size();\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        svbool_t mask = svcmplt_s32(pg, vec, t);\n        \n        if (svptest_any_b32(pg, svnot_b_z(pg, mask))) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vector_size = l.size();\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        svbool_t mask = svcmplt_s32(pg, vec, t);\n        \n        if (svptest_any_b32(pg, svnot_b_z(pg, mask))) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vector_size = l.size();\n    svbool_t pg = svwhilelt_b32_u32(0, vector_size);\n    \n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, l.data() + i);\n        svbool_t mask = svcmplt_s32(pg, vec, t);\n        \n        if (!svptest_any(pg, mask)) {\n            return false;\n        }\n        \n        pg = svwhilelt_b32_u32(i + svcntw(), vector_size);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Initialize SVE vector registers\n    svbool_t pg = svptrue_b8();\n    svint8_t zero = svdup_n_s8(0);\n    svint8_t bracket_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n\n    // Compute running sum of brackets\n    svint8_t running_sum = zero;\n    svint8_t less_than = svcmpeq_n_s8(pg, bracket_vec, '<');\n    svint8_t greater_than = svcmpeq_n_s8(pg, bracket_vec, '>');\n    \n    // Increment/decrement running sum\n    running_sum = svsel_s8(less_than, svadd_n_s8_z(pg, running_sum, 1), running_sum);\n    running_sum = svsel_s8(greater_than, svsub_n_s8_z(pg, running_sum, 1), running_sum);\n\n    // Check if running sum goes negative at any point\n    svbool_t negative_check = svcmplt_n_s8(pg, running_sum, 0);\n    if (svcntp_b8(pg, negative_check) > 0) {\n        return false;\n    }\n\n    // Final check: running sum must be zero\n    return svaddv_s8(pg, running_sum) == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n\n    // Initialize SVE vector registers\n    svbool_t pg = svptrue_b8();\n    svint8_t zero = svdup_n_s8(0);\n    svint8_t vec_brackets = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n\n    // Parallel vector processing\n    svint8_t lt_count = svclz_s8_z(pg, svcmpeq_s8(pg, vec_brackets, '<'));\n    svint8_t gt_count = svclz_s8_z(pg, svcmpeq_s8(pg, vec_brackets, '>'));\n\n    // Reduce vector to scalar\n    int lt_total = svcnth() - svpnumh(lt_count);\n    int gt_total = svcnth() - svpnumh(gt_count);\n\n    return lt_total == gt_total;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n\n    // Allocate SVE vector registers\n    svint8_t open_vec = svdup_n_s8('<');\n    svint8_t close_vec = svdup_n_s8('>');\n    \n    // Track bracket balance\n    int balance = 0;\n    svbool_t pg = svptrue_b8();\n\n    // Process vector chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Load vector of characters\n        svint8_t vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.data() + i));\n        \n        // Compare with open and close brackets\n        svbool_t is_open = svcmpeq_s8(pg, vec, open_vec);\n        svbool_t is_close = svcmpeq_s8(pg, vec, close_vec);\n        \n        // Count open and close brackets\n        int open_count = svcnt_s8_z(is_open, is_open);\n        int close_count = svcnt_s8_z(is_close, is_close);\n        \n        balance += open_count - close_count;\n        \n        // Early exit if balance becomes negative\n        if (balance < 0) return false;\n    }\n    \n    // Final check\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector of initial balance\n    svint32_t balance = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Load characters\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(brackets.data() + i));\n        \n        // Compare with '<' and '>'\n        svbool_t is_left = svcmpeq_n_u8(pg, chars, '<');\n        svbool_t is_right = svcmpeq_n_u8(pg, chars, '>');\n\n        // Increment/decrement balance\n        svint32_t left_inc = svsel_s32(is_left, svdup_n_s32(1), svdup_n_s32(0));\n        svint32_t right_dec = svsel_s32(is_right, svdup_n_s32(-1), svdup_n_s32(0));\n        \n        balance = svadd_s32_z(pg, balance, svadd_s32_z(pg, left_inc, right_dec));\n\n        // Check if balance goes negative\n        svbool_t negative = svcmplt_n_s32(pg, balance, 0);\n        if (svptest_any(pg, negative)) {\n            return false;\n        }\n    }\n\n    // Final balance check\n    int32_t final_balance = svaddv_s32(pg, balance);\n    return final_balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector predicates and working registers\n    svbool_t pg = svptrue_b8();\n    svint8_t bracket_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n    \n    // Initialize running count of open/close brackets\n    int64_t running_count = 0;\n    svint64_t count_vec = svdup_n_s64(0);\n\n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += svcntb()) {\n        // Create predicate for valid elements\n        svbool_t p = svwhilelt_b8_u64(i, n);\n\n        // Load current chunk of brackets\n        svint8_t current_vec = svld1_s8(p, reinterpret_cast<const int8_t*>(brackets.c_str() + i));\n\n        // Compare with '<' and '>'\n        svbool_t is_open = svcmpeq_n_s8(p, current_vec, '<');\n        svbool_t is_close = svcmpeq_n_s8(p, current_vec, '>');\n\n        // Increment/decrement count based on bracket type\n        svint64_t open_delta = svsel_s64(is_open, svdup_n_s64(1), svdup_n_s64(0));\n        svint64_t close_delta = svsel_s64(is_close, svdup_n_s64(-1), svdup_n_s64(0));\n        \n        count_vec = svadd_s64_z(p, count_vec, svadd_s64_z(p, open_delta, close_delta));\n\n        // Early exit if count becomes negative\n        if (svptest_any(p, svcmplt_n_s64(count_vec, 0))) {\n            return false;\n        }\n    }\n\n    // Reduce final count across vector\n    running_count = svaddv_s64(pg, count_vec);\n\n    return running_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector of input characters\n    svbool_t pg = svptrue_b8();\n    svint8_t bracket_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n\n    // Initialize running balance counter\n    int32_t balance = 0;\n    svint32_t balance_vec = svdup_n_s32(0);\n\n    // Accumulate bracket balance\n    for (size_t i = 0; i < n; i += svcntb()) {\n        // Load next chunk of brackets\n        svbool_t p = svwhilelt_b8_u64(i, n);\n        svint8_t chunk = svld1_s8(p, reinterpret_cast<const int8_t*>(brackets.c_str() + i));\n\n        // Compare with opening and closing brackets\n        svbool_t is_open = svcmpeq_n_s8(p, chunk, '(');\n        svbool_t is_close = svcmpeq_n_s8(p, chunk, ')');\n\n        // Increment/decrement balance\n        svint32_t open_inc = svsel_s32(is_open, svdup_n_s32(1), svdup_n_s32(0));\n        svint32_t close_dec = svsel_s32(is_close, svdup_n_s32(-1), svdup_n_s32(0));\n        balance_vec = svadd_s32_z(p, balance_vec, svadd_s32_z(p, open_inc, close_dec));\n    }\n\n    // Reduce balance vector to scalar\n    balance = svaddv_s32(pg, balance_vec);\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector of current bracket states\n    svint32_t balance = svdup_n_s32(0);\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        // Load brackets into vector\n        svint32_t current_brackets = svld1_s32(pg, reinterpret_cast<const int32_t*>(brackets.data() + i));\n        \n        // Compute increments: '(' is +1, ')' is -1\n        svint32_t increments = svdup_n_s32(0);\n        increments = svsel_s32(svcmpeq_n_s32(pg, current_brackets, '('), svdup_n_s32(1), increments);\n        increments = svsel_s32(svcmpeq_n_s32(pg, current_brackets, ')'), svdup_n_s32(-1), increments);\n\n        // Update balance\n        balance = svadd_s32_z(pg, balance, increments);\n\n        // Check if balance becomes negative at any point\n        svbool_t negative_balance = svcmplt_n_s32(pg, balance, 0);\n        if (svptest_any(pg, negative_balance)) {\n            return false;\n        }\n    }\n\n    // Final check: balance must be zero\n    return svaddv_s32(pg, balance) == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector of input characters\n    svbool_t pg = svptrue_b8();\n    svint8_t bracket_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n\n    // Track running balance of open/close brackets\n    int64_t balance = 0;\n    svint8_t open_vec = svdup_s8_z(pg, '(');\n    svint8_t close_vec = svdup_s8_z(pg, ')');\n\n    // Compute balance across vector\n    svbool_t is_open = svcmpeq_s8(pg, bracket_vec, open_vec);\n    svbool_t is_close = svcmpeq_s8(pg, bracket_vec, close_vec);\n    \n    int64_t open_count = svcntp_b8(pg, is_open);\n    int64_t close_count = svcntp_b8(pg, is_close);\n\n    balance = open_count - close_count;\n\n    // Check if balance is zero and no negative balance occurred\n    if (balance != 0) return false;\n\n    balance = 0;\n    for (size_t i = 0; i < n; ++i) {\n        balance += (brackets[i] == '(') ? 1 : -1;\n        if (balance < 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector of input characters\n    svbool_t pg = svptrue_b8();\n    svint8_t bracket_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n\n    // Track running balance of open/closed brackets\n    int32_t balance = 0;\n    svint8_t open_vec = svdup_s8_z(pg, '(');\n    svint8_t close_vec = svdup_s8_z(pg, ')');\n\n    // Compute balance across vector\n    svbool_t is_open = svcmpeq_s8(pg, bracket_vec, open_vec);\n    svbool_t is_close = svcmpeq_s8(pg, bracket_vec, close_vec);\n\n    int32_t open_count = svcntp_b8(pg, is_open);\n    int32_t close_count = svcntp_b8(pg, is_close);\n\n    balance = open_count - close_count;\n\n    // Validate bracket sequence\n    for (size_t i = 0; i < n; ++i) {\n        if (brackets[i] == '(') balance++;\n        else balance--;\n\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n\n    // Create SVE vector of current bracket characters\n    svbool_t pg = svptrue_b8();\n    svint8_t bracket_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(brackets.c_str()));\n\n    // Track running balance of open/close brackets\n    int32_t balance = 0;\n    svint8_t open_bracket = svdup_s8_z(pg, '(');\n    svint8_t close_bracket = svdup_s8_z(pg, ')');\n\n    // Parallel processing of brackets\n    svbool_t is_open = svcmpeq_s8(pg, bracket_vec, open_bracket);\n    svbool_t is_close = svcmpeq_s8(pg, bracket_vec, close_bracket);\n\n    // Count open and close brackets\n    int32_t open_count = svcntp_b8(pg, is_open);\n    int32_t close_count = svcntp_b8(pg, is_close);\n\n    balance = open_count - close_count;\n\n    // Validate bracket sequence\n    for (size_t i = 0; i < n; ++i) {\n        if (brackets[i] == '(') balance++;\n        else balance--;\n\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    // Determine SVE vector length for floats\n    size_t vec_len = svcntw();\n    std::vector<float> result;\n    result.reserve(xs.size() - 1);\n\n    // Process vector in SVE vector-sized chunks\n    size_t i = 0;\n    for (; i + vec_len < xs.size(); i += vec_len) {\n        // Load coefficients\n        svfloat32_t coeffs = svld1_f32(svptrue_b32(), &xs[i+1]);\n        \n        // Multiply by index (1, 2, 3, ...)\n        svfloat32_t indices = svindex_f32(1, 1);\n        svfloat32_t derivatives = svmul_f32_z(svptrue_b32(), coeffs, indices);\n\n        // Store derivatives\n        svst1_f32(svptrue_b32(), &result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; ++i) {\n        result.push_back((i + 1) * xs[i + 1]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t vector_size = svcntw(); // Number of float elements in an SVE vector\n    \n    // Process full vector chunks\n    for (size_t i = 0; i < result.size(); i += vector_size) {\n        svbool_t pg = svwhilelt_b32_u64(i, result.size());\n        \n        // Load coefficients: current index and next index\n        svfloat32_t current = svld1_f32(pg, &xs[i+1]);\n        \n        // Multiply by their index (derivative rule)\n        svfloat32_t multiplied = svmul_f32_z(pg, current, \n            svdup_f32_z(pg, static_cast<float>(i+1)));\n        \n        // Store results\n        svst1_f32(pg, &result[i], multiplied);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t vector_size = svcntw(); // Number of float elements in an SVE vector\n    \n    // Process full vector chunks\n    for (size_t i = 0; i < result.size(); i += vector_size) {\n        svbool_t pg = svwhilelt_b32_u64(i, result.size());\n        \n        // Load coefficients: current index and next index\n        svfloat32_t current = svld1_f32(pg, &xs[i+1]);\n        \n        // Multiply by their index (derivative rule)\n        svfloat32_t indices = svindex_f32(i+1, 1);\n        svfloat32_t derivative = svmul_f32_z(pg, current, indices);\n        \n        // Store results\n        svst1_f32(pg, &result[i], derivative);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    std::vector<float> result(xs.size() - 1);\n    size_t vector_size = svcntw(); // Number of float elements in an SVE vector\n    \n    // Process full vector chunks\n    for (size_t i = 0; i + vector_size <= result.size(); i += vector_size) {\n        svfloat32_t coeffs = svld1_f32(svptrue_b32(), xs.data() + i + 1);\n        svfloat32_t multipliers = svdup_f32_z(svptrue_b32(), 1.0f);\n        \n        // Multiply each coefficient by its power\n        for (size_t j = 1; j <= vector_size; ++j) {\n            multipliers = svmul_f32_z(svptrue_b32(), multipliers, svdup_f32_z(svptrue_b32(), j));\n        }\n        \n        svfloat32_t derivatives = svmul_f32_z(svptrue_b32(), coeffs, multipliers);\n        svst1_f32(svptrue_b32(), result.data() + i, derivatives);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (result.size() / vector_size) * vector_size; i < result.size(); ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) return {};\n\n    // Determine vector length dynamically\n    size_t vec_len = svcntw();\n    std::vector<float> result;\n    result.reserve(xs.size() - 1);\n\n    // Process vector chunks\n    for (size_t i = 0; i < xs.size() - 1; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, xs.size() - 1 - i);\n        svbool_t pg = svwhilelt_b32(i, xs.size() - 1);\n\n        // Load coefficients \n        svfloat32_t coeffs = svld1_f32(pg, &xs[i+1]);\n        \n        // Multiply by their position (derivative rule)\n        svfloat32_t positions = svindex_f32(i+1, 1);\n        svfloat32_t derivatives = svmul_f32_z(pg, coeffs, positions);\n\n        // Store results\n        svst1_f32(pg, &result[i], derivatives);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Process in SVE vector chunks\n    for (int i = 0; i < len; i += svcntb()) {\n        // Determine vector length for this iteration\n        svbool_t pg = svwhilelt_b8_u32(i, len);\n        \n        // Load characters from string\n        svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Convert to lowercase\n        svchar_t lower_chars = svorr_z(pg, chars, 0x20);\n        \n        // Check for vowels\n        svbool_t is_a = svcmpeq_z(pg, lower_chars, 'a');\n        svbool_t is_e = svcmpeq_z(pg, lower_chars, 'e');\n        svbool_t is_i = svcmpeq_z(pg, lower_chars, 'i');\n        svbool_t is_o = svcmpeq_z(pg, lower_chars, 'o');\n        svbool_t is_u = svcmpeq_z(pg, lower_chars, 'u');\n        \n        // Special case for 'y' at the end of the word\n        svbool_t is_y_end = svand_z(pg, \n            svcmpeq_z(pg, lower_chars, 'y'), \n            svcmpeq_z(pg, svindex_u8(0, 1), len - i - 1)\n        );\n        \n        // Combine vowel checks\n        svbool_t is_vowel = svorr_z(pg, \n            svorr_z(pg, \n                svorr_z(pg, \n                    svorr_z(pg, is_a, is_e), \n                    is_i\n                ), \n                is_o\n            ), \n            svorr_z(pg, is_u, is_y_end)\n        );\n        \n        // Count vowels in this vector chunk\n        vowel_count += svcntp_b8(pg, is_vowel);\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int length = s.length();\n    int vowel_count = 0;\n    \n    // Process characters in vector chunks\n    int vector_length = svcntb();\n    for (int i = 0; i < length; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b8_u32(i, length);\n        \n        // Load characters from string\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.c_str() + i));\n        \n        // Check for lowercase vowels\n        svbool_t is_a = svcmpeq_s8(pg, chars, 'a');\n        svbool_t is_e = svcmpeq_s8(pg, chars, 'e');\n        svbool_t is_i = svcmpeq_s8(pg, chars, 'i');\n        svbool_t is_o = svcmpeq_s8(pg, chars, 'o');\n        svbool_t is_u = svcmpeq_s8(pg, chars, 'u');\n        \n        // Check for uppercase vowels\n        svbool_t is_A = svcmpeq_s8(pg, chars, 'A');\n        svbool_t is_E = svcmpeq_s8(pg, chars, 'E');\n        svbool_t is_I = svcmpeq_s8(pg, chars, 'I');\n        svbool_t is_O = svcmpeq_s8(pg, chars, 'O');\n        svbool_t is_U = svcmpeq_s8(pg, chars, 'U');\n        \n        // Special case for 'y' at the end of the word\n        svbool_t is_y = svcmpeq_s8(pg, chars, 'y');\n        svbool_t is_Y = svcmpeq_s8(pg, chars, 'Y');\n        svbool_t is_last_y = svand_z(pg, \n            svcmpeq_s8(pg, chars, 'y'), \n            svcmpeq_n_u32(pg, svadd_n_u32(pg, svindex_u32(0, 1), i), length - 1)\n        );\n        svbool_t is_last_Y = svand_z(pg, \n            svcmpeq_s8(pg, chars, 'Y'), \n            svcmpeq_n_u32(pg, svadd_n_u32(pg, svindex_u32(0, 1), i), length - 1)\n        );\n        \n        // Combine all vowel checks\n        svbool_t is_vowel = svorr_z(pg, \n            svorr_z(pg, \n                svorr_z(pg, \n                    svorr_z(pg, \n                        svorr_z(pg, is_a, is_e), \n                    is_i), \n                is_o), \n            is_u),\n            svorr_z(pg, \n                svorr_z(pg, \n                    svorr_z(pg, \n                        svorr_z(pg, is_A, is_E), \n                    is_I), \n                is_O), \n            is_U)\n        );\n        \n        // Add last 'y' and 'Y' to vowel checks\n        is_vowel = svorr_z(pg, is_vowel, is_last_y);\n        is_vowel = svorr_z(pg, is_vowel, is_last_Y);\n        \n        // Count vowels in this chunk\n        vowel_count += svcnt_s8_z(pg, is_vowel);\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Process in SVE vector chunks\n    for (int i = 0; i < len; i += svcntb()) {\n        // Determine vector length for this iteration\n        svbool_t pg = svwhilelt_b8_u32(i, len);\n        \n        // Load characters from string\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Check for lowercase vowels\n        svbool_t is_a = svcmpeq_s8(pg, chars, 'a');\n        svbool_t is_e = svcmpeq_s8(pg, chars, 'e');\n        svbool_t is_i = svcmpeq_s8(pg, chars, 'i');\n        svbool_t is_o = svcmpeq_s8(pg, chars, 'o');\n        svbool_t is_u = svcmpeq_s8(pg, chars, 'u');\n        \n        // Check for uppercase vowels\n        svbool_t is_A = svcmpeq_s8(pg, chars, 'A');\n        svbool_t is_E = svcmpeq_s8(pg, chars, 'E');\n        svbool_t is_I = svcmpeq_s8(pg, chars, 'I');\n        svbool_t is_O = svcmpeq_s8(pg, chars, 'O');\n        svbool_t is_U = svcmpeq_s8(pg, chars, 'U');\n        \n        // Check for 'y' or 'Y' at the end of the word\n        svbool_t is_y = svcmpeq_s8(pg, chars, 'y');\n        svbool_t is_Y = svcmpeq_s8(pg, chars, 'Y');\n        svbool_t is_last_char = svcmpeq_n_u32(pg, svadd_n_u32_z(pg, svindex_u32(0, 1), i), len - 1);\n        \n        // Combine vowel checks\n        svbool_t is_vowel = \n            svorr_b_z(pg, \n                svorr_b_z(pg, \n                    svorr_b_z(pg, \n                        svorr_b_z(pg, \n                            svorr_b_z(pg, is_a, is_e), is_i), is_o), is_u),\n                svorr_b_z(pg, \n                    svorr_b_z(pg, \n                        svorr_b_z(pg, \n                            svorr_b_z(pg, is_A, is_E), is_I), is_O), is_U)\n            );\n        \n        // Add special case for 'y' or 'Y' at the end\n        is_vowel = svorr_b_z(pg, is_vowel, \n            svand_b_z(pg, svorr_b_z(pg, is_y, is_Y), is_last_char));\n        \n        // Count vowels in this vector chunk\n        vowel_count += svcnt_s8_z(pg, is_vowel);\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Process in SVE vector chunks\n    for (int i = 0; i < len; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8_u32(i, len);\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for lowercase vowels\n        svbool_t is_a = svcmpeq_u8(pg, chars, 'a');\n        svbool_t is_e = svcmpeq_u8(pg, chars, 'e');\n        svbool_t is_i = svcmpeq_u8(pg, chars, 'i');\n        svbool_t is_o = svcmpeq_u8(pg, chars, 'o');\n        svbool_t is_u = svcmpeq_u8(pg, chars, 'u');\n        \n        // Check for uppercase vowels\n        svbool_t is_A = svcmpeq_u8(pg, chars, 'A');\n        svbool_t is_E = svcmpeq_u8(pg, chars, 'E');\n        svbool_t is_I = svcmpeq_u8(pg, chars, 'I');\n        svbool_t is_O = svcmpeq_u8(pg, chars, 'O');\n        svbool_t is_U = svcmpeq_u8(pg, chars, 'U');\n        \n        // Special case for 'y' at the end of the word\n        svbool_t is_y = svcmpeq_u8(pg, chars, 'y');\n        svbool_t is_Y = svcmpeq_u8(pg, chars, 'Y');\n        \n        // Combine all vowel checks\n        svbool_t is_vowel = svorr_b_z(pg, \n            svorr_b_z(pg, \n                svorr_b_z(pg, \n                    svorr_b_z(pg, \n                        svorr_b_z(pg, is_a, is_e), \n                    is_i), \n                is_o), \n            is_u),\n            svorr_b_z(pg, \n                svorr_b_z(pg, \n                    svorr_b_z(pg, \n                        svorr_b_z(pg, is_A, is_E), \n                    is_I), \n                is_O), \n            is_U)\n        );\n        \n        // Special case for 'y' at the end of the word\n        if (i + svcntb() >= len) {\n            is_vowel = svorr_b_z(pg, is_vowel, \n                svcmpeq_u8(pg, chars, (len - 1 == i) ? 'y' : 'Y')\n            );\n        }\n        \n        // Count vowels in this chunk\n        vowel_count += svcntp_b8(pg, is_vowel);\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int vowel_count = 0;\n    \n    // Process in SVE vector chunks\n    for (int i = 0; i < len; i += svcntb()) {\n        // Determine vector length for this iteration\n        svbool_t pg = svwhilelt_b8_u32(i, len);\n        \n        // Load characters from string\n        svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.c_str() + i));\n        \n        // Convert to lowercase for consistent comparison\n        svchar_t lower_chars = svorr_z(pg, chars, 0x20);\n        \n        // Check for vowels (a, e, i, o, u)\n        svbool_t is_a = svcmpeq_z(pg, lower_chars, 'a');\n        svbool_t is_e = svcmpeq_z(pg, lower_chars, 'e');\n        svbool_t is_i = svcmpeq_z(pg, lower_chars, 'i');\n        svbool_t is_o = svcmpeq_z(pg, lower_chars, 'o');\n        svbool_t is_u = svcmpeq_z(pg, lower_chars, 'u');\n        \n        // Special case for 'y' at end of word\n        svbool_t is_y_end = (i + svcntb() >= len) ? \n            svcmpeq_z(pg, lower_chars, 'y') : svpfalse_b();\n        \n        // Combine vowel checks\n        svbool_t is_vowel = svorv_z(pg, is_a, is_e, is_i, is_o, is_u, is_y_end);\n        \n        // Count vowels in this vector chunk\n        vowel_count += svcntp_b8(pg, is_vowel);\n    }\n    \n    return vowel_count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // If string is empty, return 0\n    if (len == 0) return 0;\n    \n    // Process vector length at a time\n    size_t vec_size = svcntb();\n    size_t i = 0;\n    \n    // Create predicate for active elements\n    svbool_t pg = svwhilelt_b8_u64(i, len);\n    \n    // Accumulate sum of uppercase characters\n    int64_t sum = 0;\n    for (; i < len; i += vec_size) {\n        // Load characters\n        svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for uppercase characters\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A');\n        svbool_t is_upper_max = svcmple_n_u8(pg, chars, 'Z');\n        svbool_t is_uppercase = svand_b_z(pg, is_upper, is_upper_max);\n        \n        // Mask uppercase characters\n        svuint8_t masked_chars = svsel_u8(is_uppercase, chars, svdup_u8(0));\n        \n        // Convert to int and sum\n        svint32_t int_chars = svreinterpret_s32_u8(masked_chars);\n        svint32_t sum_vec = svaddv_u32(pg, int_chars);\n        \n        sum += sum_vec;\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b8_u64(i + vec_size, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // If string is empty, return 0\n    if (len == 0) return 0;\n    \n    // Process vector length at a time\n    size_t vec_len = svcntb();\n    size_t i = 0;\n    \n    // Create predicate for active elements\n    svbool_t pg = svwhilelt_b8_u64(i, len);\n    \n    // Accumulate sum of uppercase characters\n    for (; i < len; i += vec_len) {\n        // Load characters\n        svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for uppercase characters\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A');\n        svbool_t is_upper_end = svcmple_n_u8(pg, chars, 'Z');\n        svbool_t is_uppercase = svand_z(pg, is_upper, is_upper_end);\n        \n        // Mask uppercase characters\n        svuint8_t masked_chars = svsel_u8(is_uppercase, chars, svdup_u8(0));\n        \n        // Compute sum of uppercase characters\n        svuint32_t sum_vec = svaddv_u8(pg, masked_chars);\n        result += sum_vec;\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b8_u64(i + vec_len, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // If string is empty, return 0\n    if (len == 0) return 0;\n    \n    // Process vector-length chunks\n    size_t vec_len = svcntb();\n    size_t i = 0;\n    \n    // Create predicate for valid vector processing\n    svbool_t pg = svwhilelt_b8_u64(i, len);\n    \n    // Initialize sum vector\n    svint8_t sum_vec = svdup_n_s8(0);\n    \n    while (svptest_any(pg, pg)) {\n        // Load characters from string\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Check for uppercase characters\n        svbool_t is_upper = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_upper_max = svcmple_n_s8(pg, chars, 'Z');\n        svbool_t is_uppercase = svand_z(pg, is_upper, is_upper_max);\n        \n        // Mask uppercase characters\n        svint8_t uppercase_chars = svsel_s8(is_uppercase, chars, svdup_n_s8(0));\n        \n        // Accumulate uppercase character values\n        sum_vec = svadd_m(is_uppercase, sum_vec, uppercase_chars);\n        \n        // Move to next vector chunk\n        i += vec_len;\n        pg = svwhilelt_b8_u64(i, len);\n    }\n    \n    // Reduce vector sum to scalar\n    result = svaddv_s8(svptrue_b8(), sum_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // If string is empty, return 0\n    if (len == 0) return 0;\n    \n    // Process vector length at a time\n    size_t vec_len = svcntb();\n    size_t i = 0;\n    \n    // SVE vector processing\n    for (; i + vec_len <= len; i += vec_len) {\n        // Load string characters into SVE vector\n        svchar_t vec = svld1_u8(svptrue_b8(), reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Create predicate for uppercase characters\n        svbool_t uppercase_pred = svcmpge_n_u8(svptrue_b8(), vec, 'A');\n        svbool_t uppercase_max_pred = svcmpls_n_u8(uppercase_pred, vec, 'Z');\n        svbool_t is_uppercase = svand_b_z(svptrue_b8(), uppercase_pred, uppercase_max_pred);\n        \n        // Mask uppercase characters\n        svuint8_t masked_vec = svsel_u8(is_uppercase, vec, svdup_u8(0));\n        \n        // Compute sum of uppercase characters\n        svuint32_t sum_vec = svaddv_u8(is_uppercase, masked_vec);\n        result += sum_vec;\n    }\n    \n    // Process remaining characters sequentially\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // If string is empty, return 0\n    if (len == 0) return 0;\n    \n    // Process vector length at a time\n    size_t vec_len = svcntb();\n    size_t i = 0;\n    \n    // Create predicate for uppercase check\n    svbool_t pg = svptrue_b8();\n    \n    // Accumulate sum using SVE vector operations\n    svint8_t sum_vec = svdup_n_s8(0);\n    \n    for (; i + vec_len <= len; i += vec_len) {\n        // Load string characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Check for uppercase characters\n        svbool_t is_upper = svcmpge_n_s8(pg, chars, 'A');\n        svbool_t is_upper_end = svcmple_n_s8(pg, chars, 'Z');\n        svbool_t is_uppercase = svand_b_z(pg, is_upper, is_upper_end);\n        \n        // Mask uppercase characters\n        svint8_t uppercase_chars = svsel_s8(is_uppercase, chars, svdup_n_s8(0));\n        \n        // Accumulate sum of uppercase characters\n        sum_vec = svadd_s8_z(pg, sum_vec, uppercase_chars);\n    }\n    \n    // Horizontal sum of vector\n    result += svaddv_s8(pg, sum_vec);\n    \n    // Process remaining characters\n    for (; i < len; ++i) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            result += s[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t vector_size = arr.size();\n    svbool_t pg = svwhilelt_b32(0, vector_size);\n    \n    // Load input array\n    svint32_t values = svld1_z(pg, arr.data());\n    \n    // Create index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Create mask for even numbers\n    svbool_t even_mask = svcmpeq_n_s32(pg, svmod_s32_z(pg, values, 2), 0);\n    \n    // If no even numbers, return empty vector\n    if (!svptest_any(pg, even_mask)) return {};\n    \n    // Mask values and indices to keep only even numbers\n    svint32_t even_values = svcompact_s32(pg, even_mask, values);\n    svint32_t even_indices = svcompact_s32(pg, even_mask, indices);\n    \n    // Find minimum even value\n    svint32_t min_value = svminv_s32(even_mask, even_values);\n    \n    // Create mask for minimum value\n    svbool_t min_mask = svcmpeq_s32(pg, even_values, min_value);\n    \n    // Find first index of minimum value\n    svint32_t min_indices = svcompact_s32(pg, min_mask, even_indices);\n    int min_index = svlasta_s32(min_mask, min_indices);\n    \n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t vector_size = arr.size();\n    svbool_t pg = svwhilelt_b32(0, vector_size);\n    \n    // Load input array\n    svint32_t values = svld1_z(pg, arr.data());\n    \n    // Create index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Mask for even values\n    svbool_t even_mask = svcmpge_n_s32(pg, svmod_s32_z(pg, values, 2), 0);\n    \n    // Find minimum even value and its index\n    svint32_t min_even_values = svmin_s32_z(even_mask, values, INT_MAX);\n    svint32_t min_even_indices = svsel_s32(even_mask, indices, svdup_s32(INT_MAX));\n    \n    // Horizontal reduction to find global minimum\n    int min_value = svminv_s32(pg, min_even_values);\n    \n    // Find first index with minimum value\n    svbool_t min_mask = svcmpeq_n_s32(pg, values, min_value);\n    int min_index = svfirsttrue_b32(min_mask);\n    \n    // Return result if even value found\n    if (min_value % 2 == 0) {\n        return {min_value, min_index};\n    }\n    \n    return {};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t vector_size = arr.size();\n    svbool_t pg = svwhilelt_b32(0, vector_size);\n    \n    // Load input vector\n    svint32_t values = svld1_z(pg, arr.data());\n    \n    // Create index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Create mask for even numbers\n    svbool_t even_mask = svcmpge_n_s32(pg, svmod_s32_z(pg, values, 2), 0);\n    \n    // If no even numbers, return empty\n    if (!svptest_any(pg, even_mask)) return {};\n    \n    // Mask values and indices to keep only even numbers\n    svint32_t even_values = svsel_s32(even_mask, values, svdup_s32(-1));\n    svint32_t even_indices = svsel_s32(even_mask, indices, svdup_s32(-1));\n    \n    // Find minimum even value and its index\n    svint32_t min_even_value = svminv_s32(even_mask, even_values);\n    \n    // Create mask for minimum even value\n    svbool_t min_mask = svcmpeq_s32(pg, even_values, min_even_value);\n    \n    // Find smallest index among minimum even values\n    svint32_t masked_indices = svsel_s32(min_mask, even_indices, svdup_s32(vector_size));\n    int min_index = svminv_s32(min_mask, masked_indices);\n    \n    return {min_even_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t vector_size = arr.size();\n    svbool_t pg = svwhilelt_b32(0, vector_size);\n    \n    // Load input vector\n    svint32_t nodes = svld1_z(pg, arr.data());\n    \n    // Create index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Mask for even values\n    svbool_t even_mask = svcmpeq_n_s32(pg, svmod_s32_z(pg, nodes, 2), 0);\n    \n    // If no even values, return empty\n    if (!svptest_any(pg, even_mask)) return {};\n    \n    // Mask out odd values\n    svint32_t even_nodes = svsel_s32(even_mask, nodes, svdup_s32(INT_MAX));\n    \n    // Find minimum even value\n    svint32_t min_even = svminv_s32(even_mask, even_nodes);\n    \n    // Find first index of minimum even value\n    svbool_t min_mask = svcmpeq_n_s32(pg, even_nodes, min_even);\n    svuint32_t first_min_index = svcompact_u32(pg, min_mask, indices);\n    \n    // Return result\n    return {min_even, static_cast<int>(first_min_index[0])};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t vec_size = arr.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vec_size);\n    \n    // Load input vector\n    svint32_t values = svld1_z(pg, arr.data());\n    \n    // Create index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Mask for even values\n    svbool_t even_mask = svcmpeq_n_s32(pg, svmod_n_s32_z(pg, values, 2), 0);\n    \n    // If no even values, return empty\n    if (!svptest_any(pg, even_mask)) return {};\n    \n    // Mask out odd values\n    svint32_t even_values = svsel_s32(even_mask, values, sv_null_s32());\n    svint32_t even_indices = svsel_s32(even_mask, indices, sv_null_s32());\n    \n    // Find minimum even value\n    svint32_t min_even = svminv_s32(even_mask, even_values);\n    \n    // Create mask for minimum even values\n    svbool_t min_mask = svcmpeq_n_s32(pg, even_values, min_even);\n    \n    // Find first index of minimum even value\n    svint32_t min_indices = svcompact_s32(min_mask, even_indices);\n    int min_index = svlastb_s32(min_mask, min_indices);\n    \n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find max element to determine frequency array size\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Vectorized frequency counting\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t valid = svcmplt_s32(pg, vec, max_val + 1);\n        \n        for (int j = 0; j < svcntw(); ++j) {\n            int val = svget_s32(vec, j);\n            if (svptest_first(valid, svwhilelt_b32_s32(0, j + 1))) {\n                freq[val]++;\n            }\n        }\n    }\n    \n    // Find the result\n    for (int x = max_val; x > 0; --x) {\n        if (freq[x] >= x) {\n            return x;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    \n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // SVE vector processing for frequency counting\n    svbool_t pg = svptrue_b32();\n    size_t vec_size = svcntw();\n    \n    for (int i = 0; i < n; i += vec_size) {\n        size_t remain = std::min(vec_size, static_cast<size_t>(n - i));\n        svint32_t vec = svld1_gather_index(svptrue_b32(), lst.data() + i, svindex_s32(0, 1));\n        \n        for (size_t j = 0; j < remain; ++j) {\n            int val = svgetele_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n    \n    // SVE vector processing for checking condition\n    for (int x = max_val; x > 0; --x) {\n        if (freq[x] >= x) {\n            return x;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    \n    // Find max element to determine frequency array size\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // SVE vector length\n    const int vec_len = svcntw();\n    \n    // Count frequencies using SVE\n    for (int i = 0; i < n; i += vec_len) {\n        int remain = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n        \n        for (int j = 0; j < remain; ++j) {\n            int val = svget_s32(vec, j);\n            if (val > 0) {\n                freq[val]++;\n            }\n        }\n    }\n    \n    // Find result using SVE\n    for (int k = max_val; k > 0; --k) {\n        if (freq[k] >= k) {\n            return k;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find max element to determine frequency array size\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Compute frequencies using SVE\n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        svbool_t valid = svwhilelt_b32_s32(i, n);\n        \n        for (int j = 0; j < svcntw(); ++j) {\n            int val = svmov_n_s32_x(valid, vec, j);\n            if (val > 0) freq[val]++;\n        }\n    }\n    \n    // Check conditions in parallel\n    for (int x = max_val; x > 0; --x) {\n        if (freq[x] >= x) return x;\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    \n    // Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // SVE vector processing for frequency counting\n    svbool_t pg = svptrue_b32();\n    size_t vec_size = svcntw();\n    \n    for (int i = 0; i < n; i += vec_size) {\n        size_t remain = std::min(vec_size, static_cast<size_t>(n - i));\n        svint32_t vec = svld1_s32(svwhilelt_b32(i, n), lst.data() + i);\n        \n        for (int j = 0; j < remain; ++j) {\n            int val = svgetele_s32(vec, j);\n            if (val > 0 && val <= max_val) {\n                freq[val]++;\n            }\n        }\n    }\n    \n    // SVE vector processing for finding result\n    for (int k = max_val; k > 0; --k) {\n        if (freq[k] >= k) {\n            return k;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    // Get vector length and create SVE predicates\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Load vector data\n    svint32_t vec = svld1_z(pg, q.data(), q.size());\n\n    // Calculate total sum using SVE reduction\n    svint32_t sum_vec = svreduce_add_z(pg, vec);\n    int total_sum = svaddv_z(pg, sum_vec);\n\n    // Check weight constraint\n    if (total_sum > w) {\n        return false;\n    }\n\n    // Check palindromic balance\n    size_t n = q.size();\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    // Get vector length and create SVE predicates\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Load vector\n    svint32_t vec = svld1_z(pg, q.data(), q.size());\n\n    // Calculate total sum using SVE reduction\n    svint32_t sum_vec = svreduce_add_z(pg, vec);\n    int total_sum = svaddv_z(pg, sum_vec);\n\n    // Check weight constraint\n    if (total_sum > w) {\n        return false;\n    }\n\n    // Check palindromic balance\n    size_t n = q.size();\n    for (size_t i = 0; i < n / 2; i++) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    // Get vector length and create SVE predicates\n    size_t vec_len = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Load vector\n    svint32_t vec = svld1_z(pg, q.data(), q.size());\n\n    // Calculate total sum using SVE reduction\n    svint32_t sum_vec = svreduce_add_z(pg, vec);\n    int total_sum = svaddv_z(pg, sum_vec);\n\n    // Check weight constraint\n    if (total_sum > w) {\n        return false;\n    }\n\n    // Check palindromic property\n    size_t n = q.size();\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    // Get vector length and create SVE predicates\n    size_t vector_length = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Load vector data\n    svint32_t vec = svld1_z(pg, q.data(), q.size());\n\n    // Calculate total sum using SVE reduction\n    svint32_t sum_vec = svreduce_add_z(pg, vec);\n    int total_sum = svaddv_z(pg, sum_vec);\n\n    // Check weight constraint\n    if (total_sum > w) {\n        return false;\n    }\n\n    // Check palindrome condition\n    size_t n = q.size();\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    // Get vector length and create SVE predicates\n    size_t vector_length = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    // Load vector\n    svint32_t vec = svld1_z(pg, q.data(), q.size());\n\n    // Calculate total sum using SVE reduction\n    svint32_t sum_vec = svreduce_add_z(pg, vec);\n    int total_sum = svaddv_z(pg, sum_vec);\n\n    // Check weight constraint\n    if (total_sum > w) {\n        return false;\n    }\n\n    // Check palindrome (balanced) condition\n    size_t n = q.size();\n    for (size_t i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Use SVE to process vector in parallel\n    svbool_t pg = svptrue_b32();\n    int vector_length = svcntw();\n    \n    for (int i = 0; i < n / 2; i += vector_length) {\n        int remaining = std::min(vector_length, (n/2 - i));\n        \n        // Load left and right halves\n        svint32_t left = svld1_z(pg, arr.data() + i, remaining);\n        svint32_t right = svld1_z(pg, arr.data() + (n - 1 - i - remaining + 1), remaining);\n        \n        // Reverse right half\n        right = svrevb_z(pg, right);\n        \n        // Compare elements\n        svbool_t diff_mask = svcmpne_z(pg, left, right);\n        \n        // Count mismatches\n        changes += svcntp_b32(pg, diff_mask);\n    }\n    \n    // Handle middle element for odd-length arrays\n    if (n % 2 == 1 && n > 1) {\n        int mid = n / 2;\n        if (arr[mid] != arr[mid]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    for (int i = 0; i < n / 2; i += vec_len) {\n        // Determine number of elements to process in this iteration\n        size_t pred_len = svwhilelt_b32(i, n/2);\n        \n        // Load left half of vector\n        svint32_t left_vec = svld1_b32(svptrue_b32(), &arr[i], pred_len);\n        \n        // Load corresponding right half of vector (mirrored)\n        svint32_t right_vec = svld1_b32(svptrue_b32(), &arr[n - 1 - i], pred_len);\n        \n        // Compare elements\n        svbool_t compare_mask = svcmpeq_b32(svptrue_b32(), left_vec, right_vec);\n        \n        // Count number of mismatched elements\n        svuint32_t mismatch_count = svcntp_b32(svptrue_b32(), svnot_b32_z(svptrue_b32(), compare_mask));\n        \n        // Accumulate changes\n        changes += svaddv_b32(svptrue_b32(), mismatch_count);\n    }\n    \n    // Handle odd-length vector center element if needed\n    if (n % 2 != 0) {\n        int center = n / 2;\n        if (arr[center] != arr[center]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    for (int i = 0; i < n / 2; i += vec_len) {\n        // Determine number of elements to process in this iteration\n        size_t remaining = std::min(vec_len, (size_t)(n/2 - i));\n        \n        // Create SVE predicates and load vectors\n        svbool_t pg = svwhilelt_b32(i, n/2);\n        svint32_t left = svld1_z(pg, arr.data() + i);\n        svint32_t right = svld1_z(pg, arr.data() + n - 1 - i);\n        \n        // Reverse right vector\n        right = svrevb_z(pg, right);\n        \n        // Compare left and right vectors\n        svbool_t ne_mask = svcmpne_z(pg, left, right);\n        \n        // Count number of changes needed\n        changes += svcntp_b32(pg, ne_mask);\n    }\n    \n    // Handle middle element if vector length is odd\n    if (n % 2 != 0) {\n        int mid = n / 2;\n        if (arr[mid] != arr[mid]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    for (int i = 0; i < n / 2; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t pred_len = svwhilelt_b32(i, n/2);\n        \n        // Load first half and corresponding mirrored elements\n        svint32_t first_half = svld1_b32(svptrue_b32(), &arr[i]);\n        svint32_t mirrored_half = svld1_b32(svptrue_b32(), &arr[n - 1 - i]);\n        \n        // Compare elements\n        svbool_t compare_mask = svcmpeq_b32(svptrue_b32(), first_half, mirrored_half);\n        \n        // Count mismatches\n        svbool_t mismatch_mask = svnot_b_z(compare_mask, svptrue_b32());\n        changes += svcntp_b32(svptrue_b32(), mismatch_mask);\n    }\n    \n    // Handle odd-length vector center if needed\n    if (n % 2 != 0) {\n        for (int i = 0; i < n / 2; i++) {\n            if (arr[i] != arr[n - 1 - i]) {\n                changes++;\n            }\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector-sized chunks\n    for (int i = 0; i < n / 2; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t pred_len = svwhilelt_b32(i, n/2);\n        \n        // Load left and right halves\n        svint32_t left = svld1_z(svptrue_b32(), &arr[i], pred_len);\n        svint32_t right = svld1_z(svptrue_b32(), &arr[n-1-i], pred_len);\n        \n        // Reverse right half\n        right = svrevb_s32(right);\n        \n        // Compare elements\n        svbool_t diff_mask = svcmpne_s32(svptrue_b32(), left, right);\n        \n        // Count differences\n        changes += svcntp_b32(svptrue_b32(), diff_mask);\n    }\n    \n    // Handle remaining elements if vector length is not divisible\n    for (int i = n/2; i < n; ++i) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either vector is empty, return the first vector\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total characters in each vector\n    size_t total_chars1 = 0, total_chars2 = 0;\n    \n    // Use SVE to parallelize character counting\n    svbool_t pg = svptrue_b64();\n    \n    // Count characters in lst1\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    // Count characters in lst2\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    // Return vector with fewer total characters\n    // If equal, return first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either list is empty, return the first list\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total character count for each list\n    size_t total_chars1 = 0, total_chars2 = 0;\n    \n    // Use SVE to parallelize character count calculation\n    svbool_t pg = svptrue_b64();\n    \n    // Calculate total chars for list1\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    // Calculate total chars for list2\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // If total chars are equal or lst1 has fewer chars, return lst1\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    }\n    \n    // Otherwise return lst2\n    return lst2;\n}\n```\n\nThe implementation uses standard C++ for character count calculation. While the problem statement suggests using SVE intrinsics, the actual character count calculation doesn't benefit significantly from vectorization due to the string-based nature of the operation.\n\nThe key points of the implementation are:\n1. Handle empty list cases first\n2. Calculate total character count for both lists\n3. Compare total character counts\n4. Return the list with fewer total characters (or the first list if equal)\n\nThe function meets the requirements by:\n- Returning the first list if total characters are equal\n- Returning the list with fewer total characters\n- Handling various input scenarios like empty lists, lists of different lengths"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either list is empty, return the first list\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total characters in each list\n    size_t total_chars1 = 0, total_chars2 = 0;\n    \n    // Use SVE to parallelize character counting\n    svbool_t pg = svptrue_b64();\n    \n    // Count chars in first list\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    // Count chars in second list\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return list with fewer total characters\n    // If equal, return first list\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // If either list is empty, return the first list\n    if (lst1.empty()) return lst2;\n    if (lst2.empty()) return lst1;\n\n    // Calculate total characters in each list\n    size_t total_chars1 = 0, total_chars2 = 0;\n    \n    // Use SVE to parallelize character counting\n    svbool_t pg = svptrue_b64();\n    \n    // Calculate total chars for list 1\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    // Calculate total chars for list 2\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    // If total chars are equal or list1 has fewer chars, return list1\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    }\n    \n    // Otherwise return list2\n    return lst2;\n}\n```\n\nThe implementation uses a straightforward approach with SVE boolean predicate `svptrue_b64()` to enable potential parallel processing, though the actual character counting is done sequentially due to the string-based nature of the operation. The function calculates total characters in each list and returns the list with fewer total characters, with a preference for the first list if they are equal.\n\nKey points:\n- Handles empty list cases\n- Calculates total characters for both lists\n- Returns the list with fewer total characters\n- Uses SVE predicate for potential future parallelization"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    // Calculate total characters for each vector\n    size_t total_chars1 = 0;\n    size_t total_chars2 = 0;\n\n    // Use SVE to parallelize character counting\n    svbool_t pg = svptrue_b64();\n    svuint64_t total_vec1 = svdup_u64(0);\n    svuint64_t total_vec2 = svdup_u64(0);\n\n    // Count characters in lst1\n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n\n    // Count characters in lst2\n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n\n    // Return vector with fewer total characters\n    // If equal, return first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Handle special cases\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Determine vector length\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n\n    // Compute log(x) / log(n)\n    double log_x = log(x);\n    double log_n = log(n);\n    double result = log_x / log_n;\n\n    // Use SVE to check if result is an integer\n    svfloat64_t vec_result = svdup_f64(result);\n    svfloat64_t vec_floor = svrintz_f64_z(pg, vec_result);\n    \n    svbool_t mask = svcmpeq_f64(pg, vec_result, vec_floor);\n    bool is_integer = svptest_any(pg, mask);\n\n    return is_integer;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special cases\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Use SVE to compute powers in parallel\n    svbool_t pg = svptrue_b64();\n    svuint64_t base = svdup_n_u64(n);\n    svuint64_t current = base;\n    svuint64_t target = svdup_n_u64(x);\n\n    // Iterate through possible powers\n    for (int i = 1; i < 64; ++i) {\n        svbool_t match = svcmpeq_u64(pg, current, target);\n        if (svptest_any(pg, match)) {\n            return true;\n        }\n        current = svmul_u64_z(pg, current, base);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Determine vector length\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n\n    // Compute log base n of x\n    uint64_t log_val = 0;\n    uint64_t current_power = 1;\n\n    // Use SVE to parallelize power computation\n    while (current_power < x) {\n        svuint64_t power_vec = svdup_u64(current_power);\n        svuint64_t n_vec = svdup_u64(n);\n        \n        // Multiply current power by n\n        power_vec = svmul_u64_z(pg, power_vec, n_vec);\n        \n        // Extract first element\n        current_power = svlasta_u64(pg, power_vec);\n        log_val++;\n    }\n\n    // Check if exact power\n    return (current_power == x);\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special case handling\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // SVE vector processing\n    svbool_t pg = svptrue_b64();\n    svuint64_t x_vec = svdup_u64(x);\n    svuint64_t n_vec = svdup_u64(n);\n    svuint64_t result_vec = svdup_u64(1);\n    svuint64_t one_vec = svdup_u64(1);\n\n    // Compute n^int using SVE vector operations\n    while (svcntp_b64(pg, pg) > 0) {\n        result_vec = svmul_u64_z(pg, result_vec, n_vec);\n        pg = svpnext_b64(pg);\n\n        // Check if result matches x\n        svbool_t eq_mask = svcmpeq_u64(pg, result_vec, x_vec);\n        if (svptest_any(svptrue_b64(), eq_mask)) {\n            return true;\n        }\n\n        // Break if result exceeds x\n        svbool_t gt_mask = svcmpgt_u64(pg, result_vec, x_vec);\n        if (svptest_any(svptrue_b64(), gt_mask)) {\n            break;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    // Special cases\n    if (n <= 1 || x == 0) return false;\n    if (x == 1) return true;\n\n    // Determine vector length\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n\n    // Compute log(x) / log(n)\n    double log_x = log(x);\n    double log_n = log(n);\n    double log_ratio = log_x / log_n;\n\n    // Create vector of potential integer powers\n    svfloat64_t power_vec = svdup_f64(pg, log_ratio);\n    svfloat64_t rounded_vec = svrintp_f64_z(pg, power_vec, SV_CURRENT_RM);\n\n    // Check if rounded value is close to original log ratio\n    svfloat64_t diff_vec = svabs_f64_z(pg, svsub_f64_z(pg, power_vec, rounded_vec));\n    svbool_t close_match = svcmple_f64(pg, diff_vec, svdup_f64(pg, 1e-10));\n\n    // Check if power matches original number\n    uint64_t result = svptest_any(pg, close_match);\n    return result && (pow(n, round(log_ratio)) == x);\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_hex_digits[] = {2, 3, 5, 7, 11, 13};\n    int prime_count = 0;\n    \n    // Get SVE vector length\n    size_t vec_len = svcntb();\n    \n    for (size_t i = 0; i < num.length(); i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, num.length() - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b8(i, num.length());\n        \n        // Load hex digits into SVE vector\n        svint8_t hex_vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(num.c_str() + i));\n        \n        // Convert hex characters to numeric values\n        svint8_t numeric_vec = svcreate_s8(pg, [](int idx) {\n            char c = num[i + idx];\n            if (c >= '0' && c <= '9') return c - '0';\n            return c - 'A' + 10;\n        });\n        \n        // Compare with prime hex digits\n        for (uint8_t prime : prime_hex_digits) {\n            svbool_t match_pred = svcmpeq_n_s8(pg, numeric_vec, prime);\n            prime_count += svcntp_b8(pg, match_pred);\n        }\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_hex_digits[] = {2, 3, 5, 7, 11, 13};\n    \n    int prime_count = 0;\n    size_t vec_len = svcntb();\n    \n    for (size_t i = 0; i < num.length(); i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b8(i, num.length());\n        \n        // Load hex digits as uint8_t\n        svuint8_t hex_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        \n        // Convert hex characters to numeric values\n        svuint8_t numeric_vec = pg;\n        numeric_vec = svcmpeq_n_u8(pg, hex_vec, '0') & svdup_u8(0);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '1') & svdup_u8(1);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '2') & svdup_u8(2);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '3') & svdup_u8(3);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '4') & svdup_u8(4);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '5') & svdup_u8(5);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '6') & svdup_u8(6);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '7') & svdup_u8(7);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '8') & svdup_u8(8);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, '9') & svdup_u8(9);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, 'A') & svdup_u8(10);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, 'B') & svdup_u8(11);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, 'C') & svdup_u8(12);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, 'D') & svdup_u8(13);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, 'E') & svdup_u8(14);\n        numeric_vec |= svcmpeq_n_u8(pg, hex_vec, 'F') & svdup_u8(15);\n        \n        // Check for prime hex digits\n        svbool_t prime_mask = svdup_b8(0);\n        for (int j = 0; j < sizeof(prime_hex_digits); ++j) {\n            prime_mask |= svcmpeq_n_u8(pg, numeric_vec, prime_hex_digits[j]);\n        }\n        \n        // Count prime digits in this vector\n        prime_count += svcntp_b8(pg, prime_mask);\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const char prime_digits[] = {'2', '3', '5', '7', 'B', 'D'};\n    int prime_count = 0;\n    size_t len = num.length();\n\n    // Process vector-sized chunks\n    size_t vec_size = svcntb();\n    size_t i = 0;\n    \n    // Use SVE predicate and comparison\n    for (; i + vec_size <= len; i += vec_size) {\n        // Load input vector\n        svchar_t input_vec = svld1_u8(svptrue_b8(), \n            reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        \n        // Initialize predicate for prime digits\n        svbool_t prime_pred = svpfalse_b();\n        \n        // Check each prime digit\n        for (char prime_digit : prime_digits) {\n            svbool_t match_pred = svcmpeq_n_u8(svptrue_b8(), input_vec, prime_digit);\n            prime_pred = svorr_b_z(svptrue_b8(), prime_pred, match_pred);\n        }\n        \n        // Count matching prime digits in this vector\n        prime_count += svcntp_b8(svptrue_b8(), prime_pred);\n    }\n    \n    // Process remaining elements sequentially\n    for (; i < len; ++i) {\n        for (char prime_digit : prime_digits) {\n            if (num[i] == prime_digit) {\n                prime_count++;\n                break;\n            }\n        }\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const char primes[] = {'2', '3', '5', '7', 'B', 'D'};\n    int prime_count = 0;\n    \n    // Get SVE vector length\n    size_t vec_len = svcntb();\n    \n    for (size_t i = 0; i < num.length(); i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, num.length() - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b8(i, num.length());\n        \n        // Load vector of characters\n        svint8_t vec_chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(num.c_str() + i));\n        \n        // Compare against each prime digit\n        svbool_t is_prime = svpfalse_b();\n        for (char prime : primes) {\n            svbool_t match = svcmpeq_s8(pg, vec_chars, prime);\n            is_prime = svorr_z(pg, is_prime, match);\n        }\n        \n        // Count number of prime digits in this vector\n        prime_count += svcnt_s8_z(pg, is_prime);\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    // Prime hex digits: 2, 3, 5, 7, B (11), D (13)\n    const uint8_t prime_hex_digits[] = {2, 3, 5, 7, 11, 13};\n    \n    int prime_count = 0;\n    size_t vec_len = svcntb();\n    \n    for (size_t i = 0; i < num.length(); i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b8_u64(i, num.length());\n        \n        // Load hex digits as unsigned chars\n        svuint8_t vec_digits = svld1_u8(pg, reinterpret_cast<const uint8_t*>(num.c_str() + i));\n        \n        // Convert hex characters to numeric values\n        svuint8_t converted_digits = svsel_u8(\n            svcmpeq_n_u8(pg, vec_digits, 'A'), svsubr_n_u8(vec_digits, 'A' - 10),\n            svsel_u8(\n                svcmpeq_n_u8(pg, vec_digits, '0'), svsubr_n_u8(vec_digits, '0'),\n                vec_digits\n            )\n        );\n        \n        // Check which digits are prime\n        svbool_t is_prime = svbool_false_b8();\n        for (uint8_t prime : prime_hex_digits) {\n            is_prime = svorr_b_z(pg, is_prime, svcmpeq_n_u8(pg, converted_digits, prime));\n        }\n        \n        // Count prime digits in this vector\n        prime_count += svcntp_b8(pg, is_prime);\n    }\n    \n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // Check if string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Get SVE vector length\n    size_t vec_len = svcntb();\n    \n    // Process vector chunks\n    for (size_t i = 0; i + 2 < s.length(); i++) {\n        // Load 3 consecutive characters\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Compare first and second characters\n        svbool_t first_eq = svcmpeq_s8(pg, chars, svdup_s8(s[i]));\n        \n        // Compare first and third characters\n        svbool_t second_eq = svcmpeq_s8(pg, chars, svdup_s8(s[i+1]));\n        \n        // Check if any characters are equal\n        svbool_t equal_mask = svorr_b_z(pg, first_eq, second_eq);\n        \n        // If any characters are equal, return false\n        if (svptest_any(pg, equal_mask)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // If string length is less than 3, it cannot be happy\n    if (s.length() < 3) return false;\n\n    // Get SVE vector length in bytes\n    size_t vec_len = svcntb();\n\n    // Process the string in SVE vector chunks\n    for (size_t i = 0; i + 2 < s.length(); i++) {\n        // Load 3 consecutive characters\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n\n        // Rotate vector to compare adjacent characters\n        svint8_t rotated1 = svext_s8(chars, chars, 1);\n        svint8_t rotated2 = svext_s8(chars, chars, 2);\n\n        // Check if any characters are equal\n        svbool_t eq1 = svcmpeq_s8(pg, chars, rotated1);\n        svbool_t eq2 = svcmpeq_s8(pg, chars, rotated2);\n        svbool_t eq3 = svcmpeq_s8(pg, rotated1, rotated2);\n\n        // If any characters are equal, string is not happy\n        if (svptest_any(pg, svorr_z(pg, svorr_z(pg, eq1, eq2), eq3))) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // Check if string length is less than 3\n    if (s.length() < 3) return false;\n\n    // Get SVE vector length\n    size_t vec_len = svcntb();\n    \n    // Process vector chunks\n    for (size_t i = 0; i + 2 < s.length(); i++) {\n        // Load 3 consecutive characters\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Compare first and second characters\n        svbool_t first_eq = svcmpeq_s8(pg, chars, svdup_s8(s[i]));\n        \n        // Compare first and third characters\n        svbool_t second_eq = svcmpeq_s8(pg, chars, svdup_s8(s[i+1]));\n        \n        // Check if any characters are equal\n        svbool_t any_equal = svorr_b_z(pg, first_eq, second_eq);\n        \n        // If any characters are equal, return false\n        if (svptest_any(pg, any_equal)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // Check if string length is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Get SVE vector length\n    size_t vec_len = svcntb();\n    \n    // Process string in vector chunks\n    for (size_t i = 0; i + 2 < s.length(); i++) {\n        // Load 3 consecutive characters\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Rotate vector to compare adjacent characters\n        svint8_t rotated1 = svext_s8(chars, chars, 1);\n        svint8_t rotated2 = svext_s8(chars, chars, 2);\n        \n        // Check if any characters are equal\n        svbool_t eq1 = svcmpeq_s8(pg, chars, rotated1);\n        svbool_t eq2 = svcmpeq_s8(pg, chars, rotated2);\n        svbool_t eq3 = svcmpeq_s8(pg, rotated1, rotated2);\n        \n        // Combine equality checks\n        svbool_t any_equal = svorr_b_z(pg, eq1, svorr_b_z(pg, eq2, eq3));\n        \n        // If any characters are equal, string is not happy\n        if (svptest_any(pg, any_equal)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    // Check if string length is less than 3\n    if (s.length() < 3) {\n        return false;\n    }\n\n    // Get SVE vector length\n    size_t vector_length = svcntb();\n    \n    // Process string in vector chunks\n    for (size_t i = 0; i + 2 < s.length(); i++) {\n        // Load 3 consecutive characters\n        svbool_t pg = svwhilelt_b8_u64(0, vector_length);\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(&s[i]));\n        \n        // Rotate and compare for distinctness\n        svint8_t rotated1 = svext_s8(chars, chars, 1);\n        svint8_t rotated2 = svext_s8(chars, chars, 2);\n        \n        // Check if any characters are equal\n        svbool_t equal1 = svcmpeq_s8(pg, chars, rotated1);\n        svbool_t equal2 = svcmpeq_s8(pg, chars, rotated2);\n        svbool_t equal3 = svcmpeq_s8(pg, rotated1, rotated2);\n        \n        // Combine equality checks\n        svbool_t any_equal = svorr_b_z(pg, equal1, svorr_b_z(pg, equal2, equal3));\n        \n        // If any characters are equal, string is not happy\n        if (svptest_any(pg, any_equal)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case for small lengths\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    // SVE vector processing for primality check\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_indices = svindex_s32(3, 2);\n    svint32_t vec_len = svdup_n_s32(len);\n    \n    // Parallel divisibility check\n    svbool_t divisible = svpfalse_b_c(pg);\n    \n    while (svptest_any_b(pg, svcmplt_s32(vec_indices, vec_len))) {\n        svint32_t div_result = svdiv_s32_z(pg, vec_len, vec_indices);\n        svbool_t remainder_zero = svcmpeq_s32(pg, svmod_s32_z(pg, vec_len, vec_indices), svdup_n_s32(0));\n        divisible = svorr_b_z(pg, divisible, remainder_zero);\n        \n        vec_indices = svadd_s32_z(pg, vec_indices, svdup_n_s32(2));\n    }\n    \n    return !svptest_any_b(pg, divisible);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    \n    // Special case handling for small lengths\n    if (length <= 1) return false;\n    if (length == 2) return true;\n    if (length % 2 == 0) return false;\n\n    // SVE vector processing for primality check\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_nums = svindex_s32(3, 2);\n    svint32_t length_vec = svdup_s32(length);\n    \n    // Parallel division check\n    svint32_t divisors = svmul_s32_z(pg, vec_nums, vec_nums);\n    svbool_t cmp = svcmplt_s32(pg, divisors, length_vec);\n    \n    // Reduction to check if any divisor exists\n    while (svptest_any_z(pg, cmp)) {\n        svint32_t remainders = svrems_s32_z(pg, length_vec, vec_nums);\n        svbool_t zero_remainder = svcmpeq_s32(pg, remainders, svdup_s32(0));\n        \n        if (svptest_any_z(pg, zero_remainder)) {\n            return false;\n        }\n        \n        vec_nums = svadd_s32_z(pg, vec_nums, svdup_s32(2));\n        divisors = svmul_s32_z(pg, vec_nums, vec_nums);\n        cmp = svcmplt_s32(pg, divisors, length_vec);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // Use SVE to parallelize primality check\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_i = svindex_s32(5, 2);  // Start from 5, increment by 2\n    svint32_t vec_limit = svdup_s32(len);\n\n    while (svptest_any(pg, svcmplt(vec_i, vec_limit))) {\n        svbool_t mask = svcmplt(vec_i, vec_limit);\n        svint32_t remainder_vec = svrem_x(pg, vec_limit, vec_i);\n        \n        if (svptest_any(mask, svcmpeq(remainder_vec, svdup_s32(0)))) {\n            return false;\n        }\n        \n        vec_i = svadd_x(pg, vec_i, svdup_s32(2));\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n    \n    // Use SVE to parallelize primality check\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_i = svindex_s32(5, 2);\n    svint32_t vec_len = svdup_s32(len);\n    \n    // Parallel divisibility check\n    svbool_t divisible = svpfalse_b_c(pg);\n    do {\n        svint32_t div_sq = svmul_s32_x(pg, vec_i, vec_i);\n        svbool_t sq_check = svcmpgt_s32(pg, div_sq, vec_len);\n        if (svptest_any(pg, sq_check)) break;\n        \n        svbool_t mod_check = svcmpeq_s32(pg, svmod_s32_x(pg, vec_len, vec_i), svdup_s32(0));\n        divisible = svorr_b_z(pg, divisible, mod_check);\n        \n        vec_i = svadd_s32_x(pg, vec_i, svdup_s32(2));\n    } while (svptest_any(pg, svptrue_b32()));\n    \n    return !svptest_any(pg, divisible);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    \n    // Special case handling for small lengths\n    if (len <= 1) return false;\n    if (len == 2 || len == 3) return true;\n    if (len % 2 == 0 || len % 3 == 0) return false;\n\n    // SVE vector processing for primality check\n    svbool_t pg = svptrue_b64();\n    svint64_t vec_i = svindex_s64(5, 2);\n    \n    // Vectorized primality check\n    svbool_t divisible = svpfalse_b_c(pg);\n    for (;;) {\n        svint64_t squared = svmul_s64_x(pg, vec_i, vec_i);\n        svbool_t stop_condition = svcmpge_s64(pg, squared, len);\n        \n        svbool_t current_div = svdivr_s64_x(pg, len, vec_i);\n        divisible = svorr_b_z(pg, divisible, current_div);\n        \n        if (svptest_any(pg, stop_condition)) break;\n        vec_i = svadd_s64_x(pg, vec_i, 2);\n    }\n    \n    return !svptest_any(pg, divisible);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Initialize SVE vector to store digit extraction\n    svuint64_t digits = svdup_n_u64_z(svptrue_b64(), 0);\n    \n    // Extract digits using SVE vector operations\n    uint64_t current = N;\n    size_t index = 0;\n    \n    while (current > 0) {\n        svbool_t pg = svwhilelt_b64_u64(0, 1);\n        svuint64_t digit = svdup_n_u64_z(pg, current % 10);\n        digits = svset_u64(digits, pg, index, digit);\n        \n        current /= 10;\n        index++;\n    }\n    \n    // Compute sum of digits using SVE reduction\n    svuint64_t sum_vec = svreduce_add_u64_z(svptrue_b64(), digits);\n    uint64_t digit_sum = svlasta_u64_z(svptrue_b64(), sum_vec);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (digit_sum > 0) {\n        binary = std::to_string(digit_sum % 2) + binary;\n        digit_sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to digits\n    std::vector<uint64_t> digits;\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n    \n    // Prepare SVE processing\n    size_t vector_size = svcntd();  // Number of 64-bit elements in SVE vector\n    size_t total_digits = digits.size();\n    \n    // Accumulate digit sum using SVE\n    svbool_t pg = svptrue_b64();\n    svuint64_t sum_vec = svdup_u64(0);\n    \n    for (size_t i = 0; i < total_digits; i += vector_size) {\n        // Determine number of elements to process\n        size_t remaining = total_digits - i;\n        svbool_t p = svwhilelt_b64(0, remaining);\n        \n        // Load digits into vector\n        svuint64_t digit_vec = svld1_u64(p, &digits[i]);\n        \n        // Accumulate digits\n        sum_vec = svadd_u64_z(p, sum_vec, digit_vec);\n    }\n    \n    // Reduce vector sum to scalar\n    uint64_t total_sum = svaddv_u64(pg, sum_vec);\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum % 2) + binary;\n        total_sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Extract digits from the number\n    uint64_t sum_digits = 0;\n    while (N > 0) {\n        sum_digits += N % 10;\n        N /= 10;\n    }\n\n    // Use SVE to convert sum to binary\n    svbool_t pg = svptrue_b64();\n    svuint64_t sum_vec = svdup_u64(sum_digits);\n    \n    // Binary conversion using SVE vector operations\n    char binary_str[65] = {0};\n    int index = 63;\n    \n    while (svptest_any(pg, sum_vec)) {\n        svuint64_t remainder = svrmod_u64(pg, sum_vec, svdup_u64(2), sum_vec);\n        svuint64_t digit = svget_u64(remainder, 0);\n        \n        binary_str[index--] = (digit & 1) + '0';\n        sum_vec = svdiv_u64(pg, sum_vec, svdup_u64(2));\n    }\n\n    return std::string(binary_str + index + 1);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to digits\n    std::vector<int> digits;\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n    \n    // Prepare SVE vector processing\n    size_t vector_size = svcntw();\n    svbool_t pg = svptrue_b32();\n    \n    // Process digits in parallel\n    uint32_t sum = 0;\n    for (size_t i = 0; i < digits.size(); i += vector_size) {\n        // Load digits into SVE vector\n        size_t remaining = std::min(vector_size, digits.size() - i);\n        svint32_t digit_vec = svld1_s32(svptrue_b32(), digits.data() + i);\n        \n        // Compute digit sum using SVE reduction\n        svint32_t sum_vec = svreduce_add_s32(pg, digit_vec);\n        sum += svaddv_s32(pg, sum_vec);\n    }\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (sum > 0) {\n        binary = std::to_string(sum % 2) + binary;\n        sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to digits\n    std::vector<int> digits;\n    while (N > 0) {\n        digits.push_back(N % 10);\n        N /= 10;\n    }\n    \n    // Determine vector length\n    const int vec_len = svcntw();\n    \n    // Compute digit sum using SVE\n    uint32_t total_sum = 0;\n    for (size_t i = 0; i < digits.size(); i += vec_len) {\n        // Create SVE predicate\n        svbool_t pg = svwhilelt_b32_u64(i, digits.size());\n        \n        // Load digits into vector\n        svint32_t digit_vec = svld1_s32(pg, digits.data() + i);\n        \n        // Compute sum of digits in vector\n        svint32_t sum_vec = svreinterpret_s32_u32(svcnt_s32_z(pg, digit_vec));\n        \n        // Reduce sum across vector\n        total_sum += svaddv_s32(pg, sum_vec);\n    }\n    \n    // Convert sum to binary string\n    std::string binary;\n    while (total_sum > 0) {\n        binary = std::to_string(total_sum % 2) + binary;\n        total_sum /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine the maximum vector length supported by SVE\n    size_t sve_vector_length = svcntw();\n    \n    // Process elements in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_z(pg, lst.data() + i);\n        \n        // Create a predicate for odd indices\n        svbool_t odd_indices = svzip1_b(svpfalse_b(), svptrue_b32());\n        \n        // Mask the vector to keep only even elements at odd indices\n        svint32_t masked_vec = svsel_s32(svand_z(pg, odd_indices, svacge_s32(pg, vec, 0)), vec, svdup_s32(0));\n        \n        // Sum the masked vector\n        int chunk_sum = svaddv_s32(pg, masked_vec);\n        \n        result += chunk_sum;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine the SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process vectors in chunks\n    size_t i;\n    for (i = 1; i < vector_size; i += 2 * sve_vector_length) {\n        // Create predicate for odd indices\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load elements at odd indices\n        svint32_t odd_elements = svld1_gather_index_s32(pg, lst.data(), \n            svindex_s32(i, 2));\n        \n        // Create predicate for even elements\n        svbool_t even_pred = svcmpeq_s32(pg, svand_s32_z(pg, odd_elements, \n            svdup_s32(1)), svdup_s32(0));\n        \n        // Sum even elements at odd indices\n        result += svaddv_s32(even_pred, odd_elements);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; i += 2) {\n        if (i < vector_size && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine the SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine the number of elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n        \n        // Create predicate for odd indices\n        svbool_t odd_indices = svzip1_b32(svpfalse_b(), svptrue_b32());\n        \n        // Mask vector with odd indices\n        svint32_t odd_index_vec = svcompact_s32(odd_indices, vec);\n        \n        // Create predicate for even elements\n        svbool_t even_elements = svcmpeq_s32(pg, svmod_s32_z(pg, odd_index_vec, 2), 0);\n        \n        // Sum even elements at odd indices\n        int32_t chunk_sum = svaddv_s32(even_elements, odd_index_vec);\n        \n        result += chunk_sum;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine number of elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        \n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n        \n        // Create mask for odd indices\n        svbool_t odd_indices = svzip1_b32(svpfalse_b(), svptrue_b32());\n        \n        // Mask vector with odd indices\n        svint32_t odd_index_vec = svcompact_s32(odd_indices, vec);\n        \n        // Create mask for even elements\n        svbool_t even_elements = svcmpeq_s32(pg, svmod_s32_z(pg, odd_index_vec, 2), 0);\n        \n        // Sum even elements at odd indices\n        int32_t chunk_sum = svaddv_s32(even_elements, odd_index_vec);\n        \n        result += chunk_sum;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine the maximum vector length supported by SVE\n    size_t svl = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svl) {\n        // Determine the number of elements to process in this iteration\n        size_t elements_to_process = std::min(svl, vector_size - i);\n        \n        // Create predicate for odd indices\n        svbool_t odd_indices_pred = svwhilelt_b32_u64(1, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_u32(odd_indices_pred, lst.data() + i);\n        \n        // Mask for even elements\n        svbool_t even_pred = svcmpge_n_s32(odd_indices_pred, vec, 0);\n        even_pred = svand_b_z(odd_indices_pred, even_pred, svpnext_b_z(odd_indices_pred, svptrue_b32()));\n        \n        // Reduce even elements at odd indices\n        svint32_t masked_vec = svsel_s32(even_pred, vec, svdup_s32(0));\n        int chunk_sum = svaddv_s32(odd_indices_pred, masked_vec);\n        \n        result += chunk_sum;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Check if character is a lowercase letter\n        svbool_t is_lowercase = svcmpge_n_s8(pg, chars, 'a');\n        is_lowercase = svand_z(pg, is_lowercase, svcmple_n_s8(pg, chars, 'z'));\n        \n        // Rotate lowercase letters by 4 (2 * 2)\n        svint8_t rotated = svAdd_s8_z(is_lowercase, chars, 4);\n        \n        // Wrap around if past 'z'\n        svbool_t past_z = svcmpgt_n_s8(pg, rotated, 'z');\n        svint8_t wrap_adjustment = svsel_s8(past_z, -26, 0);\n        rotated = svAdd_s8_z(is_lowercase, rotated, wrap_adjustment);\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), rotated);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        svuint8_t input_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check if character is lowercase letter\n        svuint8_t is_lowercase = svcmge_n_u8(pg, input_vec, 'a');\n        svuint8_t is_valid_letter = svcmle_n_u8(pg, input_vec, 'z');\n        svbool_t letter_mask = svand_z(pg, is_lowercase, is_valid_letter);\n        \n        // Rotate letters by 4 (2 * 2)\n        svuint8_t rotated = svAdd_u8_z(letter_mask, input_vec, 4);\n        \n        // Wrap around if past 'z'\n        svuint8_t wrapped = svsel_u8(svcmgt_n_u8(letter_mask, rotated, 'z'), \n                                     svSub_u8_z(letter_mask, rotated, 26), \n                                     rotated);\n        \n        svst1_u8(pg, reinterpret_cast<uint8_t*>(&result[i]), wrapped);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        svuint8_t input_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Rotate lowercase letters by 4 (2 * 2)\n        svuint8_t lower_mask = svcmpeq_u8(pg, input_vec & 0xE0, 0x60);\n        svuint8_t rotated = input_vec + svsel_u8(lower_mask, 4, 0);\n        \n        // Wrap around if beyond 'z'\n        svuint8_t wrap_mask = svcmpgt_u8(pg, rotated, 'z');\n        rotated = svsel_u8(wrap_mask, rotated - 26, rotated);\n        \n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), rotated);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        svuint8_t input_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check if character is lowercase\n        svuint8_t is_lowercase = svcmge_n_u8(pg, input_vec, 'a');\n        svuint8_t is_valid_lowercase = svcmle_n_u8(pg, input_vec, 'z');\n        svbool_t lowercase_mask = svand_z(pg, is_lowercase, is_valid_lowercase);\n        \n        // Rotate lowercase letters\n        svuint8_t rotated = svqadd_n_u8_z(lowercase_mask, input_vec, 4);\n        \n        // Wrap around if rotation goes past 'z'\n        svuint8_t wrap_mask = svcmgt_n_u8(pg, rotated, 'z');\n        svuint8_t wrapped = svsel_u8(wrap_mask, svqsub_n_u8_z(pg, rotated, 26), rotated);\n        \n        // Store result back\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(result.data() + i), wrapped);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t vector_length = svcntb();\n    \n    for (size_t i = 0; i < s.length(); i += vector_length) {\n        size_t remaining = std::min(vector_length, s.length() - i);\n        svbool_t pg = svwhilelt_b8_u64(i, s.length());\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(s.data() + i));\n        \n        // Check if character is lowercase letter\n        svbool_t is_lowercase = svcmpge_n_s8(pg, chars, 'a');\n        is_lowercase = svand_z(pg, is_lowercase, svcmple_n_s8(pg, chars, 'z'));\n        \n        // Rotate lowercase letters by 4 (2 * 2)\n        svint8_t rotated = svAdd_s8_z(is_lowercase, chars, 4);\n        \n        // Wrap around if beyond 'z'\n        svbool_t beyond_z = svcmpgt_n_s8(pg, rotated, 'z');\n        svint8_t wrap_adjustment = svsel_s8(beyond_z, -26, 0);\n        rotated = svAdd_s8_z(is_lowercase, rotated, wrap_adjustment);\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), rotated);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in SVE vector chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Determine vector length for this iteration\n        svbool_t pg = svwhilelt_b8_u64(i, len);\n        \n        // Load message chunk\n        svint8_t vec = svld1_s8(pg, reinterpret_cast<const int8_t*>(message.data() + i));\n        \n        // Case swap: Uppercase to lowercase and vice versa\n        svint8_t lower_mask = svcmple_s8(pg, vec, 'z');\n        svint8_t upper_mask = svcmple_s8(pg, vec, 'Z');\n        \n        svint8_t case_swapped = vec;\n        case_swapped = svsel_s8(lower_mask, vec ^ 32, case_swapped);\n        case_swapped = svsel_s8(upper_mask, vec ^ 32, case_swapped);\n        \n        // Vowel replacement\n        svint8_t vowel_a = svcmpeq_s8(pg, case_swapped, 'a');\n        svint8_t vowel_e = svcmpeq_s8(pg, case_swapped, 'e');\n        svint8_t vowel_i = svcmpeq_s8(pg, case_swapped, 'i');\n        svint8_t vowel_o = svcmpeq_s8(pg, case_swapped, 'o');\n        svint8_t vowel_u = svcmpeq_s8(pg, case_swapped, 'u');\n        \n        svint8_t vowel_A = svcmpeq_s8(pg, case_swapped, 'A');\n        svint8_t vowel_E = svcmpeq_s8(pg, case_swapped, 'E');\n        svint8_t vowel_I = svcmpeq_s8(pg, case_swapped, 'I');\n        svint8_t vowel_O = svcmpeq_s8(pg, case_swapped, 'O');\n        svint8_t vowel_U = svcmpeq_s8(pg, case_swapped, 'U');\n        \n        case_swapped = svsel_s8(vowel_a, 'c', case_swapped);\n        case_swapped = svsel_s8(vowel_e, 'g', case_swapped);\n        case_swapped = svsel_s8(vowel_i, 'k', case_swapped);\n        case_swapped = svsel_s8(vowel_o, 'q', case_swapped);\n        case_swapped = svsel_s8(vowel_u, 'w', case_swapped);\n        \n        case_swapped = svsel_s8(vowel_A, 'C', case_swapped);\n        case_swapped = svsel_s8(vowel_E, 'G', case_swapped);\n        case_swapped = svsel_s8(vowel_I, 'K', case_swapped);\n        case_swapped = svsel_s8(vowel_O, 'Q', case_swapped);\n        case_swapped = svsel_s8(vowel_U, 'W', case_swapped);\n        \n        // Store result back\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), case_swapped);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in SVE vector chunks\n    size_t vec_size = svcntb();\n    for (size_t i = 0; i < len; i += vec_size) {\n        // Determine how many elements to process in this chunk\n        svbool_t pg = svwhilelt_b8_u64(i, len);\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(message.data() + i));\n        \n        // Swap case\n        svint8_t lower_mask = svcmpeq_s8(pg, chars, svdup_s8_z(pg, 'a'), svdup_s8_z(pg, 'z'));\n        svint8_t upper_mask = svcmpeq_s8(pg, chars, svdup_s8_z(pg, 'A'), svdup_s8_z(pg, 'Z'));\n        \n        // Lowercase to uppercase\n        svint8_t lower_to_upper = svsubr_s8_z(pg, chars, svdup_s8_z(pg, 32));\n        lower_to_upper = svsel_s8(lower_mask, lower_to_upper, chars);\n        \n        // Uppercase to lowercase\n        svint8_t upper_to_lower = svadd_s8_z(pg, chars, svdup_s8_z(pg, 32));\n        upper_to_lower = svsel_s8(upper_mask, upper_to_lower, lower_to_upper);\n        \n        // Vowel replacement\n        svint8_t vowels = svdup_s8_z(pg, 0);\n        vowels = svorr_s8_z(pg, vowels, svcmpeq_s8(pg, upper_to_lower, svdup_s8_z(pg, 'A')));\n        vowels = svorr_s8_z(pg, vowels, svcmpeq_s8(pg, upper_to_lower, svdup_s8_z(pg, 'E')));\n        vowels = svorr_s8_z(pg, vowels, svcmpeq_s8(pg, upper_to_lower, svdup_s8_z(pg, 'I')));\n        vowels = svorr_s8_z(pg, vowels, svcmpeq_s8(pg, upper_to_lower, svdup_s8_z(pg, 'O')));\n        vowels = svorr_s8_z(pg, vowels, svcmpeq_s8(pg, upper_to_lower, svdup_s8_z(pg, 'U')));\n        \n        svint8_t vowel_replace = svadd_s8_z(pg, upper_to_lower, svdup_s8_z(pg, 2));\n        vowel_replace = svsel_s8(vowels, vowel_replace, upper_to_lower);\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), vowel_replace);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in SVE vector chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Determine vector length for this iteration\n        svbool_t pg = svwhilelt_b8_u64(i, len);\n        \n        // Load characters into SVE vector\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(message.data() + i));\n        \n        // Swap case: toggle bit 5 (lowercase/uppercase)\n        svint8_t swapped_case = sveor_s8_z(pg, chars, 0x20);\n        \n        // Detect vowels\n        svbool_t is_vowel = svcmpeq_s8(pg, \n            svand_s8_z(pg, swapped_case, 0xDF),  // uppercase check\n            svcreate8(svptrue_b8(), 'A', 'E', 'I', 'O', 'U')\n        );\n        \n        // Replace vowels with chars 2 places ahead\n        svint8_t vowel_replace = svsel_s8(is_vowel, \n            svadd_s8_z(is_vowel, swapped_case, 2), \n            swapped_case\n        );\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), vowel_replace);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in SVE vector chunks\n    size_t vec_size = svcntb();\n    for (size_t i = 0; i < len; i += vec_size) {\n        // Determine how many elements to process in this chunk\n        svbool_t pg = svwhilelt_b8_u64(i, len);\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(message.data() + i));\n        \n        // Swap case\n        svint8_t lower_mask = svcmple_n_s8(pg, chars, 'z');\n        svint8_t upper_mask = svcmpge_n_s8(pg, chars, 'A');\n        svint8_t case_swap_mask = svand_z(pg, lower_mask, upper_mask);\n        \n        // Invert case\n        svint8_t case_swapped = sveor_z(case_swap_mask, chars, 32);\n        \n        // Replace vowels\n        svbool_t vowel_mask = svcmpeq_n_s8(pg, chars, 'a');\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'e'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'i'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'o'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'u'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'A'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'E'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'I'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'O'));\n        vowel_mask = svorr_z(pg, vowel_mask, svcmpeq_n_s8(pg, chars, 'U'));\n        \n        // Replace vowels with characters 2 ahead\n        svint8_t vowel_replaced = svsel_s8(vowel_mask, case_swapped + 2, case_swapped);\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), vowel_replaced);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    \n    // Process in SVE vector chunks\n    size_t vec_size = svcntb();\n    for (size_t i = 0; i < len; i += vec_size) {\n        // Determine how many elements to process in this chunk\n        svbool_t pg = svwhilelt_b8_u64(i, len);\n        \n        // Load characters\n        svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(message.data() + i));\n        \n        // Swap case\n        svint8_t lower_mask = svcmple_s8(pg, chars, 'z');\n        svint8_t upper_mask = svcmple_s8(pg, 'A', chars);\n        svint8_t case_swap = svreinterpret_s8_u8(\n            sveor_u8_x(pg, \n                svreinterpret_u8_s8(chars), \n                svdup_u8(32)\n            )\n        );\n        chars = svsel_s8(svand_z(pg, lower_mask, upper_mask), case_swap, chars);\n        \n        // Replace vowels\n        svbool_t is_vowel = svcmpeq_s8(pg, \n            svand_z(pg, chars, svdup_s8(0xDF)), // uppercase\n            svdup_s8('A')\n        );\n        is_vowel = svorr_b_z(pg, is_vowel, \n            svcmpeq_s8(pg, \n                svand_z(pg, chars, svdup_s8(0xDF)), \n                svdup_s8('E')\n            )\n        );\n        is_vowel = svorr_b_z(pg, is_vowel, \n            svcmpeq_s8(pg, \n                svand_z(pg, chars, svdup_s8(0xDF)), \n                svdup_s8('I')\n            )\n        );\n        is_vowel = svorr_b_z(pg, is_vowel, \n            svcmpeq_s8(pg, \n                svand_z(pg, chars, svdup_s8(0xDF)), \n                svdup_s8('O')\n            )\n        );\n        is_vowel = svorr_b_z(pg, is_vowel, \n            svcmpeq_s8(pg, \n                svand_z(pg, chars, svdup_s8(0xDF)), \n                svdup_s8('U')\n            )\n        );\n        \n        svint8_t vowel_replace = svsel_s8(is_vowel, \n            svadd_s8_x(pg, chars, svdup_s8(2)), \n            chars\n        );\n        \n        // Store back to result\n        svst1_s8(pg, reinterpret_cast<int8_t*>(&result[i]), vowel_replace);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    // Determine vector length\n    size_t vec_len = svcntb();\n    \n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in vector chunks\n        size_t i = 0;\n        for (; i + vec_len <= key.length(); i += vec_len) {\n            svbool_t pg = svwhilelt_b8_u64(i, key.length());\n            svint8_t vec_chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(key.data() + i));\n            \n            // Check if all characters are lowercase\n            svbool_t is_lower = svcmple_n_s8(pg, vec_chars, 'z');\n            svbool_t is_lower_range = svcmpge_n_s8(pg, vec_chars, 'a');\n            svbool_t lower_mask = svand_z(pg, is_lower, is_lower_range);\n            \n            // Check if all characters are uppercase\n            svbool_t is_upper = svcmple_n_s8(pg, vec_chars, 'Z');\n            svbool_t is_upper_range = svcmpge_n_s8(pg, vec_chars, 'A');\n            svbool_t upper_mask = svand_z(pg, is_upper, is_upper_range);\n            \n            // Update flags\n            all_lower &= svptest_any(pg, lower_mask);\n            all_upper &= svptest_any(pg, upper_mask);\n            \n            // Early exit if not consistent\n            if (!all_lower && !all_upper) return false;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            bool is_lower = (c >= 'a' && c <= 'z');\n            bool is_upper = (c >= 'A' && c <= 'Z');\n            \n            all_lower &= is_lower;\n            all_upper &= is_upper;\n            \n            if (!all_lower && !all_upper) return false;\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    // Determine vector length\n    size_t vec_len = svcntb();\n    \n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in vector chunks\n        size_t i = 0;\n        for (; i + vec_len <= key.length(); i += vec_len) {\n            svbool_t pg = svwhilelt_b8_u64(i, key.length());\n            svuint8_t vec_chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(key.data() + i));\n            \n            // Check lowercase\n            svbool_t is_lower = svcmge_n_u8(pg, vec_chars, 'a');\n            svbool_t is_lower_max = svcmle_n_u8(pg, vec_chars, 'z');\n            svbool_t is_lower_vec = svand_b_z(pg, is_lower, is_lower_max);\n            \n            // Check uppercase \n            svbool_t is_upper = svcmge_n_u8(pg, vec_chars, 'A');\n            svbool_t is_upper_max = svcmle_n_u8(pg, vec_chars, 'Z');\n            svbool_t is_upper_vec = svand_b_z(pg, is_upper, is_upper_max);\n            \n            // Update flags\n            all_lower &= svptest_any(pg, is_lower_vec);\n            all_upper &= svptest_any(pg, is_upper_vec);\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            all_lower &= (c >= 'a' && c <= 'z');\n            all_upper &= (c >= 'A' && c <= 'Z');\n        }\n        \n        // Early exit if mixed case detected\n        if (!(all_lower || all_upper)) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    // Get vector length\n    size_t vec_len = svcntb();\n    \n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in vector chunks\n        size_t i = 0;\n        for (; i + vec_len <= key.length(); i += vec_len) {\n            svbool_t pg = svwhilelt_b8_u64(i, key.length());\n            svint8_t vec_chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(key.data() + i));\n            \n            // Check lowercase\n            svbool_t is_lower = svcmple_s8(pg, vec_chars, 'z');\n            svbool_t is_lower_range = svcmpge_s8(pg, vec_chars, 'a');\n            svbool_t lower_mask = svand_z(pg, is_lower, is_lower_range);\n            \n            // Check uppercase \n            svbool_t is_upper = svcmple_s8(pg, vec_chars, 'Z');\n            svbool_t is_upper_range = svcmpge_s8(pg, vec_chars, 'A');\n            svbool_t upper_mask = svand_z(pg, is_upper, is_upper_range);\n            \n            // Update flags\n            all_lower &= svcntp_b8(pg, lower_mask) == vec_len;\n            all_upper &= svcntp_b8(pg, upper_mask) == vec_len;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            all_lower &= (c >= 'a' && c <= 'z');\n            all_upper &= (c >= 'A' && c <= 'Z');\n        }\n        \n        // Early exit if case is mixed\n        if (!(all_lower || all_upper)) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    // Determine vector length\n    size_t vec_len = svcntb();\n\n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in vector chunks\n        size_t i = 0;\n        for (; i + vec_len <= key.length(); i += vec_len) {\n            svbool_t pg = svwhilelt_b8_u64(i, key.length());\n            svint8_t vec_chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(key.data() + i));\n\n            // Check lowercase\n            svbool_t is_lower = svcmple_n_s8(pg, vec_chars, 'z');\n            svbool_t is_lower_range = svcmpge_n_s8(pg, vec_chars, 'a');\n            svbool_t lower_mask = svand_b_z(pg, is_lower, is_lower_range);\n            \n            // Check uppercase\n            svbool_t is_upper = svcmple_n_s8(pg, vec_chars, 'Z');\n            svbool_t is_upper_range = svcmpge_n_s8(pg, vec_chars, 'A');\n            svbool_t upper_mask = svand_b_z(pg, is_upper, is_upper_range);\n\n            // Update flags\n            all_lower &= svcntp_b8(pg, lower_mask) == svcntp_b8(pg, pg);\n            all_upper &= svcntp_b8(pg, upper_mask) == svcntp_b8(pg, pg);\n        }\n\n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            all_lower &= (c >= 'a' && c <= 'z');\n            all_upper &= (c >= 'A' && c <= 'Z');\n        }\n\n        // Early exit if mixed case detected\n        if (!(all_lower || all_upper)) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) return false;\n\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    // Determine vector length\n    size_t vec_len = svcntb();\n    \n    for (const auto& entry : dict) {\n        const std::string& key = entry.first;\n        \n        // Process key in vector chunks\n        size_t i = 0;\n        for (; i + vec_len <= key.length(); i += vec_len) {\n            svbool_t pg = svwhilelt_b8_u64(i, key.length());\n            svint8_t vec_chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(key.data() + i));\n            \n            // Check lowercase\n            svbool_t is_lower = svcmple_n_s8(pg, vec_chars, 'z');\n            svbool_t is_lower_range = svcmpge_n_s8(pg, vec_chars, 'a');\n            svbool_t lower_mask = svand_z(pg, is_lower, is_lower_range);\n            \n            // Check uppercase \n            svbool_t is_upper = svcmple_n_s8(pg, vec_chars, 'Z');\n            svbool_t is_upper_range = svcmpge_n_s8(pg, vec_chars, 'A');\n            svbool_t upper_mask = svand_z(pg, is_upper, is_upper_range);\n            \n            // Update flags\n            all_lower &= svcntp_b8(pg, lower_mask) == vec_len;\n            all_upper &= svcntp_b8(pg, upper_mask) == vec_len;\n        }\n        \n        // Process remaining characters\n        for (; i < key.length(); ++i) {\n            char c = key[i];\n            all_lower &= (c >= 'a' && c <= 'z');\n            all_upper &= (c >= 'A' && c <= 'Z');\n        }\n        \n        // Early exit if case is mixed\n        if (!(all_lower || all_upper)) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    \n    for (int candidate = 2; candidate < n; candidate++) {\n        svint32_t vec_candidate = svdup_n_s32(candidate);\n        svbool_t is_prime = svptrue_b32();\n        \n        for (int divisor = 2; divisor * divisor <= candidate; divisor++) {\n            svint32_t vec_divisor = svdup_n_s32(divisor);\n            svint32_t remainder = svrmod_s32_x(pg, vec_candidate, vec_divisor);\n            is_prime = svand_b_z(pg, is_prime, svcmpeq_s32(pg, remainder, svdup_n_s32(0)));\n        }\n        \n        if (svptest_any(pg, is_prime)) {\n            primes.push_back(candidate);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    \n    // Initial candidates\n    int64_t vl = svcntw();\n    svint32_t candidates = svindex_s32(2, 1);\n    \n    while (svptest_any(pg, svcmplt_s32(pg, candidates, n))) {\n        // Sieve of Eratosthenes using SVE\n        svbool_t is_prime = svdup_b_s32(true);\n        \n        for (int factor = 2; factor * factor < n; factor++) {\n            svbool_t multiple_mask = svcmpeq_s32(pg, \n                svmod_s32_z(pg, candidates, factor), 0);\n            is_prime = svbic_b_z(pg, is_prime, multiple_mask);\n        }\n        \n        // Compress and store primes\n        svint32_t prime_results = svcompress_s32_z(pg, candidates, is_prime);\n        int num_primes = svcntp_b32(pg, is_prime);\n        \n        for (int i = 0; i < num_primes; i++) {\n            int prime = svgetele_s32(prime_results, i);\n            if (prime < n) primes.push_back(prime);\n        }\n        \n        // Next batch of candidates\n        candidates = svadd_s32_z(pg, candidates, vl);\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    \n    for (int candidate = 2; candidate < n; candidate++) {\n        svint32_t vec_candidate = svdup_n_s32(candidate);\n        svbool_t is_prime = svptrue_b32();\n\n        for (int divisor = 2; divisor * divisor <= candidate; divisor++) {\n            svint32_t vec_divisor = svdup_n_s32(divisor);\n            svint32_t remainder = svrem_x(pg, vec_candidate, vec_divisor);\n            is_prime = svand_z(pg, is_prime, svcmpne_x(pg, remainder, svdup_n_s32(0)));\n        }\n\n        if (svcntp_b32(pg, is_prime)) {\n            primes.push_back(candidate);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    \n    for (int candidate = 2; candidate < n; candidate++) {\n        svint32_t vec_candidate = svdup_n_s32(candidate);\n        svbool_t is_prime = svptrue_b32();\n        \n        for (int divisor = 2; divisor * divisor <= candidate; divisor++) {\n            svint32_t vec_divisor = svdup_n_s32(divisor);\n            svint32_t remainder = svrmod_s32_z(pg, vec_candidate, vec_divisor);\n            is_prime = svand_b_z(pg, is_prime, svcmpeq_s32(pg, remainder, svdup_n_s32(0)));\n        }\n        \n        if (svptest_any(pg, is_prime)) {\n            primes.push_back(candidate);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 1) return {};\n\n    std::vector<int> primes;\n    svbool_t pg = svptrue_b32();\n    \n    // Initial candidates\n    svint32_t candidates = svindex_s32(2, 1);\n    \n    // Iterate through potential primes\n    for (int i = 2; i < n; i = svlen_s32(candidates)) {\n        svbool_t is_prime = svptrue_b32();\n        \n        // Check divisibility against previous primes\n        for (int j = 0; j < primes.size(); ++j) {\n            svint32_t divisor = svdup_s32(primes[j]);\n            svint32_t remainder = svmod_s32_z(pg, candidates, divisor);\n            is_prime = svand_b_z(pg, is_prime, svcmpne_s32(pg, remainder, svdup_s32(0)));\n        }\n        \n        // Collect and store new primes\n        int prime_count = svcntp_b32(pg, is_prime);\n        std::vector<int> new_primes(prime_count);\n        svint32_t selected_primes = svcompress_s32_z(is_prime, candidates);\n        svst1_s32(pg, new_primes.data(), selected_primes);\n        \n        primes.insert(primes.end(), new_primes.begin(), new_primes.end());\n        \n        // Generate next batch of candidates\n        candidates = svindex_s32(i + 2, 1);\n    }\n    \n    // Filter out primes less than n\n    primes.erase(std::remove_if(primes.begin(), primes.end(), \n                                [n](int p) { return p >= n; }), \n                 primes.end());\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Create predicate for even indices\n    svbool_t pg = svwhilelt_b8_u64(0, len);\n    \n    // Load characters from the string\n    svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.c_str()));\n    \n    // Create mask for even indices\n    svbool_t even_mask = svzip1_b8(svptrue_b8(), svpfalse_b8());\n    \n    // Mask characters at even indices\n    svchar_t even_chars = svcompressed_char_z(pg, chars, even_mask);\n    \n    // Check for uppercase vowels\n    svbool_t is_upper = svcmpeq_n_u8(pg, even_chars, 'A');\n    is_upper = svorr_b_z(pg, is_upper, svcmpeq_n_u8(pg, even_chars, 'E'));\n    is_upper = svorr_b_z(pg, is_upper, svcmpeq_n_u8(pg, even_chars, 'I'));\n    is_upper = svorr_b_z(pg, is_upper, svcmpeq_n_u8(pg, even_chars, 'O'));\n    is_upper = svorr_b_z(pg, is_upper, svcmpeq_n_u8(pg, even_chars, 'U'));\n    \n    // Count the number of uppercase vowels\n    result = svcntp_b8(pg, is_upper);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Create predicate for even indices\n    svbool_t pg = svwhilelt_b8_u64(0, len);\n    \n    // Process vector chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Load characters from even indices\n        svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Create predicate for even indices within current vector\n        svbool_t even_pred = svzip1_b8(svptrue_b8(), svpfalse_b8());\n        \n        // Check for uppercase vowels\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A');\n        is_upper = svand_b_z(pg, is_upper, svcmple_n_u8(pg, chars, 'Z'));\n        \n        svbool_t is_vowel = svpfalse_b8();\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'A'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'E'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'I'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'O'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'U'));\n        \n        // Combine conditions\n        svbool_t match_pred = svand_b_z(pg, even_pred, is_upper);\n        match_pred = svand_b_z(pg, match_pred, is_vowel);\n        \n        // Count matches\n        result += svcnt_u8_z(pg, match_pred);\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b8_u64(i + svcntb(), len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Create predicate for even indices\n    svbool_t pg = svwhilelt_b8_u64(0, len);\n    \n    // Load string data\n    svchar_t vec_data = svld1_char(pg, reinterpret_cast<const int8_t*>(s.c_str()));\n    \n    // Create mask for even indices\n    svbool_t even_mask = svzip1_b8(svptrue_b8(), svpfalse_b8());\n    \n    // Mask data to only consider even indices\n    svchar_t even_chars = svsel_char(even_mask, vec_data, svdup_char8(0));\n    \n    // Check for uppercase vowels\n    svbool_t is_upper = svcmpge_n_char(pg, even_chars, 'A');\n    svbool_t is_upper_vowel = svbic_b_z(pg, is_upper, \n        svcmpeq_n_char(pg, even_chars, 'E') | \n        svcmpeq_n_char(pg, even_chars, 'I') | \n        svcmpeq_n_char(pg, even_chars, 'O') | \n        svcmpeq_n_char(pg, even_chars, 'U')\n    );\n    \n    // Count uppercase vowels\n    result = svcntp_b8(pg, is_upper_vowel);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Create predicate for even indices\n    svbool_t pg = svwhilelt_b8_u64(0, len);\n    \n    // Load string data\n    svchar_t vec_data = svld1_char(pg, s.data());\n    \n    // Check for uppercase vowels: A, E, I, O, U\n    svbool_t is_upper = svcmpge_n_char(pg, vec_data, 'A');\n    svbool_t is_upper_le = svcmple_n_char(pg, vec_data, 'Z');\n    svbool_t is_upper_vowel = svand_b_z(pg, is_upper, is_upper_le);\n    \n    svbool_t is_vowel = svcmpeq_n_char(pg, vec_data, 'A') |\n                        svcmpeq_n_char(pg, vec_data, 'E') |\n                        svcmpeq_n_char(pg, vec_data, 'I') |\n                        svcmpeq_n_char(pg, vec_data, 'O') |\n                        svcmpeq_n_char(pg, vec_data, 'U');\n    \n    svbool_t is_even_index = svpnext_b8(pg, svptrue_b8(), pg);\n    \n    svbool_t match = svand_b_z(pg, is_upper_vowel, is_vowel);\n    match = svand_b_z(pg, match, is_even_index);\n    \n    result = svcntp_b8(pg, match);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int result = 0;\n    size_t len = s.length();\n    \n    // Create predicate for even indices\n    svbool_t pg = svwhilelt_b8_u64(0, len);\n    \n    // Process vector chunks\n    for (size_t i = 0; i < len; i += svcntb()) {\n        // Load characters from even indices\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for uppercase vowels: A, E, I, O, U\n        svbool_t is_vowel = svcmpeq_u8(pg, chars, 'A');\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, chars, 'E'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, chars, 'I'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, chars, 'O'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, chars, 'U'));\n        \n        // Count uppercase vowels\n        result += svcntp_b8(pg, is_vowel);\n        \n        // Update predicate\n        pg = svwhilelt_b8_u64(i + svcntb(), len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length dynamically\n    const int vec_len = svcntw();\n    \n    // Allocate vector to store results\n    std::vector<int> result(n);\n    \n    // Create initial predicate and vector for first level\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t levels = svindex_s32(1, 1);\n    \n    // First level is always n stones\n    svst1_s32(pg, result.data(), svdup_s32(n));\n    \n    // Compute subsequent levels using SVE vector operations\n    for (int i = 1; i < n; i += vec_len) {\n        // Update predicate for remaining elements\n        pg = svwhilelt_b32(i, n);\n        \n        // Load previous levels\n        svint32_t prev_levels = svld1_s32(pg, result.data() + i - 1);\n        \n        // Compute next levels based on odd/even condition\n        svint32_t next_levels = svadd_s32_z(pg, prev_levels, \n            svsel_s32(svcmpne_s32_z(pg, svand_s32_z(pg, prev_levels, svdup_s32(1)), svdup_s32(0)), \n                      svdup_s32(2), svdup_s32(1)));\n        \n        // Store results\n        svst1_s32(pg, result.data() + i, next_levels);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length dynamically\n    const int vec_len = svcntw();\n    \n    // Allocate vector to store results\n    std::vector<int> result(n);\n    \n    // Create initial predicate and index vector\n    svbool_t pg = svwhilelt_b32_u32(0, n);\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // First level is always n stones\n    svint32_t levels = svdup_s32(n);\n    \n    // Store first level\n    svst1_s32(pg, result.data(), levels);\n    \n    // Process subsequent levels\n    for (int i = 1; i < n; i++) {\n        // Adjust predicate and indices for remaining levels\n        pg = svwhilelt_b32_u32(i, n);\n        \n        // Increment levels based on previous level's parity\n        levels = svadd_s32_z(pg, levels, \n            svsel_s32(svcmpeq_s32(pg, svand_s32_z(pg, levels, svdup_s32(1)), svdup_s32(0)) ? \n                      svdup_s32(2) : svdup_s32(1)\n        ));\n        \n        // Store levels\n        svst1_s32(pg, result.data() + i, levels);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length dynamically\n    const int vec_len = svcntw();\n    \n    // Allocate vector to store results\n    std::vector<int> result(n);\n    \n    // Create initial predicate and vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n    \n    // First level always has n stones\n    svst1_s32(pg, result.data(), svdup_s32(n));\n    \n    // Process subsequent levels\n    for (int level = 1; level < n; level++) {\n        // Load previous level's stone count\n        svint32_t prev_level = svld1_s32(pg, result.data() + level - 1);\n        \n        // Determine next stone count based on odd/even\n        svint32_t next_stones = svadd_s32_z(pg, prev_level, \n            svsel_s32(svcmpeq_s32(pg, svand_s32_z(pg, prev_level, svdup_s32(1)), svdup_s32(0)), \n                      svdup_s32(1), svdup_s32(2)));\n        \n        // Store result\n        svst1_s32(pg, result.data() + level, next_stones);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length dynamically\n    const int vec_len = svcntw();\n    \n    // Allocate vector to store results\n    std::vector<int> result(n);\n    \n    // Create initial predicate and vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n    \n    // First level always has n stones\n    svst1_s32(pg, result.data(), svdup_s32(n));\n    \n    // Compute subsequent levels using SVE vector operations\n    for (int level = 1; level < n; level++) {\n        // Load previous level's stone count\n        svint32_t prev_level = svld1_s32(pg, result.data() + level - 1);\n        \n        // Determine next stone count based on parity\n        svint32_t next_stones = svadd_s32_z(pg, prev_level, \n            svsel_s32(svcmpeq_s32(pg, svand_s32_z(pg, prev_level, svdup_s32(1)), svdup_s32(0)), \n                      svdup_s32(1), svdup_s32(2)));\n        \n        // Store result\n        svst1_s32(pg, result.data() + level, next_stones);\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b32(level + 1, n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    // Determine vector length dynamically\n    const int vec_len = svcntw();\n    \n    // Allocate vector to store results\n    std::vector<int> result(n);\n    \n    // Create initial predicate and vector\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t level_vec = svindex_s32(1, 1);\n    \n    // First level is always n stones\n    result[0] = n;\n    \n    // Use SVE intrinsics to compute subsequent levels\n    for (int i = 1; i < n; i += vec_len) {\n        // Compute next levels\n        svint32_t current_levels = svsel_s32(pg, \n            svparity_s32(level_vec, 1) ? \n            svadd_s32_z(pg, level_vec, 1) : \n            svadd_s32_z(pg, level_vec, 2),\n            svdup_s32(0)\n        );\n        \n        // Store results\n        svst1_s32(pg, &result[i], current_levels);\n        \n        // Update predicate and level vector\n        pg = svwhilelt_b32(i + vec_len, n);\n        level_vec = svadd_s32_z(pg, level_vec, vec_len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate total number of elements\n    int64_t count = m - n + 1;\n    \n    // SVE vector processing\n    svbool_t pg = svptrue_b64();\n    svint64_t vec_n = svdup_n_s64(n);\n    svint64_t vec_step = svdup_n_s64(1);\n    \n    // Generate sequence from n to m\n    svint64_t vec_seq = svindex_s64(n, 1);\n    \n    // Compute sum using SVE reduction\n    svint64_t vec_sum = svaddv_s64(pg, vec_seq);\n    \n    // Compute average and round down\n    int64_t avg = vec_sum / count;\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    // Check if n is greater than m\n    if (n > m) {\n        return \"-1\";\n    }\n\n    // Calculate number of elements\n    int64_t count = m - n + 1;\n\n    // Use SVE to compute sum\n    svbool_t pg = svptrue_b64();\n    svint64_t sum = svdup_n_s64(0);\n    \n    // Process elements in vector chunks\n    for (int64_t i = n; i <= m; i += svcntd()) {\n        // Create vector of consecutive integers starting from current index\n        svint64_t current = svindex_s64(i, 1);\n        \n        // Predicate to handle last incomplete vector\n        svbool_t p = svwhilelt_b64(i, m + 1);\n        \n        // Add current vector elements to sum\n        sum = svadd_m(p, sum, current);\n    }\n\n    // Reduce sum across vector\n    int64_t total_sum = svaddv_m(pg, sum);\n\n    // Compute rounded average\n    int64_t avg = total_sum / count;\n\n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    // Check if n is greater than m\n    if (n > m) return \"-1\";\n\n    // Calculate total number of elements\n    int64_t count = m - n + 1;\n    \n    // Use SVE to compute sum\n    svbool_t pg = svptrue_b64();\n    svint64_t sum = svdup_n_s64(0);\n    \n    // Iterate through the range using SVE vector operations\n    for (int64_t i = n; i <= m; i += svcntd()) {\n        // Create a vector of consecutive integers starting from current index\n        svint64_t vec = svadd_n_s64_x(pg, svindex_s64(i, 1), 0);\n        \n        // Add vector to running sum\n        sum = svadd_s64_x(pg, sum, vec);\n    }\n    \n    // Reduce sum across vector\n    int64_t total_sum = svaddv_s64(pg, sum);\n    \n    // Compute rounded average\n    int64_t avg = total_sum / count;\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate number of elements\n    int64_t count = m - n + 1;\n    \n    // SVE vector length\n    svbool_t pg = svptrue_b64();\n    size_t vec_len = svcntd();\n    \n    // Initialize sum vector\n    svint64_t sum_vec = svdup_n_s64(0);\n    \n    // Process in vector chunks\n    for (int64_t i = 0; i < count; i += vec_len) {\n        // Create vector of sequential indices\n        svint64_t indices = svadd_n_s64_x(pg, svindex_s64(0, 1), n + i);\n        \n        // Limit vector to remaining elements\n        svbool_t active_mask = svwhilelt_b64(i, count);\n        \n        // Add indices to sum vector\n        sum_vec = svadd_s64_m(active_mask, sum_vec, indices);\n    }\n    \n    // Horizontal sum\n    int64_t total_sum = svaddv_s64(pg, sum_vec);\n    \n    // Calculate rounded average\n    int64_t avg = total_sum / count;\n    \n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    // Check if n is greater than m\n    if (n > m) return \"-1\";\n\n    // Calculate total number of elements\n    int64_t count = m - n + 1;\n\n    // Determine vector length\n    size_t vec_len = svcntd();\n    \n    // Initialize sum vector\n    svbool_t pg = svptrue_b64();\n    svint64_t sum_vec = svdup_n_s64(0);\n\n    // Process in vector chunks\n    for (int64_t i = 0; i < count; i += vec_len) {\n        // Create vector of sequential indices\n        svint64_t indices = svadd_n_s64_x(pg, svindex_s64(0, 1), n + i);\n        \n        // Limit vector to remaining elements if needed\n        svbool_t active_mask = svwhilelt_b64(i, count);\n        \n        // Add indices to sum vector\n        sum_vec = svadd_s64_z(active_mask, sum_vec, indices);\n    }\n\n    // Horizontal sum of vector\n    int64_t total_sum = svaddv_s64(pg, sum_vec);\n\n    // Calculate rounded average\n    int64_t avg = total_sum / count;\n\n    // Convert to binary string\n    std::string binary;\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Determine the SVE vector length for integers\n    const int vector_length = svcntw();\n    \n    // Process vector elements in parallel\n    for (int start = 0; start < n; start += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u32(start, n);\n        \n        // Create a vector of indices\n        svint32_t indices = svadd_z(pg, svdup_s32(start + 1), \n                                     svindex_s32(0, 1));\n        \n        // Compute values for each index\n        svint32_t values = svdup_s32(0);\n        values = svsel_z(pg, indices, \n            svcompact_s32(pg, \n                svreinterpret_u32_s32(\n                    svand_z(pg, indices, svdup_s32(1))  // Check if index is odd\n                ),\n                [&](int i) {\n                    // Odd indices: sum of numbers from 1 to i\n                    int sum = (i * (i + 1)) / 2;\n                    return sum;\n                },\n                [&](int i) {\n                    // Even indices: factorial modulo 10000\n                    int factorial = 1;\n                    for (int j = 2; j <= i; j++) {\n                        factorial = (factorial * j) % 10000;\n                    }\n                    return factorial;\n                }\n            )\n        );\n        \n        // Store results back to the vector\n        svst1_z(pg, &result[start], values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Determine the SVE vector length for integers\n    const int vector_length = svcntw();\n    \n    // Process elements in vector chunks\n    for (int i = 0; i < n; i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u32(i, n);\n        \n        // Create a vector of indices starting from current index\n        svint32_t indices = svadd_x(pg, svdup_s32(1), svindex_s32(0, 1));\n        \n        // Compute values based on even/odd indices\n        svint32_t values = svdup_s32(0);\n        \n        // Factorial for even indices\n        svbool_t even_mask = svcmpeq_u32(svumod_x(pg, indices, 2), 0);\n        svint32_t factorial = svdup_s32(1);\n        \n        for (int j = 1; j <= 20; ++j) {  // Limit factorial computation\n            factorial = svmul_x(even_mask, factorial, indices);\n            factorial = svmod_x(even_mask, factorial, 10000);\n        }\n        \n        // Sum for odd indices\n        svint32_t sum = svdiv_x(svcmpne_u32(svumod_x(pg, indices, 2), 0), indices, indices);\n        sum = svmla_x(svcmpne_u32(svumod_x(pg, indices, 2), 0), sum, indices, 1);\n        \n        // Combine results\n        values = svsel_s32(even_mask, factorial, sum);\n        \n        // Store results back to vector\n        svst1_s32(pg, &result[i], values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Determine the vector length for SVE\n    size_t vec_len = svcntw();\n    \n    // Process vector elements in parallel\n    for (int i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Create a vector of indices\n        svint32_t indices = svadd_z(pg, svdup_n_s32(1), svindex_s32(0, 1));\n        \n        // Compute values for each index\n        svint32_t values = svdup_n_s32(0);\n        \n        // Compute values for even and odd indices\n        svbool_t is_even = svcmpeq_z(pg, svand_z(pg, indices, svdup_n_s32(1)), svdup_n_s32(0));\n        \n        // Factorial for even indices\n        svint32_t factorial = svdup_n_s32(1);\n        svint32_t factorial_mask = svdup_n_s32(1);\n        for (int j = 2; j <= 20; j++) {\n            factorial_mask = svmul_z(is_even, factorial_mask, svdup_n_s32(j));\n            factorial = svmul_z(is_even, factorial, svdup_n_s32(j));\n        }\n        factorial = svmod_z(is_even, factorial, svdup_n_s32(10000));\n        \n        // Sum for odd indices\n        svint32_t sum = svdiv_z(svnot_z(is_even, pg), indices, svdup_n_s32(2));\n        sum = svmla_z(svnot_z(is_even, pg), sum, indices, svdup_n_s32(1));\n        \n        // Combine results\n        values = svsel_z(is_even, factorial, sum);\n        \n        // Store results\n        svst1_z(pg, &result[i], values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Determine the SVE vector length for integers\n    const int vector_bytes = svcntw() * sizeof(int32_t);\n    \n    // Process vector chunks\n    for (int start = 0; start < n; start += vector_bytes) {\n        // Determine the number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(start, n);\n        \n        // Create a vector of indices\n        svint32_t indices = svadd_z(pg, svdup_n_s32(start + 1), \n                                     svindex_s32(0, 1));\n        \n        // Compute values for each index\n        svint32_t values = svdup_n_s32(0);\n        \n        // Compute factorial or sum based on even/odd\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_z(pg, indices, 1), 0);\n        \n        // Factorial calculation for even indices\n        {\n            svint32_t factorial = svdup_n_s32(1);\n            svint32_t current_mult = svdup_n_s32(1);\n            \n            for (int j = 1; j <= 10; ++j) {\n                current_mult = svmul_z(pg, current_mult, indices);\n                factorial = svmul_z(pg, factorial, current_mult);\n            }\n            \n            // Modulo 10000\n            factorial = svmod_z(pg, factorial, svdup_n_s32(10000));\n            \n            // Blend factorial for even indices\n            values = svsel_z(is_even, factorial, values);\n        }\n        \n        // Sum calculation for odd indices\n        {\n            svint32_t sum = svdiv_z(pg, svmul_z(pg, indices, \n                                     svadd_z(pg, indices, svdup_n_s32(1))), \n                                     svdup_n_s32(2));\n            \n            // Blend sum for odd indices\n            values = svsel_z(svnot_z(pg, is_even), sum, values);\n        }\n        \n        // Store results back to vector\n        svst1_z(pg, &result[start], values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Determine the vector length supported by SVE\n    size_t vec_len = svcntw();\n    \n    // Process elements in vector chunks\n    for (int i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        // Create a vector of indices starting from current index\n        svint32_t indices = svadd_z(pg, svdup_n_s32(1), svindex_s32(0, 1));\n        \n        // Compute values based on even/odd indices\n        svint32_t values = svdup_n_s32(0);\n        \n        // Factorial for even indices\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_z(pg, indices, svdup_n_s32(1)), 0);\n        svint32_t factorial = svdup_n_s32(1);\n        \n        for (int j = 1; j <= 20; ++j) {\n            factorial = svmul_z(even_mask, factorial, indices);\n            factorial = svmod_n_z(even_mask, factorial, 10000);\n        }\n        \n        // Sum for odd indices\n        svint32_t sum = svdiv_z(svcmpne_n_s32(pg, svand_z(pg, indices, svdup_n_s32(1)), 0), \n                                 svmul_z(pg, indices, svdup_n_s32(2)), \n                                 svdup_n_s32(1));\n        \n        // Combine results\n        values = svsel_z(even_mask, factorial, sum);\n        \n        // Store results back to vector\n        svst1_z(pg, &result[i], values);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    svint32_t even_count = svdup_n_s32(0);\n    svint32_t odd_count = svdup_n_s32(0);\n\n    for (int i = 1; i <= n; i++) {\n        // Check if number is palindrome\n        int num = i;\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n\n        // Use SVE to update even/odd counts\n        if (i == reversed) {\n            svbool_t is_even = svcmpeq_n_s32(pg, svdup_n_s32(i % 2), 0);\n            even_count = svsel_s32(is_even, svadd_n_s32_z(pg, even_count, 1), even_count);\n            odd_count = svsel_s32(svnot_b_z(pg, is_even), svadd_n_s32_z(pg, odd_count, 1), odd_count);\n        }\n    }\n\n    // Reduce vector to scalar\n    int even = svaddv_s32(pg, even_count);\n    int odd = svaddv_s32(pg, odd_count);\n\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    svint32_t even_count = svdup_n_s32(0);\n    svint32_t odd_count = svdup_n_s32(0);\n\n    for (int i = 1; i <= n; i++) {\n        // Check if number is palindrome\n        int num = i;\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n\n        // Use SVE to update even/odd counts\n        if (i == reversed) {\n            svbool_t is_even_mask = svcmpeq_n_s32(pg, svdup_n_s32(i % 2), 0);\n            even_count = svadd_m(is_even_mask, even_count, svdup_n_s32(1));\n            odd_count = svadd_m(svnot_b_z(pg, is_even_mask), odd_count, svdup_n_s32(1));\n        }\n    }\n\n    // Reduce vector to scalar values\n    int even_total = svaddv_s32(pg, even_count);\n    int odd_total = svaddv_s32(pg, odd_count);\n\n    return {even_total, odd_total};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    svint32_t even_count = svdup_n_s32(0);\n    svint32_t odd_count = svdup_n_s32(0);\n\n    for (int i = 1; i <= n; i++) {\n        // Check if number is palindrome\n        int num = i;\n        int reversed = 0;\n        while (num > 0) {\n            reversed = reversed * 10 + num % 10;\n            num /= 10;\n        }\n\n        // If palindrome\n        if (reversed == i) {\n            // Check if even or odd\n            svbool_t is_even = svcmpeq_n_s32(pg, svdup_n_s32(i % 2), 0);\n            even_count = svadd_m(is_even, even_count, svdup_n_s32(1));\n            odd_count = svadd_m(svnot_b_z(pg, is_even), odd_count, svdup_n_s32(1));\n        }\n    }\n\n    int even_result = svaddv_s32(pg, even_count);\n    int odd_result = svaddv_s32(pg, odd_count);\n\n    return {even_result, odd_result};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    // SVE vector processing\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_indices = svindices_s32(pg);\n    \n    // Initialize even and odd palindrome counters\n    int even_count = 0, odd_count = 0;\n    \n    // Process numbers in vector chunks\n    for (int base = 1; base <= n; base += svcntw()) {\n        // Generate vector of current numbers\n        svint32_t current_nums = svadd_s32_x(pg, vec_indices, base);\n        \n        // Mask numbers within range\n        svbool_t valid_mask = svcmple_s32(pg, current_nums, n);\n        \n        // Check palindrome condition\n        svbool_t palindrome_mask = svpfalse_b();\n        for (int i = 0; i < 32; i++) {\n            svint32_t reversed = current_nums;\n            \n            // Reverse number digit by digit\n            svint32_t digit, reversed_num = svdup_s32_z(pg, 0);\n            svbool_t loop_pg = svptrue_b32();\n            \n            while (svptest_any(loop_pg, svcmpne_s32(pg, current_nums, svdup_s32_z(pg, 0)))) {\n                digit = svmod_s32_x(pg, current_nums, svdup_s32_z(pg, 10));\n                reversed_num = svadd_s32_x(pg, svmul_s32_x(pg, reversed_num, svdup_s32_z(pg, 10)), digit);\n                current_nums = svdiv_s32_x(pg, current_nums, svdup_s32_z(pg, 10));\n                \n                loop_pg = svcmpne_s32(pg, current_nums, svdup_s32_z(pg, 0));\n            }\n            \n            // Compare reversed with original\n            palindrome_mask = svorr_b_z(pg, palindrome_mask, \n                svcmpeq_s32(pg, reversed, reversed_num));\n        }\n        \n        // Combine palindrome and valid range masks\n        svbool_t final_mask = svand_b_z(pg, valid_mask, palindrome_mask);\n        \n        // Count even and odd palindromes\n        svint32_t even_mask = svand_s32_x(pg, current_nums, svdup_s32_z(pg, 1));\n        svint32_t odd_mask = svbic_s32_x(pg, current_nums, svdup_s32_z(pg, 1));\n        \n        even_count += svcnt_s32_z(final_mask, even_mask);\n        odd_count += svcnt_s32_z(final_mask, odd_mask);\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_indices = svindx_s32(pg, 1, 1);\n    \n    svint32_t even_count = svdup_s32_z(pg, 0);\n    svint32_t odd_count = svdup_s32_z(pg, 0);\n    \n    for (int i = 1; i <= n; i += svcntw()) {\n        svbool_t mask = svcmple_s32(pg, vec_indices, svdup_s32_z(pg, n));\n        \n        // Check palindrome\n        svint32_t reversed = svdup_s32_z(pg, 0);\n        svint32_t current = svand_s32_z(mask, vec_indices, vec_indices);\n        \n        while (svptest_any(pg, svcmpne_s32(pg, current, svdup_s32_z(pg, 0)))) {\n            reversed = svadd_s32_z(pg, svmul_s32_z(pg, reversed, svdup_s32_z(pg, 10)), \n                                    svmod_s32_z(pg, current, svdup_s32_z(pg, 10)));\n            current = svdiv_s32_z(pg, current, svdup_s32_z(pg, 10));\n        }\n        \n        svbool_t is_palindrome = svcmpeq_s32(pg, reversed, vec_indices);\n        is_palindrome = svand_b_z(pg, is_palindrome, mask);\n        \n        // Count even and odd palindromes\n        svint32_t even_mask = sveor_s32_z(pg, vec_indices, svdup_s32_z(pg, 1));\n        even_mask = svcmpeq_s32(pg, even_mask, vec_indices);\n        even_mask = svand_b_z(pg, even_mask, is_palindrome);\n        \n        even_count = svadd_s32_z(pg, even_count, svreinterpret_s32_b(even_mask));\n        odd_count = svadd_s32_z(pg, odd_count, svreinterpret_s32_b(svnot_b_z(pg, even_mask)));\n        \n        vec_indices = svadd_s32_z(pg, vec_indices, svdup_s32_z(pg, svcntw()));\n    }\n    \n    int even_result = svaddv_s32(pg, even_count);\n    int odd_result = svaddv_s32(pg, odd_count);\n    \n    return {even_result, odd_result};\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t vector_size = n.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, n.data() + i);\n        \n        // Compute absolute value\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract digits\n        svint32_t digit_sum = svdup_s32(0);\n        \n        while (svptest_any_z(pg, svcmpne_s32(abs_vec, svdup_s32(0)))) {\n            svint32_t digit = svmod_s32_z(pg, abs_vec, svdup_s32(10));\n            digit_sum = svadd_s32_z(pg, digit_sum, digit);\n            abs_vec = svdiv_s32_z(pg, abs_vec, svdup_s32(10));\n        }\n        \n        // Check if digit sum is positive\n        svbool_t mask = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        result += svcntp_b32_z(pg, mask);\n        \n        pg = svwhilelt_b32_u64(i + svcntw(), vector_size);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t vector_size = n.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n\n    do {\n        svint32_t vec = svld1_s32(pg, n.data());\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n\n        // Convert to digits\n        svint32_t digit1 = svmod_s32_z(pg, abs_vec, svdup_s32(10));\n        svint32_t remaining = svdiv_s32_z(pg, abs_vec, svdup_s32(10));\n        svint32_t digit2 = svmod_s32_z(pg, remaining, svdup_s32(10));\n        svint32_t remaining2 = svdiv_s32_z(pg, remaining, svdup_s32(10));\n        svint32_t digit3 = svmod_s32_z(pg, remaining2, svdup_s32(10));\n\n        // Sum digits\n        svint32_t digit_sum = svadd_s32_z(pg, digit1, \n                               svadd_s32_z(pg, digit2, digit3));\n\n        // Adjust for negative numbers\n        svint32_t sign_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n        digit_sum = svneg_s32_z(sign_mask, digit_sum);\n\n        // Count numbers with digit sum > 0\n        svbool_t sum_gt_zero = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        result += svcntp_b32(pg, sum_gt_zero);\n\n        // Move to next vector\n        n.erase(n.begin(), n.begin() + svcntw());\n        vector_size = n.size();\n        pg = svwhilelt_b32_u64(0, vector_size);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t vector_size = n.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, n.data() + i);\n        \n        // Compute absolute value\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract digits\n        svint32_t digit_sum = svdup_s32(0);\n        for (int div = 1; div <= 1000000000; div *= 10) {\n            svint32_t digit = svdiv_s32_z(pg, abs_vec, div);\n            digit = svmod_s32_z(pg, digit, 10);\n            digit_sum = svadd_s32_z(pg, digit_sum, digit);\n        }\n        \n        // Compare digit sum > 0\n        svbool_t mask = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        result += svcntp_b32(pg, mask);\n        \n        pg = svwhilelt_b32_u64(i + svcntw(), vector_size);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t vector_size = n.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, n.data() + i);\n        \n        // Compute absolute value\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract digits\n        svint32_t digit_sum = svdup_s32(0);\n        for (int div = 1; div <= 1000000000; div *= 10) {\n            svint32_t digit = svdiv_s32_z(pg, abs_vec, div);\n            digit = svmod_s32_z(pg, digit, 10);\n            digit_sum = svadd_s32_z(pg, digit_sum, digit);\n        }\n        \n        // Check if digit sum > 0\n        svbool_t mask = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        result += svcntp_b32(pg, mask);\n        \n        pg = svwhilelt_b32_u64(i + svcntw(), vector_size);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n\n    int result = 0;\n    size_t vector_size = n.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, n.data() + i);\n        \n        // Compute absolute value\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract digits and compute sum\n        svint32_t digit_sum = svdup_s32(0);\n        for (int div = 1; div <= 1000000000; div *= 10) {\n            svint32_t digit = svdiv_s32_z(pg, abs_vec, div);\n            digit = svmod_s32_z(pg, digit, 10);\n            digit_sum = svadd_s32_z(pg, digit_sum, digit);\n        }\n        \n        // Check if digit sum > 0\n        svbool_t mask = svcmpgt_s32(pg, digit_sum, svdup_s32(0));\n        result += svcntp_b32(pg, mask);\n        \n        pg = svwhilelt_b32_u64(i + svcntw(), vector_size);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find the minimum element's index\n    svint32_t vec = svld1_z(pg, arr.data(), n);\n    svint32_t min_vec = vec;\n    svuint32_t min_idx = svdup_u32(0);\n    \n    for (int i = 1; i < n; ++i) {\n        svbool_t p_min = svcmplt_s32(pg, vec, min_vec);\n        min_vec = svsel_s32(p_min, vec, min_vec);\n        min_idx = svsel_u32(p_min, svdup_u32(i), min_idx);\n    }\n    \n    uint32_t min_index = svaddv_u32(pg, min_idx);\n    \n    // Rotate the array and check if it's sorted\n    std::vector<int> rotated(n);\n    for (int k = 0; k < n; ++k) {\n        bool is_sorted = true;\n        for (int i = 0; i < n; ++i) {\n            rotated[i] = arr[(i + n - k) % n];\n        }\n        \n        svint32_t rot_vec = svld1_z(pg, rotated.data(), n);\n        svbool_t sorted_pred = svcmpge_s32(pg, rot_vec, svext_s32(rot_vec, rot_vec, 1));\n        \n        if (svptest_any(pg, sorted_pred)) {\n            is_sorted = false;\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find the minimum element's index\n    svint32_t vec = svld1_z(pg, arr.data(), n);\n    svint32_t min_vec = vec;\n    svuint32_t min_idx = svdup_u32(0);\n    \n    for (int i = 1; i < n; ++i) {\n        svbool_t p_lt = svcmplt_s32(pg, vec, min_vec);\n        min_vec = svsel_s32(p_lt, vec, min_vec);\n        min_idx = svsel_u32(p_lt, svdup_u32(i), min_idx);\n    }\n    \n    uint32_t min_index = svaddv_u32(pg, min_idx);\n    \n    // Check if rotated array is sorted\n    for (int shift = 0; shift < n; ++shift) {\n        bool is_sorted = true;\n        \n        for (int i = 0; i < n - 1; ++i) {\n            int curr = arr[(min_index + i + shift) % n];\n            int next = arr[(min_index + i + shift + 1) % n];\n            \n            if (curr > next) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find the minimum element's index\n    svint32_t vec = svld1_z(pg, arr.data(), n);\n    svint32_t min_vec = vec;\n    svuint32_t min_idx = svdup_u32(0);\n    \n    for (int i = 1; i < n; ++i) {\n        svbool_t p_lt = svcmplt_s32(pg, vec, min_vec);\n        min_vec = svsel_s32(p_lt, vec, min_vec);\n        min_idx = svsel_u32(p_lt, svdup_u32(i), min_idx);\n    }\n    \n    uint32_t min_index = svaddv_u32(pg, min_idx);\n    \n    // Check if rotated array is sorted\n    for (int shift = 0; shift < n; ++shift) {\n        bool is_sorted = true;\n        \n        for (int i = 0; i < n - 1; ++i) {\n            int curr = arr[(min_index + i + shift) % n];\n            int next = arr[(min_index + i + shift + 1) % n];\n            \n            if (curr > next) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find the minimum element and its index\n    svint32_t vec = svld1_z(pg, arr.data(), n);\n    svint32_t min_vec = svminv_z(pg, vec);\n    \n    // Find the index of the minimum element\n    svbool_t min_mask = svcmpeq_z(pg, vec, min_vec);\n    int min_index = svfirst_z(min_mask, 0);\n    \n    // Rotate the vector to start from the minimum element\n    std::vector<int> rotated(n);\n    for (int i = 0; i < n; i++) {\n        rotated[i] = arr[(i + min_index) % n];\n    }\n    \n    // Check if the rotated vector is sorted\n    svint32_t rotated_vec = svld1_z(pg, rotated.data(), n);\n    svbool_t sorted_mask = svcmpge_z(pg, rotated_vec, svext_z(pg, rotated_vec, rotated_vec, 1));\n    \n    return svptest_first(pg, sorted_mask);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    svbool_t pg = svptrue_b32();\n    \n    // Find the minimum element's index\n    svint32_t vec = svld1_z(pg, arr.data(), n);\n    svint32_t min_vec = vec;\n    svuint32_t min_idx = svdup_u32(0);\n    \n    for (int i = 1; i < n; ++i) {\n        svbool_t p_cmp = svcmplt_s32(pg, vec, min_vec);\n        min_vec = svsel_s32(p_cmp, vec, min_vec);\n        min_idx = svsel_u32(p_cmp, svdup_u32(i), min_idx);\n    }\n    \n    uint32_t min_index = svaddv_u32(pg, min_idx);\n    \n    // Check if the array can be sorted by right shifts\n    for (int shift = 0; shift < n; ++shift) {\n        bool is_sorted = true;\n        for (int j = 1; j < n; ++j) {\n            int prev = arr[(min_index + j - 1) % n];\n            int curr = arr[(min_index + j) % n];\n            if (prev > curr) {\n                is_sorted = false;\n                break;\n            }\n        }\n        if (is_sorted) return true;\n        min_index = (min_index + 1) % n;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Get SVE vector length\n    size_t vector_bytes = svcntw() * sizeof(int);\n    size_t n = lst1.size();\n\n    // Count odd numbers in lst1\n    int odd_count_lst1 = 0;\n    int even_count_lst1 = 0;\n\n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < n; i += vector_bytes) {\n        size_t chunk_size = std::min(vector_bytes, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load vector chunk\n        svint32_t vec1 = svld1_z(pg, lst1.data() + i, chunk_size);\n\n        // Check for odd/even numbers\n        svbool_t odd_mask = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, vec1, 2), 0);\n        svbool_t even_mask = svnot_b_z(pg, odd_mask);\n\n        odd_count_lst1 += svcntp_b32(pg, odd_mask);\n        even_count_lst1 += svcntp_b32(pg, even_mask);\n    }\n\n    // Count odd numbers in lst2\n    int odd_count_lst2 = 0;\n    int even_count_lst2 = 0;\n\n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < n; i += vector_bytes) {\n        size_t chunk_size = std::min(vector_bytes, n - i);\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load vector chunk\n        svint32_t vec2 = svld1_z(pg, lst2.data() + i, chunk_size);\n\n        // Check for odd/even numbers\n        svbool_t odd_mask = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, vec2, 2), 0);\n        svbool_t even_mask = svnot_b_z(pg, odd_mask);\n\n        odd_count_lst2 += svcntp_b32(pg, odd_mask);\n        even_count_lst2 += svcntp_b32(pg, even_mask);\n    }\n\n    // Check if we can exchange elements to make lst1 all even\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Get the vector length for SVE\n    size_t vector_length = svcntw();\n    \n    // Count odd numbers in lst1\n    int odd_count1 = 0;\n    int even_count1 = 0;\n    \n    // Count odd and even numbers in lst2\n    int odd_count2 = 0;\n    int even_count2 = 0;\n    \n    // Process lst1 using SVE\n    for (size_t i = 0; i < lst1.size(); i += vector_length) {\n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, lst1.size());\n        \n        // Load vector of integers\n        svint32_t vec = svld1_z(pg, lst1.data() + i);\n        \n        // Create predicate for odd numbers\n        svbool_t odd_pred = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, vec, 2), 0);\n        \n        // Count odd numbers\n        odd_count1 += svcntp_b32(pg, odd_pred);\n    }\n    \n    even_count1 = lst1.size() - odd_count1;\n    \n    // Process lst2 using SVE\n    for (size_t i = 0; i < lst2.size(); i += vector_length) {\n        // Create predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, lst2.size());\n        \n        // Load vector of integers\n        svint32_t vec = svld1_z(pg, lst2.data() + i);\n        \n        // Create predicate for odd numbers\n        svbool_t odd_pred = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, vec, 2), 0);\n        \n        // Count odd numbers\n        odd_count2 += svcntp_b32(pg, odd_pred);\n    }\n    \n    even_count2 = lst2.size() - odd_count2;\n    \n    // Check if exchange is possible\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd elements in lst1 and even elements in lst2\n    svbool_t pg = svptrue_b32();\n    svint32_t v1 = svld1_z(pg, lst1.data(), n);\n    svint32_t v2 = svld1_z(pg, lst2.data(), n);\n    \n    // Check if element is odd\n    svbool_t odd_mask = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, v1, 2), 0);\n    \n    // Count odd elements in lst1\n    uint64_t odd_count = svcntp_b32(pg, odd_mask);\n    \n    // Check if there are enough even elements in lst2\n    svbool_t even_mask = svcmpeq_n_s32(pg, svrmod_n_s32_z(pg, v2, 2), 0);\n    uint64_t even_count = svcntp_b32(pg, even_mask);\n    \n    return (odd_count <= even_count) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    \n    // Count odd numbers in lst1\n    int odd_count_lst1 = 0;\n    svbool_t pg = svptrue_b32();\n    svint32_t vec1 = svld1_z(pg, lst1.data(), n);\n    svbool_t odd_mask = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, vec1, 2), 0);\n    odd_count_lst1 = svcntp_b32(pg, odd_mask);\n\n    // Count even numbers in lst2\n    svint32_t vec2 = svld1_z(pg, lst2.data(), n);\n    svbool_t even_mask = svcmpeq_n_s32(pg, svrmod_n_s32_z(pg, vec2, 2), 0);\n    int even_count_lst2 = svcntp_b32(pg, even_mask);\n\n    // If we can replace all odd numbers in lst1 with even numbers from lst2\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    // Get the vector length\n    size_t vector_length = lst1.size();\n    \n    // Create SVE predicates and vectors\n    svbool_t pg = svptrue_b32();\n    \n    // Load input vectors into SVE vectors\n    svint32_t vec1 = svld1_z(pg, lst1.data(), vector_length);\n    svint32_t vec2 = svld1_z(pg, lst2.data(), vector_length);\n    \n    // Count odd numbers in lst1\n    svbool_t odd_mask = svcmpne_n_s32(pg, svrmod_n_s32_z(pg, vec1, 2), 0);\n    uint64_t odd_count = svcntp_b32(pg, odd_mask);\n    \n    // Count even numbers in lst2\n    svbool_t even_mask = svcmpeq_n_s32(pg, svrmod_n_s32_z(pg, vec2, 2), 0);\n    uint64_t even_count = svcntp_b32(pg, even_mask);\n    \n    // If number of odd numbers in lst1 is less than or equal to number of even numbers in lst2\n    return (odd_count <= even_count) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        // Count odd digits using SVE\n        svbool_t pg = svptrue_b8();\n        size_t odd_count = 0;\n\n        // Process string in vector chunks\n        for (size_t i = 0; i < str.length(); i += svcntb()) {\n            // Load characters as bytes\n            svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert to numeric value\n            svint8_t digits = svsub_n_s8_z(pg, chars, '0');\n            \n            // Check which digits are odd\n            svbool_t odd_mask = svcmpne_n_s8(pg, svmod_n_s8_z(pg, digits, 2), 0);\n            \n            // Count odd digits in this chunk\n            odd_count += svcntp_b8(pg, odd_mask);\n        }\n\n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        svbool_t pg = svptrue_b8();\n        \n        // Process string in SVE vector chunks\n        for (size_t i = 0; i < str.length(); i += svcntb()) {\n            // Load characters from string\n            svchar_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Convert characters to integers \n            svint8_t digits = svsub_n_s8_z(pg, chars, '0');\n            \n            // Check which digits are odd\n            svbool_t odd_mask = svcmpgt_n_s8(pg, svand_n_s8_z(pg, digits, 1), 0);\n            \n            // Count odd digits in this chunk\n            odd_count += svcntp_b8(pg, odd_mask);\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        // Count odd digits using SVE\n        svbool_t pg = svptrue_b8();\n        size_t odd_count = 0;\n\n        // Process string in SVE vector chunks\n        for (size_t i = 0; i < str.length(); i += svcntb()) {\n            // Load characters and convert to integers\n            svint8_t chars = svld1_s8(pg, reinterpret_cast<const int8_t*>(str.c_str() + i));\n            \n            // Subtract '0' to convert to digit values\n            svint8_t digits = svsub_n_s8_z(pg, chars, '0');\n            \n            // Check which digits are odd\n            svbool_t odd_mask = svcmpne_n_s8(pg, svmod_n_s8_z(pg, digits, 2), 0);\n            \n            // Count odd digits in this chunk\n            odd_count += svcntp_b8(pg, odd_mask);\n        }\n\n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        svbool_t pg = svptrue_b8();\n        \n        for (size_t i = 0; i < str.length(); i += svcntb()) {\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str.c_str() + i));\n            svbool_t is_digit = svcmpge_n_u8(pg, chars, '0');\n            is_digit = svcmplt_n_u8(is_digit, chars, '9' + 1);\n            \n            svuint8_t digit_values = chars - '0';\n            svbool_t is_odd = svrmod_n_u8_z(pg, digit_values, 2);\n            \n            odd_count += svcntp_b8(pg, svand_z(pg, is_digit, is_odd));\n        }\n        \n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \"ng \" + \n                         std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Use SVE to process multiple digits in parallel\n        size_t vector_size = svcntb();\n        for (size_t i = 0; i < str.length(); i += vector_size) {\n            svbool_t pg = svwhilelt_b8_u64(i, str.length());\n            svuint8_t digits = svld1_u8(pg, reinterpret_cast<const uint8_t*>(str.data() + i));\n            \n            // Subtract '0' to convert char digits to numeric values\n            svuint8_t numeric_digits = svsub_u8_z(pg, digits, '0');\n            \n            // Check which digits are odd\n            svbool_t odd_mask = svcmpne_u8(pg, svand_u8_z(pg, numeric_digits, 1), 0);\n            \n            // Count odd digits\n            odd_count += svcntp_b8(pg, odd_mask);\n        }\n        \n        // Create result string\n        result.push_back(\"the number of odd elements \" + std::to_string(odd_count) + \n                         \"n the str\" + std::to_string(odd_count) + \n                         \"ng \" + std::to_string(odd_count) + \" of the \" + \n                         std::to_string(odd_count) + \"nput.\");\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t result = nums[0];\n    int64_t current_sum = 0;\n    svbool_t pg = svptrue_b64();\n    \n    // Load initial vector\n    svint64_t current_vec = svld1_z(pg, nums.data(), nums.size());\n    \n    // Initialize min sum vector with first vector\n    svint64_t min_sum_vec = current_vec;\n    \n    // Compute Kadane's algorithm using SVE\n    for (size_t i = 0; i < nums.size(); i += svcntd()) {\n        // Update current sum\n        current_vec = svld1_z(pg, nums.data() + i, nums.size() - i);\n        current_sum = svminv_z(pg, current_vec);\n        \n        // Update min sum\n        min_sum_vec = svmin_z(pg, min_sum_vec, current_vec);\n        \n        // Update result\n        result = std::min(result, current_sum);\n    }\n    \n    // Horizontal reduction to find overall minimum\n    result = std::min(result, svminv_z(pg, min_sum_vec));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    // Initialize SVE vector length\n    size_t vec_len = svcntd();\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    \n    // Current sum and min sum vector registers\n    svint64_t current_sum_vec = svdup_n_s64(0);\n    svint64_t min_sum_vec = svdup_n_s64(std::numeric_limits<int64_t>::max());\n    \n    // Process data in SVE vector chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine active lanes\n        svbool_t pg = svwhilelt_b64_u64(i, n);\n        \n        // Load vector chunk\n        svint64_t vec = svld1_s64(pg, nums.data() + i);\n        \n        // Update current sum vector\n        current_sum_vec = svadd_s64_z(pg, current_sum_vec, vec);\n        \n        // Update min sum vector\n        min_sum_vec = svmin_s64_z(pg, min_sum_vec, current_sum_vec);\n        \n        // Reset current sum if it becomes positive\n        svbool_t positive_mask = svcmpgt_s64(pg, current_sum_vec, svdup_n_s64(0));\n        current_sum_vec = svsel_s64(positive_mask, svdup_n_s64(0), current_sum_vec);\n    }\n    \n    // Reduce min sum vector to scalar\n    min_sum = svminv_s64(svptrue_b64(), min_sum_vec);\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    // Initialize SVE vector length\n    size_t vec_len = svcntd();\n    \n    // Initialize minimum sum with first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n\n    // Process vectors in chunks\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine number of elements to process in this iteration\n        svbool_t pg = svwhilelt_b64(i, n);\n        \n        // Load vector of integers\n        svint64_t vec = svld1_s64(pg, nums.data() + i);\n        \n        // Compute cumulative sums\n        svint64_t cumulative_sum = svprefix_s64(pg, current_sum, vec);\n        \n        // Find minimum value in cumulative sum vector\n        svint64_t min_vec = svminv_s64(pg, cumulative_sum);\n        \n        // Update min_sum if necessary\n        min_sum = std::min(min_sum, svgetlane_s64(min_vec, 0));\n        \n        // Update current sum for next iteration\n        current_sum = svgetlane_s64(cumulative_sum, vec_len - 1);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    // Initial min sum is the first element\n    int64_t min_sum = nums[0];\n    int64_t current_sum = 0;\n\n    // Determine SVE vector length for int64_t\n    size_t vec_len = svcntd();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vec_len, n - i);\n        svbool_t pg = svwhilelt_b64(i, n);\n\n        // Load vector of integers\n        svint64_t vec = svld1_s64(pg, nums.data() + i);\n\n        // Compute cumulative sum\n        svint64_t cumulative_sum = svprefix_s64(pg, current_sum, vec);\n\n        // Find minimum value in the vector\n        svint64_t min_vec = svminv_s64(pg, cumulative_sum);\n        int64_t vec_min = svlastb_s64(pg, min_vec);\n\n        min_sum = std::min(min_sum, vec_min);\n        current_sum = svlastb_s64(pg, cumulative_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    // Initialize SVE vector length\n    size_t vec_len = svcntsd();\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    \n    // Process in vector chunks\n    for (size_t start = 0; start < n; start += vec_len) {\n        svbool_t pg = svwhilelt_b64(start, n);\n        svint64_t current_vec = svld1_z(pg, nums.data() + start, 0);\n        \n        // Compute running sum and track minimum\n        svint64_t running_sum = current_vec;\n        svint64_t min_vec = running_sum;\n        \n        // Scan through subsequent elements\n        for (size_t j = start + vec_len; j < n; j++) {\n            pg = svwhilelt_b64(start, j);\n            svint64_t next_vec = svld1_z(pg, nums.data() + j, 0);\n            \n            running_sum = svadd_z(pg, running_sum, next_vec);\n            min_vec = svmin_z(pg, min_vec, running_sum);\n        }\n        \n        // Reduce minimum across vector\n        int64_t local_min = svminv_z(svptrue_b64(), min_vec);\n        min_sum = std::min(min_sum, local_min);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n    \n    // Use SVE to count total water in parallel\n    for (int r = 0; r < rows; r += svcntw()) {\n        int remaining_rows = std::min(svcntw(), rows - r);\n        svbool_t pg = svwhilelt_b32(0, remaining_rows);\n        \n        svint32_t row_water = svdup_n_s32(0);\n        \n        for (int c = 0; c < cols; c++) {\n            svint32_t water_vec = svdup_n_s32(0);\n            \n            for (int i = 0; i < remaining_rows; i++) {\n                if (grid[r + i][c]) {\n                    water_vec = svset_s32(water_vec, svptrue_b32(), i, 1);\n                }\n            }\n            \n            row_water = svadd_s32_z(pg, row_water, water_vec);\n        }\n        \n        // Reduce vector to scalar sum\n        int32_t row_total = svaddv_s32(pg, row_water);\n        total_water += row_total;\n    }\n    \n    // Calculate number of bucket lowerings\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Use SVE vector length\n    int vec_len = svcntw();\n    \n    // Total water units\n    svint32_t total_water = svdup_n_s32(0);\n    \n    for (int r = 0; r < rows; r++) {\n        // Process grid row in vector chunks\n        for (int c = 0; c < cols; c += vec_len) {\n            // Determine active elements\n            svbool_t pg = svwhilelt_b32_u32(c, cols);\n            \n            // Load water units from current row\n            svint32_t water_vec = svld1_s32(pg, grid[r].data() + c);\n            \n            // Sum water units in this vector chunk\n            svint32_t chunk_sum = svadd_s32_z(pg, water_vec, svdup_n_s32(0));\n            total_water = svadd_s32_x(svptrue_b32(), total_water, chunk_sum);\n        }\n    }\n    \n    // Reduce total water to scalar\n    int total_water_scalar = svaddv_s32(svptrue_b32(), total_water);\n    \n    // Calculate number of bucket lowerings\n    return (total_water_scalar + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Use SVE vector length\n    int vec_len = svcntw();\n    \n    // Total water units\n    svint32_t total_water = svdup_n_s32(0);\n    \n    for (int r = 0; r < rows; r++) {\n        // Create SVE vector for current row\n        svbool_t pg = svwhilelt_b32_u32(0, cols);\n        svint32_t row_water = svld1_s32(pg, grid[r].data());\n        \n        // Sum water units in this row\n        svint32_t row_sum = svadd_s32_z(pg, row_water, svdup_n_s32(0));\n        total_water = svadd_s32_x(svptrue_b32(), total_water, row_sum);\n    }\n    \n    // Reduce vector sum to scalar\n    int total_water_scalar = svaddv_s32(svptrue_b32(), total_water);\n    \n    // Calculate number of bucket lowerings\n    return (total_water_scalar + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Total water units calculation using SVE\n    svint32_t total_water = svdup_n_s32(0);\n    \n    for (int r = 0; r < rows; r++) {\n        // Create SVE vector for current row\n        svbool_t pg = svwhilelt_b32_u32(0, cols);\n        svint32_t row_vec = svld1_s32(pg, grid[r].data());\n        \n        // Sum water units in current row\n        svint32_t row_water = svreinterpret_u32_s32(svaddv_s32(pg, row_vec));\n        total_water = svadd_s32_z(pg, total_water, row_water);\n    }\n    \n    // Horizontal sum of total water\n    int total_water_sum = svaddv_s32(svptrue_b32(), total_water);\n    \n    // Calculate number of bucket lowerings\n    return (total_water_sum + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_water = 0;\n\n    // Use SVE to count total water in parallel\n    svint32_t total_water_vec = svdup_n_s32(0);\n    \n    for (int r = 0; r < rows; r++) {\n        // Create SVE vector for current row\n        svbool_t pg = svwhilelt_b32_u32(0, cols);\n        svint32_t row_vec = svld1_s32(pg, grid[r].data());\n        \n        // Sum water in current row\n        svint32_t row_water = svaddv_s32(pg, row_vec);\n        total_water += svget_s32(row_water, 0);\n    }\n\n    // Calculate number of bucket lowerings needed\n    int bucket_lowerings = (total_water + capacity - 1) / capacity;\n    return bucket_lowerings;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n    \n    // Use SVE predicate to select even positions and odd values\n    svbool_t pg = svwhilelt_b16_u64(0, n);\n    svint16_t vec = svld1_z(pg, lst.data());\n    \n    // Create predicate for even indices (0, 2, 4, ...)\n    svbool_t even_indices = svzip1_b16(svptrue_b16(), svpfalse_b16());\n    \n    // Create predicate for odd values\n    svbool_t odd_values = svcmpne_n_s16(pg, svand_s16_z(pg, vec, svdup_n_s16_z(pg, 1)), 0);\n    \n    // Combine predicates: even indices AND odd values\n    svbool_t final_pred = svand_b_z(pg, even_indices, odd_values);\n    \n    // Select and sum values that meet both conditions\n    svint16_t selected = svsel_s16(final_pred, vec, svdup_n_s16_z(pg, 0));\n    svint64_t sum = svaddv_s16(pg, selected);\n    \n    result = svlasta_s64(pg, sum);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n    \n    // Process vector in SVE vector length chunks\n    size_t vec_len = svcntb() / sizeof(int16_t);\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b16_u64(i, n);\n        \n        // Load even-indexed elements\n        svint16_t vec = svld1_gather_index_s16(pg, lst.data(), 2);\n        \n        // Create predicate for odd elements\n        svbool_t odd_pred = svcmpne_n_s16(pg, svrmod_n_s16_z(pg, vec, 2), 0);\n        \n        // Sum odd elements\n        svint16_t odd_vec = svcompact_s16(odd_pred, vec);\n        svint64_t sum_vec = svcvt_s64_s16_z(pg, odd_vec);\n        result += svaddv_s64(pg, sum_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n\n    // Create SVE predicate vector to select even positions\n    svbool_t pg = svwhilelt_b16_u64(0, n);\n    \n    // Load input vector\n    svint16_t vec = svld1_z(pg, lst.data());\n    \n    // Create predicate for even positions\n    svbool_t even_pos_pred = svzip1_b16(svptrue_b16(), svpfalse_b16());\n    \n    // Create predicate for odd elements\n    svbool_t odd_elem_pred = svcmpne_n_s16(pg, svand_s16_z(pg, vec, svdup_n_s16_z(pg, 1)), 0);\n    \n    // Combine predicates\n    svbool_t final_pred = svand_b_z(pg, even_pos_pred, odd_elem_pred);\n    \n    // Select and sum odd elements in even positions\n    svint16_t selected = svsel_s16(final_pred, vec, svdup_n_s16_z(pg, 0));\n    svint64_t sum = svcvt_s64_s16_z(pg, selected);\n    result = svaddv_s64(pg, sum);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n    \n    // Process vector in SVE vector lengths\n    size_t vec_size = svcntb() / sizeof(int16_t);\n    \n    for (size_t i = 0; i < n; i += vec_size) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b16_u64(i, n);\n        \n        // Load vector of 16-bit integers\n        svint16_t vec = svld1_s16(pg, lst.data() + i);\n        \n        // Create mask for even positions\n        svbool_t even_pos_mask = svzip1_b16(svpfalse_b(), svptrue_b16());\n        \n        // Mask vector to get elements in even positions\n        svint16_t even_pos_vec = svcompact_s16(pg, vec, svand_z(pg, even_pos_mask, pg));\n        \n        // Create mask for odd elements\n        svbool_t odd_mask = svcmpne_n_s16(pg, svmod_s16_z(pg, even_pos_vec, 2), 0);\n        \n        // Compact odd elements\n        svint16_t odd_vec = svcompact_s16(pg, even_pos_vec, odd_mask);\n        \n        // Sum odd elements\n        int64_t vec_sum = svaddv_s16(pg, odd_vec);\n        \n        result += vec_sum;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    int64_t result = 0;\n    \n    // Create SVE predicate for even positions\n    svbool_t pg = svwhilelt_b16_u64(0, n);\n    \n    // Load vector\n    svint16_t vec = svld1_z(pg, lst.data());\n    \n    // Create predicate for odd elements in even positions\n    svbool_t odd_pred = svcmpne_n_s16(pg, svrmod_n_s16_z(pg, vec, 2), 0);\n    odd_pred = svand_z(pg, odd_pred, svptrue_pat_b16(SV_VL1));\n    \n    // Sum odd elements in even positions\n    svint16_t odd_vec = svcompact_s16(odd_pred, vec);\n    svint64_t sum_vec = svcvt_s64_s16_z(pg, odd_vec);\n    int64_t sum = svaddv_s64(pg, sum_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg = svptrue_b32();\n    \n    for (int i = 0; i < k; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        svbool_t two_digit_mask = svcmpge_s32(pg, svabs_s32(vec), 10);\n        two_digit_mask = svnot_b_z(pg, two_digit_mask);\n        \n        svint32_t filtered_vec = svsel_s32(two_digit_mask, vec, svdup_s32(0));\n        sum += svaddv_s32(pg, filtered_vec);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg = svwhilelt_b32_u32(0, k);\n    \n    for (int i = 0; i < k; i += svcntw()) {\n        svint32_t vec = svld1_z(pg, arr.data() + i);\n        \n        // Create predicate for two-digit numbers\n        svbool_t two_digit_pred = svcmpge_n_s32(pg, svabs_s32_z(pg, vec), 10);\n        svbool_t two_digit_pred_inv = svnot_b_z(pg, two_digit_pred);\n        \n        // Sum two-digit numbers\n        svint32_t two_digit_vec = svsel_s32(two_digit_pred_inv, vec, svdup_n_s32(0));\n        int partial_sum = svaddv_s32(pg, two_digit_vec);\n        \n        sum += partial_sum;\n        pg = svwhilelt_b32_u32(i + svcntw(), k);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg = svwhilelt_b32_u32(0, k);\n    \n    for (int i = 0; i < k; i += svcntw()) {\n        svint32_t vec = svld1_z(pg, arr.data() + i);\n        \n        // Check if element is between 10 and 99\n        svbool_t two_digit_mask = svcmpge_n_s32(pg, vec, 10);\n        two_digit_mask = svcmplt_n_s32(two_digit_mask, vec, 100);\n        \n        // Mask the vector with two-digit elements\n        svint32_t two_digit_vec = svsel_s32(two_digit_mask, vec, svdup_n_s32(0));\n        \n        // Sum the masked vector\n        sum += svaddv_s32(pg, two_digit_vec);\n        \n        // Update predicate for next iteration\n        pg = svwhilelt_b32_u32(i + svcntw(), k);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    // Process vector chunks\n    for (size_t i = 0; i < k; i += vector_length) {\n        size_t remaining = std::min(vector_length, k - i);\n        svbool_t pg = svwhilelt_b32(i, k);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        \n        // Create predicate for two-digit numbers (10 <= abs(x) <= 99)\n        svbool_t two_digit_mask = \n            svcmpge_s32(pg, svabs_s32_z(pg, vec), 10) & \n            svcmple_s32(pg, svabs_s32_z(pg, vec), 99);\n        \n        // Sum two-digit numbers\n        svint32_t two_digit_nums = svsel_s32(two_digit_mask, vec, svdup_s32(0));\n        sum += svaddv_s32(pg, two_digit_nums);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    svbool_t pg = svptrue_b32();\n    \n    // Process vector in SVE vector lengths\n    for (int i = 0; i < k; i += svcntw()) {\n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        \n        // Create predicate for two-digit numbers (10 <= abs(x) <= 99)\n        svbool_t two_digit_mask = \n            svcmpge_s32(pg, svabs_s32(vec), svdup_s32(10)) & \n            svcmple_s32(pg, svabs_s32(vec), svdup_s32(99));\n        \n        // Select two-digit numbers and sum them\n        svint32_t two_digit_nums = svsel_s32(two_digit_mask, vec, svdup_s32(0));\n        sum += svaddv_s32(pg, two_digit_nums);\n    }\n    \n    // Handle remaining elements sequentially\n    for (int i = (k / svcntw()) * svcntw(); i < k; ++i) {\n        int num = std::abs(arr[i]);\n        if (num >= 10 && num <= 99) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t vector_size = lst.size();\n    svbool_t pg = svwhilelt_b32_u32(0, vector_size);\n    \n    // Load first vector chunk\n    svint32_t current = svld1_z(pg, lst.data());\n    \n    // Shift vector for comparison\n    svint32_t next = svext_s32(current, svdup_s32(0), 1);\n    \n    // Check if sorted\n    svbool_t sorted_check = svcmpge_s32(pg, current, next);\n    \n    // Check for duplicates\n    svbool_t duplicate_check = svcmpeq_s32(pg, current, next);\n    \n    // Advance through vector\n    size_t index = svcntw();\n    while (index < vector_size) {\n        pg = svwhilelt_b32_u32(index, vector_size);\n        \n        current = svld1_z(pg, lst.data() + index);\n        next = svext_s32(current, svdup_s32(0), 1);\n        \n        sorted_check = svand_z(pg, sorted_check, svcmpge_s32(pg, current, next));\n        duplicate_check = svand_z(pg, duplicate_check, svcmpeq_s32(pg, current, next));\n        \n        index += svcntw();\n    }\n    \n    // Reduce vector checks to scalar\n    bool is_sorted = svptest_any(svptrue_b32(), sorted_check);\n    bool has_duplicates = svptest_any(svptrue_b32(), duplicate_check);\n    \n    return is_sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t vector_size = lst.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n    \n    // Load first vector\n    svint32_t current = svld1_z(pg, lst.data());\n    \n    // Shift vector for comparison\n    svint32_t next = svext_s32(current, svdup_s32(0), 1);\n    \n    // Check if sorted\n    svbool_t sorted_check = svcmpge_s32(pg, current, next);\n    \n    // Check for duplicates\n    svbool_t duplicate_check = svcmpeq_s32(pg, current, next);\n    \n    // Combine checks\n    svbool_t combined_check = svorr_b_z(pg, sorted_check, duplicate_check);\n    \n    // If any element violates sorting or has more than one duplicate, return false\n    if (svptest_any_z(pg, combined_check)) {\n        return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t vector_size = lst.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n    \n    // Load first vector chunk\n    svint32_t current = svld1_z(pg, lst.data());\n    \n    // Shift vector for comparison\n    svint32_t next = svext_s32(current, svdup_s32(0), 1);\n    \n    // Check if sorted\n    svbool_t sorted_check = svcmpge_s32(pg, current, next);\n    \n    // Check for duplicates\n    svbool_t unique_check = svcmpgt_s32(pg, current, next);\n    \n    // Advance through vector\n    size_t index = svcntw();\n    while (index < vector_size) {\n        pg = svwhilelt_b32_u64(index, vector_size);\n        \n        current = svld1_z(pg, lst.data() + index);\n        next = svext_s32(current, svdup_s32(0), 1);\n        \n        sorted_check = svand_z(pg, sorted_check, svcmpge_s32(pg, current, next));\n        unique_check = svand_z(pg, unique_check, svcmpgt_s32(pg, current, next));\n        \n        index += svcntw();\n    }\n    \n    // Check final conditions\n    return !svptest_any(svptrue_b32(), sorted_check) && \n           !svptest_any(svptrue_b32(), unique_check);\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    size_t vector_size = lst.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n    \n    // Load first vector\n    svint32_t current = svld1_z(pg, lst.data());\n    \n    // Shift vector for comparison\n    svint32_t next = svext_s32(current, svdup_s32(0), 1);\n    \n    // Check if current is less than next\n    svbool_t sorted_check = svcmplt_s32(pg, current, next);\n    \n    // Check for duplicates\n    svbool_t unique_check = svcmpne_s32(pg, current, next);\n    \n    // Combine checks\n    svbool_t combined_check = svand_b_z(pg, sorted_check, unique_check);\n    \n    // Advance vector and continue checking\n    size_t index = svcntw();\n    while (index < vector_size) {\n        pg = svwhilelt_b32_u64(index, vector_size);\n        \n        current = svld1_z(pg, lst.data() + index);\n        next = svext_s32(current, svdup_s32(0), 1);\n        \n        sorted_check = svcmplt_s32(pg, current, next);\n        unique_check = svcmpne_s32(pg, current, next);\n        \n        combined_check = svand_b_z(pg, combined_check, sorted_check, unique_check);\n        \n        index += svcntw();\n    }\n    \n    return svptest_any_z(svptrue_b32(), combined_check);\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n\n    // Get SVE vector length for integers\n    size_t vec_len = svcntw();\n    \n    // Process vector in chunks of SVE vector length\n    for (size_t i = 0; i < lst.size(); i += vec_len) {\n        size_t remaining = std::min(vec_len, lst.size() - i);\n        \n        // Load vector chunk\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        svint32_t current = svld1_s32(pg, &lst[i]);\n        \n        // Check if chunk is sorted and no duplicates\n        svbool_t sorted_mask = svcmpge_s32(pg, current, svext_s32(current, current, 1));\n        svbool_t unique_mask = svcmpne_s32(pg, current, svext_s32(current, current, 1));\n        \n        // If chunk is not sorted or has duplicates, return false\n        if (!svptest_any(pg, sorted_mask) || !svptest_all(pg, unique_mask)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int total_sign = 1;\n    int64_t sum_magnitude = 0;\n\n    // Get SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < arr.size(); i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        \n        // Get sign of each element\n        svint32_t signs = svsignum_s32(pg, vec);\n        \n        // Compute product of signs\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Accumulate signs\n        svint32_t sign_accumulator = signs;\n        sign_accumulator = svmul_s32_z(pg, sign_accumulator, signs);\n        \n        // Accumulate magnitudes\n        svint64_t magnitude_accumulator = svcvt_f64_s32_z(pg, abs_vec);\n        \n        // Reduce signs and magnitudes\n        int32_t chunk_sign = svaddv_s32(pg, sign_accumulator);\n        int64_t chunk_magnitude = svaddv_s64(pg, magnitude_accumulator);\n        \n        total_sign *= chunk_sign;\n        sum_magnitude += chunk_magnitude;\n    }\n    \n    return total_sign * sum_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int vector_length = arr.size();\n    svbool_t pg = svwhilelt_b32_u32(0, vector_length);\n    \n    // Load vector\n    svint32_t vec = svld1_z(pg, arr.data());\n    \n    // Compute sign of each element\n    svint32_t signs = svsignum_z(pg, vec);\n    \n    // Compute product of signs\n    svint32_t sign_prod = svreduce_mul_z(pg, signs);\n    \n    // Compute absolute values\n    svint32_t abs_vec = svabs_z(pg, vec);\n    \n    // Compute sum of magnitudes\n    svint32_t magnitude_sum = svreduce_add_z(pg, abs_vec);\n    \n    // Multiply sum of magnitudes by product of signs\n    int result = sign_prod * magnitude_sum;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int total_sign = 1;\n    int total_magnitude = 0;\n\n    // Get SVE vector length\n    size_t vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < arr.size(); i += vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vector_length, arr.size() - i);\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n\n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n\n        // Get sign of each element\n        svint32_t signs = svcmpgt_s32(pg, vec, 0);\n        svint32_t neg_signs = svcmplt_s32(pg, vec, 0);\n        svint32_t zero_signs = svcmpeq_s32(pg, vec, 0);\n\n        // Compute sign product\n        int chunk_sign_product = 1;\n        if (svptest_any(pg, neg_signs)) chunk_sign_product = -1;\n        if (svptest_any(pg, zero_signs)) chunk_sign_product = 0;\n        total_sign *= chunk_sign_product;\n\n        // Compute absolute values and sum magnitudes\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        int32_t chunk_magnitude = svaddv_s32(pg, abs_vec);\n        total_magnitude += chunk_magnitude;\n    }\n\n    return total_sign * total_magnitude;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int total_sign = 1;\n    int total_magnitude = 0;\n\n    // Get SVE vector length\n    size_t vec_len = svcntw();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < arr.size(); i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, arr.size());\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, arr.data() + i);\n        \n        // Get sign of each element\n        svint32_t signs = svsignum_s32(pg, vec);\n        \n        // Get absolute values\n        svint32_t magnitudes = svabs_s32_z(pg, vec);\n        \n        // Compute sign product\n        svint32_t sign_prod = svmul_s32_z(pg, signs, 1);\n        total_sign *= svaddv_s32(pg, sign_prod);\n        \n        // Compute magnitude sum\n        total_magnitude += svaddv_s32(pg, magnitudes);\n    }\n\n    // If total sign is 0, return 0\n    if (total_sign == 0) return 0;\n    \n    // Return magnitude sum with sign\n    return total_magnitude * total_sign;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n\n    int vector_length = arr.size();\n    svbool_t pg = svwhilelt_b32_u32(0, vector_length);\n    \n    // Load vector\n    svint32_t vec = svld1_z(pg, arr.data());\n    \n    // Compute sign of each element\n    svint32_t signs = svsignum_z(pg, vec);\n    \n    // Compute product of signs\n    svint32_t sign_product = svreduce_mul_z(pg, signs);\n    \n    // Compute absolute values\n    svint32_t abs_vec = svabs_z(pg, vec);\n    \n    // Compute sum of magnitudes\n    svint32_t magnitude_sum = svreduce_add_z(pg, abs_vec);\n    \n    // Multiply sum of magnitudes by product of signs\n    int result = sign_product * magnitude_sum;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize first step\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = grid[i][j];\n        }\n    }\n\n    // Directions: up, down, left, right\n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n\n    // SVE vector processing for path finding\n    for (int step = 2; step <= k; step++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                svint32_t min_path = svdup_n_s32(INT_MAX);\n                svint32_t current_val = svdup_n_s32(grid[i][j]);\n\n                for (int dir = 0; dir < 4; dir++) {\n                    int ni = i + dx[dir];\n                    int nj = j + dy[dir];\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        svint32_t prev_path = svdup_n_s32(dp[ni][nj][step - 1]);\n                        svint32_t candidate_path = svadd_n_s32_z(svptrue_b32(), prev_path, current_val);\n                        min_path = svmin_s32_z(svptrue_b32(), min_path, candidate_path);\n                    }\n                }\n\n                // Reduce SVE vector to scalar\n                int min_path_scalar = svminv_s32(svptrue_b32(), min_path);\n\n                if (min_path_scalar != INT_MAX) {\n                    dp[i][j][step] = min_path_scalar;\n                    \n                    // Reconstruct path\n                    for (int dir = 0; dir < 4; dir++) {\n                        int ni = i + dx[dir];\n                        int nj = j + dy[dir];\n\n                        if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                            if (dp[ni][nj][step - 1] + grid[i][j] == min_path_scalar) {\n                                paths[i][j][step] = grid[i][j];\n                                break;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Find minimum path\n    int min_val = INT_MAX;\n    std::vector<int> result;\n    result.reserve(k);\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n                result.clear();\n                for (int step = 1; step <= k; step++) {\n                    result.push_back(paths[i][j][step]);\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    svbool_t pg = svptrue_b32();\n    \n    // Parallel search for minimum path\n    svint32_t min_path_vec = svdup_n_s32(INT_MAX);\n    svint32_t current_path_vec = svdup_n_s32(0);\n    \n    // Parallel exploration of possible starting points\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            svint32_t current_cell = svdup_n_s32(grid[start_row][start_col]);\n            \n            // Parallel path exploration\n            for (int step = 1; step < k; ++step) {\n                // Parallel neighbor exploration\n                svint32_t neighbor_values = svdup_n_s32(0);\n                \n                // Check up neighbor\n                if (start_row > 0) {\n                    neighbor_values = svadd_m(pg, neighbor_values, \n                        svdup_n_s32(grid[start_row-1][start_col]));\n                }\n                \n                // Check down neighbor\n                if (start_row < N-1) {\n                    neighbor_values = svadd_m(pg, neighbor_values, \n                        svdup_n_s32(grid[start_row+1][start_col]));\n                }\n                \n                // Check left neighbor\n                if (start_col > 0) {\n                    neighbor_values = svadd_m(pg, neighbor_values, \n                        svdup_n_s32(grid[start_row][start_col-1]));\n                }\n                \n                // Check right neighbor\n                if (start_col < N-1) {\n                    neighbor_values = svadd_m(pg, neighbor_values, \n                        svdup_n_s32(grid[start_row][start_col+1]));\n                }\n                \n                // Select minimum neighbor\n                current_cell = svmin_m(pg, current_cell, neighbor_values);\n            }\n            \n            // Compare current path with minimum path\n            svbool_t is_smaller = svcmplt_m(pg, current_cell, min_path_vec);\n            min_path_vec = svsel_m(is_smaller, current_cell, min_path_vec);\n        }\n    }\n    \n    // Convert SVE vector to standard vector\n    for (int i = 0; i < k; ++i) {\n        result[i] = svgetlane_s32(min_path_vec, i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize base case\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: right, down, left, up\n    svint32_t dx = svdup_s32(0);\n    svint32_t dy = svdup_s32(0);\n    svbool_t pg = svptrue_b32();\n\n    dx = svset_s32(dx, pg, 0, 1);\n    dx = svset_s32(dx, pg, 1, -1);\n    dy = svset_s32(dy, pg, 0, 0);\n    dy = svset_s32(dy, pg, 1, 0);\n\n    // Dynamic programming with SVE\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + svget_s32(dx, d);\n                    int nj = j + svget_s32(dy, d);\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        if (dp[i][j][len] > dp[ni][nj][len-1] + grid[i][j]) {\n                            dp[i][j][len] = dp[ni][nj][len-1] + grid[i][j];\n                            paths[i][j][len] = paths[ni][nj][len-1];\n                            paths[i][j][len].push_back(grid[i][j]);\n                        } else if (dp[i][j][len] == dp[ni][nj][len-1] + grid[i][j]) {\n                            // Lexicographically smaller path\n                            std::vector<int> candidate_path = paths[ni][nj][len-1];\n                            candidate_path.push_back(grid[i][j]);\n                            if (candidate_path < paths[i][j][len]) {\n                                paths[i][j][len] = candidate_path;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Find minimum path\n    std::vector<int> min_path;\n    int min_val = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n                min_path = paths[i][j][k];\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<int> result(k);\n    svbool_t pg = svptrue_b32();\n    \n    // Parallel search for minimum path\n    svint32_t min_path_vec = svdup_n_s32(INT_MAX);\n    svint32_t current_path_vec = svdup_n_s32(0);\n    \n    // Parallel DFS with SVE intrinsics\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            std::vector<int> current_path(k);\n            current_path[0] = grid[start_row][start_col];\n            \n            // Parallel path exploration\n            svint32_t current_row = svdup_n_s32(start_row);\n            svint32_t current_col = svdup_n_s32(start_col);\n            \n            for (int path_len = 1; path_len < k; ++path_len) {\n                // Parallel neighbor exploration\n                svint32_t delta_row = svadd_x(pg, current_row, svdup_n_s32(-1));\n                svint32_t delta_col = svadd_x(pg, current_col, svdup_n_s32(-1));\n                \n                // Check valid neighbors\n                svbool_t valid_neighbor = svcmpge_x(pg, delta_row, svdup_n_s32(0)) &&\n                                          svcmplt_x(pg, delta_row, svdup_n_s32(N)) &&\n                                          svcmpge_x(pg, delta_col, svdup_n_s32(0)) &&\n                                          svcmplt_x(pg, delta_col, svdup_n_s32(N));\n                \n                // Select minimum neighbor value\n                svint32_t neighbor_value = svsel_s32(valid_neighbor, \n                    svdup_n_s32(grid[svcvt_s32_x(pg, delta_row)][svcvt_s32_x(pg, delta_col)]), \n                    svdup_n_s32(INT_MAX));\n                \n                current_path[path_len] = svadd_x(pg, current_path[path_len-1], neighbor_value);\n                \n                // Update current position\n                current_row = delta_row;\n                current_col = delta_col;\n            }\n            \n            // Compare paths lexicographically\n            svbool_t is_smaller = svaclt_x(pg, current_path_vec, min_path_vec);\n            min_path_vec = svsel_s32(is_smaller, current_path_vec, min_path_vec);\n            \n            if (svptest_any(pg, is_smaller)) {\n                result = current_path;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n#include <limits>\n#include <queue>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    const int dx[] = {0, 0, 1, -1};\n    const int dy[] = {1, -1, 0, 0};\n\n    // SVE vector width determination\n    const int vector_bytes = svcntb();\n    const int vector_ints = vector_bytes / sizeof(int);\n\n    // Parallel BFS with SVE\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N));\n    std::queue<std::pair<int, int>> q;\n\n    // Parallel initialization of start points\n    svbool_t pg = svptrue_b32();\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            paths[i][j] = {grid[i][j]};\n            q.push({i, j});\n        }\n    }\n\n    // BFS with SVE path tracking\n    while (!q.empty() && paths[q.front().first][q.front().second].size() < k) {\n        int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\n        // Parallel neighbor exploration using SVE\n        for (int d = 0; d < 4; d++) {\n            int nx = x + dx[d];\n            int ny = y + dy[d];\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                std::vector<int> newPath = paths[x][y];\n                newPath.push_back(grid[nx][ny]);\n\n                // Lexicographic comparison using SVE\n                bool betterPath = true;\n                if (!paths[nx][ny].empty()) {\n                    int minLen = std::min(newPath.size(), paths[nx][ny].size());\n                    \n                    // SVE vector comparison\n                    for (int i = 0; i < minLen; i += vector_ints) {\n                        svint32_t newVec = svld1_s32(pg, &newPath[i]);\n                        svint32_t existVec = svld1_s32(pg, &paths[nx][ny][i]);\n                        \n                        svbool_t cmp = svcmplt_s32(pg, newVec, existVec);\n                        if (svptest_any(pg, cmp)) {\n                            break;\n                        }\n                        if (svptest_any(pg, svcmpne_s32(pg, newVec, existVec))) {\n                            betterPath = false;\n                            break;\n                        }\n                    }\n                }\n\n                if (betterPath) {\n                    paths[nx][ny] = newPath;\n                    q.push({nx, ny});\n                }\n            }\n        }\n    }\n\n    // Find the lexicographically smallest path of length k\n    std::vector<int> minPathResult;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (paths[i][j].size() == k) {\n                if (minPathResult.empty() || paths[i][j] < minPathResult) {\n                    minPathResult = paths[i][j];\n                }\n            }\n        }\n    }\n\n    return minPathResult;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Create SVE vector predicate for odd digits\n    svbool_t pg = svptrue_b8();\n    svuint8_t digit_vec = svld1_u8(pg, (uint8_t*)digits);\n    \n    // Convert character digits to numeric values\n    svuint8_t zero_vec = svdup_u8('0');\n    svuint8_t numeric_vec = svsubr_u8_z(pg, digit_vec, zero_vec);\n    \n    // Create predicate for odd digits\n    svbool_t odd_pred = svcmpne_u8(pg, svmod_u8_z(pg, numeric_vec, 2), 0);\n    \n    // Compute product of odd digits\n    svuint64_t product_vec = svdup_u64(1);\n    product_vec = svmul_u64_z(odd_pred, product_vec, \n                               svreinterpret_u64_u8(numeric_vec));\n    \n    uint64_t result = svaddv_u64(pg, product_vec);\n    \n    return result > 1 ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Create SVE predicates and vectors\n    svbool_t pg = svptrue_b8();\n    svuint8_t vec_digits = svld1_u8(pg, (uint8_t*)digits);\n    \n    // Convert ASCII digits to numeric values\n    vec_digits = svsub_u8_x(pg, vec_digits, '0');\n    \n    // Create predicate for odd digits\n    svbool_t odd_pred = svcmpne_u8(pg, svmod_u8_x(pg, vec_digits, 2), 0);\n    \n    // Mask odd digits\n    svuint8_t odd_digits = svsel_u8(odd_pred, vec_digits, 0);\n    \n    // Compute product of odd digits\n    svuint64_t product = svmovd_n_u64(1);\n    for (int i = 0; i < len; i++) {\n        if (odd_digits[i] != 0) {\n            product = svmul_u64_x(pg, product, odd_digits[i]);\n        }\n    }\n    \n    return svaddv_u64(pg, product);\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string for digit extraction\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Create SVE predicates and vectors\n    svbool_t pg = svptrue_b8();\n    svuint8_t vec_digits = svld1_u8(pg, (uint8_t*)digits);\n    \n    // Convert ASCII digits to actual numeric values\n    vec_digits = svsub_u8_x(pg, vec_digits, '0');\n    \n    // Create predicate for odd digits\n    svbool_t odd_pred = svcmpne_u8(pg, svmod_u8_x(pg, vec_digits, 2), 0);\n    \n    // Mask to keep only odd digits\n    svuint8_t odd_digits = svsel_u8(odd_pred, vec_digits, 0);\n    \n    // Compute product of odd digits\n    uint64_t product = 1;\n    svuint64_t prod_vec = svdup_u64(1);\n    \n    for (int i = 0; i < len; i++) {\n        if (odd_digits[i] != 0) {\n            prod_vec = svmul_u64_x(pg, prod_vec, odd_digits[i]);\n        }\n    }\n    \n    // Reduce product vector\n    product = svaddv_u64(pg, prod_vec);\n    \n    return (product > 1) ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Create SVE predicates and vectors\n    svbool_t pg = svptrue_b8();\n    svuint8_t vec_digits = svld1_u8(pg, (uint8_t*)digits);\n    \n    // Convert ASCII digits to numeric values\n    vec_digits = svsub_u8_x(pg, vec_digits, '0');\n    \n    // Create predicate for odd digits\n    svbool_t odd_pred = svcmpne_u8(pg, svmod_u8_x(pg, vec_digits, 2), 0);\n    \n    // Mask odd digits\n    svuint8_t odd_digits = svsel_u8(odd_pred, vec_digits, 0);\n    \n    // Compute product of odd digits\n    svuint64_t product = svdup_u64(1);\n    svuint64_t odd_digits_wide = svreinterpret_u64_u8(odd_digits);\n    product = svmul_u64_x(pg, product, odd_digits_wide);\n    \n    // Reduce product\n    uint64_t result = svaddv_u64(pg, product);\n    \n    return result > 1 ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    // Convert number to string for digit extraction\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Create SVE predicates and vectors\n    svbool_t pg = svptrue_b8();\n    svuint8_t vec_digits = svld1_u8(pg, (uint8_t*)digits);\n    \n    // Convert ASCII digits to numeric values\n    svuint8_t zero_vec = svdup_u8('0');\n    svuint8_t digit_values = svsub_u8_x(pg, vec_digits, zero_vec);\n    \n    // Create predicate for odd digits\n    svbool_t odd_pred = svcmpne_u8(pg, svmod_u8_x(pg, digit_values, 2), 0);\n    \n    // Compute product of odd digits\n    svuint64_t product = svdup_u64(1);\n    svuint64_t digit_values_wide = svmovlb_u8_x(pg, digit_values);\n    product = svmul_u64_x(odd_pred, product, digit_values_wide);\n    \n    // Reduce product across vector\n    uint64_t result = svaddv_u64(pg, product);\n    \n    return result == 1 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    for (; i + svcntw() <= vector_size; i += svcntw()) {\n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &lst[i]);\n        \n        // Round up to ceiling using svrintp\n        svfloat32_t rounded_vec = svrintp_f32_z(svptrue_b32(), vec, 1);\n        \n        // Convert to integers \n        svint32_t int_vec = svcvt_s32_f32_z(svptrue_b32(), rounded_vec);\n        \n        // Square the integers\n        svint32_t squared_vec = svmul_s32_z(svptrue_b32(), int_vec, int_vec);\n        \n        // Sum the squared values\n        svuint64_t sum_vec = svsumw_u64(svptrue_b32(), squared_vec);\n        total_sum += svlasta_u64(svptrue_b64(), sum_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < vector_size; ++i) {\n        int rounded = std::ceil(lst[i]);\n        total_sum += rounded * rounded;\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // Process vector in SVE vector lengths\n    size_t i = 0;\n    for (; i + svcntw() <= vector_size; i += svcntw()) {\n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(svptrue_b32(), lst.data() + i);\n        \n        // Round up to ceiling using svrintp\n        svfloat32_t rounded_vec = svrintp_f32_z(svptrue_b32(), vec, 1);\n        \n        // Convert to integers \n        svint32_t int_vec = svcvt_s32_f32_z(svptrue_b32(), rounded_vec);\n        \n        // Square the integers\n        svint32_t squared_vec = svmul_s32_z(svptrue_b32(), int_vec, int_vec);\n        \n        // Sum the squared values\n        svuint64_t sum_vec = szvextw_u64(squared_vec);\n        total_sum += svaddv_u64(svptrue_b64(), sum_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        int rounded = std::ceil(lst[i]);\n        total_sum += rounded * rounded;\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    for (; i + svcntw() <= vector_size; i += svcntw()) {\n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(svptrue_b32(), lst.data() + i);\n        \n        // Round up to ceiling using svrintp\n        svfloat32_t rounded_vec = svrintp_f32_z(svptrue_b32(), vec, 1);\n        \n        // Convert to integers \n        svint32_t int_vec = svcvt_s32_f32_z(svptrue_b32(), rounded_vec);\n        \n        // Square the integers\n        svint32_t squared_vec = svmul_s32_z(svptrue_b32(), int_vec, int_vec);\n        \n        // Sum the squared values\n        int64_t chunk_sum = svaddv_s32(svptrue_b32(), squared_vec);\n        total_sum += chunk_sum;\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        int rounded = std::ceil(lst[i]);\n        total_sum += rounded * rounded;\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    for (; i + svcntw() <= vector_size; i += svcntw()) {\n        // Load vector of floats\n        svfloat32_t input_vec = svld1_f32(svptrue_b32(), lst.data() + i);\n        \n        // Round up to ceiling using svrintp\n        svfloat32_t rounded_vec = svrintp_f32_z(svptrue_b32(), input_vec);\n        \n        // Convert to integers\n        svint32_t int_vec = svcvt_s32_f32_z(svptrue_b32(), rounded_vec);\n        \n        // Square the integers\n        svint32_t squared_vec = svmul_s32_z(svptrue_b32(), int_vec, int_vec);\n        \n        // Sum the squared values\n        uint64_t chunk_sum = svaddv_s32(svptrue_b32(), squared_vec);\n        total_sum += chunk_sum;\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        int rounded = std::ceil(lst[i]);\n        total_sum += rounded * rounded;\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // Process vector in SVE vector lengths\n    size_t i = 0;\n    for (; i + svcntw() <= vector_size; i += svcntw()) {\n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(svptrue_b32(), lst.data() + i);\n        \n        // Round up to ceiling using svrintp\n        svfloat32_t rounded_vec = svrintp_f32_z(svptrue_b32(), vec, 1);\n        \n        // Convert to integers \n        svint32_t int_vec = svcvt_s32_f32_z(svptrue_b32(), rounded_vec);\n        \n        // Square the integers\n        svint32_t squared_vec = svmul_s32_z(svptrue_b32(), int_vec, int_vec);\n        \n        // Sum the squared values\n        svuint64_t sum_vec = szvextw_u64(squared_vec);\n        total_sum += svaddv_u64(svptrue_b64(), sum_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        int rounded = std::ceil(lst[i]);\n        total_sum += rounded * rounded;\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Load vector\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_z(pg, arr.data());\n    svint32_t curr = svld1_z(pg, arr.data() + 1);\n\n    // Compare if current element is less than previous\n    svbool_t mask = svcmplt_z(pg, curr, prev);\n    uint64_t result = svcntp_b32(pg, mask);\n\n    // If no elements found, return -1\n    if (result == 0) return -1;\n\n    // Find the last index where condition is true\n    for (int i = n - 2; i >= 0; i--) {\n        if (arr[i] > arr[i+1]) return i;\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Load vector\n    svbool_t pg = svptrue_b32();\n    svint32_t current = svld1_z(pg, arr.data(), n);\n    svint32_t next = svld1_z(pg, arr.data() + 1, n - 1);\n    \n    // Compare if current is less than next\n    svbool_t comparison = svcmplt_z(pg, current, next);\n    \n    // Find the last index where this condition is false\n    uint32_t result = -1;\n    svbool_t mask = svnot_z(pg, comparison);\n    \n    if (svptest_any(pg, mask)) {\n        svuint32_t indices = svindex_u32(0, 1);\n        svuint32_t masked_indices = svcompact_u32(mask, indices);\n        \n        if (svptest_any(pg, svcmpne_z(pg, masked_indices, svdup_u32(0)))) {\n            result = svmaxv_u32(pg, masked_indices);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Load vector\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svld1_z(pg, arr.data());\n    svint32_t curr = svld1_z(pg, arr.data() + 1);\n\n    // Compare if current is less than previous\n    svbool_t mask = svcmplt_z(pg, curr, prev);\n    uint64_t result = svbrkb_z(pg, mask);\n\n    if (result) {\n        // Find the rightmost set bit (index)\n        int index = __builtin_ctzll(result);\n        return index + 1;\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Load vector\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svdup_n_s32(arr[0]);\n    \n    // Process in vector chunks\n    for (int i = 1; i < n; i += svcntw()) {\n        // Load current chunk\n        svint32_t curr = svld1_s32(pg, &arr[i]);\n        \n        // Compare if current is less than previous\n        svbool_t mask = svcmplt_s32(pg, curr, prev);\n        \n        // Check if any element satisfies condition\n        if (svptest_any(pg, mask)) {\n            // Find last index satisfying condition\n            int last_index = i + svlastb_s32(mask);\n            return last_index;\n        }\n        \n        // Update previous vector\n        prev = curr;\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    // Load vector\n    svbool_t pg = svptrue_b32();\n    svint32_t prev = svdup_n_s32(arr[0]);\n    \n    // Iterate through array in SVE vector chunks\n    for (int i = 1; i < n; i += svcntw()) {\n        // Determine active lanes\n        svbool_t active = svwhilelt_b32(i, n);\n        \n        // Load current chunk\n        svint32_t curr = svld1_s32(active, &arr[i]);\n        \n        // Compare if current is not greater than previous\n        svbool_t not_greater = svcmpge_s32(pg, curr, prev);\n        \n        // Find first element not satisfying condition\n        int result = svfirst_s32(not_greater, active, -1);\n        \n        if (result != -1) {\n            return i + result;\n        }\n        \n        // Update previous vector\n        prev = curr;\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    // Get the vector length\n    size_t vector_length = svcntw();\n    \n    // Initialize max negative and min positive\n    int max_negative = INT_MIN;\n    int min_positive = INT_MAX;\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < lst.size(); i += vector_length) {\n        // Determine how many elements to process in this iteration\n        size_t remaining = std::min(vector_length, lst.size() - i);\n        \n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        \n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n        \n        // Find max negative using predicate for negative numbers\n        svbool_t negative_pred = svcmplt_s32(pg, vec, svdup_s32(0));\n        svint32_t max_neg_vec = svmax_s32_z(negative_pred, vec, vec);\n        int current_max_neg = svredmax_s32(negative_pred, max_neg_vec);\n        max_negative = std::max(max_negative, current_max_neg);\n        \n        // Find min positive using predicate for positive numbers\n        svbool_t positive_pred = svcmpgt_s32(pg, vec, svdup_s32(0));\n        svint32_t min_pos_vec = svmin_s32_z(positive_pred, vec, vec);\n        int current_min_pos = svredmin_s32(positive_pred, min_pos_vec);\n        min_positive = std::min(min_positive, current_min_pos);\n    }\n    \n    // Adjust results if no negative or positive found\n    max_negative = (max_negative == INT_MIN) ? 0 : max_negative;\n    min_positive = (min_positive == INT_MAX) ? 0 : min_positive;\n    \n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vec = svld1_s32(pg, lst.data());\n    \n    // Initialize max negative and min positive with extreme values\n    int max_negative = INT_MIN;\n    int min_positive = INT_MAX;\n    \n    // Process the first vector\n    svbool_t negative_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n    svbool_t positive_mask = svcmpgt_s32(pg, vec, svdup_s32(0));\n    \n    if (svptest_any(pg, negative_mask)) {\n        svint32_t negative_vec = svsel_s32(negative_mask, vec, svdup_s32(INT_MIN));\n        max_negative = svmaxv_s32(pg, negative_vec);\n    }\n    \n    if (svptest_any(pg, positive_mask)) {\n        svint32_t positive_vec = svsel_s32(positive_mask, vec, svdup_s32(INT_MAX));\n        min_positive = svminv_s32(pg, positive_vec);\n    }\n    \n    // Process remaining vectors if vector length is less than list size\n    size_t vec_len = svcntw();\n    for (size_t i = vec_len; i < lst.size(); i += vec_len) {\n        vec = svld1_s32(pg, lst.data() + i);\n        \n        negative_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n        positive_mask = svcmpgt_s32(pg, vec, svdup_s32(0));\n        \n        if (svptest_any(pg, negative_mask)) {\n            svint32_t negative_vec = svsel_s32(negative_mask, vec, svdup_s32(INT_MIN));\n            max_negative = std::max(max_negative, svmaxv_s32(pg, negative_vec));\n        }\n        \n        if (svptest_any(pg, positive_mask)) {\n            svint32_t positive_vec = svsel_s32(positive_mask, vec, svdup_s32(INT_MAX));\n            min_positive = std::min(min_positive, svminv_s32(pg, positive_vec));\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = lst.size() - (lst.size() % vec_len); i < lst.size(); ++i) {\n        if (lst[i] < 0) {\n            max_negative = std::max(max_negative, lst[i]);\n        }\n        if (lst[i] > 0) {\n            min_positive = std::min(min_positive, lst[i]);\n        }\n    }\n    \n    if (max_negative == INT_MIN) max_negative = 0;\n    if (min_positive == INT_MAX) min_positive = 0;\n    \n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svbool_t pg = svptrue_b32();\n    svint32_t vec = svld1_s32(pg, lst.data());\n    \n    // Initialize max negative and min positive\n    svint32_t max_neg = svdup_s32(-INT_MAX);\n    svint32_t min_pos = svdup_s32(INT_MAX);\n\n    // Mask for negative numbers\n    svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n    svbool_t pos_mask = svcmpgt_s32(pg, vec, svdup_s32(0));\n\n    // Update max negative\n    max_neg = svsel_s32(neg_mask, svmax_s32_z(neg_mask, max_neg, vec), max_neg);\n\n    // Update min positive\n    min_pos = svsel_s32(pos_mask, svmin_s32_z(pos_mask, min_pos, vec), min_pos);\n\n    // Reduce to scalar\n    int max_negative = svmaxv_s32(neg_mask, max_neg);\n    int min_positive = svminv_s32(pos_mask, min_pos);\n\n    // Handle cases with no negative or positive numbers\n    if (max_negative == -INT_MAX) max_negative = 0;\n    if (min_positive == INT_MAX) min_positive = 0;\n\n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    // Get the vector length\n    size_t vector_length = svcntw();\n    \n    // Initialize max negative and min positive\n    int max_negative = INT_MIN;\n    int min_positive = INT_MAX;\n    \n    // Process the vector in SVE vector chunks\n    for (size_t i = 0; i < lst.size(); i += vector_length) {\n        // Determine the number of elements to process in this iteration\n        size_t remaining = std::min(vector_length, lst.size() - i);\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        \n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Find max negative\n        svbool_t negative_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n        svint32_t negative_vec = svsel_s32(negative_mask, vec, svdup_s32(INT_MIN));\n        int current_max_negative = svmaxv_s32(pg, negative_vec);\n        max_negative = std::max(max_negative, current_max_negative);\n        \n        // Find min positive\n        svbool_t positive_mask = svcmpgt_s32(pg, vec, svdup_s32(0));\n        svint32_t positive_vec = svsel_s32(positive_mask, vec, svdup_s32(INT_MAX));\n        int current_min_positive = svminv_s32(pg, positive_vec);\n        min_positive = std::min(min_positive, current_min_positive);\n    }\n    \n    // Handle edge cases\n    if (max_negative == INT_MIN) max_negative = 0;\n    if (min_positive == INT_MAX) min_positive = 0;\n    \n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    // Get SVE vector length for integers\n    size_t vector_bytes = svcntw() * sizeof(int32_t);\n    size_t num_elements = lst.size();\n\n    // Initialize max negative and min positive to extreme values\n    int32_t max_negative = INT32_MIN;\n    int32_t min_positive = INT32_MAX;\n\n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < num_elements; i += vector_bytes) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n        \n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n\n        // Create predicate for negative numbers\n        svbool_t negative_pred = svcmplt_s32(pg, vec, svdup_s32(0));\n        \n        // Create predicate for positive numbers\n        svbool_t positive_pred = svcmpgt_s32(pg, vec, svdup_s32(0));\n\n        // Find max of negative numbers\n        int32_t curr_max_negative = svmaxv_s32(negative_pred, vec);\n        max_negative = std::max(max_negative, curr_max_negative);\n\n        // Find min of positive numbers\n        int32_t curr_min_positive = svminv_s32(positive_pred, vec);\n        min_positive = std::min(min_positive, curr_min_positive);\n    }\n\n    // Handle case where no negative or positive numbers found\n    if (max_negative == INT32_MIN) max_negative = 0;\n    if (min_positive == INT32_MAX) min_positive = 0;\n\n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Predicate for vector operations\n    svbool_t pg = svptrue_b64();\n\n    // Initialize result vector\n    svuint64_t result = svdup_u64(1);\n\n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial of current number\n        svuint64_t current_fact = svdup_u64(1);\n        svuint64_t multiplier = svdup_u64(i);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            current_fact = svmul_u64_z(pg, current_fact, multiplier);\n        }\n\n        // Multiply result with current factorial\n        result = svmul_u64_z(pg, result, current_fact);\n    }\n\n    // Reduce vector to scalar\n    uint64_t final_result = svaddv_u64(pg, result);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute factorials from 1 to n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial of current number\n        svuint64_t current_num = svdup_u64(i);\n        svuint64_t factorial = svdup_u64(1);\n        \n        for (uint64_t j = 1; j <= i; ++j) {\n            svbool_t mask = svcmplt_u64(pg, svdup_u64(j), current_num);\n            svuint64_t multiplier = svsel_u64(mask, svdup_u64(j), svdup_u64(1));\n            factorial = svmul_u64_z(mask, factorial, multiplier);\n        }\n        \n        // Multiply result with current factorial\n        result = svmul_u64_z(pg, result, factorial);\n    }\n\n    // Reduce vector to scalar\n    uint64_t final_result = svaddv_u64(pg, result);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Predicate for vector operations\n    svbool_t pg = svptrue_b64();\n\n    // Initialize result vector\n    svuint64_t result = svdup_u64(1);\n\n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial of current number\n        svuint64_t current_fact = svdup_u64(1);\n        svuint64_t multiplier = svdup_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            multiplier = svmul_u64_z(pg, multiplier, svdup_u64(j));\n        }\n\n        // Multiply result by current factorial\n        result = svmul_u64_z(pg, result, multiplier);\n    }\n\n    // Reduce vector to scalar\n    uint64_t final_result = svaddv_u64(pg, result);\n\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Predicate for vector operations\n    svbool_t pg = svptrue_b64();\n\n    // Initialize result vector\n    svuint64_t result = svdup_u64(1);\n\n    // Compute factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial of current number\n        svuint64_t current_fact = svdup_u64(1);\n        svuint64_t multiplier = svdup_u64(i);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            current_fact = svmul_u64_z(pg, current_fact, multiplier);\n        }\n\n        // Multiply result with current factorial\n        result = svmul_u64_z(pg, result, current_fact);\n    }\n\n    // Reduce vector to scalar\n    uint64_t final_result = svaddv_u64(pg, result);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n\n    // Compute factorial for each number from 1 to n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_u64(n);\n    svuint64_t result = svdup_u64(1);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        // Compute factorial for current number\n        svuint64_t current = svdup_u64(i);\n        svuint64_t factorial = svdup_u64(1);\n        \n        for (uint64_t j = 1; j <= i; ++j) {\n            factorial = svmul_u64_z(pg, factorial, current);\n            current = svsub_u64_z(pg, current, svdup_u64(1));\n        }\n        \n        // Multiply result by current factorial\n        result = svmul_u64_z(pg, result, factorial);\n    }\n\n    // Reduce vector to scalar\n    uint64_t final_result = svaddv_u64(pg, result);\n    return final_result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n\n    int total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process full SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector chunk\n        svint32_t vec = svld1_z(pg, lst.data() + i);\n        \n        // Create index vector\n        svint32_t indices = svindex_s32(i, 1);\n        \n        // Create modified vector based on index conditions\n        svint32_t modified_vec = vec;\n        \n        // Square elements at indices multiple of 3\n        svbool_t multiple_of_3 = svcmpeq_n_s32(pg, svmod_n_s32(indices, 3), 0);\n        svint32_t squared_vec = svmul_z(multiple_of_3, vec, vec);\n        modified_vec = svsel_s32(multiple_of_3, squared_vec, modified_vec);\n        \n        // Cube elements at indices multiple of 4 but not multiple of 3\n        svbool_t multiple_of_4 = svcmpeq_n_s32(pg, svmod_n_s32(indices, 4), 0);\n        svbool_t not_multiple_of_3 = svbic_z(pg, multiple_of_4, multiple_of_3);\n        svint32_t cubed_vec = svmul_z(not_multiple_of_3, vec, svmul_z(not_multiple_of_3, vec, vec));\n        modified_vec = svsel_s32(not_multiple_of_3, cubed_vec, modified_vec);\n        \n        // Reduce modified vector to sum\n        total_sum += svaddv_s32(pg, modified_vec);\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int total_sum = 0;\n    size_t vector_size = lst.size();\n    \n    // If vector is empty, return 0\n    if (vector_size == 0) return 0;\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    size_t i;\n    for (i = 0; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Load vector chunk\n        svint32_t vec = svld1_s32(svptrue_b32(), lst.data() + i);\n        \n        // Create predicate for indices multiple of 3\n        svbool_t pred_3 = svcmpeq_s32(svindex_s32(0, 1), svdup_s32(3));\n        pred_3 = svand_b_z(svptrue_b32(), pred_3, svcmplt_s32(svindex_s32(0, 1), svdup_s32(vector_size - i)));\n        \n        // Create predicate for indices multiple of 4 (but not 3)\n        svbool_t pred_4 = svcmpeq_s32(svindex_s32(0, 1), svdup_s32(4));\n        pred_4 = svand_b_z(svptrue_b32(), pred_4, svcmplt_s32(svindex_s32(0, 1), svdup_s32(vector_size - i)));\n        pred_4 = svbic_b_z(svptrue_b32(), pred_4, pred_3);\n        \n        // Square entries at indices multiple of 3\n        svint32_t squared = svmul_s32_z(pred_3, vec, vec);\n        \n        // Cube entries at indices multiple of 4 (but not 3)\n        svint32_t cubed = svmul_s32_z(pred_4, svmul_s32_z(pred_4, vec, vec), vec);\n        \n        // Combine squared and cubed with original values\n        svint32_t result = svsel_s32(pred_3, squared, \n                           svsel_s32(pred_4, cubed, vec));\n        \n        // Reduce and add to total sum\n        total_sum += svaddv_s32(svptrue_b32(), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val *= val;\n        } else if (i % 4 == 0) {\n            val *= val * val;\n        }\n        total_sum += val;\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n\n    int total_sum = 0;\n    size_t vector_size = lst.size();\n    svbool_t pg = svwhilelt_b32_u64(0, vector_size);\n\n    // Load the input vector\n    svint32_t vec = svld1_s32(pg, lst.data());\n\n    // Create index vector\n    svint32_t index_vec = svindex_s32(0, 1);\n\n    // Compute multiples of 3 mask\n    svbool_t multiple_of_3_mask = svcmpeq_s32(pg, svrmod_s32(pg, index_vec, 3), 0);\n\n    // Compute multiples of 4 mask\n    svbool_t multiple_of_4_mask = svcmpeq_s32(pg, svrmod_s32(pg, index_vec, 4), 0);\n\n    // Combine masks for special conditions\n    svbool_t square_mask = svand_b_z(pg, multiple_of_3_mask, pg);\n    svbool_t cube_mask = svand_b_z(pg, multiple_of_4_mask, svbic_b(pg, pg, multiple_of_3_mask));\n\n    // Perform transformations\n    svint32_t squared_vec = svmul_s32_z(square_mask, vec, vec);\n    svint32_t cubed_vec = svmul_s32_z(cube_mask, svmul_s32_z(cube_mask, vec, vec), vec);\n\n    // Blend original and transformed vectors\n    svint32_t result_vec = svsel_s32(square_mask, squared_vec, \n                            svsel_s32(cube_mask, cubed_vec, vec));\n\n    // Compute sum\n    total_sum = svaddv_s32(pg, result_vec);\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // Handle empty vector case\n    if (vector_size == 0) return 0;\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    size_t i = 0;\n    for (; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Load vector chunk\n        svint32_t vec = svld1_s32(svptrue_b32(), lst.data() + i);\n        \n        // Create predicate for indices multiple of 3\n        svbool_t pred_3 = svcmpge_n_s32(svptrue_b32(), svindex_s32(0, 1), 3);\n        pred_3 = svand_b_z(svptrue_b32(), pred_3, svcmpeq_n_s32(svmod_n_s32(svindex_s32(0, 1), 3), 0));\n        \n        // Create predicate for indices multiple of 4 but not 3\n        svbool_t pred_4 = svcmpge_n_s32(svptrue_b32(), svindex_s32(0, 1), 4);\n        pred_4 = svand_b_z(svptrue_b32(), pred_4, svcmpeq_n_s32(svmod_n_s32(svindex_s32(0, 1), 4), 0));\n        pred_4 = svbic_b_z(svptrue_b32(), pred_4, svcmpeq_n_s32(svmod_n_s32(svindex_s32(0, 1), 3), 0));\n        \n        // Square entries for indices multiple of 3\n        svint32_t squared_vec = svmul_s32_z(pred_3, vec, vec);\n        \n        // Cube entries for indices multiple of 4 but not 3\n        svint32_t cubed_vec = svmul_s32_z(pred_4, svmul_s32_z(pred_4, vec, vec), vec);\n        \n        // Combine squared and cubed vectors\n        svint32_t modified_vec = svadd_s32_z(svptrue_b32(), squared_vec, cubed_vec);\n        \n        // Accumulate sum\n        result += svaddv_s32(svptrue_b32(), modified_vec);\n    }\n    \n    // Handle remaining elements sequentially\n    for (; i < vector_size; ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val *= val;\n        } else if (i % 4 == 0) {\n            val *= val * val;\n        }\n        result += val;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    int result = 0;\n    size_t vector_size = lst.size();\n    \n    // If vector is empty, return 0\n    if (vector_size == 0) return 0;\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    // Process vector in SVE vector chunks\n    size_t i;\n    for (i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine how many elements to process in this chunk\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, lst.data() + i);\n        \n        // Create index vector\n        svint32_t index_vec = svindex_s32(i, 1);\n        \n        // Create modified vector\n        svint32_t modified_vec = vec;\n        \n        // Square elements at indices multiple of 3\n        svbool_t multiple_of_3 = svcmpeq_s32(pg, svrmod_s32(index_vec, 3), 0);\n        svint32_t squared_vec = svmul_s32_z(multiple_of_3, vec, vec);\n        \n        // Cube elements at indices multiple of 4 but not multiple of 3\n        svbool_t multiple_of_4 = svcmpeq_s32(pg, svrmod_s32(index_vec, 4), 0);\n        svbool_t not_multiple_of_3 = svnot_b_z(pg, multiple_of_3);\n        svbool_t cube_mask = svand_b_z(pg, multiple_of_4, not_multiple_of_3);\n        svint32_t cubed_vec = svmul_s32_z(cube_mask, vec, svmul_s32_z(cube_mask, vec, vec));\n        \n        // Combine squared and cubed vectors\n        modified_vec = svsel_s32(multiple_of_3, squared_vec, modified_vec);\n        modified_vec = svsel_s32(cube_mask, cubed_vec, modified_vec);\n        \n        // Compute sum of modified vector\n        result += svaddv_s32(pg, modified_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int result = 0;\n    size_t vector_size = nums.size();\n    \n    // Process vector in SVE vector lengths\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Determine active elements for this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, nums.data() + i);\n        \n        // Check elements > 10\n        svbool_t gt_10_mask = svcmpgt_s32(pg, vec, 10);\n        \n        // Take absolute value to handle negative numbers\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract first digit\n        svint32_t first_digit = svdiv_s32_z(pg, abs_vec, \n            svdup_s32_z(pg, (int)pow(10, floor(log10(INT_MAX)))));\n        \n        // Extract last digit\n        svint32_t last_digit = svmod_s32_z(pg, abs_vec, 10);\n        \n        // Check if first and last digits are odd\n        svbool_t first_odd_mask = svcmpeq_s32(pg, svmod_s32_z(pg, first_digit, 2), 1);\n        svbool_t last_odd_mask = svcmpeq_s32(pg, svmod_s32_z(pg, last_digit, 2), 1);\n        \n        // Combine all conditions\n        svbool_t final_mask = svandn_b_z(pg, gt_10_mask, \n            svorr_b_z(pg, svnot_b_z(pg, first_odd_mask), svnot_b_z(pg, last_odd_mask)));\n        \n        // Count matching elements\n        result += svcntp_b32(pg, final_mask);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int result = 0;\n    size_t vector_size = nums.size();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Determine active elements for this chunk\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, nums.data() + i);\n        \n        // Check > 10 condition\n        svbool_t gt_10_mask = svcmpgt_s32(pg, vec, 10);\n        \n        // First digit check (absolute value)\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit = svdiv_s32_z(pg, abs_vec, \n            svdup_s32_z(pg, (int)pow(10, floor(log10(INT_MAX)))));\n        \n        // Last digit check\n        svint32_t last_digit = svmod_s32_z(pg, abs_vec, 10);\n        \n        // Check first and last digit are odd\n        svbool_t first_digit_odd = svcmpeq_s32(pg, svmod_s32_z(pg, first_digit, 2), 1);\n        svbool_t last_digit_odd = svcmpeq_s32(pg, svmod_s32_z(pg, last_digit, 2), 1);\n        \n        // Combine conditions\n        svbool_t final_mask = svandn_b_z(pg, gt_10_mask, \n            svorr_b_z(pg, svnot_b_z(pg, first_digit_odd), svnot_b_z(pg, last_digit_odd)));\n        \n        // Count matching elements\n        result += svcntp_b32(pg, final_mask);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int result = 0;\n    size_t vector_size = nums.size();\n    \n    // Process vector in SVE vector lengths\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Determine number of active elements for this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, nums.data() + i);\n        \n        // Check elements > 10\n        svbool_t gt_10_mask = svcmpgt_s32(pg, vec, 10);\n        \n        // Compute absolute value for digit extraction\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Extract first digit\n        svint32_t first_digit = svdiv_s32_z(pg, abs_vec, \n            svdup_s32_z(pg, std::pow(10, std::floor(std::log10(INT32_MAX)))));\n        \n        // Extract last digit\n        svint32_t last_digit = svmod_s32_z(pg, abs_vec, 10);\n        \n        // Check if first and last digits are odd\n        svbool_t first_odd_mask = svcmpeq_s32(pg, svmod_s32_z(pg, first_digit, 2), 1);\n        svbool_t last_odd_mask = svcmpeq_s32(pg, svmod_s32_z(pg, last_digit, 2), 1);\n        \n        // Combine all conditions\n        svbool_t final_mask = svandn_b_z(pg, gt_10_mask, \n            svorn_b_z(pg, first_odd_mask, last_odd_mask));\n        \n        // Count matching elements\n        result += svcntp_b32(pg, final_mask);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int result = 0;\n    size_t vector_size = nums.size();\n    \n    // Process vector in SVE vector chunks\n    for (size_t i = 0; i < vector_size; i += svcntw()) {\n        // Determine active elements for this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector chunk\n        svint32_t vec = svld1_s32(pg, nums.data() + i);\n        \n        // Check > 10 condition\n        svbool_t gt_10_mask = svcmpgt_s32(pg, vec, 10);\n        \n        // First digit check (absolute value)\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit = svdiv_s32_z(pg, abs_vec, \n            svdup_s32_z(pg, (int)pow(10, floor(log10(INT_MAX)))));\n        \n        // Last digit check\n        svint32_t last_digit = svmod_s32_z(pg, abs_vec, 10);\n        \n        // Check first and last digit are odd\n        svbool_t first_odd_mask = svcmpeq_s32(pg, svmod_s32_z(pg, first_digit, 2), 1);\n        svbool_t last_odd_mask = svcmpeq_s32(pg, svmod_s32_z(pg, last_digit, 2), 1);\n        \n        // Combine all conditions\n        svbool_t final_mask = svandn_b_z(pg, gt_10_mask, \n            svorr_b_z(pg, svnot_b_z(pg, first_odd_mask), svnot_b_z(pg, last_odd_mask)));\n        \n        // Count matching elements\n        result += svcntp_b32_z(pg, final_mask);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    size_t vector_size = nums.size();\n    \n    // Determine SVE vector length for integers\n    size_t sve_vector_length = svcntw();\n    \n    for (size_t i = 0; i < vector_size; i += sve_vector_length) {\n        // Determine number of elements to process in this iteration\n        size_t elements_to_process = std::min(sve_vector_length, vector_size - i);\n        \n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of integers\n        svint32_t vec = svld1_s32(pg, nums.data() + i);\n        \n        // Check elements > 10\n        svbool_t gt_10_mask = svcmpgt_s32(pg, vec, svdup_s32(10));\n        \n        // Extract first and last digits\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit = svdiv_s32_z(pg, abs_vec, svdup_s32(pow(10, floor(log10(INT_MAX)))));\n        svint32_t last_digit = svmod_s32_z(pg, abs_vec, svdup_s32(10));\n        \n        // Check if first and last digits are odd\n        svbool_t first_digit_odd = svcmpeq_s32(pg, svmod_s32_z(pg, first_digit, svdup_s32(2)), svdup_s32(1));\n        svbool_t last_digit_odd = svcmpeq_s32(pg, svmod_s32_z(pg, last_digit, svdup_s32(2)), svdup_s32(1));\n        \n        // Combine conditions\n        svbool_t final_mask = svand_b_z(pg, gt_10_mask, first_digit_odd);\n        final_mask = svand_b_z(pg, final_mask, last_digit_odd);\n        \n        // Count matching elements\n        count += svcntp_b32(pg, final_mask);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector for storing a\n    svbool_t pg = svptrue_b64();\n    svuint64_t indices = svindx_u64(pg, 1, 1);\n    svuint64_t squares = svmul_u64_z(pg, indices, indices);\n    svuint64_t a = svsub_u64_z(pg, svmla_u64_z(pg, squares, indices, -1), indices);\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            svbool_t pred = svptrue_b64();\n            svuint64_t ai = svdup_u64(svldr_u64(pg, &a[i]));\n            svuint64_t aj = svdup_u64(svldr_u64(pg, &a[j]));\n\n            for (uint64_t k = j + 1; k < n; ++k) {\n                svuint64_t ak = svdup_u64(svldr_u64(pg, &a[k]));\n                svuint64_t sum = svadd_u64_z(pred, svadd_u64_z(pred, ai, aj), ak);\n                svbool_t is_multiple = svcmpeq_u64(pred, svmod_u64_z(pred, sum, 3), 0);\n                \n                if (svptest_any(pred, is_multiple)) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Allocate vector to store a\n    svbool_t pg = svptrue_b64();\n    svuint64_t indices = svindex_u64(1, 1);\n    \n    // Compute a[i] = i * i - i + 1 using SVE vector operations\n    svuint64_t a = svmul_u64_z(pg, indices, indices);\n    a = svsub_u64_z(pg, a, indices);\n    a = svadd_u64_z(pg, a, svdup_u64(1));\n    \n    // Count triples\n    uint64_t triple_count = 0;\n    \n    // Nested loops with SVE vector comparisons\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                uint64_t sum = svelm_u64(a, i) + svelm_u64(a, j) + svelm_u64(a, k);\n                if (sum % 3 == 0) {\n                    triple_count++;\n                }\n            }\n        }\n    }\n    \n    return triple_count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector for a\n    svbool_t pg = svptrue_b64();\n    svuint64_t indices = svindex_u64(1, 1);\n    svuint64_t a = svsub_x(pg, svmul_x(pg, indices, indices), indices);\n    a = svadd_x(pg, a, 1);\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                uint64_t sum = a[i] + a[j] + a[k];\n                if (sum % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector for storing a\n    svbool_t pg = svptrue_b64();\n    svuint64_t indices = svindx_u64(pg, 1, 1);\n    svuint64_t squares = svmul_u64_z(pg, indices, indices);\n    svuint64_t a = svsub_u64_z(pg, svmla_u64_z(pg, squares, indices, 1), indices);\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            svbool_t pred = svptrue_b64();\n            svuint64_t ai = svdup_u64_z(pred, svgetlane_u64(a, i));\n            svuint64_t aj = svdup_u64_z(pred, svgetlane_u64(a, j));\n\n            for (uint64_t k = j + 1; k < n; ++k) {\n                svuint64_t ak = svdup_u64_z(pred, svgetlane_u64(a, k));\n                svuint64_t sum = svadd_u64_z(pred, svadd_u64_z(pred, ai, aj), ak);\n                svuint64_t mod3 = svmod_u64_z(pred, sum, 3);\n                \n                if (svptest_any(pred, svcmpeq_u64(pred, mod3, 0))) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    // Create vector for storing a\n    svbool_t pg = svptrue_b64();\n    svuint64_t indices = svindx_u64(pg, 1, 1);\n    svuint64_t squares = svmul_u64_z(pg, indices, indices);\n    svuint64_t a = svsub_u64_z(pg, svadd_u64_z(pg, squares, 1), indices);\n\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                uint64_t sum = svgetele_u64(a, i) + svgetele_u64(a, j) + svgetele_u64(a, k);\n                if (sum % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime\n    if (n <= 1) return y;\n    \n    svbool_t pg = svptrue_b32();\n    svint32_t divisors = svindex_s32(2, 1);\n    svint32_t target = svdup_s32(n);\n    \n    while (svpTrue_b32(pg)) {\n        svbool_t cmp = svcmplt_s32(pg, divisors, svrsqrt_s32(target));\n        \n        svint32_t remainder = svrmod_s32(pg, target, divisors);\n        svbool_t is_divisible = svcmpeq_s32(pg, remainder, svdup_s32(0));\n        \n        if (svptest_any(pg, is_divisible)) {\n            return y;\n        }\n        \n        if (!svptest_any(pg, cmp)) {\n            break;\n        }\n        \n        divisors = svAdd_s32_z(pg, divisors, svdup_s32(1));\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SVE vector operations\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_n = svdup_n_s32(n);\n    svint32_t vec_two = svdup_n_s32(2);\n    \n    // Check divisibility from 2 to sqrt(n)\n    svbool_t is_prime = svtrue_b32();\n    for (int i = 2; i * i <= n; i++) {\n        svint32_t vec_i = svdup_n_s32(i);\n        svint32_t remainder = svmod_s32_z(pg, vec_n, vec_i);\n        is_prime = svand_b_z(pg, is_prime, svcmpne_s32(pg, remainder, svdup_n_s32(0)));\n    }\n    \n    // Reduce vector predicate to scalar boolean\n    uint64_t is_prime_scalar = svorv_b32(pg, is_prime);\n    \n    // Return x if prime, y otherwise\n    return is_prime_scalar ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SVE vector operations\n    if (n <= 1) return y;\n    \n    // Use SVE predicate to vectorize prime checking\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_n = svdup_n_s32(n);\n    svint32_t vec_two = svdup_n_s32(2);\n    \n    // Start checking divisibility from 2 to sqrt(n)\n    for (int i = 2; i * i <= n; i++) {\n        svint32_t vec_i = svdup_n_s32(i);\n        \n        // Check if n is divisible by current vector of integers\n        svint32_t remainder = svmod_s32_z(pg, vec_n, vec_i);\n        svbool_t is_divisible = svcmpeq_s32(pg, remainder, svdup_n_s32(0));\n        \n        // If any vector lane shows divisibility, n is not prime\n        if (svptest_any(pg, is_divisible)) {\n            return y;\n        }\n    }\n    \n    // If no divisors found, n is prime\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime\n    if (n <= 1) return y;\n    \n    svbool_t pg = svptrue_b32();\n    svint32_t vec_n = svdup_n_s32(n);\n    svint32_t vec_two = svdup_n_s32(2);\n    \n    // Early exit for small primes\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n    \n    // Vectorized primality test\n    for (int i = 3; i * i <= n; i += 2) {\n        svint32_t vec_i = svdup_n_s32(i);\n        svint32_t vec_mod = svrem_s32_x(pg, vec_n, vec_i);\n        svbool_t zero_mask = svcmpeq_s32(pg, vec_mod, svdup_n_s32(0));\n        \n        if (svptest_any(pg, zero_mask)) {\n            return y;  // Not prime\n        }\n    }\n    \n    return x;  // Prime number\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    // Check if n is prime using SVE vector operations\n    svbool_t pg = svptrue_b32();\n    svint32_t vec_n = svdup_n_s32(n);\n    svint32_t vec_two = svdup_n_s32(2);\n    \n    // Check divisibility from 2 to sqrt(n)\n    svbool_t is_prime = svptrue_b32();\n    for (int i = 2; i * i <= n; i++) {\n        svint32_t vec_i = svdup_n_s32(i);\n        svint32_t remainder = svmod_s32_z(pg, vec_n, vec_i);\n        is_prime = svand_b_z(pg, is_prime, svcmpne_s32(pg, remainder, svdup_n_s32(0)));\n    }\n    \n    // Reduce vector predicate to scalar boolean\n    bool prime_result = svcntp_b32(pg, is_prime) > 0;\n    \n    // Return x if prime, y otherwise\n    return prime_result ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for floats\n    size_t sve_vector_length = svcntw();\n    \n    size_t i = 0;\n    for (; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Create predicate for odd integers\n        svbool_t odd_pred = svcmpge_n_f32(pg, vec, 1.0f);\n        odd_pred = svand_b_z(pg, odd_pred, svcmpeq_n_f32(pg, svfract_f32(vec), 0.0f));\n        odd_pred = svand_b_z(pg, odd_pred, svcmpne_n_f32(pg, svabs_f32_z(pg, vec), vec));\n        \n        // Square the odd integers\n        svfloat32_t squared = svmul_f32_z(odd_pred, vec, vec);\n        \n        // Reduce to sum\n        result += svadd_f32_z(pg, squared);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && std::floor(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += val * val;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for float\n    size_t sve_vector_length = svcntw();\n    \n    size_t i = 0;\n    for (; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Create predicate for odd integers\n        svbool_t odd_pred = svcmpge_n_f32(pg, vec, 0);  // Non-negative\n        odd_pred = svand_b_z(odd_pred, svcmpeq_f32(pg, svrintm_f32_z(odd_pred, vec), vec));  // Integer\n        odd_pred = svand_b_z(odd_pred, svcmpeq_n_u32(svreinterpret_u32_f32(vec), 1U, 1));  // Odd\n        \n        // Square the odd integers\n        svfloat32_t squared = svmul_f32_z(odd_pred, vec, vec);\n        \n        // Sum the squared values\n        float partial_sum = svadda_f32(pg, 0.0f, squared);\n        result += static_cast<uint64_t>(partial_sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && std::floor(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += static_cast<uint64_t>(val * val);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for floats\n    size_t sve_vector_length = svcntw();\n    \n    size_t i = 0;\n    for (; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32_u64(i, vector_size);\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Create predicate for odd integers\n        svbool_t odd_pred = svcmpge_n_f32(pg, vec, 1.0f);\n        odd_pred = svand_b_z(pg, odd_pred, svcmpeq_n_f32(pg, svfract_f32(vec), 0.0f));\n        \n        // Square the odd integers\n        svfloat32_t squared = svmul_f32_z(odd_pred, vec, vec);\n        \n        // Reduce to scalar sum\n        result += svaddv_f32(odd_pred, squared);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && std::floor(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += val * val;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for float\n    size_t sve_vector_length = svcntw();\n    \n    size_t i = 0;\n    for (; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Create predicate for odd integers\n        svbool_t odd_pred = svcmpge_n_f32(pg, vec, 0.0f);  // non-negative\n        odd_pred = svand_b_z(pg, odd_pred, svcmpeq_n_f32(pg, svrintm_f32_z(pg, vec), vec));  // integer check\n        odd_pred = svand_b_z(pg, odd_pred, svcmpeq_n_u32(svreinterpret_u32_f32(vec), 1, 1));  // odd check\n        \n        // Square the odd integers\n        svfloat32_t squared = svmul_f32_z(odd_pred, vec, vec);\n        \n        // Sum the squared values\n        float partial_sum = svaddv_f32(odd_pred, squared);\n        \n        result += static_cast<uint64_t>(partial_sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        float val = lst[i];\n        if (val > 0 && std::floor(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += static_cast<uint64_t>(val * val);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t result = 0;\n    size_t vector_size = lst.size();\n    \n    // Determine SVE vector length for floats\n    size_t sve_vector_length = svcntw();\n    \n    size_t i = 0;\n    for (; i + sve_vector_length <= vector_size; i += sve_vector_length) {\n        // Create SVE predicate for active elements\n        svbool_t pg = svwhilelt_b32(i, vector_size);\n        \n        // Load vector of floats\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Create predicate for odd integers\n        svbool_t odd_pred = svcmpge_n_f32(pg, vec, 1.0f);  // >= 1\n        odd_pred = svand_b_z(pg, odd_pred, svcmpeq_n_f32(pg, svfract_f32(vec), 0.0f));  // integer check\n        odd_pred = svand_b_z(pg, odd_pred, svcmpeq_n_s32(svreinterpret_s32_f32(vec), 1, pg));  // odd check\n        \n        // Square the odd integers\n        svfloat32_t squared = svmul_f32_z(odd_pred, vec, vec);\n        \n        // Sum the squared values\n        float partial_sum = svaddv_f32(odd_pred, squared);\n        \n        result += static_cast<uint64_t>(partial_sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < vector_size; ++i) {\n        float val = lst[i];\n        if (val >= 1 && std::floor(val) == val && static_cast<int>(val) % 2 == 1) {\n            result += static_cast<uint64_t>(val * val);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Determine SVE vector length for int\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load game and guess vectors\n        svint32_t game_vec = svld1_z(pg, game.data() + i);\n        svint32_t guess_vec = svld1_z(pg, guess.data() + i);\n\n        // Compare vectors\n        svbool_t eq_mask = svcmpeq_z(pg, game_vec, guess_vec);\n        \n        // Compute absolute difference\n        svint32_t diff = svabs_z(pg, svsub_z(pg, game_vec, guess_vec));\n        \n        // Set result to 0 where guess matches game, otherwise use absolute difference\n        svint32_t result_vec = svsel_z(eq_mask, svdup_n_s32(0), diff);\n\n        // Store results\n        svst1_z(pg, result.data() + i, result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    // Process vector in SVE vector lengths\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        \n        // Load game and guess vectors\n        svint32_t game_vec = svld1_s32(pg, game.data() + i);\n        svint32_t guess_vec = svld1_s32(pg, guess.data() + i);\n        \n        // Compute absolute difference\n        svint32_t diff = svabd_s32_z(pg, game_vec, guess_vec);\n        \n        // Store result\n        svst1_s32(pg, result.data() + i, diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    // Determine SVE vector length for int\n    size_t vec_len = svcntw();\n\n    for (size_t i = 0; i < n; i += vec_len) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32(i, n);\n\n        // Load game and guess vectors\n        svint32_t game_vec = svld1_z(pg, game.data() + i);\n        svint32_t guess_vec = svld1_z(pg, guess.data() + i);\n\n        // Compute absolute difference\n        svint32_t diff = svsub_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_z(pg, diff);\n\n        // Store result\n        svst1_z(pg, result.data() + i, abs_diff);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    // Process vector in SVE vector lengths\n    size_t vector_length = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < n; i += vector_length) {\n        // Determine how many elements to process in this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        \n        // Load game and guess vectors\n        svint32_t game_vec = svld1_s32(pg, game.data() + i);\n        svint32_t guess_vec = svld1_s32(pg, guess.data() + i);\n        \n        // Compute absolute difference\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        // Store result\n        svst1_s32(pg, result.data() + i, abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    // Process vector in SVE vector chunks\n    size_t vector_size = svcntw(); // Number of 32-bit elements in an SVE vector\n    \n    for (size_t i = 0; i < n; i += vector_size) {\n        // Determine active lanes for this iteration\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        \n        // Load game and guess vectors\n        svint32_t game_vec = svld1_s32(pg, game.data() + i);\n        svint32_t guess_vec = svld1_s32(pg, guess.data() + i);\n        \n        // Compute absolute difference\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        // Store results\n        svst1_s32(pg, result.data() + i, abs_diff);\n    }\n    \n    return result;\n}\n```"}

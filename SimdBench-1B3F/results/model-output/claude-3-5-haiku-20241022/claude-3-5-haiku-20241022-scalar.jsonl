{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from source to destination using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from source to destination using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from source to destination using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from source to destination using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from source to destination using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from source to destination using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from source to destination using indices as lookups\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from source to destination using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```cpp\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation: Copy values from source array to destination using indices\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation: Copy values from source array to destination using indices as write locations\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Check if slice_idx is valid\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    // Calculate the offset for the specific slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the slice from the tensor to the output slice\n    for (size_t i = 0; i < dim1 * dim2; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Check if slice_idx is valid\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    // Calculate the offset to the start of the desired slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the slice from the tensor to the output slice\n    for (size_t i = 0; i < dim1 * dim2; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Check if slice_idx is valid\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    // Calculate the offset to the start of the desired slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the slice from the tensor to the output slice\n    for (size_t i = 0; i < dim1 * dim2; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Check if slice index is valid\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    // Calculate the offset to the start of the desired slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the slice from the tensor to the output slice\n    for (size_t i = 0; i < dim1 * dim2; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    // Check if slice_idx is valid\n    if (slice_idx >= dim3) {\n        return;\n    }\n\n    // Calculate the offset for the desired slice\n    size_t slice_offset = slice_idx * dim1 * dim2;\n\n    // Copy the slice from the tensor to the output slice\n    for (size_t i = 0; i < dim1 * dim2; i++) {\n        slice[i] = tensor[slice_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            // Process each block\n            for (size_t i = row_block; i < (row_block + block_size) && i < rows; i++) {\n                for (size_t j = col_block; j < (col_block + block_size) && j < cols; j++) {\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            // Process each block\n            for (size_t i = row_block; i < row_block + block_size && i < rows; i++) {\n                for (size_t j = col_block; j < col_block + block_size && j < cols; j++) {\n                    // Transpose the current element\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            // Process each block\n            for (size_t row = row_block; row < (row_block + block_size) && row < rows; row++) {\n                for (size_t col = col_block; col < (col_block + block_size) && col < cols; col++) {\n                    // Transpose the element\n                    dst[col * rows + row] = src[row * cols + col];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            // Process each block\n            for (size_t i = row_block; i < row_block + block_size && i < rows; i++) {\n                for (size_t j = col_block; j < col_block + block_size && j < cols; j++) {\n                    // Transpose the element\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t row_block = 0; row_block < rows; row_block += block_size) {\n        for (size_t col_block = 0; col_block < cols; col_block += block_size) {\n            // Process each block\n            for (size_t i = row_block; i < row_block + block_size && i < rows; i++) {\n                for (size_t j = col_block; j < col_block + block_size && j < cols; j++) {\n                    // Transpose the element\n                    dst[j * rows + i] = src[i * cols + j];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float diagonal_sum = 0.0f;\n    \n    for (size_t i = 0; i < dim; i++) {\n        diagonal_sum += array[i * dim * dim + i * dim + i];\n    }\n    \n    return diagonal_sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float diagonal_sum = 0.0f;\n    \n    for (size_t i = 0; i < dim; i++) {\n        diagonal_sum += array[i * dim * dim + i * dim + i];\n    }\n    \n    return diagonal_sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float diagonal_sum = 0.0f;\n    \n    for (size_t i = 0; i < dim; i++) {\n        diagonal_sum += array[i * dim * dim + i * dim + i];\n    }\n    \n    return diagonal_sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float diagonal_sum = 0.0f;\n    \n    for (size_t i = 0; i < dim; i++) {\n        diagonal_sum += array[i * dim * dim + i * dim + i];\n    }\n    \n    return diagonal_sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float diagonal_sum = 0.0f;\n    \n    for (size_t i = 0; i < dim; i++) {\n        diagonal_sum += array[i * dim * dim + i * dim + i];\n    }\n    \n    return diagonal_sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t source_row_index = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[source_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t source_row_index = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[source_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t source_row_index = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[source_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t source_row_index = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[source_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t source_row_index = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[source_row_index * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min_even = INT_MAX;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 1 && src[i] < min_even) {\n            min_even = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min_even = INT_MAX;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 1 && src[i] < min_even) {\n            min_even = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min_even = INT_MAX;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 1 && src[i] < min_even) {\n            min_even = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min_even = INT_MAX;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 1 && src[i] < min_even) {\n            min_even = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min_even = INT_MAX;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 1 && src[i] < min_even) {\n            min_even = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min_even : -1;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n        \n        // Logical right shift (convert to unsigned, shift, then convert back)\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        \n        // Add the two shifts together\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arithmetic_shift = src[i] >> shift;\n        unsigned int unsigned_src = (unsigned int)src[i];\n        int logical_shift = (int)(unsigned_src >> shift);\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n        \n        // Logical right shift (convert to unsigned, shift, then convert back)\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        \n        // Add the results and store in destination\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n        \n        // Logical right shift (convert to unsigned, shift, convert back)\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        \n        // Add the two shifts together\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Arithmetic right shift\n        int arithmetic_shift = src[i] >> shift;\n        \n        // Logical right shift (convert to unsigned, shift, convert back)\n        int logical_shift = (int)((unsigned int)src[i] >> shift);\n        \n        // Add the two shifts together\n        dst[i] = arithmetic_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += matrix[i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        uint32_t count = 0;\n        \n        while (num) {\n            count += num & 1;\n            num >>= 1;\n        }\n        \n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        num = num - ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num + (num >> 4)) & 0x0F0F0F0F;\n        num = num + (num >> 8);\n        num = num + (num >> 16);\n        dst[i] = num & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        num = num - ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num + (num >> 4)) & 0x0F0F0F0F;\n        num = num + (num >> 8);\n        num = num + (num >> 16);\n        dst[i] = num & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        num = num - ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num + (num >> 4)) & 0x0F0F0F0F;\n        num = num + (num >> 8);\n        num = num + (num >> 16);\n        dst[i] = num & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t num = src[i];\n        num = num - ((num >> 1) & 0x55555555);\n        num = (num & 0x33333333) + ((num >> 2) & 0x33333333);\n        num = (num + (num >> 4)) & 0x0F0F0F0F;\n        num = num + (num >> 8);\n        num = num + (num >> 16);\n        dst[i] = num & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            C[i * p + j] = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                \n                if (a_val >= -100 && a_val <= 100 && b_val >= -100 && b_val <= 100) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            for (size_t k = 0; k < dim3; k++) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                C[index] = A[index] + B[index];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float row_sum_squares = 0.0f;\n        \n        // Calculate L2 norm (square root of sum of squares)\n        for (size_t j = 0; j < n; j++) {\n            row_sum_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        \n        float row_l2_norm = sqrtf(row_sum_squares);\n        \n        // Divide each element by L2 norm\n        if (row_l2_norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= row_l2_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float row_sum_squares = 0.0f;\n        \n        // Calculate L^2 norm (square root of sum of squares)\n        for (size_t j = 0; j < n; j++) {\n            row_sum_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        \n        float row_norm = sqrtf(row_sum_squares);\n        \n        // Divide each element by row norm\n        for (size_t j = 0; j < n; j++) {\n            mat[i * n + j] /= row_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float row_sum_squares = 0.0f;\n        \n        // Calculate L2 norm (square root of sum of squares)\n        for (size_t j = 0; j < n; j++) {\n            row_sum_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        \n        float row_norm = sqrtf(row_sum_squares);\n        \n        // Normalize row by dividing each element by row norm\n        if (row_norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float row_sum_squares = 0.0f;\n        \n        // Calculate L2 norm (square root of sum of squares)\n        for (size_t j = 0; j < n; j++) {\n            row_sum_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        \n        float row_norm = sqrtf(row_sum_squares);\n        \n        // Divide each element by row norm\n        if (row_norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= row_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float row_sum_squares = 0.0f;\n        \n        // Calculate L2 norm (square root of sum of squares)\n        for (size_t j = 0; j < n; j++) {\n            row_sum_squares += mat[i * n + j] * mat[i * n + j];\n        }\n        \n        float norm = sqrtf(row_sum_squares);\n        \n        // Divide each element in the row by the norm\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded_value = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded_value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        float subtraction_result = tensor1[i] - tensor2[i];\n        dst[i] = (subtraction_result > 0) ? floorf(subtraction_result) : ceilf(subtraction_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        float subtraction_result = tensor1[i] - tensor2[i];\n        dst[i] = (subtraction_result > 0) ? floorf(subtraction_result) : ceilf(subtraction_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        float subtraction_result = tensor1[i] - tensor2[i];\n        dst[i] = (subtraction_result > 0) ? floorf(subtraction_result) : ceilf(subtraction_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        float subtraction_result = tensor1[i] - tensor2[i];\n        \n        // Round towards zero\n        dst[i] = subtraction_result > 0 ? floorf(subtraction_result) : ceilf(subtraction_result);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        float subtraction_result = tensor1[i] - tensor2[i];\n        dst[i] = (subtraction_result > 0) ? floorf(subtraction_result) : ceilf(subtraction_result);\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        bool is_ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 1; col++) {\n            int current = matrix[row * cols + col];\n            int next = matrix[row * cols + col + 1];\n            \n            if (is_ascending && current > next) {\n                return false;\n            }\n            \n            if (!is_ascending && current < next) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols - 1; j++) {\n            int current = matrix[i * cols + j];\n            int next = matrix[i * cols + j + 1];\n            \n            if (directions[i]) {\n                // Ascending order check\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                // Descending order check\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        bool is_ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 1; col++) {\n            int current = matrix[row * cols + col];\n            int next = matrix[row * cols + col + 1];\n            \n            if (is_ascending) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        bool is_ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 1; col++) {\n            int current = matrix[row * cols + col];\n            int next = matrix[row * cols + col + 1];\n            \n            if (is_ascending) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        bool is_ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 1; col++) {\n            int current = matrix[row * cols + col];\n            int next = matrix[row * cols + col + 1];\n            \n            if (is_ascending) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t multiple = (value / base) * base;\n        dst[i] = multiple;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        if (row_match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        if (row_match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        if (row_match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        if (row_match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        if (row_match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t equal_count = 0;\n\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            equal_count++;\n        }\n    }\n\n    return equal_count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = llabs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = llabs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = llabs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = llabs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        y[i] = llabs(a * x[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Initialize min and max with the first element\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    // Iterate through the vector to find min and max\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Initialize min and max with the first element\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    // Iterate through the vector to find min and max\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Initialize min and max with the first element\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    // Iterate through the vector to find min and max\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Initialize min and max with the first element\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    // Iterate through the vector to find min and max\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Initialize min and max with the first element\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    // Iterate through the vector to find min and max\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            // Skip first block\n            if (br == 0 && bc == 0) continue;\n\n            // Current block start\n            const int* current_block = matrix + (br * block_cols + bc) * block_size * block_size;\n\n            // Compare current block with first block\n            for (size_t r = 0; r < block_size; r++) {\n                for (size_t c = 0; c < block_size; c++) {\n                    if (first_block[r * block_size + c] != current_block[r * block_size + c]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Reference first block\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t block_row = 0; block_row < block_rows; block_row++) {\n        for (size_t block_col = 0; block_col < block_cols; block_col++) {\n            // Skip first block\n            if (block_row == 0 && block_col == 0) continue;\n\n            // Current block start\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Compare current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    if (first_block[i * block_size + j] != current_block[i * block_size + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < block_rows; block_row++) {\n        for (size_t block_col = 0; block_col < block_cols; block_col++) {\n            // Skip the first block\n            if (block_row == 0 && block_col == 0) continue;\n\n            // Current block start\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Compare each element of current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    if (first_block[i * block_size + j] != current_block[i * block_size + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check if block_size is valid\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // Reference first block\n    const int* first_block = matrix;\n\n    // Compare each block with the first block\n    for (size_t block_row = 0; block_row < block_rows; block_row++) {\n        for (size_t block_col = 0; block_col < block_cols; block_col++) {\n            // Skip first block\n            if (block_row == 0 && block_col == 0) continue;\n\n            // Current block start\n            const int* current_block = matrix + (block_row * block_cols + block_col) * block_size * block_size;\n\n            // Compare block elements\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    if (first_block[i * block_size + j] != current_block[i * block_size + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    // Check for illegal block size\n    if (block_size == 0 || block_size > rows || block_size > cols) {\n        return false;\n    }\n\n    // Check if matrix can be perfectly divided into blocks\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    // Number of blocks in rows and columns\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    // First block as reference\n    const int* first_block = matrix;\n\n    // Iterate through all blocks\n    for (size_t br = 0; br < block_rows; br++) {\n        for (size_t bc = 0; bc < block_cols; bc++) {\n            // Skip first block\n            if (br == 0 && bc == 0) continue;\n\n            // Current block start\n            const int* current_block = matrix + (br * block_cols + bc) * block_size * block_size;\n\n            // Compare current block with first block\n            for (size_t r = 0; r < block_size; r++) {\n                for (size_t c = 0; c < block_size; c++) {\n                    if (first_block[r * block_size + c] != current_block[r * block_size + c]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t block = 1; block < num_blocks; ++block) {\n        size_t block_start = block * block_size;\n        \n        for (size_t i = 0; i < block_size; ++i) {\n            double diff = std::abs(vec[i] - vec[block_start + i]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        size_t block_start = block * block_size;\n        for (size_t i = 0; i < block_size; ++i) {\n            if (std::abs(vec[i] - vec[block_start + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        size_t block_start = block * block_size;\n        \n        for (size_t i = 0; i < block_size; ++i) {\n            double diff = std::abs(vec[i] - vec[block_start + i]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for illegal inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        size_t block_start = block * block_size;\n        for (size_t i = 0; i < block_size; ++i) {\n            if (std::abs(vec[i] - vec[block_start + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    // Check for invalid inputs\n    if (!vec || length == 0 || block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    // Calculate number of complete blocks\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks < 2) {\n        return false;\n    }\n\n    // Compare each subsequent block with the first block\n    for (size_t block = 1; block < num_complete_blocks; ++block) {\n        size_t block_start = block * block_size;\n        \n        for (size_t i = 0; i < block_size; ++i) {\n            double diff = std::abs(vec[i] - vec[block_start + i]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double row_norm = 0.0;\n        \n        // Calculate Euclidean norm for the current row\n        for (size_t j = 0; j < cols; j++) {\n            double element = matrix[i * cols + j];\n            row_norm += element * element;\n        }\n        \n        row_norm = sqrt(row_norm);\n        \n        // Compare row norm with corresponding threshold\n        result[i] = (row_norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double row_norm = 0.0;\n        \n        // Calculate Euclidean norm for current row\n        for (size_t j = 0; j < cols; j++) {\n            double value = matrix[i * cols + j];\n            row_norm += value * value;\n        }\n        \n        row_norm = sqrt(row_norm);\n        \n        // Compare row norm with corresponding threshold\n        result[i] = (row_norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double row_norm = 0.0;\n        \n        // Calculate Euclidean norm for current row\n        for (size_t j = 0; j < cols; j++) {\n            double value = matrix[i * cols + j];\n            row_norm += value * value;\n        }\n        \n        row_norm = sqrt(row_norm);\n        \n        // Compare row norm with corresponding threshold\n        result[i] = (row_norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double row_norm = 0.0;\n        \n        // Calculate Euclidean norm for the current row\n        for (size_t j = 0; j < cols; j++) {\n            double value = matrix[i * cols + j];\n            row_norm += value * value;\n        }\n        \n        row_norm = sqrt(row_norm);\n        \n        // Compare row norm with corresponding threshold\n        result[i] = (row_norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double row_norm = 0.0;\n        \n        for (size_t j = 0; j < cols; j++) {\n            double element = matrix[i * cols + j];\n            row_norm += element * element;\n        }\n        \n        row_norm = sqrt(row_norm);\n        result[i] = (row_norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_of_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_of_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_of_squares - 2 * sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n\n    for (size_t i = 0; i < length; i++) {\n        sum_squares += (int64_t)A[i] * A[i] + (int64_t)B[i] * B[i];\n        sum_products += (int64_t)A[i] * B[i];\n    }\n\n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Elements before midpoint: bitwise XOR\n    for (size_t i = 0; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Element at midpoint: keep value from A\n    C[midpoint] = A[midpoint];\n\n    // Elements after midpoint: bitwise AND\n    for (size_t i = midpoint + 1; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Elements before midpoint: bitwise XOR\n    for (size_t i = 0; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Element at midpoint: keep value from A\n    C[midpoint] = A[midpoint];\n    \n    // Elements after midpoint: bitwise AND\n    for (size_t i = midpoint + 1; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    for (size_t i = 0; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    C[midpoint] = A[midpoint];\n\n    for (size_t i = midpoint + 1; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    \n    // Elements before midpoint: bitwise XOR\n    for (size_t i = 0; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Element at midpoint: keep value from A\n    C[midpoint] = A[midpoint];\n    \n    // Elements after midpoint: bitwise AND\n    for (size_t i = midpoint + 1; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n\n    // Elements before midpoint: bitwise XOR\n    for (size_t i = 0; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Element at midpoint: keep value from A\n    C[midpoint] = A[midpoint];\n\n    // Elements after midpoint: bitwise AND\n    for (size_t i = midpoint + 1; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                \n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                \n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                \n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                \n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    for (size_t i = 0; i < dim1; ++i) {\n        for (size_t j = 0; j < dim2; ++j) {\n            for (size_t k = 0; k < dim3; ++k) {\n                size_t index = i * dim2 * dim3 + j * dim3 + k;\n                \n                if (cond1[index] && cond2[index]) {\n                    out[index] = A[index];\n                } else if (cond1[index] && !cond2[index]) {\n                    out[index] = B[index];\n                } else if (!cond1[index] && cond2[index]) {\n                    out[index] = C[index];\n                } else {\n                    out[index] = D[index];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t bit_count = 0;\n        \n        while (value) {\n            bit_count += value & 1;\n            value >>= 1;\n        }\n        \n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t bit_count = 0;\n        \n        while (value) {\n            bit_count += value & 1;\n            value >>= 1;\n        }\n        \n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t bit_count = 0;\n        \n        while (value) {\n            bit_count += value & 1;\n            value >>= 1;\n        }\n        \n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t current = A[i];\n        uint8_t bit_count = 0;\n        \n        while (current) {\n            bit_count += current & 1;\n            current >>= 1;\n        }\n        \n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t bit_count = 0;\n        \n        while (value) {\n            bit_count += value & 1;\n            value >>= 1;\n        }\n        \n        out[i] = bit_count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Check if low 4 bits are all 1\n        if ((src[i] & 0x0F) == 0x0F) {\n            // Rotate the element by rotate_bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negation of the element\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Check if low 4 bits are all 1\n        if ((src[i] & 0x0F) == 0x0F) {\n            // Rotate bits toward low bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negation\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Check if low 4 bits are all 1\n        if ((src[i] & 0x0F) == 0x0F) {\n            // Rotate bits toward low bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negation\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0x0F) == 0x0F) {\n            // If low 4 bits are all 1, rotate the element\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Otherwise, perform bitwise negation\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        // Check if low 4 bits are all 1\n        if ((src[i] & 0x0F) == 0x0F) {\n            // Rotate bits toward low bits\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            // Bitwise negation\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = fabsf(epsilon);\n        \n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = fabsf(epsilon);\n        \n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = fabsf(epsilon);\n        \n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = fabsf(epsilon);\n        \n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        float abs_epsilon = fabsf(epsilon);\n        \n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * (1 << scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * powf(10, scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * powf(10, scale);\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * powf(10, scale);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float div_result = A[i] / B[i];\n        C[i] = (int32_t)roundf(div_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)roundf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)roundf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)roundf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float result = A[i] / B[i];\n        C[i] = (int32_t)roundf(result);\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            \n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            \n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            \n            if (normalized < 0.0f) {\n                B[i] = 0.0f;\n            } else if (normalized > 1.0f) {\n                B[i] = 1.0f;\n            } else {\n                B[i] = normalized;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            \n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            \n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            \n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            \n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            \n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            \n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        // Extract high 16 bits by right-shifting 16 bits and converting to float\n        float value = (float)((A[i] >> 16) & 0xFFFF);\n        \n        // Take square root of the value\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        // Extract high 16 bits and convert to float\n        float value = (float)((A[i] >> 16) & 0xFFFF);\n        \n        // Take square root\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        // Extract high 16 bits by right-shifting 16 bits and converting to float\n        float value = (float)((A[i] >> 16) & 0xFFFF);\n        \n        // Take square root of the float value\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        // Extract high 16 bits by right-shifting 16 bits and converting to float\n        float value = (float)((A[i] >> 16) & 0xFFFF);\n        \n        // Take square root of the value\n        B[i] = sqrtf(value);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_value = (float)high_bits;\n        B[i] = sqrtf(float_value);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Always set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Process remaining elements\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            // Compute difference when condition is true\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            // Set to 0.0f when condition is false\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0.0f\n    diff[0] = 0.0f;\n\n    // Iterate through the rest of the array\n    for (size_t i = 1; i < size; i++) {\n        // If condition is true, compute difference and convert to float\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        }\n        // If condition is false, set to 0.0f\n        else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0.0f\n    diff[0] = 0.0f;\n\n    // Process remaining elements\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            // Compute difference when condition is true\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            // Set to 0.0f when condition is false\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // First element is always 0.0f\n    diff[0] = 0.0f;\n\n    // Process remaining elements\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            // Compute difference when condition is true\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            // Set to 0.0f when condition is false\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Always set first element to 0.0f\n    diff[0] = 0.0f;\n\n    // Iterate through the rest of the array\n    for (size_t i = 1; i < size; i++) {\n        // If condition is true, compute difference and convert to float\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        }\n        // If condition is false, set to 0.0f\n        else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n\n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n\n            // ReLU activation\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = (sum > 0) ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    \n    for (int operation : operations) {\n        balance += operation;\n        \n        if (balance < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int operation : operations) {\n        balance += operation;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    \n    // Calculate mean\n    double mean = 0.0;\n    for (double num : numbers) {\n        mean += num;\n    }\n    mean /= numbers.size();\n    \n    // Calculate absolute deviations\n    double total_deviation = 0.0;\n    for (double num : numbers) {\n        total_deviation += std::abs(num - mean);\n    }\n    \n    // Return mean absolute deviation\n    return total_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    \n    // Calculate mean\n    double mean = 0.0;\n    for (double num : numbers) {\n        mean += num;\n    }\n    mean /= numbers.size();\n    \n    // Calculate absolute deviations\n    double total_deviation = 0.0;\n    for (double num : numbers) {\n        total_deviation += std::abs(num - mean);\n    }\n    \n    // Return mean absolute deviation\n    return total_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    \n    // Calculate mean\n    double mean = 0.0;\n    for (double num : numbers) {\n        mean += num;\n    }\n    mean /= numbers.size();\n    \n    // Calculate absolute deviations\n    double total_deviation = 0.0;\n    for (double num : numbers) {\n        total_deviation += std::abs(num - mean);\n    }\n    \n    // Return mean absolute deviation\n    return total_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    \n    // Calculate mean\n    double mean = 0.0;\n    for (double num : numbers) {\n        mean += num;\n    }\n    mean /= numbers.size();\n    \n    // Calculate absolute deviations\n    double total_deviation = 0.0;\n    for (double num : numbers) {\n        total_deviation += std::abs(num - mean);\n    }\n    \n    // Return mean absolute deviation\n    return total_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    \n    // Calculate mean\n    double mean = 0.0;\n    for (double num : numbers) {\n        mean += num;\n    }\n    mean /= numbers.size();\n    \n    // Calculate absolute deviations\n    double total_deviation = 0.0;\n    for (double num : numbers) {\n        total_deviation += std::abs(num - mean);\n    }\n    \n    // Return mean absolute deviation\n    return total_deviation / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n    \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        \n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n    \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        \n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    \n    for (size_t i = 0; i < numbers.size(); ++i) {\n        if (i > 0) {\n            result.push_back(delimeter);\n        }\n        result.push_back(numbers[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n    \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        \n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n    \n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        \n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    \n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    \n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    \n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    \n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    int current_max = INT_MIN;\n    \n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings are of equal length by padding with leading zeros\n    int max_length = std::max(a.length(), b.length());\n    a = std::string(max_length - a.length(), '0') + a;\n    b = std::string(max_length - b.length(), '0') + b;\n    \n    // Perform XOR operation\n    std::string result;\n    for (int i = 0; i < max_length; i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings are of equal length by padding with leading zeros\n    if (a.length() < b.length()) {\n        a = std::string(b.length() - a.length(), '0') + a;\n    } else if (b.length() < a.length()) {\n        b = std::string(a.length() - b.length(), '0') + b;\n    }\n    \n    // Perform XOR on each character\n    std::string result;\n    for (size_t i = 0; i < a.length(); ++i) {\n        // XOR each bit: 0^0=0, 0^1=1, 1^0=1, 1^1=0\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings are the same length by padding with zeros\n    while (a.length() < b.length()) {\n        a = '0' + a;\n    }\n    while (b.length() < a.length()) {\n        b = '0' + b;\n    }\n    \n    // Perform XOR on each bit\n    std::string result;\n    for (size_t i = 0; i < a.length(); i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings are the same length by padding with leading zeros\n    int max_length = std::max(a.length(), b.length());\n    a = std::string(max_length - a.length(), '0') + a;\n    b = std::string(max_length - b.length(), '0') + b;\n    \n    // Perform XOR operation\n    std::string result;\n    for (int i = 0; i < max_length; i++) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\nstd::string string_xor(std::string a, std::string b) {\n    // Ensure both strings are the same length by padding with leading zeros\n    int max_length = std::max(a.length(), b.length());\n    a = std::string(max_length - a.length(), '0') + a;\n    b = std::string(max_length - b.length(), '0') + b;\n    \n    // Perform XOR on each character\n    std::string result;\n    for (int i = 0; i < max_length; i++) {\n        // XOR each bit\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    return *std::max_element(strings.begin(), strings.end(), \n        [](const std::string& a, const std::string& b) {\n            return a.length() < b.length();\n        });\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    return *std::max_element(strings.begin(), strings.end(), \n        [](const std::string& a, const std::string& b) {\n            return a.length() < b.length();\n        });\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    return *std::max_element(strings.begin(), strings.end(), \n        [](const std::string& a, const std::string& b) {\n            return a.length() < b.length();\n        });\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    return *std::max_element(strings.begin(), strings.end(), \n        [](const std::string& a, const std::string& b) {\n            return a.length() < b.length();\n        });\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    return *std::max_element(strings.begin(), strings.end(), \n        [](const std::string& a, const std::string& b) {\n            return a.length() < b.length();\n        });\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n    \n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = std::abs(numbers[i] - numbers[i-1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i-1];\n            second = numbers[i];\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n    \n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = std::abs(numbers[i] - numbers[i-1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i-1];\n            second = numbers[i];\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n    \n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = std::abs(numbers[i] - numbers[i-1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i-1];\n            second = numbers[i];\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n    \n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = std::abs(numbers[i] - numbers[i-1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i-1];\n            second = numbers[i];\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n    \n    std::sort(numbers.begin(), numbers.end());\n    \n    float min_diff = std::numeric_limits<float>::max();\n    float first = numbers[0];\n    float second = numbers[1];\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = std::abs(numbers[i] - numbers[i-1]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            first = numbers[i-1];\n            second = numbers[i];\n        }\n    }\n    \n    return {first, second};\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return numbers;\n    }\n    \n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    \n    if (min_val == max_val) {\n        return std::vector<float>(numbers.size(), 0.0f);\n    }\n    \n    std::vector<float> result;\n    for (float num : numbers) {\n        result.push_back((num - min_val) / (max_val - min_val));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i >= 1; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    for (uint64_t i = n / 2; i > 0; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    \n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    \n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    \n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    \n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    \n    for (int i = 2; i * i <= n; i++) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    \n    for (int64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    \n    for (int64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    \n    for (int64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    \n    for (int64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    \n    for (int64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    \n    for (char& c : result) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            c = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    bool hasLetter = false;\n    std::string result = s;\n    \n    for (char& c : result) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            c = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    \n    for (char& c : result) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            c = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s){\n    bool hasLetter = false;\n    std::string result = s;\n    \n    for (char& c : result) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            c = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\nstd::string solve(const std::string & s) {\n    bool hasLetter = false;\n    std::string result = s;\n    \n    for (char& c : result) {\n        if (std::isalpha(c)) {\n            hasLetter = true;\n            c = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    \n    if (!hasLetter) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> to_sort;\n    for (int i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    std::sort(to_sort.begin(), to_sort.end());\n    \n    int sort_index = 0;\n    for (int i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            l[i] = to_sort[sort_index];\n            sort_index++;\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> to_sort;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    std::sort(to_sort.begin(), to_sort.end());\n    \n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> to_sort;\n    for (int i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    std::sort(to_sort.begin(), to_sort.end());\n    \n    for (int i = 0; i < to_sort.size(); i++) {\n        l[i * 3] = to_sort[i];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> to_sort;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    std::sort(to_sort.begin(), to_sort.end());\n    \n    size_t sort_index = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> to_sort;\n    for (int i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            to_sort.push_back(l[i]);\n        }\n    }\n    \n    std::sort(to_sort.begin(), to_sort.end());\n    \n    int sort_index = 0;\n    for (int i = 0; i < l.size(); i += 3) {\n        if (i < l.size()) {\n            l[i] = to_sort[sort_index++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    float max_val = l[0];\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    float max_val = l[0];\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    float max_val = l[0];\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    float max_val = l[0];\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l) {\n    float max_val = l[0];\n    for (float num : l) {\n        if (num > max_val) {\n            max_val = num;\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && strstr(itoa(i), \"7\") != NULL) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && strstr(itoa(i), \"7\") != NULL) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && strchr(itoa(i), '7') != NULL) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if ((i % 11 == 0 || i % 13 == 0) && strstr(itoa(i), \"7\") != NULL) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    std::vector<float> result = l;\n    \n    // Extract even-indexed values\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Replace even indices with sorted values\n    size_t sorted_index = 0;\n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_values[sorted_index++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    \n    // Extract even-indexed values\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even-indexed values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the result vector\n    std::vector<float> result = l;\n    size_t even_index = 0;\n    \n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_values[even_index++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    std::vector<float> result = l;\n    \n    // Extract even-indexed values\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even-indexed values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Replace even indices with sorted values\n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_values[(i - 1) / 2];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    \n    // Extract even-indexed values\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even-indexed values\n    std::sort(even_values.begin(), even_values.end());\n    \n    // Reconstruct the result vector\n    std::vector<float> result = l;\n    size_t even_index = 0;\n    \n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_values[even_index++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_values;\n    std::vector<float> result = l;\n\n    // Extract even-indexed values\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort even-indexed values\n    std::sort(even_values.begin(), even_values.end());\n\n    // Replace even indices with sorted values\n    for (size_t i = 1; i < result.size(); i += 2) {\n        result[i] = even_values[(i - 1) / 2];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector has less than 3 elements, return false\n    if (n < 3) return false;\n    \n    // Sort the vector to help with efficient searching\n    std::sort(l.begin(), l.end());\n    \n    // Iterate through each element as a potential first element of the triple\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates to avoid repeated checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        // Use two-pointer technique to find complementary pair\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int current_sum = l[i] + l[left] + l[right];\n            \n            if (current_sum == 0) {\n                return true;  // Found a triple that sums to zero\n            }\n            \n            if (current_sum < 0) {\n                left++;  // Need a larger sum, move left pointer right\n            } else {\n                right--;  // Need a smaller sum, move right pointer left\n            }\n        }\n    }\n    \n    return false;  // No triple found that sums to zero\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector has less than 3 elements, return false\n    if (n < 3) return false;\n    \n    // Sort the vector to help with searching\n    std::sort(l.begin(), l.end());\n    \n    // Iterate through the vector, fixing one element\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates to avoid duplicate triplets\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        // Two-pointer technique to find complementary elements\n        while (left < right) {\n            int current_sum = l[i] + l[left] + l[right];\n            \n            if (current_sum == 0) {\n                return true;\n            }\n            else if (current_sum < 0) {\n                left++;\n            }\n            else {\n                right--;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    // If less than 3 elements, return false\n    if (n < 3) {\n        return false;\n    }\n    \n    // Sort the vector to help with efficient searching\n    std::sort(l.begin(), l.end());\n    \n    // Iterate through the vector, fixing one element\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates to avoid repeated combinations\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        // Use two-pointer technique to find complementary pair\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int current_sum = l[i] + l[left] + l[right];\n            \n            if (current_sum == 0) {\n                return true;\n            }\n            \n            if (current_sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    // If less than 3 elements, return false\n    if (n < 3) return false;\n    \n    // Sort the vector to help with searching\n    std::sort(l.begin(), l.end());\n    \n    // Iterate through each element as the first number\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates to avoid repeated checks\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        // Use two-pointer technique to find complementary pair\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int current_sum = l[i] + l[left] + l[right];\n            \n            if (current_sum == 0) {\n                return true;  // Found a triplet that sums to zero\n            }\n            \n            if (current_sum < 0) {\n                left++;  // Need a larger sum\n            } else {\n                right--;  // Need a smaller sum\n            }\n        }\n    }\n    \n    return false;  // No triplet found\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\nbool triples_sum_to_zero(std::vector<int> l) {\n    int n = l.size();\n    \n    // If vector has less than 3 elements, return false\n    if (n < 3) return false;\n    \n    // Sort the vector to help with efficient searching\n    std::sort(l.begin(), l.end());\n    \n    // Iterate through the vector, fixing one element at a time\n    for (int i = 0; i < n - 2; i++) {\n        // Skip duplicates to avoid duplicate triples\n        if (i > 0 && l[i] == l[i-1]) continue;\n        \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int current_sum = l[i] + l[left] + l[right];\n            \n            if (current_sum == 0) {\n                return true;  // Found a triple that sums to zero\n            }\n            \n            if (current_sum < 0) {\n                left++;  // Need a larger sum, move left pointer\n            } else {\n                right--;  // Need a smaller sum, move right pointer\n            }\n        }\n    }\n    \n    return false;  // No triple found that sums to zero\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (int& num : l) {\n        num++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    \n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n    \n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    \n    return negative ? \"-\" + result : result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n    \n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    \n    return negative ? \"-\" + result : result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n    \n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    \n    return negative ? \"-\" + result : result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n    \n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    \n    return negative ? \"-\" + result : result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n    \n    while (x > 0) {\n        result = std::to_string(x % base) + result;\n        x /= base;\n    }\n    \n    return negative ? \"-\" + result : result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s) {\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s) {\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s) {\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s) {\n    std::string out;\n    int i;\n    for (i = 0; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out = out + (char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int num : l) {\n        if(num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '<') {\n            balance++;\n        } else if (bracket == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    \n    for (char bracket : brackets) {\n        if (bracket == '(') {\n            balance++;\n        } else if (bracket == ')') {\n            balance--;\n        }\n        \n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return {};\n    }\n    \n    std::vector<float> result;\n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\nstd::vector<float> derivative(std::vector<float> xs) {\n    std::vector<float> result;\n    \n    for (size_t i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = std::tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check for 'y' at the end of the word\n    if (!s.empty() && std::tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = std::tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if 'y' is at the end of the word\n    if (!s.empty() && std::tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = std::tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check for 'y' at the end of the word\n    if (!s.empty() && std::tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = std::tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check for 'y' at the end of the word\n    if (!s.empty() && std::tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char c : s) {\n        c = std::tolower(c);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if 'y' is at the end and is a vowel\n    if (!s.empty() && std::tolower(s.back()) == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even || \n                (arr[i] == smallest_even && i < smallest_index) || \n                smallest_index == -1) {\n                smallest_even = arr[i];\n                smallest_index = i;\n            }\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    }\n    \n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    }\n    \n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    }\n    \n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    }\n    \n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\nstd::vector<int> pluck(std::vector<int> arr) {\n    int smallest_even = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    }\n    \n    return {smallest_even, smallest_index};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> frequency;\n    \n    // Count frequency of each number\n    for (int num : lst) {\n        frequency[num]++;\n    }\n    \n    int maxResult = -1;\n    \n    // Check each unique number\n    for (auto& pair : frequency) {\n        int num = pair.first;\n        int freq = pair.second;\n        \n        // Check if frequency is greater or equal to the number\n        if (num > 0 && freq >= num) {\n            maxResult = std::max(maxResult, num);\n        }\n    }\n    \n    return maxResult;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    \n    // Count frequency of each number\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int maxVal = -1;\n    \n    // Check each unique number\n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        \n        // If frequency is >= number and number is positive\n        if (num > 0 && count >= num) {\n            maxVal = std::max(maxVal, num);\n        }\n    }\n    \n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    \n    // Count frequency of each number\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int maxVal = -1;\n    \n    // Check each unique number\n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        \n        // Check if frequency is greater or equal to the number\n        if (num > 0 && count >= num) {\n            maxVal = std::max(maxVal, num);\n        }\n    }\n    \n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    \n    // Count frequency of each number\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int maxVal = -1;\n    \n    // Check each unique number\n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        \n        // Check if frequency is greater or equal to number\n        if (num > 0 && count >= num) {\n            maxVal = std::max(maxVal, num);\n        }\n    }\n    \n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    \n    // Count frequency of each number\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int maxVal = -1;\n    \n    // Check each unique number\n    for (auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        \n        // If frequency is greater or equal to the number\n        if (count >= num) {\n            maxVal = std::max(maxVal, num);\n        }\n    }\n    \n    return maxVal;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to maximum weight\n    int total_weight = 0;\n    for (int num : q) {\n        total_weight += num;\n    }\n    \n    if (total_weight > w) {\n        return false;\n    }\n    \n    // Check if the vector is balanced (palindromic)\n    int left = 0;\n    int right = q.size() - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to maximum weight\n    int total_weight = 0;\n    for (int num : q) {\n        total_weight += num;\n    }\n    \n    if (total_weight > w) {\n        return false;\n    }\n    \n    // Check if the vector is balanced (palindromic)\n    int left = 0;\n    int right = q.size() - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the sum of elements is less than or equal to the maximum weight\n    int total_weight = 0;\n    for (int num : q) {\n        total_weight += num;\n    }\n    \n    if (total_weight > w) {\n        return false;\n    }\n    \n    // Check if the vector is balanced (palindromic)\n    int left = 0;\n    int right = q.size() - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the total weight is less than or equal to maximum weight\n    int total_weight = 0;\n    for (int num : q) {\n        total_weight += num;\n    }\n    \n    if (total_weight > w) {\n        return false;\n    }\n    \n    // Check if the vector is balanced (palindromic)\n    int left = 0;\n    int right = q.size() - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\nbool will_it_fly(std::vector<int> q, int w) {\n    // Check if the total weight exceeds the maximum weight\n    int total_weight = 0;\n    for (int num : q) {\n        total_weight += num;\n    }\n    if (total_weight > w) {\n        return false;\n    }\n    \n    // Check if the vector is balanced (palindromic)\n    int left = 0;\n    int right = q.size() - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n    \n    // Calculate total characters in first vector\n    for (const std::string& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    // Calculate total characters in second vector\n    for (const std::string& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    // Return vector with fewer total characters\n    // If equal, return first vector\n    return (total_chars2 < total_chars1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n    \n    for (const std::string& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    for (const std::string& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n    \n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n    \n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    return total_chars1 <= total_chars2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n    \n    for (const auto& str : lst1) {\n        total_chars1 += str.length();\n    }\n    \n    for (const auto& str : lst2) {\n        total_chars2 += str.length();\n    }\n    \n    return (total_chars1 <= total_chars2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n <= 1 || x == 0) return false;\n    \n    while (x % n == 0) {\n        x /= n;\n    }\n    \n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n <= 1 || x == 0) return false;\n    \n    while (x % n == 0) {\n        x /= n;\n    }\n    \n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n    \n    while (x % n == 0) {\n        x /= n;\n    }\n    \n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n    \n    while (x % n == 0) {\n        x /= n;\n    }\n    \n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n <= 1) return false;\n    if (x == 1) return true;\n    \n    while (x % n == 0) {\n        x /= n;\n    }\n    \n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    \n    for (char c : num) {\n        if (primes.count(c) > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    \n    for (char c : num) {\n        if (primes.count(c)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    \n    for (char digit : num) {\n        if (primes.count(digit) > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    \n    for (char c : num) {\n        if (primes.count(c) > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    \n    for (char digit : num) {\n        if (primes.count(digit)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    for (size_t i = 0; i + 2 < s.length(); ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int length = str.length();\n    \n    if (length <= 1) return false;\n    \n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int length = str.length();\n    \n    if (length <= 1) return false;\n    \n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int length = str.length();\n    \n    if (length <= 1) return false;\n    \n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int length = str.length();\n    \n    if (length <= 1) return false;\n    \n    for (int i = 2; i * i <= length; i++) {\n        if (length % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\nbool prime_length(const std::string & str) {\n    int len = str.length();\n    \n    if (len <= 1) return false;\n    \n    for (int i = 2; i * i <= len; i++) {\n        if (len % i == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    // Calculate the sum of digits\n    uint64_t digitSum = 0;\n    while (N > 0) {\n        digitSum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert digit sum to binary string\n    if (digitSum == 0) return \"0\";\n    \n    std::string binary;\n    while (digitSum > 0) {\n        binary = std::to_string(digitSum % 2) + binary;\n        digitSum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    // Calculate the sum of digits\n    uint64_t digitSum = 0;\n    while (N > 0) {\n        digitSum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert sum to binary string\n    if (digitSum == 0) return \"0\";\n    \n    std::string binary;\n    while (digitSum > 0) {\n        binary = std::to_string(digitSum % 2) + binary;\n        digitSum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    // Calculate the sum of digits\n    uint64_t digitSum = 0;\n    while (N > 0) {\n        digitSum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert sum to binary\n    if (digitSum == 0) return \"0\";\n    \n    std::string binary;\n    while (digitSum > 0) {\n        binary = std::to_string(digitSum % 2) + binary;\n        digitSum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    // Calculate the sum of digits\n    uint64_t digitSum = 0;\n    while (N > 0) {\n        digitSum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert digit sum to binary string\n    if (digitSum == 0) return \"0\";\n    \n    std::string binary;\n    while (digitSum > 0) {\n        binary = std::to_string(digitSum % 2) + binary;\n        digitSum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\nstd::string solve(uint64_t N) {\n    // Calculate the sum of digits\n    uint64_t digitSum = 0;\n    while (N > 0) {\n        digitSum += N % 10;\n        N /= 10;\n    }\n    \n    // Convert digit sum to binary string\n    if (digitSum == 0) return \"0\";\n    \n    std::string binary;\n    while (digitSum > 0) {\n        binary = std::to_string(digitSum % 2) + binary;\n        digitSum /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for(char c : s){\n        if(isalpha(c)){\n            char base = islower(c) ? 'a' : 'A';\n            result += base + (c - base + 2 * 2) % 26;\n        }\n        else{\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if(isalpha(c)){\n            char base = islower(c) ? 'a' : 'A';\n            result += base + (c - base + 2 * 2) % 26;\n        }\n        else{\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for(char c : s){\n        if(isalpha(c)){\n            char base = islower(c) ? 'a' : 'A';\n            result += base + (c - base + 2 * 2) % 26;\n        }\n        else{\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for(char c : s){\n        if(isalpha(c)){\n            char base = islower(c) ? 'a' : 'A';\n            result += base + (c - base + 2 * 2) % 26;\n        }\n        else{\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\nstd::string encrypt(const std::string & s){\n    std::string result = \"\";\n    for(char c : s){\n        if(isalpha(c)){\n            char base = islower(c) ? 'a' : 'A';\n            result += base + (c - base + 2 * 2) % 26;\n        }\n        else{\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (std::isalpha(c)) {\n            // Swap case\n            char swapped = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n            \n            // Check if vowel\n            if (strchr(\"aeiouAEIOU\", swapped)) {\n                // Replace vowel with letter 2 places ahead\n                char base = std::islower(swapped) ? 'a' : 'A';\n                swapped = base + (swapped - base + 2) % 26;\n            }\n            \n            result += swapped;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message){\n    std::string result;\n    for (char c : message) {\n        if (std::isalpha(c)) {\n            // Swap case\n            char swapped = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n            \n            // Check if vowel\n            if (strchr(\"aeiouAEIOU\", swapped)) {\n                // Replace vowel with letter 2 places ahead\n                char base = std::islower(swapped) ? 'a' : 'A';\n                char replacement = base + ((swapped - base + 2) % 26);\n                result += replacement;\n            } else {\n                result += swapped;\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (std::isalpha(c)) {\n            // Swap case\n            char swapped = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n            \n            // Check if vowel\n            if (strchr(\"aeiouAEIOU\", swapped)) {\n                // Replace vowel with letter 2 places ahead\n                char base = std::isupper(swapped) ? 'A' : 'a';\n                swapped = base + (swapped - base + 2) % 26;\n            }\n            \n            result += swapped;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message){\n    std::string result = message;\n    \n    for (char &c : result) {\n        // Swap case\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n        \n        // Replace vowels\n        if (strchr(\"aeiouAEIOU\", c)) {\n            switch (tolower(c)) {\n                case 'a': c = isupper(c) ? 'C' : 'c'; break;\n                case 'e': c = isupper(c) ? 'G' : 'g'; break;\n                case 'i': c = isupper(c) ? 'K' : 'k'; break;\n                case 'o': c = isupper(c) ? 'Q' : 'q'; break;\n                case 'u': c = isupper(c) ? 'W' : 'w'; break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (std::isalpha(c)) {\n            // Swap case\n            char swapped = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n            \n            // Check if vowel\n            if (strchr(\"aeiouAEIOU\", swapped) != nullptr) {\n                // Replace vowel with letter 2 places ahead\n                char base = std::isupper(swapped) ? 'A' : 'a';\n                char encoded = base + (swapped - base + 2) % 26;\n                result += encoded;\n            } else {\n                result += swapped;\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if key contains non-alphabetic characters\n        if (!std::all_of(key.begin(), key.end(), [](char c) { return std::isalpha(c); })) {\n            return false;\n        }\n        \n        // Check lowercase\n        if (!std::all_of(key.begin(), key.end(), [](char c) { return std::islower(c); })) {\n            all_lower = false;\n        }\n        \n        // Check uppercase\n        if (!std::all_of(key.begin(), key.end(), [](char c) { return std::isupper(c); })) {\n            all_upper = false;\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if key contains non-alphabetic characters\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false;\n            }\n        }\n        \n        // Check case consistency\n        for (char c : key) {\n            if (std::islower(c)) {\n                all_upper = false;\n            }\n            if (std::isupper(c)) {\n                all_lower = false;\n            }\n        }\n        \n        // If both flags are false, return false\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if key contains non-alphabetic characters\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false;\n            }\n        }\n        \n        // Check lowercase\n        all_lower &= std::all_of(key.begin(), key.end(), [](char c) { return std::islower(c); });\n        \n        // Check uppercase\n        all_upper &= std::all_of(key.begin(), key.end(), [](char c) { return std::isupper(c); });\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if key contains non-alphabetic characters\n        if (!std::all_of(key.begin(), key.end(), [](char c) { return std::isalpha(c); })) {\n            return false;\n        }\n        \n        // Check if all keys are lowercase\n        if (!std::all_of(key.begin(), key.end(), [](char c) { return std::islower(c); })) {\n            all_lower = false;\n        }\n        \n        // Check if all keys are uppercase\n        if (!std::all_of(key.begin(), key.end(), [](char c) { return std::isupper(c); })) {\n            all_upper = false;\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        // Check if key contains non-alphabetic characters\n        for (char c : key) {\n            if (!std::isalpha(c)) {\n                return false;\n            }\n        }\n        \n        // Check case consistency\n        for (char c : key) {\n            if (std::islower(c)) {\n                all_upper = false;\n            }\n            if (std::isupper(c)) {\n                all_lower = false;\n            }\n        }\n        \n        // If both flags are false, keys are mixed case\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    \n    if (n <= 1) {\n        return primes;\n    }\n    \n    // Use Sieve of Eratosthenes to find primes\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    \n    if (n <= 1) {\n        return primes;\n    }\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    \n    if (n <= 1) {\n        return primes;\n    }\n    \n    // Use Sieve of Eratosthenes to find primes\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    \n    if (n <= 1) {\n        return primes;\n    }\n    \n    // Use Sieve of Eratosthenes to find primes\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    \n    if (n <= 1) {\n        return primes;\n    }\n    \n    // Use Sieve of Eratosthenes to find primes\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    \n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\nint count_upper(const std::string & s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile(n);\n    pile[0] = n;\n    \n    for (int i = 1; i < n; i++) {\n        if (pile[i-1] % 2 == 0) {\n            pile[i] = pile[i-1] + 2;\n        } else {\n            pile[i] = pile[i-1] + 2;\n        }\n    }\n    \n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile(n);\n    pile[0] = n;\n    \n    for (int i = 1; i < n; i++) {\n        if (pile[i-1] % 2 == 0) {\n            pile[i] = pile[i-1] + 2;\n        } else {\n            pile[i] = pile[i-1] + 2;\n        }\n    }\n    \n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile(n);\n    pile[0] = n;\n    \n    for (int i = 1; i < n; i++) {\n        if (pile[i-1] % 2 == 0) {\n            pile[i] = pile[i-1] + 2;\n        } else {\n            pile[i] = pile[i-1] + 2;\n        }\n    }\n    \n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile(n);\n    pile[0] = n;\n    \n    for (int i = 1; i < n; i++) {\n        if (pile[i-1] % 2 == 0) {\n            pile[i] = pile[i-1] + 2;\n        } else {\n            pile[i] = pile[i-1] + 2;\n        }\n    }\n    \n    return pile;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> pile(n);\n    pile[0] = n;\n    \n    for (int i = 1; i < n; i++) {\n        if (pile[i-1] % 2 == 0) {\n            pile[i] = pile[i-1] + 2;\n        } else {\n            pile[i] = pile[i-1] + 2;\n        }\n    }\n    \n    return pile;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n    \n    if (sum % count >= count / 2) {\n        avg++;\n    }\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n    \n    if (sum % count >= count / 2) {\n        avg++;\n    }\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n    \n    if (sum % count >= count / 2) {\n        avg++;\n    }\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n    \n    if (sum % count >= count / 2) {\n        avg++;\n    }\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; i++) {\n        sum += i;\n    }\n    \n    int64_t count = m - n + 1;\n    int64_t avg = sum / count;\n    \n    if (sum % count >= count / 2) {\n        avg++;\n    }\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long factorial = 1;\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            factorial *= i;\n            result[i-1] = factorial % 10000;\n        } else {\n            sum += i;\n            result[i-1] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long factorial = 1;\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            factorial *= i;\n            result[i-1] = factorial % 10000;\n        } else {\n            sum += i;\n            result[i-1] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long factorial = 1;\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            factorial *= i;\n            result[i-1] = factorial % 10000;\n        } else {\n            sum += i;\n            result[i-1] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long factorial = 1;\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            factorial *= i;\n            result[i-1] = factorial % 10000;\n        } else {\n            sum += i;\n            result[i-1] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\nstd::vector<int> func(int n) {\n    std::vector<int> result(n);\n    long long factorial = 1;\n    int sum = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        if (i % 2 == 0) {\n            factorial *= i;\n            result[i-1] = factorial % 10000;\n        } else {\n            sum += i;\n            result[i-1] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        // Convert number to string to check palindrome\n        std::string num_str = std::to_string(i);\n        \n        // Check if number is palindrome\n        bool is_palindrome = true;\n        int left = 0;\n        int right = num_str.length() - 1;\n        \n        while (left < right) {\n            if (num_str[left] != num_str[right]) {\n                is_palindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n        \n        // Count even or odd palindromes\n        if (is_palindrome) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        // Convert number to string to check palindrome\n        std::string numStr = std::to_string(i);\n        \n        // Check if number is palindrome\n        bool isPalindrome = true;\n        for (int j = 0; j < numStr.length() / 2; j++) {\n            if (numStr[j] != numStr[numStr.length() - 1 - j]) {\n                isPalindrome = false;\n                break;\n            }\n        }\n        \n        // If palindrome, count even or odd\n        if (isPalindrome) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0;\n    int oddCount = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        // Convert number to string to check palindrome\n        std::string numStr = std::to_string(i);\n        \n        // Check if number is palindrome\n        bool isPalindrome = true;\n        for (int j = 0; j < numStr.length() / 2; j++) {\n            if (numStr[j] != numStr[numStr.length() - 1 - j]) {\n                isPalindrome = false;\n                break;\n            }\n        }\n        \n        // If palindrome, increment even or odd count\n        if (isPalindrome) {\n            if (i % 2 == 0) {\n                evenCount++;\n            } else {\n                oddCount++;\n            }\n        }\n    }\n    \n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        // Convert number to string to check palindrome\n        std::string num_str = std::to_string(i);\n        \n        // Check if number is palindrome\n        bool is_palindrome = true;\n        int left = 0;\n        int right = num_str.length() - 1;\n        \n        while (left < right) {\n            if (num_str[left] != num_str[right]) {\n                is_palindrome = false;\n                break;\n            }\n            left++;\n            right--;\n        }\n        \n        // If palindrome, increment even or odd count\n        if (is_palindrome) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\nstd::vector<int> even_odd_palindrome(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    \n    for (int i = 1; i <= n; i++) {\n        // Convert number to string to check palindrome\n        std::string num_str = std::to_string(i);\n        \n        // Check if number is palindrome\n        bool is_palindrome = true;\n        for (int j = 0; j < num_str.length() / 2; j++) {\n            if (num_str[j] != num_str[num_str.length() - 1 - j]) {\n                is_palindrome = false;\n                break;\n            }\n        }\n        \n        // Count even and odd palindromes\n        if (is_palindrome) {\n            if (i % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    \n    for (int num : n) {\n        int digit_sum = 0;\n        int abs_num = std::abs(num);\n        \n        while (abs_num > 0) {\n            int digit = abs_num % 10;\n            \n            // If original number is negative, first digit becomes negative\n            if (num < 0 && digit_sum == 0) {\n                digit = -digit;\n            }\n            \n            digit_sum += digit;\n            abs_num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int abs_num = std::abs(num);\n        \n        while (abs_num > 0) {\n            int digit = abs_num % 10;\n            digit_sum += (num < 0 && digit_sum == 0) ? -digit : digit;\n            abs_num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int abs_num = std::abs(num);\n        \n        // Handle signed digits for negative numbers\n        if (num < 0) {\n            digit_sum -= (abs_num / std::pow(10, std::to_string(abs_num).length() - 1));\n        }\n        \n        // Sum the digits\n        while (abs_num > 0) {\n            digit_sum += abs_num % 10;\n            abs_num /= 10;\n        }\n        \n        // Increment count if digit sum is greater than 0\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int abs_num = std::abs(num);\n        \n        // Handle first digit with sign\n        if (num < 0) {\n            digit_sum -= (abs_num / std::pow(10, std::to_string(abs_num).length() - 1));\n        }\n        \n        // Sum remaining digits\n        while (abs_num > 0) {\n            digit_sum += abs_num % 10;\n            abs_num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int digit_sum = 0;\n        int abs_num = std::abs(num);\n        \n        while (abs_num > 0) {\n            int digit = abs_num % 10;\n            digit_sum += (num < 0 && digit_sum == 0) ? -digit : digit;\n            abs_num /= 10;\n        }\n        \n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    \n    // Empty vector is always sorted\n    if (n <= 1) return true;\n    \n    // Find the index where the sequence breaks\n    int break_point = -1;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            if (break_point != -1) return false;\n            break_point = i;\n        }\n    }\n    \n    // If no break point found, vector is already sorted\n    if (break_point == -1) return true;\n    \n    // Check if the sequence can be sorted by right shifts\n    return arr[break_point] <= arr[(break_point + 1) % n];\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    \n    // Empty vector is always sorted\n    if (n <= 1) return true;\n    \n    // Find the index where the sequence breaks\n    int break_index = -1;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            if (break_index != -1) return false;\n            break_index = i;\n        }\n    }\n    \n    // If no break found, vector is already sorted\n    if (break_index == -1) return true;\n    \n    // Check if right shift can make the vector sorted\n    return arr[(break_index + 1) % n] >= arr[0] && \n           arr[break_index] <= arr[(break_index + n - 1) % n];\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    // If vector is empty or has only one element, it's always sorted\n    if (arr.size() <= 1) return true;\n    \n    // Find the index where the array would be rotated\n    int rotationIndex = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > arr[(i + 1) % arr.size()]) {\n            rotationIndex = (i + 1) % arr.size();\n            break;\n        }\n    }\n    \n    // Check if the array is sorted after rotation\n    for (int i = 0; i < arr.size() - 1; i++) {\n        int current = (rotationIndex + i) % arr.size();\n        int next = (rotationIndex + i + 1) % arr.size();\n        \n        if (arr[current] > arr[next]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    \n    // If vector is empty or has only one element, return true\n    if (n <= 1) return true;\n    \n    // Find the index where the vector is \"broken\" (not in ascending order)\n    int break_point = -1;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            if (break_point != -1) return false;\n            break_point = i;\n        }\n    }\n    \n    // If no break point found, vector is already sorted\n    if (break_point == -1) return true;\n    \n    // Check if the break point allows sorting after right shifts\n    return arr[break_point] <= arr[(break_point + 1) % n];\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    \n    // Empty vector is always considered sorted\n    if (n <= 1) return true;\n    \n    // Find the index where the array is \"broken\"\n    int break_index = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i + 1) % n]) {\n            break_index = i;\n            break;\n        }\n    }\n    \n    // Check if the array can be sorted by right shifts\n    for (int i = 0; i < n; i++) {\n        bool is_sorted = true;\n        for (int j = 0; j < n - 1; j++) {\n            int curr = (break_index + j + 1) % n;\n            int next = (break_index + j + 2) % n;\n            \n            if (arr[curr] > arr[next]) {\n                is_sorted = false;\n                break;\n            }\n        }\n        \n        if (is_sorted) return true;\n        break_index = (break_index + 1) % n;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n\n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n\n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n\n    // If number of odd numbers in lst1 is less than or equal to even numbers in lst2\n    // we can exchange elements to make lst1 all even\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n    \n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n    \n    // If number of odd numbers in lst1 is less than or equal to \n    // number of even numbers in lst2, we can exchange\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n    \n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n    \n    // If number of odd numbers in lst1 is less than or equal to number of even numbers in lst2\n    // we can exchange elements to make lst1 all even\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n    \n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n    \n    // If number of odd numbers in lst1 is less than or equal to even numbers in lst2\n    // we can replace all odd numbers with even numbers\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    // Count odd numbers in lst1\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_count_lst1++;\n        }\n    }\n    \n    // Count even numbers in lst2\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_count_lst2++;\n        }\n    }\n    \n    // If number of odd numbers in lst1 is less than or equal to \n    // number of even numbers in lst2, we can exchange\n    return (odd_count_lst1 <= even_count_lst2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        \n        for (char digit : lst[i]) {\n            if ((digit - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        \n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                             \"n the str\" + std::to_string(odd_count) + \n                             \"ng \" + std::to_string(odd_count) + \" of the \" + \n                             std::to_string(odd_count) + \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        \n        for (char digit : lst[i]) {\n            if ((digit - '0') % 2 == 1) {\n                ++odd_count;\n            }\n        }\n        \n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                              \"n the str\" + std::to_string(odd_count) + \n                              \"ng \" + std::to_string(odd_count) + \" of the \" + \n                              std::to_string(odd_count) + \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        \n        for (char digit : lst[i]) {\n            if ((digit - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        \n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                              \"n the str\" + std::to_string(odd_count) + \n                              \"ng \" + std::to_string(odd_count) + \" of the \" + \n                              std::to_string(odd_count) + \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        \n        for (char digit : lst[i]) {\n            if ((digit - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        \n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                              \"n the str\" + std::to_string(odd_count) + \n                              \"ng \" + std::to_string(odd_count) + \" of the \" + \n                              std::to_string(odd_count) + \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        int odd_count = 0;\n        \n        for (char digit : lst[i]) {\n            if ((digit - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n        \n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) + \n                             \"n the str\" + std::to_string(odd_count) + \n                             \"ng \" + std::to_string(odd_count) + \" of the \" + \n                             std::to_string(odd_count) + \"nput.\";\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); i++) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); i++) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); i++) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); i++) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t minSum = nums[0];\n    int64_t currentSum = nums[0];\n    \n    for (size_t i = 1; i < nums.size(); i++) {\n        currentSum = std::min(nums[i], currentSum + nums[i]);\n        minSum = std::min(minSum, currentSum);\n    }\n    \n    return minSum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_water = 0;\n    \n    // Count total water units in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n    \n    // If no water, return 0\n    if (total_water == 0) return 0;\n    \n    // Calculate number of bucket lowerings needed\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_water = 0;\n    \n    // Count total water units in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n    \n    // If no water, return 0\n    if (total_water == 0) return 0;\n    \n    // Calculate number of bucket lowerings needed\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_water = 0;\n    \n    // Count total water units in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n    \n    // If no water, return 0\n    if (total_water == 0) return 0;\n    \n    // Calculate number of bucket lowerings needed\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_water = 0;\n    \n    // Count total water units in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n    \n    // If no water, return 0\n    if (total_water == 0) return 0;\n    \n    // Calculate number of bucket lowerings needed\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total_water = 0;\n    \n    // Count total water units in the grid\n    for (const auto& row : grid) {\n        for (int cell : row) {\n            total_water += cell;\n        }\n    }\n    \n    // If no water, return 0\n    if (total_water == 0) {\n        return 0;\n    }\n    \n    // Calculate number of bucket lowerings needed\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k && i < arr.size(); i++) {\n        if (abs(arr[i]) >= 10 && abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k && i < arr.size(); i++) {\n        if (abs(arr[i]) >= 10 && abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k && i < arr.size(); i++) {\n        if (abs(arr[i]) >= 10 && abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k && i < arr.size(); i++) {\n        if (abs(arr[i]) >= 10 && abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k && i < arr.size(); i++) {\n        if (abs(arr[i]) >= 10 && abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    std::unordered_map<int, int> count;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        count[lst[i]]++;\n        if (count[lst[i]] > 2) return false;\n        \n        if (i > 0 && lst[i] < lst[i-1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    std::unordered_map<int, int> count;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        count[lst[i]]++;\n        if (count[lst[i]] > 2) return false;\n        \n        if (i > 0 && lst[i] < lst[i-1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    std::unordered_map<int, int> count;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        count[lst[i]]++;\n        if (count[lst[i]] > 2) return false;\n        \n        if (i > 0 && lst[i] < lst[i-1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    std::unordered_map<int, int> count;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        count[lst[i]]++;\n        if (count[lst[i]] > 2) return false;\n        \n        if (i > 0 && lst[i] < lst[i-1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    std::unordered_map<int, int> count;\n    \n    for (int i = 0; i < lst.size(); i++) {\n        count[lst[i]]++;\n        if (count[lst[i]] > 2) return false;\n        \n        if (i > 0 && lst[i] < lst[i-1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sign_product = 1;\n    int total_magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        sign_product *= (num > 0) ? 1 : -1;\n        total_magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * total_magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sign_product = 1;\n    int total_magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        sign_product *= (num > 0) ? 1 : -1;\n        total_magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * total_magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sign_product = 1;\n    int magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        sign_product *= (num > 0) ? 1 : -1;\n        magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    int sign_product = 1;\n    int total_magnitude_sum = 0;\n    \n    for (int num : arr) {\n        if (num == 0) {\n            return 0;\n        }\n        \n        sign_product *= (num > 0) ? 1 : -1;\n        total_magnitude_sum += std::abs(num);\n    }\n    \n    return sign_product * total_magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n    std::vector<std::vector<std::vector<int>>> path(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize base case for paths of length 1\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            path[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    std::vector<std::pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Build paths of length 2 to k\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                std::vector<int> minPathValues;\n                for (auto& dir : dirs) {\n                    int ni = i + dir.first;\n                    int nj = j + dir.second;\n                    \n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        std::vector<int> candidate = path[ni][nj][len - 1];\n                        candidate.push_back(grid[i][j]);\n                        \n                        if (minPathValues.empty() || lexicographicallySmaller(candidate, minPathValues)) {\n                            minPathValues = candidate;\n                        }\n                    }\n                }\n                \n                path[i][j][len] = minPathValues;\n            }\n        }\n    }\n\n    // Find the minimum path of length k\n    std::vector<int> result;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (result.empty() || lexicographicallySmaller(path[i][j][k], result)) {\n                result = path[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n\nbool lexicographicallySmaller(const std::vector<int>& a, const std::vector<int>& b) {\n    for (size_t i = 0; i < std::min(a.size(), b.size()); i++) {\n        if (a[i] < b[i]) return true;\n        if (a[i] > b[i]) return false;\n    }\n    return a.size() < b.size();\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize base case for paths of length 1\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    std::vector<std::pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Dynamic programming to find minimum path\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                std::vector<int> minPathValues;\n                int minPathValue = INT_MAX;\n\n                for (auto& dir : dirs) {\n                    int ni = i + dir.first;\n                    int nj = j + dir.second;\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        std::vector<int> tempPath = paths[ni][nj][len - 1];\n                        tempPath.push_back(grid[i][j]);\n\n                        if (tempPath < minPathValues || minPathValues.empty()) {\n                            minPathValues = tempPath;\n                        }\n                    }\n                }\n\n                paths[i][j][len] = minPathValues;\n            }\n        }\n    }\n\n    // Find the minimum path of length k\n    std::vector<int> result;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (result.empty() || paths[i][j][k] < result) {\n                result = paths[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    std::vector<std::vector<std::vector<std::vector<int>>>> dp(n, \n        std::vector<std::vector<std::vector<int>>>(n, \n            std::vector<std::vector<int>>(k + 1, \n                std::vector<int>())));\n    \n    // Initialize first cell paths\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = {grid[i][j]};\n        }\n    }\n    \n    // Directions: right, down, left, up\n    std::vector<std::pair<int, int>> dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n    \n    // Build paths of length 2 to k\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (auto& dir : dirs) {\n                    int ni = i + dir.first;\n                    int nj = j + dir.second;\n                    \n                    if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                        if (!dp[i][j][len-1].empty()) {\n                            std::vector<int> newPath = dp[i][j][len-1];\n                            newPath.push_back(grid[ni][nj]);\n                            \n                            if (dp[ni][nj][len].empty() || \n                                newPath < dp[ni][nj][len]) {\n                                dp[ni][nj][len] = newPath;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Find minimum path of length k\n    std::vector<int> minPathResult;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!dp[i][j][k].empty()) {\n                if (minPathResult.empty() || \n                    dp[i][j][k] < minPathResult) {\n                    minPathResult = dp[i][j][k];\n                }\n            }\n        }\n    }\n    \n    return minPathResult;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize base case for paths of length 1\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    std::vector<std::pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Dynamic programming to find minimum path\n    for (int length = 2; length <= k; length++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                std::vector<int> minPathValues;\n                int minPathValue = INT_MAX;\n\n                for (auto& dir : dirs) {\n                    int ni = i + dir.first;\n                    int nj = j + dir.second;\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        std::vector<int> candidatePath = paths[ni][nj][length - 1];\n                        candidatePath.push_back(grid[i][j]);\n\n                        if (candidatePath < minPathValues || minPathValues.empty()) {\n                            minPathValues = candidatePath;\n                        }\n                    }\n                }\n\n                paths[i][j][length] = minPathValues;\n            }\n        }\n    }\n\n    // Find the minimum path of length k\n    std::vector<int> result;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (result.empty() || paths[i][j][k] < result) {\n                result = paths[i][j][k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    std::vector<std::vector<std::vector<int>>> dp(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n    std::vector<std::vector<std::vector<int>>> paths(N, std::vector<std::vector<int>>(N, std::vector<int>(k + 1)));\n\n    // Initialize base case for paths of length 1\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            dp[i][j][1] = grid[i][j];\n            paths[i][j][1] = {grid[i][j]};\n        }\n    }\n\n    // Directions: up, down, left, right\n    std::vector<std::pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Build paths of length 2 to k\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                std::vector<int> minPathValues;\n                int minPathValue = INT_MAX;\n\n                for (auto& dir : dirs) {\n                    int ni = i + dir.first;\n                    int nj = j + dir.second;\n\n                    if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                        int currentPathValue = dp[ni][nj][len - 1] * 10 + grid[i][j];\n                        if (currentPathValue < minPathValue) {\n                            minPathValue = currentPathValue;\n                            minPathValues = paths[ni][nj][len - 1];\n                            minPathValues.push_back(grid[i][j]);\n                        }\n                    }\n                }\n\n                dp[i][j][len] = minPathValue;\n                paths[i][j][len] = minPathValues;\n            }\n        }\n    }\n\n    // Find the minimum path of length k\n    std::vector<int> result;\n    int minValue = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (paths[i][j][k].size() == k) {\n                if (paths[i][j][k] < result || result.empty()) {\n                    result = paths[i][j][k];\n                }\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOddDigit = false;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        \n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        \n        n /= 10;\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOddDigit = false;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        \n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        \n        n /= 10;\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOddDigit = false;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        \n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        \n        n /= 10;\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOddDigit = false;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        \n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        \n        n /= 10;\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool hasOddDigit = false;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        \n        if (digit % 2 != 0) {\n            product *= digit;\n            hasOddDigit = true;\n        }\n        \n        n /= 10;\n    }\n    \n    return hasOddDigit ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t result = 0;\n    for(float num : lst) {\n        int ceiling = std::ceil(num);\n        result += ceiling * ceiling;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    for (float num : lst) {\n        int ceiling = std::ceil(num);\n        result += ceiling * ceiling;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    for (float num : lst) {\n        int ceiling = std::ceil(num);\n        result += ceiling * ceiling;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t result = 0;\n    for(float num : lst) {\n        int ceiling = std::ceil(num);\n        result += ceiling * ceiling;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    for (float num : lst) {\n        int ceiling = std::ceil(num);\n        result += ceiling * ceiling;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; i--) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; i--) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; i--) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; i--) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; i--) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = std::max(largest_negative, num);\n            has_negative = true;\n        }\n        \n        if (num > 0) {\n            smallest_positive = std::min(smallest_positive, num);\n            has_positive = true;\n        }\n    }\n    \n    return {\n        has_negative ? largest_negative : 0,\n        has_positive ? smallest_positive : 0\n    };\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = std::max(largest_negative, num);\n            has_negative = true;\n        }\n        if (num > 0) {\n            smallest_positive = std::min(smallest_positive, num);\n            has_positive = true;\n        }\n    }\n    \n    return {\n        has_negative ? largest_negative : 0,\n        has_positive ? smallest_positive : 0\n    };\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = std::max(largest_negative, num);\n            has_negative = true;\n        }\n        if (num > 0) {\n            smallest_positive = std::min(smallest_positive, num);\n            has_positive = true;\n        }\n    }\n    \n    return {\n        has_negative ? largest_negative : 0,\n        has_positive ? smallest_positive : 0\n    };\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = std::max(largest_negative, num);\n            has_negative = true;\n        }\n        if (num > 0) {\n            smallest_positive = std::min(smallest_positive, num);\n            has_positive = true;\n        }\n    }\n    \n    return {\n        has_negative ? largest_negative : 0,\n        has_positive ? smallest_positive : 0\n    };\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = INT_MIN;\n    int smallest_positive = INT_MAX;\n    bool has_negative = false;\n    bool has_positive = false;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            largest_negative = std::max(largest_negative, num);\n            has_negative = true;\n        }\n        if (num > 0) {\n            smallest_positive = std::min(smallest_positive, num);\n            has_positive = true;\n        }\n    }\n    \n    return {\n        has_negative ? largest_negative : 0,\n        has_positive ? smallest_positive : 0\n    };\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    uint64_t factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        factorial *= i;\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    uint64_t factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        factorial *= i;\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    uint64_t factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        factorial *= i;\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    uint64_t factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        factorial *= i;\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\nuint64_t special_factorial(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    uint64_t factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        factorial *= i;\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    int total_sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            total_sum += lst[i];\n        }\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    int total_sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            total_sum += lst[i];\n        }\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\nint sum_squares(const std::vector<int> & lst) {\n    int total_sum = 0;\n    \n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total_sum += lst[i] * lst[i];\n        } else if (i % 4 == 0 && i % 3 != 0) {\n            total_sum += lst[i] * lst[i] * lst[i];\n        } else {\n            total_sum += lst[i];\n        }\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = abs(num);\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            \n            int lastDigit = abs(num) % 10;\n            \n            if ((firstDigit % 2 == 1) && (lastDigit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            // Convert number to absolute value to handle negative numbers\n            int absNum = std::abs(num);\n            \n            // Get first and last digits\n            int firstDigit = std::to_string(absNum)[0] - '0';\n            int lastDigit = absNum % 10;\n            \n            // Check if first and last digits are odd\n            bool isFirstDigitOdd = (firstDigit % 2 == 1);\n            bool isLastDigitOdd = (lastDigit % 2 == 1);\n            \n            // Increment count if conditions are met\n            if (isFirstDigitOdd && isLastDigitOdd) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            int absNum = std::abs(num);\n            int firstDigit = std::to_string(absNum)[0] - '0';\n            int lastDigit = absNum % 10;\n            \n            if ((firstDigit % 2 == 1) && (lastDigit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = abs(num);\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            \n            int lastDigit = abs(num) % 10;\n            \n            if ((firstDigit % 2 == 1) && (lastDigit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    \n    for (int num : nums) {\n        if (num > 10) {\n            int firstDigit = abs(num);\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            \n            int lastDigit = abs(num) % 10;\n            \n            if ((firstDigit % 2 == 1) && (lastDigit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; ++i) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; ++i) {\n        for (uint64_t j = i + 1; j < n - 1; ++j) {\n            for (uint64_t k = j + 1; k < n; ++k) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\nuint64_t get_max_triples(uint64_t n) {\n    vector<uint64_t> a(n);\n    for (uint64_t i = 1; i <= n; i++) {\n        a[i-1] = i * i - i + 1;\n    }\n    \n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n - 2; i++) {\n        for (uint64_t j = i + 1; j < n - 1; j++) {\n            for (uint64_t k = j + 1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```cpp\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    \n    for (float num : lst) {\n        // Check if number is a positive integer and odd\n        if (num > 0 && std::floor(num) == num && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(std::pow(num, 2));\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (std::floor(num) == num && num > 0 && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(std::pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (std::floor(num) == num && num > 0 && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (std::floor(num) == num && num > 0 && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<uint64_t>(std::pow(num, 2));\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (std::floor(num) == num && num > 0 && static_cast<int>(num) % 2 == 1) {\n            sum += static_cast<uint64_t>(num * num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}

{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        uint64x2_t src_vec = vld1q_u64((uint64_t*)&src[i]);\n        uint64x2_t dst_vec = vld1q_u64((uint64_t*)&dst[i]);\n        \n        uint64x2_t mask_vec;\n        mask_vec = vsetq_lane_u64(mask[i] ? UINT64_MAX : 0, mask_vec, 0);\n        mask_vec = vsetq_lane_u64(mask[i+1] ? UINT64_MAX : 0, mask_vec, 1);\n        \n        uint64x2_t result = vbslq_u64(mask_vec, src_vec, dst_vec);\n        vst1q_u64((uint64_t*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        uint64x2_t src_vec = vld1q_u64((uint64_t*)&src[i]);\n        uint64x2_t dst_vec = vld1q_u64((uint64_t*)&dst[i]);\n        \n        uint64x2_t mask_vec;\n        mask_vec = vsetq_lane_u64(mask[i] ? UINT64_MAX : 0, mask_vec, 0);\n        mask_vec = vsetq_lane_u64(mask[i+1] ? UINT64_MAX : 0, mask_vec, 1);\n        \n        uint64x2_t result = vbslq_u64(mask_vec, src_vec, dst_vec);\n        vst1q_u64((uint64_t*)&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        uint64x2_t src_vec = vld1q_u64((uint64_t*)&src[i]);\n        uint64x2_t dst_vec = vld1q_u64((uint64_t*)&dst[i]);\n        \n        uint64x2_t mask_vec;\n        mask_vec = vsetq_lane_u64(mask[i] ? UINT64_MAX : 0, mask_vec, 0);\n        mask_vec = vsetq_lane_u64(mask[i+1] ? UINT64_MAX : 0, mask_vec, 1);\n        \n        uint64x2_t result = vbslq_u64(mask_vec, src_vec, dst_vec);\n        vst1q_u64((uint64_t*)&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        uint64x2_t src_vec = vld1q_u64((uint64_t*)&src[i]);\n        uint64x2_t dst_vec = vld1q_u64((uint64_t*)&dst[i]);\n        \n        uint64x2_t mask_vec;\n        mask_vec = vsetq_lane_u64(mask[i] ? UINT64_MAX : 0, mask_vec, 0);\n        mask_vec = vsetq_lane_u64(mask[i+1] ? UINT64_MAX : 0, mask_vec, 1);\n        \n        uint64x2_t result = vbslq_u64(mask_vec, src_vec, dst_vec);\n        vst1q_u64((uint64_t*)&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        uint64x2_t src_vec = vld1q_u64((uint64_t*)&src[i]);\n        uint64x2_t dst_vec = vld1q_u64((uint64_t*)&dst[i]);\n        \n        uint64x2_t mask_vec;\n        mask_vec = vsetq_lane_u64(mask[i] ? UINT64_MAX : 0, mask_vec, 0);\n        mask_vec = vsetq_lane_u64(mask[i+1] ? UINT64_MAX : 0, mask_vec, 1);\n        \n        uint64x2_t result = vbslq_u64(mask_vec, src_vec, dst_vec);\n        vst1q_u64((uint64_t*)&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        int32x4_t mul = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(mul, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        int32x4_t tmp2 = vshlq_n_s32(mul, 3);\n        \n        // Calculate tmp1 * tmp2\n        int32x4_t tmp1_mul_tmp2 = vmulq_s32(tmp1, tmp2);\n        \n        // Calculate element * scale + tmp1 * tmp2\n        int32x4_t sum = vaddq_s32(mul, tmp1_mul_tmp2);\n        \n        // Divide by 7\n        int32x4_t div7 = vdupq_n_s32(7);\n        int32x4_t result = vdivq_s32(sum, div7);\n        \n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        int32x4_t mul = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(mul, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        int32x4_t tmp2 = vshlq_n_s32(mul, 3);\n        \n        // Calculate tmp1 * tmp2\n        int32x4_t tmp1_mul_tmp2 = vmulq_s32(tmp1, tmp2);\n        \n        // Calculate element * scale + tmp1 * tmp2\n        int32x4_t sum = vaddq_s32(mul, tmp1_mul_tmp2);\n        \n        // Divide by 7\n        float32x4_t sum_f = vcvtq_f32_s32(sum);\n        float32x4_t div_f = vmulq_n_f32(sum_f, 1.0f/7.0f);\n        int32x4_t result = vcvtq_s32_f32(div_f);\n        \n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = length & ~3; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        int32x4_t mul = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(mul, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        int32x4_t tmp2 = vshlq_n_s32(mul, 3);\n        \n        // Calculate tmp1 * tmp2\n        int32x4_t tmp1_mul_tmp2 = vmulq_s32(tmp1, tmp2);\n        \n        // Calculate element * scale + tmp1 * tmp2\n        int32x4_t sum = vaddq_s32(mul, tmp1_mul_tmp2);\n        \n        // Divide by 7 using multiplication by magic number\n        int32x4_t magic = vdupq_n_s32(0x24924925);\n        int32x4_t result = vqdmulhq_s32(sum, magic);\n        result = vshrq_n_s32(result, 2);\n        \n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = ((src[i] * scale) + (tmp1 * tmp2)) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        int32x4_t mul = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(mul, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        int32x4_t tmp2 = vshlq_n_s32(mul, 3);\n        \n        // Calculate tmp1 * tmp2\n        int32x4_t tmp1_mul_tmp2 = vmulq_s32(tmp1, tmp2);\n        \n        // Calculate element * scale + tmp1 * tmp2\n        int32x4_t sum = vaddq_s32(mul, tmp1_mul_tmp2);\n        \n        // Divide by 7 using multiplication by magic number\n        int32x4_t magic = vdupq_n_s32(0x24924925);\n        int32x4_t result = vmulq_s32(sum, magic);\n        result = vshrq_n_s32(result, 34);\n        \n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = length & ~3; i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = ((src[i] * scale) + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    \n    for (size_t i = 0; i < length - 3; i += 4) {\n        int32x4_t src_vec = vld1q_s32(&src[i]);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        int32x4_t mul = vmulq_s32(src_vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(mul, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        int32x4_t tmp2 = vshlq_n_s32(mul, 3);\n        \n        // Calculate tmp1 * tmp2\n        int32x4_t tmp1_mul_tmp2 = vmulq_s32(tmp1, tmp2);\n        \n        // Calculate element * scale + tmp1 * tmp2\n        int32x4_t sum = vaddq_s32(mul, tmp1_mul_tmp2);\n        \n        // Divide by 7 using multiplication by magic number\n        int32x4_t magic = vdupq_n_s32(0x24924925);\n        int32x4_t result = vqdmulhq_s32(sum, magic);\n        result = vshrq_n_s32(result, 2);\n        \n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = length - (length % 4); i < length; i++) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = ((src[i] * scale) + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    size_t step = 2;\n    size_t rows_vec = rows - (rows % step);\n    \n    for (i = 0; i < rows_vec; i += step) {\n        float64x2_t v = vld1q_f64(&src[i * cols + stride]);\n        vst1q_f64(&dst[i], v);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vec_size = 2;\n    size_t vec_rows = rows / vec_size;\n    size_t remain = rows % vec_size;\n    \n    for (size_t i = 0; i < vec_rows; i++) {\n        size_t idx1 = (i * 2) * cols + stride;\n        size_t idx2 = (i * 2 + 1) * cols + stride;\n        \n        float64x2_t vec = {src[idx1], src[idx2]};\n        vst1q_f64(&dst[i * 2], vec);\n    }\n\n    size_t offset = vec_rows * vec_size;\n    for (size_t i = 0; i < remain; i++) {\n        dst[offset + i] = src[(offset + i) * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    const size_t step = 2;\n    size_t i;\n    \n    for (i = 0; i + step <= rows; i += step) {\n        float64x2_t v = vld1q_f64(&src[i * cols + stride]);\n        vst1q_f64(&dst[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vec_size = 2;\n    size_t vec_rows = rows / vec_size;\n    size_t remaining = rows % vec_size;\n\n    for (size_t i = 0; i < vec_rows; i++) {\n        float64x2_t vec;\n        size_t idx1 = (i * 2) * cols + stride;\n        size_t idx2 = (i * 2 + 1) * cols + stride;\n        \n        vec = vsetq_lane_f64(src[idx1], vec, 0);\n        vec = vsetq_lane_f64(src[idx2], vec, 1);\n        \n        vst1q_f64(&dst[i * 2], vec);\n    }\n\n    size_t offset = vec_rows * vec_size;\n    for (size_t i = 0; i < remaining; i++) {\n        dst[offset + i] = src[(offset + i) * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vec_size = 2;\n    size_t vec_rows = rows / vec_size;\n    size_t remaining = rows % vec_size;\n    \n    for (size_t i = 0; i < vec_rows; i++) {\n        float64x2_t vec;\n        size_t idx1 = (i * 2) * cols + stride;\n        size_t idx2 = (i * 2 + 1) * cols + stride;\n        \n        float64x2_t indices = {src[idx1], src[idx2]};\n        vst1q_f64(&dst[i * 2], indices);\n    }\n\n    size_t offset = vec_rows * vec_size;\n    for (size_t i = 0; i < remaining; i++) {\n        dst[offset + i] = src[(offset + i) * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather operation - load from scattered addresses\n        float32x4_t gathered;\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values sequentially\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 sequential values\n        float32x4_t values = vld1q_f32(&src[i]);\n        \n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Scatter - store to scattered addresses\n        dst[indices[i]] = values[0];\n        dst[indices[i+1]] = values[1];\n        dst[indices[i+2]] = values[2];\n        dst[indices[i+3]] = values[3];\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i <= length - 4; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather operation - load values from src using indices\n        float32x4_t gathered;\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values to dst\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i <= length - 4; i += 4) {\n        // Load 4 values from src\n        float32x4_t values = vld1q_f32(&src[i]);\n        \n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Scatter values to dst using indices\n        dst[indices[i]] = vgetq_lane_f32(values, 0);\n        dst[indices[i+1]] = vgetq_lane_f32(values, 1);\n        dst[indices[i+2]] = vgetq_lane_f32(values, 2); \n        dst[indices[i+3]] = vgetq_lane_f32(values, 3);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather operation - load values from src using indices\n        float32x4_t gathered;\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values to dst\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 values from src\n        float32x4_t values = vld1q_f32(&src[i]);\n        \n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Scatter values to dst using indices\n        dst[indices[i]] = vgetq_lane_f32(values, 0);\n        dst[indices[i+1]] = vgetq_lane_f32(values, 1);\n        dst[indices[i+2]] = vgetq_lane_f32(values, 2); \n        dst[indices[i+3]] = vgetq_lane_f32(values, 3);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather operation - load values from src using indices\n        float32x4_t gathered;\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values to dst\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 values from src\n        float32x4_t values = vld1q_f32(&src[i]);\n        \n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Scatter values to dst using indices\n        dst[indices[i]] = vgetq_lane_f32(values, 0);\n        dst[indices[i+1]] = vgetq_lane_f32(values, 1);\n        dst[indices[i+2]] = vgetq_lane_f32(values, 2); \n        dst[indices[i+3]] = vgetq_lane_f32(values, 3);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Gather operation - load values from src using indices\n        float32x4_t gathered;\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values to dst\n        vst1q_f32(&dst[i], gathered);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 values from src\n        float32x4_t values = vld1q_f32(&src[i]);\n        \n        // Load 4 indices\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        \n        // Scatter values to dst using indices\n        dst[indices[i]] = vgetq_lane_f32(values, 0);\n        dst[indices[i+1]] = vgetq_lane_f32(values, 1);\n        dst[indices[i+2]] = vgetq_lane_f32(values, 2); \n        dst[indices[i+3]] = vgetq_lane_f32(values, 3);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end && (end - start) >= 7) {\n        int16x8_t v1 = vld1q_s16(&arr[start]);\n        int16x8_t v2 = vld1q_s16(&arr[end-7]);\n        \n        int16x8_t rev = vrev64q_s16(v2);\n        rev = vcombine_s16(vget_high_s16(rev), vget_low_s16(rev));\n        \n        vst1q_s16(&arr[start], rev);\n        vst1q_s16(&arr[end-7], vrev64q_s16(vcombine_s16(vget_high_s16(v1), vget_low_s16(v1))));\n        \n        start += 8;\n        end -= 8;\n    }\n    \n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n    \n    // Process 8 elements at a time using NEON\n    while (left + 7 < right - 7) {\n        int16x8_t left_vec = vld1q_s16(&arr[left]);\n        int16x8_t right_vec = vld1q_s16(&arr[right-7]);\n        \n        // Reverse the vectors\n        int16x8_t rev_left = vrev64q_s16(left_vec);\n        int16x8_t rev_right = vrev64q_s16(right_vec);\n        rev_left = vcombine_s16(vget_high_s16(rev_left), vget_low_s16(rev_left));\n        rev_right = vcombine_s16(vget_high_s16(rev_right), vget_low_s16(rev_right));\n        \n        // Store reversed vectors\n        vst1q_s16(&arr[left], rev_right);\n        vst1q_s16(&arr[right-7], rev_left);\n        \n        left += 8;\n        right -= 8;\n    }\n    \n    // Handle remaining elements\n    while (left < right) {\n        int16_t temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end && (end - start) >= 7) {\n        int16x8_t v1 = vld1q_s16(&arr[start]);\n        int16x8_t v2 = vld1q_s16(&arr[end-7]);\n        \n        int16x8_t rev1 = vrev64q_s16(v2);\n        int16x8_t rev2 = vrev64q_s16(v1);\n        \n        int16x4_t low1 = vget_low_s16(rev1);\n        int16x4_t high1 = vget_high_s16(rev1);\n        int16x4_t low2 = vget_low_s16(rev2);\n        int16x4_t high2 = vget_high_s16(rev2);\n        \n        int16x8_t final1 = vcombine_s16(high1, low1);\n        int16x8_t final2 = vcombine_s16(high2, low2);\n        \n        vst1q_s16(&arr[start], final1);\n        vst1q_s16(&arr[end-7], final2);\n        \n        start += 8;\n        end -= 8;\n    }\n    \n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n    \n    // Process 8 elements at a time using NEON\n    while (left + 7 < right - 7) {\n        int16x8_t left_vec = vld1q_s16(&arr[left]);\n        int16x8_t right_vec = vld1q_s16(&arr[right-7]);\n        \n        // Reverse the vectors\n        int16x8_t rev_left = vrev64q_s16(left_vec);\n        int16x8_t rev_right = vrev64q_s16(right_vec);\n        rev_left = vcombine_s16(vget_high_s16(rev_left), vget_low_s16(rev_left));\n        rev_right = vcombine_s16(vget_high_s16(rev_right), vget_low_s16(rev_right));\n        \n        // Store reversed vectors\n        vst1q_s16(&arr[left], rev_right);\n        vst1q_s16(&arr[right-7], rev_left);\n        \n        left += 8;\n        right -= 8;\n    }\n    \n    // Handle remaining elements\n    while (left < right) {\n        int16_t temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n    \n    // Process 8 elements at a time using NEON\n    while (left + 7 < right - 7) {\n        int16x8_t left_vec = vld1q_s16(&arr[left]);\n        int16x8_t right_vec = vld1q_s16(&arr[right-7]);\n        \n        // Reverse the vectors\n        int16x8_t rev_left = vrev64q_s16(left_vec);\n        int16x8_t rev_right = vrev64q_s16(right_vec);\n        rev_left = vcombine_s16(vget_high_s16(rev_left), vget_low_s16(rev_left));\n        rev_right = vcombine_s16(vget_high_s16(rev_right), vget_low_s16(rev_right));\n        \n        // Store reversed vectors\n        vst1q_s16(&arr[left], rev_right);\n        vst1q_s16(&arr[right-7], rev_left);\n        \n        left += 8;\n        right -= 8;\n    }\n    \n    // Handle remaining elements\n    while (left < right) {\n        int16_t temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t offset = slice_idx * slice_size;\n    const uint8_t *src = tensor + offset;\n    \n    // Process 16 elements at a time using NEON\n    size_t vec_size = slice_size / 16;\n    size_t remaining = slice_size % 16;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        uint8x16_t v = vld1q_u8(src + i * 16);\n        vst1q_u8(slice + i * 16, v);\n    }\n    \n    // Handle remaining elements\n    size_t vec_offset = vec_size * 16;\n    for (size_t i = 0; i < remaining; i++) {\n        slice[vec_offset + i] = src[vec_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t offset = slice_idx * slice_size;\n    const uint8_t *src = tensor + offset;\n    \n    // Process 16 elements at a time using NEON\n    size_t vec_size = slice_size / 16;\n    size_t remaining = slice_size % 16;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        uint8x16_t vec = vld1q_u8(src + i * 16);\n        vst1q_u8(slice + i * 16, vec);\n    }\n    \n    // Handle remaining elements\n    size_t vec_offset = vec_size * 16;\n    for (size_t i = 0; i < remaining; i++) {\n        slice[vec_offset + i] = src[vec_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t offset = slice_idx * slice_size;\n    const uint8_t* src = tensor + offset;\n    \n    // Process 16 elements at a time using NEON\n    size_t vec_size = slice_size / 16;\n    size_t remaining = slice_size % 16;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        uint8x16_t v = vld1q_u8(src + i * 16);\n        vst1q_u8(slice + i * 16, v);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size * 16; i < slice_size; i++) {\n        slice[i] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t offset = slice_idx * slice_size;\n    const uint8_t *src = tensor + offset;\n    \n    // Process 16 elements at a time using NEON\n    size_t vec_size = slice_size / 16;\n    size_t remaining = slice_size % 16;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        uint8x16_t v = vld1q_u8(src + i * 16);\n        vst1q_u8(slice + i * 16, v);\n    }\n    \n    // Handle remaining elements\n    size_t vec_offset = vec_size * 16;\n    if (remaining >= 8) {\n        uint8x8_t v = vld1_u8(src + vec_offset);\n        vst1_u8(slice + vec_offset, v);\n        vec_offset += 8;\n        remaining -= 8;\n    }\n    \n    // Copy any leftover elements\n    for (size_t i = 0; i < remaining; i++) {\n        slice[vec_offset + i] = src[vec_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t offset = slice_idx * slice_size;\n    const uint8_t *src = tensor + offset;\n    \n    // Process 16 elements at a time using Neon\n    size_t vec_size = slice_size / 16;\n    size_t remaining = slice_size % 16;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        uint8x16_t v = vld1q_u8(src + i * 16);\n        vst1q_u8(slice + i * 16, v);\n    }\n    \n    // Handle remaining elements\n    size_t vec_offset = vec_size * 16;\n    for (size_t i = 0; i < remaining; i++) {\n        slice[vec_offset + i] = src[vec_offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 4) {\n                for (size_t bj = j; bj < max_j; bj += 4) {\n                    if (bi + 4 <= max_i && bj + 4 <= max_j) {\n                        // Load 4x4 block\n                        int16x4_t row0 = vld1_s16(&src[bi * cols + bj]);\n                        int16x4_t row1 = vld1_s16(&src[(bi + 1) * cols + bj]);\n                        int16x4_t row2 = vld1_s16(&src[(bi + 2) * cols + bj]);\n                        int16x4_t row3 = vld1_s16(&src[(bi + 3) * cols + bj]);\n\n                        // Transpose 4x4 block using NEON intrinsics\n                        int16x4x2_t zip0 = vzip_s16(row0, row1);\n                        int16x4x2_t zip1 = vzip_s16(row2, row3);\n\n                        int16x4x2_t result0 = vzip_s16(zip0.val[0], zip1.val[0]);\n                        int16x4x2_t result1 = vzip_s16(zip0.val[1], zip1.val[1]);\n\n                        // Store transposed block\n                        vst1_s16(&dst[bj * rows + bi], result0.val[0]);\n                        vst1_s16(&dst[(bj + 1) * rows + bi], result0.val[1]);\n                        vst1_s16(&dst[(bj + 2) * rows + bi], result1.val[0]);\n                        vst1_s16(&dst[(bj + 3) * rows + bi], result1.val[1]);\n                    } else {\n                        // Handle remaining elements\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 4) {\n                for (size_t bj = j; bj < max_j; bj += 4) {\n                    if (bi + 4 <= max_i && bj + 4 <= max_j) {\n                        int16x4_t r0 = vld1_s16(&src[bi * cols + bj]);\n                        int16x4_t r1 = vld1_s16(&src[(bi + 1) * cols + bj]);\n                        int16x4_t r2 = vld1_s16(&src[(bi + 2) * cols + bj]);\n                        int16x4_t r3 = vld1_s16(&src[(bi + 3) * cols + bj]);\n\n                        int16x4x2_t zip1 = vzip_s16(r0, r1);\n                        int16x4x2_t zip2 = vzip_s16(r2, r3);\n\n                        int16x4x2_t res1 = vzip_s16(zip1.val[0], zip2.val[0]);\n                        int16x4x2_t res2 = vzip_s16(zip1.val[1], zip2.val[1]);\n\n                        vst1_s16(&dst[bj * rows + bi], res1.val[0]);\n                        vst1_s16(&dst[(bj + 1) * rows + bi], res1.val[1]);\n                        vst1_s16(&dst[(bj + 2) * rows + bi], res2.val[0]);\n                        vst1_s16(&dst[(bj + 3) * rows + bi], res2.val[1]);\n                    } else {\n                        for (size_t ii = bi; ii < min(bi + 4, max_i); ii++) {\n                            for (size_t jj = bj; jj < min(bj + 4, max_j); jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 4) {\n                for (size_t bj = j; bj < max_j; bj += 4) {\n                    if (bi + 4 <= max_i && bj + 4 <= max_j) {\n                        int16x4_t row0 = vld1_s16(&src[bi * cols + bj]);\n                        int16x4_t row1 = vld1_s16(&src[(bi + 1) * cols + bj]);\n                        int16x4_t row2 = vld1_s16(&src[(bi + 2) * cols + bj]);\n                        int16x4_t row3 = vld1_s16(&src[(bi + 3) * cols + bj]);\n\n                        int16x4x2_t zip1 = vzip_s16(row0, row1);\n                        int16x4x2_t zip2 = vzip_s16(row2, row3);\n\n                        int16x4x2_t result1 = vzip_s16(zip1.val[0], zip2.val[0]);\n                        int16x4x2_t result2 = vzip_s16(zip1.val[1], zip2.val[1]);\n\n                        vst1_s16(&dst[bj * rows + bi], result1.val[0]);\n                        vst1_s16(&dst[(bj + 1) * rows + bi], result1.val[1]);\n                        vst1_s16(&dst[(bj + 2) * rows + bi], result2.val[0]);\n                        vst1_s16(&dst[(bj + 3) * rows + bi], result2.val[1]);\n                    } else {\n                        for (size_t ii = bi; ii < min(bi + 4, max_i); ii++) {\n                            for (size_t jj = bj; jj < min(bj + 4, max_j); jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 4) {\n                for (size_t bj = j; bj < max_j; bj += 4) {\n                    if (bi + 4 <= max_i && bj + 4 <= max_j) {\n                        // Load 4x4 block\n                        int16x4_t row0 = vld1_s16(&src[bi * cols + bj]);\n                        int16x4_t row1 = vld1_s16(&src[(bi + 1) * cols + bj]);\n                        int16x4_t row2 = vld1_s16(&src[(bi + 2) * cols + bj]);\n                        int16x4_t row3 = vld1_s16(&src[(bi + 3) * cols + bj]);\n\n                        // Transpose 4x4 block using NEON intrinsics\n                        int16x4x2_t zip1 = vzip_s16(row0, row1);\n                        int16x4x2_t zip2 = vzip_s16(row2, row3);\n\n                        int16x4x2_t result1 = vzip_s16(zip1.val[0], zip2.val[0]);\n                        int16x4x2_t result2 = vzip_s16(zip1.val[1], zip2.val[1]);\n\n                        // Store transposed block\n                        vst1_s16(&dst[bj * rows + bi], result1.val[0]);\n                        vst1_s16(&dst[(bj + 1) * rows + bi], result1.val[1]);\n                        vst1_s16(&dst[(bj + 2) * rows + bi], result2.val[0]);\n                        vst1_s16(&dst[(bj + 3) * rows + bi], result2.val[1]);\n                    } else {\n                        // Handle remaining elements\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 4) {\n                for (size_t bj = j; bj < max_j; bj += 4) {\n                    if (bi + 4 <= max_i && bj + 4 <= max_j) {\n                        int16x4_t row0 = vld1_s16(&src[bi * cols + bj]);\n                        int16x4_t row1 = vld1_s16(&src[(bi + 1) * cols + bj]);\n                        int16x4_t row2 = vld1_s16(&src[(bi + 2) * cols + bj]);\n                        int16x4_t row3 = vld1_s16(&src[(bi + 3) * cols + bj]);\n\n                        int16x4x2_t zip1 = vzip_s16(row0, row1);\n                        int16x4x2_t zip2 = vzip_s16(row2, row3);\n\n                        int16x4x2_t res1 = vzip_s16(zip1.val[0], zip2.val[0]);\n                        int16x4x2_t res2 = vzip_s16(zip1.val[1], zip2.val[1]);\n\n                        vst1_s16(&dst[bj * rows + bi], res1.val[0]);\n                        vst1_s16(&dst[(bj + 1) * rows + bi], res1.val[1]);\n                        vst1_s16(&dst[(bj + 2) * rows + bi], res2.val[0]);\n                        vst1_s16(&dst[(bj + 3) * rows + bi], res2.val[1]);\n                    } else {\n                        for (size_t ii = bi; ii < min(bi + 4, max_i); ii++) {\n                            for (size_t jj = bj; jj < min(bj + 4, max_j); jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t dim_sq = dim * dim;\n    size_t i = 0;\n    \n    // Process 4 diagonal elements at a time\n    for (; i + 3 < dim; i += 4) {\n        size_t idx0 = i * dim_sq + i * dim + i;\n        size_t idx1 = (i + 1) * dim_sq + (i + 1) * dim + (i + 1);\n        size_t idx2 = (i + 2) * dim_sq + (i + 2) * dim + (i + 2);\n        size_t idx3 = (i + 3) * dim_sq + (i + 3) * dim + (i + 3);\n        \n        float32x4_t diag = {array[idx0], array[idx1], array[idx2], array[idx3]};\n        sum_vec = vaddq_f32(sum_vec, diag);\n    }\n    \n    // Handle remaining elements\n    float sum = vaddvq_f32(sum_vec);\n    for (; i < dim; i++) {\n        size_t idx = i * dim_sq + i * dim + i;\n        sum += array[idx];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    \n    // Process 4 diagonal elements at a time\n    for (; i + 3 < dim; i += 4) {\n        size_t idx0 = i * dim * dim + i * dim + i;\n        size_t idx1 = (i + 1) * dim * dim + (i + 1) * dim + (i + 1);\n        size_t idx2 = (i + 2) * dim * dim + (i + 2) * dim + (i + 2);\n        size_t idx3 = (i + 3) * dim * dim + (i + 3) * dim + (i + 3);\n        \n        float32x4_t diag = {array[idx0], array[idx1], array[idx2], array[idx3]};\n        sum_vec = vaddq_f32(sum_vec, diag);\n    }\n    \n    // Handle remaining elements\n    float sum = vaddvq_f32(sum_vec);\n    for (; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n    \n    // Process 4 diagonal elements at a time\n    for (i = 0; i + 3 < dim; i += 4) {\n        size_t idx0 = i * (dim * dim + dim + 1);\n        size_t idx1 = (i + 1) * (dim * dim + dim + 1);\n        size_t idx2 = (i + 2) * (dim * dim + dim + 1);\n        size_t idx3 = (i + 3) * (dim * dim + dim + 1);\n        \n        float32x4_t diag = {\n            array[idx0],\n            array[idx1], \n            array[idx2],\n            array[idx3]\n        };\n        \n        sum_vec = vaddq_f32(sum_vec, diag);\n    }\n    \n    // Handle remaining elements\n    float sum = vaddvq_f32(sum_vec);\n    for (; i < dim; i++) {\n        sum += array[i * (dim * dim + dim + 1)];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n    \n    // Process 4 diagonal elements at a time\n    for (i = 0; i + 3 < dim; i += 4) {\n        size_t idx0 = i * (dim * dim + dim + 1);\n        size_t idx1 = (i + 1) * (dim * dim + dim + 1);\n        size_t idx2 = (i + 2) * (dim * dim + dim + 1);\n        size_t idx3 = (i + 3) * (dim * dim + dim + 1);\n        \n        float32x4_t diag = {\n            array[idx0],\n            array[idx1], \n            array[idx2],\n            array[idx3]\n        };\n        \n        sum_vec = vaddq_f32(sum_vec, diag);\n    }\n    \n    // Handle remaining elements\n    float sum = vaddvq_f32(sum_vec);\n    for (; i < dim; i++) {\n        sum += array[i * (dim * dim + dim + 1)];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i = 0;\n    \n    // Process 4 diagonal elements at a time\n    for (; i + 3 < dim; i += 4) {\n        size_t idx0 = i * dim * dim + i * dim + i;\n        size_t idx1 = (i + 1) * dim * dim + (i + 1) * dim + (i + 1);\n        size_t idx2 = (i + 2) * dim * dim + (i + 2) * dim + (i + 2);\n        size_t idx3 = (i + 3) * dim * dim + (i + 3) * dim + (i + 3);\n        \n        float32x4_t diag = {array[idx0], array[idx1], array[idx2], array[idx3]};\n        sum_vec = vaddq_f32(sum_vec, diag);\n    }\n    \n    // Handle remaining elements\n    float sum = vaddvq_f32(sum_vec);\n    for (; i < dim; i++) {\n        size_t idx = i * dim * dim + i * dim + i;\n        sum += array[idx];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n    \n    size_t total = rows * cols;\n    size_t vec_size = total - (total % 2);\n    \n    for (size_t i = 0; i < vec_size; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_result);\n    }\n\n    for (size_t i = vec_size; i < total; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t vec_size = total / 2;\n    size_t remaining = total % 2;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t src_vec = vld1q_f64(&src[i * 2]);\n        uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled = vmulq_f64(src_vec, scale_vec);\n        float64x2_t result = vbslq_f64(mask, scaled, src_vec);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 2; i < total; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t input = vld1q_f64(&src[i * 2]);\n        uint64x2_t mask = vcgtq_f64(input, threshold_vec);\n        float64x2_t scaled = vmulq_f64(input, scale_vec);\n        float64x2_t result = vbslq_f64(mask, scaled, input);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 2; i < total; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t vec_size = total / 2;\n    size_t remaining = total % 2;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t input = vld1q_f64(&src[i * 2]);\n        uint64x2_t mask = vcgtq_f64(input, threshold_vec);\n        float64x2_t scaled = vmulq_f64(input, scale_vec);\n        float64x2_t result = vbslq_f64(mask, scaled, input);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 2; i < total; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n\n    float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n\n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t input = vld1q_f64(&src[i * 2]);\n        uint64x2_t mask = vcgtq_f64(input, threshold_vec);\n        float64x2_t scaled = vmulq_f64(input, scale_vec);\n        float64x2_t result = vbslq_f64(mask, scaled, input);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 2; i < total; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_blocks = cols / 2;\n    size_t col_remainder = cols % 2;\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        // Process 2 doubles at a time using NEON\n        for (size_t j = 0; j < col_blocks; j++) {\n            float64x2_t v = vld1q_f64(&src[src_offset + j * 2]);\n            vst1q_f64(&dst[dst_offset + j * 2], v);\n        }\n\n        // Handle remaining column\n        if (col_remainder) {\n            dst[dst_offset + cols - 1] = src[src_offset + cols - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    const size_t step = 2; // Process 2 doubles at a time with NEON\n    size_t col_blocks = cols / step;\n    size_t col_remainder = cols % step;\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n\n        // Process blocks of 2 doubles using NEON\n        for (size_t j = 0; j < col_blocks; j++) {\n            float64x2_t v = vld1q_f64(&src[src_row + j * step]);\n            vst1q_f64(&dst[dst_row + j * step], v);\n        }\n\n        // Handle remaining columns\n        size_t processed = col_blocks * step;\n        for (size_t j = 0; j < col_remainder; j++) {\n            dst[dst_row + processed + j] = src[src_row + processed + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    const size_t step = 2; // Process 2 doubles at a time using NEON\n    size_t col_blocks = cols / step;\n    size_t col_remainder = cols % step;\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        \n        // Process blocks of 2 doubles using NEON\n        for (size_t j = 0; j < col_blocks; j++) {\n            float64x2_t v = vld1q_f64(&src[src_row + j * step]);\n            vst1q_f64(&dst[dst_row + j * step], v);\n        }\n\n        // Handle remaining columns\n        size_t processed = col_blocks * step;\n        for (size_t j = 0; j < col_remainder; j++) {\n            dst[dst_row + processed + j] = src[src_row + processed + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_blocks = cols / 2;\n    size_t col_remainder = cols % 2;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* src_row = src + indices[i] * cols;\n        double* dst_row = dst + i * cols;\n\n        size_t j;\n        for (j = 0; j < col_blocks; j++) {\n            float64x2_t v = vld1q_f64(src_row + j * 2);\n            vst1q_f64(dst_row + j * 2, v);\n        }\n\n        if (col_remainder) {\n            dst_row[j * 2] = src_row[j * 2];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t col_blocks = cols / 2;\n    size_t col_remainder = cols % 2;\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        // Process 2 doubles at a time using NEON\n        for (size_t j = 0; j < col_blocks; j++) {\n            float64x2_t v = vld1q_f64(&src[src_offset + j*2]);\n            vst1q_f64(&dst[dst_offset + j*2], v);\n        }\n\n        // Handle remaining column if cols is odd\n        if (col_remainder) {\n            dst[dst_offset + cols - 1] = src[src_offset + cols - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i;\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t v1 = vld1q_s64(&src1[i]);\n        int64x2_t v2 = vld1q_s64(&src2[i]);\n        int64x2_t sum = vaddq_s64(v1, v2);\n        sum = vaddq_s64(sum, scalar_vec);\n        int64x2_t result = vshrq_n_s64(sum, 1);\n        vst1q_s64(&dst[i], result);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i;\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t v1 = vld1q_s64(&src1[i]);\n        int64x2_t v2 = vld1q_s64(&src2[i]);\n        \n        int64x2_t sum = vaddq_s64(v1, v2);\n        sum = vaddq_s64(sum, scalar_vec);\n        int64x2_t result = vshrq_n_s64(sum, 1);\n        \n        vst1q_s64(&dst[i], result);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i;\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t v1 = vld1q_s64(&src1[i]);\n        int64x2_t v2 = vld1q_s64(&src2[i]);\n        int64x2_t sum = vaddq_s64(v1, v2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(&dst[i], sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i;\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t v1 = vld1q_s64(&src1[i]);\n        int64x2_t v2 = vld1q_s64(&src2[i]);\n        int64x2_t sum = vaddq_s64(v1, v2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(&dst[i], sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i;\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t v1 = vld1q_s64(&src1[i]);\n        int64x2_t v2 = vld1q_s64(&src2[i]);\n        int64x2_t sum = vaddq_s64(v1, v2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(&dst[i], sum);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    \n    size_t vec_size = length / 4;\n    size_t i;\n    \n    for (i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t curr = vld1q_s32(&src[i]);\n        int32x4_t mask = vdupq_n_s32(1);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(curr, mask), vdupq_n_s32(0));\n        int32x4_t even_vals = vbslq_s32(even_mask, curr, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, even_vals);\n    }\n    \n    int32_t min_arr[4];\n    vst1q_s32(min_arr, min_vec);\n    \n    for (i = 0; i < 4; i++) {\n        if (min_arr[i] < min_val) {\n            min_val = min_arr[i];\n        }\n    }\n    \n    for (i = vec_size * 4; i < length; i++) {\n        if ((i % 2 == 0) && (src[i] < min_val)) {\n            min_val = src[i];\n        }\n    }\n    \n    return min_val == INT_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    \n    size_t vec_size = length / 4;\n    size_t i;\n    \n    for (i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t data = vld1q_s32(&src[i]);\n        int32x4_t even_mask = vdupq_n_s32(0);\n        even_mask = vsetq_lane_s32(-1, even_mask, 0);\n        even_mask = vsetq_lane_s32(-1, even_mask, 2);\n        \n        data = vandq_s32(data, even_mask);\n        data = vorrq_s32(data, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, data);\n    }\n    \n    int32_t min_arr[4];\n    vst1q_s32(min_arr, min_vec);\n    \n    min_val = min(min_arr[0], min_arr[2]);\n    \n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    \n    size_t vec_size = length / 4;\n    size_t i;\n    \n    for (i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x4_t mask = vdupq_n_s32(0);\n        mask = vsetq_lane_s32(-1, mask, 0);\n        mask = vsetq_lane_s32(-1, mask, 2);\n        vec = vandq_s32(vec, mask);\n        min_vec = vminq_s32(min_vec, vec);\n    }\n    \n    int32_t min_arr[4];\n    vst1q_s32(min_arr, min_vec);\n    \n    min_val = min(min_arr[0], min_arr[2]);\n    \n    for (; i < length; i += 2) {\n        min_val = min(min_val, src[i]);\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    \n    size_t vec_size = length / 4;\n    size_t i;\n    \n    for (i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t curr = vld1q_s32(&src[i]);\n        int32x4_t mask = vdupq_n_s32(1);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(curr, mask), vdupq_n_s32(0));\n        int32x4_t even_vals = vbslq_s32(even_mask, curr, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, even_vals);\n    }\n    \n    int32_t min_arr[4];\n    vst1q_s32(min_arr, min_vec);\n    \n    for (i = 0; i < 4; i++) {\n        if (min_arr[i] < min_val) {\n            min_val = min_arr[i];\n        }\n    }\n    \n    for (i = vec_size * 4; i < length; i++) {\n        if ((i % 2 == 0) && (src[i] < min_val)) {\n            min_val = src[i];\n        }\n    }\n    \n    return min_val == INT_MAX ? -1 : min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    \n    size_t vec_size = length / 4;\n    size_t i;\n    \n    for (i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t curr = vld1q_s32(&src[i]);\n        int32x4_t mask = vdupq_n_s32(0);\n        mask = vsetq_lane_s32(-1, mask, 0);\n        mask = vsetq_lane_s32(-1, mask, 2);\n        \n        curr = vandq_s32(curr, mask);\n        curr = vorrq_s32(curr, vdupq_n_s32(INT_MAX));\n        min_vec = vminq_s32(min_vec, curr);\n    }\n    \n    int32_t min_arr[4];\n    vst1q_s32(min_arr, min_vec);\n    \n    min_val = min(min_arr[0], min_arr[2]);\n    \n    for (; i < length; i += 2) {\n        min_val = min(min_val, src[i]);\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arithmetic = vshrq_n_s32(vec, shift);\n        \n        // Logical right shift - convert to uint, shift, convert back\n        uint32x4_t uvec = vreinterpretq_u32_s32(vec);\n        uint32x4_t logical = vshrq_n_u32(uvec, shift);\n        int32x4_t logical_s = vreinterpretq_s32_u32(logical);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arithmetic, logical_s);\n        \n        // Store result\n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arithmetic = src[i] >> shift;\n        int logical = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(vec, shift);\n        \n        // Logical right shift - convert to uint, shift, convert back\n        uint32x4_t uvec = vreinterpretq_u32_s32(vec);\n        uint32x4_t logic_shift = vshrq_n_u32(uvec, shift);\n        int32x4_t logic_shift_s = vreinterpretq_s32_u32(logic_shift);\n        \n        // Add results and store\n        int32x4_t result = vaddq_s32(arith_shift, logic_shift_s);\n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith = src[i] >> shift;\n        int logic = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith + logic;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 4;\n    \n    for (i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(vec, shift);\n        \n        // Logical right shift\n        uint32x4_t uvec = vreinterpretq_u32_s32(vec);\n        uint32x4_t logic_shift = vshrq_n_u32(uvec, shift);\n        int32x4_t logic_shift_s = vreinterpretq_s32_u32(logic_shift);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arith_shift, logic_shift_s);\n        \n        // Store result\n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 4;\n    \n    for (i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arith_shift = vshrq_n_s32(vec, shift);\n        \n        // Logical right shift (convert to uint, shift, convert back)\n        uint32x4_t uvec = vreinterpretq_u32_s32(vec);\n        uint32x4_t logic_shift = vshrq_n_u32(uvec, shift);\n        int32x4_t logic_shift_s = vreinterpretq_s32_u32(logic_shift);\n        \n        // Add results and store\n        int32x4_t result = vaddq_s32(arith_shift, logic_shift_s);\n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        \n        // Arithmetic right shift\n        int32x4_t arithmetic = vshrq_n_s32(vec, shift);\n        \n        // Logical right shift\n        uint32x4_t uvec = vreinterpretq_u32_s32(vec);\n        uint32x4_t logical = vshrq_n_u32(uvec, shift);\n        int32x4_t logical_s = vreinterpretq_s32_u32(logical);\n        \n        // Add results\n        int32x4_t result = vaddq_s32(arithmetic, logical_s);\n        \n        // Store result\n        vst1q_s32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arithmetic = src[i] >> shift;\n        int logical = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arithmetic + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t size = rows * cols;\n    size_t step = 4;\n    size_t i = 0;\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    // Process 4 elements at a time\n    for (; i + step <= size; i += step) {\n        int32x4_t data = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, data);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_2 = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    sum_2 = vpadd_s32(sum_2, sum_2);\n    total = vget_lane_s32(sum_2, 0);\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t size = rows * cols;\n    size_t vec_size = size - (size % 4);\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    // Process 4 elements at a time\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t v = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n    \n    // Horizontal sum of vector\n    int32x2_t sum_2 = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n    int32x2_t sum_1 = vpadd_s32(sum_2, sum_2);\n    total = vget_lane_s32(sum_1, 0);\n    \n    // Add remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t size = rows * cols;\n    size_t step = 4;\n    size_t i = 0;\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (; i + step <= size; i += step) {\n        int32x4_t v = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    total = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (; i < size; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t size = rows * cols;\n    size_t step = 4;\n    size_t i = 0;\n    \n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    // Process 4 elements at a time\n    for (; i + step <= size; i += step) {\n        int32x4_t v = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n    \n    // Extract results\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    total = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t size = rows * cols;\n    size_t step = 4;\n    size_t i = 0;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    // Process 4 elements at a time\n    for (; i + step <= size; i += step) {\n        int32x4_t v = vld1q_s32(&matrix[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n\n    // Extract results and sum\n    int32_t temp_sum[4];\n    vst1q_s32(temp_sum, sum_vec);\n    total = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        total += matrix[i];\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    \n    size_t vec_size = 16;\n    size_t vec_length = length / vec_size;\n    \n    if (vec_length > 0) {\n        int8x16_t max_vec = vld1q_s8(src);\n        int8x16_t idx_vec = vcreate_s8(0x0F0E0D0C0B0A09080706050403020100);\n        int8x16_t curr_idx = idx_vec;\n        int8x16_t max_idx_vec = idx_vec;\n        \n        for (size_t i = 1; i < vec_length; i++) {\n            int8x16_t curr_vec = vld1q_s8(src + i * vec_size);\n            curr_idx = vaddq_s8(curr_idx, vdupq_n_s8(vec_size));\n            \n            uint8x16_t mask = vcgtq_s8(curr_vec, max_vec);\n            max_vec = vbslq_s8(mask, curr_vec, max_vec);\n            max_idx_vec = vbslq_s8(mask, curr_idx, max_idx_vec);\n        }\n        \n        int8_t max_arr[16];\n        int8_t idx_arr[16];\n        vst1q_s8(max_arr, max_vec);\n        vst1q_s8(idx_arr, max_idx_vec);\n        \n        for (size_t i = 0; i < vec_size; i++) {\n            if (max_arr[i] > max_val) {\n                max_val = max_arr[i];\n                max_idx = idx_arr[i];\n            }\n        }\n    }\n    \n    for (size_t i = vec_length * vec_size; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    size_t max_idx = 0;\n    size_t i;\n    \n    for (i = 0; i + 16 <= length; i += 16) {\n        int8x16_t curr_vec = vld1q_s8(&src[i]);\n        uint8x16_t cmp = vcgtq_s8(curr_vec, max_vec);\n        \n        if (vmaxvq_u8(cmp)) {\n            int8_t max_val = src[max_idx];\n            for (size_t j = i; j < i + 16; j++) {\n                if (src[j] > max_val) {\n                    max_val = src[j];\n                    max_idx = j;\n                }\n            }\n            max_vec = vdupq_n_s8(max_val);\n        }\n    }\n    \n    for (; i < length; i++) {\n        if (src[i] > src[max_idx]) {\n            max_idx = i;\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    size_t max_idx = 0;\n    size_t i;\n\n    for (i = 0; i + 16 <= length; i += 16) {\n        int8x16_t curr_vec = vld1q_s8(&src[i]);\n        uint8x16_t mask = vcgtq_s8(curr_vec, max_vec);\n        \n        if (vmaxvq_u8(mask) != 0) {\n            for (size_t j = 0; j < 16; j++) {\n                if (src[i + j] > vgetq_lane_s8(max_vec, 0)) {\n                    max_vec = vdupq_n_s8(src[i + j]);\n                    max_idx = i + j;\n                }\n            }\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > vgetq_lane_s8(max_vec, 0)) {\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    size_t max_idx = 0;\n    size_t i;\n\n    for (i = 0; i + 16 <= length; i += 16) {\n        int8x16_t curr_vec = vld1q_s8(&src[i]);\n        uint8x16_t cmp = vcgtq_s8(curr_vec, max_vec);\n        \n        if (vmaxvq_u8(cmp)) {\n            for (size_t j = 0; j < 16; j++) {\n                if (src[i + j] > vgetq_lane_s8(max_vec, 0)) {\n                    max_vec = vdupq_n_s8(src[i + j]);\n                    max_idx = i + j;\n                }\n            }\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > vgetq_lane_s8(max_vec, 0)) {\n            max_idx = i;\n        }\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    int8x16_t max_vec = vdupq_n_s8(src[0]);\n    size_t max_idx = 0;\n    size_t i;\n    \n    for (i = 0; i + 16 <= length; i += 16) {\n        int8x16_t curr_vec = vld1q_s8(&src[i]);\n        uint8x16_t cmp = vcgtq_s8(curr_vec, max_vec);\n        \n        if (vmaxvq_u8(cmp)) {\n            int8_t max_val = src[max_idx];\n            for (size_t j = i; j < i + 16; j++) {\n                if (src[j] > max_val) {\n                    max_val = src[j];\n                    max_idx = j;\n                }\n            }\n            max_vec = vdupq_n_s8(max_val);\n        }\n    }\n    \n    for (; i < length; i++) {\n        if (src[i] > src[max_idx]) {\n            max_idx = i;\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 8;\n    \n    for (i = 0; i + step <= length; i += step) {\n        uint16x8_t indices = vcreate_u16((uint64_t)i | ((uint64_t)(i+1)<<16) | \n                                       ((uint64_t)(i+2)<<32) | ((uint64_t)(i+3)<<48));\n        uint16x8_t indices2 = vcreate_u16((uint64_t)(i+4) | ((uint64_t)(i+5)<<16) | \n                                        ((uint64_t)(i+6)<<32) | ((uint64_t)(i+7)<<48));\n        \n        uint16x8_t mask_vec = vcombine_u16(vmovn_u32(vdupq_n_u32(mask)), \n                                          vmovn_u32(vdupq_n_u32(mask)));\n        \n        uint16x8_t and_result = vorrq_u16(vandq_u16(indices, mask_vec),\n                                         vandq_u16(indices2, mask_vec));\n        \n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n        \n        uint16x8_t result = vbslq_u16(vcgtq_u16(and_result, vdupq_n_u16(0)), \n                                     src1_vec, src2_vec);\n        \n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 8;\n    \n    for (i = 0; i + step <= length; i += step) {\n        uint16x8_t indices = vcreate_u16((uint64_t)i | ((uint64_t)(i+1)<<16) | \n                                       ((uint64_t)(i+2)<<32) | ((uint64_t)(i+3)<<48));\n        uint16x8_t indices2 = vcreate_u16((uint64_t)(i+4) | ((uint64_t)(i+5)<<16) | \n                                        ((uint64_t)(i+6)<<32) | ((uint64_t)(i+7)<<48));\n        \n        uint16x8_t mask_vec = vcombine_u16(vmovn_u32(vdupq_n_u32(mask)), \n                                          vmovn_u32(vdupq_n_u32(mask)));\n        \n        uint16x8_t and_result = vandq_u16(indices, mask_vec);\n        uint16x8_t and_result2 = vandq_u16(indices2, mask_vec);\n        \n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n        \n        uint16x8_t zero = vdupq_n_u16(0);\n        uint16x8_t mask_cmp = vceqq_u16(and_result, zero);\n        uint16x8_t mask_cmp2 = vceqq_u16(and_result2, zero);\n        \n        uint16x8_t result = vbslq_u16(mask_cmp, src2_vec, src1_vec);\n        \n        vst1q_u16(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 8;\n    \n    for (i = 0; i + step <= length; i += step) {\n        uint16x8_t indices = vcreate_u16(((uint64_t)i << 48) | ((uint64_t)(i+1) << 32) | \n                                       ((uint64_t)(i+2) << 16) | (i+3));\n        uint16x8_t indices2 = vcreate_u16(((uint64_t)(i+4) << 48) | ((uint64_t)(i+5) << 32) | \n                                        ((uint64_t)(i+6) << 16) | (i+7));\n        \n        uint16x8_t mask_vec = vcombine_u16(vmovn_u32(vdupq_n_u32(mask)), \n                                          vmovn_u32(vdupq_n_u32(mask)));\n        \n        uint16x8_t and_result = vandq_u16(indices, mask_vec);\n        uint16x8_t and_result2 = vandq_u16(indices2, mask_vec);\n        \n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n        \n        uint16x8_t zero = vdupq_n_u16(0);\n        uint16x8_t mask1 = vcgtq_u16(and_result, zero);\n        uint16x8_t mask2 = vcgtq_u16(and_result2, zero);\n        \n        uint16x8_t result = vbslq_u16(mask1, src1_vec, src2_vec);\n        \n        vst1q_u16(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((i & mask) != 0) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 8;\n    \n    for (i = 0; i + step <= length; i += step) {\n        uint16x8_t indices = vcreate_u16((uint64_t)i | ((uint64_t)(i+1)<<16) | ((uint64_t)(i+2)<<32) | \n                                       ((uint64_t)(i+3)<<48) | ((uint64_t)(i+4)<<64) | ((uint64_t)(i+5)<<80) |\n                                       ((uint64_t)(i+6)<<96) | ((uint64_t)(i+7)<<112));\n        \n        uint16x8_t mask_vec = vdupq_n_u16(mask);\n        uint16x8_t and_result = vandq_u16(indices, mask_vec);\n        uint16x8_t zero = vdupq_n_u16(0);\n        uint16x8_t mask_cmp = vcgtq_u16(and_result, zero);\n        \n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n        \n        uint16x8_t result = vbslq_u16(mask_cmp, src1_vec, src2_vec);\n        vst1q_u16(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 8;\n    \n    for (i = 0; i + step <= length; i += step) {\n        uint16x8_t indices = vcreate_u16(((uint64_t)i << 48) | ((uint64_t)(i+1) << 32) | \n                                       ((uint64_t)(i+2) << 16) | (i+3));\n        uint16x8_t indices2 = vcreate_u16(((uint64_t)(i+4) << 48) | ((uint64_t)(i+5) << 32) | \n                                        ((uint64_t)(i+6) << 16) | (i+7));\n        \n        uint16x8_t mask_vec = vcombine_u16(vmovn_u32(vdupq_n_u32(mask)), \n                                          vmovn_u32(vdupq_n_u32(mask)));\n        \n        uint16x8_t and_result = vandq_u16(indices, mask_vec);\n        uint16x8_t and_result2 = vandq_u16(indices2, mask_vec);\n        \n        uint16x8_t src1_vec = vld1q_u16(&src1[i]);\n        uint16x8_t src2_vec = vld1q_u16(&src2[i]);\n        \n        uint16x8_t zero = vdupq_n_u16(0);\n        uint16x8_t mask1 = vcgtq_u16(and_result, zero);\n        uint16x8_t mask2 = vcgtq_u16(and_result2, zero);\n        \n        uint16x8_t result = vbslq_u16(mask1, src1_vec, src2_vec);\n        \n        vst1q_u16(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        \n        // Count bits in each byte\n        uint8x16_t bytes = vreinterpretq_u8_u32(input);\n        uint8x16_t cnt = vcntq_u8(bytes);\n        \n        // Sum up bytes for each 32-bit element\n        uint16x8_t sum16 = vpaddlq_u8(cnt);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        vst1q_u32(&dst[i], sum32);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        \n        uint8x16_t bytes = vreinterpretq_u8_u32(input);\n        uint8x16_t cnt = vcntq_u8(bytes);\n        \n        uint16x8_t sum16 = vpaddlq_u8(cnt);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        vst1q_u32(&dst[i], sum32);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        \n        // Count bits in each byte\n        uint8x16_t bytes = vcntq_u8(vreinterpretq_u8_u32(input));\n        \n        // Add adjacent bytes\n        uint16x8_t sum16 = vpaddlq_u8(bytes);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        vst1q_u32(&dst[i], sum32);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        dst[i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        \n        // Count bits in each byte\n        uint8x16_t bytes = vcntq_u8(vreinterpretq_u8_u32(input));\n        \n        // Add adjacent bytes\n        uint16x8_t sum16 = vpaddlq_u8(bytes);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        // Store results\n        vst1q_u32(&dst[i], sum32);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        dst[i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        uint32x4_t input = vld1q_u32(&src[i]);\n        \n        uint8x16_t bytes = vreinterpretq_u8_u32(input);\n        uint8x16_t cnt = vcntq_u8(bytes);\n        \n        uint16x8_t sum16 = vpaddlq_u8(cnt);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        vst1q_u32(&dst[i], sum32);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vec_size = 8;\n    size_t vec_length = length / vec_size;\n    size_t remaining = length % vec_size;\n\n    for (size_t i = 0; i < vec_length; i++) {\n        uint16x8_t v1 = vld1q_u16(src1 + i * vec_size);\n        uint16x8_t v2 = vld1q_u16(src2 + i * vec_size);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i * vec_size, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - remaining; i < length; i++) {\n        dst[i] = (uint16_t)((uint32_t)src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length / 8;\n    \n    for (i = 0; i < vec_size; i++) {\n        uint16x8_t v1 = vld1q_u16(src1 + i * 8);\n        uint16x8_t v2 = vld1q_u16(src2 + i * 8);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i * 8, result);\n    }\n\n    // Handle remaining elements\n    for (i = vec_size * 8; i < length; i++) {\n        dst[i] = (uint16_t)((uint32_t)src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t vec_size = 8;\n    size_t vec_length = length - (length % vec_size);\n\n    // Process 8 elements at a time using NEON\n    for (i = 0; i < vec_length; i += vec_size) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vec_size = 8;\n    size_t vec_length = length / vec_size;\n    size_t remaining = length % vec_size;\n\n    for (size_t i = 0; i < vec_length; i++) {\n        uint16x8_t v1 = vld1q_u16(src1 + i * vec_size);\n        uint16x8_t v2 = vld1q_u16(src2 + i * vec_size);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i * vec_size, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = length - remaining; i < length; i++) {\n        dst[i] = (uint16_t)((uint32_t)src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length - (length % 8);\n    \n    for (i = 0; i < vec_size; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    float64x2_t vmin = vdupq_n_f64(-100.0);\n    float64x2_t vmax = vdupq_n_f64(100.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t vsum = vdupq_n_f64(0.0);\n            size_t k;\n            \n            for (k = 0; k + 1 < n; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[k * p + j]);\n                \n                uint64x2_t mask_a_min = vcgeq_f64(va, vmin);\n                uint64x2_t mask_a_max = vcleq_f64(va, vmax);\n                uint64x2_t mask_b_min = vcgeq_f64(vb, vmin);\n                uint64x2_t mask_b_max = vcleq_f64(vb, vmax);\n                \n                uint64x2_t mask_a = vandq_u64(mask_a_min, mask_a_max);\n                uint64x2_t mask_b = vandq_u64(mask_b_min, mask_b_max);\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                \n                float64x2_t vmul = vmulq_f64(va, vb);\n                vmul = vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(vmul), mask));\n                vsum = vaddq_f64(vsum, vmul);\n            }\n            \n            double sum = vgetq_lane_f64(vsum, 0) + vgetq_lane_f64(vsum, 1);\n            \n            for (; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            float64x2_t min_val = vdupq_n_f64(-100.0);\n            float64x2_t max_val = vdupq_n_f64(100.0);\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                \n                uint64x2_t mask_a = vandq_u64(\n                    vcgeq_f64(a, min_val),\n                    vcleq_f64(a, max_val)\n                );\n                \n                uint64x2_t mask_b = vandq_u64(\n                    vcgeq_f64(b, min_val),\n                    vcleq_f64(b, max_val)\n                );\n                \n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                \n                float64x2_t prod = vmulq_f64(a, b);\n                float64x2_t masked_prod = vreinterpretq_f64_u64(\n                    vandq_u64(vreinterpretq_u64_f64(prod), mask)\n                );\n                \n                sum = vaddq_f64(sum, masked_prod);\n            }\n            \n            double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                size_t k = n - 1;\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    total += a * b;\n                }\n            }\n            \n            C[i * p + j] = total;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    float64x2_t vmin = vdupq_n_f64(-100.0);\n    float64x2_t vmax = vdupq_n_f64(100.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t vsum = vdupq_n_f64(0.0);\n            size_t k;\n            \n            for (k = 0; k + 1 < n; k += 2) {\n                float64x2_t va = vld1q_f64(&A[i * n + k]);\n                float64x2_t vb = vld1q_f64(&B[k * p + j]);\n                \n                uint64x2_t mask_a_min = vcgeq_f64(va, vmin);\n                uint64x2_t mask_a_max = vcleq_f64(va, vmax);\n                uint64x2_t mask_b_min = vcgeq_f64(vb, vmin);\n                uint64x2_t mask_b_max = vcleq_f64(vb, vmax);\n                \n                uint64x2_t mask_a = vandq_u64(mask_a_min, mask_a_max);\n                uint64x2_t mask_b = vandq_u64(mask_b_min, mask_b_max);\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                \n                float64x2_t vmul = vmulq_f64(va, vb);\n                vmul = vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(vmul), mask));\n                vsum = vaddq_f64(vsum, vmul);\n            }\n            \n            double sum = vgetq_lane_f64(vsum, 0) + vgetq_lane_f64(vsum, 1);\n            \n            for (; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            float64x2_t min_val = vdupq_n_f64(-100.0);\n            float64x2_t max_val = vdupq_n_f64(100.0);\n            \n            size_t k;\n            for (k = 0; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                \n                uint64x2_t mask_a = vandq_u64(\n                    vcgeq_f64(a, min_val),\n                    vcleq_f64(a, max_val)\n                );\n                uint64x2_t mask_b = vandq_u64(\n                    vcgeq_f64(b, min_val),\n                    vcleq_f64(b, max_val)\n                );\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                \n                float64x2_t prod = vmulq_f64(a, b);\n                prod = vreinterpretq_f64_u64(\n                    vandq_u64(\n                        vreinterpretq_u64_f64(prod),\n                        mask\n                    )\n                );\n                \n                sum = vaddq_f64(sum, prod);\n            }\n            \n            double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            \n            // Handle remaining element if n is odd\n            if (k < n) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    total += a * b;\n                }\n            }\n            \n            C[i * p + j] = total;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            float64x2_t min_val = vdupq_n_f64(-100.0);\n            float64x2_t max_val = vdupq_n_f64(100.0);\n            \n            size_t k;\n            for (k = 0; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                \n                uint64x2_t mask_a = vandq_u64(\n                    vcgeq_f64(a, min_val),\n                    vcleq_f64(a, max_val)\n                );\n                uint64x2_t mask_b = vandq_u64(\n                    vcgeq_f64(b, min_val),\n                    vcleq_f64(b, max_val)\n                );\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                \n                float64x2_t prod = vmulq_f64(a, b);\n                prod = vreinterpretq_f64_u64(\n                    vandq_u64(vreinterpretq_u64_f64(prod), mask)\n                );\n                \n                sum = vaddq_f64(sum, prod);\n            }\n            \n            double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            \n            // Handle remaining element if n is odd\n            if (k < n) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    total += a * b;\n                }\n            }\n            \n            C[i * p + j] = total;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 2;\n    size_t remainder = total_size % 2;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        int64x2_t a = vld1q_s64(&A[i * 2]);\n        int64x2_t b = vld1q_s64(&B[i * 2]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i * 2], c);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t last = total_size - 1;\n        C[last] = A[last] + B[last];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vec_size = 2; // Number of int64 elements in int64x2_t\n    size_t vec_count = total_elements / vec_size;\n    size_t remaining = total_elements % vec_size;\n\n    // Process 2 elements at a time using NEON\n    for (size_t i = 0; i < vec_count; i++) {\n        int64x2_t a = vld1q_s64(&A[i * vec_size]);\n        int64x2_t b = vld1q_s64(&B[i * vec_size]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i * vec_size], c);\n    }\n\n    // Handle remaining elements\n    size_t offset = vec_count * vec_size;\n    for (size_t i = 0; i < remaining; i++) {\n        C[offset + i] = A[offset + i] + B[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 2;\n    size_t remainder = total_size % 2;\n\n    for (size_t i = 0; i < vec_size; i++) {\n        int64x2_t a = vld1q_s64(&A[i * 2]);\n        int64x2_t b = vld1q_s64(&B[i * 2]); \n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i * 2], c);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t start = vec_size * 2;\n        C[start] = A[start] + B[start];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 2;\n    size_t remainder = total_size % 2;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        int64x2_t a = vld1q_s64(&A[i * 2]);\n        int64x2_t b = vld1q_s64(&B[i * 2]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i * 2], c);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t start = vec_size * 2;\n        C[start] = A[start] + B[start];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 2;\n    size_t remaining = total_size % 2;\n\n    for (size_t i = 0; i < vec_size; i++) {\n        int64x2_t a = vld1q_s64(&A[i * 2]);\n        int64x2_t b = vld1q_s64(&B[i * 2]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i * 2], c);\n    }\n\n    // Handle remaining elements\n    if (remaining) {\n        size_t idx = vec_size * 2;\n        C[idx] = A[idx] + B[idx];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vec_size = length - (length % 4);\n    size_t i;\n\n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 4;\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 4;\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length - (length % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 4;\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const size_t step = 4;\n    const float32x4_t neg_ones = vdupq_n_f32(-1.0f);\n    const float32x4_t fifty = vdupq_n_f32(50.0f);\n    const uint32x4_t index_mask = {0, 1, 0, 1};\n\n    for (size_t i = 0; i < length; i += step) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        \n        // Check if difference is within 50\n        uint32x4_t diff_mask = vcleq_f32(abs_diff, fifty);\n        \n        // Create index mask for multiples of 2\n        uint32x4_t idx_check = vceqq_u32(vandq_u32(vreinterpretq_u32_f32(index_mask), \n                                                   vreinterpretq_u32_f32(vdupq_n_f32(1.0f))),\n                                        vdupq_n_u32(0));\n        \n        // Combine conditions\n        uint32x4_t final_mask = vandq_u32(diff_mask, idx_check);\n        \n        // Multiply values\n        float32x4_t mul = vmulq_f32(v1, v2);\n        \n        // Round up toward positive infinity\n        float32x4_t rounded = vceilq_f32(mul);\n        \n        // Select between rounded result and -1 based on mask\n        float32x4_t result = vbslq_f32(final_mask, rounded, neg_ones);\n        \n        // Store result\n        vst1q_f32(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (length/step)*step; i < length; i++) {\n        if ((i % 2 == 0) && (fabsf(src1[i] - src2[i]) <= 50.0f)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const size_t step = 4;\n    size_t i;\n    \n    float32x4_t minus_one = vdupq_n_f32(-1.0f);\n    float32x4_t fifty = vdupq_n_f32(50.0f);\n    float32x4_t zero = vdupq_n_f32(0.0f);\n    uint32x4_t two = vdupq_n_u32(2);\n    \n    for (i = 0; i + step <= length; i += step) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        \n        // Check if difference is within 50\n        uint32x4_t mask1 = vcleq_f32(abs_diff, fifty);\n        \n        // Check if index is multiple of 2\n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t mod2 = vandq_u32(indices, vdupq_n_u32(1));\n        uint32x4_t mask2 = vceqq_u32(mod2, zero);\n        \n        // Combine conditions\n        uint32x4_t mask = vandq_u32(mask1, mask2);\n        \n        // Multiply elements that meet conditions\n        float32x4_t mul = vmulq_f32(v1, v2);\n        \n        // Round up toward positive infinity\n        float32x4_t ceil_mul = vrndpq_f32(mul);\n        \n        // Select between -1 and rounded multiplication based on mask\n        float32x4_t result = vbslq_f32(mask, ceil_mul, minus_one);\n        \n        vst1q_f32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if (diff <= 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const size_t step = 4;\n    size_t i;\n    \n    float32x4_t neg_ones = vdupq_n_f32(-1.0f);\n    float32x4_t fifty = vdupq_n_f32(50.0f);\n    float32x4_t indices = {0.0f, 1.0f, 2.0f, 3.0f};\n    float32x4_t two = vdupq_n_f32(2.0f);\n    \n    for (i = 0; i + step <= length; i += step) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        \n        // Check if difference is within 50\n        uint32x4_t mask1 = vcleq_f32(abs_diff, fifty);\n        \n        // Check if index is multiple of 2\n        float32x4_t curr_indices = vaddq_f32(indices, vdupq_n_f32(i));\n        float32x4_t div_by_2 = vdivq_f32(curr_indices, two);\n        float32x4_t round_div = vrndq_f32(div_by_2);\n        float32x4_t mul_2 = vmulq_f32(round_div, two);\n        uint32x4_t mask2 = vceqq_f32(curr_indices, mul_2);\n        \n        // Combine conditions\n        uint32x4_t mask = vandq_u32(mask1, mask2);\n        \n        // Multiply values where conditions are met\n        float32x4_t prod = vmulq_f32(v1, v2);\n        float32x4_t rounded = vrndpq_f32(prod);\n        \n        // Select between -1 and computed result based on mask\n        float32x4_t result = vbslq_f32(mask, rounded, neg_ones);\n        \n        vst1q_f32(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (fabsf(src1[i] - src2[i]) <= 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const size_t step = 4;\n    const float32x4_t minus_one = vdupq_n_f32(-1.0f);\n    const float32x4_t fifty = vdupq_n_f32(50.0f);\n    const uint32x4_t index_mask = vsetq_lane_u32(1, vsetq_lane_u32(0, vsetq_lane_u32(1, vsetq_lane_u32(0, vdupq_n_u32(0), 0), 1), 2), 3);\n\n    for (size_t i = 0; i < length; i += step) {\n        float32x4_t v1 = vld1q_f32(&src1[i]);\n        float32x4_t v2 = vld1q_f32(&src2[i]);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        \n        // Check if difference is within 50\n        uint32x4_t diff_mask = vcleq_f32(abs_diff, fifty);\n        \n        // Calculate indices\n        uint32x4_t indices = vaddq_u32(vdupq_n_u32(i), vdupq_n_u32(0, 1, 2, 3));\n        uint32x4_t even_mask = vceqq_u32(vandq_u32(indices, vdupq_n_u32(1)), index_mask);\n        \n        // Combine conditions\n        uint32x4_t final_mask = vandq_u32(diff_mask, even_mask);\n        \n        // Multiply values\n        float32x4_t mul = vmulq_f32(v1, v2);\n        \n        // Round up\n        float32x4_t rounded = vrndpq_f32(mul);\n        \n        // Select between rounded result and -1 based on mask\n        float32x4_t result = vbslq_f32(final_mask, rounded, minus_one);\n        \n        // Store result\n        vst1q_f32(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (length/step)*step; i < length; i++) {\n        if ((i % 2 == 0) && (fabs(src1[i] - src2[i]) <= 50.0f)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    float32x4_t neg_ones = vdupq_n_f32(-1.0f);\n    float32x4_t fifty = vdupq_n_f32(50.0f);\n    uint32x4_t index_mask = vsetq_lane_u32(1, vsetq_lane_u32(0, vsetq_lane_u32(1, vsetq_lane_u32(0, vdupq_n_u32(0), 0), 1), 2), 3);\n\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        // Calculate absolute difference\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        \n        // Check if difference is within 50\n        uint32x4_t diff_mask = vcleq_f32(abs_diff, fifty);\n        \n        // Create index mask for multiples of 2\n        uint32x4_t curr_indices = vaddq_u32(vdupq_n_u32(i), vdupq_n_u32(0));\n        uint32x4_t mod2_mask = vceqq_u32(vandq_u32(curr_indices, vdupq_n_u32(1)), vdupq_n_u32(0));\n        \n        // Combine conditions\n        uint32x4_t final_mask = vandq_u32(diff_mask, mod2_mask);\n        \n        // Multiply values where conditions are met\n        float32x4_t product = vmulq_f32(v1, v2);\n        \n        // Round up the product\n        float32x4_t rounded = vrndpq_f32(product);\n        \n        // Select between rounded product and -1 based on mask\n        float32x4_t result = vbslq_f32(final_mask, rounded, neg_ones);\n        \n        // Store result\n        vst1q_f32(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((i % 2 == 0) && (fabs(src1[i] - src2[i]) <= 50.0f)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remaining = total % 2;\n    \n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i * 2]);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    if (remaining) {\n        dst[total - 1] = mat[total - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remaining = total % 2;\n    \n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i * 2]);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    if (remaining) {\n        dst[total - 1] = mat[total - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i * 2]);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    if (remainder) {\n        dst[total - 1] = mat[total - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i * 2]);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    if (remainder) {\n        dst[total - 1] = mat[total - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i * 2]);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    if (remainder) {\n        dst[total - 1] = mat[total - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        \n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n        \n        // Reduce sum_vec to single value\n        float sum = vgetq_lane_f32(sum_vec, 0) + \n                   vgetq_lane_f32(sum_vec, 1) +\n                   vgetq_lane_f32(sum_vec, 2) + \n                   vgetq_lane_f32(sum_vec, 3);\n                   \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        float norm = 1.0f / sqrtf(sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        \n        // Normalize row using NEON\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, norm_vec);\n            vst1q_f32(row + j, v);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n        \n        // Reduce sum_vec to single value\n        float sum = vgetq_lane_f32(sum_vec, 0) + \n                   vgetq_lane_f32(sum_vec, 1) + \n                   vgetq_lane_f32(sum_vec, 2) + \n                   vgetq_lane_f32(sum_vec, 3);\n                   \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal of square root\n        float norm = 1.0f / sqrtf(sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        \n        // Normalize the row using NEON\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, norm_vec);\n            vst1q_f32(row + j, v);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        \n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n        \n        // Reduce sum_vec to single value\n        float sum = vgetq_lane_f32(sum_vec, 0) + \n                   vgetq_lane_f32(sum_vec, 1) +\n                   vgetq_lane_f32(sum_vec, 2) + \n                   vgetq_lane_f32(sum_vec, 3);\n                   \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        float norm = 1.0f / sqrtf(sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        \n        // Normalize the row using NEON\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, norm_vec);\n            vst1q_f32(row + j, v);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        \n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n        \n        // Reduce sum_vec to single value\n        float sum = vgetq_lane_f32(sum_vec, 0) + \n                   vgetq_lane_f32(sum_vec, 1) + \n                   vgetq_lane_f32(sum_vec, 2) + \n                   vgetq_lane_f32(sum_vec, 3);\n                   \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        float norm = 1.0f / sqrtf(sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        \n        // Normalize row using NEON\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, norm_vec);\n            vst1q_f32(row + j, v);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares using NEON\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n        \n        // Reduce sum vector\n        float sum = vgetq_lane_f32(sum_vec, 0) + \n                   vgetq_lane_f32(sum_vec, 1) +\n                   vgetq_lane_f32(sum_vec, 2) + \n                   vgetq_lane_f32(sum_vec, 3);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            sum += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal of square root\n        float norm = 1.0f / sqrtf(sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        \n        // Normalize row using NEON\n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, norm_vec);\n            vst1q_f32(row + j, v);\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n\n            // Handle remaining element if n is odd\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            if (n % 2) {\n                result += mat1[i * n + n - 1] * mat2[(n - 1) * p + j];\n            }\n            \n            // Round to nearest integer\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n\n            // Handle remaining element if n is odd\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            if (n % 2) {\n                result += mat1[i * n + n - 1] * mat2[(n - 1) * p + j];\n            }\n            \n            // Round to nearest integer\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            size_t k;\n            for (k = 0; k + 1 < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n            \n            double temp = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            \n            // Handle remaining element if n is odd\n            if (k < n) {\n                temp += mat1[i * n + k] * mat2[k * p + j];\n            }\n            \n            // Round to nearest integer\n            dst[i * p + j] = round(temp);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vfmaq_f64(sum, a, b);\n            }\n\n            // Handle remaining elements if n is odd\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            if (n % 2) {\n                result += mat1[i * n + n - 1] * mat2[(n - 1) * p + j];\n            }\n            \n            // Round to nearest integer\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                sum = vmlaq_f64(sum, a, b);\n            }\n\n            // Handle remaining element if n is odd\n            double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            if (n % 2) {\n                result += mat1[i * n + n - 1] * mat2[(n - 1) * p + j];\n            }\n            \n            // Round to nearest integer\n            dst[i * p + j] = round(result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t point_25 = vdupq_n_f32(0.25f);\n    const float32x4_t four = vdupq_n_f32(4.0f);\n    \n    // Process 4x4 blocks\n    for (size_t i = 0; i < rows - 3; i += 4) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[(i + 0) * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]); \n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, dividing by 4\n            row0 = vmulq_f32(vrndaq_f32(vmulq_f32(row0, four)), point_25);\n            row1 = vmulq_f32(vrndaq_f32(vmulq_f32(row1, four)), point_25);\n            row2 = vmulq_f32(vrndaq_f32(vmulq_f32(row2, four)), point_25);\n            row3 = vmulq_f32(vrndaq_f32(vmulq_f32(row3, four)), point_25);\n\n            // Transpose 4x4 matrix\n            float32x4x2_t row01 = vtrnq_f32(row0, row1);\n            float32x4x2_t row23 = vtrnq_f32(row2, row3);\n\n            float32x4_t trans0 = vcombine_f32(vget_low_f32(row01.val[0]), vget_low_f32(row23.val[0]));\n            float32x4_t trans1 = vcombine_f32(vget_low_f32(row01.val[1]), vget_low_f32(row23.val[1]));\n            float32x4_t trans2 = vcombine_f32(vget_high_f32(row01.val[0]), vget_high_f32(row23.val[0]));\n            float32x4_t trans3 = vcombine_f32(vget_high_f32(row01.val[1]), vget_high_f32(row23.val[1]));\n\n            vst1q_f32(&dst[j * rows + i], trans0);\n            vst1q_f32(&dst[(j + 1) * rows + i], trans1);\n            vst1q_f32(&dst[(j + 2) * rows + i], trans2);\n            vst1q_f32(&dst[(j + 3) * rows + i], trans3);\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = (cols/4)*4; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n    \n    for (size_t i = (rows/4)*4; i < rows; i++) {\n        for (size_t j = 0; j < (cols/4)*4; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t four = vdupq_n_f32(4.0f);\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n\n    // Process 4x4 blocks\n    for (size_t i = 0; i < rows - 3; i += 4) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[(i + 0) * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            row0 = vmulq_f32(vrndnq_f32(vmulq_f32(row0, four)), quarter);\n            row1 = vmulq_f32(vrndnq_f32(vmulq_f32(row1, four)), quarter);\n            row2 = vmulq_f32(vrndnq_f32(vmulq_f32(row2, four)), quarter);\n            row3 = vmulq_f32(vrndnq_f32(vmulq_f32(row3, four)), quarter);\n\n            // Transpose 4x4 block\n            float32x4x2_t row01 = vtrnq_f32(row0, row1);\n            float32x4x2_t row23 = vtrnq_f32(row2, row3);\n\n            float32x4_t tmp0 = vcombine_f32(vget_low_f32(row01.val[0]), vget_low_f32(row23.val[0]));\n            float32x4_t tmp1 = vcombine_f32(vget_low_f32(row01.val[1]), vget_low_f32(row23.val[1]));\n            float32x4_t tmp2 = vcombine_f32(vget_high_f32(row01.val[0]), vget_high_f32(row23.val[0]));\n            float32x4_t tmp3 = vcombine_f32(vget_high_f32(row01.val[1]), vget_high_f32(row23.val[1]));\n\n            vst1q_f32(&dst[j * rows + i], tmp0);\n            vst1q_f32(&dst[(j + 1) * rows + i], tmp1);\n            vst1q_f32(&dst[(j + 2) * rows + i], tmp2);\n            vst1q_f32(&dst[(j + 3) * rows + i], tmp3);\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = (cols/4)*4; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n\n    for (size_t i = (rows/4)*4; i < rows; i++) {\n        for (size_t j = 0; j < (cols/4)*4; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t point_25 = vdupq_n_f32(0.25f);\n    const float32x4_t four = vdupq_n_f32(4.0f);\n\n    // Process 4x4 blocks\n    for (size_t i = 0; i < rows - 3; i += 4) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[(i + 0) * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]); \n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            row0 = vmulq_f32(row0, four);\n            row1 = vmulq_f32(row1, four);\n            row2 = vmulq_f32(row2, four);\n            row3 = vmulq_f32(row3, four);\n\n            row0 = vrndnq_f32(row0);\n            row1 = vrndnq_f32(row1);\n            row2 = vrndnq_f32(row2);\n            row3 = vrndnq_f32(row3);\n\n            row0 = vmulq_f32(row0, point_25);\n            row1 = vmulq_f32(row1, point_25);\n            row2 = vmulq_f32(row2, point_25);\n            row3 = vmulq_f32(row3, point_25);\n\n            // Transpose 4x4 block\n            float32x4x4_t temp = vld4q_f32((float*)&row0);\n            vst1q_f32(&dst[j * rows + i], temp.val[0]);\n            vst1q_f32(&dst[(j+1) * rows + i], temp.val[1]);\n            vst1q_f32(&dst[(j+2) * rows + i], temp.val[2]); \n            vst1q_f32(&dst[(j+3) * rows + i], temp.val[3]);\n        }\n\n        // Handle remaining columns\n        for (size_t j = cols - (cols % 4); j < cols; j++) {\n            for (size_t k = 0; k < 4; k++) {\n                float val = src[(i + k) * cols + j];\n                val = roundf(val * 4.0f) * 0.25f;\n                dst[j * rows + i + k] = val;\n            }\n        }\n    }\n\n    // Handle remaining rows\n    for (size_t i = rows - (rows % 4); i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t four = vdupq_n_f32(4.0f);\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n\n    // Process 4x4 blocks\n    for (size_t i = 0; i < rows - 3; i += 4) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[(i + 0) * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            row0 = vmulq_f32(vrndnq_f32(vmulq_f32(row0, four)), quarter);\n            row1 = vmulq_f32(vrndnq_f32(vmulq_f32(row1, four)), quarter);\n            row2 = vmulq_f32(vrndnq_f32(vmulq_f32(row2, four)), quarter);\n            row3 = vmulq_f32(vrndnq_f32(vmulq_f32(row3, four)), quarter);\n\n            // Transpose 4x4 block\n            float32x4x2_t row01 = vtrnq_f32(row0, row1);\n            float32x4x2_t row23 = vtrnq_f32(row2, row3);\n\n            float32x4_t tmp0 = vcombine_f32(vget_low_f32(row01.val[0]), vget_low_f32(row23.val[0]));\n            float32x4_t tmp1 = vcombine_f32(vget_low_f32(row01.val[1]), vget_low_f32(row23.val[1]));\n            float32x4_t tmp2 = vcombine_f32(vget_high_f32(row01.val[0]), vget_high_f32(row23.val[0]));\n            float32x4_t tmp3 = vcombine_f32(vget_high_f32(row01.val[1]), vget_high_f32(row23.val[1]));\n\n            vst1q_f32(&dst[j * rows + i], tmp0);\n            vst1q_f32(&dst[(j + 1) * rows + i], tmp1);\n            vst1q_f32(&dst[(j + 2) * rows + i], tmp2);\n            vst1q_f32(&dst[(j + 3) * rows + i], tmp3);\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = (cols/4)*4; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n    \n    for (size_t i = (rows/4)*4; i < rows; i++) {\n        for (size_t j = 0; j < (cols/4)*4; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t four = vdupq_n_f32(4.0f);\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n\n    // Process 4x4 blocks\n    for (size_t i = 0; i < rows - 3; i += 4) {\n        for (size_t j = 0; j < cols - 3; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            row0 = vmulq_f32(vrndnq_f32(vmulq_f32(row0, four)), quarter);\n            row1 = vmulq_f32(vrndnq_f32(vmulq_f32(row1, four)), quarter);\n            row2 = vmulq_f32(vrndnq_f32(vmulq_f32(row2, four)), quarter);\n            row3 = vmulq_f32(vrndnq_f32(vmulq_f32(row3, four)), quarter);\n\n            // Transpose 4x4 matrix\n            float32x4x2_t row01 = vtrnq_f32(row0, row1);\n            float32x4x2_t row23 = vtrnq_f32(row2, row3);\n\n            float32x4_t trans0 = vcombine_f32(vget_low_f32(row01.val[0]), vget_low_f32(row23.val[0]));\n            float32x4_t trans1 = vcombine_f32(vget_low_f32(row01.val[1]), vget_low_f32(row23.val[1]));\n            float32x4_t trans2 = vcombine_f32(vget_high_f32(row01.val[0]), vget_high_f32(row23.val[0]));\n            float32x4_t trans3 = vcombine_f32(vget_high_f32(row01.val[1]), vget_high_f32(row23.val[1]));\n\n            vst1q_f32(&dst[j * rows + i], trans0);\n            vst1q_f32(&dst[(j + 1) * rows + i], trans1);\n            vst1q_f32(&dst[(j + 2) * rows + i], trans2);\n            vst1q_f32(&dst[(j + 3) * rows + i], trans3);\n        }\n\n        // Handle remaining columns\n        for (size_t j = cols - (cols % 4); j < cols; j++) {\n            for (size_t k = 0; k < 4; k++) {\n                float val = src[(i + k) * cols + j];\n                val = roundf(val * 4.0f) * 0.25f;\n                dst[j * rows + (i + k)] = val;\n            }\n        }\n    }\n\n    // Handle remaining rows\n    for (size_t i = rows - (rows % 4); i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndq_f32(diff);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    for (size_t i = vec_size; i < total_size; i++) {\n        dst[i] = roundf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndq_f32(diff);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    for (size_t i = vec_size; i < total_size; i++) {\n        dst[i] = roundf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        \n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndq_f32(diff);\n        \n        vst1q_f32(&dst[i], rounded);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size; i < total_size; i++) {\n        dst[i] = roundf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndq_f32(diff);\n        vst1q_f32(&dst[i], rounded);\n    }\n\n    for (size_t i = vec_size; i < total_size; i++) {\n        dst[i] = roundf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 4;\n    size_t remaining = total_size % 4;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i * 4);\n        float32x4_t v2 = vld1q_f32(tensor2 + i * 4);\n        \n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndq_f32(diff);\n        \n        vst1q_f32(dst + i * 4, rounded);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size * 4; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff > 0) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t v1 = vld1q_f64(&mat1[i * 2]);\n        float64x2_t v2 = vld1q_f64(&mat2[i * 2]);\n        float64x2_t result = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t last = total - 1;\n        dst[last] = mat1[last] * mat2[last];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t v1 = vld1q_f64(&mat1[i * 2]);\n        float64x2_t v2 = vld1q_f64(&mat2[i * 2]); \n        float64x2_t result = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t last = total - 1;\n        dst[last] = mat1[last] * mat2[last];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t v1 = vld1q_f64(&mat1[i * 2]);\n        float64x2_t v2 = vld1q_f64(&mat2[i * 2]);\n        float64x2_t result = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t idx = vec_size * 2;\n        dst[idx] = mat1[idx] * mat2[idx];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t v1 = vld1q_f64(&mat1[i * 2]);\n        float64x2_t v2 = vld1q_f64(&mat2[i * 2]);\n        float64x2_t result = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t last = total - 1;\n        dst[last] = mat1[last] * mat2[last];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vec_size = total / 2;\n    size_t remainder = total % 2;\n\n    for (size_t i = 0; i < vec_size; i++) {\n        float64x2_t v1 = vld1q_f64(&mat1[i * 2]);\n        float64x2_t v2 = vld1q_f64(&mat2[i * 2]);\n        float64x2_t result = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i * 2], result);\n    }\n\n    // Handle remaining elements\n    if (remainder) {\n        size_t last = total - 1;\n        dst[last] = mat1[last] * mat2[last];\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    const size_t step = 4;\n    size_t n_blocks = n / step;\n    size_t n_remain = n % step;\n\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        const float* row = mat + i * n;\n        \n        // Process 4 elements at a time\n        for (size_t j = 0; j < n_blocks; j++) {\n            float32x4_t mat_vec = vld1q_f32(row + j * step);\n            float32x4_t vec_vec = vld1q_f32(vec + j * step);\n            sum_vec = vmlaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n\n        // Sum up the 4 elements in the vector\n        float sum = vaddvq_f32(sum_vec);\n        \n        // Handle remaining elements\n        for (size_t j = n_blocks * step; j < n; j++) {\n            sum += row[j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vmlaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vmlaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    const size_t step = 4;\n    \n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j;\n        \n        for (j = 0; j + step <= n; j += step) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vmlaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            float32x4_t mat_vec = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_vec = vld1q_f32(vec + j);\n            sum_vec = vmlaq_f32(sum_vec, mat_vec, vec_vec);\n        }\n        \n        float sum = vaddvq_f32(sum_vec);\n        \n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total = m * n;\n    size_t i;\n    \n    for (i = 0; i < total - (total % 2); i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        sum = vaddq_f64(sum, v);\n    }\n    \n    double final_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    for (; i < total; i++) {\n        final_sum += mat[i];\n    }\n    \n    return final_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total = m * n;\n    size_t i;\n    \n    for (i = 0; i < total - 1; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        sum = vaddq_f64(sum, v);\n    }\n    \n    double final_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Handle remaining element if total is odd\n    if (i < total) {\n        final_sum += mat[i];\n    }\n    \n    return final_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total = m * n;\n    size_t i;\n    \n    for (i = 0; i + 1 < total; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        sum = vaddq_f64(sum, v);\n    }\n    \n    double final_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    for (; i < total; i++) {\n        final_sum += mat[i];\n    }\n    \n    return final_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total = m * n;\n    size_t i = 0;\n    \n    // Process 2 elements at a time\n    for (; i + 1 < total; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        sum = vaddq_f64(sum, v);\n    }\n    \n    // Handle remaining element if total is odd\n    double final_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    if (i < total) {\n        final_sum += mat[i];\n    }\n    \n    return final_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    size_t total = m * n;\n    size_t i;\n    \n    for (i = 0; i < total - 1; i += 2) {\n        float64x2_t v = vld1q_f64(&mat[i]);\n        sum = vaddq_f64(sum, v);\n    }\n    \n    double final_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Handle remaining element if total is odd\n    if (i < total) {\n        final_sum += mat[i];\n    }\n    \n    return final_sum / total;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            int32x4_t v1 = vld1q_s32(curr_row + col);\n            int32x4_t v2 = vld1q_s32(curr_row + col + 1);\n            \n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v1, v2);\n            } else {\n                cmp = vcgeq_s32(v1, v2);\n            }\n            \n            uint32_t mask = vgetq_lane_u32(vandq_u32(cmp, vdupq_n_u32(1)), 0) & \n                           vgetq_lane_u32(vandq_u32(cmp, vdupq_n_u32(1)), 1) &\n                           vgetq_lane_u32(vandq_u32(cmp, vdupq_n_u32(1)), 2);\n                           \n            if (!mask) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            int32x4_t v1 = vld1q_s32(curr_row + col);\n            int32x4_t v2 = vld1q_s32(curr_row + col + 1);\n            \n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v1, v2);\n            } else {\n                cmp = vcgeq_s32(v1, v2);\n            }\n            \n            if (vgetq_lane_u32(cmp, 0) == 0 ||\n                vgetq_lane_u32(cmp, 1) == 0 ||\n                vgetq_lane_u32(cmp, 2) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            int32x4_t v1 = vld1q_s32(curr_row + col);\n            int32x4_t v2 = vld1q_s32(curr_row + col + 1);\n            \n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v1, v2);\n            } else {\n                cmp = vcgeq_s32(v1, v2);\n            }\n            \n            if (vgetq_lane_u32(cmp, 0) == 0 ||\n                vgetq_lane_u32(cmp, 1) == 0 ||\n                vgetq_lane_u32(cmp, 2) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            int32x4_t v1 = vld1q_s32(curr_row + col);\n            int32x4_t v2 = vld1q_s32(curr_row + col + 1);\n            \n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v1, v2);\n            } else {\n                cmp = vcgeq_s32(v1, v2);\n            }\n            \n            uint32_t mask = vgetq_lane_u32(vandq_u32(cmp, vdupq_n_u32(1)), 0) &\n                           vgetq_lane_u32(vandq_u32(cmp, vdupq_n_u32(1)), 1) &\n                           vgetq_lane_u32(vandq_u32(cmp, vdupq_n_u32(1)), 2);\n                           \n            if (!mask) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            int32x4_t v1 = vld1q_s32(curr_row + col);\n            int32x4_t v2 = vld1q_s32(curr_row + col + 1);\n            \n            uint32x4_t cmp;\n            if (ascending) {\n                cmp = vcleq_s32(v1, v2);\n            } else {\n                cmp = vcgeq_s32(v1, v2);\n            }\n            \n            if (vgetq_lane_u32(cmp, 0) == 0 ||\n                vgetq_lane_u32(cmp, 1) == 0 ||\n                vgetq_lane_u32(cmp, 2) == 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    size_t i;\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(src + i);\n        int16x8_t vdiv = vdivq_s16(vsrc, vbase);\n        int16x8_t vmul = vmulq_s16(vdiv, vbase);\n        vst1q_s16(dst + i, vmul);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16(base);\n    size_t vec_size = 8;\n    size_t vec_length = length / vec_size;\n    size_t remaining = length % vec_size;\n\n    for (size_t i = 0; i < vec_length; i++) {\n        int16x8_t src_vec = vld1q_s16(src + i * vec_size);\n        int16x8_t div_result = vdivq_s16(src_vec, base_vec);\n        int16x8_t mult_result = vmulq_s16(div_result, base_vec);\n        vst1q_s16(dst + i * vec_size, mult_result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_length * vec_size; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16(base);\n    size_t vec_size = 8;\n    size_t vec_length = length / vec_size;\n    size_t remaining = length % vec_size;\n\n    for (size_t i = 0; i < vec_length; i++) {\n        int16x8_t src_vec = vld1q_s16(src + i * vec_size);\n        int16x8_t div_vec = vdivq_s16(src_vec, base_vec);\n        int16x8_t mult_vec = vmulq_s16(div_vec, base_vec);\n        vst1q_s16(dst + i * vec_size, mult_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_length * vec_size; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vec_size = 8;\n    size_t vec_length = length / vec_size;\n    size_t remaining = length % vec_size;\n    \n    int16x8_t base_vec = vdupq_n_s16(base);\n    \n    for (size_t i = 0; i < vec_length; i++) {\n        int16x8_t src_vec = vld1q_s16(src + i * vec_size);\n        int16x8_t div_vec = vdivq_s16(src_vec, base_vec);\n        int16x8_t mult_vec = vmulq_s16(div_vec, base_vec);\n        vst1q_s16(dst + i * vec_size, mult_vec);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_length * vec_size; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t base_vec = vdupq_n_s16(base);\n    size_t i;\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        int16x8_t src_vec = vld1q_s16(&src[i]);\n        int16x8_t div_vec = vdivq_s16(src_vec, base_vec);\n        int16x8_t mul_vec = vmulq_s16(div_vec, base_vec);\n        vst1q_s16(&dst[i], mul_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t step = 2; // Process 2 doubles at a time with NEON\n    size_t aligned_cols = cols - (cols % step);\n    \n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        size_t j;\n        \n        for (j = 0; j < aligned_cols; j += step) {\n            float64x2_t mat_row = vld1q_f64(matrix + i*cols + j);\n            float64x2_t vec = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(mat_row, vec);\n            \n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (!row_match) continue;\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            if (matrix[i*cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t step = 2; // Process 2 doubles at a time with NEON\n    size_t col_blocks = cols / step;\n    size_t col_remainder = cols % step;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        for (size_t j = 0; j < col_blocks; j++) {\n            float64x2_t v1 = vld1q_f64(row + j * step);\n            float64x2_t v2 = vld1q_f64(vector + j * step);\n            uint64x2_t cmp = vceqq_f64(v1, v2);\n            \n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (!row_match) continue;\n\n        // Handle remaining elements\n        size_t remaining_start = col_blocks * step;\n        for (size_t j = 0; j < col_remainder; j++) {\n            if (row[remaining_start + j] != vector[remaining_start + j]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        \n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t v1 = vld1q_f64(row + j);\n            float64x2_t v2 = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(v1, v2);\n            \n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        \n        if (!match) continue;\n        \n        for (; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        \n        if (match) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        \n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t v1 = vld1q_f64(row + j);\n            float64x2_t v2 = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(v1, v2);\n            \n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        \n        if (!match) continue;\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        \n        if (match) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t step = 2; // Process 2 doubles at a time with NEON\n    size_t col_blocks = cols / step;\n    size_t col_remainder = cols % step;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        for (size_t j = 0; j < col_blocks; j++) {\n            float64x2_t v1 = vld1q_f64(row + j * step);\n            float64x2_t v2 = vld1q_f64(vector + j * step);\n            uint64x2_t cmp = vceqq_f64(v1, v2);\n            \n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (!row_match) continue;\n\n        // Handle remaining elements\n        size_t remaining_start = col_blocks * step;\n        for (size_t j = 0; j < col_remainder; j++) {\n            if (row[remaining_start + j] != vector[remaining_start + j]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n\n    // Process 16 elements at a time\n    for (; i + 15 < total_size; i += 16) {\n        uint8x16_t a = vld1q_u8(A + i);\n        uint8x16_t b = vld1q_u8(B + i);\n        \n        uint8x16_t equal = vceqq_u8(a, b);\n        \n        uint8x8_t sum_low = vget_low_u8(equal);\n        uint8x8_t sum_high = vget_high_u8(equal);\n        \n        uint16x8_t sum16 = vaddl_u8(sum_low, sum_high);\n        uint32x4_t sum32_low = vaddl_u16(vget_low_u16(sum16), vget_high_u16(sum16));\n        \n        count_vec = vaddq_u32(count_vec, sum32_low);\n    }\n\n    // Sum up the vector elements\n    uint32_t temp[4];\n    vst1q_u32(temp, count_vec);\n    count = temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n\n    // Process 16 elements at a time\n    for (; i + 15 < total_size; i += 16) {\n        uint8x16_t a = vld1q_u8(A + i);\n        uint8x16_t b = vld1q_u8(B + i);\n        \n        uint8x16_t equal = vceqq_u8(a, b);\n        \n        uint8x8_t sum_low = vget_low_u8(equal);\n        uint8x8_t sum_high = vget_high_u8(equal);\n        \n        uint16x8_t sum16 = vaddl_u8(sum_low, sum_high);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        count_vec = vaddq_u32(count_vec, sum32);\n    }\n\n    // Sum up the vector elements\n    uint32_t temp[4];\n    vst1q_u32(temp, count_vec);\n    count = temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n\n    for (; i + 16 <= total_size; i += 16) {\n        uint8x16_t a = vld1q_u8(A + i);\n        uint8x16_t b = vld1q_u8(B + i);\n        uint8x16_t equal = vceqq_u8(a, b);\n        \n        uint8x8_t low = vget_low_u8(equal);\n        uint8x8_t high = vget_high_u8(equal);\n        \n        uint16x8_t sum16 = vaddl_u8(low, high);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        count_vec = vaddq_u32(count_vec, sum32);\n    }\n\n    uint32_t temp[4];\n    vst1q_u32(temp, count_vec);\n    count = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < total_size; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n\n    // Process 16 elements at a time\n    for (; i + 15 < total_size; i += 16) {\n        uint8x16_t a = vld1q_u8(A + i);\n        uint8x16_t b = vld1q_u8(B + i);\n        \n        uint8x16_t equal = vceqq_u8(a, b);\n        \n        uint8x8_t sum_low = vget_low_u8(equal);\n        uint8x8_t sum_high = vget_high_u8(equal);\n        \n        uint16x8_t sum16 = vaddl_u8(sum_low, sum_high);\n        uint32x4_t sum32_low = vaddl_u16(vget_low_u16(sum16), vget_high_u16(sum16));\n        \n        count_vec = vaddq_u32(count_vec, sum32_low);\n    }\n\n    // Sum up the vector elements\n    uint32_t temp[4];\n    vst1q_u32(temp, count_vec);\n    count = temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    uint32x4_t count_vec = vdupq_n_u32(0);\n\n    // Process 16 elements at a time\n    for (; i + 15 < total_size; i += 16) {\n        uint8x16_t a = vld1q_u8(A + i);\n        uint8x16_t b = vld1q_u8(B + i);\n        \n        uint8x16_t equal = vceqq_u8(a, b);\n        \n        uint8x8_t sum_low = vget_low_u8(equal);\n        uint8x8_t sum_high = vget_high_u8(equal);\n        \n        uint16x8_t sum16 = vaddl_u8(sum_low, sum_high);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        count_vec = vaddq_u32(count_vec, sum32);\n    }\n\n    // Sum up the vector elements\n    uint32_t temp[4];\n    vst1q_u32(temp, count_vec);\n    count = temp[0] + temp[1] + temp[2] + temp[3];\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n    \n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        \n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vy_abs = vabsq_s64(vy);\n        int64x2_t result = vsubq_s64(vax, vy_abs);\n        \n        vst1q_s64(&y[i], result);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n    \n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        \n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vy_abs = vabsq_s64(vy);\n        int64x2_t result = vsubq_s64(vax, vy_abs);\n        \n        vst1q_s64(&y[i], result);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n    \n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        \n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabs_y = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabs_y);\n        \n        vst1q_s64(&y[i], vresult);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n    \n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        \n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vy_abs = vabsq_s64(vy);\n        int64x2_t result = vsubq_s64(vax, vy_abs);\n        \n        vst1q_s64(&y[i], result);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t va = vdupq_n_s64(a);\n    \n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        \n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vy_abs = vabsq_s64(vy);\n        int64x2_t result = vsubq_s64(vax, vy_abs);\n        \n        vst1q_s64(&y[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Load first 8 elements\n    int16x8_t current = vld1q_s16(vec);\n    int16x8_t min_vec = current;\n    int16x8_t max_vec = current;\n    \n    // Process 8 elements at a time\n    for(size_t i = 8; i < length - 7; i += 8) {\n        current = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, current);\n        max_vec = vmaxq_s16(max_vec, current);\n    }\n    \n    // Find min/max across vector elements\n    int16x4_t min_fold = vpmin_s16(vget_low_s16(min_vec), vget_high_s16(min_vec));\n    min_fold = vpmin_s16(min_fold, min_fold);\n    min_fold = vpmin_s16(min_fold, min_fold);\n    \n    int16x4_t max_fold = vpmax_s16(vget_low_s16(max_vec), vget_high_s16(max_vec));\n    max_fold = vpmax_s16(max_fold, max_fold);\n    max_fold = vpmax_s16(max_fold, max_fold);\n    \n    result.min_num = vget_lane_s16(min_fold, 0);\n    result.max_num = vget_lane_s16(max_fold, 0);\n    \n    // Handle remaining elements\n    for(size_t i = (length/8)*8; i < length; i++) {\n        if(vec[i] < result.min_num) result.min_num = vec[i];\n        if(vec[i] > result.max_num) result.max_num = vec[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmax = vld1q_s16(vec);\n    int16x8_t vmin = vmax;\n    \n    size_t i;\n    for (i = 8; i + 7 < length; i += 8) {\n        int16x8_t vcur = vld1q_s16(vec + i);\n        vmax = vmaxq_s16(vmax, vcur);\n        vmin = vminq_s16(vmin, vcur);\n    }\n\n    int16_t max_val = vgetq_lane_s16(vmax, 0);\n    int16_t min_val = vgetq_lane_s16(vmin, 0);\n    \n    for (int j = 1; j < 8; j++) {\n        int16_t cur_max = vgetq_lane_s16(vmax, j);\n        int16_t cur_min = vgetq_lane_s16(vmin, j);\n        max_val = max_val > cur_max ? max_val : cur_max;\n        min_val = min_val < cur_min ? min_val : cur_min;\n    }\n\n    for (; i < length; i++) {\n        max_val = max_val > vec[i] ? max_val : vec[i];\n        min_val = min_val < vec[i] ? min_val : vec[i];\n    }\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Load first 8 elements\n    int16x8_t current = vld1q_s16(vec);\n    int16x8_t min_vec = current;\n    int16x8_t max_vec = current;\n    \n    // Process 8 elements at a time\n    for(size_t i = 8; i < length - 7; i += 8) {\n        current = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, current);\n        max_vec = vmaxq_s16(max_vec, current);\n    }\n    \n    // Find min/max across vector elements\n    int16x4_t min_fold = vpmin_s16(vget_low_s16(min_vec), vget_high_s16(min_vec));\n    min_fold = vpmin_s16(min_fold, min_fold);\n    min_fold = vpmin_s16(min_fold, min_fold);\n    \n    int16x4_t max_fold = vpmax_s16(vget_low_s16(max_vec), vget_high_s16(max_vec));\n    max_fold = vpmax_s16(max_fold, max_fold);\n    max_fold = vpmax_s16(max_fold, max_fold);\n    \n    result.min_num = vget_lane_s16(min_fold, 0);\n    result.max_num = vget_lane_s16(max_fold, 0);\n    \n    // Handle remaining elements\n    for(size_t i = (length/8)*8; i < length; i++) {\n        if(vec[i] < result.min_num) result.min_num = vec[i];\n        if(vec[i] > result.max_num) result.max_num = vec[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Load first 8 elements\n    int16x8_t current = vld1q_s16(vec);\n    int16x8_t min_vec = current;\n    int16x8_t max_vec = current;\n    \n    // Process 8 elements at a time\n    for (size_t i = 8; i < length - 7; i += 8) {\n        current = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, current);\n        max_vec = vmaxq_s16(max_vec, current);\n    }\n    \n    // Find min/max from remaining elements\n    int16_t min_arr[8];\n    int16_t max_arr[8];\n    vst1q_s16(min_arr, min_vec);\n    vst1q_s16(max_arr, max_vec);\n    \n    result.min_num = min_arr[0];\n    result.max_num = max_arr[0];\n    \n    for (int i = 1; i < 8; i++) {\n        if (min_arr[i] < result.min_num) result.min_num = min_arr[i];\n        if (max_arr[i] > result.max_num) result.max_num = max_arr[i];\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (length/8)*8; i < length; i++) {\n        if (vec[i] < result.min_num) result.min_num = vec[i];\n        if (vec[i] > result.max_num) result.max_num = vec[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    // Load first 8 elements\n    int16x8_t current = vld1q_s16(vec);\n    int16x8_t min_vec = current;\n    int16x8_t max_vec = current;\n    \n    // Process 8 elements at a time\n    size_t i;\n    for(i = 8; i <= length - 8; i += 8) {\n        current = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, current);\n        max_vec = vmaxq_s16(max_vec, current);\n    }\n    \n    // Find min/max within vectors\n    int16x4_t min_fold = vpmin_s16(vget_low_s16(min_vec), vget_high_s16(min_vec));\n    min_fold = vpmin_s16(min_fold, min_fold);\n    min_fold = vpmin_s16(min_fold, min_fold);\n    \n    int16x4_t max_fold = vpmax_s16(vget_low_s16(max_vec), vget_high_s16(max_vec));\n    max_fold = vpmax_s16(max_fold, max_fold);\n    max_fold = vpmax_s16(max_fold, max_fold);\n    \n    result.min_num = vget_lane_s16(min_fold, 0);\n    result.max_num = vget_lane_s16(max_fold, 0);\n    \n    // Handle remaining elements\n    for(; i < length; i++) {\n        if(vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if(vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n\n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            \n            uint32x4_t comp = vcgtq_s32(next, curr);\n            uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n            \n            if (vminvq_u32(vandq_u32(comp, mask)) == 0) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            \n            uint32x4_t comp = vcgtq_s32(next, curr);\n            uint32x4_t mask = vmvnq_u32(comp);\n            \n            if (vgetq_lane_u32(mask, 0) || \n                vgetq_lane_u32(mask, 1) || \n                vgetq_lane_u32(mask, 2)) {\n                return false;\n            }\n        }\n        \n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n\n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            \n            uint32x4_t comp = vcgtq_s32(next, curr);\n            uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n            \n            if (vgetq_lane_u32(vceqq_u32(comp, mask), 0) == 0 ||\n                vgetq_lane_u32(vceqq_u32(comp, mask), 1) == 0 ||\n                vgetq_lane_u32(vceqq_u32(comp, mask), 2) == 0) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n\n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            \n            uint32x4_t comp = vcgtq_s32(next, curr);\n            uint32x4_t mask = vmvnq_u32(comp);\n            \n            if (vgetq_lane_u32(mask, 0) || \n                vgetq_lane_u32(mask, 1) || \n                vgetq_lane_u32(mask, 2)) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n\n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            int32x4_t curr = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            \n            uint32x4_t comp = vcgtq_s32(next, curr);\n            uint32x4_t mask = vmvnq_u32(comp);\n            \n            if (vgetq_lane_u32(mask, 0) || \n                vgetq_lane_u32(mask, 1) || \n                vgetq_lane_u32(mask, 2)) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Process 4 elements at a time using NEON\n    const size_t simd_width = 4;\n\n    for (size_t i = 0; i < block_size; i++) {\n        for (size_t j = 0; j < block_size; j++) {\n            int ref_val = matrix[i * cols + j];\n            int32x4_t ref_vec = vdupq_n_s32(ref_val);\n\n            for (size_t bi = 0; bi < num_blocks_row; bi++) {\n                for (size_t bj = 0; bj < num_blocks_col; bj++) {\n                    if (bi == 0 && bj == 0) continue;\n\n                    size_t row = bi * block_size + i;\n                    size_t col = bj * block_size + j;\n                    \n                    // Skip first block\n                    if (row < block_size && col < block_size) continue;\n\n                    int curr_val = matrix[row * cols + col];\n                    if (curr_val != ref_val) {\n                        return false;\n                    }\n                }\n            }\n\n            // Process remaining elements in current position across blocks\n            for (size_t bi = 0; bi < num_blocks_row; bi++) {\n                for (size_t bj = 0; bj < num_blocks_col; bj += simd_width) {\n                    if (bi == 0 && bj < simd_width) continue;\n\n                    size_t row = bi * block_size + i;\n                    size_t remaining = num_blocks_col - bj;\n                    if (remaining >= simd_width) {\n                        int32x4_t curr_vec = vld1q_s32(&matrix[row * cols + bj * block_size + j]);\n                        uint32x4_t cmp = vceqq_s32(curr_vec, ref_vec);\n                        if (vgetq_lane_u32(cmp, 0) == 0 || \n                            vgetq_lane_u32(cmp, 1) == 0 ||\n                            vgetq_lane_u32(cmp, 2) == 0 || \n                            vgetq_lane_u32(cmp, 3) == 0) {\n                            return false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Process 4 elements at a time using NEON\n    size_t vec_size = 4;\n    size_t vec_count = block_size * block_size / vec_size;\n    size_t remaining = block_size * block_size % vec_size;\n\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            if (i == 0 && j == 0) continue;\n\n            const int* first_block = matrix;\n            const int* current_block = matrix + (i * block_size * cols + j * block_size);\n\n            // Compare vectors of 4 elements\n            for (size_t k = 0; k < vec_count; k++) {\n                int32x4_t vec1 = vld1q_s32(first_block + k * vec_size);\n                int32x4_t vec2 = vld1q_s32(current_block + k * vec_size);\n                uint32x4_t cmp = vceqq_s32(vec1, vec2);\n                \n                if (vgetq_lane_u32(cmp, 0) == 0 || \n                    vgetq_lane_u32(cmp, 1) == 0 ||\n                    vgetq_lane_u32(cmp, 2) == 0 || \n                    vgetq_lane_u32(cmp, 3) == 0) {\n                    return false;\n                }\n            }\n\n            // Handle remaining elements\n            for (size_t k = vec_count * vec_size; k < block_size * block_size; k++) {\n                if (first_block[k] != current_block[k]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    \n    // Process 4 elements at a time using NEON\n    size_t vec_size = 4;\n    size_t block_elements = block_size * block_size;\n    \n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) continue;\n            \n            const int* first_block = matrix;\n            const int* curr_block = matrix + (block_row * block_size * cols + block_col * block_size);\n            \n            for (size_t i = 0; i < block_size; i++) {\n                size_t j = 0;\n                // Process 4 elements at a time\n                for (; j + vec_size <= block_size; j += vec_size) {\n                    int32x4_t first = vld1q_s32(first_block + i * cols + j);\n                    int32x4_t curr = vld1q_s32(curr_block + i * cols + j);\n                    uint32x4_t cmp = vceqq_s32(first, curr);\n                    \n                    // Check if any elements are not equal\n                    if (vminvq_u32(cmp) == 0) {\n                        return false;\n                    }\n                }\n                \n                // Handle remaining elements\n                for (; j < block_size; j++) {\n                    if (first_block[i * cols + j] != curr_block[i * cols + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    \n    // Process 4 elements at a time using NEON\n    size_t vec_size = 4;\n    size_t block_elements = block_size * block_size;\n    \n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) continue;\n            \n            const int* first_block = matrix;\n            const int* curr_block = matrix + block_row * block_size * cols + block_col * block_size;\n            \n            for (size_t i = 0; i < block_size; i++) {\n                size_t j = 0;\n                for (; j + vec_size <= block_size; j += vec_size) {\n                    int32x4_t v1 = vld1q_s32(first_block + i * cols + j);\n                    int32x4_t v2 = vld1q_s32(curr_block + i * cols + j);\n                    uint32x4_t cmp = vceqq_s32(v1, v2);\n                    if (vminvq_u32(cmp) == 0) {\n                        return false;\n                    }\n                }\n                \n                // Handle remaining elements\n                for (; j < block_size; j++) {\n                    if (first_block[i * cols + j] != curr_block[i * cols + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Process 4 elements at a time using NEON\n    size_t vec_size = 4;\n    size_t vec_count = block_size * block_size / vec_size;\n    size_t remaining = block_size * block_size % vec_size;\n\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            if (i == 0 && j == 0) continue;\n\n            const int* first_block = matrix;\n            const int* current_block = matrix + (i * block_size * cols + j * block_size);\n\n            // Compare vectors of 4 elements\n            for (size_t k = 0; k < vec_count; k++) {\n                int32x4_t first = vld1q_s32(first_block + k * vec_size);\n                int32x4_t current = vld1q_s32(current_block + k * vec_size);\n                uint32x4_t cmp = vceqq_s32(first, current);\n                \n                if (vgetq_lane_u32(cmp, 0) == 0 || \n                    vgetq_lane_u32(cmp, 1) == 0 ||\n                    vgetq_lane_u32(cmp, 2) == 0 || \n                    vgetq_lane_u32(cmp, 3) == 0) {\n                    return false;\n                }\n            }\n\n            // Handle remaining elements\n            size_t offset = vec_count * vec_size;\n            for (size_t k = 0; k < remaining; k++) {\n                if (first_block[offset + k] != current_block[offset + k]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size * 2)\n        return false;\n\n    // Number of complete blocks\n    size_t num_blocks = length / block_size;\n    \n    // Number of elements we can process with NEON (2 doubles per vector)\n    size_t neon_elements = (block_size / 2) * 2;\n    \n    // If we can't process at least 2 doubles with NEON, fall back\n    if (neon_elements < 2)\n        return false;\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n\n    for (size_t block = 1; block < num_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + (block * block_size);\n        \n        // Process 2 elements at a time using NEON\n        for (size_t i = 0; i < neon_elements; i += 2) {\n            float64x2_t base = vld1q_f64(base_ptr + i);\n            float64x2_t curr = vld1q_f64(curr_ptr + i);\n            \n            float64x2_t diff = vabdq_f64(base, curr);\n            uint64x2_t cmp = vcgtq_f64(diff, tolerance_vec);\n            \n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements in the block\n        for (size_t i = neon_elements; i < block_size; i++) {\n            if (fabs(base_ptr[i] - curr_ptr[i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size || tolerance < 0) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    // Number of 2-element vectors needed per block\n    size_t vectors_per_block = block_size / 2;\n    size_t remainder_per_block = block_size % 2;\n\n    if (vectors_per_block == 0) {\n        return false;\n    }\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n\n    // For each block after the first\n    for (size_t block = 1; block < num_complete_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + (block * block_size);\n\n        // Compare 2 elements at a time using NEON\n        for (size_t i = 0; i < vectors_per_block; i++) {\n            float64x2_t base_vec = vld1q_f64(base_ptr + (i * 2));\n            float64x2_t curr_vec = vld1q_f64(curr_ptr + (i * 2));\n            \n            float64x2_t diff = vabdq_f64(base_vec, curr_vec);\n            uint64x2_t cmp = vcgtq_f64(diff, tolerance_vec);\n            \n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return false;\n            }\n        }\n\n        // Handle remaining element if block_size is odd\n        if (remainder_per_block) {\n            double base_val = base_ptr[block_size - 1];\n            double curr_val = curr_ptr[block_size - 1];\n            if (fabs(base_val - curr_val) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size * 2)\n        return false;\n\n    // Number of complete blocks that can be processed\n    size_t num_blocks = length / block_size;\n    \n    // Number of elements that can be processed using NEON (2 doubles per vector)\n    size_t neon_elements = (block_size / 2) * 2;\n    \n    // Check if we can use NEON\n    if (neon_elements == 0)\n        return false;\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n\n    // For each block after the first\n    for (size_t block = 1; block < num_blocks; block++) {\n        // Compare elements within block using NEON\n        for (size_t i = 0; i < neon_elements; i += 2) {\n            float64x2_t first_block = vld1q_f64(&vec[i]);\n            float64x2_t current_block = vld1q_f64(&vec[block * block_size + i]);\n            \n            float64x2_t diff = vabdq_f64(first_block, current_block);\n            uint64x2_t cmp = vcgtq_f64(diff, tolerance_vec);\n            \n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1))\n                return false;\n        }\n\n        // Handle remaining elements in block\n        for (size_t i = neon_elements; i < block_size; i++) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance)\n                return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size * 2)\n        return false;\n\n    // Number of complete blocks that can be processed\n    size_t num_blocks = length / block_size;\n    \n    // Number of elements that can be processed using NEON (2 doubles per vector)\n    size_t neon_elements = (block_size / 2) * 2;\n    \n    // Check if we can use NEON\n    if (neon_elements == 0)\n        return false;\n\n    float64x2_t tolerance_vec = vdupq_n_f64(tolerance);\n\n    // Process each block\n    for (size_t block = 1; block < num_blocks; block++) {\n        // Compare elements within each block using NEON\n        for (size_t i = 0; i < neon_elements; i += 2) {\n            float64x2_t first_block = vld1q_f64(&vec[i]);\n            float64x2_t current_block = vld1q_f64(&vec[block * block_size + i]);\n            \n            float64x2_t diff = vabdq_f64(first_block, current_block);\n            uint64x2_t cmp = vcgtq_f64(diff, tolerance_vec);\n            \n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1))\n                return false;\n        }\n\n        // Handle remaining elements in block scalar-wise\n        for (size_t i = neon_elements; i < block_size; i++) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance)\n                return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size || tolerance < 0) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    size_t simd_width = 2; // Number of doubles in float64x2_t\n    size_t simd_blocks = block_size / simd_width;\n    size_t remaining = block_size % simd_width;\n\n    float64x2_t vTolerance = vdupq_n_f64(tolerance);\n\n    for (size_t block = 1; block < num_complete_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + block * block_size;\n\n        // Process SIMD blocks\n        for (size_t i = 0; i < simd_blocks; i++) {\n            float64x2_t vBase = vld1q_f64(base_ptr + i * simd_width);\n            float64x2_t vCurr = vld1q_f64(curr_ptr + i * simd_width);\n            \n            float64x2_t vDiff = vabdq_f64(vBase, vCurr);\n            uint64x2_t vCmp = vcgtq_f64(vDiff, vTolerance);\n            \n            if (vgetq_lane_u64(vCmp, 0) || vgetq_lane_u64(vCmp, 1)) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        size_t offset = simd_blocks * simd_width;\n        for (size_t i = 0; i < remaining; i++) {\n            if (fabs(base_ptr[offset + i] - curr_ptr[offset + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared = vmulq_f64(vec, vec);\n            sum = vaddq_f64(sum, squared);\n        }\n        \n        double row_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            row_sum += val * val;\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            sum = vaddq_f64(sum, vmulq_f64(vec, vec));\n        }\n        \n        double row_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            row_sum += val * val;\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared = vmulq_f64(vec, vec);\n            sum = vaddq_f64(sum, squared);\n        }\n        \n        double row_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            row_sum += val * val;\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared = vmulq_f64(vec, vec);\n            sum = vaddq_f64(sum, squared);\n        }\n        \n        double row_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            row_sum += val * val;\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&matrix[i * cols + j]);\n            float64x2_t squared = vmulq_f64(vec, vec);\n            sum = vaddq_f64(sum, squared);\n        }\n        \n        double row_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            row_sum += val * val;\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t vectorized_length = length & ~3;\n    \n    for (i = 0; i < vectorized_length; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t b = vld1q_u32(&B[i]);\n        uint32x4_t result = vorrq_u32(a, b);\n        vst1q_u32(&C[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t vec_length = length / 4;\n    \n    for (i = 0; i < vec_length * 4; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t b = vld1q_u32(&B[i]);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(&C[i], c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t vec_size = length - (length % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t b = vld1q_u32(&B[i]);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(&C[i], c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t vec_size = length / 4;\n    \n    for (i = 0; i < vec_size * 4; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t b = vld1q_u32(&B[i]);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(&C[i], c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 4;\n    \n    for (i = 0; i < vec_size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t b = vld1q_u32(&B[i]);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(&C[i], c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t result = 0;\n    size_t i = 0;\n    \n    int16x8_t sum_squares = vdupq_n_s16(0);\n    int16x8_t sum_products = vdupq_n_s16(0);\n    \n    for (; i + 8 <= length; i += 8) {\n        int8x8_t a = vld1_s8(A + i);\n        int8x8_t b = vld1_s8(B + i);\n        \n        int16x8_t a_16 = vmovl_s8(a);\n        int16x8_t b_16 = vmovl_s8(b);\n        \n        sum_squares = vaddq_s16(sum_squares, vmlaq_s16(vmulq_s16(a_16, a_16), b_16, b_16));\n        sum_products = vaddq_s16(sum_products, vmulq_s16(a_16, b_16));\n    }\n    \n    int16_t squares[8], products[8];\n    vst1q_s16(squares, sum_squares);\n    vst1q_s16(products, sum_products);\n    \n    int64_t sum_sq = 0, sum_prod = 0;\n    for (int j = 0; j < 8; j++) {\n        sum_sq += squares[j];\n        sum_prod += products[j];\n    }\n    \n    for (; i < length; i++) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n    \n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t result = 0;\n    int16x8_t sum_squares = vdupq_n_s16(0);\n    int16x8_t sum_products = vdupq_n_s16(0);\n    \n    size_t i;\n    for (i = 0; i + 8 <= length; i += 8) {\n        int8x8_t a = vld1_s8(A + i);\n        int8x8_t b = vld1_s8(B + i);\n        \n        int16x8_t a16 = vmovl_s8(a);\n        int16x8_t b16 = vmovl_s8(b);\n        \n        sum_squares = vaddq_s16(sum_squares, vmlaq_s16(vmulq_s16(a16, a16), b16, b16));\n        sum_products = vaddq_s16(sum_products, vmulq_s16(a16, b16));\n    }\n    \n    int32x4_t sum_squares_32_low = vmovl_s16(vget_low_s16(sum_squares));\n    int32x4_t sum_squares_32_high = vmovl_s16(vget_high_s16(sum_squares));\n    int32x4_t sum_products_32_low = vmovl_s16(vget_low_s16(sum_products));\n    int32x4_t sum_products_32_high = vmovl_s16(vget_high_s16(sum_products));\n    \n    int64x2_t sum_squares_64 = vpaddlq_s32(vaddq_s32(sum_squares_32_low, sum_squares_32_high));\n    int64x2_t sum_products_64 = vpaddlq_s32(vaddq_s32(sum_products_32_low, sum_products_32_high));\n    \n    result = vgetq_lane_s64(sum_squares_64, 0) + vgetq_lane_s64(sum_squares_64, 1);\n    result -= 2 * (vgetq_lane_s64(sum_products_64, 0) + vgetq_lane_s64(sum_products_64, 1));\n    \n    for (; i < length; i++) {\n        result += A[i] * A[i] + B[i] * B[i] - 2 * A[i] * B[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t result = 0;\n    size_t i;\n    \n    int16x8_t sum_squares = vdupq_n_s16(0);\n    int16x8_t sum_products = vdupq_n_s16(0);\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        int8x8_t a = vld1_s8(A + i);\n        int8x8_t b = vld1_s8(B + i);\n        \n        int16x8_t a_16 = vmovl_s8(a);\n        int16x8_t b_16 = vmovl_s8(b);\n        \n        sum_squares = vaddq_s16(sum_squares, vmlaq_s16(vmulq_s16(a_16, a_16), b_16, b_16));\n        sum_products = vaddq_s16(sum_products, vmulq_s16(a_16, b_16));\n    }\n    \n    int32x4_t sum_squares_32_low = vmovl_s16(vget_low_s16(sum_squares));\n    int32x4_t sum_squares_32_high = vmovl_s16(vget_high_s16(sum_squares));\n    int32x4_t sum_products_32_low = vmovl_s16(vget_low_s16(sum_products));\n    int32x4_t sum_products_32_high = vmovl_s16(vget_high_s16(sum_products));\n    \n    int64x2_t sum_squares_64 = vaddl_s32(vget_low_s32(sum_squares_32_low), vget_high_s32(sum_squares_32_low));\n    sum_squares_64 = vaddw_s32(sum_squares_64, vget_low_s32(sum_squares_32_high));\n    sum_squares_64 = vaddw_s32(sum_squares_64, vget_high_s32(sum_squares_32_high));\n    \n    int64x2_t sum_products_64 = vaddl_s32(vget_low_s32(sum_products_32_low), vget_high_s32(sum_products_32_low));\n    sum_products_64 = vaddw_s32(sum_products_64, vget_low_s32(sum_products_32_high));\n    sum_products_64 = vaddw_s32(sum_products_64, vget_high_s32(sum_products_32_high));\n    \n    int64_t sum_squares_scalar = vgetq_lane_s64(sum_squares_64, 0) + vgetq_lane_s64(sum_squares_64, 1);\n    int64_t sum_products_scalar = vgetq_lane_s64(sum_products_64, 0) + vgetq_lane_s64(sum_products_64, 1);\n    \n    result = sum_squares_scalar - 2 * sum_products_scalar;\n    \n    for (; i < length; i++) {\n        result += A[i] * A[i] + B[i] * B[i] - 2 * A[i] * B[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t result = 0;\n    size_t i = 0;\n    \n    int32x4_t sum_squares = vdupq_n_s32(0);\n    int32x4_t sum_products = vdupq_n_s32(0);\n    \n    for (; i + 15 < length; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        int16x8_t a_low = vmovl_s8(vget_low_s8(a));\n        int16x8_t a_high = vmovl_s8(vget_high_s8(a));\n        int16x8_t b_low = vmovl_s8(vget_low_s8(b));\n        int16x8_t b_high = vmovl_s8(vget_high_s8(b));\n        \n        int32x4_t a_sq_low = vmull_s16(vget_low_s16(a_low), vget_low_s16(a_low));\n        int32x4_t a_sq_high = vmull_s16(vget_high_s16(a_low), vget_high_s16(a_low));\n        int32x4_t b_sq_low = vmull_s16(vget_low_s16(b_low), vget_low_s16(b_low));\n        int32x4_t b_sq_high = vmull_s16(vget_high_s16(b_low), vget_high_s16(b_low));\n        \n        int32x4_t prod_low = vmull_s16(vget_low_s16(a_low), vget_low_s16(b_low));\n        int32x4_t prod_high = vmull_s16(vget_high_s16(a_low), vget_high_s16(b_low));\n        \n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(a_sq_low, a_sq_high));\n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(b_sq_low, b_sq_high));\n        sum_products = vaddq_s32(sum_products, vaddq_s32(prod_low, prod_high));\n        \n        a_sq_low = vmull_s16(vget_low_s16(a_high), vget_low_s16(a_high));\n        a_sq_high = vmull_s16(vget_high_s16(a_high), vget_high_s16(a_high));\n        b_sq_low = vmull_s16(vget_low_s16(b_high), vget_low_s16(b_high));\n        b_sq_high = vmull_s16(vget_high_s16(b_high), vget_high_s16(b_high));\n        \n        prod_low = vmull_s16(vget_low_s16(a_high), vget_low_s16(b_high));\n        prod_high = vmull_s16(vget_high_s16(a_high), vget_high_s16(b_high));\n        \n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(a_sq_low, a_sq_high));\n        sum_squares = vaddq_s32(sum_squares, vaddq_s32(b_sq_low, b_sq_high));\n        sum_products = vaddq_s32(sum_products, vaddq_s32(prod_low, prod_high));\n    }\n    \n    int32_t squares[4], products[4];\n    vst1q_s32(squares, sum_squares);\n    vst1q_s32(products, sum_products);\n    \n    int64_t sum_sq = squares[0] + squares[1] + squares[2] + squares[3];\n    int64_t sum_prod = products[0] + products[1] + products[2] + products[3];\n    \n    for (; i < length; i++) {\n        sum_sq += A[i] * A[i] + B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n    \n    return sum_sq - (2 * sum_prod);\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t result = 0;\n    size_t i = 0;\n    \n    int16x8_t sum_squares = vdupq_n_s16(0);\n    int16x8_t sum_products = vdupq_n_s16(0);\n    \n    for (; i + 8 <= length; i += 8) {\n        int8x8_t a = vld1_s8(A + i);\n        int8x8_t b = vld1_s8(B + i);\n        \n        int16x8_t a16 = vmovl_s8(a);\n        int16x8_t b16 = vmovl_s8(b);\n        \n        sum_squares = vaddq_s16(sum_squares, vmlaq_s16(vmulq_s16(a16, a16), b16, b16));\n        sum_products = vaddq_s16(sum_products, vmulq_s16(a16, b16));\n    }\n    \n    int32x4_t sum_squares_32_low = vmovl_s16(vget_low_s16(sum_squares));\n    int32x4_t sum_squares_32_high = vmovl_s16(vget_high_s16(sum_squares));\n    int32x4_t sum_products_32_low = vmovl_s16(vget_low_s16(sum_products));\n    int32x4_t sum_products_32_high = vmovl_s16(vget_high_s16(sum_products));\n    \n    int64x2_t sum_squares_64 = vaddl_s32(vget_low_s32(sum_squares_32_low), vget_high_s32(sum_squares_32_low));\n    sum_squares_64 = vaddw_s32(sum_squares_64, vget_low_s32(sum_squares_32_high));\n    sum_squares_64 = vaddw_s32(sum_squares_64, vget_high_s32(sum_squares_32_high));\n    \n    int64x2_t sum_products_64 = vaddl_s32(vget_low_s32(sum_products_32_low), vget_high_s32(sum_products_32_low));\n    sum_products_64 = vaddw_s32(sum_products_64, vget_low_s32(sum_products_32_high));\n    sum_products_64 = vaddw_s32(sum_products_64, vget_high_s32(sum_products_32_high));\n    \n    result = vgetq_lane_s64(sum_squares_64, 0) + vgetq_lane_s64(sum_squares_64, 1);\n    result -= 2 * (vgetq_lane_s64(sum_products_64, 0) + vgetq_lane_s64(sum_products_64, 1));\n    \n    for (; i < length; i++) {\n        int16_t a = A[i];\n        int16_t b = B[i];\n        result += a * a + b * b - 2 * a * b;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t vectorized_length = length / 2;\n    \n    for (i = 0; i < vectorized_length * 2; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t vectorized_length = length / 2;\n    \n    for (i = 0; i < vectorized_length * 2; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t vectorized_length = length & ~1UL;\n    \n    for (i = 0; i < vectorized_length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t vec_size = length / 2;\n    \n    for (i = 0; i < vec_size * 2; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t vectorized_length = length / 2;\n    \n    for (i = 0; i < vectorized_length * 2; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vec_size = length - (length % 16);\n    size_t i;\n\n    for (i = 0; i < vec_size; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        uint8x16_t pos_mask = vandq_u8(\n            vreinterpretq_u8_s8(vshrq_n_s8(a, 7)),\n            vreinterpretq_u8_s8(vshrq_n_s8(b, 7))\n        );\n        \n        uint8x16_t neg_mask = vandq_u8(\n            vreinterpretq_u8_s8(vshrq_n_s8(vnegq_s8(a), 7)),\n            vreinterpretq_u8_s8(vshrq_n_s8(vnegq_s8(b), 7))\n        );\n\n        int8x16_t result = vbslq_s8(\n            pos_mask,\n            vdupq_n_s8(1),\n            vbslq_s8(neg_mask, vdupq_n_s8(-1), vdupq_n_s8(0))\n        );\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vec_size = length - (length % 16);\n    size_t i;\n\n    for (i = 0; i < vec_size; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        // Check if both positive (>0)\n        uint8x16_t pos_mask = vandq_u8(\n            vcgtq_s8(a, vdupq_n_s8(0)),\n            vcgtq_s8(b, vdupq_n_s8(0))\n        );\n        \n        // Check if both negative (<0)\n        uint8x16_t neg_mask = vandq_u8(\n            vcltq_s8(a, vdupq_n_s8(0)),\n            vcltq_s8(b, vdupq_n_s8(0))\n        );\n\n        // Convert masks to -1, 0, 1\n        int8x16_t result = vbslq_s8(pos_mask, vdupq_n_s8(1), \n                          vbslq_s8(neg_mask, vdupq_n_s8(-1), \n                                           vdupq_n_s8(0)));\n        \n        vst1q_s8(C + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vec_size = length / 16;\n    size_t remaining = length % 16;\n\n    int8x16_t ones = vdupq_n_s8(1);\n    int8x16_t neg_ones = vdupq_n_s8(-1);\n    int8x16_t zeros = vdupq_n_s8(0);\n\n    for (size_t i = 0; i < vec_size; i++) {\n        int8x16_t a = vld1q_s8(A + i * 16);\n        int8x16_t b = vld1q_s8(B + i * 16);\n\n        uint8x16_t a_pos = vcgtq_s8(a, zeros);\n        uint8x16_t b_pos = vcgtq_s8(b, zeros);\n        uint8x16_t a_neg = vcltq_s8(a, zeros);\n        uint8x16_t b_neg = vcltq_s8(b, zeros);\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vbslq_s8(both_pos, ones, vbslq_s8(both_neg, neg_ones, zeros));\n        vst1q_s8(C + i * 16, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 16; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vec_size = length / 16;\n    size_t remain = length % 16;\n    \n    int8x16_t ones = vdupq_n_s8(1);\n    int8x16_t neg_ones = vdupq_n_s8(-1);\n    int8x16_t zeros = vdupq_n_s8(0);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        int8x16_t a = vld1q_s8(A + i * 16);\n        int8x16_t b = vld1q_s8(B + i * 16);\n        \n        uint8x16_t pos_mask = vandq_u8(vcgtq_s8(a, zeros), vcgtq_s8(b, zeros));\n        uint8x16_t neg_mask = vandq_u8(vcltq_s8(a, zeros), vcltq_s8(b, zeros));\n        \n        int8x16_t result = vbslq_s8(pos_mask, ones, vbslq_s8(neg_mask, neg_ones, zeros));\n        \n        vst1q_s8(C + i * 16, result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size * 16; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    const size_t step = 16;\n    \n    for (i = 0; i + step <= length; i += step) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n        \n        // Check if both positive (>0)\n        uint8x16_t pos_mask = vandq_u8(\n            vcgtq_s8(a, vdupq_n_s8(0)),\n            vcgtq_s8(b, vdupq_n_s8(0))\n        );\n        \n        // Check if both negative (<0)\n        uint8x16_t neg_mask = vandq_u8(\n            vcltq_s8(a, vdupq_n_s8(0)),\n            vcltq_s8(b, vdupq_n_s8(0))\n        );\n        \n        // Set 1 where both positive\n        int8x16_t pos_result = vreinterpretq_s8_u8(pos_mask);\n        \n        // Set -1 where both negative\n        int8x16_t neg_result = vnegq_s8(vreinterpretq_s8_u8(neg_mask));\n        \n        // Combine results\n        int8x16_t result = vorrq_s8(pos_result, neg_result);\n        \n        vst1q_s8(C + i, result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process elements before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    i = midpoint + 1;\n    \n    // Process elements after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n\n    // Process 8 elements at a time before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n\n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle midpoint\n    C[midpoint] = A[midpoint];\n    i = midpoint + 1;\n\n    // Process 8 elements at a time after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n\n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process elements before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    i = midpoint + 1;\n    \n    // Process elements after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a = vld1q_u16(A + i);\n        uint16x8_t b = vld1q_u16(B + i);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(C + i, result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process elements before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process elements after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process elements before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i); \n        uint16x8_t vc = veorq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process elements after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t va = vld1q_u16(A + i);\n        uint16x8_t vb = vld1q_u16(B + i);\n        uint16x8_t vc = vandq_u16(va, vb);\n        vst1q_u16(C + i, vc);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remain = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        size_t idx = i * vec_size;\n        \n        float32x4_t a = vld1q_f32(A + idx);\n        float32x4_t b = vld1q_f32(B + idx);\n        float32x4_t c = vld1q_f32(C + idx);\n        float32x4_t d = vld1q_f32(D + idx);\n\n        uint32x4_t cond1_mask = vreinterpretq_u32_u8(vld1q_u8((uint8_t*)(cond1 + idx)));\n        uint32x4_t cond2_mask = vreinterpretq_u32_u8(vld1q_u8((uint8_t*)(cond2 + idx)));\n\n        float32x4_t result = vbslq_f32(cond1_mask,\n            vbslq_f32(cond2_mask, a, b),\n            vbslq_f32(cond2_mask, c, d));\n\n        vst1q_f32(out + idx, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remain = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        size_t idx = i * vec_size;\n        \n        uint32x4_t mask1 = vld1q_u32((uint32_t*)(cond1 + idx));\n        uint32x4_t mask2 = vld1q_u32((uint32_t*)(cond2 + idx));\n        \n        float32x4_t a = vld1q_f32(A + idx);\n        float32x4_t b = vld1q_f32(B + idx);\n        float32x4_t c = vld1q_f32(C + idx);\n        float32x4_t d = vld1q_f32(D + idx);\n\n        uint32x4_t cond1_and_cond2 = vandq_u32(mask1, mask2);\n        uint32x4_t cond1_and_not_cond2 = vandq_u32(mask1, vmvnq_u32(mask2));\n        uint32x4_t not_cond1_and_cond2 = vandq_u32(vmvnq_u32(mask1), mask2);\n        uint32x4_t not_cond1_and_not_cond2 = vandq_u32(vmvnq_u32(mask1), vmvnq_u32(mask2));\n\n        float32x4_t result = vbslq_f32(cond1_and_cond2, a, \n                                      vbslq_f32(cond1_and_not_cond2, b,\n                                               vbslq_f32(not_cond1_and_cond2, c, d)));\n\n        vst1q_f32(out + idx, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, \n                            const bool* cond1, const bool* cond2, float* out,\n                            size_t dim1, size_t dim2, size_t dim3) {\n    \n    const size_t total_elements = dim1 * dim2 * dim3;\n    const size_t simd_size = 4;\n    const size_t simd_elements = total_elements - (total_elements % simd_size);\n\n    for (size_t i = 0; i < simd_elements; i += simd_size) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        uint32x4_t cond1_mask = vreinterpretq_u32_u8(vld1q_u8((uint8_t*)(cond1 + i)));\n        uint32x4_t cond2_mask = vreinterpretq_u32_u8(vld1q_u8((uint8_t*)(cond2 + i)));\n\n        float32x4_t result = vbslq_f32(cond1_mask,\n                                      vbslq_f32(cond2_mask, a, b),\n                                      vbslq_f32(cond2_mask, c, d));\n\n        vst1q_f32(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_elements; i < total_elements; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, \n                            const bool* cond1, const bool* cond2, float* out,\n                            size_t dim1, size_t dim2, size_t dim3) {\n    \n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remain = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        size_t idx = i * vec_size;\n        \n        // Load 4 elements from each array\n        float32x4_t a = vld1q_f32(A + idx);\n        float32x4_t b = vld1q_f32(B + idx);\n        float32x4_t c = vld1q_f32(C + idx);\n        float32x4_t d = vld1q_f32(D + idx);\n\n        // Load conditions and convert to 32-bit integers\n        uint32x4_t cond1_vec = vreinterpretq_u32_u8(vcreate_u8(\n            *(uint32_t*)(cond1 + idx)));\n        uint32x4_t cond2_vec = vreinterpretq_u32_u8(vcreate_u8(\n            *(uint32_t*)(cond2 + idx)));\n\n        // Create masks based on conditions\n        uint32x4_t mask1 = cond1_vec;\n        uint32x4_t mask2 = cond2_vec;\n\n        // Select between A and B based on cond2 when cond1 is true\n        float32x4_t sel1 = vbslq_f32(mask2, a, b);\n        \n        // Select between C and D based on cond2 when cond1 is false\n        float32x4_t sel2 = vbslq_f32(mask2, c, d);\n        \n        // Final selection based on cond1\n        float32x4_t result = vbslq_f32(mask1, sel1, sel2);\n        \n        // Store result\n        vst1q_f32(out + idx, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remaining = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        size_t idx = i * vec_size;\n        \n        uint32x4_t cond1_vec = vld1q_u32((uint32_t*)(cond1 + idx));\n        uint32x4_t cond2_vec = vld1q_u32((uint32_t*)(cond2 + idx));\n        float32x4_t a_vec = vld1q_f32(A + idx);\n        float32x4_t b_vec = vld1q_f32(B + idx);\n        float32x4_t c_vec = vld1q_f32(C + idx);\n        float32x4_t d_vec = vld1q_f32(D + idx);\n\n        uint32x4_t mask1 = cond1_vec;\n        uint32x4_t mask2 = cond2_vec;\n        \n        float32x4_t result = vbslq_f32(mask1,\n            vbslq_f32(mask2, a_vec, b_vec),\n            vbslq_f32(mask2, c_vec, d_vec));\n\n        vst1q_f32(out + idx, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        out[i] = cond1[i] ? (cond2[i] ? A[i] : B[i]) : (cond2[i] ? C[i] : D[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remain = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        uint32x4_t input = vld1q_u32(&A[i * vec_size]);\n        \n        // Count bits using parallel bit counting algorithm\n        uint32x4_t mask1 = vdupq_n_u32(0x55555555);\n        uint32x4_t mask2 = vdupq_n_u32(0x33333333);\n        uint32x4_t mask3 = vdupq_n_u32(0x0F0F0F0F);\n        \n        uint32x4_t x = input;\n        x = vsubq_u32(x, vandq_u32(vshrq_n_u32(x, 1), mask1));\n        x = vaddq_u32(vandq_u32(x, mask2), vandq_u32(vshrq_n_u32(x, 2), mask2));\n        x = vandq_u32(vaddq_u32(x, vshrq_n_u32(x, 4)), mask3);\n        x = vaddq_u32(x, vshrq_n_u32(x, 8));\n        x = vaddq_u32(x, vshrq_n_u32(x, 16));\n        x = vandq_u32(x, vdupq_n_u32(0x3F));\n        \n        // Convert to 8-bit and store\n        uint16x4_t narrow16 = vmovn_u32(x);\n        uint8x8_t narrow8 = vmovn_u16(vcombine_u16(narrow16, narrow16));\n        vst1_lane_u8(&out[i * vec_size], narrow8, 0);\n        vst1_lane_u8(&out[i * vec_size + 1], narrow8, 1);\n        vst1_lane_u8(&out[i * vec_size + 2], narrow8, 2);\n        vst1_lane_u8(&out[i * vec_size + 3], narrow8, 3);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        out[i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remain = total_size % vec_size;\n    \n    for (size_t i = 0; i < vec_count; i++) {\n        uint32x4_t a = vld1q_u32(A + i * vec_size);\n        \n        // Count bits using parallel bit counting algorithm\n        uint32x4_t mask1 = vdupq_n_u32(0x55555555);\n        uint32x4_t mask2 = vdupq_n_u32(0x33333333);\n        uint32x4_t mask3 = vdupq_n_u32(0x0F0F0F0F);\n        \n        uint32x4_t x = vshrq_n_u32(a, 1);\n        x = vandq_u32(x, mask1);\n        a = vsubq_u32(a, x);\n        \n        x = vshrq_n_u32(a, 2);\n        x = vandq_u32(x, mask2);\n        a = vandq_u32(a, mask2);\n        a = vaddq_u32(a, x);\n        \n        x = vshrq_n_u32(a, 4);\n        a = vaddq_u32(a, x);\n        a = vandq_u32(a, mask3);\n        \n        x = vshrq_n_u32(a, 8);\n        a = vaddq_u32(a, x);\n        \n        x = vshrq_n_u32(a, 16);\n        a = vaddq_u32(a, x);\n        \n        a = vandq_u32(a, vdupq_n_u32(0x3F));\n        \n        // Convert to uint8\n        uint16x4_t narrow16 = vmovn_u32(a);\n        uint8x8_t narrow8 = vmovn_u16(vcombine_u16(narrow16, narrow16));\n        \n        vst1_lane_u8(out + i * vec_size, narrow8, 0);\n        vst1_lane_u8(out + i * vec_size + 1, narrow8, 1);\n        vst1_lane_u8(out + i * vec_size + 2, narrow8, 2);\n        vst1_lane_u8(out + i * vec_size + 3, narrow8, 3);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        out[i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remaining = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        uint32x4_t input = vld1q_u32(A + i * vec_size);\n        \n        // Count bits using parallel bit counting algorithm\n        uint32x4_t mask1 = vdupq_n_u32(0x55555555);\n        uint32x4_t mask2 = vdupq_n_u32(0x33333333);\n        uint32x4_t mask3 = vdupq_n_u32(0x0F0F0F0F);\n        \n        uint32x4_t count = vshrq_n_u32(vandq_u32(input, mask1), 0);\n        count = vaddq_u32(count, vshrq_n_u32(vandq_u32(input, vshlq_n_u32(mask1, 1)), 1));\n        \n        count = vandq_u32(vaddq_u32(count, vshrq_n_u32(count, 2)), mask2);\n        count = vaddq_u32(count, vshrq_n_u32(count, 4));\n        count = vandq_u32(count, mask3);\n        \n        count = vaddq_u32(count, vshrq_n_u32(count, 8));\n        count = vaddq_u32(count, vshrq_n_u32(count, 16));\n        count = vandq_u32(count, vdupq_n_u32(0x3F));\n\n        // Convert to uint8\n        uint16x4_t narrow16 = vmovn_u32(count);\n        uint8x8_t narrow8 = vmovn_u16(vcombine_u16(narrow16, narrow16));\n        \n        vst1_lane_u8(out + i * vec_size, narrow8, 0);\n        vst1_lane_u8(out + i * vec_size + 1, narrow8, 1);\n        vst1_lane_u8(out + i * vec_size + 2, narrow8, 2);\n        vst1_lane_u8(out + i * vec_size + 3, narrow8, 3);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        val = (val & 0x55555555) + ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val & 0x0F0F0F0F) + ((val >> 4) & 0x0F0F0F0F);\n        val = (val & 0x00FF00FF) + ((val >> 8) & 0x00FF00FF);\n        val = (val & 0x0000FFFF) + ((val >> 16) & 0x0000FFFF);\n        out[i] = (uint8_t)val;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remaining = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        uint32x4_t input = vld1q_u32(&A[i * vec_size]);\n        \n        // Count bits using parallel bit counting algorithm\n        uint32x4_t mask1 = vdupq_n_u32(0x55555555);\n        uint32x4_t mask2 = vdupq_n_u32(0x33333333);\n        uint32x4_t mask3 = vdupq_n_u32(0x0F0F0F0F);\n        \n        uint32x4_t x = input;\n        x = vshrq_n_u32(x, 1) & mask1;\n        input = input & mask1;\n        input = vaddq_u32(input, x);\n        \n        x = vshrq_n_u32(input, 2) & mask2;\n        input = input & mask2;\n        input = vaddq_u32(input, x);\n        \n        x = vshrq_n_u32(input, 4) & mask3;\n        input = input & mask3;\n        input = vaddq_u32(input, x);\n        \n        input = vaddq_u32(input, vshrq_n_u32(input, 8));\n        input = vaddq_u32(input, vshrq_n_u32(input, 16));\n        input = vandq_u32(input, vdupq_n_u32(0x3F));\n        \n        // Convert to 8-bit and store\n        uint16x4_t narrow16 = vmovn_u32(input);\n        uint8x8_t narrow8 = vmovn_u16(vcombine_u16(narrow16, narrow16));\n        vst1_lane_u8(&out[i * vec_size], narrow8, 0);\n        vst1_lane_u8(&out[i * vec_size + 1], narrow8, 1);\n        vst1_lane_u8(&out[i * vec_size + 2], narrow8, 2);\n        vst1_lane_u8(&out[i * vec_size + 3], narrow8, 3);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        out[i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = 4;\n    size_t vec_count = total_size / vec_size;\n    size_t remain = total_size % vec_size;\n\n    for (size_t i = 0; i < vec_count; i++) {\n        uint32x4_t a = vld1q_u32(A + i * vec_size);\n        \n        // Count bits using parallel add approach\n        uint32x4_t cnt = vcntq_u32(a);\n        \n        // Narrow 32-bit counts to 8-bit\n        uint16x4_t cnt16 = vmovn_u32(cnt);\n        uint8x8_t cnt8 = vmovn_u16(vcombine_u16(cnt16, cnt16));\n        \n        // Store lower 4 bytes\n        vst1_lane_u8(out + i * vec_size, cnt8, 0);\n        vst1_lane_u8(out + i * vec_size + 1, cnt8, 1);\n        vst1_lane_u8(out + i * vec_size + 2, cnt8, 2);\n        vst1_lane_u8(out + i * vec_size + 3, cnt8, 3);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_count * vec_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        out[i] = (uint8_t)__builtin_popcount(val);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    const size_t step = 4;\n    size_t total = rows * cols;\n    size_t i = 0;\n\n    for (; i + step <= total; i += step) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        \n        // Create vector of 3s\n        int32x4_t threes = vdupq_n_s32(3);\n        \n        // Calculate remainder when divided by 3\n        int32x4_t remainder = vmodq_s32(a, threes);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        uint32x4_t mask = vceqzq_s32(remainder);\n        \n        // Get absolute values\n        int32x4_t abs_a = vabsq_s32(a);\n        \n        // Select between original and absolute based on mask\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n        \n        // Store result\n        vst1q_s32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    const size_t step = 4;\n    size_t total = rows * cols;\n    size_t i = 0;\n\n    int32x4_t three = vdupq_n_s32(3);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (; i + step <= total; i += step) {\n        int32x4_t a = vld1q_s32(A + i);\n        \n        // Calculate remainder when divided by 3\n        int32x4_t quotient = vdivq_s32(a, three);\n        int32x4_t remainder = vsubq_s32(a, vmulq_s32(quotient, three));\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        uint32x4_t mask = vceqq_s32(remainder, zero);\n        \n        // Get absolute values\n        int32x4_t abs_a = vabsq_s32(a);\n        \n        // Select between original and absolute based on mask\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n        \n        vst1q_s32(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < total; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    const size_t step = 4;\n    size_t total = rows * cols;\n    size_t i = 0;\n\n    for (; i + step <= total; i += step) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        \n        // Create vector of 3s\n        int32x4_t threes = vdupq_n_s32(3);\n        \n        // Calculate remainder when divided by 3\n        int32x4_t remainder = vmodq_s32(a, threes);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        uint32x4_t mask = vceqzq_s32(remainder);\n        \n        // Get absolute values\n        int32x4_t abs_a = vabsq_s32(a);\n        \n        // Select between original and absolute based on mask\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n        \n        // Store result\n        vst1q_s32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    const size_t step = 4;\n    size_t total = rows * cols;\n    size_t i = 0;\n\n    for (; i + step <= total; i += step) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        \n        // Create vector of 3s\n        int32x4_t threes = vdupq_n_s32(3);\n        \n        // Calculate remainders when divided by 3\n        int32x4_t remainders = vmodq_s32(a, threes);\n        \n        // Create mask where remainder is 0 (divisible by 3)\n        uint32x4_t mask = vceqzq_s32(remainders);\n        \n        // Get absolute values\n        int32x4_t abs_a = vabsq_s32(a);\n        \n        // Select between original and absolute based on mask\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n        \n        // Store result\n        vst1q_s32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < total; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    const size_t step = 4;\n    size_t total = rows * cols;\n    size_t i = 0;\n    \n    for (; i + step <= total; i += step) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        int32x4_t three = vdupq_n_s32(3);\n        int32x4_t zero = vdupq_n_s32(0);\n        \n        // Calculate remainder when divided by 3\n        int32x4_t quotient = vdivq_s32(a, three);\n        int32x4_t product = vmulq_s32(quotient, three);\n        int32x4_t remainder = vsubq_s32(a, product);\n        \n        // Create mask for divisible by 3\n        uint32x4_t mask = vceqq_s32(remainder, zero);\n        \n        // Calculate absolute values\n        int32x4_t abs_a = vabsq_s32(a);\n        \n        // Select between original and absolute based on mask\n        int32x4_t result = vbslq_s32(mask, abs_a, a);\n        \n        vst1q_s32(&B[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < total; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    const size_t step = 4;\n    size_t i;\n    \n    for (i = 0; i <= length - step; i += step) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        uint32x4_t mask = vandq_u32(src_vec, vdupq_n_u32(0xF));\n        uint32x4_t cmp = vceqq_u32(mask, vdupq_n_u32(0xF));\n        \n        // Prepare rotated values\n        uint32x4_t rot_right = vshrq_n_u32(src_vec, rotate_bits);\n        uint32x4_t rot_left = vshlq_n_u32(src_vec, 32 - rotate_bits);\n        uint32x4_t rotated = vorrq_u32(rot_right, rot_left);\n        \n        // Prepare negated values\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        // Select between rotated and negated based on condition\n        uint32x4_t result = vbslq_u32(cmp, rotated, negated);\n        \n        // Store result\n        vst1q_u32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t mask = vdupq_n_u32(0xF);\n    uint32x4_t compare = vdupq_n_u32(0xF);\n    \n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t condition = vceqq_u32(low_bits, compare);\n        \n        uint32x4_t rotated = vsriq_n_u32(vshlq_n_u32(src_vec, 32 - rotate_bits), \n                                        src_vec, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t mask = vdupq_n_u32(0xF);\n    uint32x4_t compare = vdupq_n_u32(0xF);\n    \n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t condition = vceqq_u32(low_bits, compare);\n        \n        uint32x4_t rotated = vsriq_n_u32(vshlq_n_u32(src_vec, 32 - rotate_bits), \n                                        src_vec, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    const size_t step = 4;\n    size_t i;\n    \n    for (i = 0; i <= length - step; i += step) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        uint32x4_t mask = vandq_u32(src_vec, vdupq_n_u32(0xF));\n        uint32x4_t cmp = vceqq_u32(mask, vdupq_n_u32(0xF));\n        \n        // Perform rotation for elements that match condition\n        uint32x4_t rot_right = vshrq_n_u32(src_vec, rotate_bits);\n        uint32x4_t rot_left = vshlq_n_u32(src_vec, 32 - rotate_bits);\n        uint32x4_t rotated = vorrq_u32(rot_right, rot_left);\n        \n        // Perform bitwise NOT for elements that don't match condition\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        // Select between rotated and negated based on condition\n        uint32x4_t result = vbslq_u32(cmp, rotated, negated);\n        \n        vst1q_u32(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t mask = vdupq_n_u32(0xF);\n    uint32x4_t compare = vdupq_n_u32(0xF);\n    \n    for (i = 0; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t condition = vceqq_u32(low_bits, compare);\n        \n        uint32x4_t rotated = vsriq_n_u32(vshlq_n_u32(src_vec, 32 - rotate_bits), \n                                        src_vec, rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t eps_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_eps_vec = vnegq_f32(eps_vec);\n    float32x4_t ones = vdupq_n_f32(1.0f);\n    float32x4_t neg_ones = vdupq_n_f32(-1.0f);\n    float32x4_t zeros = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(&A[i]);\n        float32x4_t b_vec = vld1q_f32(&B[i]);\n        float32x4_t diff = vsubq_f32(a_vec, b_vec);\n        \n        uint32x4_t gt_mask = vcgtq_f32(diff, eps_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff, neg_eps_vec);\n        \n        float32x4_t result = vbslq_f32(gt_mask, ones, zeros);\n        result = vbslq_f32(lt_mask, neg_ones, result);\n        \n        int8x8_t narrow = vmovn_s16(vcombine_s16(\n            vmovn_s32(vcvtq_s32_f32(result)),\n            vmovn_s32(vcvtq_s32_f32(zeros))\n        ));\n        \n        vst1_s8(&out[i], narrow);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    const size_t step = 4;\n    size_t i;\n    float32x4_t eps_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_eps_vec = vdupq_n_f32(-epsilon);\n    int8x8_t ones = vdup_n_s8(1);\n    int8x8_t neg_ones = vdup_n_s8(-1);\n    int8x8_t zeros = vdup_n_s8(0);\n\n    for (i = 0; i + step <= length; i += step) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t diff = vsubq_f32(a_vec, b_vec);\n        \n        uint32x4_t gt_mask = vcgtq_f32(diff, eps_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff, neg_eps_vec);\n        \n        int8x8_t result = vcreate_s8(0);\n        result = vbsl_s8(vget_low_u8(vreinterpretq_u8_u32(gt_mask)), ones, result);\n        result = vbsl_s8(vget_low_u8(vreinterpretq_u8_u32(lt_mask)), neg_ones, result);\n        result = vbsl_s8(vmvn_u8(vorr_u8(\n            vget_low_u8(vreinterpretq_u8_u32(gt_mask)),\n            vget_low_u8(vreinterpretq_u8_u32(lt_mask))\n        )), zeros, result);\n        \n        vst1_s8(out + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    const size_t step = 4;\n    size_t i = 0;\n    float32x4_t eps_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_eps_vec = vdupq_n_f32(-epsilon);\n    \n    for (; i + step <= length; i += step) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t diff = vsubq_f32(a, b);\n        \n        uint32x4_t gt_eps = vcgtq_f32(diff, eps_vec);\n        uint32x4_t lt_neg_eps = vcltq_f32(diff, neg_eps_vec);\n        \n        int8x8_t result = vcreate_s8(0);\n        result = vset_lane_s8(vgetq_lane_u32(gt_eps, 0) ? 1 : (vgetq_lane_u32(lt_neg_eps, 0) ? -1 : 0), result, 0);\n        result = vset_lane_s8(vgetq_lane_u32(gt_eps, 1) ? 1 : (vgetq_lane_u32(lt_neg_eps, 1) ? -1 : 0), result, 1);\n        result = vset_lane_s8(vgetq_lane_u32(gt_eps, 2) ? 1 : (vgetq_lane_u32(lt_neg_eps, 2) ? -1 : 0), result, 2);\n        result = vset_lane_s8(vgetq_lane_u32(gt_eps, 3) ? 1 : (vgetq_lane_u32(lt_neg_eps, 3) ? -1 : 0), result, 3);\n        \n        vst1_lane_s8(out + i, result, 0);\n        vst1_lane_s8(out + i + 1, result, 1);\n        vst1_lane_s8(out + i + 2, result, 2);\n        vst1_lane_s8(out + i + 3, result, 3);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    const size_t step = 4;\n    size_t i = 0;\n    float32x4_t eps_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_eps_vec = vdupq_n_f32(-epsilon);\n    int8x8_t ones = vdup_n_s8(1);\n    int8x8_t neg_ones = vdup_n_s8(-1);\n    int8x8_t zeros = vdup_n_s8(0);\n\n    for (; i + step <= length; i += step) {\n        float32x4_t a_vec = vld1q_f32(&A[i]);\n        float32x4_t b_vec = vld1q_f32(&B[i]);\n        float32x4_t diff = vsubq_f32(a_vec, b_vec);\n\n        uint32x4_t gt_mask = vcgtq_f32(diff, eps_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff, neg_eps_vec);\n        \n        int8x8_t result;\n        result = vand_s8(vreinterpret_s8_u32(vget_low_u32(gt_mask)), ones);\n        result = vorr_s8(result, vand_s8(vreinterpret_s8_u32(vget_low_u32(lt_mask)), neg_ones));\n        \n        vst1_s8(&out[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float32x4_t eps_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_eps_vec = vnegq_f32(eps_vec);\n    float32x4_t ones = vdupq_n_f32(1.0f);\n    float32x4_t neg_ones = vdupq_n_f32(-1.0f);\n    float32x4_t zeros = vdupq_n_f32(0.0f);\n\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        float32x4_t a_vec = vld1q_f32(&A[i]);\n        float32x4_t b_vec = vld1q_f32(&B[i]);\n        float32x4_t diff = vsubq_f32(a_vec, b_vec);\n        \n        uint32x4_t gt_mask = vcgtq_f32(diff, eps_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff, neg_eps_vec);\n        \n        float32x4_t result = vbslq_f32(gt_mask, ones, zeros);\n        result = vbslq_f32(lt_mask, neg_ones, result);\n        \n        int8x8_t narrow = vmovn_s16(vcombine_s16(\n            vmovn_s32(vcvtq_s32_f32(result)),\n            vmovn_s32(vcvtq_s32_f32(zeros))\n        ));\n        \n        vst1_s8(&out[i], narrow);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v_float = vld1q_f32(&A[i]);\n        int32x4_t v_int = vcvtq_s32_f32(v_float);\n        \n        float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n        \n        uint32x4_t mask_max = vcgtq_f32(v_float, max_float);\n        uint32x4_t mask_min = vcltq_f32(v_float, min_float);\n        \n        v_int = vbslq_s32(mask_max, vdupq_n_s32(INT32_MAX), v_int);\n        v_int = vbslq_s32(mask_min, vdupq_n_s32(INT32_MIN), v_int);\n        \n        vst1q_s32(&B[i], v_int);\n    }\n    \n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v_float = vld1q_f32(&A[i]);\n        int32x4_t v_int = vcvtq_s32_f32(v_float);\n        \n        float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n        \n        uint32x4_t mask_max = vcgtq_f32(v_float, max_float);\n        uint32x4_t mask_min = vcltq_f32(v_float, min_float);\n        \n        v_int = vbslq_s32(mask_max, vdupq_n_s32(INT32_MAX), v_int);\n        v_int = vbslq_s32(mask_min, vdupq_n_s32(INT32_MIN), v_int);\n        \n        vst1q_s32(&B[i], v_int);\n    }\n    \n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v_float = vld1q_f32(&A[i]);\n        int32x4_t v_int = vcvtq_s32_f32(v_float);\n        \n        float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n        \n        uint32x4_t mask_max = vcgtq_f32(v_float, max_float);\n        uint32x4_t mask_min = vcltq_f32(v_float, min_float);\n        \n        v_int = vbslq_s32(mask_max, vdupq_n_s32(INT32_MAX), v_int);\n        v_int = vbslq_s32(mask_min, vdupq_n_s32(INT32_MIN), v_int);\n        \n        vst1q_s32(&B[i], v_int);\n    }\n    \n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v_float = vld1q_f32(&A[i]);\n        int32x4_t v_int = vcvtq_s32_f32(v_float);\n        \n        float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n        \n        uint32x4_t mask_max = vcgtq_f32(v_float, max_float);\n        uint32x4_t mask_min = vcltq_f32(v_float, min_float);\n        \n        v_int = vbslq_s32(mask_max, vdupq_n_s32(INT32_MAX), v_int);\n        v_int = vbslq_s32(mask_min, vdupq_n_s32(INT32_MIN), v_int);\n        \n        vst1q_s32(&B[i], v_int);\n    }\n    \n    for (; i < size; i++) {\n        if (A[i] > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t v_float = vld1q_f32(A + i);\n        int32x4_t v_int = vcvtq_s32_f32(v_float);\n        \n        float32x4_t max_float = vdupq_n_f32((float)INT32_MAX);\n        float32x4_t min_float = vdupq_n_f32((float)INT32_MIN);\n        \n        uint32x4_t mask_max = vcgtq_f32(v_float, max_float);\n        uint32x4_t mask_min = vcltq_f32(v_float, min_float);\n        \n        v_int = vbslq_s32(mask_max, vdupq_n_s32(INT32_MAX), v_int);\n        v_int = vbslq_s32(mask_min, vdupq_n_s32(INT32_MIN), v_int);\n        \n        vst1q_s32(B + i, v_int);\n    }\n    \n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    const size_t step = 4;\n    size_t i = 0;\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    \n    for (; i + step <= size; i += step) {\n        int32x4_t input = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(input);\n        float32x4_t result = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], scaled);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    \n    for (i = 0; i <= size-4; i+=4) {\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t scaled = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], scaled);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    \n    for (i = 0; i <= size-4; i += 4) {\n        int32x4_t int_vec = vld1q_s32(&A[i]);\n        float32x4_t float_vec = vcvtq_f32_s32(int_vec);\n        float32x4_t result = vmulq_f32(float_vec, scale_vec);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        int32x4_t input = vld1q_s32(&A[i]);\n        float32x4_t converted = vcvtq_f32_s32(input);\n        float32x4_t scaled = vmulq_f32(converted, scale_vec);\n        vst1q_f32(&B[i], scaled);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div = vdivq_f32(a, b);\n        int32x4_t result = vcvtnq_s32_f32(div);\n        vst1q_s32(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    size_t step = 4;\n    \n    for (; i + step <= size; i += step) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div = vdivq_f32(a, b);\n        int32x4_t result = vcvtnq_s32_f32(div);\n        vst1q_s32(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div = vdivq_f32(a, b);\n        int32x4_t result = vcvtnq_s32_f32(div);\n        vst1q_s32(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div = vdivq_f32(a, b);\n        int32x4_t result = vcvtnq_s32_f32(div);\n        vst1q_s32(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    \n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div = vdivq_f32(a, b);\n        int32x4_t result = vcvtnq_s32_f32(div);\n        vst1q_s32(&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    float32x4_t max_val = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_val = vdupq_n_f32(-FLT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 3 < size; i += 4) {\n        float64x2_t a0 = vld1q_f64(A + i);\n        float64x2_t a1 = vld1q_f64(A + i + 2);\n        \n        float32x2_t f0 = vcvt_f32_f64(a0);\n        float32x2_t f1 = vcvt_f32_f64(a1);\n        \n        float32x4_t result = vcombine_f32(f0, f1);\n        \n        result = vminq_f32(result, max_val);\n        result = vmaxq_f32(result, min_val);\n        \n        vst1q_f32(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t max_val = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_val = vdupq_n_f32(-FLT_MAX);\n\n    // Process 4 elements at a time\n    for (i = 0; i + 3 < size; i += 4) {\n        // Load 4 doubles into two registers since NEON can only handle 2 doubles at a time\n        float64x2_t in_low = vld1q_f64(A + i);\n        float64x2_t in_high = vld1q_f64(A + i + 2);\n        \n        // Convert doubles to floats\n        float32x2_t float_low = vcvt_f32_f64(in_low);\n        float32x2_t float_high = vcvt_f32_f64(in_high);\n        \n        // Combine into single float32x4_t\n        float32x4_t result = vcombine_f32(float_low, float_high);\n        \n        // Apply min/max bounds\n        result = vminq_f32(result, max_val);\n        result = vmaxq_f32(result, min_val);\n        \n        // Store result\n        vst1q_f32(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x2_t flt_max = vdup_n_f32(FLT_MAX);\n    const float32x2_t flt_min = vdup_n_f32(-FLT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 1 < size; i += 2) {\n        float64x2_t a = vld1q_f64(&A[i]);\n        float32x2_t b = vcvt_f32_f64(a);\n        \n        // Clamp values between -FLT_MAX and FLT_MAX\n        b = vmin_f32(b, flt_max);\n        b = vmax_f32(b, flt_min);\n        \n        vst1_f32(&B[i], b);\n    }\n\n    // Handle remaining element if size is odd\n    if (i < size) {\n        float val = (float)A[i];\n        if (val > FLT_MAX) val = FLT_MAX;\n        if (val < -FLT_MAX) val = -FLT_MAX;\n        B[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x2_t flt_max = vdup_n_f32(FLT_MAX);\n    const float32x2_t flt_min = vdup_n_f32(-FLT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 1 < size; i += 2) {\n        float64x2_t a = vld1q_f64(&A[i]);\n        float32x2_t b = vcvt_f32_f64(a);\n        b = vmin_f32(b, flt_max);\n        b = vmax_f32(b, flt_min);\n        vst1_f32(&B[i], b);\n    }\n\n    // Handle remaining element if size is odd\n    if (i < size) {\n        float val = (float)A[i];\n        if (val > FLT_MAX) val = FLT_MAX;\n        if (val < -FLT_MAX) val = -FLT_MAX;\n        B[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    float32x4_t max_vec = vdupq_n_f32(FLT_MAX);\n    float32x4_t min_vec = vdupq_n_f32(-FLT_MAX);\n\n    // Process 4 elements at a time\n    for (i = 0; i + 3 < size; i += 4) {\n        // Load 4 doubles into two registers since NEON can only handle 2 doubles at a time\n        float64x2_t in_lo = vld1q_f64(A + i);\n        float64x2_t in_hi = vld1q_f64(A + i + 2);\n        \n        // Convert doubles to floats\n        float32x2_t float_lo = vcvt_f32_f64(in_lo);\n        float32x2_t float_hi = vcvt_f32_f64(in_hi);\n        \n        // Combine into single float32x4_t\n        float32x4_t result = vcombine_f32(float_lo, float_hi);\n        \n        // Apply min/max bounds\n        result = vminq_f32(result, max_vec);\n        result = vmaxq_f32(result, min_vec);\n        \n        // Store result\n        vst1q_f32(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        int16x4_t a = vld1_s16(A + i);\n        int32x4_t b = vmovl_s16(a);\n        vst1q_s32(B + i, b);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 4; i += 4) {\n        int16x4_t a = vld1_s16(A + i);\n        int32x4_t b = vmovl_s16(a);\n        vst1q_s32(B + i, b);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    \n    // Process 8 elements per iteration\n    for (i = 0; i + 8 <= size; i += 8) {\n        // Load 8 int16_t values\n        int16x8_t a = vld1q_s16(&A[i]);\n        \n        // Convert lower 4 elements to int32\n        int32x4_t b_low = vmovl_s16(vget_low_s16(a));\n        \n        // Convert upper 4 elements to int32 \n        int32x4_t b_high = vmovl_s16(vget_high_s16(a));\n        \n        // Store results\n        vst1q_s32(&B[i], b_low);\n        vst1q_s32(&B[i + 4], b_high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    \n    // Process 8 elements at a time\n    for (i = 0; i + 8 <= size; i += 8) {\n        int16x8_t a = vld1q_s16(A + i);\n        int32x4_t low = vmovl_s16(vget_low_s16(a));\n        int32x4_t high = vmovl_s16(vget_high_s16(a));\n        vst1q_s32(B + i, low);\n        vst1q_s32(B + i + 4, high);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        int16x4_t a = vld1_s16(A + i);\n        int32x4_t b = vmovl_s16(a);\n        vst1q_s32(B + i, b);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n    int32x4_t vzero_int = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vctrl = vld1q_s32(&control[i]);\n        \n        uint32x4_t mask = vcgtq_s32(vctrl, vzero_int);\n        float32x4_t normalized = vsubq_f32(va, vmin);\n        normalized = vdivq_f32(normalized, vrange);\n        normalized = vminq_f32(normalized, vone);\n        normalized = vmaxq_f32(normalized, vzero);\n        \n        float32x4_t result = vbslq_f32(mask, normalized, va);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n    int32x4_t vzero_int = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vctrl = vld1q_s32(&control[i]);\n        \n        uint32x4_t mask = vcgtq_s32(vctrl, vzero_int);\n        float32x4_t normalized = vsubq_f32(va, vmin);\n        normalized = vdivq_f32(normalized, vrange);\n        normalized = vminq_f32(vone, vmaxq_f32(vzero, normalized));\n        \n        float32x4_t result = vbslq_f32(mask, normalized, va);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n    int32x4_t vzero_int = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vctrl = vld1q_s32(&control[i]);\n        \n        uint32x4_t mask = vcgtq_s32(vctrl, vzero_int);\n        float32x4_t normalized = vsubq_f32(va, vmin);\n        normalized = vdivq_f32(normalized, vrange);\n        normalized = vminq_f32(normalized, vone);\n        normalized = vmaxq_f32(normalized, vzero);\n        \n        float32x4_t result = vbslq_f32(mask, normalized, va);\n        vst1q_f32(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n    int32x4_t vzero_int = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vctrl = vld1q_s32(&control[i]);\n        \n        uint32x4_t mask = vcgtq_s32(vctrl, vzero_int);\n        float32x4_t normalized = vsubq_f32(va, vmin);\n        normalized = vdivq_f32(normalized, vrange);\n        normalized = vminq_f32(vone, vmaxq_f32(vzero, normalized));\n        \n        float32x4_t result = vbslq_f32(mask, normalized, va);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized < 0.0f ? 0.0f : (normalized > 1.0f ? 1.0f : normalized);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    float32x4_t vrange = vsubq_f32(vmax, vmin);\n    float32x4_t vzero = vdupq_n_f32(0.0f);\n    float32x4_t vone = vdupq_n_f32(1.0f);\n    int32x4_t vzero_int = vdupq_n_s32(0);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        float32x4_t va = vld1q_f32(&A[i]);\n        int32x4_t vctrl = vld1q_s32(&control[i]);\n        \n        uint32x4_t mask = vcgtq_s32(vctrl, vzero_int);\n        float32x4_t normalized = vsubq_f32(va, vmin);\n        normalized = vdivq_f32(normalized, vrange);\n        normalized = vminq_f32(normalized, vone);\n        normalized = vmaxq_f32(normalized, vzero);\n        \n        float32x4_t result = vbslq_f32(mask, normalized, va);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t step = 4;\n    size_t main_loop = size - (size % step);\n    \n    for (i = 0; i < main_loop; i += step) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t shifted = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(shifted);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t step = 4;\n    size_t main_loop = size - (size % step);\n    \n    for (i = 0; i < main_loop; i += step) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t shifted = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(shifted);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t step = 4;\n    size_t main_loop = size - (size % step);\n    \n    for (i = 0; i < main_loop; i += step) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t shifted = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(shifted);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t step = 4;\n    size_t main_loop = size - (size % step);\n    \n    for (i = 0; i < main_loop; i += step) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t shifted = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(shifted);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t step = 4;\n    size_t main_loop = size - (size % step);\n    \n    for (i = 0; i < main_loop; i += step) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t shifted = vshrq_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(shifted);\n        float32x4_t result = vsqrtq_f32(f);\n        vst1q_f32(&B[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    \n    // Process 4 elements at a time using NEON\n    for (i = 0; i + 4 <= size; i += 4) {\n        uint32x4_t v = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(v));\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32x2_t v = vld1_dup_u32(&A[i]);\n        vst1_lane_f32(&B[i], vreinterpret_f32_u32(v), 0);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(a));\n    }\n    \n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t vec_size = size - (size % 4);\n    \n    for (i = 0; i < vec_size; i += 4) {\n        uint32x4_t vec = vld1q_u32(&A[i]);\n        vst1q_f32(&B[i], vreinterpretq_f32_u32(vec));\n    }\n    \n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        uint32x4_t int_vec = vld1q_u32(&A[i]);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(&B[i], float_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = *((float*)&A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    \n    // Process 4 elements at a time using NEON\n    for (i = 0; i + 4 <= size; i += 4) {\n        uint32x4_t v = vld1q_u32(A + i);\n        vst1q_f32(B + i, vreinterpretq_f32_u32(v));\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } conv;\n        conv.u = A[i];\n        B[i] = conv.f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const size_t vec_size = 4;\n    size_t i = 1;\n\n    for (; i + vec_size <= size; i += vec_size) {\n        int32x4_t curr = vld1q_s32(&A[i]);\n        int32x4_t prev = vld1q_s32(&A[i-1]);\n        uint32x4_t mask = vld1q_u32((uint32_t*)&cond[i]);\n        \n        int32x4_t diff_vec = vsubq_s32(curr, prev);\n        float32x4_t float_diff = vcvtq_f32_s32(diff_vec);\n        \n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask_ext = vceqq_u32(mask, vdupq_n_u32(1));\n        float32x4_t result = vbslq_f32(mask_ext, float_diff, zero);\n        \n        vst1q_f32(&diff[i], result);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const size_t vec_size = 4;\n    size_t i = 1;\n\n    for (; i + vec_size <= size; i += vec_size) {\n        int32x4_t curr = vld1q_s32(&A[i]);\n        int32x4_t prev = vld1q_s32(&A[i-1]);\n        uint32x4_t mask = vld1q_u32((const uint32_t*)&cond[i]);\n        \n        int32x4_t diff_vec = vsubq_s32(curr, prev);\n        float32x4_t float_diff = vcvtq_f32_s32(diff_vec);\n        \n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t masked = vbslq_f32(mask, float_diff, zero);\n        \n        vst1q_f32(&diff[i], masked);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    // Handle first element\n    diff[0] = 0.0f;\n    \n    if (size < 2) return;\n\n    // Process 4 elements at a time\n    const size_t vec_size = 4;\n    size_t i = 1;\n    \n    for (; i + vec_size <= size; i += vec_size) {\n        // Load current and previous values\n        int32x4_t curr = vld1q_s32(&A[i]);\n        int32x4_t prev = vld1q_s32(&A[i-1]);\n        \n        // Load condition flags\n        uint32x4_t cond_vec = vld1q_u32((const uint32_t*)&cond[i]);\n        \n        // Calculate differences\n        int32x4_t diff_vec = vsubq_s32(curr, prev);\n        \n        // Convert to float\n        float32x4_t float_diff = vcvtq_f32_s32(diff_vec);\n        \n        // Apply condition mask\n        float32x4_t zero = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vceqq_u32(cond_vec, vdupq_n_u32(1));\n        float32x4_t masked_diff = vbslq_f32(mask, float_diff, zero);\n        \n        // Store result\n        vst1q_f32(&diff[i], masked_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    if (size == 1) return;\n\n    const size_t step = 4;\n    size_t i = 1;\n\n    for (; i + step <= size; i += step) {\n        int32x4_t curr = vld1q_s32(&A[i]);\n        int32x4_t prev = vld1q_s32(&A[i-1]);\n        uint32x4_t mask = vld1q_u32((uint32_t*)&cond[i]);\n        \n        int32x4_t diff_i32 = vsubq_s32(curr, prev);\n        float32x4_t diff_f32 = vcvtq_f32_s32(diff_i32);\n        \n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t masked = vbslq_f32(mask, diff_f32, zero);\n        \n        vst1q_f32(&diff[i], masked);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const size_t vec_size = 4;\n    size_t i = 1;\n\n    for (; i + vec_size <= size; i += vec_size) {\n        int32x4_t curr = vld1q_s32(&A[i]);\n        int32x4_t prev = vld1q_s32(&A[i-1]);\n        uint32x4_t mask = vld1q_u32((uint32_t*)&cond[i]);\n        \n        int32x4_t diff_vec = vsubq_s32(curr, prev);\n        float32x4_t float_diff = vcvtq_f32_s32(diff_vec);\n        \n        float32x4_t zero = vdupq_n_f32(0.0f);\n        float32x4_t masked = vbslq_f32(mask, float_diff, zero);\n        \n        vst1q_f32(&diff[i], masked);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 2;\n    size_t main_loop = length - (length % step);\n    \n    uint32x2_t vec_src;\n    uint64x2_t vec_dst;\n    uint64x2_t high_bits = vdupq_n_u64(0xFFFFFFFF00000000);\n    \n    for (i = 0; i < main_loop; i += step) {\n        vec_src = vld1_u32(src + i);\n        vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, high_bits);\n        vst1q_u64(dst + i, vec_dst);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 2;\n    size_t main_loop = length - (length % step);\n    \n    uint32x2_t vec_src;\n    uint64x2_t vec_dst;\n    uint64x2_t high_bits = vdupq_n_u64(0xFFFFFFFF00000000);\n    \n    for (i = 0; i < main_loop; i += step) {\n        vec_src = vld1_u32(src + i);\n        vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, high_bits);\n        vst1q_u64(dst + i, vec_dst);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 2;\n    size_t main_loop = length - (length % step);\n    \n    for (i = 0; i < main_loop; i += step) {\n        uint32x2_t in = vld1_u32(src + i);\n        uint64x2_t widened = vmovl_u32(in);\n        uint64x2_t result = vorrq_u64(widened, vdupq_n_u64(0xFFFFFFFF00000000));\n        vst1q_u64(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    size_t vec_size = length - length % 2;\n    \n    for (i = 0; i < vec_size; i += 2) {\n        uint32x2_t v_src = vld1_u32(src + i);\n        uint64x2_t v_dst = vmovl_u32(v_src);\n        v_dst = vorrq_u64(v_dst, vdupq_n_u64(0xFFFFFFFF00000000));\n        vst1q_u64(dst + i, v_dst);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const size_t step = 2;\n    size_t main_loop = length - (length % step);\n    \n    uint32x2_t vec_src;\n    uint64x2_t vec_dst;\n    uint64x2_t high_bits = vdupq_n_u64(0xFFFFFFFF00000000);\n    \n    for (i = 0; i < main_loop; i += step) {\n        vec_src = vld1_u32(src + i);\n        vec_dst = vmovl_u32(vec_src);\n        vec_dst = vorrq_u64(vec_dst, high_bits);\n        vst1q_u64(dst + i, vec_dst);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    // Process 2 elements at a time\n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        int16x2_t idx = vld1_s16(&index[i]);\n        int64x2_t idx_ext = vmovl_s32(vmovl_s16(idx));\n        \n        // Gather indexed elements\n        float64x2_t v;\n        v[0] = vec[idx_ext[0]];\n        v[1] = vec[idx_ext[1]];\n        \n        sum = vaddq_f64(sum, v);\n    }\n    \n    // Handle remaining element\n    double result = vaddvq_f64(sum);\n    if (i < length) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        int16x2_t idx = vld1_s16(&index[i]);\n        int64x2_t idx_ext = vmovl_s32(vmovl_s16(idx));\n        \n        float64x2_t values = {\n            vec[vgetq_lane_s64(idx_ext, 0)],\n            vec[vgetq_lane_s64(idx_ext, 1)]\n        };\n        \n        sum = vaddq_f64(sum, values);\n    }\n    \n    double final_sum = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        final_sum += vec[index[i]];\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        int16x2_t idx = vld1_s16(&index[i]);\n        int64x2_t idx_ext = vmovl_s32(vmovl_s16(idx));\n        \n        float64x2_t v = {vec[vgetq_lane_s64(idx_ext, 0)],\n                        vec[vgetq_lane_s64(idx_ext, 1)]};\n        \n        sum = vaddq_f64(sum, v);\n    }\n    \n    double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        int16x2_t idx = vld1_s16(&index[i]);\n        int64x2_t idx_ext = vmovl_s32(vmovl_s16(idx));\n        \n        float64x2_t v = {vec[vgetq_lane_s64(idx_ext, 0)],\n                        vec[vgetq_lane_s64(idx_ext, 1)]};\n        \n        sum = vaddq_f64(sum, v);\n    }\n    \n    double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    float64x2_t sum = vdupq_n_f64(0.0);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        int16x2_t idx = vld1_s16(&index[i]);\n        int64x2_t idx_ext = vmovl_s32(vmovl_s16(idx));\n        \n        float64x2_t v = {vec[vgetq_lane_s64(idx_ext, 0)],\n                        vec[vgetq_lane_s64(idx_ext, 1)]};\n        \n        sum = vaddq_f64(sum, v);\n    }\n    \n    double result = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for(size_t i = 0; i < output_size; i++) {\n        for(size_t j = 0; j < output_size; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for(size_t ki = 0; ki < kernel_size; ki++) {\n                for(size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(&input[input_idx]);\n                    float64x2_t kernel_val = vdupq_n_f64(kernel[ki * kernel_size + kj]);\n                    sum = vfmaq_f64(sum, input_vec, kernel_val);\n                }\n            }\n            \n            // ReLU activation\n            float64x2_t zeros = vdupq_n_f64(0.0);\n            sum = vmaxq_f64(sum, zeros);\n            \n            // Store result\n            if(j + 1 < output_size) {\n                vst1q_f64(&output[i * output_size + j], sum);\n            } else {\n                output[i * output_size + j] = vgetq_lane_f64(sum, 0);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for(size_t i = 0; i < output_size; i++) {\n        for(size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for(size_t ki = 0; ki < kernel_size; ki += 2) {\n                for(size_t kj = 0; kj < kernel_size; kj++) {\n                    if(ki + 1 < kernel_size) {\n                        // Load 2 elements from input and kernel\n                        float64x2_t input_vec = vld1q_f64(&input[(i+ki)*input_size + j + kj]);\n                        float64x2_t kernel_vec = vld1q_f64(&kernel[ki*kernel_size + kj]);\n                        \n                        // Multiply and accumulate\n                        sum = vmlaq_f64(sum, input_vec, kernel_vec);\n                    }\n                    else {\n                        // Handle remaining element if kernel_size is odd\n                        output[i*output_size + j] += \n                            input[(i+ki)*input_size + j + kj] * kernel[ki*kernel_size + kj];\n                    }\n                }\n            }\n            \n            // Sum the vector elements\n            double temp[2];\n            vst1q_f64(temp, sum);\n            output[i*output_size + j] = temp[0] + temp[1];\n            \n            // Apply ReLU\n            if(output[i*output_size + j] < 0) {\n                output[i*output_size + j] = 0;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for(size_t i = 0; i < output_size; i++) {\n        for(size_t j = 0; j < output_size; j += 2) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for(size_t ki = 0; ki < kernel_size; ki++) {\n                for(size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    float64x2_t input_vec = vld1q_f64(&input[input_idx]);\n                    float64x2_t kernel_val = vdupq_n_f64(kernel[ki * kernel_size + kj]);\n                    sum = vfmaq_f64(sum, input_vec, kernel_val);\n                }\n            }\n            \n            // ReLU activation\n            float64x2_t zeros = vdupq_n_f64(0.0);\n            sum = vmaxq_f64(sum, zeros);\n            \n            // Store result\n            if(j + 1 < output_size) {\n                vst1q_f64(&output[i * output_size + j], sum);\n            } else {\n                output[i * output_size + j] = vgetq_lane_f64(sum, 0);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for(size_t i = 0; i < output_size; i++) {\n        for(size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for(size_t k = 0; k < kernel_size; k += 2) {\n                for(size_t l = 0; l < kernel_size; l += 2) {\n                    if(k + 1 < kernel_size && l + 1 < kernel_size) {\n                        // Load 2x2 blocks from input and kernel\n                        float64x2_t input1 = vld1q_f64(&input[(i+k)*input_size + j+l]);\n                        float64x2_t input2 = vld1q_f64(&input[(i+k+1)*input_size + j+l]);\n                        float64x2_t kernel1 = vld1q_f64(&kernel[k*kernel_size + l]);\n                        float64x2_t kernel2 = vld1q_f64(&kernel[(k+1)*kernel_size + l]);\n                        \n                        // Multiply and accumulate\n                        sum = vaddq_f64(sum, vmulq_f64(input1, kernel1));\n                        sum = vaddq_f64(sum, vmulq_f64(input2, kernel2));\n                    }\n                    else {\n                        // Handle remaining elements\n                        for(size_t m = k; m < min(k+2, kernel_size); m++) {\n                            for(size_t n = l; n < min(l+2, kernel_size); n++) {\n                                double val = input[(i+m)*input_size + j+n] * kernel[m*kernel_size + n];\n                                sum = vaddq_f64(sum, vdupq_n_f64(val));\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Reduce sum vector\n            double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            \n            // Apply ReLU\n            output[i*output_size + j] = total > 0.0 ? total : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for(size_t i = 0; i < output_size; i++) {\n        for(size_t j = 0; j < output_size; j++) {\n            float64x2_t sum = vdupq_n_f64(0.0);\n            \n            for(size_t ki = 0; ki < kernel_size; ki += 2) {\n                for(size_t kj = 0; kj < kernel_size; kj += 2) {\n                    if(ki + 1 < kernel_size && kj + 1 < kernel_size) {\n                        // Load 2x2 blocks from input and kernel\n                        float64x2_t input1 = vld1q_f64(&input[(i+ki)*input_size + j+kj]);\n                        float64x2_t input2 = vld1q_f64(&input[(i+ki+1)*input_size + j+kj]);\n                        float64x2_t kernel1 = vld1q_f64(&kernel[ki*kernel_size + kj]);\n                        float64x2_t kernel2 = vld1q_f64(&kernel[(ki+1)*kernel_size + kj]);\n                        \n                        // Multiply and accumulate\n                        sum = vaddq_f64(sum, vmulq_f64(input1, kernel1));\n                        sum = vaddq_f64(sum, vmulq_f64(input2, kernel2));\n                    }\n                    else {\n                        // Handle remaining elements\n                        for(size_t k1 = ki; k1 < min(ki+2, kernel_size); k1++) {\n                            for(size_t k2 = kj; k2 < min(kj+2, kernel_size); k2++) {\n                                double val = input[(i+k1)*input_size + j+k2] * kernel[k1*kernel_size + k2];\n                                sum = vaddq_f64(sum, vdupq_n_f64(val));\n                            }\n                        }\n                    }\n                }\n            }\n            \n            // Sum the vector elements\n            double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n            \n            // Apply ReLU\n            output[i*output_size + j] = total > 0 ? total : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    const int vec_size = 2;\n    const int n = numbers.size();\n    float32x2_t threshold_vec = vdup_n_f32(threshold);\n\n    for (int i = 0; i < n-1; i++) {\n        float32x2_t v1 = vdup_n_f32(numbers[i]);\n        \n        for (int j = i+1; j < n; j += vec_size) {\n            int remaining = std::min(vec_size, n-j);\n            \n            float32x2_t v2;\n            if (remaining == 2) {\n                v2 = vld1_f32((const float*)&numbers[j]);\n            } else {\n                v2 = vdup_n_f32(numbers[j]); \n            }\n\n            float32x2_t diff = vabs_f32(vsub_f32(v1, v2));\n            uint32x2_t comp = vclt_f32(diff, threshold_vec);\n            \n            if (vget_lane_u32(comp, 0) || (remaining == 2 && vget_lane_u32(comp, 1))) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    const int vec_size = 2;\n    const int n = numbers.size();\n    \n    float32x2_t threshold_vec = vdup_n_f32(threshold);\n\n    for (int i = 0; i < n-1; i++) {\n        float32x2_t vec1 = vdup_n_f32(numbers[i]);\n        \n        for (int j = i+1; j < n; j += vec_size) {\n            int remaining = n - j;\n            if (remaining >= vec_size) {\n                float32x2_t vec2 = vld1_f32((const float32_t*)&numbers[j]);\n                float32x2_t diff = vabs_f32(vsub_f32(vec1, vec2));\n                uint32x2_t comp = vclt_f32(diff, threshold_vec);\n                if (vget_lane_u32(comp, 0) || vget_lane_u32(comp, 1)) {\n                    return true;\n                }\n            } else {\n                float val = std::abs(numbers[i] - numbers[j]);\n                if (val < threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    const int vec_size = 2;\n    int n = numbers.size();\n    \n    for (int i = 0; i < n-1; i++) {\n        int remaining = n - i - 1;\n        int vec_elements = std::min(remaining, vec_size);\n        \n        float64x2_t v1 = vdupq_n_f64(numbers[i]);\n        \n        for (int j = 0; j < remaining; j += vec_size) {\n            if (j + vec_size <= remaining) {\n                float64x2_t v2 = vld1q_f64(&numbers[i+1+j]);\n                float64x2_t diff = vabdq_f64(v1, v2);\n                uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n                if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                    return true;\n                }\n            } else {\n                for (int k = 0; k < remaining - j; k++) {\n                    if (std::abs(numbers[i] - numbers[i+1+j+k]) < threshold) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    const int vec_size = 2;\n    const int n = numbers.size();\n    \n    float64x2_t thresh_vec = vdupq_n_f64(threshold);\n    \n    for (int i = 0; i < n-1; i++) {\n        float64x2_t v1 = vdupq_n_f64(numbers[i]);\n        \n        for (int j = i+1; j < n; j += vec_size) {\n            int remaining = n - j;\n            if (remaining >= vec_size) {\n                float64x2_t v2 = vld1q_f64(&numbers[j]);\n                float64x2_t diff = vabdq_f64(v1, v2);\n                uint64x2_t mask = vcltq_f64(diff, thresh_vec);\n                if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                    return true;\n                }\n            } else {\n                for (int k = 0; k < remaining; k++) {\n                    if (std::abs(numbers[i] - numbers[j+k]) < threshold) {\n                        return true;\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    const int vec_size = 2;\n    const int n = numbers.size();\n    \n    for (int i = 0; i < n-1; i++) {\n        int j = i + 1;\n        int remaining = n - j;\n        \n        while (remaining >= vec_size) {\n            float64x2_t v1 = vdupq_n_f64(numbers[i]);\n            float64x2_t v2 = vld1q_f64(&numbers[j]);\n            \n            float64x2_t diff = vabdq_f64(v1, v2);\n            uint64x2_t mask = vcltq_f64(diff, vdupq_n_f64(threshold));\n            \n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return true;\n            }\n            \n            j += vec_size;\n            remaining -= vec_size;\n        }\n        \n        // Handle remaining elements\n        while (j < n) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n            j++;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    const int vec_size = 4;\n    int len = operations.size();\n    int running_sum = 0;\n    int i = 0;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n\n    // Process 4 elements at a time\n    for (; i + vec_size <= len; i += vec_size) {\n        int32x4_t vec = vld1q_s32(&operations[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        \n        // Get individual elements to check running sum\n        int32_t sums[4];\n        vst1q_s32(sums, sum_vec);\n        \n        for (int j = 0; j < 4; j++) {\n            running_sum = sums[j];\n            if (running_sum < 0) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    const int step = 4;\n    int len = operations.size();\n    int i = 0;\n    int32_t running_sum = 0;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (; i + step <= len; i += step) {\n        int32x4_t vec = vld1q_s32(&operations[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        \n        int32x4_t partial_sums = vpaddq_s32(sum_vec, sum_vec);\n        partial_sums = vpaddq_s32(partial_sums, partial_sums);\n        running_sum = vgetq_lane_s32(partial_sums, 0);\n        \n        if (running_sum < 0) {\n            return true;\n        }\n    }\n\n    for (; i < len; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    const int vec_size = 4;\n    int len = operations.size();\n    int balance = 0;\n    int i = 0;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    // Process 4 elements at a time\n    for (; i + vec_size <= len; i += vec_size) {\n        int32x4_t vec = vld1q_s32(&operations[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        \n        // Get running sum at each position\n        int32_t sums[4];\n        vst1q_s32(sums, sum_vec);\n        \n        // Check if any position has negative balance\n        for (int j = 0; j < 4; j++) {\n            balance += (j == 0) ? sums[j] : (sums[j] - sums[j-1]);\n            if (balance < 0) {\n                return true;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    const int step = 4;\n    int len = operations.size();\n    int i = 0;\n    int32x4_t running_sum = vdupq_n_s32(0);\n\n    // Process 4 elements at a time\n    for (; i + step <= len; i += step) {\n        int32x4_t vec = vld1q_s32(&operations[i]);\n        running_sum = vaddq_s32(running_sum, vec);\n        \n        // Extract elements to check if any partial sum is negative\n        int32_t sums[4];\n        vst1q_s32(sums, running_sum);\n        if (sums[0] < 0 || sums[1] < 0 || sums[2] < 0 || sums[3] < 0) {\n            return true;\n        }\n    }\n\n    // Handle remaining elements\n    int32_t current_sum = vgetq_lane_s32(running_sum, 3);\n    for (; i < len; i++) {\n        current_sum += operations[i];\n        if (current_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    const int vec_size = 4;\n    int size = operations.size();\n    int balance = 0;\n    int i = 0;\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    \n    for (; i + vec_size <= size; i += vec_size) {\n        int32x4_t vec = vld1q_s32(&operations[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n        \n        int32_t partial_sums[4];\n        vst1q_s32(partial_sums, sum_vec);\n        \n        for (int j = 0; j < vec_size; j++) {\n            balance += operations[i + j];\n            if (balance < 0) {\n                return true;\n            }\n        }\n    }\n\n    for (; i < size; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int size = numbers.size();\n    if (size == 0) return 0.0;\n\n    // Calculate mean first\n    float64x2_t sum = vdupq_n_f64(0.0);\n    for (int i = 0; i < size - 1; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum = vaddq_f64(sum, vec);\n    }\n    \n    // Handle remaining element if odd size\n    double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    if (size % 2) {\n        total += numbers[size - 1];\n    }\n    double mean = total / size;\n\n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t abs_sum = vdupq_n_f64(0.0);\n    \n    for (int i = 0; i < size - 1; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        // Absolute value using max(x,-x)\n        float64x2_t neg_diff = vnegq_f64(diff);\n        float64x2_t abs_diff = vmaxq_f64(diff, neg_diff);\n        abs_sum = vaddq_f64(abs_sum, abs_diff);\n    }\n\n    double abs_total = vgetq_lane_f64(abs_sum, 0) + vgetq_lane_f64(abs_sum, 1);\n    \n    // Handle remaining element if odd size\n    if (size % 2) {\n        abs_total += fabs(numbers[size - 1] - mean);\n    }\n\n    return abs_total / size;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int size = numbers.size();\n    if (size == 0) return 0.0;\n    \n    // Calculate mean first\n    float64x2_t sum = vdupq_n_f64(0.0);\n    for (int i = 0; i < size - 1; i += 2) {\n        float64x2_t vals = vld1q_f64(&numbers[i]);\n        sum = vaddq_f64(sum, vals);\n    }\n    \n    // Handle remaining element if size is odd\n    double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    if (size % 2) {\n        total += numbers[size-1];\n    }\n    double mean = total / size;\n    \n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t abs_sum = vdupq_n_f64(0.0);\n    \n    for (int i = 0; i < size - 1; i += 2) {\n        float64x2_t vals = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vals, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_sum = vaddq_f64(abs_sum, abs_diff);\n    }\n    \n    double abs_total = vgetq_lane_f64(abs_sum, 0) + vgetq_lane_f64(abs_sum, 1);\n    \n    // Handle remaining element if size is odd\n    if (size % 2) {\n        abs_total += std::abs(numbers[size-1] - mean);\n    }\n    \n    return abs_total / size;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    size_t vec_size = n - (n % 2);\n    \n    // Calculate mean\n    float64x2_t sum = vdupq_n_f64(0.0);\n    for (size_t i = 0; i < vec_size; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum = vaddq_f64(sum, vec);\n    }\n    \n    double mean = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    for (size_t i = vec_size; i < n; i++) {\n        mean += numbers[i];\n    }\n    mean /= n;\n    \n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t abs_dev_sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vec_size; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_dev_sum = vaddq_f64(abs_dev_sum, abs_diff);\n    }\n    \n    double mad = vgetq_lane_f64(abs_dev_sum, 0) + vgetq_lane_f64(abs_dev_sum, 1);\n    for (size_t i = vec_size; i < n; i++) {\n        mad += std::fabs(numbers[i] - mean);\n    }\n    \n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    int size = numbers.size();\n    \n    // Calculate mean first\n    float64x2_t sum = vdupq_n_f64(0.0);\n    for (int i = 0; i < size - 1; i += 2) {\n        float64x2_t vals = vld1q_f64(&numbers[i]);\n        sum = vaddq_f64(sum, vals);\n    }\n    \n    // Handle remaining element if odd size\n    double total = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    if (size % 2) {\n        total += numbers[size-1];\n    }\n    double mean = total / size;\n    \n    // Calculate absolute deviations\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t abs_sum = vdupq_n_f64(0.0);\n    \n    for (int i = 0; i < size - 1; i += 2) {\n        float64x2_t vals = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vals, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_sum = vaddq_f64(abs_sum, abs_diff);\n    }\n    \n    double abs_total = vgetq_lane_f64(abs_sum, 0) + vgetq_lane_f64(abs_sum, 1);\n    \n    // Handle remaining element if odd size\n    if (size % 2) {\n        abs_total += fabs(numbers[size-1] - mean);\n    }\n    \n    return abs_total / size;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    size_t vec_size = n - (n % 2);\n    \n    // Calculate mean using NEON\n    float64x2_t sum = vdupq_n_f64(0.0);\n    for (size_t i = 0; i < vec_size; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        sum = vaddq_f64(sum, vec);\n    }\n    \n    double mean = vgetq_lane_f64(sum, 0) + vgetq_lane_f64(sum, 1);\n    \n    // Add remaining elements\n    for (size_t i = vec_size; i < n; i++) {\n        mean += numbers[i];\n    }\n    mean /= n;\n    \n    // Calculate absolute deviations using NEON\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    float64x2_t abs_diff_sum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < vec_size; i += 2) {\n        float64x2_t vec = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(vec, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_diff_sum = vaddq_f64(abs_diff_sum, abs_diff);\n    }\n    \n    double mad = vgetq_lane_f64(abs_diff_sum, 0) + vgetq_lane_f64(abs_diff_sum, 1);\n    \n    // Add remaining elements\n    for (size_t i = vec_size; i < n; i++) {\n        mad += std::fabs(numbers[i] - mean);\n    }\n    \n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = input_size * 2 - 1;\n    std::vector<int> result(output_size);\n\n    // Handle first element\n    result[0] = numbers[0];\n\n    // Process 4 elements at a time using NEON\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    \n    for (size_t i = 1; i + 3 < input_size; i += 4) {\n        // Load 4 input numbers\n        int32x4_t nums = vld1q_s32(&numbers[i]);\n        \n        // Store interleaved values\n        size_t out_idx = i * 2;\n        vst1q_s32(&result[out_idx], delim_vec);\n        vst1q_s32(&result[out_idx + 1], nums);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (input_size / 4) * 4 + 1; i < input_size; i++) {\n        size_t out_idx = i * 2;\n        result[out_idx - 1] = delimeter;\n        result[out_idx] = numbers[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result((numbers.size() * 2) - 1);\n    \n    int i = 0, j = 0;\n    int n = numbers.size();\n    \n    // Process 4 elements at a time using NEON\n    int block_size = 4;\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    \n    for (; i + block_size <= n; i += block_size) {\n        // Load 4 numbers\n        int32x4_t nums = vld1q_s32(&numbers[i]);\n        \n        // Store number and delimiter alternately\n        vst1q_lane_s32(&result[j], nums, 0);\n        vst1q_lane_s32(&result[j+1], delim_vec, 0);\n        vst1q_lane_s32(&result[j+2], nums, 1);\n        vst1q_lane_s32(&result[j+3], delim_vec, 0);\n        vst1q_lane_s32(&result[j+4], nums, 2);\n        vst1q_lane_s32(&result[j+5], delim_vec, 0);\n        vst1q_lane_s32(&result[j+6], nums, 3);\n        \n        if (i + block_size < n) {\n            vst1q_lane_s32(&result[j+7], delim_vec, 0);\n        }\n        \n        j += (block_size * 2);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[j] = numbers[i];\n        if (i < n-1) {\n            result[j+1] = delimeter;\n            j += 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result((numbers.size() * 2) - 1);\n    \n    int i = 0, j = 0;\n    int n = numbers.size();\n    \n    // Process 4 elements at a time using NEON\n    int block_size = 4;\n    int neon_iters = n / block_size;\n    \n    for (; i < neon_iters * block_size; i += block_size) {\n        // Load 4 input numbers\n        int32x4_t input = vld1q_s32(&numbers[i]);\n        \n        // Store first number\n        vst1q_lane_s32(&result[j], input, 0);\n        j++;\n        // Store delimiter\n        result[j++] = delimeter;\n        \n        // Store second number\n        vst1q_lane_s32(&result[j], input, 1);\n        j++;\n        // Store delimiter\n        result[j++] = delimeter;\n        \n        // Store third number\n        vst1q_lane_s32(&result[j], input, 2);\n        j++;\n        // Store delimiter\n        result[j++] = delimeter;\n        \n        // Store fourth number\n        vst1q_lane_s32(&result[j], input, 3);\n        j++;\n        \n        if (i + block_size < n) {\n            result[j++] = delimeter;\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[j++] = numbers[i];\n        if (i < n - 1) {\n            result[j++] = delimeter;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = input_size * 2 - 1;\n    std::vector<int> result(output_size);\n\n    // Handle first element\n    result[0] = numbers[0];\n\n    // Process 4 elements at a time using NEON\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    \n    for (size_t i = 1; i + 3 < input_size; i += 4) {\n        // Load 4 input numbers\n        int32x4_t nums = vld1q_s32(&numbers[i]);\n        \n        // Store interleaved values to result\n        size_t out_idx = i * 2;\n        vst1q_s32(&result[out_idx], delim_vec);\n        vst1q_s32(&result[out_idx + 1], nums);\n    }\n\n    // Handle remaining elements\n    for (size_t i = (input_size / 4) * 4 + 1; i < input_size; i++) {\n        result[i * 2 - 1] = delimeter;\n        result[i * 2] = numbers[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result((numbers.size() * 2) - 1);\n    \n    int i = 0, j = 0;\n    int n = numbers.size();\n    \n    // Process 4 elements at a time using NEON\n    for (; i <= n-4; i+=4, j+=7) {\n        int32x4_t nums = vld1q_s32(&numbers[i]);\n        \n        // Store first number\n        vst1q_lane_s32(&result[j], nums, 0);\n        \n        // Store delimiter\n        result[j+1] = delimeter;\n        \n        // Store second number\n        vst1q_lane_s32(&result[j+2], nums, 1);\n        \n        // Store delimiter\n        result[j+3] = delimeter;\n        \n        // Store third number\n        vst1q_lane_s32(&result[j+4], nums, 2);\n        \n        // Store delimiter\n        result[j+5] = delimeter;\n        \n        // Store fourth number\n        vst1q_lane_s32(&result[j+6], nums, 3);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[j++] = numbers[i];\n        if (i < n-1) {\n            result[j++] = delimeter;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t nums = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, nums);\n        prod_vec = vmulq_s16(prod_vec, nums);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, sum_vec);\n    vst1q_s16(prod_arr, prod_vec);\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int j = 0; j < 8; j++) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t nums = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, nums);\n        prod_vec = vmulq_s16(prod_vec, nums);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, sum_vec);\n    vst1q_s16(prod_arr, prod_vec);\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int j = 0; j < 8; j++) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t nums = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, nums);\n        prod_vec = vmulq_s16(prod_vec, nums);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, sum_vec);\n    vst1q_s16(prod_arr, prod_vec);\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int j = 0; j < 8; j++) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t nums = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, nums);\n        prod_vec = vmulq_s16(prod_vec, nums);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, sum_vec);\n    vst1q_s16(prod_arr, prod_vec);\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int j = 0; j < 8; j++) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        int16x8_t nums = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, nums);\n        prod_vec = vmulq_s16(prod_vec, nums);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    vst1q_s16(sum_arr, sum_vec);\n    vst1q_s16(prod_arr, prod_vec);\n\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (int j = 0; j < 8; j++) {\n        sum += sum_arr[j];\n        product *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); i++) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    // Process 4 elements at a time using NEON\n    const int step = 4;\n    int i = 1;\n    \n    for (; i + step <= numbers.size(); i += step) {\n        // Load 4 consecutive integers into NEON register\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        \n        // Create vector with current max replicated 4 times\n        int32x4_t max_vec = vdupq_n_s32(current_max);\n        \n        // Compare and get maximum between loaded values and current max\n        max_vec = vmaxq_s32(vec, max_vec);\n        \n        // Store results\n        vst1q_s32(&result[i], max_vec);\n        \n        // Update scalar current_max by finding max across vector elements\n        int32_t max_array[4];\n        vst1q_s32(max_array, max_vec);\n        for (int j = 0; j < 4; j++) {\n            current_max = std::max(current_max, max_array[j]);\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    // Process 4 elements at a time using NEON\n    const int step = 4;\n    int i = 1;\n    for (; i + step <= numbers.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        int32x4_t max_vec = vdupq_n_s32(current_max);\n        \n        // Compare with previous max\n        max_vec = vmaxq_s32(max_vec, vec);\n        \n        // Update running max horizontally\n        int32x2_t max_fold = vpmax_s32(vget_low_s32(max_vec), vget_high_s32(max_vec));\n        max_fold = vpmax_s32(max_fold, max_fold);\n        current_max = vget_lane_s32(max_fold, 0);\n        \n        // Store intermediate results\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    // Process 4 elements at a time using NEON\n    const int step = 4;\n    int i = 1;\n    for (; i + step <= numbers.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        int32x4_t max_vec = vdupq_n_s32(current_max);\n        \n        // Compare with running max\n        max_vec = vmaxq_s32(max_vec, vec);\n        \n        // Update running max horizontally\n        int32_t max_array[4];\n        vst1q_s32(max_array, max_vec);\n        \n        for (int j = 0; j < step; j++) {\n            current_max = std::max(current_max, max_array[j]);\n            result[i + j] = current_max;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    result[0] = numbers[0];\n    \n    int i = 0;\n    int current_max = numbers[0];\n    \n    // Process 4 elements at a time using NEON\n    for (; i + 4 <= numbers.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        int32x4_t running_max = vdupq_n_s32(current_max);\n        \n        // Compare each element with running max\n        running_max = vmaxq_s32(vec, running_max);\n        \n        // Store max values\n        vst1q_s32(&result[i], running_max);\n        \n        // Update current max\n        int32_t max_array[4];\n        vst1q_s32(max_array, running_max);\n        current_max = std::max(std::max(max_array[0], max_array[1]), \n                             std::max(max_array[2], max_array[3]));\n    }\n    \n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    // Process 4 elements at a time using NEON\n    int i = 1;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&numbers[i]);\n        int32x4_t max_vec = vdupq_n_s32(current_max);\n        max_vec = vmaxq_s32(max_vec, vec);\n        \n        // Get max across vector elements\n        int32x2_t max_fold = vpmax_s32(vget_low_s32(max_vec), vget_high_s32(max_vec));\n        max_fold = vpmax_s32(max_fold, max_fold);\n        current_max = vget_lane_s32(max_fold, 0);\n        \n        // Store progressive maxima\n        result[i] = vmaxvq_s32(vdupq_n_s32(current_max));\n        max_vec = vmaxq_s32(vdupq_n_s32(result[i]), vec);\n        vst1q_s32(&result[i], max_vec);\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vec_size = 16;\n    size_t vec_iterations = len / vec_size;\n    \n    for(size_t i = 0; i < vec_iterations; i++) {\n        uint8x16_t vec_a = vld1q_u8((uint8_t*)&a[i * vec_size]);\n        uint8x16_t vec_b = vld1q_u8((uint8_t*)&b[i * vec_size]);\n        \n        uint8x16_t xor_result = veorq_u8(vec_a, vec_b);\n        \n        vst1q_u8((uint8_t*)&result[i * vec_size], xor_result);\n    }\n    \n    // Handle remaining elements\n    for(size_t i = vec_iterations * vec_size; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    \n    // Process 16 characters at a time using NEON\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t va = vld1q_u8((uint8_t*)&a[i]);\n        uint8x16_t vb = vld1q_u8((uint8_t*)&b[i]);\n        \n        // Convert '0'/'1' chars to 0/1 values by subtracting '0'\n        va = vsubq_u8(va, vdupq_n_u8('0'));\n        vb = vsubq_u8(vb, vdupq_n_u8('0')); \n        \n        // XOR the values\n        uint8x16_t vr = veorq_u8(va, vb);\n        \n        // Convert back to '0'/'1' chars\n        vr = vaddq_u8(vr, vdupq_n_u8('0'));\n        \n        // Store result\n        vst1q_u8((uint8_t*)&result[i], vr);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vec_size = 16;\n    size_t vec_len = len / vec_size;\n    \n    for(size_t i = 0; i < vec_len * vec_size; i += vec_size) {\n        uint8x16_t va = vld1q_u8((uint8_t*)&a[i]);\n        uint8x16_t vb = vld1q_u8((uint8_t*)&b[i]);\n        \n        uint8x16_t vxor = veorq_u8(va, vb);\n        \n        uint8x16_t v48 = vdupq_n_u8('0');\n        uint8x16_t vres = veorq_u8(vxor, v48);\n        \n        vst1q_u8((uint8_t*)&result[i], vres);\n    }\n    \n    for(size_t i = vec_len * vec_size; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vectorized_len = len / 16;\n    size_t remaining = len % 16;\n    \n    for(size_t i = 0; i < vectorized_len; i++) {\n        uint8x16_t va = vld1q_u8((uint8_t*)&a[i*16]);\n        uint8x16_t vb = vld1q_u8((uint8_t*)&b[i*16]);\n        \n        // Convert '0'/'1' chars to 0/1 by subtracting '0'\n        va = vsubq_u8(va, vdupq_n_u8('0'));\n        vb = vsubq_u8(vb, vdupq_n_u8('0'));\n        \n        // XOR the bits\n        uint8x16_t vresult = veorq_u8(va, vb);\n        \n        // Convert back to '0'/'1' chars\n        vresult = vaddq_u8(vresult, vdupq_n_u8('0'));\n        \n        vst1q_u8((uint8_t*)&result[i*16], vresult);\n    }\n    \n    // Handle remaining elements\n    for(size_t i = len - remaining; i < len; i++) {\n        result[i] = (a[i] ^ b[i]) == 0 ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    \n    // Process 16 characters at a time using NEON\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t va = vld1q_u8((uint8_t*)&a[i]);\n        uint8x16_t vb = vld1q_u8((uint8_t*)&b[i]);\n        \n        // Convert '0'/'1' chars to 0/1 values by subtracting '0'\n        va = vsubq_u8(va, vdupq_n_u8('0'));\n        vb = vsubq_u8(vb, vdupq_n_u8('0'));\n        \n        // XOR the values\n        uint8x16_t vr = veorq_u8(va, vb);\n        \n        // Convert back to '0'/'1' chars\n        vr = vaddq_u8(vr, vdupq_n_u8('0'));\n        \n        // Store result\n        vst1q_u8((uint8_t*)&result[i], vr);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        result[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 lengths at a time using NEON\n    uint32x4_t curr_max = vdupq_n_u32(0);\n    \n    for (size_t i = 0; i < strings.size() - 3; i += 4) {\n        uint32x4_t lens = {\n            (uint32_t)strings[i].length(),\n            (uint32_t)strings[i+1].length(), \n            (uint32_t)strings[i+2].length(),\n            (uint32_t)strings[i+3].length()\n        };\n        \n        uint32x4_t mask = vcgtq_u32(lens, curr_max);\n        curr_max = vbslq_u32(mask, lens, curr_max);\n        \n        // Find index of max length\n        uint32_t max_vals[4];\n        vst1q_u32(max_vals, curr_max);\n        \n        for(int j = 0; j < 4; j++) {\n            if(strings[i+j].length() == max_vals[0] && max_vals[0] > max_len) {\n                max_len = max_vals[0];\n                max_idx = i+j;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (strings.size()/4)*4; i < strings.size(); i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time using NEON\n    size_t vec_size = strings.size();\n    size_t step = 4;\n    size_t i;\n    \n    for (i = 0; i <= vec_size - step; i += step) {\n        uint32x4_t lengths = {\n            (uint32_t)strings[i].length(),\n            (uint32_t)strings[i+1].length(), \n            (uint32_t)strings[i+2].length(),\n            (uint32_t)strings[i+3].length()\n        };\n        \n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t curr_max = vdupq_n_u32(max_len);\n        uint32x4_t curr_idx = vdupq_n_u32(max_idx);\n        \n        uint32x4_t mask = vcgtq_u32(lengths, curr_max);\n        max_len = vmaxvq_u32(lengths);\n        \n        // Update index of max length\n        uint32x4_t selected_indices = vbslq_u32(mask, indices, curr_idx);\n        max_idx = vgetq_lane_u32(selected_indices, 0);\n        for(int j = 1; j < 4; j++) {\n            if(vgetq_lane_u32(lengths, j) == max_len && \n               vgetq_lane_u32(indices, j) < max_idx) {\n                max_idx = vgetq_lane_u32(indices, j);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < vec_size; i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time using NEON\n    size_t vec_size = strings.size();\n    size_t step = 4;\n    size_t i;\n    \n    for (i = 0; i <= vec_size - step; i += step) {\n        uint32x4_t lengths = {\n            (uint32_t)strings[i].length(),\n            (uint32_t)strings[i+1].length(),\n            (uint32_t)strings[i+2].length(), \n            (uint32_t)strings[i+3].length()\n        };\n        \n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t curr_max = vdupq_n_u32(max_len);\n        uint32x4_t curr_idx = vdupq_n_u32(max_idx);\n        \n        uint32x4_t mask = vcgtq_u32(lengths, curr_max);\n        max_len = vmaxvq_u32(lengths);\n        \n        // Update index of max length\n        uint32x4_t selected_indices = vbslq_u32(mask, indices, curr_idx);\n        max_idx = vgetq_lane_u32(selected_indices, 0);\n        for(int j = 1; j < 4; j++) {\n            if(vgetq_lane_u32(lengths, j) == max_len && \n               vgetq_lane_u32(indices, j) < max_idx) {\n                max_idx = vgetq_lane_u32(indices, j);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < vec_size; i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time using NEON\n    size_t vec_size = strings.size() / 4 * 4;\n    for (size_t i = 0; i < vec_size; i += 4) {\n        uint32x4_t lengths = {\n            (uint32_t)strings[i].length(),\n            (uint32_t)strings[i+1].length(), \n            (uint32_t)strings[i+2].length(),\n            (uint32_t)strings[i+3].length()\n        };\n        \n        uint32x4_t indices = {i, i+1, i+2, i+3};\n        uint32x4_t curr_max = vdupq_n_u32(max_len);\n        uint32x4_t curr_idx = vdupq_n_u32(max_idx);\n        \n        uint32x4_t mask = vcgtq_u32(lengths, curr_max);\n        max_len = vmaxvq_u32(lengths);\n        \n        // Find index of max length\n        uint32x4_t selected_indices = vbslq_u32(mask, indices, curr_idx);\n        uint32_t tmp_idx[4];\n        vst1q_u32(tmp_idx, selected_indices);\n        \n        for(int j = 0; j < 4; j++) {\n            if(strings[tmp_idx[j]].length() == max_len) {\n                max_idx = tmp_idx[j];\n                break;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size; i < strings.size(); i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time using NEON\n    for (size_t i = 0; i < strings.size() - 3; i += 4) {\n        uint32x4_t lengths = {\n            (uint32_t)strings[i].length(),\n            (uint32_t)strings[i+1].length(), \n            (uint32_t)strings[i+2].length(),\n            (uint32_t)strings[i+3].length()\n        };\n        \n        uint32_t max_val = vmaxvq_u32(lengths);\n        \n        if (max_val > max_len) {\n            // Find index of max length\n            for (size_t j = 0; j < 4; j++) {\n                if (strings[i+j].length() == max_val) {\n                    max_len = max_val;\n                    max_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (strings.size()/4)*4; i < strings.size(); i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vcombine_u64(vcreate_u64(a), vcreate_u64(a));\n    uint64x2_t vb = vcombine_u64(vcreate_u64(b), vcreate_u64(b));\n    \n    while (vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vt = vb;\n        vb = vandq_u64(va, vsubq_u64(vdupq_n_u64(0), vb));\n        va = vt;\n    }\n    \n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vcombine_u64(vcreate_u64(a), vcreate_u64(a));\n    uint64x2_t vb = vcombine_u64(vcreate_u64(b), vcreate_u64(b));\n    \n    while (vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vt = vb;\n        uint64x2_t vrem = vmodq_u64(va, vb);\n        vb = vrem;\n        va = vt;\n    }\n    \n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vcombine_u64(vcreate_u64(a), vcreate_u64(a));\n    uint64x2_t vb = vcombine_u64(vcreate_u64(b), vcreate_u64(b));\n    \n    while (vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vt = vb;\n        vb = vandq_u64(va, vsubq_u64(vcltq_u64(va, vb), vdupq_n_u64(1)));\n        va = vt;\n        \n        uint64x2_t vmod = vmodq_u64(va, vb);\n        va = vb;\n        vb = vmod;\n    }\n    \n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vcombine_u64(vcreate_u64(a), vcreate_u64(a));\n    uint64x2_t vb = vcombine_u64(vcreate_u64(b), vcreate_u64(b));\n    \n    while (vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vt = vb;\n        vb = vandq_u64(va, vsubq_u64(vcltq_u64(va, vb), vdupq_n_u64(1)));\n        va = vt;\n        \n        uint64x2_t vq = vshrq_n_u64(va, 1);\n        uint64x2_t vr = vsubq_u64(va, vshlq_n_u64(vq, 1));\n        va = vbslq_u64(vceqq_u64(vr, vdupq_n_u64(0)), vq, va);\n    }\n    \n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t va = vcombine_u64(vcreate_u64(a), vcreate_u64(a));\n    uint64x2_t vb = vcombine_u64(vcreate_u64(b), vcreate_u64(b));\n    \n    while (vgetq_lane_u64(vb, 0) != 0) {\n        uint64x2_t vt = vb;\n        uint64x2_t vrem = vmodq_u64(va, vb);\n        vb = vrem;\n        va = vt;\n    }\n    \n    return vgetq_lane_u64(va, 0);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        \n        for (size_t j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabdq_f32(v1, v2);\n            \n            float diffs[4];\n            vst1q_f32(diffs, diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (i + k >= n) break;\n                for (int l = 0; l < 4; l++) {\n                    if (j + l >= n) break;\n                    if (i + k == j + l) continue;\n                    \n                    if (diffs[k] < min_diff) {\n                        min_diff = diffs[k];\n                        num1 = std::min(numbers[i + k], numbers[j + l]);\n                        num2 = std::max(numbers[i + k], numbers[j + l]);\n                    }\n                }\n            }\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        \n        for (size_t j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabdq_f32(v1, v2);\n            \n            float diffs[4];\n            vst1q_f32(diffs, diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (i + k >= n) break;\n                for (int l = 0; l < 4; l++) {\n                    if (j + l >= n) break;\n                    if (i + k == j + l) continue;\n                    \n                    if (diffs[k] < min_diff) {\n                        min_diff = diffs[k];\n                        num1 = std::min(numbers[i + k], numbers[j + l]);\n                        num2 = std::max(numbers[i + k], numbers[j + l]);\n                    }\n                }\n            }\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        \n        for (size_t j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabdq_f32(v1, v2);\n            \n            float diffs[4];\n            vst1q_f32(diffs, diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (i + k >= n) break;\n                for (int l = 0; l < 4; l++) {\n                    if (j + l >= n) break;\n                    if (i + k != j + l && diffs[k] < min_diff) {\n                        min_diff = diffs[k];\n                        num1 = std::min(numbers[i + k], numbers[j + l]);\n                        num2 = std::max(numbers[i + k], numbers[j + l]);\n                    }\n                }\n            }\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        \n        for (size_t j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabdq_f32(v1, v2);\n            \n            float diffs[4];\n            vst1q_f32(diffs, diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (i + k >= n) break;\n                for (int l = 0; l < 4; l++) {\n                    if (j + l >= n) break;\n                    if (i + k == j + l) continue;\n                    \n                    if (diffs[k] < min_diff) {\n                        min_diff = diffs[k];\n                        num1 = std::min(numbers[i + k], numbers[j + l]);\n                        num2 = std::max(numbers[i + k], numbers[j + l]);\n                    }\n                }\n            }\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        \n        for (size_t j = 0; j < n; j += 4) {\n            if (i == j) continue;\n            \n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabdq_f32(v1, v2);\n            \n            float diffs[4];\n            vst1q_f32(diffs, diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (i + k >= n) break;\n                for (int l = 0; l < 4; l++) {\n                    if (j + l >= n) break;\n                    if (i + k == j + l) continue;\n                    \n                    if (diffs[k] < min_diff) {\n                        min_diff = diffs[k];\n                        num1 = std::min(numbers[i + k], numbers[j + l]);\n                        num2 = std::max(numbers[i + k], numbers[j + l]);\n                    }\n                }\n            }\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using NEON\n    float32x4_t vmin = vdupq_n_f32(numbers[0]);\n    float32x4_t vmax = vdupq_n_f32(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Reduce min/max vectors\n    float min_val = std::min(std::min(vgetq_lane_f32(vmin, 0), vgetq_lane_f32(vmin, 1)),\n                            std::min(vgetq_lane_f32(vmin, 2), vgetq_lane_f32(vmin, 3)));\n    float max_val = std::max(std::max(vgetq_lane_f32(vmax, 0), vgetq_lane_f32(vmax, 1)),\n                            std::max(vgetq_lane_f32(vmax, 2), vgetq_lane_f32(vmax, 3)));\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n\n    // Scale factor\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n\n    // Process vectors of 4 elements\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        v = vsubq_f32(v, vmin_val);\n        v = vdivq_f32(v, vrange);\n        vst1q_f32(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using NEON\n    float32x4_t vmin = vdupq_n_f32(numbers[0]);\n    float32x4_t vmax = vdupq_n_f32(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    float min_val = vminvq_f32(vmin);\n    float max_val = vmaxvq_f32(vmax);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return numbers;\n\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n\n    // Apply transformation using NEON\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        v = vsubq_f32(v, vmin_val);\n        v = vdivq_f32(v, vrange);\n        vst1q_f32(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using NEON\n    float32x4_t vmin = vdupq_n_f32(numbers[0]);\n    float32x4_t vmax = vdupq_n_f32(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Reduce min/max across vector\n    float min_val = vminvq_f32(vmin);\n    float max_val = vmaxvq_f32(vmax);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]); \n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return numbers;\n\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n\n    // Process vector elements\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        v = vsubq_f32(v, vmin_val);\n        v = vdivq_f32(v, vrange);\n        vst1q_f32(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using NEON\n    float32x4_t vmin = vdupq_n_f32(numbers[0]);\n    float32x4_t vmax = vdupq_n_f32(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Reduce vectors to get min/max\n    float min_val = vminvq_f32(vmin);\n    float max_val = vmaxvq_f32(vmax);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n\n    // Broadcast min and range\n    float32x4_t vmin_broadcast = vdupq_n_f32(min_val);\n    float32x4_t vrange_broadcast = vdupq_n_f32(range);\n\n    // Process vectors of 4 elements\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        v = vsubq_f32(v, vmin_broadcast);\n        v = vdivq_f32(v, vrange_broadcast);\n        vst1q_f32(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using NEON\n    float32x4_t vmin = vdupq_n_f32(numbers[0]);\n    float32x4_t vmax = vdupq_n_f32(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, v);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    // Reduce vectors to get min/max\n    float min_val = vminvq_f32(vmin);\n    float max_val = vmaxvq_f32(vmax);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return numbers;\n\n    // Create vectors for scaling\n    float32x4_t vrange = vdupq_n_f32(range);\n    float32x4_t vmin_val = vdupq_n_f32(min_val);\n\n    // Process vector elements\n    for (i = 0; i + 4 <= n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        v = vsubq_f32(v, vmin_val);\n        v = vdivq_f32(v, vrange);\n        vst1q_f32(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t half = n/2;\n    uint32x4_t vec_n = vdupq_n_u32(n);\n    uint32x4_t result = vdupq_n_u32(1);\n    \n    for (uint64_t i = 2; i <= half; i += 4) {\n        uint32x4_t vec_nums = {i, i+1, i+2, i+3};\n        uint32x4_t vec_div = vdupq_n_u32(0);\n        \n        // Calculate remainders using vector operations\n        uint32x4_t vec_rem = vshrq_n_u32(vmulq_u32(vec_n, vdupq_n_u32(1)), 32);\n        vec_rem = vsubq_u32(vec_n, vmulq_u32(vec_nums, vec_div));\n        \n        // Check which numbers divide evenly (remainder = 0)\n        uint32x4_t vec_mask = vceqq_u32(vec_rem, vdupq_n_u32(0));\n        \n        // Update result where mask is true and number is larger\n        result = vbslq_u32(vandq_u32(vec_mask, vcgtq_u32(vec_nums, result)), \n                          vec_nums, \n                          result);\n    }\n    \n    // Find maximum across vector elements\n    uint32_t max_divisor = vgetq_lane_u32(result, 0);\n    for (int i = 1; i < 4; i++) {\n        uint32_t val = vgetq_lane_u32(result, i);\n        if (val > max_divisor) max_divisor = val;\n    }\n    \n    // Handle remaining numbers sequentially\n    for (uint64_t i = ((half/4)*4)+1; i <= half; i++) {\n        if (n % i == 0) max_divisor = i;\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint32x4_t vec_n = vdupq_n_u32(n);\n    uint32x4_t divisors = {2,3,4,5};\n    uint32x4_t increment = vdupq_n_u32(4);\n    uint32_t max_divisor = 1;\n    \n    for(uint32_t i = 2; i <= n/2; i+=4) {\n        uint32x4_t quotients = vdivq_u32(vec_n, divisors);\n        uint32x4_t products = vmulq_u32(quotients, divisors);\n        uint32x4_t matches = vceqq_u32(products, vec_n);\n        \n        uint32_t mask = vaddvq_u32(matches);\n        \n        if(mask) {\n            uint32_t values[4];\n            vst1q_u32(values, divisors);\n            \n            for(int j = 0; j < 4; j++) {\n                if(values[j] <= n/2 && n % values[j] == 0) {\n                    max_divisor = values[j];\n                }\n            }\n        }\n        \n        divisors = vaddq_u32(divisors, increment);\n    }\n    \n    // Handle remaining numbers sequentially\n    for(uint32_t i = ((n/2)/4)*4 + 1; i <= n/2; i++) {\n        if(n % i == 0) {\n            max_divisor = i;\n        }\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint32_t limit = sqrt(n);\n    uint32_t largest = 1;\n    \n    uint32x4_t vn = vdupq_n_u32(n);\n    uint32x4_t inc = {0,1,2,3};\n    uint32x4_t vcur = vaddq_u32(vdupq_n_u32(1), inc);\n    \n    for (uint32_t i = 1; i <= limit; i += 4) {\n        uint32x4_t vrem = vreinterpretq_u32_u64(vmodq_u64(\n            vreinterpretq_u64_u32(vn), \n            vreinterpretq_u64_u32(vcur)));\n            \n        uint32x4_t vmask = vceqq_u32(vrem, vdupq_n_u32(0));\n        \n        if (vgetq_lane_u32(vmask, 0))\n            largest = i;\n        if (vgetq_lane_u32(vmask, 1))\n            largest = i+1;\n        if (vgetq_lane_u32(vmask, 2))\n            largest = i+2;\n        if (vgetq_lane_u32(vmask, 3))\n            largest = i+3;\n            \n        vcur = vaddq_u32(vcur, vdupq_n_u32(4));\n    }\n    \n    if (largest == 1)\n        return n;\n        \n    uint64_t result = n / largest;\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint32x4_t vec_n = vdupq_n_u32(n);\n    uint32x4_t vec_div = vld1q_u32((uint32_t[]){2,3,4,5});\n    uint32x4_t vec_inc = vdupq_n_u32(4);\n    uint64_t max_divisor = 1;\n    \n    for(uint32_t i = 2; i <= n/2; i += 4) {\n        uint32x4_t vec_rem = vmodq_u32(vec_n, vec_div);\n        uint32x4_t vec_mask = vceqq_u32(vec_rem, vdupq_n_u32(0));\n        \n        uint32_t mask = vgetq_lane_u32(vec_mask, 0);\n        if(mask) max_divisor = i;\n        \n        mask = vgetq_lane_u32(vec_mask, 1);\n        if(mask) max_divisor = i+1;\n        \n        mask = vgetq_lane_u32(vec_mask, 2);\n        if(mask) max_divisor = i+2;\n        \n        mask = vgetq_lane_u32(vec_mask, 3);\n        if(mask) max_divisor = i+3;\n        \n        vec_div = vaddq_u32(vec_div, vec_inc);\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint32x4_t div = vdupq_n_u32(0);\n    uint32x4_t inc = vdupq_n_u32(4);\n    uint32x4_t nums = {n/2, n/2-1, n/2-2, n/2-3};\n    \n    for(; vgetq_lane_u32(nums, 3) > 1;) {\n        uint32x4_t rem = vdupq_n_u32(n);\n        rem = vmodq_u32(rem, nums);\n        uint32x4_t mask = vceqq_u32(rem, vdupq_n_u32(0));\n        \n        if(vgetq_lane_u32(mask, 0))\n            return vgetq_lane_u32(nums, 0);\n        if(vgetq_lane_u32(mask, 1))\n            return vgetq_lane_u32(nums, 1);\n        if(vgetq_lane_u32(mask, 2))\n            return vgetq_lane_u32(nums, 2);\n        if(vgetq_lane_u32(mask, 3))\n            return vgetq_lane_u32(nums, 3);\n            \n        nums = vsubq_u32(nums, inc);\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle 2 as a special case first\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    // Create vectors for parallel processing\n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t divisors = vcreate_u32(0x0B090705); // Load 4 odd numbers: 5,7,9,11\n    uint32x4_t increment = vdupq_n_u32(8); // Increment by 8 to get next 4 odd numbers\n    \n    int sqrtN = sqrt(n);\n    \n    while (n > 1) {\n        // Check divisibility for 4 numbers in parallel\n        uint32x4_t quotients = vdivq_u32(num, divisors);\n        uint32x4_t products = vmulq_u32(quotients, divisors);\n        uint32x4_t matches = vceqq_u32(products, num);\n        \n        uint32_t mask = vgetq_lane_u32(matches, 0) | \n                        vgetq_lane_u32(matches, 1) |\n                        vgetq_lane_u32(matches, 2) |\n                        vgetq_lane_u32(matches, 3);\n                        \n        if (mask) {\n            // Found a factor\n            for (int i = 0; i < 4; i++) {\n                if (vgetq_lane_u32(matches, i)) {\n                    int factor = vgetq_lane_u32(divisors, i);\n                    while (n % factor == 0) {\n                        factors.push_back(factor);\n                        n /= factor;\n                    }\n                    num = vdupq_n_u32(n);\n                    sqrtN = sqrt(n);\n                    break;\n                }\n            }\n        } else {\n            // No factors found, increment divisors\n            divisors = vaddq_u32(divisors, increment);\n            \n            // Check if we've exceeded square root\n            if (vgetq_lane_u32(divisors, 0) > sqrtN) {\n                if (n > 1) {\n                    factors.push_back(n);\n                }\n                break;\n            }\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle 2 as a special case first\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    // Create vectors for parallel processing\n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t divisors = vcreate_u32(0x0B090705); // Load 4 odd numbers: 5,7,9,11\n    uint32x4_t increment = vdupq_n_u32(8); // Increment by 8 to get next 4 odd numbers\n    \n    // Process until sqrt(n)\n    int sqrtn = sqrt(n);\n    \n    while (n > 1 && vgetq_lane_u32(divisors, 0) <= sqrtn) {\n        uint32x4_t quotient = vdupq_n_u32(n);\n        uint32x4_t remainder = vmodq_u32(quotient, divisors);\n        uint32x4_t zero = vdupq_n_u32(0);\n        \n        // Create mask for divisors that divide n evenly\n        uint32x4_t mask = vceqq_u32(remainder, zero);\n        \n        // Check each lane\n        for (int i = 0; i < 4; i++) {\n            if (vgetq_lane_u32(mask, i)) {\n                int d = vgetq_lane_u32(divisors, i);\n                while (n % d == 0) {\n                    factors.push_back(d);\n                    n /= d;\n                }\n                sqrtn = sqrt(n);\n            }\n        }\n        \n        // Update divisors for next iteration\n        divisors = vaddq_u32(divisors, increment);\n    }\n    \n    // Add remaining number if it's greater than 1\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle 2 as a special case first\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    // Create vectors for parallel processing\n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t divisors = vcreate_u32(0x0B090705); // Load 4 odd numbers: 5,7,9,11\n    uint32x4_t increment = vdupq_n_u32(8); // Increment by 8 to get next 4 odd numbers\n    \n    int sqrtN = sqrt(n);\n    \n    while (n > 1) {\n        // Check divisibility for 4 numbers in parallel\n        uint32x4_t quotient = vdivq_u32(num, divisors);\n        uint32x4_t product = vmulq_u32(quotient, divisors);\n        uint32x4_t is_divisible = vceqq_u32(num, product);\n        \n        uint32_t mask = vgetq_lane_u32(is_divisible, 0) |\n                        vgetq_lane_u32(is_divisible, 1) |\n                        vgetq_lane_u32(is_divisible, 2) |\n                        vgetq_lane_u32(is_divisible, 3);\n                        \n        if (mask) {\n            // Found a factor, add it and divide n\n            for (int i = 0; i < 4; i++) {\n                if (vgetq_lane_u32(is_divisible, i)) {\n                    int d = vgetq_lane_u32(divisors, i);\n                    factors.push_back(d);\n                    n /= d;\n                    num = vdupq_n_u32(n);\n                    sqrtN = sqrt(n);\n                    break;\n                }\n            }\n        } else {\n            // No factors found, increment divisors\n            divisors = vaddq_u32(divisors, increment);\n            \n            // Check if we've exceeded sqrt(n)\n            if (vgetq_lane_u32(divisors, 0) > sqrtN) {\n                if (n > 1) {\n                    factors.push_back(n);\n                }\n                break;\n            }\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle 2 as a special case first\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    // Create vectors for parallel processing\n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t divisors = vcreate_u32(0x0B090705); // Load 4 odd numbers: 5,7,9,11\n    uint32x4_t increment = vdupq_n_u32(8);\n    \n    // Process until sqrt(n)\n    int limit = sqrt(n);\n    \n    while (n > 1 && vgetq_lane_u32(divisors, 0) <= limit) {\n        // Check divisibility for 4 numbers in parallel\n        uint32x4_t quotients = vdivq_u32(num, divisors);\n        uint32x4_t products = vmulq_u32(quotients, divisors);\n        uint32x4_t matches = vceqq_u32(products, num);\n        \n        // Extract results\n        uint32_t mask = vgetq_lane_u32(matches, 0);\n        \n        for (int i = 0; i < 4; i++) {\n            uint32_t d = vgetq_lane_u32(divisors, i);\n            while (n % d == 0 && d <= limit) {\n                factors.push_back(d);\n                n /= d;\n                limit = sqrt(n);\n            }\n        }\n        \n        // Increment divisors by 8 to maintain odd numbers\n        divisors = vaddq_u32(divisors, increment);\n    }\n    \n    // Add remaining number if it's prime\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle 2 as a special case first\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    // Create vectors for parallel processing\n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t divisors = vcreate_u32(0x0000000B00000007); // Load 3,5,7,11\n    uint32x4_t increment = vdupq_n_u32(4);\n    \n    while (n > 1) {\n        // Check divisibility in parallel\n        uint32x4_t quotients = vdivq_u32(num, divisors);\n        uint32x4_t products = vmulq_u32(quotients, divisors);\n        uint32x4_t matches = vceqq_u32(products, num);\n        \n        uint32_t mask = vgetq_lane_u32(matches, 0) | \n                       vgetq_lane_u32(matches, 1) |\n                       vgetq_lane_u32(matches, 2) |\n                       vgetq_lane_u32(matches, 3);\n                       \n        if (mask) {\n            // Found a factor\n            for (int i = 0; i < 4; i++) {\n                if (vgetq_lane_u32(matches, i)) {\n                    int factor = vgetq_lane_u32(divisors, i);\n                    factors.push_back(factor);\n                    n /= factor;\n                    num = vdupq_n_u32(n);\n                    goto next_iteration;\n                }\n            }\n        }\n        \n        // No factors found, increment divisors\n        divisors = vaddq_u32(divisors, increment);\n        \n        // Check if we've gone too far\n        if (vgetq_lane_u32(divisors, 0) * vgetq_lane_u32(divisors, 0) > (uint32_t)n) {\n            if (n > 1) {\n                factors.push_back(n);\n            }\n            break;\n        }\n        \n        next_iteration:\n        continue;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        \n        float32x4_t masked = vreinterpretq_f32_u32(vandq_u32(\n            vreinterpretq_u32_f32(vec),\n            mask\n        ));\n        \n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t nonzero = vceqq_f32(masked, zeros);\n        nonzero = vmvnq_u32(nonzero);\n        \n        float values[4];\n        vst1q_f32(values, masked);\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(nonzero, j)) {\n                result.push_back(values[j]);\n            }\n        }\n    }\n    \n    for (size_t i = vec_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        \n        float32x4_t masked = vreinterpretq_f32_u32(vandq_u32(\n            vreinterpretq_u32_f32(vec),\n            mask\n        ));\n        \n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t nonzero = vceqq_f32(masked, zeros);\n        nonzero = vmvnq_u32(nonzero);\n        \n        float values[4];\n        vst1q_f32(values, masked);\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(nonzero, j)) {\n                result.push_back(values[j]);\n            }\n        }\n    }\n    \n    for (size_t i = vec_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    const int step = 4;\n    int i = 0;\n    \n    for (; i <= l.size() - step; i += step) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        \n        float32x4_t masked = vreinterpretq_f32_u32(vandq_u32(\n            vreinterpretq_u32_f32(vec),\n            mask\n        ));\n        \n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t nonzero = vceqq_f32(masked, zeros);\n        nonzero = vmvnq_u32(nonzero);\n        \n        float values[4];\n        vst1q_f32(values, masked);\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(nonzero, j)) {\n                result.push_back(values[j]);\n            }\n        }\n    }\n    \n    for (; i < l.size(); i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        \n        float32x4_t masked = vreinterpretq_f32_u32(vandq_u32(\n            vreinterpretq_u32_f32(vec),\n            mask\n        ));\n        \n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t nonzero = vceqq_f32(masked, zeros);\n        nonzero = vmvnq_u32(nonzero);\n        \n        float values[4];\n        vst1q_f32(values, masked);\n        \n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(nonzero, j)) {\n                result.push_back(values[j]);\n            }\n        }\n    }\n    \n    for (size_t i = vec_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    const int step = 4;\n    int i;\n    \n    for (i = 0; i <= l.size() - step; i += step) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        \n        float32x4_t masked = vreinterpretq_f32_u32(vandq_u32(\n            vreinterpretq_u32_f32(vec),\n            mask\n        ));\n        \n        float32_t temp[4];\n        vst1q_f32(temp, masked);\n        \n        for (int j = 0; j < 4; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    for (; i < l.size(); i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    int64_t i;\n\n    // Load vector of incrementing values starting from 5\n    int64x2_t vec_i = {5, 7};\n    int64x2_t vec_increment = vdupq_n_s64(6);\n    \n    for (i = 5; i <= sqrt_n; i += 6) {\n        int64x2_t vec_n = vdupq_n_s64(n);\n        int64x2_t vec_rem = vmodq_s64(vec_n, vec_i);\n        uint64x2_t vec_cmp = vceqzq_s64(vec_rem);\n        \n        if (vgetq_lane_u64(vec_cmp, 0) || vgetq_lane_u64(vec_cmp, 1)) {\n            return false;\n        }\n        \n        vec_i = vaddq_s64(vec_i, vec_increment);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    int64_t i;\n\n    // Load vector of incrementing values starting from 5\n    int64x2_t vec_i = {5, 7};\n    int64x2_t vec_increment = vdupq_n_s64(6);\n    \n    for (i = 5; i <= sqrt_n; i += 6) {\n        int64x2_t vec_n = vdupq_n_s64(n);\n        int64x2_t vec_mod = vmodq_s64(vec_n, vec_i);\n        uint64x2_t vec_zero = vceqzq_s64(vec_mod);\n        \n        if (vgetq_lane_u64(vec_zero, 0) || vgetq_lane_u64(vec_zero, 1)) {\n            return false;\n        }\n        \n        vec_i = vaddq_s64(vec_i, vec_increment);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    int64_t i;\n\n    // Load vector of incrementing values starting from 5\n    int64x2_t vec_i = {5, 7};\n    int64x2_t vec_increment = vdupq_n_s64(6);\n    \n    for (i = 5; i <= sqrt_n; i += 6) {\n        int64x2_t vec_n = vdupq_n_s64(n);\n        int64x2_t vec_mod = vmodq_s64(vec_n, vec_i);\n        uint64x2_t vec_cmp = vceqzq_s64(vec_mod);\n        \n        if (vgetq_lane_u64(vec_cmp, 0) || vgetq_lane_u64(vec_cmp, 1)) {\n            return false;\n        }\n        \n        vec_i = vaddq_s64(vec_i, vec_increment);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    int64_t i;\n\n    // Load vector of 2 int64 values starting at 5 with stride of 6\n    int64x2_t vec_i = {5, 11};\n    int64x2_t vec_stride = vdupq_n_s64(12);\n    int64x2_t vec_n = vdupq_n_s64(n);\n    \n    for (i = 5; i <= sqrt_n; i += 12) {\n        // Check if n is divisible by vec_i or vec_i + 2\n        int64x2_t vec_rem = vmodq_s64(vec_n, vec_i);\n        int64x2_t vec_i_plus2 = vaddq_s64(vec_i, vdupq_n_s64(2));\n        int64x2_t vec_rem2 = vmodq_s64(vec_n, vec_i_plus2);\n        \n        uint64x2_t vec_zero = vceqzq_s64(vec_rem);\n        uint64x2_t vec_zero2 = vceqzq_s64(vec_rem2);\n        \n        if (vgetq_lane_u64(vec_zero, 0) || vgetq_lane_u64(vec_zero, 1) ||\n            vgetq_lane_u64(vec_zero2, 0) || vgetq_lane_u64(vec_zero2, 1)) {\n            return false;\n        }\n        \n        vec_i = vaddq_s64(vec_i, vec_stride);\n    }\n\n    // Check remaining values serially\n    for (; i <= sqrt_n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    int64_t i;\n\n    // Load vector of 2,2,2,2\n    int32x4_t inc = vdupq_n_s32(2);\n    // Load vector with starting values 5,7,9,11\n    int32x4_t nums = {5,7,9,11}; \n    \n    for (i = 5; i <= sqrt_n; i += 8) {\n        int32x4_t remainders = vdupq_n_s32(n);\n        // Compute remainders in parallel\n        remainders = vshrq_n_s32(vmulq_s32(remainders, \n                     vdupq_n_s32(1.0/vgetq_lane_s32(nums,0))), 0);\n        remainders = vmulq_s32(remainders, nums);\n        remainders = vsubq_s32(vdupq_n_s32(n), remainders);\n        \n        // Check if any remainder is 0\n        uint32x4_t cmp = vceqzq_s32(remainders);\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || \n            vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            return false;\n        }\n        \n        // Increment nums vector by 8\n        nums = vaddq_s32(nums, vdupq_n_s32(8));\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n\n    // Process 16 chars at a time\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Check for lowercase letters\n        uint8x16_t is_lower = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('a')),\n            vcleq_u8(chars, vdupq_n_u8('z'))\n        );\n        \n        // Check for uppercase letters\n        uint8x16_t is_upper = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('A')),\n            vcleq_u8(chars, vdupq_n_u8('Z'))\n        );\n\n        // Convert case by adding/subtracting 32\n        uint8x16_t case_diff = vdupq_n_u8(32);\n        uint8x16_t to_upper = vsubq_u8(chars, vandq_u8(is_lower, case_diff));\n        uint8x16_t to_lower = vaddq_u8(chars, vandq_u8(is_upper, case_diff));\n        \n        // Combine results\n        uint8x16_t result_chars = vbslq_u8(\n            vorrq_u8(is_lower, is_upper),\n            vbslq_u8(is_lower, to_upper, to_lower),\n            chars\n        );\n        \n        vst1q_u8((uint8_t*)&result[i], result_chars);\n        \n        // Check if any letters found\n        if (!has_letters) {\n            uint8x16_t any_letters = vorrq_u8(is_lower, is_upper);\n            has_letters |= vmaxvq_u8(any_letters) > 0;\n        }\n    }\n\n    // Handle remaining characters\n    for (int i = (len / 16) * 16; i < len; i++) {\n        char c = s[i];\n        if (isalpha(c)) {\n            has_letters = true;\n            result[i] = isupper(c) ? tolower(c) : toupper(c);\n        }\n    }\n\n    // If no letters found, reverse the whole string\n    if (!has_letters) {\n        int i = 0, j = len - 1;\n        while (i < j) {\n            std::swap(result[i++], result[j--]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n\n    // Process 16 characters at a time using NEON\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Check for lowercase letters\n        uint8x16_t lower_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('a')),\n            vcleq_u8(chars, vdupq_n_u8('z'))\n        );\n        \n        // Check for uppercase letters\n        uint8x16_t upper_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('A')),\n            vcleq_u8(chars, vdupq_n_u8('Z'))\n        );\n\n        // Convert case if letter\n        uint8x16_t any_letter = vorrq_u8(lower_mask, upper_mask);\n        has_letters |= vmaxvq_u8(any_letter) > 0;\n        \n        chars = vbslq_u8(\n            lower_mask,\n            vsubq_u8(chars, vdupq_n_u8(32)),\n            chars\n        );\n        \n        chars = vbslq_u8(\n            upper_mask,\n            vaddq_u8(chars, vdupq_n_u8(32)), \n            chars\n        );\n        \n        vst1q_u8((uint8_t*)&result[i], chars);\n    }\n\n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; i++) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n\n    // If no letters found, reverse the string\n    if (!has_letters) {\n        int i = 0;\n        int j = len - 1;\n        while (i < j) {\n            std::swap(result[i], result[j]);\n            i++;\n            j--;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n\n    // Process 16 characters at a time using NEON\n    for (int i = 0; i <= len-16; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Check for lowercase letters\n        uint8x16_t lower_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('a')),\n            vcleq_u8(chars, vdupq_n_u8('z'))\n        );\n        \n        // Check for uppercase letters\n        uint8x16_t upper_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('A')),\n            vcleq_u8(chars, vdupq_n_u8('Z'))\n        );\n\n        // Convert lowercase to uppercase by subtracting 32\n        uint8x16_t to_upper = vsubq_u8(chars, vandq_u8(lower_mask, vdupq_n_u8(32)));\n        \n        // Convert uppercase to lowercase by adding 32\n        uint8x16_t final = vaddq_u8(to_upper, vandq_u8(upper_mask, vdupq_n_u8(32)));\n\n        // Store result\n        vst1q_u8((uint8_t*)&result[i], final);\n\n        // Check if any letters were found\n        if (vmaxvq_u8(vorrq_u8(lower_mask, upper_mask))) {\n            has_letters = true;\n        }\n    }\n\n    // Handle remaining characters\n    for (int i = (len/16)*16; i < len; i++) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n\n    // If no letters found, reverse the entire string\n    if (!has_letters) {\n        int left = 0, right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    size_t len = s.length();\n    bool has_letters = false;\n\n    // Process 16 characters at a time using NEON\n    for (size_t i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Check for lowercase letters\n        uint8x16_t lower_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('a')),\n            vcleq_u8(chars, vdupq_n_u8('z'))\n        );\n        \n        // Check for uppercase letters\n        uint8x16_t upper_mask = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('A')),\n            vcleq_u8(chars, vdupq_n_u8('Z'))\n        );\n\n        // Convert lowercase to uppercase\n        uint8x16_t to_upper = vbicq_u8(chars, vdupq_n_u8(0x20));\n        \n        // Convert uppercase to lowercase\n        uint8x16_t to_lower = vorrq_u8(chars, vdupq_n_u8(0x20));\n        \n        // Select based on case\n        chars = vbslq_u8(lower_mask, to_upper, chars);\n        chars = vbslq_u8(upper_mask, to_lower, chars);\n        \n        vst1q_u8((uint8_t*)&result[i], chars);\n        \n        // Check if any letters were found\n        if (vmaxvq_u8(vorrq_u8(lower_mask, upper_mask))) {\n            has_letters = true;\n        }\n    }\n\n    // Handle remaining characters\n    for (size_t i = len - (len % 16); i < len; i++) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n\n    // If no letters found, reverse the entire string\n    if (!has_letters) {\n        size_t i = 0;\n        size_t j = len - 1;\n        while (i < j) {\n            std::swap(result[i], result[j]);\n            i++;\n            j--;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n    \n    // Process 16 characters at a time using NEON\n    for (int i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Check for lowercase letters\n        uint8x16_t is_lower = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('a')),\n            vcleq_u8(chars, vdupq_n_u8('z'))\n        );\n        \n        // Check for uppercase letters\n        uint8x16_t is_upper = vandq_u8(\n            vcgeq_u8(chars, vdupq_n_u8('A')),\n            vcleq_u8(chars, vdupq_n_u8('Z'))\n        );\n        \n        // Convert lowercase to uppercase\n        uint8x16_t to_upper = vsubq_u8(chars, vdupq_n_u8(32));\n        chars = vbslq_u8(is_lower, to_upper, chars);\n        \n        // Convert uppercase to lowercase \n        uint8x16_t to_lower = vaddq_u8(chars, vdupq_n_u8(32));\n        chars = vbslq_u8(is_upper, to_lower, chars);\n        \n        // Store result\n        vst1q_u8((uint8_t*)&result[i], chars);\n        \n        // Check if any letters found\n        uint8x16_t is_letter = vorrq_u8(is_lower, is_upper);\n        if (vmaxvq_u8(is_letter) != 0) {\n            has_letters = true;\n        }\n    }\n    \n    // Handle remaining characters\n    for (int i = (len/16)*16; i < len; i++) {\n        if (isalpha(s[i])) {\n            has_letters = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n    \n    // If no letters found, reverse the string\n    if (!has_letters) {\n        int left = 0, right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> third_elements;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_elements.push_back(l[i]);\n    }\n    \n    // Sort the third elements\n    std::sort(third_elements.begin(), third_elements.end());\n    \n    // Put sorted elements back\n    size_t third_idx = 0;\n    int n = l.size() / 4 * 4;\n    \n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t v = vld1q_s32(&l[i]);\n        \n        if (third_idx < third_elements.size()) {\n            v = vsetq_lane_s32(third_elements[third_idx++], v, 0);\n        }\n        if (i + 3 < l.size() && third_idx < third_elements.size() && (i + 3) % 3 == 0) {\n            v = vsetq_lane_s32(third_elements[third_idx++], v, 3); \n        }\n        \n        vst1q_s32(&l[i], v);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = n; i < l.size(); i++) {\n        if (i % 3 == 0 && third_idx < third_elements.size()) {\n            l[i] = third_elements[third_idx++];\n        }\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    // Get number of complete triplets\n    size_t n = l.size() / 3;\n    \n    // Extract values at indices divisible by 3\n    std::vector<int> thirds;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n    \n    // Sort the extracted values using NEON\n    if (thirds.size() >= 4) {\n        for (size_t i = 0; i < thirds.size() - 4; i += 4) {\n            int32x4_t v = vld1q_s32(&thirds[i]);\n            \n            // Bitonic sort network for 4 elements\n            int32x4_t t1 = vrev64q_s32(v);\n            int32x4_t m1 = vminq_s32(v, t1);\n            int32x4_t m2 = vmaxq_s32(v, t1);\n            \n            int32x4_t t2 = vcombine_s32(vget_high_s32(m1), vget_low_s32(m2));\n            m1 = vminq_s32(m1, t2);\n            m2 = vmaxq_s32(m1, t2);\n            \n            vst1q_s32(&thirds[i], m1);\n        }\n    }\n    \n    // Sort remaining elements\n    std::sort(thirds.begin() + (thirds.size()/4)*4, thirds.end());\n    \n    // Put sorted values back\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = thirds[j++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Extract elements at indices divisible by 3\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n\n    // Sort the extracted elements using NEON\n    int n = thirds.size();\n    if (n > 0) {\n        for (int i = 0; i < n-1; i++) {\n            for (int j = 0; j < n-i-1; j += 4) {\n                int remaining = std::min(4, n-j-i-1);\n                if (remaining >= 4) {\n                    int32x4_t v1 = vld1q_s32(&thirds[j]);\n                    int32x4_t v2 = vld1q_s32(&thirds[j+1]);\n                    \n                    uint32x4_t mask = vcgtq_s32(v1, v2);\n                    int32x4_t temp = vbslq_s32(mask, v1, v2);\n                    v2 = vbslq_s32(mask, v2, v1);\n                    v1 = temp;\n                    \n                    vst1q_s32(&thirds[j], v1);\n                    vst1q_s32(&thirds[j+1], v2);\n                } else {\n                    // Handle remaining elements\n                    for (int k = 0; k < remaining; k++) {\n                        if (thirds[j+k] > thirds[j+k+1]) {\n                            std::swap(thirds[j+k], thirds[j+k+1]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    // Put sorted elements back into result vector\n    for (size_t i = 0, j = 0; i < result.size(); i += 3) {\n        if (j < thirds.size()) {\n            result[i] = thirds[j++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Extract elements at indices divisible by 3\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n\n    // Sort the extracted elements using NEON\n    int n = thirds.size();\n    if (n >= 4) {\n        for (int i = 0; i < n-4; i += 4) {\n            int32x4_t v = vld1q_s32(&thirds[i]);\n            \n            // Bitonic sort network for 4 elements\n            int32x4_t tmp = vrev64q_s32(v);\n            int32x4_t min = vminq_s32(v, tmp);\n            int32x4_t max = vmaxq_s32(v, tmp);\n            \n            v = vcombine_s32(vget_low_s32(min), vget_high_s32(max));\n            tmp = vextq_s32(v, v, 2);\n            min = vminq_s32(v, tmp);\n            max = vmaxq_s32(v, tmp);\n            \n            v = vcombine_s32(vget_low_s32(min), vget_high_s32(max));\n            tmp = vextq_s32(v, v, 1);\n            min = vminq_s32(v, tmp);\n            max = vmaxq_s32(v, tmp);\n            \n            vst1q_s32(&thirds[i], min);\n        }\n    }\n    \n    // Sort remaining elements\n    std::sort(thirds.begin() + (n/4)*4, thirds.end());\n    \n    // Put sorted elements back\n    size_t j = 0;\n    for (size_t i = 0; i < result.size(); i += 3) {\n        result[i] = thirds[j++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> result = l;\n    std::vector<int> thirds;\n    \n    // Extract elements at indices divisible by 3\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n    \n    // Sort the extracted elements using NEON\n    int n = thirds.size();\n    if (n > 0) {\n        for (int i = 0; i < n-1; i++) {\n            for (int j = 0; j < n-i-1; j += 4) {\n                int remaining = std::min(4, n-j-i-1);\n                if (remaining >= 4) {\n                    int32x4_t v1 = vld1q_s32(&thirds[j]);\n                    int32x4_t v2 = vld1q_s32(&thirds[j+1]);\n                    \n                    uint32x4_t mask = vcgtq_s32(v1, v2);\n                    int32x4_t temp = vbslq_s32(mask, v1, v2);\n                    v2 = vbslq_s32(mask, v2, v1);\n                    v1 = temp;\n                    \n                    vst1q_s32(&thirds[j], v1);\n                    vst1q_s32(&thirds[j+1], v2);\n                }\n                else {\n                    // Handle remaining elements\n                    for (int k = 0; k < remaining; k++) {\n                        if (thirds[j+k] > thirds[j+k+1]) {\n                            std::swap(thirds[j+k], thirds[j+k+1]);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Put sorted elements back into result vector\n    size_t thirds_idx = 0;\n    for (size_t i = 0; i < result.size(); i += 3) {\n        if (thirds_idx < thirds.size()) {\n            result[i] = thirds[thirds_idx++];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    const int step = 4;\n    int n = l.size();\n    float32x4_t max_vec = vdupq_n_f32(-INFINITY);\n    \n    int i;\n    for (i = 0; i <= n-step; i += step) {\n        float32x4_t curr = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, curr);\n    }\n    \n    float max_val = -INFINITY;\n    float maxarr[4];\n    vst1q_f32(maxarr, max_vec);\n    \n    for (int j = 0; j < 4; j++) {\n        max_val = std::max(max_val, maxarr[j]);\n    }\n    \n    for (; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    float max_val = l[0];\n    \n    if (size >= 4) {\n        float32x4_t vmax = vld1q_f32(l.data());\n        \n        for (size_t i = 4; i < vec_size; i += 4) {\n            float32x4_t v = vld1q_f32(l.data() + i);\n            vmax = vmaxq_f32(vmax, v);\n        }\n        \n        float32x2_t vmax2 = vpmax_f32(vget_low_f32(vmax), vget_high_f32(vmax));\n        vmax2 = vpmax_f32(vmax2, vmax2);\n        max_val = vget_lane_f32(vmax2, 0);\n    }\n    \n    for (size_t i = vec_size; i < size; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    float max_val = l[0];\n    \n    if (size >= 4) {\n        float32x4_t vmax = vld1q_f32(l.data());\n        \n        for (size_t i = 4; i < vec_size; i += 4) {\n            float32x4_t v = vld1q_f32(l.data() + i);\n            vmax = vmaxq_f32(vmax, v);\n        }\n        \n        float32x2_t vmax2 = vpmax_f32(vget_low_f32(vmax), vget_high_f32(vmax));\n        vmax2 = vpmax_f32(vmax2, vmax2);\n        max_val = vget_lane_f32(vmax2, 0);\n    }\n    \n    for (size_t i = vec_size; i < size; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t vec_size = 4;\n    size_t vec_count = n / vec_size;\n    \n    float32x4_t max_vec = vdupq_n_f32(-std::numeric_limits<float>::infinity());\n    \n    for(size_t i = 0; i < vec_count; i++) {\n        float32x4_t curr = vld1q_f32(&l[i * vec_size]);\n        max_vec = vmaxq_f32(max_vec, curr);\n    }\n    \n    // Handle remaining elements\n    float max_val = vgetq_lane_f32(max_vec, 0);\n    max_val = std::max(max_val, vgetq_lane_f32(max_vec, 1));\n    max_val = std::max(max_val, vgetq_lane_f32(max_vec, 2));\n    max_val = std::max(max_val, vgetq_lane_f32(max_vec, 3));\n    \n    for(size_t i = vec_count * vec_size; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    const int step = 4;\n    int size = l.size();\n    float32x4_t max_vec = vdupq_n_f32(-std::numeric_limits<float>::infinity());\n    \n    int i;\n    for(i = 0; i <= size - step; i += step) {\n        float32x4_t curr = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, curr);\n    }\n    \n    float max_val = -std::numeric_limits<float>::infinity();\n    float temp[4];\n    vst1q_f32(temp, max_vec);\n    \n    for(int j = 0; j < 4; j++) {\n        max_val = std::max(max_val, temp[j]);\n    }\n    \n    for(; i < size; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    uint8x16_t sevens = vdupq_n_u8('7');\n    \n    for(int i = 0; i < n; i += 16) {\n        uint8x16_t nums = vdupq_n_u8(0);\n        uint8x16_t result = vdupq_n_u8(0);\n        \n        for(int j = 0; j < 16 && (i+j) < n; j++) {\n            int num = i + j;\n            if(num % 11 == 0 || num % 13 == 0) {\n                char str[8];\n                int len = snprintf(str, sizeof(str), \"%d\", num);\n                for(int k = 0; k < len; k++) {\n                    vsetq_lane_u8(str[k], nums, j);\n                    uint8x16_t cmp = vceqq_u8(nums, sevens);\n                    result = vorrq_u8(result, cmp);\n                }\n            }\n        }\n        \n        uint8_t temp[16];\n        vst1q_u8(temp, result);\n        \n        for(int j = 0; j < 16; j++) {\n            if(temp[j]) count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    uint8x16_t sevens = vdupq_n_u8('7');\n    \n    for(int i = 0; i < n; i += 16) {\n        uint8x16_t nums = vdupq_n_u8(0);\n        uint8x16_t result = vdupq_n_u8(0);\n        \n        for(int j = 0; j < 16 && (i+j) < n; j++) {\n            int num = i + j;\n            if(num % 11 == 0 || num % 13 == 0) {\n                char str[8];\n                int len = sprintf(str, \"%d\", num);\n                for(int k = 0; k < len; k++) {\n                    nums = vsetq_lane_u8(str[k], nums, j);\n                }\n            }\n        }\n        \n        result = vceqq_u8(nums, sevens);\n        uint8_t temp[16];\n        vst1q_u8(temp, result);\n        \n        for(int j = 0; j < 16; j++) {\n            if(temp[j] == 255) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    uint8x16_t seven = vdupq_n_u8('7');\n    \n    for(int i = 0; i < n; i += 16) {\n        uint8x16_t nums = vdupq_n_u8(0);\n        uint8x16_t counts = vdupq_n_u8(0);\n        \n        for(int j = 0; j < 16 && (i+j) < n; j++) {\n            int num = i + j;\n            if(num % 11 == 0 || num % 13 == 0) {\n                char str[8];\n                int len = sprintf(str, \"%d\", num);\n                uint8_t digit_count = 0;\n                \n                for(int k = 0; k < len; k++) {\n                    if(str[k] == '7') {\n                        digit_count++;\n                    }\n                }\n                vsetq_lane_u8(digit_count, counts, j);\n            }\n        }\n        \n        uint8x16_t result = counts;\n        uint8_t sum[16];\n        vst1q_u8(sum, result);\n        \n        for(int j = 0; j < 16; j++) {\n            count += sum[j];\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    uint8x16_t sevens = vdupq_n_u8('7');\n    \n    for(int i = 0; i < n; i += 16) {\n        uint8x16_t nums = vdupq_n_u8(0);\n        uint8x16_t result = vdupq_n_u8(0);\n        \n        for(int j = 0; j < 16 && (i+j) < n; j++) {\n            int num = i + j;\n            if(num % 11 == 0 || num % 13 == 0) {\n                char str[4];\n                sprintf(str, \"%d\", num);\n                int len = strlen(str);\n                for(int k = 0; k < len; k++) {\n                    nums = vsetq_lane_u8(str[k], nums, j);\n                    result = vorrq_u8(result, vceqq_u8(vdupq_n_u8(str[k]), sevens));\n                }\n            }\n        }\n        \n        uint8x8_t sum = vpadd_u8(vget_low_u8(vreinterpretq_u8_u8(result)), \n                                vget_high_u8(vreinterpretq_u8_u8(result)));\n        while(vget_lane_u8(sum, 0) > 0 || vget_lane_u8(sum, 1) > 0 || \n              vget_lane_u8(sum, 2) > 0 || vget_lane_u8(sum, 3) > 0 ||\n              vget_lane_u8(sum, 4) > 0 || vget_lane_u8(sum, 5) > 0 ||\n              vget_lane_u8(sum, 6) > 0 || vget_lane_u8(sum, 7) > 0) {\n            count++;\n            sum = vsub_u8(sum, vdup_n_u8(1));\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    uint8x16_t sevens = vdupq_n_u8('7');\n    \n    for(int i = 0; i < n; i += 16) {\n        uint8x16_t nums = vdupq_n_u8(0);\n        uint8x16_t result = vdupq_n_u8(0);\n        \n        for(int j = 0; j < 16 && (i+j) < n; j++) {\n            int num = i + j;\n            if(num % 11 == 0 || num % 13 == 0) {\n                char str[8];\n                int len = sprintf(str, \"%d\", num);\n                nums = vsetq_lane_u8(len, nums, j);\n                \n                for(int k = 0; k < len; k++) {\n                    if(str[k] == '7') {\n                        result = vsetq_lane_u8(\n                            vgetq_lane_u8(result, j) + 1,\n                            result, j);\n                    }\n                }\n            }\n        }\n        \n        uint8x8_t sum = vadd_u8(vget_low_u8(result), vget_high_u8(result));\n        count += vaddv_u8(sum);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_values;\n    even_values.reserve(even_count);\n    \n    // Extract even indices\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even values using NEON\n    size_t vec_size = even_count - (even_count % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v = vld1q_f32(&even_values[i]);\n        \n        // Sort within vector using min/max operations\n        float32x4_t min = vminq_f32(v, vrev64q_f32(v));\n        float32x4_t max = vmaxq_f32(v, vrev64q_f32(v));\n        \n        float32x4_t sorted = vcombine_f32(\n            vget_low_f32(min),\n            vget_high_f32(max)\n        );\n        \n        vst1q_f32(&even_values[i], sorted);\n    }\n    \n    // Sort remaining elements\n    std::sort(even_values.begin() + vec_size, even_values.end());\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_values(even_count);\n    \n    // Extract even indices\n    for (size_t i = 0; i < n; i += 2) {\n        even_values[i/2] = l[i];\n    }\n    \n    // Sort even values using NEON\n    for (size_t i = 0; i < even_count; i += 4) {\n        size_t remaining = std::min(4UL, even_count - i);\n        if (remaining < 2) break;\n        \n        float32x4_t v = vld1q_f32(&even_values[i]);\n        \n        // Parallel compare and swap\n        if (remaining >= 4) {\n            float32x4_t v1 = vrev64q_f32(v);\n            float32x4_t min = vminq_f32(v, v1);\n            float32x4_t max = vmaxq_f32(v, v1);\n            v = vcombine_f32(vget_low_f32(min), vget_high_f32(max));\n            \n            v1 = vextq_f32(v, v, 2);\n            min = vminq_f32(v, v1);\n            max = vmaxq_f32(v, v1);\n            v = vcombine_f32(vget_low_f32(min), vget_high_f32(max));\n            \n            vst1q_f32(&even_values[i], v);\n        }\n        else {\n            // Handle remaining elements\n            for (size_t j = i; j < i + remaining - 1; j++) {\n                for (size_t k = j + 1; k < i + remaining; k++) {\n                    if (even_values[j] > even_values[k]) {\n                        std::swap(even_values[j], even_values[k]);\n                    }\n                }\n            }\n        }\n    }\n    \n    // Put sorted even values back\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[i/2];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_values;\n    even_values.reserve(even_count);\n    \n    // Extract even indices\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even values using NEON\n    size_t vec_size = even_count - (even_count % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v = vld1q_f32(&even_values[i]);\n        \n        // Sort within vector using min/max operations\n        float32x4_t min = vminq_f32(v, vrev64q_f32(v));\n        float32x4_t max = vmaxq_f32(v, vrev64q_f32(v));\n        \n        float32x4_t sorted = vcombine_f32(\n            vget_low_f32(min),\n            vget_high_f32(max)\n        );\n        \n        vst1q_f32(&even_values[i], sorted);\n    }\n    \n    // Sort remaining elements\n    std::sort(even_values.begin() + vec_size, even_values.end());\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_values;\n    even_values.reserve(even_count);\n    \n    // Extract even indices\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort even values using NEON\n    size_t vec_size = even_count - (even_count % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v = vld1q_f32(&even_values[i]);\n        \n        // Sort within vector using min/max operations\n        float32x4_t min = vminq_f32(v, vrev64q_f32(v));\n        float32x4_t max = vmaxq_f32(v, vrev64q_f32(v));\n        \n        float32x4_t t1 = vcombine_f32(vget_low_f32(min), vget_high_f32(max));\n        float32x4_t t2 = vcombine_f32(vget_low_f32(max), vget_high_f32(min));\n        \n        min = vminq_f32(t1, t2);\n        max = vmaxq_f32(t1, t2);\n        \n        v = vcombine_f32(vget_low_f32(min), vget_high_f32(max));\n        vst1q_f32(&even_values[i], v);\n    }\n    \n    // Sort remaining elements\n    std::sort(even_values.begin() + vec_size, even_values.end());\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_values;\n    even_values.reserve(even_count);\n    \n    // Extract even indices\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even values using NEON\n    size_t vec_size = even_count - (even_count % 4);\n    \n    for (size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v = vld1q_f32(&even_values[i]);\n        \n        // Sort within vector using min/max operations\n        float32x4_t min1 = vminq_f32(v, vrev64q_f32(v));\n        float32x4_t max1 = vmaxq_f32(v, vrev64q_f32(v));\n        \n        float32x4_t min2 = vminq_f32(min1, vextq_f32(max1, max1, 2));\n        float32x4_t max2 = vmaxq_f32(min1, vextq_f32(max1, max1, 2));\n        \n        v = vcombine_f32(vget_low_f32(min2), vget_high_f32(max2));\n        vst1q_f32(&even_values[i], v);\n    }\n    \n    // Sort remaining elements\n    std::sort(even_values.begin() + vec_size, even_values.end());\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    const int n = l.size();\n    \n    // Pad input vector to multiple of 4\n    while (l.size() % 4 != 0) {\n        l.push_back(0);\n    }\n    \n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            // Load target sum (-a[i]-a[j])\n            int target = -(l[i] + l[j]);\n            \n            // Process 4 elements at a time\n            int32x4_t target_v = vdupq_n_s32(target);\n            \n            for (int k = j+1; k < n; k += 4) {\n                if (k + 3 >= n) break;\n                \n                // Load 4 elements\n                int32x4_t vec = vld1q_s32(&l[k]);\n                \n                // Compare with target\n                uint32x4_t mask = vceqq_s32(vec, target_v);\n                \n                // Check if any element matches\n                if (vgetq_lane_u32(mask, 0) || \n                    vgetq_lane_u32(mask, 1) ||\n                    vgetq_lane_u32(mask, 2) ||\n                    vgetq_lane_u32(mask, 3)) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (int k = ((n-j-1)/4)*4 + j+1; k < n; k++) {\n                if (l[k] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int vectorSize = 4;\n    \n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int remaining = -(l[i] + l[j]);\n            \n            // Process 4 elements at a time\n            int k;\n            for (k = j+1; k+vectorSize <= n; k += vectorSize) {\n                int32x4_t v1 = vld1q_s32(&l[k]);\n                int32x4_t v2 = vdupq_n_s32(remaining);\n                uint32x4_t vcmp = vceqq_s32(v1, v2);\n                \n                // Check if any element matches\n                if (vgetq_lane_u32(vcmp, 0) || \n                    vgetq_lane_u32(vcmp, 1) ||\n                    vgetq_lane_u32(vcmp, 2) || \n                    vgetq_lane_u32(vcmp, 3)) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                if (l[k] == remaining) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    const int n = l.size();\n    const int vec_size = 4;\n    \n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            \n            // Load target sum (-a[i]-a[j])\n            int32_t target = -(l[i] + l[j]);\n            int32x4_t target_vec = vdupq_n_s32(target);\n            \n            // Process 4 elements at a time\n            for (int k = j+1; k <= n-vec_size; k += vec_size) {\n                int32x4_t vec = vld1q_s32(&l[k]);\n                uint32x4_t cmp = vceqq_s32(vec, target_vec);\n                \n                // Check if any element matches target\n                if (vgetq_lane_u32(cmp, 0) || \n                    vgetq_lane_u32(cmp, 1) ||\n                    vgetq_lane_u32(cmp, 2) || \n                    vgetq_lane_u32(cmp, 3)) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (int k = n-n%vec_size; k < n; k++) {\n                if (k > j && l[k] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int vectorSize = 4;\n    \n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int remaining = -(l[i] + l[j]);\n            \n            // Process 4 elements at a time\n            int k;\n            for (k = j+1; k+vectorSize <= n; k += vectorSize) {\n                int32x4_t v1 = vld1q_s32(&l[k]);\n                int32x4_t v2 = vdupq_n_s32(remaining);\n                uint32x4_t vcmp = vceqq_s32(v1, v2);\n                \n                // Check if any element matches\n                if (vgetq_lane_u32(vcmp, 0) || \n                    vgetq_lane_u32(vcmp, 1) ||\n                    vgetq_lane_u32(vcmp, 2) || \n                    vgetq_lane_u32(vcmp, 3)) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                if (l[k] == remaining) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int vectorSize = 4;\n    \n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int remaining = -(l[i] + l[j]);\n            \n            // Process 4 elements at a time\n            int k;\n            for (k = j+1; k+vectorSize-1 < n; k += vectorSize) {\n                int32x4_t v = vld1q_s32(&l[k]);\n                int32x4_t target = vdupq_n_s32(remaining);\n                uint32x4_t mask = vceqq_s32(v, target);\n                \n                // Check if any element matches\n                if (vgetq_lane_u32(mask, 0) || \n                    vgetq_lane_u32(mask, 1) ||\n                    vgetq_lane_u32(mask, 2) || \n                    vgetq_lane_u32(mask, 3)) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                if (l[k] == remaining) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    std::vector<int> result(size);\n    \n    // Process 4 elements at a time\n    size_t vec_size = size - (size % 4);\n    for(size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        int32x4_t ones = vdupq_n_s32(1);\n        int32x4_t sum = vaddq_s32(vec, ones);\n        vst1q_s32(&result[i], sum);\n    }\n    \n    // Handle remaining elements\n    for(size_t i = vec_size; i < size; i++) {\n        result[i] = l[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    // Process 4 elements at a time using NEON\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        l[i] += 1;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    for(size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    \n    for(size_t i = vec_size; i < size; i++) {\n        l[i] += 1;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    // Process 4 elements at a time using NEON\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        l[i] += 1;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t vec_size = size - (size % 4);\n    \n    // Process 4 elements at a time using NEON\n    for (size_t i = 0; i < vec_size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(&l[i], vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        l[i] += 1;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    const int vec_size = 4;\n    int n = l.size();\n    \n    for (int i = 0; i < n; i++) {\n        int remaining = ((n-i-1) / vec_size) * vec_size;\n        int j;\n        \n        int32x4_t v1 = vdupq_n_s32(-l[i]);\n        \n        for (j = i+1; j <= n-vec_size && remaining > 0; j += vec_size) {\n            int32x4_t v2 = vld1q_s32(&l[j]);\n            uint32x4_t cmp = vceqq_s32(v1, v2);\n            uint32_t mask = vaddvq_u32(cmp);\n            if (mask > 0) return true;\n            remaining -= vec_size;\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    const int n = l.size();\n    const int step = 4;\n    \n    for (int i = 0; i < n; i++) {\n        int32x4_t v1 = vdupq_n_s32(l[i]);\n        \n        for (int j = 0; j < n - step + 1; j += step) {\n            if (j <= i && i < j + step) continue;\n            \n            int32x4_t v2 = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(v1, v2);\n            uint32x4_t cmp = vceqzq_s32(sum);\n            \n            if (vmaxvq_u32(cmp) != 0) {\n                return true;\n            }\n        }\n        \n        // Handle remaining elements\n        for (int j = (n/step)*step; j < n; j++) {\n            if (i != j && l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    const int vec_size = 4;\n    int n = l.size();\n    \n    for (int i = 0; i < n; i++) {\n        int remaining = (n - i - 1);\n        int j;\n        \n        // Process 4 elements at a time using NEON\n        for (j = i + 1; j + vec_size - 1 < n; j += vec_size) {\n            int32x4_t v1 = vdupq_n_s32(l[i]);\n            int32x4_t v2 = vld1q_s32(&l[j]);\n            \n            // Add vectors\n            int32x4_t sum = vaddq_s32(v1, v2);\n            \n            // Compare sum with zero\n            uint32x4_t cmp = vceqq_s32(sum, vdupq_n_s32(0));\n            \n            // Convert comparison result to scalar\n            uint32_t mask = vgetq_lane_u32(cmp, 0) | \n                           vgetq_lane_u32(cmp, 1) |\n                           vgetq_lane_u32(cmp, 2) |\n                           vgetq_lane_u32(cmp, 3);\n                           \n            if (mask) return true;\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            if (l[i] + l[j] == 0) return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    const int step = 4;\n    int n = l.size();\n    \n    for (int i = 0; i < n; i++) {\n        int remaining = n - i - 1;\n        int j = i + 1;\n        \n        while (remaining >= step) {\n            int32x4_t v1 = vdupq_n_s32(l[i]);\n            int32x4_t v2 = vld1q_s32(&l[j]);\n            \n            int32x4_t sum = vaddq_s32(v1, v2);\n            uint32x4_t cmp = vceqzq_s32(sum);\n            \n            uint32_t mask = vaddvq_u32(cmp);\n            if (mask > 0) return true;\n            \n            j += step;\n            remaining -= step;\n        }\n        \n        // Handle remaining elements\n        while (j < n) {\n            if (l[i] + l[j] == 0) return true;\n            j++;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    const int step = 4;\n    int n = l.size();\n    \n    for (int i = 0; i < n; i++) {\n        int remaining = n - i - 1;\n        int j = i + 1;\n        \n        while (remaining >= step) {\n            int32x4_t v1 = vdupq_n_s32(l[i]);\n            int32x4_t v2 = vld1q_s32(&l[j]);\n            \n            int32x4_t sum = vaddq_s32(v1, v2);\n            uint32x4_t cmp = vceqq_s32(sum, vdupq_n_s32(0));\n            \n            uint32_t mask = vgetq_lane_u32(cmp, 0) |\n                           vgetq_lane_u32(cmp, 1) |\n                           vgetq_lane_u32(cmp, 2) |\n                           vgetq_lane_u32(cmp, 3);\n                           \n            if (mask) return true;\n            \n            j += step;\n            remaining -= step;\n        }\n        \n        // Handle remaining elements\n        while (j < n) {\n            if (l[i] + l[j] == 0) return true;\n            j++;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Load constants\n    int8x8_t base_vec = vdup_n_s8(base);\n    int8x8_t zero = vdup_n_s8('0');\n    \n    // Process 8 digits at a time\n    while (x > 0) {\n        int8x8_t remainders;\n        int i;\n        for (i = 0; i < 8 && x > 0; i++) {\n            remainders[i] = x % base;\n            x /= base;\n        }\n        \n        // Convert remainders to ASCII\n        int8x8_t ascii_digits = vadd_s8(remainders, zero);\n        \n        // Store results\n        vst1_s8((int8_t*)(digits + idx), ascii_digits);\n        idx += i;\n    }\n    \n    // Reverse the digits\n    for (int i = 0; i < idx/2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[idx-1-i];\n        digits[idx-1-i] = temp;\n    }\n    \n    return std::string(digits, idx);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Load constants\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int8x16_t zero = vdupq_n_s8('0');\n    \n    while (x > 0) {\n        // Process 16 digits at a time\n        int8x16_t remainders;\n        for (int i = 0; i < 16 && x > 0; i++) {\n            int8_t remainder = x % base;\n            vsetq_lane_s8(remainder, remainders, i);\n            x /= base;\n        }\n        \n        // Convert to ASCII\n        int8x16_t ascii_digits = vaddq_s8(remainders, zero);\n        \n        // Store results\n        vst1q_s8((int8_t*)(digits + idx), ascii_digits);\n        idx += 16;\n    }\n    \n    // Remove leading zeros and reverse\n    int start = 0;\n    while (start < idx && digits[start] == '0') start++;\n    \n    std::string result;\n    for (int i = idx-1; i >= start; i--) {\n        result += digits[i];\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Load constants\n    int8x8_t base_vec = vdup_n_s8(base);\n    int8x8_t zero = vdup_n_s8('0');\n    \n    // Process 8 digits at a time\n    while (x > 0) {\n        int8x8_t remainders;\n        int i;\n        for (i = 0; i < 8 && x > 0; i++) {\n            remainders[i] = x % base;\n            x /= base;\n        }\n        \n        // Convert remainders to ASCII\n        int8x8_t ascii = vadd_s8(remainders, zero);\n        \n        // Store results\n        vst1_s8((int8_t*)(digits + idx), ascii);\n        idx += i;\n    }\n    \n    // Reverse the digits\n    for (int i = 0; i < idx/2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[idx-1-i];\n        digits[idx-1-i] = temp;\n    }\n    \n    return std::string(digits, idx);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int pos = 0;\n    \n    // Load constants\n    int8x8_t base_vec = vdup_n_s8(base);\n    int8x8_t zero = vdup_n_s8('0');\n    \n    // Process 8 digits at a time\n    while (x > 0) {\n        int8x8_t remainders;\n        int i;\n        for (i = 0; i < 8 && x > 0; i++) {\n            remainders[i] = x % base;\n            x /= base;\n        }\n        \n        // Convert remainders to ASCII\n        int8x8_t ascii = vadd_s8(remainders, zero);\n        \n        // Store results\n        vst1_s8((int8_t*)(digits + pos), ascii);\n        pos += i;\n    }\n    \n    // Reverse the digits\n    for (int i = 0; i < pos/2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[pos-1-i];\n        digits[pos-1-i] = temp;\n    }\n    \n    return std::string(digits, pos);\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Load constants\n    int8x8_t base_vec = vdup_n_s8(base);\n    int8x8_t zero = vdup_n_s8('0');\n    \n    // Process 8 digits at a time\n    while (x > 0) {\n        int8x8_t remainders;\n        int i;\n        for (i = 0; i < 8 && x > 0; i++) {\n            remainders[i] = x % base;\n            x /= base;\n        }\n        \n        // Convert remainders to ASCII\n        int8x8_t ascii_digits = vadd_s8(remainders, zero);\n        \n        // Store results\n        vst1_s8((int8_t*)(digits + idx), ascii_digits);\n        idx += i;\n    }\n    \n    // Reverse the digits\n    for (int i = 0; i < idx/2; i++) {\n        char temp = digits[i];\n        digits[i] = digits[idx-1-i];\n        digits[idx-1-i] = temp;\n    }\n    \n    return std::string(digits, idx);\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.c_str();\n    const char* end = start + len - 8;\n    \n    while (start < end) {\n        uint8x8_t forward = vld1_u8((const uint8_t*)start);\n        uint8x8_t reverse = vld1_u8((const uint8_t*)(text.c_str() + len - (start - text.c_str()) - 8));\n        \n        uint8x8_t reversed = vrev64_u8(reverse);\n        uint8x8_t comparison = vceq_u8(forward, reversed);\n        uint64_t mask = vget_lane_u64(vreinterpret_u64_u8(comparison), 0);\n        \n        if (mask != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        \n        start += 8;\n        end -= 8;\n    }\n    \n    // Handle remaining characters\n    start = text.c_str() + (start - text.c_str());\n    end = text.c_str() + len - (start - text.c_str()) - 1;\n    \n    while (start < end) {\n        if (*start != *end) return false;\n        start++;\n        end--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.c_str();\n    const char* end = start + len - 8;\n    \n    while (start < end) {\n        uint8x8_t forward = vld1_u8((const uint8_t*)start);\n        uint8x8_t reverse = vld1_u8((const uint8_t*)(text.c_str() + len - (start - text.c_str()) - 8));\n        \n        uint8x8_t reversed = vrev64_u8(reverse);\n        uint8x8_t comparison = vceq_u8(forward, reversed);\n        uint64_t mask = vget_lane_u64(vreinterpret_u64_u8(comparison), 0);\n        \n        if (mask != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        \n        start += 8;\n        end -= 8;\n    }\n    \n    // Handle remaining characters\n    start = text.c_str() + (start - text.c_str());\n    end = text.c_str() + len - (start - text.c_str()) - 1;\n    \n    while (start < end) {\n        if (*start != *end) return false;\n        start++;\n        end--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.c_str();\n    const char* end = start + len - 8;\n    \n    while (start < end) {\n        uint8x8_t forward = vld1_u8((const uint8_t*)start);\n        uint8x8_t backward = vld1_u8((const uint8_t*)(text.c_str() + len - (start - text.c_str()) - 8));\n        \n        uint8x8_t reversed = vrev64_u8(backward);\n        uint8x8_t comparison = vceq_u8(forward, reversed);\n        uint64_t mask = vget_lane_u64(vreinterpret_u64_u8(comparison), 0);\n        \n        if (mask != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        \n        start += 8;\n    }\n\n    // Handle remaining characters\n    size_t remaining = (text.c_str() + len - start) / 2;\n    for (size_t i = 0; i < remaining; i++) {\n        if (start[i] != text[len - 1 - i]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.c_str();\n    const char* end = start + len - 8;\n    \n    while (start < end) {\n        uint8x8_t forward = vld1_u8((const uint8_t*)start);\n        uint8x8_t reverse = vld1_u8((const uint8_t*)(text.c_str() + len - (start - text.c_str()) - 8));\n        \n        uint8x8_t reversed = vrev64_u8(reverse);\n        uint8x8_t comparison = vceq_u8(forward, reversed);\n        \n        if (vmaxv_u8(vmvn_u8(comparison)) != 0) {\n            return false;\n        }\n        \n        start += 8;\n    }\n    \n    // Handle remaining characters\n    start = text.c_str() + (len - (end - start));\n    end = text.c_str() + len - 1;\n    \n    while (start < end) {\n        if (*start != *end) return false;\n        start++;\n        end--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.c_str();\n    const char* end = start + len - 8;\n    \n    while (start < end) {\n        uint8x8_t forward = vld1_u8((const uint8_t*)start);\n        uint8x8_t reverse = vld1_u8((const uint8_t*)(text.c_str() + len - (start - text.c_str()) - 8));\n        \n        uint8x8_t reversed = vrev64_u8(reverse);\n        uint8x8_t comparison = vceq_u8(forward, reversed);\n        uint64_t mask = vget_lane_u64(vreinterpret_u64_u8(comparison), 0);\n        \n        if (mask != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        \n        start += 8;\n        end -= 8;\n    }\n\n    // Handle remaining characters\n    start = text.c_str() + (start - text.c_str());\n    end = text.c_str() + len - (start - text.c_str()) - 1;\n    \n    while (start < end) {\n        if (*start != *end) return false;\n        start++;\n        end--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    // Process 16 characters at a time\n    for (i = 0; i + 16 <= s.length(); i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t decoded = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Handle wrap-around for characters that go below 'a'\n        uint8x16_t below_a = vcltq_u8(decoded, vdupq_n_u8('a'));\n        uint8x16_t wrap = vandq_u8(below_a, vdupq_n_u8(26));\n        decoded = vaddq_u8(decoded, wrap);\n        \n        // Store result\n        vst1q_u8((uint8_t*)&out[i], decoded);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    // Process 16 characters at a time using NEON\n    for (i = 0; i + 16 <= s.length(); i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        chars = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Handle wrap around for characters that go below 'a'\n        uint8x16_t below_a = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t wrap = vandq_u8(below_a, vdupq_n_u8(26));\n        chars = vaddq_u8(chars, wrap);\n        \n        // Store result\n        vst1q_u8((uint8_t*)&out[i], chars);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    \n    int i;\n    for (i = 0; i <= s.length()-16; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t decoded = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Handle wrap-around for characters that go below 'a'\n        uint8x16_t below_a = vcltq_u8(decoded, vdupq_n_u8('a'));\n        uint8x16_t wrap = vandq_u8(below_a, vdupq_n_u8(26));\n        decoded = vaddq_u8(decoded, wrap);\n        \n        vst1q_u8((uint8_t*)&out[i], decoded);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    // Process 16 characters at a time using NEON\n    for (i = 0; i + 16 <= s.length(); i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        chars = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Handle wraparound for characters that go below 'a'\n        uint8x16_t below_a = vcltq_u8(chars, vdupq_n_u8('a'));\n        uint8x16_t wrap = vandq_u8(below_a, vdupq_n_u8(26));\n        chars = vaddq_u8(chars, wrap);\n        \n        // Store result\n        vst1q_u8((uint8_t*)&out[i], chars);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    // Process 16 characters at a time using NEON\n    for (i = 0; i + 16 <= s.length(); i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        uint8x16_t decoded = vsubq_u8(chars, vdupq_n_u8(5));\n        \n        // Handle wrap-around for characters that go below 'a'\n        uint8x16_t below_a = vcltq_u8(decoded, vdupq_n_u8('a'));\n        uint8x16_t wrap = vandq_u8(below_a, vdupq_n_u8(26));\n        decoded = vaddq_u8(decoded, wrap);\n        \n        // Store result\n        vst1q_u8((uint8_t*)&out[i], decoded);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w + (int)'a';\n        out[i] = (char)w;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) {\n        return true;\n    }\n\n    const int step = 4;\n    int i = 0;\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (; i + step <= l.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(vec, threshold);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    const int step = 4;\n    int32x4_t threshold = vdupq_n_s32(t);\n    \n    for (size_t i = 0; i <= l.size() - step; i += step) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(vec, threshold);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = l.size() - (l.size() % step); i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) {\n        return true;\n    }\n\n    const int step = 4;\n    int i = 0;\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (; i + step <= l.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(vec, threshold);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n\n    for (; i < l.size(); i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    const int step = 4;\n    int len = l.size();\n    int i = 0;\n\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (; i + step <= len; i += step) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(vec, threshold);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    const int step = 4;\n    int len = l.size();\n    int i = 0;\n\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (; i + step <= len; i += step) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcltq_s32(vec, threshold);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int padding = 16 - (len % 16);\n        brackets.append(padding, '>');\n        len = brackets.length();\n    }\n\n    int8_t count = 0;\n    int8x16_t count_vec = vdupq_n_s8(0);\n    int8x16_t one = vdupq_n_s8(1);\n    int8x16_t neg_one = vdupq_n_s8(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t data = vld1q_u8((uint8_t*)&brackets[i]);\n        uint8x16_t is_open = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t is_close = vceqq_u8(data, vdupq_n_u8('>'));\n        \n        int8x16_t delta = vbslq_s8(is_open, one, neg_one);\n        count_vec = vaddq_s8(count_vec, delta);\n        \n        int8_t temp[16];\n        vst1q_s8(temp, count_vec);\n        \n        for (int j = 0; j < 16; j++) {\n            count += temp[j];\n            if (count < 0) return false;\n        }\n        count_vec = vdupq_n_s8(0);\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        std::string padded = brackets;\n        padded.append(16 - (len % 16), '>');\n        brackets = padded;\n        len = brackets.length();\n    }\n\n    int count = 0;\n    int8x16_t zero = vdupq_n_s8(0);\n    \n    for (int i = 0; i < len; i += 16) {\n        int8x16_t chunk = vld1q_s8((const int8_t*)&brackets[i]);\n        int8x16_t lt = vceqq_s8(chunk, vdupq_n_s8('<'));\n        int8x16_t gt = vceqq_s8(chunk, vdupq_n_s8('>'));\n        \n        int8x16_t ones = vdupq_n_s8(1);\n        int8x16_t neg_ones = vdupq_n_s8(-1);\n        \n        int8x16_t lt_count = vandq_s8(lt, ones);\n        int8x16_t gt_count = vandq_s8(gt, neg_ones);\n        \n        int8x16_t sum = vaddq_s8(lt_count, gt_count);\n        \n        int8_t temp[16];\n        vst1q_s8(temp, sum);\n        \n        for (int j = 0; j < 16 && (i + j) < len; j++) {\n            count += temp[j];\n            if (count < 0) return false;\n        }\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int padding = 16 - (len % 16);\n        brackets.append(padding, '>');\n        len = brackets.length();\n    }\n\n    int8_t count = 0;\n    int8x16_t count_vec = vdupq_n_s8(0);\n    int8x16_t one = vdupq_n_s8(1);\n    int8x16_t neg_one = vdupq_n_s8(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t data = vld1q_u8((uint8_t*)&brackets[i]);\n        uint8x16_t is_open = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t is_close = vceqq_u8(data, vdupq_n_u8('>'));\n        \n        int8x16_t delta = vbslq_s8(is_open, one, neg_one);\n        count_vec = vaddq_s8(count_vec, delta);\n        \n        int8_t temp_counts[16];\n        vst1q_s8(temp_counts, count_vec);\n        \n        for (int j = 0; j < 16; j++) {\n            count += temp_counts[j];\n            if (count < 0) return false;\n        }\n        count_vec = vdupq_n_s8(0);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int padding = 16 - (len % 16);\n        brackets.append(padding, '>');\n        len += padding;\n    }\n\n    int8_t count = 0;\n    int8x16_t count_vec = vdupq_n_s8(0);\n    int8x16_t one = vdupq_n_s8(1);\n    int8x16_t neg_one = vdupq_n_s8(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        int8x16_t chars = vld1q_s8((const int8_t*)&brackets[i]);\n        int8x16_t is_open = vceqq_s8(chars, vdupq_n_s8('<'));\n        int8x16_t is_close = vceqq_s8(chars, vdupq_n_s8('>'));\n        \n        int8x16_t delta = vbslq_s8(is_open, one, vbslq_s8(is_close, neg_one, vdupq_n_s8(0)));\n        count_vec = vaddq_s8(count_vec, delta);\n\n        int8_t temp_counts[16];\n        vst1q_s8(temp_counts, count_vec);\n        \n        for (int j = 0; j < 16; j++) {\n            count += temp_counts[j];\n            if (count < 0) return false;\n        }\n        count_vec = vdupq_n_s8(0);\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        std::string padding(16 - (len % 16), '>');\n        brackets += padding;\n        len = brackets.length();\n    }\n\n    int16_t count = 0;\n    int16x8_t count_vec = vdupq_n_s16(0);\n    int16x8_t one = vdupq_n_s16(1);\n    int16x8_t minus_one = vdupq_n_s16(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t data = vld1q_u8((uint8_t*)&brackets[i]);\n        uint8x16_t is_open = vceqq_u8(data, vdupq_n_u8('<'));\n        uint8x16_t is_close = vceqq_u8(data, vdupq_n_u8('>'));\n\n        int16x8_t open_low = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(is_open)));\n        int16x8_t open_high = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(is_open)));\n        int16x8_t close_low = vreinterpretq_s16_u16(vmovl_u8(vget_low_u8(is_close)));\n        int16x8_t close_high = vreinterpretq_s16_u16(vmovl_u8(vget_high_u8(is_close)));\n\n        count_vec = vaddq_s16(count_vec, vmulq_s16(open_low, one));\n        count_vec = vaddq_s16(count_vec, vmulq_s16(close_low, minus_one));\n        \n        int16x8_t temp = count_vec;\n        count_vec = vaddq_s16(count_vec, vmulq_s16(open_high, one));\n        count_vec = vaddq_s16(count_vec, vmulq_s16(close_high, minus_one));\n\n        int16_t counts[8];\n        vst1q_s16(counts, temp);\n        for(int j = 0; j < 8; j++) {\n            if(counts[j] < 0) return false;\n        }\n    }\n\n    int16_t final_counts[8];\n    vst1q_s16(final_counts, count_vec);\n    count = 0;\n    for(int i = 0; i < 8; i++) {\n        count += final_counts[i];\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const int len = brackets.length();\n    int count = 0;\n    \n    int8_t* data = (int8_t*)brackets.data();\n    int8x16_t open_mask = vdupq_n_s8('(');\n    int8x16_t close_mask = vdupq_n_s8(')');\n    \n    for (int i = 0; i < len - 15; i += 16) {\n        int8x16_t chunk = vld1q_s8(data + i);\n        \n        uint8x16_t is_open = vceqq_s8(chunk, open_mask);\n        uint8x16_t is_close = vceqq_s8(chunk, close_mask);\n        \n        uint8x8_t open_sum = vpadd_u8(vget_low_u8(is_open), vget_high_u8(is_open));\n        uint8x8_t close_sum = vpadd_u8(vget_low_u8(is_close), vget_high_u8(is_close));\n        \n        while (vget_lane_u8(open_sum, 0) > 0) {\n            count++;\n            open_sum = vset_lane_u8(vget_lane_u8(open_sum, 0) - 1, open_sum, 0);\n        }\n        \n        while (vget_lane_u8(close_sum, 0) > 0) {\n            count--;\n            if (count < 0) return false;\n            close_sum = vset_lane_u8(vget_lane_u8(close_sum, 0) - 1, close_sum, 0);\n        }\n    }\n    \n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; i++) {\n        if (brackets[i] == '(') count++;\n        else {\n            count--;\n            if (count < 0) return false;\n        }\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const size_t len = brackets.length();\n    int count = 0;\n    \n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(chars, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(chars, vdupq_n_u8(')'));\n        \n        uint8x16_t ones = vdupq_n_u8(1);\n        int8x16_t adds = vreinterpretq_s8_u8(vandq_u8(open_mask, ones));\n        int8x16_t subs = vreinterpretq_s8_u8(vandq_u8(close_mask, ones));\n        \n        int8x16_t changes = vsubq_s8(adds, subs);\n        \n        int8x8_t sum_v = vpadd_s8(vget_low_s8(changes), vget_high_s8(changes));\n        sum_v = vpadd_s8(sum_v, sum_v);\n        sum_v = vpadd_s8(sum_v, sum_v);\n        \n        count += vget_lane_s8(sum_v, 0);\n        \n        if (count < 0) return false;\n    }\n    \n    for (; i < len; i++) {\n        if (brackets[i] == '(') count++;\n        else count--;\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int pad = 16 - (len % 16);\n        brackets.append(pad, '(');\n        len = brackets.length();\n    }\n\n    int8_t count = 0;\n    int8x16_t zero = vdupq_n_s8(0);\n    int8x16_t one = vdupq_n_s8(1);\n    int8x16_t neg_one = vdupq_n_s8(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        int8x16_t chars = vld1q_s8((const int8_t*)&brackets[i]);\n        int8x16_t open_mask = vceqq_s8(chars, vdupq_n_s8('('));\n        int8x16_t close_mask = vceqq_s8(chars, vdupq_n_s8(')'));\n        \n        int8x16_t delta = vbslq_s8(open_mask, one, zero);\n        delta = vbslq_s8(close_mask, neg_one, delta);\n        \n        int8_t temp[16];\n        vst1q_s8(temp, delta);\n        \n        for (int j = 0; j < 16; j++) {\n            count += temp[j];\n            if (count < 0) return false;\n        }\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int pad = 16 - (len % 16);\n        brackets.append(pad, '(');\n        len += pad;\n    }\n\n    int8_t count = 0;\n    int8x16_t count_vec = vdupq_n_s8(0);\n    int8x16_t one = vdupq_n_s8(1);\n    int8x16_t neg_one = vdupq_n_s8(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        int8x16_t chars = vld1q_s8((const int8_t*)&brackets[i]);\n        int8x16_t open_mask = vceqq_s8(chars, vdupq_n_s8('('));\n        int8x16_t close_mask = vceqq_s8(chars, vdupq_n_s8(')'));\n        \n        count_vec = vaddq_s8(count_vec, vandq_s8(open_mask, one));\n        count_vec = vaddq_s8(count_vec, vandq_s8(close_mask, neg_one));\n        \n        int8_t temp_counts[16];\n        vst1q_s8(temp_counts, count_vec);\n        \n        for (int j = 0; j < 16; j++) {\n            count += temp_counts[j];\n            if (count < 0) return false;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int pad = 16 - (len % 16);\n        brackets.append(pad, '(');\n        len = brackets.length();\n    }\n\n    int8_t count = 0;\n    int8x16_t count_vec = vdupq_n_s8(0);\n    int8x16_t one = vdupq_n_s8(1);\n    int8x16_t neg_one = vdupq_n_s8(-1);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t data = vld1q_u8((uint8_t*)&brackets[i]);\n        uint8x16_t open_mask = vceqq_u8(data, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(data, vdupq_n_u8(')'));\n        \n        int8x16_t open_count = vreinterpretq_s8_u8(vandq_u8(open_mask, vreinterpretq_u8_s8(one)));\n        int8x16_t close_count = vreinterpretq_s8_u8(vandq_u8(close_mask, vreinterpretq_u8_s8(neg_one)));\n        \n        count_vec = vaddq_s8(count_vec, open_count);\n        count_vec = vaddq_s8(count_vec, close_count);\n        \n        int8_t temp_counts[16];\n        vst1q_s8(temp_counts, count_vec);\n        \n        for (int j = 0; j < 16; j++) {\n            count += temp_counts[j];\n            if (count < 0) return false;\n        }\n        count_vec = vdupq_n_s8(0);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= result.size(); i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n        float32x4_t indices = {1.0f + i, 2.0f + i, 3.0f + i, 4.0f + i};\n        float32x4_t products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < result.size(); i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= xs.size() - 1; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n        float32x4_t indices = {1.0f + i, 2.0f + i, 3.0f + i, 4.0f + i};\n        float32x4_t products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= result.size(); i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n        float32x4_t indices = {1.0f + i, 2.0f + i, 3.0f + i, 4.0f + i};\n        float32x4_t products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < result.size(); i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= xs.size() - 1; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n        float32x4_t indices = {1.0f + i, 2.0f + i, 3.0f + i, 4.0f + i};\n        float32x4_t products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= result.size(); i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i + 1]);\n        float32x4_t indices = {1.0f + i, 2.0f + i, 3.0f + i, 4.0f + i};\n        float32x4_t products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < result.size(); i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int total_vowels = 0;\n    \n    // Convert string to lowercase for case-insensitive comparison\n    for(int i = 0; i < len; i++) {\n        s[i] = tolower(s[i]);\n    }\n    \n    // Process 16 characters at a time using NEON\n    uint8x16_t vowel_a = vdupq_n_u8('a');\n    uint8x16_t vowel_e = vdupq_n_u8('e'); \n    uint8x16_t vowel_i = vdupq_n_u8('i');\n    uint8x16_t vowel_o = vdupq_n_u8('o');\n    uint8x16_t vowel_u = vdupq_n_u8('u');\n    \n    int i;\n    for(i = 0; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t is_a = vceqq_u8(chars, vowel_a);\n        uint8x16_t is_e = vceqq_u8(chars, vowel_e);\n        uint8x16_t is_i = vceqq_u8(chars, vowel_i); \n        uint8x16_t is_o = vceqq_u8(chars, vowel_o);\n        uint8x16_t is_u = vceqq_u8(chars, vowel_u);\n        \n        uint8x16_t is_vowel = vorrq_u8(is_a, is_e);\n        is_vowel = vorrq_u8(is_vowel, is_i);\n        is_vowel = vorrq_u8(is_vowel, is_o);\n        is_vowel = vorrq_u8(is_vowel, is_u);\n        \n        // Count set bits\n        uint8x8_t sum = vpaddl_u8(vget_low_u8(is_vowel));\n        sum = vpadd_u8(sum, vget_high_u8(is_vowel));\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        \n        total_vowels += vget_lane_u8(sum, 0);\n    }\n    \n    // Process remaining characters\n    for(; i < len; i++) {\n        char c = s[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            total_vowels++;\n        }\n    }\n    \n    // Check if last character is 'y'\n    if(len > 0 && s[len-1] == 'y') {\n        total_vowels++;\n    }\n    \n    return total_vowels;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    const int len = s.length();\n    if (len == 0) return 0;\n    \n    uint8_t* data = (uint8_t*)s.c_str();\n    uint8x16_t vowels_a = vdupq_n_u8('a');\n    uint8x16_t vowels_e = vdupq_n_u8('e'); \n    uint8x16_t vowels_i = vdupq_n_u8('i');\n    uint8x16_t vowels_o = vdupq_n_u8('o');\n    uint8x16_t vowels_u = vdupq_n_u8('u');\n    uint8x16_t vowels_A = vdupq_n_u8('A');\n    uint8x16_t vowels_E = vdupq_n_u8('E');\n    uint8x16_t vowels_I = vdupq_n_u8('I');\n    uint8x16_t vowels_O = vdupq_n_u8('O');\n    uint8x16_t vowels_U = vdupq_n_u8('U');\n\n    int count = 0;\n    int i;\n    \n    for (i = 0; i <= len-16; i += 16) {\n        uint8x16_t chars = vld1q_u8(data + i);\n        \n        uint8x16_t mask_a = vceqq_u8(chars, vowels_a);\n        uint8x16_t mask_e = vceqq_u8(chars, vowels_e);\n        uint8x16_t mask_i = vceqq_u8(chars, vowels_i);\n        uint8x16_t mask_o = vceqq_u8(chars, vowels_o);\n        uint8x16_t mask_u = vceqq_u8(chars, vowels_u);\n        uint8x16_t mask_A = vceqq_u8(chars, vowels_A);\n        uint8x16_t mask_E = vceqq_u8(chars, vowels_E);\n        uint8x16_t mask_I = vceqq_u8(chars, vowels_I);\n        uint8x16_t mask_O = vceqq_u8(chars, vowels_O);\n        uint8x16_t mask_U = vceqq_u8(chars, vowels_U);\n        \n        uint8x16_t mask = vorrq_u8(mask_a, mask_e);\n        mask = vorrq_u8(mask, mask_i);\n        mask = vorrq_u8(mask, mask_o);\n        mask = vorrq_u8(mask, mask_u);\n        mask = vorrq_u8(mask, mask_A);\n        mask = vorrq_u8(mask, mask_E);\n        mask = vorrq_u8(mask, mask_I);\n        mask = vorrq_u8(mask, mask_O);\n        mask = vorrq_u8(mask, mask_U);\n        \n        count += vaddvq_u8(mask) >> 7;\n    }\n\n    // Handle remaining characters\n    for (; i < len; i++) {\n        char c = tolower(data[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check for 'y' at the end\n    if (len > 0 && tolower(s[len-1]) == 'y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    const int len = s.length();\n    if (len == 0) return 0;\n    \n    // Convert to lowercase\n    for (int i = 0; i < len; i++) {\n        s[i] = tolower(s[i]);\n    }\n    \n    int count = 0;\n    int i = 0;\n    \n    // Create vectors with vowels\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('a', vowels, 0);\n    vowels = vsetq_lane_u8('e', vowels, 1); \n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n\n    // Process 16 characters at a time\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t result = uint8x16_t();\n        for (int j = 0; j < 5; j++) {\n            uint8x16_t vowel = vdupq_n_u8(vgetq_lane_u8(vowels, j));\n            result = vorrq_u8(result, vceqq_u8(chars, vowel));\n        }\n        \n        // Count matches\n        uint8x8_t sum = vpadd_u8(vget_low_u8(result), vget_high_u8(result));\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        count += vget_lane_u8(sum, 0);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check for 'y' at the end\n    if (len > 0 && s[len-1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    const int len = s.length();\n    int count = 0;\n    \n    // Create vectors with vowels\n    uint8x16_t vowels_a = vdupq_n_u8('a');\n    uint8x16_t vowels_e = vdupq_n_u8('e'); \n    uint8x16_t vowels_i = vdupq_n_u8('i');\n    uint8x16_t vowels_o = vdupq_n_u8('o');\n    uint8x16_t vowels_u = vdupq_n_u8('u');\n    uint8x16_t vowels_A = vdupq_n_u8('A');\n    uint8x16_t vowels_E = vdupq_n_u8('E');\n    uint8x16_t vowels_I = vdupq_n_u8('I');\n    uint8x16_t vowels_O = vdupq_n_u8('O');\n    uint8x16_t vowels_U = vdupq_n_u8('U');\n    \n    // Process 16 characters at a time\n    int i;\n    for(i = 0; i <= len-16; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t mask_a = vceqq_u8(chars, vowels_a);\n        uint8x16_t mask_e = vceqq_u8(chars, vowels_e);\n        uint8x16_t mask_i = vceqq_u8(chars, vowels_i);\n        uint8x16_t mask_o = vceqq_u8(chars, vowels_o);\n        uint8x16_t mask_u = vceqq_u8(chars, vowels_u);\n        uint8x16_t mask_A = vceqq_u8(chars, vowels_A);\n        uint8x16_t mask_E = vceqq_u8(chars, vowels_E);\n        uint8x16_t mask_I = vceqq_u8(chars, vowels_I);\n        uint8x16_t mask_O = vceqq_u8(chars, vowels_O);\n        uint8x16_t mask_U = vceqq_u8(chars, vowels_U);\n        \n        uint8x16_t mask = vorrq_u8(mask_a, mask_e);\n        mask = vorrq_u8(mask, mask_i);\n        mask = vorrq_u8(mask, mask_o);\n        mask = vorrq_u8(mask, mask_u);\n        mask = vorrq_u8(mask, mask_A);\n        mask = vorrq_u8(mask, mask_E);\n        mask = vorrq_u8(mask, mask_I);\n        mask = vorrq_u8(mask, mask_O);\n        mask = vorrq_u8(mask, mask_U);\n        \n        count += vaddvq_u8(mask);\n    }\n    \n    // Handle remaining characters and check for 'y'/'Y' at end\n    for(; i < len; i++) {\n        char c = tolower(s[i]);\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u')\n            count++;\n    }\n    \n    // Check if word ends with y/Y\n    if(len > 0) {\n        char last = tolower(s[len-1]);\n        if(last == 'y')\n            count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    const size_t len = s.length();\n    if (len == 0) return 0;\n    \n    int count = 0;\n    size_t i = 0;\n    \n    // Create vectors with vowels for comparison\n    uint8x16_t vowels_a = vdupq_n_u8('a');\n    uint8x16_t vowels_e = vdupq_n_u8('e'); \n    uint8x16_t vowels_i = vdupq_n_u8('i');\n    uint8x16_t vowels_o = vdupq_n_u8('o');\n    uint8x16_t vowels_u = vdupq_n_u8('u');\n    uint8x16_t vowels_A = vdupq_n_u8('A');\n    uint8x16_t vowels_E = vdupq_n_u8('E');\n    uint8x16_t vowels_I = vdupq_n_u8('I');\n    uint8x16_t vowels_O = vdupq_n_u8('O');\n    uint8x16_t vowels_U = vdupq_n_u8('U');\n\n    // Process 16 characters at a time\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t match_a = vceqq_u8(chars, vowels_a);\n        uint8x16_t match_e = vceqq_u8(chars, vowels_e);\n        uint8x16_t match_i = vceqq_u8(chars, vowels_i);\n        uint8x16_t match_o = vceqq_u8(chars, vowels_o);\n        uint8x16_t match_u = vceqq_u8(chars, vowels_u);\n        uint8x16_t match_A = vceqq_u8(chars, vowels_A);\n        uint8x16_t match_E = vceqq_u8(chars, vowels_E);\n        uint8x16_t match_I = vceqq_u8(chars, vowels_I);\n        uint8x16_t match_O = vceqq_u8(chars, vowels_O);\n        uint8x16_t match_U = vceqq_u8(chars, vowels_U);\n\n        uint8x16_t result = vorrq_u8(match_a, match_e);\n        result = vorrq_u8(result, match_i);\n        result = vorrq_u8(result, match_o);\n        result = vorrq_u8(result, match_u);\n        result = vorrq_u8(result, match_A);\n        result = vorrq_u8(result, match_E);\n        result = vorrq_u8(result, match_I);\n        result = vorrq_u8(result, match_O);\n        result = vorrq_u8(result, match_U);\n\n        uint8_t temp[16];\n        vst1q_u8(temp, result);\n        \n        for(int j = 0; j < 16; j++) {\n            if(temp[j]) count++;\n        }\n    }\n\n    // Handle remaining characters and check for 'y'/'Y' at end\n    for(; i < len; i++) {\n        char c = tolower(s[i]);\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if word ends with 'y' or 'Y'\n    if(len > 0) {\n        char last = tolower(s[len-1]);\n        if(last == 'y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    \n    if (len == 0) return 0;\n\n    uint8_t* data = (uint8_t*)s.c_str();\n    uint8x16_t upper_mask = vdupq_n_u8(0x40);\n    uint8x16_t lower_mask = vdupq_n_u8(0x5B);\n    \n    int vectorized_len = len - (len % 16);\n    \n    for (int i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t chars = vld1q_u8(data + i);\n        uint8x16_t is_upper = vandq_u8(vcgtq_u8(chars, upper_mask), \n                                      vcltq_u8(chars, lower_mask));\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        \n        uint16x8_t sum16_low = vpaddlq_u8(upper_chars);\n        uint32x4_t sum32 = vpaddlq_u16(sum16_low);\n        uint64x2_t sum64 = vpaddlq_u32(sum32);\n        \n        sum += vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n    }\n    \n    for (int i = vectorized_len; i < len; i++) {\n        if (data[i] >= 'A' && data[i] <= 'Z') {\n            sum += data[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    \n    // Process 16 characters at a time\n    uint8x16_t upper_mask = vdupq_n_u8(0x40);\n    uint8x16_t lower_mask = vdupq_n_u8(0x5B);\n    \n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        uint8x16_t is_upper = vandq_u8(vcgtq_u8(chars, upper_mask), \n                                     vcltq_u8(chars, lower_mask));\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        \n        uint16x8_t sum16_low = vpaddlq_u8(upper_chars);\n        uint32x4_t sum32 = vpaddlq_u16(sum16_low);\n        uint64x2_t sum64 = vpaddlq_u32(sum32);\n        \n        sum += vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    \n    // Process 16 characters at a time\n    uint8x16_t upper_mask = vdupq_n_u8(0x40);\n    uint8x16_t lower_mask = vdupq_n_u8(0x5B);\n    \n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        uint8x16_t is_upper = vandq_u8(vcgtq_u8(chars, upper_mask), \n                                     vcltq_u8(chars, lower_mask));\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        \n        uint16x8_t sum16_low = vpaddlq_u8(upper_chars);\n        uint32x4_t sum32 = vpaddlq_u16(sum16_low);\n        uint64x2_t sum64 = vpaddlq_u32(sum32);\n        sum += vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    \n    if (len == 0) return 0;\n\n    // Process 16 characters at a time\n    int vectorSize = 16;\n    int i = 0;\n    \n    uint8x16_t upperMask = vdupq_n_u8(0x40); // '@' ASCII 64\n    uint8x16_t lowerMask = vdupq_n_u8(0x5B); // '[' ASCII 91\n    \n    for (; i + vectorSize <= len; i += vectorSize) {\n        // Load 16 characters\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        // Check if characters are uppercase (between '@' and '[')\n        uint8x16_t isGreaterThanAt = vcgtq_u8(chars, upperMask);\n        uint8x16_t isLessThanBracket = vcltq_u8(chars, lowerMask);\n        uint8x16_t isUpper = vandq_u8(isGreaterThanAt, isLessThanBracket);\n        \n        // Zero out non-uppercase characters\n        uint8x16_t maskedChars = vandq_u8(chars, isUpper);\n        \n        // Horizontal sum\n        uint16x8_t sum16 = vpaddlq_u8(maskedChars);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        uint64x2_t sum64 = vpaddlq_u32(sum32);\n        \n        sum += vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    \n    // Process 16 characters at a time\n    uint8x16_t upper_mask = vdupq_n_u8(0x40);\n    uint8x16_t lower_mask = vdupq_n_u8(0x5B);\n    \n    for (; i <= len-16; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        uint8x16_t is_upper = vandq_u8(vcgtq_u8(chars, upper_mask), \n                                     vcltq_u8(chars, lower_mask));\n        uint8x16_t masked = vandq_u8(chars, is_upper);\n        \n        uint16x8_t sum16_low = vpaddlq_u8(masked);\n        uint16x4_t sum16_0 = vget_low_u16(sum16_low);\n        uint16x4_t sum16_1 = vget_high_u16(sum16_low);\n        uint32x2_t sum32 = vpadd_u32(vpaddl_u16(sum16_0), vpaddl_u16(sum16_1));\n        sum += vget_lane_u32(sum32, 0) + vget_lane_u32(sum32, 1);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int len = arr.size();\n    const int step = 4;\n    \n    uint32x4_t min_val = vdupq_n_u32(UINT32_MAX);\n    uint32x4_t min_idx = vdupq_n_u32(UINT32_MAX);\n    uint32x4_t indices = {0,1,2,3};\n    const uint32x4_t four = vdupq_n_u32(4);\n    \n    for (int i = 0; i < len; i += step) {\n        uint32x4_t data;\n        if (i + step <= len) {\n            data = vld1q_u32((uint32_t*)&arr[i]);\n        } else {\n            uint32_t temp[4] = {UINT32_MAX, UINT32_MAX, UINT32_MAX, UINT32_MAX};\n            for(int j = 0; j < len-i; j++) {\n                temp[j] = arr[i+j];\n            }\n            data = vld1q_u32(temp);\n        }\n        \n        // Check if numbers are even\n        uint32x4_t is_even = vbicq_u32(vdupq_n_u32(1), data);\n        uint32x4_t even_mask = vceqq_u32(is_even, vdupq_n_u32(0));\n        \n        // Apply mask to get even numbers only\n        data = vbslq_u32(even_mask, data, vdupq_n_u32(UINT32_MAX));\n        \n        // Update minimum values and indices\n        uint32x4_t curr_min_mask = vcltq_u32(data, min_val);\n        min_val = vbslq_u32(curr_min_mask, data, min_val);\n        min_idx = vbslq_u32(curr_min_mask, indices, min_idx);\n        \n        indices = vaddq_u32(indices, four);\n    }\n    \n    // Find minimum across vector elements\n    uint32_t vals[4], idxs[4];\n    vst1q_u32(vals, min_val);\n    vst1q_u32(idxs, min_idx);\n    \n    uint32_t min_value = UINT32_MAX;\n    uint32_t min_index = UINT32_MAX;\n    \n    for(int i = 0; i < 4; i++) {\n        if(vals[i] < min_value) {\n            min_value = vals[i];\n            min_index = idxs[i];\n        }\n    }\n    \n    if(min_value == UINT32_MAX) {\n        return {};\n    }\n    \n    return {(int)min_value, (int)min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int step = 4;\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n    \n    // Process 4 elements at a time using NEON\n    for (int i = 0; i <= n-step; i += step) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even numbers\n        int32x4_t two = vdupq_n_s32(2);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, two), vdupq_n_s32(0));\n        \n        // Get minimum of even numbers\n        int32x4_t max_vec = vdupq_n_s32(INT_MAX);\n        int32x4_t masked = vbslq_s32(even_mask, vec, max_vec);\n        int32x2_t min2 = vpmin_s32(vget_low_s32(masked), vget_high_s32(masked));\n        int32x2_t min1 = vpmin_s32(min2, min2);\n        int curr_min = vget_lane_s32(min1, 0);\n        \n        if (curr_min < min_even) {\n            // Find index of minimum even number\n            for (int j = 0; j < step; j++) {\n                if (arr[i+j] == curr_min && arr[i+j] % 2 == 0) {\n                    min_even = curr_min;\n                    min_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/step)*step; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_idx = i;\n        }\n    }\n    \n    if (min_idx == -1) return {};\n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    const int step = 4;\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n\n    // Process 4 elements at a time using NEON\n    for (int i = 0; i <= n-step; i += step) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even numbers\n        int32x4_t two = vdupq_n_s32(2);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, two), vdupq_n_s32(0));\n        \n        // Get minimum of even numbers\n        int32x4_t max_vec = vdupq_n_s32(INT_MAX);\n        int32x4_t masked = vbslq_s32(even_mask, vec, max_vec);\n        int32x2_t min2 = vpmin_s32(vget_low_s32(masked), vget_high_s32(masked));\n        int32x2_t min1 = vpmin_s32(min2, min2);\n        int curr_min = vget_lane_s32(min1, 0);\n        \n        if (curr_min < min_even) {\n            // Find index of minimum even number\n            for (int j = 0; j < step; j++) {\n                if (arr[i+j] == curr_min && arr[i+j] % 2 == 0) {\n                    min_even = curr_min;\n                    min_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = (n/step)*step; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_idx = i;\n        }\n    }\n\n    if (min_idx == -1) {\n        return {};\n    }\n    \n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int step = 4;\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n    \n    // Process 4 elements at a time using NEON\n    for (int i = 0; i <= n-step; i += step) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even numbers\n        int32x4_t two = vdupq_n_s32(2);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, two), vdupq_n_s32(0));\n        \n        // Get minimum of even numbers\n        int32x4_t max_vec = vdupq_n_s32(INT_MAX);\n        int32x4_t masked = vbslq_s32(even_mask, vec, max_vec);\n        int32x2_t min2 = vpmin_s32(vget_low_s32(masked), vget_high_s32(masked));\n        int32x2_t min1 = vpmin_s32(min2, min2);\n        int curr_min = vget_lane_s32(min1, 0);\n        \n        if (curr_min < min_even) {\n            // Find index of minimum even number\n            for (int j = 0; j < step; j++) {\n                if (arr[i+j] == curr_min && arr[i+j] % 2 == 0) {\n                    min_even = curr_min;\n                    min_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/step)*step; i < n; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_idx = i;\n        }\n    }\n    \n    if (min_idx == -1) return {};\n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int len = arr.size();\n    const int step = 4;\n    int min_even = INT_MAX;\n    int min_idx = -1;\n    \n    // Process 4 elements at a time using NEON\n    for (int i = 0; i <= len-step; i += step) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for even numbers\n        int32x4_t two = vdupq_n_s32(2);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, two), vdupq_n_s32(0));\n        \n        // Get minimum of even numbers\n        int32x4_t max_vec = vdupq_n_s32(INT_MAX);\n        int32x4_t masked = vbslq_s32(even_mask, vec, max_vec);\n        int32x2_t min2 = vpmin_s32(vget_low_s32(masked), vget_high_s32(masked));\n        min2 = vpmin_s32(min2, min2);\n        int curr_min = vget_lane_s32(min2, 0);\n        \n        if (curr_min < min_even) {\n            // Find index of minimum even number\n            for (int j = 0; j < step; j++) {\n                if (arr[i+j] == curr_min && arr[i+j] % 2 == 0) {\n                    min_even = curr_min;\n                    min_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (len/step)*step; i < len; i++) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_idx = i;\n        }\n    }\n    \n    if (min_idx == -1) return {};\n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_element = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > max_element) max_element = lst[i];\n    }\n\n    // Initialize frequency array\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Count frequencies using NEON\n    int i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        uint32x4_t vec = vld1q_u32((uint32_t*)&lst[i]);\n        for (int j = 0; j < 4; j++) {\n            freq[vgetq_lane_u32(vec, j)]++;\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\n    // Find result using NEON\n    int result = -1;\n    int n = freq.size();\n    i = 0;\n    \n    for (; i + 4 <= n; i += 4) {\n        uint32x4_t freq_vec = vld1q_u32((uint32_t*)&freq[i]);\n        uint32x4_t idx_vec = {(uint32_t)(i), (uint32_t)(i+1), (uint32_t)(i+2), (uint32_t)(i+3)};\n        uint32x4_t cmp = vcgeq_u32(freq_vec, idx_vec);\n        \n        if (vgetq_lane_u32(cmp, 0) && freq[i] >= i && i > result) result = i;\n        if (vgetq_lane_u32(cmp, 1) && freq[i+1] >= i+1 && i+1 > result) result = i+1;\n        if (vgetq_lane_u32(cmp, 2) && freq[i+2] >= i+2 && i+2 > result) result = i+2;\n        if (vgetq_lane_u32(cmp, 3) && freq[i+3] >= i+3 && i+3 > result) result = i+3;\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (freq[i] >= i && i > result) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine histogram size\n    int max_val = lst[0];\n    for (int x : lst) {\n        if (x > max_val) max_val = x;\n    }\n\n    // Create histogram array initialized to 0\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Process 4 elements at a time using NEON\n    int i = 0;\n    int n = lst.size();\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            freq[val]++;\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        freq[lst[i]]++;\n    }\n\n    // Find largest number with frequency >= value\n    int result = -1;\n    for (int i = 1; i <= max_val; i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_element = 0;\n    for (int i = 0; i < lst.size(); i++) {\n        if (lst[i] > max_element) max_element = lst[i];\n    }\n\n    // Initialize frequency array\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Count frequencies using NEON\n    int i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        uint32x4_t vec = vld1q_u32((uint32_t*)&lst[i]);\n        for (int j = 0; j < 4; j++) {\n            freq[vgetq_lane_u32(vec, j)]++;\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\n    // Find result using NEON\n    int result = -1;\n    int n = freq.size();\n    i = 0;\n    \n    for (; i + 4 <= n; i += 4) {\n        uint32x4_t freq_vec = vld1q_u32((uint32_t*)&freq[i]);\n        uint32x4_t idx_vec = vdupq_n_u32(i);\n        idx_vec = vaddq_u32(idx_vec, vcreate_u32(0x03020100));\n        \n        uint32x4_t cmp = vcgeq_u32(freq_vec, idx_vec);\n        \n        if (vmaxvq_u32(vandq_u32(cmp, idx_vec)) > result) {\n            for (int j = 0; j < 4; j++) {\n                int idx = i + j;\n                if (idx > 0 && freq[idx] >= idx && idx > result) {\n                    result = idx;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i > 0 && freq[i] >= i && i > result) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine histogram size\n    int max_val = 0;\n    for (int x : lst) {\n        max_val = std::max(max_val, x);\n    }\n\n    // Create histogram array\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Process 4 elements at a time using NEON\n    int i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        uint32x4_t vals = vld1q_u32((uint32_t*)&lst[i]);\n        \n        // Increment frequencies\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_u32(vals, j);\n            freq[val]++;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\n    // Find largest number where frequency >= number\n    for (int i = max_val; i > 0; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_element = lst[0];\n    for (int x : lst) {\n        if (x > max_element) max_element = x;\n    }\n\n    // Initialize frequency array\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Process 4 elements at a time using NEON\n    int i = 0;\n    int n = lst.size();\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        for (int j = 0; j < 4; j++) {\n            int val = vgetq_lane_s32(vec, j);\n            freq[val]++;\n        }\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        freq[lst[i]]++;\n    }\n\n    // Find largest number where frequency >= number\n    for (int i = max_element; i > 0; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    \n    // Calculate sum using NEON\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for (int i = 0; i < size - 3; i += 4) {\n        int32x4_t v = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n    \n    // Handle remaining elements\n    int sum = vaddvq_s32(sum_vec);\n    for (int i = (size/4)*4; i < size; i++) {\n        sum += q[i];\n    }\n    \n    // Check if sum exceeds weight\n    if (sum > w) return false;\n    \n    // Check palindrome using NEON\n    int half = size / 2;\n    for (int i = 0; i < half - 3; i += 4) {\n        int32x4_t v1 = vld1q_s32(&q[i]);\n        int32x4_t v2 = vld1q_s32(&q[size-4-i]);\n        v2 = vrev64q_s32(v2);\n        v2 = vcombine_s32(vget_high_s32(v2), vget_low_s32(v2));\n        uint32x4_t cmp = vceqq_s32(v1, v2);\n        if (vminvq_u32(cmp) == 0) return false;\n    }\n    \n    // Handle remaining elements\n    for (int i = (half/4)*4; i < half; i++) {\n        if (q[i] != q[size-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    \n    // Calculate sum using NEON\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for(int i = 0; i < size - 3; i += 4) {\n        int32x4_t v = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n    \n    // Handle remaining elements\n    int sum = vaddvq_s32(sum_vec);\n    for(int i = (size/4)*4; i < size; i++) {\n        sum += q[i];\n    }\n    \n    // Check if sum exceeds weight\n    if(sum > w) return false;\n    \n    // Check palindrome using NEON\n    int half = size/2;\n    for(int i = 0; i < half - 3; i += 4) {\n        int32x4_t v1 = vld1q_s32(&q[i]);\n        int j = size - i - 4;\n        int32x4_t v2 = vld1q_s32(&q[j]);\n        v2 = vrev64q_s32(v2);\n        v2 = vcombine_s32(vget_high_s32(v2), vget_low_s32(v2));\n        \n        uint32x4_t cmp = vceqq_s32(v1, v2);\n        if(vminvq_u32(cmp) == 0) return false;\n    }\n    \n    // Handle remaining elements\n    for(int i = (half/4)*4; i < half; i++) {\n        if(q[i] != q[size-1-i]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    \n    // Calculate sum using NEON\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for(int i = 0; i < size - 3; i += 4) {\n        int32x4_t v = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, v);\n    }\n    \n    // Handle remaining elements\n    int sum = vaddvq_s32(sum_vec);\n    for(int i = (size/4)*4; i < size; i++) {\n        sum += q[i];\n    }\n    \n    // Check if sum exceeds weight\n    if(sum > w) return false;\n    \n    // Check palindrome using NEON\n    int half = size/2;\n    for(int i = 0; i < half - 3; i += 4) {\n        int32x4_t v1 = vld1q_s32(&q[i]);\n        \n        // Load reversed elements\n        int32x4_t v2;\n        v2[0] = q[size-1-i];\n        v2[1] = q[size-2-i];\n        v2[2] = q[size-3-i]; \n        v2[3] = q[size-4-i];\n        \n        uint32x4_t cmp = vceqq_s32(v1, v2);\n        if(vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n    \n    // Check remaining elements\n    for(int i = (half/4)*4; i < half; i++) {\n        if(q[i] != q[size-1-i]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    if (size == 0) return false;\n    \n    // Check sum <= w\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using NEON\n    if (size >= 4) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        for (; i <= size - 4; i += 4) {\n            int32x4_t v = vld1q_s32(&q[i]);\n            sum_vec = vaddq_s32(sum_vec, v);\n        }\n        int32_t temp_sum[4];\n        vst1q_s32(temp_sum, sum_vec);\n        sum = temp_sum[0] + temp_sum[1] + temp_sum[2] + temp_sum[3];\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        sum += q[i];\n    }\n    \n    if (sum > w) return false;\n    \n    // Check palindrome\n    int left = 0;\n    int right = size - 1;\n    \n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    \n    // Check sum <= w using NEON\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    for(int i = 0; i < size; i += 4) {\n        int remaining = std::min(4, size - i);\n        if(remaining == 4) {\n            int32x4_t v = vld1q_s32(&q[i]);\n            sum_vec = vaddq_s32(sum_vec, v);\n        } else {\n            int32x4_t v = vdupq_n_s32(0);\n            for(int j = 0; j < remaining; j++) {\n                v = vsetq_lane_s32(q[i+j], v, j);\n            }\n            sum_vec = vaddq_s32(sum_vec, v);\n        }\n    }\n    \n    int sum = vgetq_lane_s32(sum_vec, 0) + \n              vgetq_lane_s32(sum_vec, 1) + \n              vgetq_lane_s32(sum_vec, 2) + \n              vgetq_lane_s32(sum_vec, 3);\n              \n    if(sum > w) return false;\n    \n    // Check palindrome using NEON\n    int half = size/2;\n    for(int i = 0; i < half; i += 4) {\n        int remaining = std::min(4, half - i);\n        if(remaining == 4) {\n            int32x4_t v1 = vld1q_s32(&q[i]);\n            int32x4_t v2 = vld1q_s32(&q[size-i-4]);\n            int32x4_t rev = vrev64q_s32(v2);\n            rev = vcombine_s32(vget_high_s32(rev), vget_low_s32(rev));\n            uint32x4_t cmp = vceqq_s32(v1, rev);\n            if(vgetq_lane_u32(cmp,0) == 0 || \n               vgetq_lane_u32(cmp,1) == 0 ||\n               vgetq_lane_u32(cmp,2) == 0 ||\n               vgetq_lane_u32(cmp,3) == 0) {\n                return false;\n            }\n        } else {\n            for(int j = 0; j < remaining; j++) {\n                if(q[i+j] != q[size-1-i-j]) return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 pairs at a time using NEON\n    int simd_iters = n/8;\n    for(int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        int32x4_t v1 = vld1q_s32(&arr[i*4]);\n        int32x4_t v2 = vld1q_s32(&arr[n-4-(i*4)]);\n        \n        // Reverse elements from end\n        int32x4_t v2_rev = vrev64q_s32(v2);\n        v2_rev = vcombine_s32(vget_high_s32(v2_rev), vget_low_s32(v2_rev));\n        \n        // Compare vectors\n        uint32x4_t cmp = vceqq_s32(v1, v2_rev);\n        \n        // Count non-matching elements\n        uint32x2_t sum = vpadd_u32(vget_low_u32(cmp), vget_high_u32(cmp));\n        sum = vpadd_u32(sum, sum);\n        changes += 4 - vget_lane_u32(sum, 0);\n    }\n    \n    // Handle remaining elements\n    for(int i = simd_iters*4; i < n/2; i++) {\n        if(arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 pairs at a time using NEON\n    int simd_iters = n/8;\n    for(int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        int32x4_t v1 = vld1q_s32(&arr[i*4]);\n        int32x4_t v2 = vld1q_s32(&arr[n-4-(i*4)]);\n        \n        // Reverse elements from end\n        int32x4_t v2_rev = vrev64q_s32(v2);\n        v2_rev = vcombine_s32(vget_high_s32(v2_rev), vget_low_s32(v2_rev));\n        \n        // Compare vectors\n        uint32x4_t cmp = vceqq_s32(v1, v2_rev);\n        \n        // Count non-matching elements\n        uint32x2_t sum = vpadd_u32(vget_low_u32(cmp), vget_high_u32(cmp));\n        sum = vpadd_u32(sum, sum);\n        changes += 4 - vget_lane_u32(sum, 0);\n    }\n    \n    // Handle remaining elements\n    for(int i = simd_iters*4; i < n/2; i++) {\n        if(arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 pairs at a time using NEON\n    int simd_iters = n/8;\n    for(int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        int32x4_t v1 = vld1q_s32(&arr[i*4]);\n        int32x4_t v2 = vld1q_s32(&arr[n-4-(i*4)]);\n        \n        // Reverse elements from end\n        int32x4_t v2_rev = vrev64q_s32(v2);\n        v2_rev = vcombine_s32(vget_high_s32(v2_rev), vget_low_s32(v2_rev));\n        \n        // Compare vectors\n        uint32x4_t cmp = vceqq_s32(v1, v2_rev);\n        \n        // Count non-matching elements\n        uint32x2_t sum = vpadd_u32(vget_low_u32(cmp), vget_high_u32(cmp));\n        sum = vpadd_u32(sum, sum);\n        changes += 4 - vget_lane_u32(sum, 0);\n    }\n    \n    // Handle remaining elements\n    for(int i = simd_iters*4; i < n/2; i++) {\n        if(arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 pairs at a time using NEON\n    int i = 0;\n    int j = n - 1;\n    \n    while (i + 4 <= j - 3) {\n        // Load 4 elements from start and end\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[j-3]);\n        \n        // Reverse elements from end\n        int32x4_t v2_rev = vrev64q_s32(v2);\n        v2_rev = vcombine_s32(vget_high_s32(v2_rev), vget_low_s32(v2_rev));\n        \n        // Compare vectors\n        uint32x4_t neq = vmvnq_u32(vceqq_s32(v1, v2_rev));\n        \n        // Count non-equal elements\n        uint32x2_t sum = vpadd_u32(vget_low_u32(neq), vget_high_u32(neq));\n        sum = vpadd_u32(sum, sum);\n        changes += vget_lane_u32(sum, 0);\n        \n        i += 4;\n        j -= 4;\n    }\n    \n    // Handle remaining elements\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            changes++;\n        }\n        i++;\n        j--;\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Process 4 pairs at a time using NEON\n    int i = 0;\n    int j = n - 1;\n    \n    while (i + 4 <= j - 3) {\n        // Load 4 elements from start and end\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[j-3]);\n        \n        // Reverse elements from end\n        int32x4_t v2_rev = vrev64q_s32(v2);\n        v2_rev = vcombine_s32(vget_high_s32(v2_rev), vget_low_s32(v2_rev));\n        \n        // Compare vectors\n        uint32x4_t cmp = vceqq_s32(v1, v2_rev);\n        \n        // Count non-matching elements\n        uint32x2_t sum = vpadd_u32(vget_low_u32(cmp), vget_high_u32(cmp));\n        sum = vpadd_u32(sum, sum);\n        changes += 4 - vget_lane_u32(sum, 0);\n        \n        i += 4;\n        j -= 4;\n    }\n    \n    // Handle remaining elements\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            changes++;\n        }\n        i++;\n        j--;\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    // Calculate total chars in lst1\n    size_t total1 = 0;\n    size_t len1 = lst1.size();\n    uint32_t lengths1[4] = {0};\n    \n    for (size_t i = 0; i < len1; i += 4) {\n        size_t remaining = std::min(size_t(4), len1 - i);\n        for (size_t j = 0; j < remaining; j++) {\n            lengths1[j] = lst1[i + j].length();\n        }\n        \n        uint32x4_t vec = vld1q_u32(lengths1);\n        uint32x2_t sum = vadd_u32(vget_low_u32(vec), vget_high_u32(vec));\n        sum = vpadd_u32(sum, sum);\n        total1 += vget_lane_u32(sum, 0);\n    }\n\n    // Calculate total chars in lst2\n    size_t total2 = 0;\n    size_t len2 = lst2.size();\n    uint32_t lengths2[4] = {0};\n    \n    for (size_t i = 0; i < len2; i += 4) {\n        size_t remaining = std::min(size_t(4), len2 - i);\n        for (size_t j = 0; j < remaining; j++) {\n            lengths2[j] = lst2[i + j].length();\n        }\n        \n        uint32x4_t vec = vld1q_u32(lengths2);\n        uint32x2_t sum = vadd_u32(vget_low_u32(vec), vget_high_u32(vec));\n        sum = vpadd_u32(sum, sum);\n        total2 += vget_lane_u32(sum, 0);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    // Calculate total chars in lst1\n    size_t total1 = 0;\n    size_t len1 = lst1.size();\n    uint32_t lens1[4] = {0};\n    \n    for (size_t i = 0; i < len1; i += 4) {\n        size_t remaining = std::min(size_t(4), len1 - i);\n        for (size_t j = 0; j < remaining; j++) {\n            lens1[j] = lst1[i + j].length();\n        }\n        \n        uint32x4_t vec = vld1q_u32(lens1);\n        uint32x2_t sum = vadd_u32(vget_low_u32(vec), vget_high_u32(vec));\n        uint32x2_t folded = vpadd_u32(sum, sum);\n        total1 += vget_lane_u32(folded, 0);\n    }\n\n    // Calculate total chars in lst2  \n    size_t total2 = 0;\n    size_t len2 = lst2.size();\n    uint32_t lens2[4] = {0};\n    \n    for (size_t i = 0; i < len2; i += 4) {\n        size_t remaining = std::min(size_t(4), len2 - i);\n        for (size_t j = 0; j < remaining; j++) {\n            lens2[j] = lst2[i + j].length();\n        }\n        \n        uint32x4_t vec = vld1q_u32(lens2);\n        uint32x2_t sum = vadd_u32(vget_low_u32(vec), vget_high_u32(vec));\n        uint32x2_t folded = vpadd_u32(sum, sum);\n        total2 += vget_lane_u32(folded, 0);\n    }\n\n    // Return vector with smaller total chars\n    if (total2 < total1) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    // Process 4 strings at a time using NEON\n    uint32x4_t sum1 = vdupq_n_u32(0);\n    uint32x4_t sum2 = vdupq_n_u32(0);\n    \n    size_t i = 0;\n    for (; i + 4 <= lst1.size(); i += 4) {\n        uint32x4_t lens = {\n            static_cast<uint32_t>(lst1[i].length()),\n            static_cast<uint32_t>(lst1[i+1].length()),\n            static_cast<uint32_t>(lst1[i+2].length()),\n            static_cast<uint32_t>(lst1[i+3].length())\n        };\n        sum1 = vaddq_u32(sum1, lens);\n    }\n    \n    // Handle remaining elements\n    for (; i < lst1.size(); i++) {\n        total1 += lst1[i].length();\n    }\n    \n    // Add up the 4 lanes of sum1\n    total1 += vgetq_lane_u32(sum1, 0) + vgetq_lane_u32(sum1, 1) + \n              vgetq_lane_u32(sum1, 2) + vgetq_lane_u32(sum1, 3);\n              \n    i = 0;\n    for (; i + 4 <= lst2.size(); i += 4) {\n        uint32x4_t lens = {\n            static_cast<uint32_t>(lst2[i].length()),\n            static_cast<uint32_t>(lst2[i+1].length()),\n            static_cast<uint32_t>(lst2[i+2].length()),\n            static_cast<uint32_t>(lst2[i+3].length())\n        };\n        sum2 = vaddq_u32(sum2, lens);\n    }\n    \n    for (; i < lst2.size(); i++) {\n        total2 += lst2[i].length();\n    }\n    \n    total2 += vgetq_lane_u32(sum2, 0) + vgetq_lane_u32(sum2, 1) + \n              vgetq_lane_u32(sum2, 2) + vgetq_lane_u32(sum2, 3);\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    // Calculate total chars in lst1\n    size_t total1 = 0;\n    size_t len1 = lst1.size();\n    uint32_t lengths1[4] = {0};\n    \n    for (size_t i = 0; i < len1; i += 4) {\n        size_t remaining = std::min(size_t(4), len1 - i);\n        for (size_t j = 0; j < remaining; j++) {\n            lengths1[j] = lst1[i + j].length();\n        }\n        \n        uint32x4_t vec = vld1q_u32(lengths1);\n        uint32x2_t sum = vadd_u32(vget_low_u32(vec), vget_high_u32(vec));\n        sum = vpadd_u32(sum, sum);\n        total1 += vget_lane_u32(sum, 0);\n    }\n\n    // Calculate total chars in lst2  \n    size_t total2 = 0;\n    size_t len2 = lst2.size();\n    uint32_t lengths2[4] = {0};\n    \n    for (size_t i = 0; i < len2; i += 4) {\n        size_t remaining = std::min(size_t(4), len2 - i);\n        for (size_t j = 0; j < remaining; j++) {\n            lengths2[j] = lst2[i + j].length();\n        }\n        \n        uint32x4_t vec = vld1q_u32(lengths2);\n        uint32x2_t sum = vadd_u32(vget_low_u32(vec), vget_high_u32(vec));\n        sum = vpadd_u32(sum, sum);\n        total2 += vget_lane_u32(sum, 0);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    // Process 8 characters at a time using NEON\n    uint8x16_t sum1 = vdupq_n_u8(0);\n    uint8x16_t sum2 = vdupq_n_u8(0);\n    \n    // Calculate sum for lst1\n    for (const auto& str : lst1) {\n        const size_t len = str.length();\n        const char* ptr = str.c_str();\n        size_t i = 0;\n        \n        // Process 16 bytes at a time\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)(ptr + i));\n            sum1 = vaddq_u8(sum1, chars);\n        }\n        \n        // Handle remaining bytes\n        for (; i < len; i++) {\n            total1 += (unsigned char)ptr[i];\n        }\n    }\n    \n    // Calculate sum for lst2\n    for (const auto& str : lst2) {\n        const size_t len = str.length();\n        const char* ptr = str.c_str();\n        size_t i = 0;\n        \n        // Process 16 bytes at a time\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)(ptr + i));\n            sum2 = vaddq_u8(sum2, chars);\n        }\n        \n        // Handle remaining bytes\n        for (; i < len; i++) {\n            total2 += (unsigned char)ptr[i];\n        }\n    }\n    \n    // Sum up the NEON vectors\n    uint8_t temp1[16], temp2[16];\n    vst1q_u8(temp1, sum1);\n    vst1q_u8(temp2, sum2);\n    \n    for (int i = 0; i < 16; i++) {\n        total1 += temp1[i];\n        total2 += temp2[i];\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_result = vdupq_n_u64(1);\n    uint64x2_t vec_one = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(vec_result, 0) < x) {\n        vec_result = vmulq_u64(vec_result, vec_n);\n        \n        // Check for overflow\n        if (vgetq_lane_u64(vec_result, 0) == 0) {\n            return false;\n        }\n    }\n\n    return vgetq_lane_u64(vec_result, 0) == x;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_result = vdupq_n_u64(1);\n    uint64x2_t vec_one = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(vec_result, 0) <= x) {\n        if (vgetq_lane_u64(vec_result, 0) == x) {\n            return true;\n        }\n        vec_result = vmulq_u64(vec_result, vec_n);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_result = vdupq_n_u64(1);\n    uint64x2_t vec_one = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(vec_result, 0) < x) {\n        vec_result = vmulq_u64(vec_result, vec_n);\n        \n        // Check for overflow\n        if (vgetq_lane_u64(vec_result, 0) == 0) {\n            return false;\n        }\n    }\n\n    return vgetq_lane_u64(vec_result, 0) == x;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t one = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(result, 0) < x) {\n        result = vmulq_u64(result, vec_n);\n        \n        if (vgetq_lane_u64(result, 0) == x) {\n            return true;\n        }\n        \n        if (vgetq_lane_u64(result, 0) > x) {\n            return false;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n == 0 || n == 1) return false;\n\n    uint64x2_t vec_x = vdupq_n_u64(x);\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t one = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(result, 0) <= x) {\n        result = vmulq_u64(result, vec_n);\n        if (vgetq_lane_u64(result, 0) == x) {\n            return true;\n        }\n        if (vgetq_lane_u64(result, 0) > x) {\n            break;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string& num) {\n    if (num.empty()) return 0;\n    \n    const int len = num.length();\n    int count = 0;\n    \n    // Load lookup table for prime hex digits (0-15)\n    // 1 for prime digits (2,3,5,7,11,13), 0 for others\n    static const uint8_t prime_lookup[16] = {\n        0,0,1,1,0,1,0,1,0,0,0,1,0,1,0,0\n    };\n    \n    uint8x16_t prime_mask = vld1q_u8(prime_lookup);\n    \n    // Process 16 characters at a time\n    int i;\n    for(i = 0; i + 15 < len; i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&num[i]);\n        \n        // Convert ASCII hex chars to 4-bit values\n        uint8x16_t num_vals = vdupq_n_u8(0);\n        \n        // Handle 0-9\n        uint8x16_t is_num = vcleq_u8(input, vdupq_n_u8('9'));\n        uint8x16_t num_part = vsubq_u8(input, vdupq_n_u8('0'));\n        num_vals = vbslq_u8(is_num, num_part, num_vals);\n        \n        // Handle A-F\n        uint8x16_t is_letter = vcgtq_u8(input, vdupq_n_u8('9'));\n        uint8x16_t letter_part = vsubq_u8(input, vdupq_n_u8('A' - 10));\n        num_vals = vbslq_u8(is_letter, letter_part, num_vals);\n        \n        // Lookup prime values\n        uint8x16_t prime_vals = vqtbl1q_u8(prime_mask, num_vals);\n        \n        // Count ones\n        count += vaddvq_u8(prime_vals);\n    }\n    \n    // Handle remaining characters\n    for(; i < len; i++) {\n        int val;\n        if(num[i] >= '0' && num[i] <= '9')\n            val = num[i] - '0';\n        else\n            val = num[i] - 'A' + 10;\n            \n        count += prime_lookup[val];\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Process 16 characters at a time\n    for (int i = 0; i < len - 15; i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&num[i]);\n        \n        // Create masks for different ranges\n        uint8x16_t digit_0_9 = vcgeq_u8(input, vdupq_n_u8('0'));\n        digit_0_9 = vandq_u8(digit_0_9, vcleq_u8(input, vdupq_n_u8('9')));\n        \n        uint8x16_t digit_AF = vcgeq_u8(input, vdupq_n_u8('A'));\n        digit_AF = vandq_u8(digit_AF, vcleq_u8(input, vdupq_n_u8('F')));\n        \n        // Convert ASCII to values\n        uint8x16_t values = vbslq_u8(digit_0_9,\n                                    vsubq_u8(input, vdupq_n_u8('0')),\n                                    vsubq_u8(input, vsubq_u8(vdupq_n_u8('A'), vdupq_n_u8(10))));\n                                    \n        // Check for prime numbers (2,3,5,7,11,13)\n        uint8x16_t is_2 = vceqq_u8(values, vdupq_n_u8(2));\n        uint8x16_t is_3 = vceqq_u8(values, vdupq_n_u8(3));\n        uint8x16_t is_5 = vceqq_u8(values, vdupq_n_u8(5));\n        uint8x16_t is_7 = vceqq_u8(values, vdupq_n_u8(7));\n        uint8x16_t is_11 = vceqq_u8(values, vdupq_n_u8(11));\n        uint8x16_t is_13 = vceqq_u8(values, vdupq_n_u8(13));\n        \n        // Combine results\n        uint8x16_t is_prime = vorrq_u8(is_2, is_3);\n        is_prime = vorrq_u8(is_prime, is_5);\n        is_prime = vorrq_u8(is_prime, is_7);\n        is_prime = vorrq_u8(is_prime, is_11);\n        is_prime = vorrq_u8(is_prime, is_13);\n        \n        // Count set bits\n        count += vaddvq_u8(vandq_u8(is_prime, vdupq_n_u8(1)));\n    }\n    \n    // Handle remaining characters\n    for (int i = (len/16)*16; i < len; i++) {\n        char c = num[i];\n        int val;\n        if (c >= '0' && c <= '9') {\n            val = c - '0';\n        } else {\n            val = c - 'A' + 10;\n        }\n        if (val == 2 || val == 3 || val == 5 || val == 7 || val == 11 || val == 13) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    const int len = num.length();\n    const int vec_size = 16;\n    const int iterations = len / vec_size;\n    const int remainder = len % vec_size;\n    \n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    uint8x16_t two_three = vdupq_n_u8(0);\n    uint8x16_t five_seven = vdupq_n_u8(0);\n    uint8x16_t bd = vdupq_n_u8(0);\n    \n    // Set masks for prime hex digits (2,3,5,7,B,D)\n    prime_mask = vsetq_lane_u8(1, prime_mask, '2' - '0');\n    prime_mask = vsetq_lane_u8(1, prime_mask, '3' - '0');\n    prime_mask = vsetq_lane_u8(1, prime_mask, '5' - '0');\n    prime_mask = vsetq_lane_u8(1, prime_mask, '7' - '0');\n    prime_mask = vsetq_lane_u8(1, prime_mask, 'B' - '0');\n    prime_mask = vsetq_lane_u8(1, prime_mask, 'D' - '0');\n\n    int count = 0;\n    \n    // Process 16 characters at a time\n    for (int i = 0; i < iterations; i++) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&num[i * vec_size]);\n        \n        // Convert ASCII to hex value\n        uint8x16_t digits = input;\n        uint8x16_t ascii_nums = vdupq_n_u8('0');\n        uint8x16_t ascii_letters = vdupq_n_u8('A' - 10);\n        \n        uint8x16_t is_letter = vcgtq_u8(input, vdupq_n_u8('9'));\n        digits = vsubq_u8(digits, vbslq_u8(is_letter, ascii_letters, ascii_nums));\n        \n        // Check if digit is prime using lookup\n        uint8x16_t matches = vqtbl1q_u8(prime_mask, digits);\n        \n        // Count matches\n        count += vaddvq_u8(matches);\n    }\n    \n    // Handle remaining characters\n    for (int i = iterations * vec_size; i < len; i++) {\n        char c = num[i];\n        int digit;\n        if (c >= '0' && c <= '9')\n            digit = c - '0';\n        else\n            digit = c - 'A' + 10;\n            \n        if (digit == 2 || digit == 3 || digit == 5 || digit == 7 || \n            digit == 11 || digit == 13)\n            count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if(num.empty()) return 0;\n    \n    const int len = num.length();\n    const uint8_t* str = (const uint8_t*)num.c_str();\n    \n    // Create lookup table for prime hex digits\n    uint8_t prime_lut[256] = {0};\n    prime_lut['2'] = 1;\n    prime_lut['3'] = 1; \n    prime_lut['5'] = 1;\n    prime_lut['7'] = 1;\n    prime_lut['B'] = 1;\n    prime_lut['D'] = 1;\n\n    int count = 0;\n    int i = 0;\n\n    // Process 16 bytes at a time using NEON\n    for(; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(str + i);\n        uint8x16_t result = vld1q_u8(prime_lut + str[i]);\n        \n        // Count set bits\n        uint8x16_t cnt8 = vcntq_u8(result);\n        uint16x8_t cnt16 = vpaddlq_u8(cnt8);\n        uint32x4_t cnt32 = vpaddlq_u16(cnt16);\n        uint64x2_t cnt64 = vpaddlq_u32(cnt32);\n        \n        count += vgetq_lane_u64(cnt64, 0) + vgetq_lane_u64(cnt64, 1);\n    }\n\n    // Handle remaining bytes\n    for(; i < len; i++) {\n        count += prime_lut[str[i]];\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Process 16 characters at a time\n    for (int i = 0; i < len - 15; i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&num[i]);\n        \n        // Check for digits 2,3,5,7\n        uint8x16_t eq2 = vceqq_u8(input, vdupq_n_u8('2'));\n        uint8x16_t eq3 = vceqq_u8(input, vdupq_n_u8('3')); \n        uint8x16_t eq5 = vceqq_u8(input, vdupq_n_u8('5'));\n        uint8x16_t eq7 = vceqq_u8(input, vdupq_n_u8('7'));\n        \n        // Check for B(11) and D(13)\n        uint8x16_t eqB = vceqq_u8(input, vdupq_n_u8('B'));\n        uint8x16_t eqD = vceqq_u8(input, vdupq_n_u8('D'));\n        \n        // Combine results\n        uint8x16_t result = vorrq_u8(eq2, eq3);\n        result = vorrq_u8(result, eq5);\n        result = vorrq_u8(result, eq7);\n        result = vorrq_u8(result, eqB);\n        result = vorrq_u8(result, eqD);\n        \n        // Count matches\n        uint8x8_t sum = vadd_u8(vget_low_u8(result), vget_high_u8(result));\n        count += vaddv_u8(sum);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len/16)*16; i < len; i++) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || \n            c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const size_t len = s.length();\n    const size_t simd_len = len - 2;\n    const size_t step = 16;\n\n    for (size_t i = 0; i < simd_len; i += step) {\n        size_t chunk = std::min(step, simd_len - i);\n        \n        if (chunk >= 16) {\n            uint8x16_t v1 = vld1q_u8((uint8_t*)&s[i]);\n            uint8x16_t v2 = vld1q_u8((uint8_t*)&s[i+1]); \n            uint8x16_t v3 = vld1q_u8((uint8_t*)&s[i+2]);\n\n            uint8x16_t eq12 = vceqq_u8(v1, v2);\n            uint8x16_t eq23 = vceqq_u8(v2, v3);\n            uint8x16_t eq13 = vceqq_u8(v1, v3);\n            \n            uint8x16_t any_eq = vorrq_u8(vorrq_u8(eq12, eq23), eq13);\n            \n            uint64x2_t res = vreinterpretq_u64_u8(any_eq);\n            if (vgetq_lane_u64(res, 0) || vgetq_lane_u64(res, 1)) {\n                return false;\n            }\n        } else {\n            for (size_t j = i; j < i + chunk; j++) {\n                if (s[j] == s[j+1] || s[j] == s[j+2] || s[j+1] == s[j+2]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const size_t len = s.length();\n    const size_t simd_len = len - 2;\n    const size_t step = 16;\n\n    for (size_t i = 0; i < simd_len; i += step) {\n        size_t chunk = std::min(step, simd_len - i);\n        \n        if (chunk >= 16) {\n            uint8x16_t v1 = vld1q_u8((const uint8_t*)&s[i]);\n            uint8x16_t v2 = vld1q_u8((const uint8_t*)&s[i+1]); \n            uint8x16_t v3 = vld1q_u8((const uint8_t*)&s[i+2]);\n\n            uint8x16_t eq12 = vceqq_u8(v1, v2);\n            uint8x16_t eq23 = vceqq_u8(v2, v3);\n            uint8x16_t eq13 = vceqq_u8(v1, v3);\n            \n            uint8x16_t any_eq = vorrq_u8(vorrq_u8(eq12, eq23), eq13);\n            \n            if (vmaxvq_u8(any_eq) != 0) {\n                return false;\n            }\n        } else {\n            for (size_t j = i; j < i + chunk; j++) {\n                if (s[j] == s[j+1] || s[j] == s[j+2] || s[j+1] == s[j+2]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const size_t len = s.length();\n    const size_t simd_len = len - 2;\n    const size_t step = 16;\n\n    for (size_t i = 0; i < simd_len; i += step) {\n        size_t chunk = std::min(step, simd_len - i);\n        \n        if (chunk >= 16) {\n            uint8x16_t v1 = vld1q_u8((const uint8_t*)&s[i]);\n            uint8x16_t v2 = vld1q_u8((const uint8_t*)&s[i+1]); \n            uint8x16_t v3 = vld1q_u8((const uint8_t*)&s[i+2]);\n\n            uint8x16_t eq12 = vceqq_u8(v1, v2);\n            uint8x16_t eq23 = vceqq_u8(v2, v3);\n            uint8x16_t eq13 = vceqq_u8(v1, v3);\n            \n            uint8x16_t any_eq = vorrq_u8(vorrq_u8(eq12, eq23), eq13);\n            \n            if (vmaxvq_u8(any_eq) != 0) {\n                return false;\n            }\n        } else {\n            for (size_t j = i; j < i + chunk; j++) {\n                if (s[j] == s[j+1] || s[j] == s[j+2] || s[j+1] == s[j+2]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const size_t len = s.length();\n    const size_t simd_width = 16;\n    const size_t vec_size = len - 2;\n    \n    // Process 16 elements at a time\n    for (size_t i = 0; i < vec_size; i += simd_width) {\n        size_t chunk_size = std::min(simd_width, vec_size - i);\n        \n        if (chunk_size >= 3) {\n            uint8x16_t vec1 = vld1q_u8((const uint8_t*)&s[i]);\n            uint8x16_t vec2 = vld1q_u8((const uint8_t*)&s[i+1]); \n            uint8x16_t vec3 = vld1q_u8((const uint8_t*)&s[i+2]);\n\n            // Check if any 3 consecutive chars are equal\n            uint8x16_t mask1 = vceqq_u8(vec1, vec2);\n            uint8x16_t mask2 = vceqq_u8(vec2, vec3);\n            uint8x16_t mask3 = vceqq_u8(vec1, vec3);\n            \n            uint8x16_t result = vorrq_u8(vorrq_u8(mask1, mask2), mask3);\n            \n            uint64x2_t hi_lo = vreinterpretq_u64_u8(result);\n            uint64_t r = vgetq_lane_u64(hi_lo, 0) | vgetq_lane_u64(hi_lo, 1);\n            \n            if (r != 0) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t j = i; j < i + chunk_size - 2; j++) {\n            if (s[j] == s[j+1] || s[j+1] == s[j+2] || s[j] == s[j+2]) {\n                return false;\n            }\n        }\n    }\n    \n    // Check last triplet if not covered by SIMD\n    size_t remaining = len % simd_width;\n    if (remaining >= 3) {\n        size_t start = len - 3;\n        if (s[start] == s[start+1] || s[start+1] == s[start+2] || s[start] == s[start+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length() - 2;\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n\n    for (int i = 0; i < len; i += 16) {\n        int block_size = std::min(16, len - i);\n        \n        if (block_size >= 16) {\n            uint8x16_t v1 = vld1q_u8(str + i);\n            uint8x16_t v2 = vld1q_u8(str + i + 1); \n            uint8x16_t v3 = vld1q_u8(str + i + 2);\n\n            uint8x16_t eq1 = vceqq_u8(v1, v2);\n            uint8x16_t eq2 = vceqq_u8(v2, v3);\n            uint8x16_t eq3 = vceqq_u8(v1, v3);\n            \n            uint8x16_t any_equal = vorrq_u8(vorrq_u8(eq1, eq2), eq3);\n            \n            if (vmaxvq_u8(any_equal) != 0) {\n                return false;\n            }\n        } else {\n            for (int j = i; j < i + block_size; j++) {\n                if (str[j] == str[j+1] || str[j] == str[j+2] || str[j+1] == str[j+2]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n    \n    uint32_t sqrtLen = sqrt(len);\n    uint32_t i = 3;\n    \n    uint32x4_t vLen = vdupq_n_u32(len);\n    uint32x4_t vIndices;\n    \n    while (i <= sqrtLen) {\n        vIndices = vdupq_n_u32(i);\n        vIndices = vaddq_u32(vIndices, vdupq_n_u32(0));\n        vIndices = vaddq_u32(vIndices, vdupq_n_u32(1));\n        vIndices = vaddq_u32(vIndices, vdupq_n_u32(2));\n        vIndices = vaddq_u32(vIndices, vdupq_n_u32(3));\n        \n        uint32x4_t vRem = vmodq_u32(vLen, vIndices);\n        uint32x4_t vCmp = vceqq_u32(vRem, vdupq_n_u32(0));\n        \n        if (vgetq_lane_u32(vCmp, 0) || \n            vgetq_lane_u32(vCmp, 1) || \n            vgetq_lane_u32(vCmp, 2) || \n            vgetq_lane_u32(vCmp, 3)) {\n            return false;\n        }\n        \n        i += 4;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    uint32_t limit = sqrt(len);\n    uint32_t i = 3;\n\n    uint32x4_t vec_num = vdupq_n_u32(len);\n    uint32x4_t vec_inc = {0, 1, 2, 3};\n    \n    for (; i + 4 <= limit; i += 4) {\n        uint32x4_t vec_div = vaddq_u32(vdupq_n_u32(i), vec_inc);\n        uint32x4_t vec_rem = vmodq_u32(vec_num, vec_div);\n        uint32x4_t vec_zero = vdupq_n_u32(0);\n        uint32x4_t vec_cmp = vceqq_u32(vec_rem, vec_zero);\n        \n        if (vgetq_lane_u32(vec_cmp, 0) || \n            vgetq_lane_u32(vec_cmp, 1) ||\n            vgetq_lane_u32(vec_cmp, 2) || \n            vgetq_lane_u32(vec_cmp, 3)) {\n            return false;\n        }\n    }\n\n    for (; i <= limit; i++) {\n        if (len % i == 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    uint32_t sqrtLen = sqrt(len);\n    uint32_t i = 3;\n\n    uint32x4_t vLen = vdupq_n_u32(len);\n    uint32x4_t vIndices;\n    uint32_t indices[4] = {0,1,2,3};\n\n    while (i <= sqrtLen) {\n        vIndices = vld1q_u32(indices);\n        vIndices = vmulq_n_u32(vIndices, 4);\n        vIndices = vaddq_u32(vIndices, vdupq_n_u32(i));\n\n        uint32x4_t vDivs = vdivq_u32(vLen, vIndices);\n        vDivs = vmulq_u32(vDivs, vIndices);\n        uint32x4_t vCmp = vceqq_u32(vDivs, vLen);\n        \n        uint32_t results[4];\n        vst1q_u32(results, vCmp);\n\n        for(int j = 0; j < 4; j++) {\n            if(indices[j] + i <= sqrtLen && results[j]) {\n                return false;\n            }\n        }\n\n        i += 4;\n        indices[0] += 4;\n        indices[1] += 4; \n        indices[2] += 4;\n        indices[3] += 4;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    uint32_t sqrt_len = sqrt(len);\n    uint32_t i = 3;\n\n    uint32x4_t vec_len = vdupq_n_u32(len);\n    uint32x4_t increment = {0, 1, 2, 3};\n    \n    for (; i + 3 <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = vaddq_u32(vdupq_n_u32(i), increment);\n        uint32x4_t quotient = vdivq_u32(vec_len, vec_i);\n        uint32x4_t product = vmulq_u32(quotient, vec_i);\n        uint32x4_t compare = vceqq_u32(vec_len, product);\n        \n        if (vgetq_lane_u32(compare, 0) || \n            vgetq_lane_u32(compare, 1) || \n            vgetq_lane_u32(compare, 2) || \n            vgetq_lane_u32(compare, 3)) {\n            return false;\n        }\n    }\n\n    for (; i <= sqrt_len; i++) {\n        if (len % i == 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n\n    uint32_t sqrt_len = sqrt(len);\n    uint32_t i = 3;\n\n    uint32x4_t vec_len = vdupq_n_u32(len);\n    uint32x4_t increment = {0, 1, 2, 3};\n    \n    for (; i + 4 <= sqrt_len; i += 4) {\n        uint32x4_t vec_i = vaddq_u32(vdupq_n_u32(i), increment);\n        uint32x4_t quotient = vdivq_u32(vec_len, vec_i);\n        uint32x4_t product = vmulq_u32(quotient, vec_i);\n        uint32x4_t compare = vceqq_u32(product, vec_len);\n        \n        uint32_t mask = vaddvq_u32(compare);\n        if (mask > 0) return false;\n    }\n\n    for (; i <= sqrt_len; i++) {\n        if (len % i == 0) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digits = vdupq_n_u8(0);\n    uint8x16_t ten = vdupq_n_u8(10);\n    uint8_t sum = 0;\n    \n    // Convert to array of digits\n    int idx = 0;\n    while (N > 0) {\n        uint8_t digit = N % 10;\n        digits = vsetq_lane_u8(digit, digits, idx++);\n        N /= 10;\n        if (idx == 16) break;\n    }\n\n    // Sum digits using SIMD\n    uint16x8_t sum_vec = vpaddlq_u8(digits);\n    uint32x4_t sum_vec32 = vpaddlq_u16(sum_vec);\n    uint64x2_t sum_vec64 = vpaddlq_u32(sum_vec32);\n    sum = vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec64), 0) + \n          vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec64), 8);\n\n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = (sum & 1 ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digits = vdupq_n_u8(0);\n    uint8x16_t ten = vdupq_n_u8(10);\n    uint8x16_t sum = vdupq_n_u8(0);\n    \n    // Convert number to digits\n    int idx = 0;\n    while (N > 0) {\n        uint8_t digit = N % 10;\n        digits = vsetq_lane_u8(digit, digits, idx++);\n        N /= 10;\n        if (idx == 16) break;\n    }\n\n    // Sum digits using SIMD\n    sum = vpaddlq_u8(digits);\n    uint32x4_t sum32 = vpaddlq_u16(vpaddlq_u8(digits));\n    uint64x2_t sum64 = vpaddlq_u32(sum32);\n    uint64_t total = vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n\n    // Convert to binary string\n    if (total == 0) return \"0\";\n    \n    std::string result;\n    while (total > 0) {\n        result = ((total & 1) ? \"1\" : \"0\") + result;\n        total >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digits = vdupq_n_u8(0);\n    uint8x16_t ten = vdupq_n_u8(10);\n    uint8_t sum = 0;\n    \n    // Convert number to array of digits\n    int idx = 0;\n    while (N > 0) {\n        uint8_t digit = N % 10;\n        digits = vsetq_lane_u8(digit, digits, idx++);\n        N /= 10;\n        if (idx == 16) break;\n    }\n\n    // Sum digits using SIMD\n    uint16x8_t sum_vec = vpaddlq_u8(digits);\n    uint32x4_t sum_vec2 = vpaddlq_u16(sum_vec);\n    uint64x2_t sum_vec3 = vpaddlq_u32(sum_vec2);\n    sum = vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec3), 0) + \n          vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec3), 8);\n\n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = ((sum & 1) ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digits = vdupq_n_u8(0);\n    uint8x16_t ten = vdupq_n_u8(10);\n    uint8_t sum = 0;\n    \n    // Convert number to array of digits\n    int idx = 0;\n    while (N > 0) {\n        uint8_t digit = N % 10;\n        digits = vsetq_lane_u8(digit, digits, idx++);\n        N /= 10;\n        if (idx == 16) break;\n    }\n    \n    // Sum digits using SIMD\n    uint16x8_t sum_vec = vpaddlq_u8(digits);\n    uint32x4_t sum_vec2 = vpaddlq_u16(sum_vec);\n    uint64x2_t sum_vec3 = vpaddlq_u32(sum_vec2);\n    sum = vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec3), 0) + \n          vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec3), 8);\n\n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = ((sum & 1) ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digits = vdupq_n_u8(0);\n    uint8x16_t ten = vdupq_n_u8(10);\n    uint8_t sum = 0;\n    \n    // Convert to array of digits\n    int idx = 0;\n    while (N > 0) {\n        uint8_t digit = N % 10;\n        digits = vsetq_lane_u8(digit, digits, idx++);\n        N /= 10;\n        if (idx == 16) break;\n    }\n\n    // Sum digits using SIMD\n    uint16x8_t sum_vec = vpaddlq_u8(digits);\n    uint32x4_t sum_vec2 = vpaddlq_u16(sum_vec);\n    uint64x2_t sum_vec3 = vpaddlq_u32(sum_vec2);\n    sum = vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec3), 0) + \n          vgetq_lane_u8(vreinterpretq_u8_u64(sum_vec3), 8);\n\n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = ((sum & 1) ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n    \n    // Process 4 elements at a time\n    int vectorSize = size / 4 * 4;\n    for (int i = 0; i < vectorSize; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create mask for odd indices (1,3,...)\n        int32x4_t indices = {0,1,2,3};\n        uint32x4_t odd_mask = vtstq_s32(indices, vdupq_n_s32(1));\n        \n        // Create mask for even numbers\n        uint32x4_t even_mask = vtstq_s32(vec, vdupq_n_s32(1));\n        even_mask = vmvnq_u32(even_mask);\n        \n        // Combine masks\n        uint32x4_t final_mask = vandq_u32(odd_mask, even_mask);\n        \n        // Zero out unwanted elements\n        int32x4_t masked = vreinterpretq_s32_u32(vandq_u32(vreinterpretq_u32_s32(vec), final_mask));\n        \n        // Horizontal add\n        int32x2_t sum = vadd_s32(vget_low_s32(masked), vget_high_s32(masked));\n        sum = vpadd_s32(sum, sum);\n        result += vget_lane_s32(sum, 0);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorSize; i < size; i++) {\n        if ((i % 2 == 1) && (lst[i] % 2 == 0)) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n    \n    // Process 4 elements at a time\n    int vec_size = size / 4;\n    for(int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create mask for odd indices (1,3,...)\n        uint32x4_t odd_mask = vcreq_u32(vdupq_n_u32(1), vandq_u32(vdupq_n_u32(1), \n                             vreinterpretq_u32_s32(vaddq_s32(vdupq_n_s32(i), \n                             vld1q_s32((int32_t[]){0,1,2,3})))));\n                             \n        // Create mask for even values\n        int32x4_t even_mask = vreinterpretq_s32_u32(\n                             vcleq_s32(vandq_s32(vec, vdupq_n_s32(1)), \n                             vdupq_n_s32(0)));\n                             \n        // Combine masks and multiply with values\n        int32x4_t masked = vandq_s32(vec, \n                          vandq_s32(vreinterpretq_s32_u32(odd_mask), even_mask));\n        \n        // Horizontal add\n        int32x2_t sum = vadd_s32(vget_low_s32(masked), vget_high_s32(masked));\n        sum = vpadd_s32(sum, sum);\n        result += vget_lane_s32(sum, 0);\n    }\n    \n    // Handle remaining elements\n    for(int i = vec_size * 4; i < size; i++) {\n        if(i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n    \n    // Process 4 elements at a time\n    int vec_size = size / 4;\n    for(int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create mask for odd indices (1,3)\n        uint32x4_t odd_mask = vdupq_n_u32(0);\n        odd_mask = vsetq_lane_u32(0xFFFFFFFF, odd_mask, 1);\n        odd_mask = vsetq_lane_u32(0xFFFFFFFF, odd_mask, 3);\n        \n        // Create mask for even numbers\n        int32x4_t even_mask = vreinterpretq_s32_u32(\n            vceqq_u32(vandq_u32(vreinterpretq_u32_s32(vec), vdupq_n_u32(1)), vdupq_n_u32(0))\n        );\n        \n        // Combine masks and get values\n        int32x4_t masked = vandq_s32(vec, vandq_s32(even_mask, vreinterpretq_s32_u32(odd_mask)));\n        \n        // Horizontal add\n        int32x2_t sum = vadd_s32(vget_low_s32(masked), vget_high_s32(masked));\n        result += vget_lane_s32(vpadd_s32(sum, sum), 0);\n    }\n    \n    // Handle remaining elements\n    for(int i = vec_size * 4; i < size; i++) {\n        if((i % 2 == 1) && (lst[i] % 2 == 0)) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n    \n    // Process 4 elements at a time\n    int i = 1; // Start from odd indices\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t mask = vdupq_n_s32(1);\n        int32x4_t even_mask = vshrq_n_s32(vec, 1);\n        even_mask = vmlaq_s32(even_mask, even_mask, vdupq_n_s32(1));\n        even_mask = vsubq_s32(vec, even_mask);\n        int32x4_t masked = vbicq_s32(vec, even_mask);\n        \n        int32x2_t sum = vpadd_s32(vget_low_s32(vreinterpretq_s32_s32(masked)), \n                                 vget_high_s32(vreinterpretq_s32_s32(masked)));\n        sum = vpadd_s32(sum, sum);\n        result += vget_lane_s32(sum, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int result = 0;\n    \n    // Process 4 elements at a time\n    int vec_size = size / 4;\n    for(int i = 0; i < vec_size * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create mask for odd indices (1,3)\n        uint32x4_t mask = vdupq_n_u32(0);\n        mask = vsetq_lane_u32(0xFFFFFFFF, mask, 1);\n        mask = vsetq_lane_u32(0xFFFFFFFF, mask, 3);\n        \n        // Mask for even numbers\n        int32x4_t two = vdupq_n_s32(2);\n        uint32x4_t even_mask = vceqq_s32(vandq_s32(vec, two), vdupq_n_s32(0));\n        \n        // Combine masks and get final values\n        uint32x4_t final_mask = vandq_u32(mask, even_mask);\n        int32x4_t masked = vandq_s32(vec, vreinterpretq_s32_u32(final_mask));\n        \n        // Horizontal add\n        int32x2_t sum_2 = vadd_s32(vget_low_s32(masked), vget_high_s32(masked));\n        result += vget_lane_s32(vpadd_s32(sum_2, sum_2), 0);\n    }\n    \n    // Handle remaining elements\n    for(int i = vec_size * 4; i < size; i++) {\n        if(i % 2 == 1 && lst[i] % 2 == 0) {\n            result += lst[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    size_t len = s.length();\n    size_t vectorized_len = len - (len % 16);\n    \n    for (size_t i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(4);\n        uint8x16_t output = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), output);\n    }\n\n    // Handle remaining characters\n    for (size_t i = vectorized_len; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    int len = s.length();\n    int vectorized_len = len - (len % 16);\n    \n    for (int i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&s[i]);\n        uint8x16_t shift = vdupq_n_u8(4);\n        uint8x16_t output = vaddq_u8(input, shift);\n        vst1q_u8((uint8_t*)&result[i], output);\n    }\n\n    // Handle remaining elements\n    for (int i = vectorized_len; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    size_t len = s.length();\n    size_t vectorized_len = len & ~15;  // Multiple of 16 for NEON processing\n\n    for (size_t i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Multiply by 2 and shift by 2\n        uint8x16_t shift = vdupq_n_u8(4);\n        uint8x16_t encrypted = vaddq_u8(input, shift);\n        \n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    // Handle remaining characters\n    for (size_t i = vectorized_len; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    int len = s.length();\n    int vectorized_len = len & ~0xF;\n    \n    for (int i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        \n        // Multiply by 2\n        uint8x16_t shift = vdupq_n_u8(2);\n        uint8x16_t doubled = vmulq_u8(shift, shift);\n        \n        // Add the shift amount\n        uint8x16_t shifted = vaddq_u8(input, doubled);\n        \n        // Store result\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), shifted);\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorized_len; i < len; i++) {\n        result[i] = s[i] + (2 * 2);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    int len = s.length();\n    int vectorized_len = len - (len % 16);\n    \n    if (len >= 16) {\n        for (int i = 0; i < vectorized_len; i += 16) {\n            uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n            \n            // Multiply by 2\n            uint8x16_t temp = vaddq_u8(input, input);\n            \n            // Multiply by 2 again (total multiply by 4) \n            uint8x16_t shifted = vaddq_u8(temp, temp);\n            \n            // Store result\n            vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), shifted);\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = vectorized_len; i < len; i++) {\n        result[i] = s[i] * 4;\n    }\n    \n    // Apply modulo to keep in alphabet range\n    for (int i = 0; i < len; i++) {\n        if (result[i] >= 'a' && result[i] <= 'z') {\n            result[i] = 'a' + ((result[i] - 'a') % 26);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    int len = message.length();\n    int vectorSize = 16;\n    \n    // Process 16 characters at a time\n    for (int i = 0; i <= len - vectorSize; i += vectorSize) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&message[i]);\n        \n        // Create masks for different cases\n        uint8x16_t upperMask = vcgtq_u8(chars, vdupq_n_u8('Z'));\n        uint8x16_t lowerMask = vcltq_u8(chars, vdupq_n_u8('a'));\n        \n        // Create vowel masks\n        uint8x16_t isA = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('a'));\n        uint8x16_t isE = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('e'));\n        uint8x16_t isI = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('i'));\n        uint8x16_t isO = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('o'));\n        uint8x16_t isU = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('u'));\n        \n        uint8x16_t isVowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(isA, isE), isI), isO), isU);\n        \n        // Swap case\n        uint8x16_t caseOffset = vbslq_u8(upperMask, vdupq_n_u8(32), vdupq_n_u8(-32));\n        chars = veorq_u8(chars, vandq_u8(caseOffset, vorrq_u8(upperMask, lowerMask)));\n        \n        // Replace vowels\n        uint8x16_t vowelReplacement = vbslq_u8(isA, vdupq_n_u8('c'), \n                                    vbslq_u8(isE, vdupq_n_u8('g'),\n                                    vbslq_u8(isI, vdupq_n_u8('k'),\n                                    vbslq_u8(isO, vdupq_n_u8('q'),\n                                    vbslq_u8(isU, vdupq_n_u8('w'), chars)))));\n                                    \n        chars = vbslq_u8(isVowel, vowelReplacement, chars);\n        \n        vst1q_u8((uint8_t*)&result[i], chars);\n    }\n    \n    // Handle remaining characters\n    for (int i = len - (len % vectorSize); i < len; i++) {\n        char c = message[i];\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        } else if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        }\n        \n        if (c == 'a' || c == 'A') c = 'C';\n        else if (c == 'e' || c == 'E') c = 'G';\n        else if (c == 'i' || c == 'I') c = 'K';\n        else if (c == 'o' || c == 'O') c = 'Q';\n        else if (c == 'u' || c == 'U') c = 'W';\n        \n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t vectorized_len = len & ~15;\n    \n    uint8x16_t vowels = vdupq_n_u8(0);\n    uint8x16_t vowel_mask = vcombine_u8(vcreate_u8(0x0000000000000011), vcreate_u8(0x0000000000000011));\n    \n    for (size_t i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t input = vld1q_u8((uint8_t*)&message[i]);\n        \n        // Check for uppercase and lowercase\n        uint8x16_t is_upper = vcgeq_u8(input, vdupq_n_u8('A')) & vcleq_u8(input, vdupq_n_u8('Z'));\n        uint8x16_t is_lower = vcgeq_u8(input, vdupq_n_u8('a')) & vcleq_u8(input, vdupq_n_u8('z'));\n        \n        // Swap case\n        uint8x16_t case_delta = vbslq_u8(is_upper, vdupq_n_u8(32), vdupq_n_u8(-32));\n        input = vaddq_u8(input, vandq_u8(vorrq_u8(is_upper, is_lower), case_delta));\n        \n        // Check for vowels (a,e,i,o,u,A,E,I,O,U)\n        uint8x16_t is_a = vceqq_u8(input, vdupq_n_u8('a')) | vceqq_u8(input, vdupq_n_u8('A'));\n        uint8x16_t is_e = vceqq_u8(input, vdupq_n_u8('e')) | vceqq_u8(input, vdupq_n_u8('E'));\n        uint8x16_t is_i = vceqq_u8(input, vdupq_n_u8('i')) | vceqq_u8(input, vdupq_n_u8('I'));\n        uint8x16_t is_o = vceqq_u8(input, vdupq_n_u8('o')) | vceqq_u8(input, vdupq_n_u8('O'));\n        uint8x16_t is_u = vceqq_u8(input, vdupq_n_u8('u')) | vceqq_u8(input, vdupq_n_u8('U'));\n        \n        uint8x16_t is_vowel = is_a | is_e | is_i | is_o | is_u;\n        \n        // Replace vowels with char 2 positions ahead\n        uint8x16_t vowel_replacement = vbslq_u8(is_a, vdupq_n_u8('C'),\n                                     vbslq_u8(is_e, vdupq_n_u8('G'),\n                                     vbslq_u8(is_i, vdupq_n_u8('K'),\n                                     vbslq_u8(is_o, vdupq_n_u8('Q'),\n                                     vbslq_u8(is_u, vdupq_n_u8('W'), input)))));\n        \n        input = vbslq_u8(is_vowel, vowel_replacement, input);\n        \n        vst1q_u8((uint8_t*)&result[i], input);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = vectorized_len; i < len; i++) {\n        char c = message[i];\n        if (std::isupper(c)) {\n            c = std::tolower(c);\n        } else if (std::islower(c)) {\n            c = std::toupper(c);\n        }\n        \n        switch(std::tolower(c)) {\n            case 'a': c = 'C'; break;\n            case 'e': c = 'G'; break;\n            case 'i': c = 'K'; break;\n            case 'o': c = 'Q'; break;\n            case 'u': c = 'W'; break;\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t vectorized_len = len & ~15;\n    \n    uint8x16_t vowels = vdupq_n_u8(0);\n    uint8x16_t vowel_mask = vcombine_u8(vcreate_u8(0x0000000000008A8A), vcreate_u8(0x0000000000008A8A));\n    uint8x16_t case_flip = vdupq_n_u8(32);\n    \n    for (size_t i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&message[i]);\n        \n        // Check for vowels (aeiou/AEIOU)\n        uint8x16_t is_a = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('a'));\n        uint8x16_t is_e = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('e'));\n        uint8x16_t is_i = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('i'));\n        uint8x16_t is_o = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('o'));\n        uint8x16_t is_u = vceqq_u8(vorrq_u8(chars, vdupq_n_u8(32)), vdupq_n_u8('u'));\n        \n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_a, is_e), is_i), is_o), is_u);\n        \n        // Replace vowels with char+2\n        uint8x16_t vowel_replaced = vaddq_u8(chars, vandq_u8(is_vowel, vdupq_n_u8(2)));\n        \n        // Flip case for all letters\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(chars, vdupq_n_u8('A')), \n                                      vcleq_u8(chars, vdupq_n_u8('Z')));\n        uint8x16_t is_lower = vandq_u8(vcgeq_u8(chars, vdupq_n_u8('a')), \n                                      vcleq_u8(chars, vdupq_n_u8('z')));\n        \n        uint8x16_t case_flipped = veorq_u8(vowel_replaced, \n                                          vandq_u8(vorrq_u8(is_upper, is_lower), case_flip));\n        \n        vst1q_u8((uint8_t*)&result[i], case_flipped);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = vectorized_len; i < len; i++) {\n        char c = message[i];\n        if (std::isalpha(c)) {\n            if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || \n                tolower(c) == 'o' || tolower(c) == 'u') {\n                c = c + 2;\n            }\n            result[i] = std::isupper(c) ? std::tolower(c) : std::toupper(c);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t vectorized_len = len & ~15;\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('a', vowels, 0);\n    vowels = vsetq_lane_u8('e', vowels, 1); \n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n\n    uint8x16_t vowel_replacements = vdupq_n_u8(0);\n    vowel_replacements = vsetq_lane_u8('c', vowel_replacements, 0);\n    vowel_replacements = vsetq_lane_u8('g', vowel_replacements, 1);\n    vowel_replacements = vsetq_lane_u8('k', vowel_replacements, 2);\n    vowel_replacements = vsetq_lane_u8('q', vowel_replacements, 3);\n    vowel_replacements = vsetq_lane_u8('w', vowel_replacements, 4);\n    vowel_replacements = vsetq_lane_u8('C', vowel_replacements, 5);\n    vowel_replacements = vsetq_lane_u8('G', vowel_replacements, 6);\n    vowel_replacements = vsetq_lane_u8('K', vowel_replacements, 7);\n    vowel_replacements = vsetq_lane_u8('Q', vowel_replacements, 8);\n    vowel_replacements = vsetq_lane_u8('W', vowel_replacements, 9);\n\n    uint8x16_t upper_mask = vdupq_n_u8(0x20);\n    uint8x16_t lower_bound = vdupq_n_u8('a');\n    uint8x16_t upper_bound = vdupq_n_u8('z');\n    uint8x16_t upper_lower_bound = vdupq_n_u8('A');\n    uint8x16_t upper_upper_bound = vdupq_n_u8('Z');\n\n    for (size_t i = 0; i < vectorized_len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&message[i]);\n        \n        // Check for vowels\n        uint8x16_t is_vowel = vdupq_n_u8(0);\n        for (int j = 0; j < 10; j++) {\n            uint8x16_t vowel = vdupq_n_u8(vgetq_lane_u8(vowels, j));\n            is_vowel = vorrq_u8(is_vowel, vceqq_u8(chars, vowel));\n        }\n\n        // Replace vowels\n        uint8x16_t replaced = chars;\n        for (int j = 0; j < 10; j++) {\n            uint8x16_t vowel = vdupq_n_u8(vgetq_lane_u8(vowels, j));\n            uint8x16_t replacement = vdupq_n_u8(vgetq_lane_u8(vowel_replacements, j));\n            uint8x16_t should_replace = vceqq_u8(chars, vowel);\n            replaced = vbslq_u8(should_replace, replacement, replaced);\n        }\n\n        // Swap case for all letters\n        uint8x16_t is_lower = vandq_u8(vcgeq_u8(chars, lower_bound), vcleq_u8(chars, upper_bound));\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(chars, upper_lower_bound), vcleq_u8(chars, upper_upper_bound));\n        \n        uint8x16_t case_swapped = veorq_u8(chars, vandq_u8(vorrq_u8(is_lower, is_upper), upper_mask));\n        \n        // Combine vowel replacement and case swapping\n        uint8x16_t final = vbslq_u8(is_vowel, replaced, case_swapped);\n        \n        vst1q_u8((uint8_t*)&result[i], final);\n    }\n\n    // Handle remaining characters\n    for (size_t i = vectorized_len; i < len; i++) {\n        char c = message[i];\n        bool is_vowel = false;\n        char replacement = c;\n\n        // Check for vowels and replace\n        switch(tolower(c)) {\n            case 'a': replacement = (c >= 'a' && c <= 'z') ? 'c' : 'C'; is_vowel = true; break;\n            case 'e': replacement = (c >= 'a' && c <= 'z') ? 'g' : 'G'; is_vowel = true; break;\n            case 'i': replacement = (c >= 'a' && c <= 'z') ? 'k' : 'K'; is_vowel = true; break;\n            case 'o': replacement = (c >= 'a' && c <= 'z') ? 'q' : 'Q'; is_vowel = true; break;\n            case 'u': replacement = (c >= 'a' && c <= 'z') ? 'w' : 'W'; is_vowel = true; break;\n        }\n\n        if (is_vowel) {\n            result[i] = replacement;\n        } else {\n            result[i] = (c >= 'a' && c <= 'z') ? toupper(c) : tolower(c);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t vec_size = 16;\n    size_t vec_count = len / vec_size;\n\n    uint8x16_t vowels = vdupq_n_u8(0);\n    vowels = vsetq_lane_u8('a', vowels, 0);\n    vowels = vsetq_lane_u8('e', vowels, 1); \n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n\n    uint8x16_t vowel_replacements = vdupq_n_u8(0);\n    vowel_replacements = vsetq_lane_u8('c', vowel_replacements, 0);\n    vowel_replacements = vsetq_lane_u8('g', vowel_replacements, 1);\n    vowel_replacements = vsetq_lane_u8('k', vowel_replacements, 2);\n    vowel_replacements = vsetq_lane_u8('q', vowel_replacements, 3);\n    vowel_replacements = vsetq_lane_u8('w', vowel_replacements, 4);\n    vowel_replacements = vsetq_lane_u8('C', vowel_replacements, 5);\n    vowel_replacements = vsetq_lane_u8('G', vowel_replacements, 6);\n    vowel_replacements = vsetq_lane_u8('K', vowel_replacements, 7);\n    vowel_replacements = vsetq_lane_u8('Q', vowel_replacements, 8);\n    vowel_replacements = vsetq_lane_u8('W', vowel_replacements, 9);\n\n    for (size_t i = 0; i < vec_count; i++) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&message[i * vec_size]);\n        \n        // Check for lowercase\n        uint8x16_t is_lower = vcgeq_u8(chars, vdupq_n_u8('a'));\n        is_lower = vandq_u8(is_lower, vcleq_u8(chars, vdupq_n_u8('z')));\n        \n        // Check for uppercase\n        uint8x16_t is_upper = vcgeq_u8(chars, vdupq_n_u8('A'));\n        is_upper = vandq_u8(is_upper, vcleq_u8(chars, vdupq_n_u8('Z')));\n\n        // Convert case\n        uint8x16_t case_diff = vdupq_n_u8('a' - 'A');\n        chars = vbslq_u8(is_lower, vsubq_u8(chars, case_diff), chars);\n        chars = vbslq_u8(is_upper, vaddq_u8(chars, case_diff), chars);\n\n        // Check for vowels and replace\n        for(int j = 0; j < 10; j++) {\n            uint8x16_t is_vowel = vceqq_u8(chars, vdupq_n_u8(vgetq_lane_u8(vowels, j)));\n            chars = vbslq_u8(is_vowel, vdupq_n_u8(vgetq_lane_u8(vowel_replacements, j)), chars);\n        }\n\n        vst1q_u8((uint8_t*)&result[i * vec_size], chars);\n    }\n\n    // Handle remaining characters\n    for (size_t i = vec_count * vec_size; i < len; i++) {\n        char c = message[i];\n        if (isalpha(c)) {\n            // Swap case\n            if (islower(c)) {\n                c = toupper(c);\n            } else {\n                c = tolower(c);\n            }\n            \n            // Replace vowels\n            switch(c) {\n                case 'a': c = 'c'; break;\n                case 'e': c = 'g'; break;\n                case 'i': c = 'k'; break;\n                case 'o': c = 'q'; break;\n                case 'u': c = 'w'; break;\n                case 'A': c = 'C'; break;\n                case 'E': c = 'G'; break;\n                case 'I': c = 'K'; break;\n                case 'O': c = 'Q'; break;\n                case 'U': c = 'W'; break;\n            }\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n    \n    uint8x16_t lower_mask = vdupq_n_u8(0x60); // 'a'-1 in ASCII\n    uint8x16_t upper_mask = vdupq_n_u8(0x40); // 'A'-1 in ASCII\n    uint8x16_t alpha_mask = vdupq_n_u8(0x1A); // 26 letters\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        for (size_t i = 0; i < key.length(); i += 16) {\n            size_t remaining = std::min(size_t(16), key.length() - i);\n            uint8_t temp[16] = {0};\n            memcpy(temp, key.c_str() + i, remaining);\n            \n            uint8x16_t chars = vld1q_u8(temp);\n            \n            // Check if characters are lowercase\n            uint8x16_t lower_diff = vsubq_u8(chars, lower_mask);\n            uint8x16_t lower_check = vcleq_u8(lower_diff, vdupq_n_u8(26));\n            \n            // Check if characters are uppercase  \n            uint8x16_t upper_diff = vsubq_u8(chars, upper_mask);\n            uint8x16_t upper_check = vcleq_u8(upper_diff, vdupq_n_u8(26));\n            \n            uint64x2_t lower_result = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(lower_check)));\n            uint64x2_t upper_result = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(upper_check)));\n            \n            if (vgetq_lane_u64(lower_result, 0) + vgetq_lane_u64(lower_result, 1) > 0) {\n                hasLower = true;\n            }\n            \n            if (vgetq_lane_u64(upper_result, 0) + vgetq_lane_u64(upper_result, 1) > 0) {\n                hasUpper = true;\n            }\n            \n            // Check for non-alphabetic characters\n            uint8x16_t alpha_diff_lower = vsubq_u8(chars, lower_mask);\n            uint8x16_t alpha_diff_upper = vsubq_u8(chars, upper_mask);\n            uint8x16_t is_lower_alpha = vcleq_u8(alpha_diff_lower, alpha_mask);\n            uint8x16_t is_upper_alpha = vcleq_u8(alpha_diff_upper, alpha_mask);\n            uint8x16_t is_alpha = vorrq_u8(is_lower_alpha, is_upper_alpha);\n            \n            uint64x2_t alpha_result = vpaddlq_u32(vpaddlq_u16(vpaddlq_u8(is_alpha)));\n            if (vgetq_lane_u64(alpha_result, 0) + vgetq_lane_u64(alpha_result, 1) < remaining) {\n                return false;\n            }\n        }\n    }\n\n    return (hasLower ^ hasUpper) && (hasLower || hasUpper);\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Get all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check if first key is valid\n    const std::string& first_key = keys[0];\n    bool first_upper = std::isupper(first_key[0]);\n    bool first_lower = std::islower(first_key[0]);\n    \n    if (!first_upper && !first_lower) {\n        return false;\n    }\n\n    // Process 16 characters at a time using NEON\n    for (const auto& key : keys) {\n        const size_t len = key.length();\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n            \n            // Check for uppercase A-Z (0x41-0x5A)\n            uint8x16_t upper_min = vdupq_n_u8(0x41);\n            uint8x16_t upper_max = vdupq_n_u8(0x5A);\n            uint8x16_t is_upper = vandq_u8(\n                vcgeq_u8(chars, upper_min),\n                vcleq_u8(chars, upper_max)\n            );\n\n            // Check for lowercase a-z (0x61-0x7A) \n            uint8x16_t lower_min = vdupq_n_u8(0x61);\n            uint8x16_t lower_max = vdupq_n_u8(0x7A);\n            uint8x16_t is_lower = vandq_u8(\n                vcgeq_u8(chars, lower_min),\n                vcleq_u8(chars, lower_max)\n            );\n\n            uint8_t upper_mask = vaddvq_u8(is_upper);\n            uint8_t lower_mask = vaddvq_u8(is_lower);\n\n            // Check if character is neither upper nor lower\n            if (upper_mask == 0 && lower_mask == 0) {\n                return false;\n            }\n\n            // Check if case matches first character\n            if (first_upper && lower_mask > 0) {\n                return false;\n            }\n            if (first_lower && upper_mask > 0) {\n                return false;\n            }\n        }\n\n        // Handle remaining characters\n        for (; i < len; i++) {\n            if (first_upper && std::islower(str[i])) {\n                return false;\n            }\n            if (first_lower && std::isupper(str[i])) {\n                return false;\n            }\n            if (!std::isalpha(str[i])) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Get all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check first key to determine expected case\n    bool expect_upper = std::isupper(keys[0][0]);\n    bool expect_lower = std::islower(keys[0][0]);\n    \n    if (!expect_upper && !expect_lower) {\n        return false;\n    }\n\n    // Process 16 characters at a time using NEON\n    for (const auto& key : keys) {\n        const size_t len = key.length();\n        const char* str = key.c_str();\n        size_t i;\n\n        for (i = 0; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)str + i);\n            \n            if (expect_upper) {\n                // Check if any character is lowercase (0x61-0x7A)\n                uint8x16_t lower_bound = vdupq_n_u8(0x61);\n                uint8x16_t upper_bound = vdupq_n_u8(0x7A);\n                uint8x16_t ge_lower = vcgeq_u8(chars, lower_bound);\n                uint8x16_t le_upper = vcleq_u8(chars, upper_bound);\n                uint8x16_t is_lower = vandq_u8(ge_lower, le_upper);\n                \n                if (vmaxvq_u8(is_lower)) {\n                    return false;\n                }\n            } else {\n                // Check if any character is uppercase (0x41-0x5A)\n                uint8x16_t lower_bound = vdupq_n_u8(0x41);\n                uint8x16_t upper_bound = vdupq_n_u8(0x5A);\n                uint8x16_t ge_lower = vcgeq_u8(chars, lower_bound);\n                uint8x16_t le_upper = vcleq_u8(chars, upper_bound);\n                uint8x16_t is_upper = vandq_u8(ge_lower, le_upper);\n                \n                if (vmaxvq_u8(is_upper)) {\n                    return false;\n                }\n            }\n        }\n\n        // Handle remaining characters\n        for (; i < len; i++) {\n            char c = str[i];\n            if (expect_upper && std::islower(c)) {\n                return false;\n            }\n            if (expect_lower && std::isupper(c)) {\n                return false;\n            }\n            if (!std::isalpha(c)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Get all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check first key to determine expected case\n    bool expect_upper = std::isupper(keys[0][0]);\n    \n    // Process 16 characters at a time using NEON\n    for (const auto& key : keys) {\n        const size_t len = key.length();\n        const char* str = key.c_str();\n        size_t i = 0;\n\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)str + i);\n            \n            if (expect_upper) {\n                // Check if any character is lowercase (0x61-0x7A)\n                uint8x16_t lower_bound = vdupq_n_u8(0x61);\n                uint8x16_t upper_bound = vdupq_n_u8(0x7A);\n                uint8x16_t ge_lower = vcgeq_u8(chars, lower_bound);\n                uint8x16_t le_upper = vcleq_u8(chars, upper_bound);\n                uint8x16_t is_lower = vandq_u8(ge_lower, le_upper);\n                \n                if (vmaxvq_u8(is_lower) != 0) {\n                    return false;\n                }\n            } else {\n                // Check if any character is uppercase (0x41-0x5A)\n                uint8x16_t lower_bound = vdupq_n_u8(0x41);\n                uint8x16_t upper_bound = vdupq_n_u8(0x5A);\n                uint8x16_t ge_lower = vcgeq_u8(chars, lower_bound);\n                uint8x16_t le_upper = vcleq_u8(chars, upper_bound);\n                uint8x16_t is_upper = vandq_u8(ge_lower, le_upper);\n                \n                if (vmaxvq_u8(is_upper) != 0) {\n                    return false;\n                }\n            }\n        }\n\n        // Handle remaining characters\n        for (; i < len; i++) {\n            char c = str[i];\n            if (expect_upper) {\n                if (std::islower(c)) return false;\n            } else {\n                if (std::isupper(c)) return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Get all keys\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check if first key is valid\n    const std::string& first_key = keys[0];\n    bool first_upper = std::isupper(first_key[0]);\n    bool first_lower = std::islower(first_key[0]);\n    \n    if (!first_upper && !first_lower) {\n        return false;\n    }\n\n    // Process 16 characters at a time using NEON\n    for (size_t i = 0; i < keys.size(); i++) {\n        const std::string& key = keys[i];\n        const char* str = key.c_str();\n        size_t len = key.length();\n        size_t vec_size = len - (len % 16);\n\n        for (size_t j = 0; j < vec_size; j += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)str + j);\n            \n            if (first_upper) {\n                // Check if any character is lowercase\n                uint8x16_t lower_mask = vandq_u8(chars, vdupq_n_u8(0x20));\n                uint8x16_t is_lower = vceqq_u8(lower_mask, vdupq_n_u8(0x20));\n                if (vaddvq_u8(is_lower) > 0) {\n                    return false;\n                }\n            } else {\n                // Check if any character is uppercase\n                uint8x16_t upper_mask = vandq_u8(chars, vdupq_n_u8(0x20)); \n                uint8x16_t is_upper = vceqq_u8(upper_mask, vdupq_n_u8(0));\n                if (vaddvq_u8(is_upper) > 0) {\n                    return false;\n                }\n            }\n        }\n\n        // Handle remaining characters\n        for (size_t j = vec_size; j < len; j++) {\n            char c = str[j];\n            if (first_upper && std::islower(c)) {\n                return false;\n            }\n            if (first_lower && std::isupper(c)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return std::vector<int>();\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    uint32x4_t increment = vdupq_n_u32(8);\n    uint32x4_t candidates = {5,7,11,13};\n    \n    while(vgetq_lane_u32(candidates, 0) < n) {\n        uint32x4_t is_prime = vdupq_n_u32(1);\n        \n        for(uint32_t i = 2; i * i <= vgetq_lane_u32(candidates, 3); i++) {\n            uint32x4_t divisor = vdupq_n_u32(i);\n            uint32x4_t remainder = vmodq_u32(candidates, divisor);\n            uint32x4_t zero = vdupq_n_u32(0);\n            uint32x4_t comp = vceqq_u32(remainder, zero);\n            is_prime = vandq_u32(is_prime, vmvnq_u32(comp));\n        }\n        \n        for(int i = 0; i < 4; i++) {\n            if(vgetq_lane_u32(candidates, i) >= n) break;\n            if(vgetq_lane_u32(is_prime, i)) {\n                primes.push_back(vgetq_lane_u32(candidates, i));\n            }\n        }\n        \n        candidates = vaddq_u32(candidates, increment);\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return std::vector<int>();\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    uint32x4_t vn = vdupq_n_u32(n);\n    \n    for (int i = 5; i < n; i += 6) {\n        uint32x4_t vcand = {i, i+1, i+2, i+3};\n        uint32x4_t is_prime = vdupq_n_u32(1);\n        \n        for (int j = 2; j * j <= i+3; j++) {\n            uint32x4_t vj = vdupq_n_u32(j);\n            uint32x4_t vrem = vmodq_u32(vcand, vj);\n            uint32x4_t vzero = vdupq_n_u32(0);\n            uint32x4_t vcmp = vceqq_u32(vrem, vzero);\n            is_prime = vandq_u32(is_prime, vmvnq_u32(vcmp));\n        }\n        \n        uint32_t lanes[4];\n        vst1q_u32(lanes, is_prime);\n        \n        for (int k = 0; k < 4; k++) {\n            if (i + k < n && lanes[k] && (i + k) % 2 != 0 && (i + k) % 3 != 0) {\n                primes.push_back(i + k);\n            }\n        }\n        \n        if (i + 4 < n) {\n            uint32x4_t vcand2 = {i+4, i+5, i+6, i+7}; \n            is_prime = vdupq_n_u32(1);\n            \n            for (int j = 2; j * j <= i+7; j++) {\n                uint32x4_t vj = vdupq_n_u32(j);\n                uint32x4_t vrem = vmodq_u32(vcand2, vj);\n                uint32x4_t vzero = vdupq_n_u32(0);\n                uint32x4_t vcmp = vceqq_u32(vrem, vzero);\n                is_prime = vandq_u32(is_prime, vmvnq_u32(vcmp));\n            }\n            \n            vst1q_u32(lanes, is_prime);\n            \n            for (int k = 0; k < 2; k++) {\n                if (i + k + 4 < n && lanes[k] && (i + k + 4) % 2 != 0 && (i + k + 4) % 3 != 0) {\n                    primes.push_back(i + k + 4);\n                }\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return std::vector<int>();\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    uint32_t candidates[16];\n    int candidate = 5;\n    \n    while (candidate < n) {\n        // Fill candidates array with 16 numbers to check\n        int count = 0;\n        for (int i = 0; i < 16 && candidate < n; i++, candidate += 2) {\n            candidates[i] = candidate;\n            count++;\n        }\n        \n        if (count == 0) break;\n        \n        uint32x4_t mask = vdupq_n_u32(1);\n        \n        // Process 4 numbers at a time\n        for (int i = 0; i < count; i += 4) {\n            uint32x4_t nums = vld1q_u32(&candidates[i]);\n            uint32x4_t isPrime = vdupq_n_u32(1);\n            \n            // Check divisibility up to sqrt of max candidate\n            int limit = (int)sqrt(candidates[std::min(i+3, count-1)]);\n            \n            for (int j = 3; j <= limit; j += 2) {\n                uint32x4_t divisor = vdupq_n_u32(j);\n                uint32x4_t remainder = vmodq_u32(nums, divisor);\n                uint32x4_t zero = vdupq_n_u32(0);\n                uint32x4_t cmp = vceqq_u32(remainder, zero);\n                isPrime = vandq_u32(isPrime, vmvnq_u32(cmp));\n            }\n            \n            // Extract results and add prime numbers\n            uint32_t results[4];\n            vst1q_u32(results, isPrime);\n            \n            for (int j = 0; j < 4 && (i+j) < count; j++) {\n                if (results[j]) {\n                    primes.push_back(candidates[i+j]);\n                }\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return std::vector<int>();\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    uint32_t numbers[32];\n    for (int i = 0; i < 32; i++) {\n        numbers[i] = i + 5;\n    }\n    \n    uint32x4_t ones = vdupq_n_u32(1);\n    \n    for (int i = 5; i < n; i += 32) {\n        uint32x4_t results[8] = {vdupq_n_u32(1), vdupq_n_u32(1), vdupq_n_u32(1),\n                                vdupq_n_u32(1), vdupq_n_u32(1), vdupq_n_u32(1),\n                                vdupq_n_u32(1), vdupq_n_u32(1)};\n                                \n        for (int j = 0; j < 8; j++) {\n            uint32x4_t curr = vld1q_u32(numbers + j*4);\n            \n            for (int k = 2; k * k <= i + 31; k++) {\n                uint32x4_t divisor = vdupq_n_u32(k);\n                uint32x4_t remainder = vmodq_u32(curr, divisor);\n                uint32x4_t is_divisible = vceqq_u32(remainder, vdupq_n_u32(0));\n                results[j] = vandq_u32(results[j], vmvnq_u32(is_divisible));\n            }\n            \n            uint32_t result[4];\n            vst1q_u32(result, results[j]);\n            \n            for (int k = 0; k < 4; k++) {\n                if (result[k] && (j*4 + k + i) < n) {\n                    primes.push_back(j*4 + k + i);\n                }\n            }\n        }\n        \n        for (int j = 0; j < 32; j++) {\n            numbers[j] += 32;\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return std::vector<int>();\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    // Create vectors for parallel processing\n    uint32x4_t vnum, vdiv, vmod;\n    uint32x4_t vzero = vdupq_n_u32(0);\n    \n    // Process 4 numbers at a time\n    for (int i = 5; i < n; i += 4) {\n        vnum = vdupq_n_u32(i);\n        vnum = vaddq_u32(vnum, vcombine_u32(vcreate_u32(0x0000000300000000), \n                                           vcreate_u32(0x0000000100000002)));\n        \n        bool isPrime[4] = {true, true, true, true};\n        \n        // Check divisibility up to sqrt(n)\n        for (int j = 2; j * j <= i + 3 && j < n; j++) {\n            vdiv = vdupq_n_u32(j);\n            vmod = vmodq_u32(vnum, vdiv);\n            uint32x4_t vcmp = vceqq_u32(vmod, vzero);\n            uint32_t mask = vgetq_lane_u32(vcmp, 0) | \n                           (vgetq_lane_u32(vcmp, 1) << 1) |\n                           (vgetq_lane_u32(vcmp, 2) << 2) |\n                           (vgetq_lane_u32(vcmp, 3) << 3);\n                           \n            for (int k = 0; k < 4; k++) {\n                if ((mask & (1 << k)) && vgetq_lane_u32(vnum, k) != j) {\n                    isPrime[k] = false;\n                }\n            }\n        }\n        \n        // Add prime numbers to result vector\n        for (int k = 0; k < 4; k++) {\n            uint32_t val = vgetq_lane_u32(vnum, k);\n            if (val < n && isPrime[k]) {\n                primes.push_back(val);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int len = s.length();\n    int count = 0;\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if ((c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') && \n                (c >= 'A' && c <= 'Z')) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    uint8x16_t vowels_a = vdupq_n_u8('A');\n    uint8x16_t vowels_e = vdupq_n_u8('E'); \n    uint8x16_t vowels_i = vdupq_n_u8('I');\n    uint8x16_t vowels_o = vdupq_n_u8('O');\n    uint8x16_t vowels_u = vdupq_n_u8('U');\n    uint8x16_t upper_bound = vdupq_n_u8('Z');\n    uint8x16_t lower_bound = vdupq_n_u8('A');\n\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t is_a = vceqq_u8(chars, vowels_a);\n        uint8x16_t is_e = vceqq_u8(chars, vowels_e);\n        uint8x16_t is_i = vceqq_u8(chars, vowels_i);\n        uint8x16_t is_o = vceqq_u8(chars, vowels_o);\n        uint8x16_t is_u = vceqq_u8(chars, vowels_u);\n        \n        uint8x16_t is_vowel = vorrq_u8(\n            vorrq_u8(\n                vorrq_u8(is_a, is_e),\n                vorrq_u8(is_i, is_o)\n            ),\n            is_u\n        );\n        \n        uint8x16_t is_upper = vandq_u8(\n            vcleq_u8(lower_bound, chars),\n            vcleq_u8(chars, upper_bound)\n        );\n        \n        uint8x16_t is_upper_vowel = vandq_u8(is_vowel, is_upper);\n        \n        uint8x16_t even_mask = vdupq_n_u8(0);\n        uint8_t pattern[16] = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0};\n        even_mask = vld1q_u8(pattern);\n        \n        uint8x16_t final_mask = vandq_u8(is_upper_vowel, even_mask);\n        \n        uint8x8_t sum_v = vpadd_u8(\n            vget_low_u8(vreinterpretq_u8_u8(final_mask)),\n            vget_high_u8(vreinterpretq_u8_u8(final_mask))\n        );\n        \n        while (vget_lane_u8(sum_v, 0) > 0) {\n            count++;\n            sum_v = vset_lane_u8(vget_lane_u8(sum_v, 0) - 1, sum_v, 0);\n        }\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if ((c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') && \n            (c >= 'A' && c <= 'Z')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    uint8x16_t vowels_a = vdupq_n_u8('A');\n    uint8x16_t vowels_e = vdupq_n_u8('E'); \n    uint8x16_t vowels_i = vdupq_n_u8('I');\n    uint8x16_t vowels_o = vdupq_n_u8('O');\n    uint8x16_t vowels_u = vdupq_n_u8('U');\n    \n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        uint8x16_t data = vld1q_u8((const uint8_t*)&s[i]);\n        \n        uint8x16_t mask_a = vceqq_u8(data, vowels_a);\n        uint8x16_t mask_e = vceqq_u8(data, vowels_e);\n        uint8x16_t mask_i = vceqq_u8(data, vowels_i);\n        uint8x16_t mask_o = vceqq_u8(data, vowels_o);\n        uint8x16_t mask_u = vceqq_u8(data, vowels_u);\n        \n        uint8x16_t mask = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(mask_a, mask_e), mask_i), mask_o), mask_u);\n        \n        uint8x16_t even_mask = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0};\n        mask = vandq_u8(mask, even_mask);\n        \n        uint8x8_t sum = vpadd_u8(vget_low_u8(vreinterpretq_u8_u8(mask)), \n                                vget_high_u8(vreinterpretq_u8_u8(mask)));\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        \n        count += vget_lane_u8(sum, 0);\n    }\n    \n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    uint8x16_t vowels_a = vdupq_n_u8('A');\n    uint8x16_t vowels_e = vdupq_n_u8('E'); \n    uint8x16_t vowels_i = vdupq_n_u8('I');\n    uint8x16_t vowels_o = vdupq_n_u8('O');\n    uint8x16_t vowels_u = vdupq_n_u8('U');\n\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        uint8x16_t data = vld1q_u8((const uint8_t*)&s[i]);\n        \n        uint8x16_t mask_a = vceqq_u8(data, vowels_a);\n        uint8x16_t mask_e = vceqq_u8(data, vowels_e);\n        uint8x16_t mask_i = vceqq_u8(data, vowels_i);\n        uint8x16_t mask_o = vceqq_u8(data, vowels_o);\n        uint8x16_t mask_u = vceqq_u8(data, vowels_u);\n\n        uint8x16_t mask = vorrq_u8(mask_a, mask_e);\n        mask = vorrq_u8(mask, mask_i);\n        mask = vorrq_u8(mask, mask_o);\n        mask = vorrq_u8(mask, mask_u);\n\n        uint8x16_t even_mask = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0};\n        mask = vandq_u8(mask, even_mask);\n\n        uint8x8_t sum = vpadd_u8(vget_low_u8(mask), vget_high_u8(mask));\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        \n        count += vget_lane_u8(sum, 0);\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int len = s.length();\n    int count = 0;\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    uint8x16_t vowels_a = vdupq_n_u8('A');\n    uint8x16_t vowels_e = vdupq_n_u8('E'); \n    uint8x16_t vowels_i = vdupq_n_u8('I');\n    uint8x16_t vowels_o = vdupq_n_u8('O');\n    uint8x16_t vowels_u = vdupq_n_u8('U');\n\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        uint8x16_t data = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t mask_a = vceqq_u8(data, vowels_a);\n        uint8x16_t mask_e = vceqq_u8(data, vowels_e);\n        uint8x16_t mask_i = vceqq_u8(data, vowels_i);\n        uint8x16_t mask_o = vceqq_u8(data, vowels_o);\n        uint8x16_t mask_u = vceqq_u8(data, vowels_u);\n\n        uint8x16_t mask = vorrq_u8(mask_a, mask_e);\n        mask = vorrq_u8(mask, mask_i);\n        mask = vorrq_u8(mask, mask_o);\n        mask = vorrq_u8(mask, mask_u);\n\n        uint8x16_t even_mask = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0};\n        mask = vandq_u8(mask, even_mask);\n\n        uint8_t result[16];\n        vst1q_u8(result, mask);\n\n        for(int j = 0; j < 16; j++) {\n            count += (result[j] != 0);\n        }\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    uint8x16_t vowels_a = vdupq_n_u8('A');\n    uint8x16_t vowels_e = vdupq_n_u8('E'); \n    uint8x16_t vowels_i = vdupq_n_u8('I');\n    uint8x16_t vowels_o = vdupq_n_u8('O');\n    uint8x16_t vowels_u = vdupq_n_u8('U');\n    \n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        uint8x16_t chars = vld1q_u8((uint8_t*)&s[i]);\n        \n        uint8x16_t mask_a = vceqq_u8(chars, vowels_a);\n        uint8x16_t mask_e = vceqq_u8(chars, vowels_e);\n        uint8x16_t mask_i = vceqq_u8(chars, vowels_i);\n        uint8x16_t mask_o = vceqq_u8(chars, vowels_o);\n        uint8x16_t mask_u = vceqq_u8(chars, vowels_u);\n        \n        uint8x16_t mask = vorrq_u8(mask_a, mask_e);\n        mask = vorrq_u8(mask, mask_i);\n        mask = vorrq_u8(mask, mask_o);\n        mask = vorrq_u8(mask, mask_u);\n        \n        uint8x16_t even_mask = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0};\n        mask = vandq_u8(mask, even_mask);\n        \n        uint8_t result[16];\n        vst1q_u8(result, mask);\n        \n        for(int j = 0; j < 16; j++) {\n            count += (result[j] != 0);\n        }\n    }\n    \n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    // Handle first element separately\n    int increment = (n % 2 == 0) ? 2 : 2;\n    int current = n + increment;\n    \n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        int32x4_t curr_vec = vdupq_n_s32(current);\n        int32x4_t inc_vec = vdupq_n_s32(8);\n        int32x4_t res = vaddq_s32(curr_vec, vmulq_s32(vdupq_n_s32(0), inc_vec));\n        \n        vst1q_s32(&result[i], res);\n        \n        current += 8;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = current;\n        current += 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    // Handle first element separately\n    int increment = (n % 2 == 0) ? 2 : 2;\n    int current = n;\n    \n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        int32x4_t curr_vec = vdupq_n_s32(current);\n        int32x4_t incr_vec = vdupq_n_s32(increment * 4);\n        int32x4_t idx_vec = {1, 2, 3, 4};\n        \n        // Multiply index by increment and add to current\n        int32x4_t mul = vmulq_s32(idx_vec, vdupq_n_s32(increment));\n        int32x4_t res = vaddq_s32(curr_vec, mul);\n        \n        vst1q_s32(&result[i], res);\n        current += increment * 4;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        current += increment;\n        result[i] = current;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    // Initialize vector with indices 0,1,2,3\n    int32x4_t indices = {0, 1, 2, 3};\n    // Vector with all 2's for increment\n    int32x4_t twos = vdupq_n_s32(2);\n    \n    // Process 4 elements at a time\n    int i;\n    for(i = 1; i + 4 <= n; i += 4) {\n        // Get previous values\n        int32x4_t prev = vld1q_s32(&result[i-1]);\n        // Add 2 to each element\n        int32x4_t next = vaddq_s32(prev, twos);\n        // Store results\n        vst1q_s32(&result[i], next);\n    }\n    \n    // Handle remaining elements\n    for(; i < n; i++) {\n        result[i] = result[i-1] + 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    // Handle first value separately\n    int increment = (n % 2 == 0) ? 2 : 2;\n    int current = n;\n    \n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        int32x4_t curr_vec = vdupq_n_s32(current);\n        int32x4_t incr_vec = vdupq_n_s32(increment * 4);\n        int32x4_t idx_vec = {1, 2, 3, 4};\n        \n        // Multiply index by increment and add to current\n        int32x4_t mul = vmulq_s32(idx_vec, vdupq_n_s32(increment));\n        int32x4_t res = vaddq_s32(curr_vec, mul);\n        \n        vst1q_s32(&result[i], res);\n        current += increment * 4;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        current += increment;\n        result[i] = current;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    // Handle first value separately\n    int increment = (n % 2 == 0) ? 2 : 2;\n    int current = n;\n    \n    // Process 4 elements at a time using NEON\n    int i = 1;\n    for (; i + 3 < n; i += 4) {\n        int32x4_t curr_vec = vdupq_n_s32(current);\n        int32x4_t incr_vec = vdupq_n_s32(increment * 4);\n        int32x4_t idx_vec = {1, 2, 3, 4};\n        \n        // Multiply index by increment and add to current\n        int32x4_t mul = vmulq_s32(idx_vec, vdupq_n_s32(increment));\n        int32x4_t res = vaddq_s32(curr_vec, mul);\n        \n        vst1q_s32(&result[i], res);\n        \n        current += increment * 4;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        current += increment;\n        result[i] = current;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t num_vectors = count / 2;\n    int64_t remainder = count % 2;\n    \n    int64x2_t sum = vdupq_n_s64(0);\n    int64x2_t increment = vdupq_n_s64(1);\n    int64x2_t current = vcombine_s64(vcreate_s64(n), vcreate_s64(n+1));\n    \n    for(int i = 0; i < num_vectors; i++) {\n        sum = vaddq_s64(sum, current);\n        current = vaddq_s64(current, vdupq_n_s64(2));\n    }\n    \n    int64_t total = vgetq_lane_s64(sum, 0) + vgetq_lane_s64(sum, 1);\n    \n    if(remainder) {\n        total += m;\n    }\n    \n    int64_t avg = total / count;\n    \n    if(avg == 0) return \"0\";\n    \n    std::string binary;\n    while(avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t num_vectors = count / 2;\n    int64_t remainder = count % 2;\n    \n    int64x2_t sum = vdupq_n_s64(0);\n    int64x2_t increment = vdupq_n_s64(1);\n    int64x2_t current = vcombine_s64(vcreate_s64(n), vcreate_s64(n+1));\n    \n    for(int i = 0; i < num_vectors; i++) {\n        sum = vaddq_s64(sum, current);\n        current = vaddq_s64(current, vdupq_n_s64(2));\n    }\n    \n    int64_t total = vgetq_lane_s64(sum, 0) + vgetq_lane_s64(sum, 1);\n    \n    if(remainder) {\n        total += m;\n    }\n    \n    int64_t avg = total / count;\n    \n    if(avg == 0) return \"0\";\n    \n    std::string result;\n    while(avg > 0) {\n        result = (avg % 2 ? \"1\" : \"0\") + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n    \n    // Process 2 numbers at a time using NEON\n    int64x2_t vec_sum = vdupq_n_s64(0);\n    int64_t i;\n    \n    for (i = n; i <= m-1; i += 2) {\n        int64x2_t nums = vcombine_s64(vcreate_s64(i), vcreate_s64(i+1));\n        vec_sum = vaddq_s64(vec_sum, nums);\n    }\n    \n    // Sum the vector elements\n    sum = vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n    \n    // Handle remaining element if count is odd\n    if (i == m) {\n        sum += m;\n    }\n    \n    // Calculate average and round down\n    int64_t avg = sum / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n    \n    // Process 2 numbers at a time using NEON\n    int64x2_t vec_sum = vdupq_n_s64(0);\n    int64x2_t vec_inc = vdupq_n_s64(2);\n    int64x2_t vec_n = {n, n+1};\n    \n    for(int64_t i = n; i <= m-1; i+=2) {\n        vec_sum = vaddq_s64(vec_sum, vec_n);\n        vec_n = vaddq_s64(vec_n, vec_inc);\n    }\n    \n    sum = vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n    \n    // Handle remaining element if count is odd\n    if (count % 2) {\n        sum += m;\n    }\n    \n    int64_t avg = sum / count;\n    \n    std::string result;\n    while(avg > 0) {\n        result = (avg % 2 ? \"1\" : \"0\") + result;\n        avg /= 2;\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t num_vectors = count / 2;\n    int64_t remainder = count % 2;\n    \n    int64x2_t sum = vdupq_n_s64(0);\n    int64x2_t increment = vdupq_n_s64(1);\n    int64x2_t current = vcombine_s64(vcreate_s64(n), vcreate_s64(n+1));\n    \n    for(int i = 0; i < num_vectors; i++) {\n        sum = vaddq_s64(sum, current);\n        current = vaddq_s64(current, vdupq_n_s64(2));\n    }\n    \n    int64_t total = vgetq_lane_s64(sum, 0) + vgetq_lane_s64(sum, 1);\n    \n    if(remainder) {\n        total += m;\n    }\n    \n    int64_t avg = total / count;\n    \n    if(avg == 0) return \"0\";\n    \n    std::string binary;\n    while(avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n\n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i), {0, 1, 2, 3});\n        \n        // Calculate factorials for even indices\n        int32x4_t facts = vdupq_n_s32(1);\n        for (int j = 1; j <= i + 3; j++) {\n            facts = vmulq_s32(facts, vdupq_n_s32(j));\n            facts = vandq_s32(facts, vdupq_n_s32(9999)); // mod 10000\n        }\n        \n        // Calculate sums for odd indices\n        int32x4_t sums = vdupq_n_s32(0);\n        for (int j = 1; j <= i + 3; j++) {\n            int32x4_t mask = vcleq_s32(vdupq_n_s32(j), indices);\n            sums = vaddq_s32(sums, vandq_s32(vdupq_n_s32(j), mask));\n        }\n        \n        // Select factorial or sum based on even/odd\n        int32x4_t is_even = vtstq_s32(indices, vdupq_n_s32(1));\n        int32x4_t values = vbslq_s32(is_even, facts, sums);\n        \n        vst1q_s32(&result[i], values);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial\n            int fact = 1;\n            for (int j = 1; j <= i; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            // Calculate sum\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n\n    if (n <= 1) return result;\n\n    // Pre-calculate factorials mod 10000\n    int factorials[16] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 3628800, 3628800, 3628800, 3628800, 3628800};\n    for (int i = 5; i < 16; i++) {\n        factorials[i] %= 10000;\n    }\n\n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        // Create index vector\n        int32x4_t idx = vdupq_n_s32(0);\n        idx = vsetq_lane_s32(i, idx, 0);\n        idx = vsetq_lane_s32(i+1, idx, 1);\n        idx = vsetq_lane_s32(i+2, idx, 2);\n        idx = vsetq_lane_s32(i+3, idx, 3);\n\n        // Calculate sum 1..i for odd indices\n        int32x4_t sums = vaddq_s32(idx, vdupq_n_s32(1));\n        sums = vmulq_s32(sums, idx);\n        sums = vshrq_n_s32(sums, 1);\n\n        // Get factorials for even indices\n        int32x4_t facts = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int curr_idx = i + j;\n            if (curr_idx % 2 == 0) {\n                facts = vsetq_lane_s32(factorials[curr_idx/2], facts, j);\n            }\n        }\n\n        // Create mask for even/odd selection\n        int32x4_t mask = vdupq_n_s32(0);\n        mask = vsetq_lane_s32(i % 2 == 0 ? -1 : 0, mask, 0);\n        mask = vsetq_lane_s32((i+1) % 2 == 0 ? -1 : 0, mask, 1);\n        mask = vsetq_lane_s32((i+2) % 2 == 0 ? -1 : 0, mask, 2);\n        mask = vsetq_lane_s32((i+3) % 2 == 0 ? -1 : 0, mask, 3);\n\n        // Select between sums and facts based on mask\n        int32x4_t res = vbslq_s32(mask, facts, sums);\n\n        // Store results\n        vst1q_s32(&result[i], res);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = factorials[i/2] % 10000;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) result[0] = 1;\n    \n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i), {0,1,2,3});\n        int32x4_t sums = vdupq_n_s32(0);\n        int32x4_t facts = vdupq_n_s32(1);\n        \n        // Calculate factorial and sum for each index\n        for (int j = 1; j <= i + 3; j++) {\n            // Add j to running sums\n            sums = vaddq_s32(sums, vdupq_n_s32(j));\n            \n            // Multiply facts by j and take modulo 10000\n            facts = vmulq_s32(facts, vdupq_n_s32(j));\n            facts = vmodq_s32(facts, vdupq_n_s32(10000));\n        }\n        \n        // Select factorial for even indices, sum for odd indices\n        int32x4_t is_even = vceqq_s32(vandq_s32(indices, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t values = vbslq_s32(is_even, facts, sums);\n        \n        // Store results\n        vst1q_s32(&result[i], values);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            // Calculate factorial\n            int fact = 1;\n            for (int j = 1; j <= i; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            // Calculate sum\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n\n    if (n <= 1) return result;\n\n    // Pre-calculate factorials mod 10000\n    int factorials[16] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 3628800, 3628800, 3628800, 3628800, 3628800};\n    for (int i = 10; i < 16; i++) {\n        factorials[i] %= 10000;\n    }\n\n    // Process 4 elements at a time using NEON\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        // Create index vector\n        int32x4_t idx = vdupq_n_s32(0);\n        idx = vsetq_lane_s32(i, idx, 0);\n        idx = vsetq_lane_s32(i+1, idx, 1);\n        idx = vsetq_lane_s32(i+2, idx, 2);\n        idx = vsetq_lane_s32(i+3, idx, 3);\n\n        // Calculate sum 1..i for odd indices\n        int32x4_t sums = vaddq_s32(idx, vdupq_n_s32(1));\n        sums = vmulq_s32(sums, idx);\n        sums = vshrq_n_s32(sums, 1);\n\n        // Get factorials for even indices\n        int32x4_t facts = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            int curr_idx = i + j;\n            if (curr_idx % 2 == 0) {\n                facts = vsetq_lane_s32(factorials[curr_idx] % 10000, facts, j);\n            }\n        }\n\n        // Create mask for even/odd selection\n        int32x4_t mask = vdupq_n_s32(0);\n        for (int j = 0; j < 4; j++) {\n            mask = vsetq_lane_s32((i + j) % 2 == 0 ? -1 : 0, mask, j);\n        }\n\n        // Select between sums and factorials based on even/odd\n        int32x4_t res = vbslq_s32(vreinterpretq_u32_s32(mask), facts, sums);\n        \n        // Store results\n        vst1q_s32(&result[i], res);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = factorials[i] % 10000;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n\n    if (n <= 1) return result;\n\n    // Pre-compute factorials mod 10000\n    int factorials[16] = {1};\n    for (int i = 1; i < 16; i++) {\n        factorials[i] = (factorials[i-1] * i) % 10000;\n    }\n\n    // Process 4 elements at a time\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        // Create index vector\n        int32x4_t idx = vdupq_n_s32(i);\n        idx = vaddq_s32(idx, vld1q_s32((int32_t[]){0,1,2,3}));\n        \n        // Calculate sum for odd indices\n        int32x4_t sums = vaddq_s32(idx, vdupq_n_s32(1));\n        sums = vmulq_s32(idx, sums);\n        sums = vshrq_n_s32(sums, 1);\n\n        // Load factorials for even indices\n        int32x4_t facts = vld1q_s32(&factorials[i/2]);\n        \n        // Create mask for even/odd\n        int32x4_t even_mask = vtstq_s32(idx, vdupq_n_s32(1));\n        \n        // Select between sums and factorials based on even/odd\n        int32x4_t res = vbslq_s32(even_mask, sums, \n                                 vandq_s32(facts, vdupq_n_s32(9999)));\n        \n        vst1q_s32(&result[i], res);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = factorials[i/2] % 10000;\n        } else {\n            result[i] = (i * (i + 1)) / 2;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32x4_t count = vdupq_n_u32(0);\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t twos = vdupq_n_u32(2);\n    \n    // Process 4 numbers at a time\n    int i;\n    for(i = 1; i + 3 <= n; i += 4) {\n        uint32x4_t nums = {(uint32_t)i, (uint32_t)(i+1), (uint32_t)(i+2), (uint32_t)(i+3)};\n        uint32x4_t rev = {0,0,0,0};\n        uint32x4_t temp = nums;\n        \n        // Reverse digits\n        while (vgetq_lane_u32(vorrq_u32(temp, vdupq_n_u32(0)), 0) ||\n               vgetq_lane_u32(vorrq_u32(temp, vdupq_n_u32(0)), 1) ||\n               vgetq_lane_u32(vorrq_u32(temp, vdupq_n_u32(0)), 2) ||\n               vgetq_lane_u32(vorrq_u32(temp, vdupq_n_u32(0)), 3)) {\n            \n            rev = vmlaq_u32(rev, vdupq_n_u32(10), rev);\n            rev = vaddq_u32(rev, vandq_u32(temp, vdupq_n_u32(9)));\n            temp = vshrq_n_u32(temp, 1);\n        }\n        \n        // Check palindrome and even/odd\n        uint32x4_t is_palindrome = vceqq_u32(nums, rev);\n        uint32x4_t is_even = vceqq_u32(vandq_u32(nums, ones), vdupq_n_u32(0));\n        \n        // Update counts\n        count = vaddq_u32(count, vandq_u32(is_palindrome, is_even));\n    }\n    \n    // Handle remaining numbers\n    int even_count = vgetq_lane_u32(count, 0);\n    int odd_count = 0;\n    \n    for(; i <= n; i++) {\n        int num = i;\n        int rev = 0;\n        int temp = num;\n        \n        while(temp) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        \n        if(num == rev) {\n            if(num % 2 == 0) even_count++;\n            else odd_count++;\n        }\n    }\n    \n    return {even_count, n - even_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32x4_t nums = vdupq_n_u32(0);\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t evens = vdupq_n_u32(0);\n    uint32x4_t odds = vdupq_n_u32(0);\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for(int i = 1; i <= n; i += 4) {\n        // Load 4 consecutive numbers\n        nums = vdupq_n_u32(i);\n        nums = vaddq_u32(nums, vcombine_u32(vcreate_u32(0x0000000100000000), \n                                           vcreate_u32(0x0000000300000002)));\n                                           \n        // Check which numbers are within range\n        uint32x4_t mask = vcleq_u32(nums, vdupq_n_u32(n));\n        \n        // For each number, check if palindrome\n        uint32x4_t palindrome_mask = vdupq_n_u32(0);\n        for(int j = 0; j < 4; j++) {\n            uint32_t num = vgetq_lane_u32(nums, j);\n            if(vgetq_lane_u32(mask, j)) {\n                // Check if palindrome\n                uint32_t rev = 0;\n                uint32_t temp = num;\n                while(temp > 0) {\n                    rev = rev * 10 + temp % 10;\n                    temp /= 10;\n                }\n                if(num == rev) {\n                    palindrome_mask = vsetq_lane_u32(1, palindrome_mask, j);\n                    if(num % 2 == 0) {\n                        even_count++;\n                    } else {\n                        odd_count++; \n                    }\n                }\n            }\n        }\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint16x8_t nums = vdupq_n_u16(0);\n    uint16x8_t ones = vdupq_n_u16(1);\n    uint16x8_t evens = vdupq_n_u16(0);\n    uint16x8_t odds = vdupq_n_u16(0);\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for(int i = 1; i <= n; i += 8) {\n        // Load 8 consecutive numbers\n        uint16_t temp[8] = {(uint16_t)i, (uint16_t)(i+1), (uint16_t)(i+2), (uint16_t)(i+3),\n                           (uint16_t)(i+4), (uint16_t)(i+5), (uint16_t)(i+6), (uint16_t)(i+7)};\n        nums = vld1q_u16(temp);\n        \n        // Check which numbers exceed n\n        uint16x8_t mask = vcleq_u16(nums, vdupq_n_u16(n));\n        \n        // Check palindromes\n        uint16x8_t palindrome_mask = vdupq_n_u16(0);\n        for(int j = 0; j < 8; j++) {\n            uint16_t num = vgetq_lane_u16(nums, j);\n            if(num > n) continue;\n            \n            // Check if palindrome\n            int original = num;\n            int reversed = 0;\n            while(original > 0) {\n                reversed = reversed * 10 + original % 10;\n                original /= 10;\n            }\n            if(num == reversed) {\n                palindrome_mask = vsetq_lane_u16(1, palindrome_mask, j);\n            }\n        }\n        \n        // Count even/odd palindromes\n        uint16x8_t even_mask = vandq_u16(palindrome_mask, \n                                        vceqq_u16(vandq_u16(nums, ones), vdupq_n_u16(0)));\n        uint16x8_t odd_mask = vandq_u16(palindrome_mask,\n                                       vcgtq_u16(vandq_u16(nums, ones), vdupq_n_u16(0)));\n        \n        // Accumulate counts\n        evens = vaddq_u16(evens, vandq_u16(even_mask, mask));\n        odds = vaddq_u16(odds, vandq_u16(odd_mask, mask));\n    }\n    \n    // Sum up results\n    uint16_t even_sum[8], odd_sum[8];\n    vst1q_u16(even_sum, evens);\n    vst1q_u16(odd_sum, odds);\n    \n    for(int i = 0; i < 8; i++) {\n        even_count += even_sum[i];\n        odd_count += odd_sum[i];\n    }\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32x4_t counts = vdupq_n_u32(0);\n    uint32x4_t ones = vdupq_n_u32(1);\n    \n    // Process 4 numbers at a time\n    for(int i = 1; i <= n; i += 4) {\n        uint32x4_t nums = {\n            (uint32_t)(i),\n            (uint32_t)(i + 1 <= n ? i + 1 : 0),\n            (uint32_t)(i + 2 <= n ? i + 2 : 0), \n            (uint32_t)(i + 3 <= n ? i + 3 : 0)\n        };\n        \n        uint32x4_t palindrome_mask = vdupq_n_u32(0);\n        uint32x4_t even_mask = vdupq_n_u32(0);\n        \n        // Check palindrome for each number\n        for(int j = 0; j < 4; j++) {\n            uint32_t num = vgetq_lane_u32(nums, j);\n            if(num > n) continue;\n            \n            // Check if palindrome\n            uint32_t rev = 0;\n            uint32_t temp = num;\n            while(temp > 0) {\n                rev = rev * 10 + temp % 10;\n                temp /= 10;\n            }\n            \n            if(num == rev) {\n                palindrome_mask = vsetq_lane_u32(1, palindrome_mask, j);\n                if(num % 2 == 0) {\n                    even_mask = vsetq_lane_u32(1, even_mask, j);\n                }\n            }\n        }\n        \n        // Update counts using SIMD\n        uint32x4_t even_counts = vandq_u32(palindrome_mask, even_mask);\n        uint32x4_t odd_counts = vandq_u32(palindrome_mask, vmvnq_u32(even_mask));\n        \n        counts = vaddq_u32(counts, vcombine_u32(\n            vpadd_u32(vget_low_u32(even_counts), vget_high_u32(even_counts)),\n            vpadd_u32(vget_low_u32(odd_counts), vget_high_u32(odd_counts))\n        ));\n    }\n    \n    // Extract final counts\n    uint32_t even_sum = vgetq_lane_u32(counts, 0) + vgetq_lane_u32(counts, 1);\n    uint32_t odd_sum = vgetq_lane_u32(counts, 2) + vgetq_lane_u32(counts, 3);\n    \n    return {(int)even_sum, (int)odd_sum};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    \n    // Load 8 numbers at a time\n    uint16x8_t numbers;\n    uint16x8_t ones = vdupq_n_u16(1);\n    uint16x8_t tens = vdupq_n_u16(10);\n    uint16x8_t zeros = vdupq_n_u16(0);\n    \n    int even_count = 0;\n    int odd_count = 0;\n    \n    for(int i = 1; i <= n; i += 8) {\n        // Load 8 consecutive numbers\n        uint16_t temp[8];\n        for(int j = 0; j < 8 && (i+j) <= n; j++) {\n            temp[j] = i + j;\n        }\n        numbers = vld1q_u16(temp);\n        \n        // Check palindrome for 8 numbers in parallel\n        uint16x8_t nums = numbers;\n        uint16x8_t reversed = zeros;\n        uint16x8_t original = numbers;\n        \n        // Reverse digits\n        while(vgetq_lane_u16(vmaxq_u16(nums, zeros), 0) != 0) {\n            reversed = vmulq_u16(reversed, tens);\n            reversed = vaddq_u16(reversed, vandq_u16(nums, ones));\n            nums = vshrq_n_u16(nums, 1);\n        }\n        \n        // Compare original with reversed\n        uint16x8_t is_palindrome = vceqq_u16(original, reversed);\n        \n        // Check even/odd\n        uint16x8_t is_even = vceqq_u16(vandq_u16(original, ones), zeros);\n        \n        // Count results\n        for(int j = 0; j < 8 && (i+j) <= n; j++) {\n            if(vgetq_lane_u16(is_palindrome, j)) {\n                if(vgetq_lane_u16(is_even, j)) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n    }\n    \n    result[0] = even_count;\n    result[1] = odd_count;\n    return result;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int len = n.size();\n    int i = 0;\n    \n    // Process 4 integers at a time using NEON\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        int32x4_t signs = vshrq_n_s32(nums, 31);\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        int32x4_t sums = zeros;\n        \n        // Extract digits and sum them\n        while (vmaxvq_s32(abs_nums) > 0) {\n            int32x4_t digits = vmodq_s32(abs_nums, vdupq_n_s32(10));\n            sums = vaddq_s32(sums, digits);\n            abs_nums = vdivq_s32(abs_nums, vdupq_n_s32(10));\n        }\n        \n        // Apply sign to first digit\n        sums = vsubq_s32(sums, vmulq_s32(signs, vmodq_s32(vabsq_s32(nums), vdupq_n_s32(10))));\n        sums = vmulq_s32(sums, vdupq_n_s32(2));\n        \n        // Compare sums with zero\n        uint32x4_t mask = vcgtq_s32(sums, zeros);\n        count += vaddvq_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        bool neg = num < 0;\n        num = abs(num);\n        \n        bool first = true;\n        while (num > 0) {\n            int digit = num % 10;\n            if (first && neg) {\n                sum -= digit;\n                first = false;\n            } else {\n                sum += digit;\n            }\n            num /= 10;\n        }\n        \n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int len = n.size();\n    int i = 0;\n    \n    // Process 4 integers at a time\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        int32x4_t results = zeros;\n        \n        // Process each number's digits\n        while (1) {\n            int32x4_t quotients = vdivq_s32(nums, vdupq_n_s32(10));\n            int32x4_t remainders = vsubq_s32(nums, vmulq_s32(quotients, vdupq_n_s32(10)));\n            results = vaddq_s32(results, remainders);\n            nums = quotients;\n            \n            uint32x4_t cmp = vceqq_s32(nums, zeros);\n            if (vgetq_lane_u32(cmp, 0) && vgetq_lane_u32(cmp, 1) && \n                vgetq_lane_u32(cmp, 2) && vgetq_lane_u32(cmp, 3)) {\n                break;\n            }\n        }\n        \n        // Count numbers with non-zero digit sums\n        uint32x4_t cmp = vceqq_s32(results, zeros);\n        count += 4 - (vgetq_lane_u32(cmp, 0) + vgetq_lane_u32(cmp, 1) + \n                     vgetq_lane_u32(cmp, 2) + vgetq_lane_u32(cmp, 3));\n    }\n    \n    // Process remaining elements\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum != 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int len = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        int32x4_t signs = vshrq_n_s32(nums, 31);\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        int32x4_t sums = zeros;\n        \n        // Extract digits and sum them\n        while (vmaxvq_s32(abs_nums) > 0) {\n            int32x4_t digits = vmodq_s32(abs_nums, vdupq_n_s32(10));\n            sums = vaddq_s32(sums, digits);\n            abs_nums = vdivq_s32(abs_nums, vdupq_n_s32(10));\n        }\n        \n        // Apply sign to first digit\n        sums = vsubq_s32(sums, vmulq_s32(signs, vmodq_s32(vabsq_s32(nums), vdupq_n_s32(10))));\n        sums = vmulq_s32(sums, vdupq_n_s32(2));\n        \n        // Compare sums with zero\n        uint32x4_t mask = vcgtq_s32(sums, zeros);\n        count += vaddvq_u32(mask);\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        bool first = true;\n        \n        while (num != 0) {\n            int digit = num % 10;\n            if (first && num < 0) {\n                sum -= digit;\n            } else {\n                sum += digit;\n            }\n            num /= 10;\n            first = false;\n        }\n        \n        if (sum > 0) count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int len = n.size();\n    int i = 0;\n    \n    // Process 4 integers at a time using NEON\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        int32x4_t signs = vshrq_n_s32(nums, 31);\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        int32x4_t sums = zeros;\n        \n        // Extract digits and sum them\n        while (vmaxvq_s32(abs_nums) > 0) {\n            int32x4_t digits = vmodq_s32(abs_nums, vdupq_n_s32(10));\n            sums = vaddq_s32(sums, digits);\n            abs_nums = vdivq_s32(abs_nums, vdupq_n_s32(10));\n        }\n        \n        // Apply sign to first digit\n        sums = vsubq_s32(sums, vmulq_s32(signs, vmodq_s32(vabsq_s32(nums), vdupq_n_s32(10))));\n        sums = vmulq_s32(sums, vdupq_n_s32(2));\n        \n        // Compare with zero and count non-zeros\n        uint32x4_t mask = vcgtq_s32(sums, zeros);\n        count += vaddvq_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        bool first = true;\n        \n        while (num != 0) {\n            int digit = num % 10;\n            if (first && num < 0) {\n                sum -= digit;\n                first = false;\n            } else {\n                sum += digit;\n            }\n            num /= 10;\n        }\n        \n        if (sum != 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int len = n.size();\n    int i = 0;\n\n    // Process 4 integers at a time using NEON\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t nums = vld1q_s32(&n[i]);\n        int32x4_t zeros = vdupq_n_s32(0);\n        int32x4_t signs = vshrq_n_s32(nums, 31);\n        int32x4_t abs_nums = vabsq_s32(nums);\n        \n        int32x4_t sums = zeros;\n        \n        // Extract digits and sum them\n        while (vmaxvq_s32(abs_nums) > 0) {\n            int32x4_t digits = vmodq_s32(abs_nums, vdupq_n_s32(10));\n            sums = vaddq_s32(sums, digits);\n            abs_nums = vdivq_s32(abs_nums, vdupq_n_s32(10));\n        }\n        \n        // Adjust first digit sign for negative numbers\n        int32x4_t first_digits = vmulq_s32(\n            vmodq_s32(vabsq_s32(nums), vdupq_n_s32(10)),\n            vsubq_s32(vdupq_n_s32(1), vaddq_s32(signs, signs))\n        );\n        \n        // Compare sums with 0\n        uint32x4_t mask = vcgtq_s32(sums, zeros);\n        count += vaddvq_u32(mask);\n    }\n\n    // Handle remaining elements\n    for (; i < len; i++) {\n        int num = n[i];\n        int sum = 0;\n        bool first = true;\n        \n        while (num != 0) {\n            int digit = num % 10;\n            if (first && n[i] < 0) {\n                digit = -digit;\n                first = false;\n            }\n            sum += digit;\n            num /= 10;\n        }\n        \n        if (sum > 0) count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.size() <= 1) return true;\n    \n    int n = arr.size();\n    \n    // Find position of minimum element\n    int32x4_t vmin = vdupq_n_s32(INT_MAX);\n    int min_pos = 0;\n    \n    for (int i = 0; i < n-3; i+=4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        uint32x4_t cmp = vcltq_s32(v, vmin);\n        if (vgetq_lane_u32(cmp, 0)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 0), vmin, 0);\n            min_pos = i;\n        }\n        if (vgetq_lane_u32(cmp, 1)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 1), vmin, 0);\n            min_pos = i+1;\n        }\n        if (vgetq_lane_u32(cmp, 2)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 2), vmin, 0);\n            min_pos = i+2;\n        }\n        if (vgetq_lane_u32(cmp, 3)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 3), vmin, 0);\n            min_pos = i+3;\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = ((n-1)/4)*4; i < n; i++) {\n        if (arr[i] < vgetq_lane_s32(vmin, 0)) {\n            vmin = vsetq_lane_s32(arr[i], vmin, 0);\n            min_pos = i;\n        }\n    }\n\n    // Check if array is sorted after rotation\n    int prev = arr[min_pos];\n    for (int i = 1; i < n; i++) {\n        int curr_pos = (min_pos + i) % n;\n        if (arr[curr_pos] < prev) {\n            return false;\n        }\n        prev = arr[curr_pos];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.size() <= 1) return true;\n    \n    int n = arr.size();\n    int count = 0;\n    \n    // Find number of ascending sequences\n    for (int i = 0; i < n; i += 4) {\n        int remaining = std::min(4, n - i);\n        int32x4_t curr, next;\n        \n        if (remaining == 4) {\n            curr = vld1q_s32(&arr[i]);\n            next = vextq_s32(curr, curr, 1);\n            \n            uint32x4_t comp = vcgtq_s32(curr, next);\n            uint32_t mask = vgetq_lane_u32(comp, 0) | \n                           (vgetq_lane_u32(comp, 1) << 1) |\n                           (vgetq_lane_u32(comp, 2) << 2) |\n                           (vgetq_lane_u32(comp, 3) << 3);\n                           \n            count += __builtin_popcount(mask & 0x7);\n            \n            if (i == 0) {\n                int32x4_t first = vdupq_n_s32(arr[0]);\n                int32x4_t last = vdupq_n_s32(arr[n-1]); \n                if (vgetq_lane_s32(last, 0) > vgetq_lane_s32(first, 0)) {\n                    count++;\n                }\n            }\n        } else {\n            for (int j = i; j < i + remaining - 1; j++) {\n                if (arr[j] > arr[j+1]) count++;\n            }\n            if (i == 0 && arr[n-1] > arr[0]) count++;\n        }\n    }\n    \n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n <= 1) return true;\n\n    // Find position of minimum element\n    int32x4_t vmin = vdupq_n_s32(INT_MAX);\n    int min_pos = 0;\n    \n    for (int i = 0; i < n-3; i+=4) {\n        int32x4_t vcurr = vld1q_s32(&arr[i]);\n        uint32x4_t vcmp = vcltq_s32(vcurr, vmin);\n        \n        if (vgetq_lane_u32(vcmp, 0)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 0), vmin, 0);\n            min_pos = i;\n        }\n        if (vgetq_lane_u32(vcmp, 1)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 1), vmin, 0);\n            min_pos = i+1;\n        }\n        if (vgetq_lane_u32(vcmp, 2)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 2), vmin, 0);\n            min_pos = i+2;\n        }\n        if (vgetq_lane_u32(vcmp, 3)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 3), vmin, 0);\n            min_pos = i+3;\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = ((n-1)/4)*4; i < n; i++) {\n        if (arr[i] < vgetq_lane_s32(vmin, 0)) {\n            vmin = vsetq_lane_s32(arr[i], vmin, 0);\n            min_pos = i;\n        }\n    }\n\n    // Check if array is sorted after rotation\n    int prev = arr[min_pos];\n    for (int i = 1; i < n; i++) {\n        int curr_pos = (min_pos + i) % n;\n        if (arr[curr_pos] < prev) {\n            return false;\n        }\n        prev = arr[curr_pos];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n == 1) return true;\n\n    // Find position of minimum element\n    int32x4_t vmin = vdupq_n_s32(INT_MAX);\n    int min_pos = 0;\n    \n    for (int i = 0; i < n-3; i+=4) {\n        int32x4_t vcurr = vld1q_s32(&arr[i]);\n        uint32x4_t vcmp = vcltq_s32(vcurr, vmin);\n        \n        if (vgetq_lane_u32(vcmp, 0)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 0), vmin, 0);\n            min_pos = i;\n        }\n        if (vgetq_lane_u32(vcmp, 1)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 1), vmin, 0);\n            min_pos = i+1;\n        }\n        if (vgetq_lane_u32(vcmp, 2)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 2), vmin, 0);\n            min_pos = i+2;\n        }\n        if (vgetq_lane_u32(vcmp, 3)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(vcurr, 3), vmin, 0);\n            min_pos = i+3;\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < vgetq_lane_s32(vmin, 0)) {\n            vmin = vsetq_lane_s32(arr[i], vmin, 0);\n            min_pos = i;\n        }\n    }\n\n    // Check if array is sorted after rotation\n    int prev = arr[min_pos];\n    for (int i = 1; i < n; i++) {\n        int curr_pos = (min_pos + i) % n;\n        if (arr[curr_pos] < prev) {\n            return false;\n        }\n        prev = arr[curr_pos];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.size() <= 1) return true;\n    \n    int n = arr.size();\n    int count = 0;\n    \n    // Find number of rotations needed by finding min element\n    int32x4_t vmin = vdupq_n_s32(INT_MAX);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n-3; i+=4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        uint32x4_t vcmp = vcltq_s32(v, vmin);\n        \n        if (vgetq_lane_u32(vcmp, 0)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 0), vmin, 0);\n            min_idx = i;\n        }\n        if (vgetq_lane_u32(vcmp, 1)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 1), vmin, 0); \n            min_idx = i+1;\n        }\n        if (vgetq_lane_u32(vcmp, 2)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 2), vmin, 0);\n            min_idx = i+2;\n        }\n        if (vgetq_lane_u32(vcmp, 3)) {\n            vmin = vsetq_lane_s32(vgetq_lane_s32(v, 3), vmin, 0);\n            min_idx = i+3;\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < vgetq_lane_s32(vmin, 0)) {\n            vmin = vsetq_lane_s32(arr[i], vmin, 0);\n            min_idx = i;\n        }\n    }\n\n    // Rotate array to put min element at start\n    std::rotate(arr.begin(), arr.begin() + min_idx, arr.end());\n    \n    // Check if array is sorted after rotation\n    int32x4_t prev = vdupq_n_s32(INT_MIN);\n    \n    for (int i = 0; i < n-3; i+=4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        uint32x4_t vcmp = vcleq_s32(prev, curr);\n        \n        if (vgetq_lane_u32(vcmp, 0) == 0 ||\n            vgetq_lane_u32(vcmp, 1) == 0 ||\n            vgetq_lane_u32(vcmp, 2) == 0 ||\n            vgetq_lane_u32(vcmp, 3) == 0) {\n            return false;\n        }\n        prev = curr;\n    }\n    \n    // Check remaining elements\n    int last = vgetq_lane_s32(prev, 3);\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < last) return false;\n        last = arr[i];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 3; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        \n        // Create mask for odd numbers (LSB = 1)\n        uint32x4_t mask1 = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1));\n        uint32x4_t mask2 = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1));\n        \n        // Count odd numbers in lst1\n        odd_count1 += vaddvq_u32(mask1);\n        \n        // Count even numbers in lst2\n        even_count2 += 4 - vaddvq_u32(mask2);\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (lst1[i] & 1) odd_count1++;\n        if (!(lst2[i] & 1)) even_count2++;\n    }\n    \n    // If number of odd elements in lst1 is less than or equal to \n    // number of even elements in lst2, exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 3; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        \n        // Create mask for odd numbers (LSB = 1)\n        int32x4_t odd_mask1 = vandq_s32(v1, vdupq_n_s32(1));\n        int32x4_t odd_mask2 = vandq_s32(v2, vdupq_n_s32(1));\n        \n        // Count odd numbers in lst1\n        uint32x4_t cmp1 = vceqq_s32(odd_mask1, vdupq_n_s32(1));\n        odd_count1 += vaddvq_u32(cmp1);\n        \n        // Count even numbers in lst2\n        uint32x4_t cmp2 = vceqq_s32(odd_mask2, vdupq_n_s32(0));\n        even_count2 += vaddvq_u32(cmp2);\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (lst1[i] & 1) odd_count1++;\n        if (!(lst2[i] & 1)) even_count2++;\n    }\n    \n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (int i = 0; i < n - 3; i += 4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        \n        // Create mask for odd numbers (LSB = 1)\n        uint32x4_t mask1 = vandq_u32(vreinterpretq_u32_s32(v1), vdupq_n_u32(1));\n        uint32x4_t mask2 = vandq_u32(vreinterpretq_u32_s32(v2), vdupq_n_u32(1));\n        \n        // Count odd numbers in lst1\n        odd_count1 += vaddvq_u32(mask1);\n        \n        // Count even numbers in lst2\n        even_count2 += 4 - vaddvq_u32(mask2);\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (lst1[i] & 1) odd_count1++;\n        if (!(lst2[i] & 1)) even_count2++;\n    }\n    \n    // If number of odd elements in lst1 is less than or equal to \n    // number of even elements in lst2, exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using NEON\n    int i = 0;\n    for (; i <= n-4; i+=4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        \n        // Create mask for odd numbers (LSB = 1)\n        int32x4_t odd_mask1 = vandq_s32(v1, vdupq_n_s32(1));\n        int32x4_t odd_mask2 = vandq_s32(v2, vdupq_n_s32(1));\n        \n        // Count odd numbers in lst1\n        uint32x4_t cmp1 = vceqq_s32(odd_mask1, vdupq_n_s32(1));\n        odd_count1 += vaddvq_u32(cmp1);\n        \n        // Count even numbers in lst2\n        uint32x4_t cmp2 = vceqq_s32(odd_mask2, vdupq_n_s32(0));\n        even_count2 += vaddvq_u32(cmp2);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        odd_count1 += (lst1[i] & 1);\n        even_count2 += !(lst2[i] & 1);\n    }\n\n    // If number of odd elements in lst1 is less than or equal to \n    // number of even elements in lst2, exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using NEON\n    for(int i = 0; i < n-3; i+=4) {\n        int32x4_t v1 = vld1q_s32(&lst1[i]);\n        int32x4_t v2 = vld1q_s32(&lst2[i]);\n        \n        // Create mask for odd numbers (LSB = 1)\n        int32x4_t odd_mask1 = vandq_s32(v1, vdupq_n_s32(1));\n        int32x4_t odd_mask2 = vandq_s32(v2, vdupq_n_s32(1));\n        \n        // Count odd numbers in lst1\n        uint32x4_t cmp1 = vceqq_s32(odd_mask1, vdupq_n_s32(1));\n        odd_count1 += vaddvq_u32(cmp1);\n        \n        // Count even numbers in lst2\n        uint32x4_t cmp2 = vceqq_s32(odd_mask2, vdupq_n_s32(0));\n        even_count2 += vaddvq_u32(cmp2);\n    }\n    \n    // Handle remaining elements\n    for(int i = (n/4)*4; i < n; i++) {\n        if(lst1[i] & 1) odd_count1++;\n        if(!(lst2[i] & 1)) even_count2++;\n    }\n    \n    // If number of odd elements in lst1 is less than or equal to \n    // number of even elements in lst2, exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %dn the str%dng %d of the %dnput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const int len = str.length();\n        const int simd_len = len - (len % 8);\n        \n        // Process 8 digits at a time using NEON\n        uint8x8_t odd_mask = vdup_n_u8(1);\n        for (int i = 0; i < simd_len; i += 8) {\n            uint8x8_t chars = vld1_u8((uint8_t*)&str[i]);\n            uint8x8_t digits = vsub_u8(chars, vdup_n_u8('0'));\n            uint8x8_t odd = vand_u8(digits, odd_mask);\n            \n            uint8x8_t cmp = vtst_u8(odd, odd_mask);\n            odd_count += vaddv_u8(cmp) >> 7;\n        }\n        \n        // Handle remaining digits\n        for (int i = simd_len; i < len; i++) {\n            odd_count += ((str[i] - '0') & 1);\n        }\n\n        char buffer[128];\n        snprintf(buffer, sizeof(buffer), template_str, \n                odd_count, odd_count, odd_count, odd_count);\n        result.emplace_back(buffer);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using NEON\n        int len = str.length();\n        int i = 0;\n        \n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n            \n            // Convert ASCII digits to actual numbers by subtracting '0'\n            uint8x16_t nums = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Create mask for odd numbers (bitwise AND with 1)\n            uint8x16_t odd_mask = vandq_u8(nums, vdupq_n_u8(1));\n            \n            // Count odd numbers using horizontal sum\n            uint8x8_t sum_8 = vpadd_u8(vget_low_u8(odd_mask), vget_high_u8(odd_mask));\n            sum_8 = vpadd_u8(sum_8, sum_8);\n            sum_8 = vpadd_u8(sum_8, sum_8);\n            sum_8 = vpadd_u8(sum_8, sum_8);\n            \n            odd_count += vget_lane_u8(sum_8, 0);\n        }\n        \n        // Handle remaining characters\n        for (; i < len; i++) {\n            if ((str[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n        \n        // Format result string\n        char buffer[128];\n        snprintf(buffer, sizeof(buffer), template_str, odd_count, odd_count, odd_count, odd_count);\n        result.emplace_back(buffer);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using NEON\n        int len = str.length();\n        int i = 0;\n        \n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n            \n            // Convert ASCII digits to actual numbers by subtracting '0'\n            uint8x16_t nums = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Create mask for odd numbers (bitwise AND with 1)\n            uint8x16_t odd_mask = vandq_u8(nums, vdupq_n_u8(1));\n            \n            // Count number of 1s in the mask\n            uint8x8_t sum_low = vpaddl_u8(vget_low_u8(odd_mask));\n            uint8x8_t sum_high = vpaddl_u8(vget_high_u8(odd_mask));\n            uint16x4_t sum = vpaddl_u8(vadd_u8(sum_low, sum_high));\n            uint32x2_t sum2 = vpaddl_u16(sum);\n            odd_count += vget_lane_u32(sum2, 0);\n        }\n        \n        // Handle remaining characters\n        for (; i < len; i++) {\n            if ((str[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n        \n        // Format result string\n        char buffer[256];\n        snprintf(buffer, sizeof(buffer), template_str, \n                odd_count, odd_count, odd_count, odd_count);\n        result.push_back(std::string(buffer));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %dn the str%dng %d of the %dnput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using NEON\n        int len = str.length();\n        int i = 0;\n        \n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n            \n            // Convert ASCII digits to actual numbers by subtracting '0'\n            uint8x16_t nums = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Create mask for odd numbers (1 for odd, 0 for even)\n            uint8x16_t odd_mask = vandq_u8(nums, vdupq_n_u8(1));\n            \n            // Count number of 1s in the mask\n            uint8x8_t sum_low = vpaddl_u8(vget_low_u8(odd_mask));\n            uint8x8_t sum_high = vpaddl_u8(vget_high_u8(odd_mask));\n            uint16x4_t sum = vpaddl_u8(vadd_u8(sum_low, sum_high));\n            uint32x2_t sum2 = vpaddl_u16(sum);\n            odd_count += vget_lane_u32(sum2, 0);\n        }\n        \n        // Handle remaining characters\n        for (; i < len; i++) {\n            if ((str[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n        \n        char buffer[256];\n        snprintf(buffer, sizeof(buffer), template_str, \n                odd_count, odd_count, odd_count, odd_count);\n        result.push_back(std::string(buffer));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %dn the str%dng %d of the %dnput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using NEON\n        int len = str.length();\n        int i = 0;\n        \n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n            \n            // Convert ASCII digits to actual numbers by subtracting '0'\n            uint8x16_t nums = vsubq_u8(chars, vdupq_n_u8('0'));\n            \n            // Create mask for odd numbers (1 for odd, 0 for even)\n            uint8x16_t odd_mask = vandq_u8(nums, vdupq_n_u8(1));\n            \n            // Count number of 1s in the mask\n            uint8x8_t sum_low = vpaddl_u8(vget_low_u8(odd_mask));\n            uint8x8_t sum_high = vpaddl_u8(vget_high_u8(odd_mask));\n            uint16x4_t sum = vpaddl_u8(vadd_u8(sum_low, sum_high));\n            uint32x2_t sum2 = vpaddl_u16(sum);\n            odd_count += vget_lane_u32(sum2, 0);\n        }\n        \n        // Handle remaining characters\n        for (; i < len; i++) {\n            if ((str[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n        \n        char buffer[256];\n        snprintf(buffer, sizeof(buffer), template_str, \n                odd_count, odd_count, odd_count, odd_count);\n        result.emplace_back(buffer);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    const size_t n = nums.size();\n    if (n < 4) {\n        int64_t minSum = nums[0];\n        int64_t currSum = 0;\n        for (size_t i = 0; i < n; i++) {\n            currSum = std::max(nums[i], currSum + nums[i]);\n            minSum = std::min(minSum, currSum);\n        }\n        return minSum;\n    }\n\n    int64_t minSum = nums[0];\n    int64x2_t currSum = vdupq_n_s64(0);\n    int64x2_t minSumVec = vdupq_n_s64(INT64_MAX);\n    \n    // Process 2 elements at a time\n    for (size_t i = 0; i < n - 1; i += 2) {\n        int64x2_t nums_vec;\n        if (i + 1 < n) {\n            nums_vec = vld1q_s64(&nums[i]);\n        } else {\n            nums_vec = vdupq_n_s64(nums[i]);\n        }\n        \n        // Calculate current sum\n        currSum = vaddq_s64(currSum, nums_vec);\n        \n        // Compare with just taking the current elements\n        currSum = vmaxq_s64(nums_vec, currSum);\n        \n        // Update minimum sum\n        minSumVec = vminq_s64(minSumVec, currSum);\n    }\n\n    // Extract minimum from vector\n    int64_t min_arr[2];\n    vst1q_s64(min_arr, minSumVec);\n    minSum = std::min(min_arr[0], min_arr[1]);\n\n    // Handle remaining element if array size is odd\n    if (n % 2) {\n        int64_t lastSum = std::max(nums[n-1], nums[n-1]);\n        minSum = std::min(minSum, lastSum);\n    }\n\n    return minSum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    size_t n = nums.size();\n    if (n < 2) return nums[0];\n\n    // Process 2 elements at a time using NEON\n    int64_t curr_sum = 0;\n    int64_t min_sum = nums[0];\n    size_t i = 0;\n\n    for (; i + 1 < n; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        int64x2_t curr_sum_vec = vdupq_n_s64(curr_sum);\n        curr_sum_vec = vaddq_s64(curr_sum_vec, vec);\n        \n        int64_t sums[2];\n        vst1q_s64(sums, curr_sum_vec);\n        \n        // Update running sum and minimum\n        curr_sum = sums[1];\n        min_sum = std::min(min_sum, sums[0]);\n        min_sum = std::min(min_sum, sums[1]);\n        \n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n    }\n\n    // Handle remaining element if array length is odd\n    if (i < n) {\n        curr_sum += nums[i];\n        min_sum = std::min(min_sum, curr_sum);\n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    size_t n = nums.size();\n    if (n < 2) return nums[0];\n\n    // Initialize vectors for current sum and minimum sum\n    int64x2_t curr_sum = vdupq_n_s64(0);\n    int64x2_t min_sum = vdupq_n_s64(INT64_MAX);\n    int64x2_t zero = vdupq_n_s64(0);\n\n    // Process 2 elements at a time\n    for (size_t i = 0; i < n - 1; i += 2) {\n        int64x2_t nums_vec;\n        if (i + 1 < n) {\n            nums_vec = vld1q_s64(&nums[i]);\n        } else {\n            nums_vec = vsetq_lane_s64(nums[i], zero, 0);\n        }\n\n        // Add to current sum\n        curr_sum = vaddq_s64(curr_sum, nums_vec);\n        \n        // Update minimum sum\n        min_sum = vminq_s64(min_sum, curr_sum);\n        \n        // Reset current sum if it becomes positive\n        int64x2_t mask = vcltq_s64(curr_sum, zero);\n        curr_sum = vandq_s64(curr_sum, mask);\n    }\n\n    // Extract minimum from vector\n    int64_t min1 = vgetq_lane_s64(min_sum, 0);\n    int64_t min2 = vgetq_lane_s64(min_sum, 1);\n    \n    // Handle remaining element if array size is odd\n    if (n % 2) {\n        int64_t last = nums[n-1];\n        int64_t curr = std::min(last, last + vgetq_lane_s64(curr_sum, 1));\n        return std::min({min1, min2, curr});\n    }\n\n    return std::min(min1, min2);\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    const size_t n = nums.size();\n    if (n < 4) {\n        int64_t minSum = nums[0];\n        int64_t currSum = 0;\n        for (size_t i = 0; i < n; i++) {\n            currSum = std::max(nums[i], currSum + nums[i]);\n            minSum = std::min(minSum, currSum);\n        }\n        return minSum;\n    }\n\n    int64_t minSum = nums[0];\n    int64x2_t currSum = vdupq_n_s64(0);\n    int64x2_t minSumVec = vdupq_n_s64(INT64_MAX);\n    \n    for (size_t i = 0; i < n-1; i += 2) {\n        int64x2_t nums_vec;\n        if (i + 1 < n) {\n            nums_vec = vld1q_s64(&nums[i]);\n        } else {\n            nums_vec = vdupq_n_s64(nums[i]);\n        }\n        \n        currSum = vaddq_s64(currSum, nums_vec);\n        \n        int64x2_t temp = vpminq_s64(currSum, nums_vec);\n        minSumVec = vpminq_s64(minSumVec, temp);\n        \n        int64_t low = vgetq_lane_s64(currSum, 0);\n        int64_t high = vgetq_lane_s64(currSum, 1);\n        \n        if (low < 0) {\n            currSum = vsetq_lane_s64(0, currSum, 0);\n        }\n        if (high < 0) {\n            currSum = vsetq_lane_s64(0, currSum, 1);\n        }\n    }\n    \n    int64_t min1 = vgetq_lane_s64(minSumVec, 0);\n    int64_t min2 = vgetq_lane_s64(minSumVec, 1);\n    \n    return std::min(minSum, std::min(min1, min2));\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    size_t n = nums.size();\n    if (n < 2) return nums[0];\n\n    // Process 2 elements at a time using NEON\n    int64_t curr_sum = 0;\n    int64_t min_sum = nums[0];\n    size_t i = 0;\n\n    for (; i + 1 < n; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        int64x2_t curr_sum_vec = vdupq_n_s64(curr_sum);\n        curr_sum_vec = vaddq_s64(curr_sum_vec, vec);\n        \n        int64_t sums[2];\n        vst1q_s64(sums, curr_sum_vec);\n        \n        // Update running sum and minimum\n        curr_sum = sums[1];\n        min_sum = std::min(min_sum, sums[0]);\n        min_sum = std::min(min_sum, sums[1]);\n        \n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n    }\n\n    // Handle remaining element if array length is odd\n    if (i < n) {\n        curr_sum += nums[i];\n        min_sum = std::min(min_sum, curr_sum);\n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Initialize array to store water counts per row\n    int row_sums[rows];\n    memset(row_sums, 0, rows * sizeof(int));\n\n    // Process 16 elements at a time using NEON\n    for (int i = 0; i < rows; i++) {\n        int j = 0;\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        \n        // Sum 4 elements at a time\n        for (; j + 3 < cols; j += 4) {\n            int32x4_t data = vld1q_s32((const int32_t*)&grid[i][j]);\n            sum_vec = vaddq_s32(sum_vec, data);\n        }\n        \n        // Horizontal sum of vector\n        int32x2_t sum_2 = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        int32x2_t sum_1 = vpadd_s32(sum_2, sum_2);\n        row_sums[i] = vget_lane_s32(sum_1, 0);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            row_sums[i] += grid[i][j];\n        }\n    }\n    \n    // Calculate total trips needed\n    int total_trips = 0;\n    for (int i = 0; i < rows; i++) {\n        total_trips += (row_sums[i] + capacity - 1) / capacity;\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> >& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Count total water units in each row using NEON\n    std::vector<int> row_sums(rows);\n    \n    for (int i = 0; i < rows; i++) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        int j = 0;\n        \n        // Process 4 elements at a time\n        for (; j + 3 < cols; j += 4) {\n            int32x4_t data = vld1q_s32((const int32_t*)&grid[i][j]);\n            sum_vec = vaddq_s32(sum_vec, data);\n        }\n        \n        // Sum the 4 elements in the vector\n        int sum = vgetq_lane_s32(sum_vec, 0) + \n                 vgetq_lane_s32(sum_vec, 1) + \n                 vgetq_lane_s32(sum_vec, 2) + \n                 vgetq_lane_s32(sum_vec, 3);\n                 \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            sum += grid[i][j];\n        }\n        \n        row_sums[i] = sum;\n    }\n    \n    // Calculate total number of bucket operations needed\n    int total_ops = 0;\n    for (int i = 0; i < rows; i++) {\n        total_ops += (row_sums[i] + capacity - 1) / capacity;\n    }\n    \n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Count total 1s in each row using NEON\n    std::vector<int> row_sums(rows);\n    \n    for (int i = 0; i < rows; i++) {\n        int32x4_t sum = vdupq_n_s32(0);\n        int j = 0;\n        \n        // Process 4 elements at a time\n        for (; j + 3 < cols; j += 4) {\n            int32x4_t vec = vld1q_s32((const int32_t*)&grid[i][j]);\n            sum = vaddq_s32(sum, vec);\n        }\n        \n        // Sum the 4 elements in the vector\n        int32_t temp[4];\n        vst1q_s32(temp, sum);\n        int row_sum = temp[0] + temp[1] + temp[2] + temp[3];\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            row_sum += grid[i][j];\n        }\n        \n        row_sums[i] = row_sum;\n    }\n    \n    // Calculate total trips needed\n    int total_trips = 0;\n    for (int sum : row_sums) {\n        total_trips += (sum + capacity - 1) / capacity;\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Handle small inputs without SIMD\n    if (cols < 4) {\n        int total = 0;\n        for (int i = 0; i < rows; i++) {\n            int row_sum = 0;\n            for (int j = 0; j < cols; j++) {\n                row_sum += grid[i][j];\n            }\n            total += (row_sum + capacity - 1) / capacity;\n        }\n        return total;\n    }\n\n    int result = 0;\n    const int vec_size = 4;\n    const int vec_cols = cols - (cols % vec_size);\n    \n    for (int i = 0; i < rows; i++) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        \n        // Process 4 elements at a time using NEON\n        for (int j = 0; j < vec_cols; j += vec_size) {\n            int32x4_t data = vld1q_s32((const int32_t*)&grid[i][j]);\n            sum_vec = vaddq_s32(sum_vec, data);\n        }\n        \n        // Horizontal sum of vector\n        int row_sum = vgetq_lane_s32(sum_vec, 0) + \n                     vgetq_lane_s32(sum_vec, 1) +\n                     vgetq_lane_s32(sum_vec, 2) + \n                     vgetq_lane_s32(sum_vec, 3);\n                     \n        // Add remaining elements\n        for (int j = vec_cols; j < cols; j++) {\n            row_sum += grid[i][j];\n        }\n        \n        // Calculate buckets needed for this row\n        result += (row_sum + capacity - 1) / capacity;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Calculate number of complete vectors and remaining elements\n    const int vec_size = 4;\n    const int vec_count = cols / vec_size;\n    const int remainder = cols % vec_size;\n    \n    int total_trips = 0;\n    \n    // Process each row\n    for (int i = 0; i < rows; i++) {\n        int water_units = 0;\n        \n        // Process vectors of 4 elements using NEON\n        for (int j = 0; j < vec_count; j++) {\n            uint32x4_t vec = vld1q_u32((uint32_t*)&grid[i][j * vec_size]);\n            uint32x4_t sum = vpaddlq_u32(vec);\n            sum = vpaddq_u32(sum, vdupq_n_u32(0));\n            water_units += vgetq_lane_u32(sum, 0) + vgetq_lane_u32(sum, 1);\n        }\n        \n        // Process remaining elements\n        for (int j = vec_count * vec_size; j < cols; j++) {\n            water_units += grid[i][j];\n        }\n        \n        // Calculate trips needed for this row\n        total_trips += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] % 2 != 0) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    int vectorized_size = size - (size % 8);\n    int16x8_t mask = vdupq_n_s16(1);\n    int64x2_t acc = vdupq_n_s64(0);\n    \n    for (int i = 0; i < vectorized_size; i += 8) {\n        int16x8_t data = vld1q_s16(&lst[i]);\n        int16x8_t even_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        int16x8_t even_elements = vandq_s16(data, even_mask);\n        \n        int16x8_t odd_check = vandq_s16(data, mask);\n        uint16x8_t is_odd = vceqq_s16(odd_check, mask);\n        int16x8_t odd_nums = vandq_s16(even_elements, vreinterpretq_s16_u16(is_odd));\n        \n        int32x4_t sum_low = vpaddlq_s16(odd_nums);\n        int64x2_t sum_ll = vpaddlq_s32(sum_low);\n        acc = vaddq_s64(acc, sum_ll);\n    }\n    \n    sum = vgetq_lane_s64(acc, 0) + vgetq_lane_s64(acc, 1);\n    \n    for (int i = vectorized_size; i < size; i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] % 2 != 0) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    int vectorized_size = size - (size % 8);\n    \n    int16x8_t mask_even = {1, 0, 1, 0, 1, 0, 1, 0};\n    int16x8_t one = vdupq_n_s16(1);\n    int64x2_t acc = vdupq_n_s64(0);\n    \n    for (int i = 0; i < vectorized_size; i += 8) {\n        int16x8_t data = vld1q_s16(&lst[i]);\n        int16x8_t is_odd = vandq_s16(data, one);\n        is_odd = vceqq_s16(is_odd, one);\n        int16x8_t masked = vandq_s16(is_odd, mask_even);\n        int16x8_t result = vandq_s16(data, masked);\n        \n        int32x4_t sum_low = vmovl_s16(vget_low_s16(result));\n        int32x4_t sum_high = vmovl_s16(vget_high_s16(result));\n        \n        int64x2_t sum_l = vpaddlq_s32(sum_low);\n        int64x2_t sum_h = vpaddlq_s32(sum_high);\n        acc = vaddq_s64(acc, sum_l);\n        acc = vaddq_s64(acc, sum_h);\n    }\n    \n    sum = vgetq_lane_s64(acc, 0) + vgetq_lane_s64(acc, 1);\n\n    for (int i = vectorized_size; i < size; i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] % 2 != 0) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    int vectorized_size = size - (size % 8);\n    \n    int16x8_t mask_one = vdupq_n_s16(1);\n    int16x8_t zeros = vdupq_n_s16(0);\n    int64x2_t acc = vdupq_n_s64(0);\n    \n    for (int i = 0; i < vectorized_size; i += 8) {\n        int16x8_t data = vld1q_s16(&lst[i]);\n        \n        // Create mask for even positions (1,0,1,0,1,0,1,0)\n        int16x8_t pos_mask = {1,0,1,0,1,0,1,0};\n        \n        // Check for odd numbers\n        int16x8_t odd_mask = vandq_s16(data, mask_one);\n        odd_mask = vceqq_s16(odd_mask, mask_one);\n        \n        // Combine position and odd number masks\n        int16x8_t final_mask = vandq_s16(odd_mask, pos_mask);\n        \n        // Zero out non-qualifying numbers\n        int16x8_t masked_data = vandq_s16(data, final_mask);\n        \n        // Accumulate in 64-bit chunks\n        int32x4_t sum32 = vpaddlq_s16(masked_data);\n        int64x2_t sum64 = vpaddlq_s32(sum32);\n        acc = vaddq_s64(acc, sum64);\n    }\n    \n    sum = vgetq_lane_s64(acc, 0) + vgetq_lane_s64(acc, 1);\n    \n    // Handle remaining elements\n    for (int i = vectorized_size; i < size; i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] % 2 != 0) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    int vectorized_size = size - (size % 8);\n    \n    int16x8_t mask_even = {1, 0, 1, 0, 1, 0, 1, 0};\n    int16x8_t one = vdupq_n_s16(1);\n    int32x4_t acc = vdupq_n_s32(0);\n    \n    for (int i = 0; i < vectorized_size; i += 8) {\n        int16x8_t data = vld1q_s16(&lst[i]);\n        int16x8_t is_odd = vandq_s16(data, one);\n        is_odd = vceqq_s16(is_odd, one);\n        int16x8_t masked = vandq_s16(is_odd, mask_even);\n        int16x8_t result = vandq_s16(data, masked);\n        \n        int32x4_t sum_low = vmovl_s16(vget_low_s16(result));\n        int32x4_t sum_high = vmovl_s16(vget_high_s16(result));\n        acc = vaddq_s32(acc, sum_low);\n        acc = vaddq_s32(acc, sum_high);\n    }\n    \n    int32_t temp[4];\n    vst1q_s32(temp, acc);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (int i = vectorized_size; i < size; i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t vec_size = size - (size % 8);\n    \n    if (vec_size > 0) {\n        int16x8_t mask = vdupq_n_s16(1);\n        int16x8_t even_mask = {1,0,1,0,1,0,1,0};\n        int64x2_t acc = vdupq_n_s64(0);\n        \n        for (size_t i = 0; i < vec_size; i += 8) {\n            int16x8_t v = vld1q_s16(&lst[i]);\n            int16x8_t is_odd = vandq_s16(v, mask);\n            is_odd = vceqq_s16(is_odd, mask);\n            int16x8_t masked = vandq_s16(is_odd, even_mask);\n            masked = vandq_s16(masked, v);\n            \n            int32x4_t sum_low = vpaddlq_s16(masked);\n            int64x2_t sum_ll = vpaddlq_s32(sum_low);\n            acc = vaddq_s64(acc, sum_ll);\n        }\n        \n        sum = vgetq_lane_s64(acc, 0) + vgetq_lane_s64(acc, 1);\n    }\n    \n    for (size_t i = vec_size; i < size; i += 2) {\n        if (i < size && (lst[i] & 1)) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers < 100\n        int32x4_t hundred = vdupq_n_s32(100);\n        uint32x4_t mask = vcltq_s32(vabsq_s32(vec), hundred);\n        \n        // Zero out numbers >= 100\n        vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        \n        // Add elements horizontally\n        int32x2_t sum_2 = vpadd_s32(vget_low_s32(vec), vget_high_s32(vec));\n        sum_2 = vpadd_s32(sum_2, sum_2);\n        sum += vget_lane_s32(sum_2, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int result = 0;\n    int i = 0;\n\n    // Process 4 elements at a time using NEON\n    for (; i + 3 < k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers >= 100\n        int32x4_t hundred = vdupq_n_s32(100);\n        uint32x4_t mask = vcltq_s32(vec, hundred);\n        \n        // Zero out numbers >= 100\n        vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        \n        // Horizontal sum\n        int32x2_t sum = vget_low_s32(vec) + vget_high_s32(vec);\n        sum = vpadd_s32(sum, sum);\n        result += vget_lane_s32(sum, 0);\n    }\n\n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] < 100) {\n            result += arr[i];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (; i + 3 < k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers >= 100\n        int32x4_t hundred = vdupq_n_s32(100);\n        uint32x4_t mask = vcltq_s32(vec, hundred);\n        \n        // Zero out numbers >= 100\n        vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        \n        // Add elements horizontally\n        int32x2_t sum_2 = vpadd_s32(vget_low_s32(vec), vget_high_s32(vec));\n        sum_2 = vpadd_s32(sum_2, sum_2);\n        sum += vget_lane_s32(sum_2, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (; i + 4 <= k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers >= 100\n        int32x4_t hundred = vdupq_n_s32(100);\n        uint32x4_t mask = vcltq_s32(vec, hundred);\n        \n        // Zero out numbers >= 100\n        vec = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        \n        // Add elements horizontally\n        int32x2_t sum_2 = vpadd_s32(vget_low_s32(vec), vget_high_s32(vec));\n        sum_2 = vpadd_s32(sum_2, sum_2);\n        sum += vget_lane_s32(sum_2, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using NEON\n    for (; i + 3 < k; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Create mask for numbers < 100\n        int32x4_t hundred = vdupq_n_s32(100);\n        uint32x4_t mask = vcltq_s32(vabsq_s32(vec), hundred);\n        \n        // Zero out numbers >= 100\n        int32x4_t masked = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        \n        // Horizontal sum of masked values\n        int32x2_t sum_2 = vpadd_s32(vget_low_s32(masked), vget_high_s32(masked));\n        sum_2 = vpadd_s32(sum_2, sum_2);\n        sum += vget_lane_s32(sum_2, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (abs(arr[i]) < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    const int n = lst.size();\n    \n    // Check for duplicates using SIMD\n    for (int i = 0; i < n-4; i+=4) {\n        uint32x4_t v1 = vld1q_u32((uint32_t*)&lst[i]);\n        \n        // Compare each element with next 3 elements\n        for (int j = 1; j < 4; j++) {\n            uint32x4_t v2 = vextq_u32(v1, v1, j);\n            uint32x4_t eq = vceqq_u32(v1, v2);\n            if (vgetq_lane_u32(eq, 0) || vgetq_lane_u32(eq, 1) || \n                vgetq_lane_u32(eq, 2) || vgetq_lane_u32(eq, 3)) {\n                // Check if more than 2 equal elements\n                int count = 0;\n                for (int k = i; k < i+4 && k < n; k++) {\n                    for (int l = k+1; l < n; l++) {\n                        if (lst[k] == lst[l]) count++;\n                        if (count > 1) return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    // Check remaining elements for duplicates\n    for (int i = n-n%4; i < n; i++) {\n        int count = 0;\n        for (int j = i+1; j < n; j++) {\n            if (lst[i] == lst[j]) count++;\n            if (count > 1) return false;\n        }\n    }\n\n    // Check if sorted using SIMD\n    for (int i = 0; i < n-4; i+=4) {\n        uint32x4_t v1 = vld1q_u32((uint32_t*)&lst[i]);\n        uint32x4_t v2 = vld1q_u32((uint32_t*)&lst[i+1]);\n        \n        uint32x4_t cmp = vcleq_u32(v1, v2);\n        uint32_t mask = vgetq_lane_u32(cmp, 0) & vgetq_lane_u32(cmp, 1) & \n                       vgetq_lane_u32(cmp, 2) & vgetq_lane_u32(cmp, 3);\n                       \n        if (!mask) return false;\n    }\n    \n    // Check remaining elements\n    for (int i = n-n%4; i < n-1; i++) {\n        if (lst[i] > lst[i+1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    const int n = lst.size();\n    \n    // Check for duplicates using SIMD\n    for (int i = 0; i < n-4; i+=4) {\n        uint32x4_t v1 = vld1q_u32((uint32_t*)&lst[i]);\n        \n        // Compare each element with next 3 elements\n        for (int j = i+1; j < std::min(i+4, n); j++) {\n            uint32x4_t v2 = vdupq_n_u32(lst[j]);\n            uint32x4_t eq = vceqq_u32(v1, v2);\n            uint32_t mask = vgetq_lane_u32(eq, 0) | vgetq_lane_u32(eq, 1) | \n                           vgetq_lane_u32(eq, 2) | vgetq_lane_u32(eq, 3);\n            if (__builtin_popcount(mask) > 1) return false;\n        }\n    }\n    \n    // Check remaining elements for duplicates\n    for (int i = (n/4)*4; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (lst[i] == lst[j]) {\n                int count = 0;\n                for (int k = i; k <= j; k++) {\n                    if (lst[k] == lst[i]) count++;\n                }\n                if (count > 2) return false;\n            }\n        }\n    }\n\n    // Check if sorted using SIMD\n    for (int i = 0; i < n-4; i+=4) {\n        uint32x4_t curr = vld1q_u32((uint32_t*)&lst[i]);\n        uint32x4_t next = vld1q_u32((uint32_t*)&lst[i+1]);\n        \n        uint32x4_t cmp = vcleq_u32(curr, next);\n        uint32_t mask = vgetq_lane_u32(cmp, 0) & vgetq_lane_u32(cmp, 1) & \n                       vgetq_lane_u32(cmp, 2);\n                       \n        if (mask == 0) return false;\n    }\n    \n    // Check remaining elements\n    for (int i = (n/4)*4; i < n-1; i++) {\n        if (lst[i] > lst[i+1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    const int n = lst.size();\n    \n    // Check if sorted in ascending order using NEON\n    for (int i = 0; i < n-4; i+=4) {\n        uint32x4_t curr = vld1q_u32((uint32_t*)&lst[i]);\n        uint32x4_t next = vld1q_u32((uint32_t*)&lst[i+1]);\n        \n        uint32x4_t cmp = vcleq_u32(curr, next);\n        uint32_t mask = vgetq_lane_u32(cmp, 0) & vgetq_lane_u32(cmp, 1) & \n                        vgetq_lane_u32(cmp, 2);\n                        \n        if (!mask) return false;\n    }\n    \n    // Handle remaining elements\n    for (int i = n-n%4; i < n-1; i++) {\n        if (lst[i] > lst[i+1]) return false;\n    }\n    \n    // Check for more than 1 duplicate\n    for (int i = 0; i < n-4; i+=4) {\n        uint32x4_t curr = vld1q_u32((uint32_t*)&lst[i]);\n        uint32x4_t next = vld1q_u32((uint32_t*)&lst[i+1]);\n        uint32x4_t next2 = vld1q_u32((uint32_t*)&lst[i+2]);\n        \n        uint32x4_t eq1 = vceqq_u32(curr, next);\n        uint32x4_t eq2 = vceqq_u32(curr, next2);\n        \n        uint32_t mask = vgetq_lane_u32(eq1, 0) & vgetq_lane_u32(eq2, 0);\n        if (mask) return false;\n    }\n    \n    // Check remaining elements for duplicates\n    for (int i = n-n%4; i < n-2; i++) {\n        if (lst[i] == lst[i+1] && lst[i] == lst[i+2]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t len = lst.size();\n    size_t vec_size = len - (len % 4);\n    \n    // Check if sorted using SIMD\n    for (size_t i = 0; i < vec_size; i += 4) {\n        uint32x4_t curr = vld1q_u32((uint32_t*)&lst[i]);\n        uint32x4_t next = i + 4 < len ? vld1q_u32((uint32_t*)&lst[i + 1]) : curr;\n        \n        // Compare current elements with shifted elements\n        uint32x4_t cmp = vcgeq_u32(next, curr);\n        \n        // Check if any comparison failed\n        if (vgetq_lane_u32(cmp, 0) == 0 || \n            vgetq_lane_u32(cmp, 1) == 0 || \n            vgetq_lane_u32(cmp, 2) == 0) {\n            return false;\n        }\n        \n        // Check for duplicates by comparing equality\n        uint32x4_t eq = vceqq_u32(next, curr);\n        int dup_count = 0;\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(eq, j)) {\n                dup_count++;\n                if (dup_count > 1) return false;\n            }\n        }\n    }\n    \n    // Check remaining elements\n    for (size_t i = vec_size; i < len - 1; i++) {\n        if (lst[i] > lst[i + 1]) return false;\n        if (lst[i] == lst[i + 1]) {\n            // Check for more than one duplicate\n            if (i + 2 < len && lst[i] == lst[i + 2]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    const int n = lst.size();\n    \n    // Check for duplicates using SIMD\n    for (int i = 0; i < n-3; i += 4) {\n        uint32x4_t v1 = vld1q_u32((uint32_t*)&lst[i]);\n        \n        // Compare each element with next 3 elements\n        for (int j = i+1; j < std::min(i+4, n); j++) {\n            uint32x4_t v2 = vdupq_n_u32(lst[j]);\n            uint32x4_t eq = vceqq_u32(v1, v2);\n            uint32_t mask = vgetq_lane_u32(eq, 0) | vgetq_lane_u32(eq, 1) | \n                           vgetq_lane_u32(eq, 2) | vgetq_lane_u32(eq, 3);\n            if (__builtin_popcount(mask) > 1) return false;\n        }\n    }\n    \n    // Check remaining elements for duplicates\n    for (int i = (n/4)*4; i < n; i++) {\n        for (int j = i+1; j < n; j++) {\n            if (lst[i] == lst[j]) {\n                int count = 0;\n                for (int k = i; k <= j; k++) {\n                    if (lst[k] == lst[i]) count++;\n                }\n                if (count > 2) return false;\n            }\n        }\n    }\n\n    // Check if sorted using SIMD\n    for (int i = 0; i < n-4; i += 4) {\n        uint32x4_t curr = vld1q_u32((uint32_t*)&lst[i]);\n        uint32x4_t next = vld1q_u32((uint32_t*)&lst[i+1]);\n        \n        uint32x4_t cmp = vcleq_u32(curr, next);\n        uint32_t mask = vgetq_lane_u32(cmp, 0) & vgetq_lane_u32(cmp, 1) & \n                       vgetq_lane_u32(cmp, 2);\n                       \n        if (mask == 0) return false;\n    }\n    \n    // Check remaining elements\n    for (int i = (n/4)*4; i < n-1; i++) {\n        if (lst[i] > lst[i+1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    const int n = arr.size();\n    int sign_prod = 1;\n    int32_t sum = 0;\n    \n    // Process 4 elements at a time\n    int i = 0;\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        \n        // Get signs\n        int32x4_t zeros = vdupq_n_s32(0);\n        uint32x4_t gt_mask = vcgtq_s32(vec, zeros);\n        uint32x4_t lt_mask = vcltq_s32(vec, zeros);\n        \n        int32x4_t ones = vdupq_n_s32(1);\n        int32x4_t neg_ones = vdupq_n_s32(-1);\n        \n        int32x4_t signs = vbslq_s32(gt_mask, ones, \n                         vbslq_s32(lt_mask, neg_ones, zeros));\n        \n        // Get absolute values\n        int32x4_t abs_vec = vabsq_s32(vec);\n        \n        // Multiply signs\n        int32x4_t sign_prod_vec = signs;\n        int32_t sign_arr[4];\n        vst1q_s32(sign_arr, sign_prod_vec);\n        sign_prod *= sign_arr[0] * sign_arr[1] * sign_arr[2] * sign_arr[3];\n        \n        // Add absolute values\n        int32x2_t sum_2 = vadd_s32(vget_low_s32(abs_vec), vget_high_s32(abs_vec));\n        sum_2 = vpadd_s32(sum_2, sum_2);\n        sum += vget_lane_s32(sum_2, 0);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (arr[i] > 0) sign_prod *= 1;\n        else if (arr[i] < 0) sign_prod *= -1;\n        else sign_prod *= 0;\n        sum += std::abs(arr[i]);\n    }\n    \n    return sign_prod * sum;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    const int n = arr.size();\n    int prod_sign = 1;\n    int32_t sum = 0;\n    \n    // Process 4 elements at a time\n    int i = 0;\n    if (n >= 4) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        \n        for (; i <= n-4; i += 4) {\n            int32x4_t vec = vld1q_s32(&arr[i]);\n            \n            // Get signs\n            int32x4_t signs = vshrq_n_s32(vec, 31);\n            signs = vorrq_s32(signs, vreinterpretq_s32_u32(vcltq_s32(vec, vdupq_n_s32(0))));\n            \n            // Multiply signs\n            int32x2_t signs_low = vget_low_s32(signs);\n            int32x2_t signs_high = vget_high_s32(signs);\n            int32x2_t prod = vmul_s32(signs_low, signs_high);\n            prod_sign *= vget_lane_s32(prod, 0) * vget_lane_s32(prod, 1);\n            \n            // Add magnitudes\n            sum_vec = vaddq_s32(sum_vec, vabsq_s32(vec));\n        }\n        \n        int32x2_t sum_low = vget_low_s32(sum_vec);\n        int32x2_t sum_high = vget_high_s32(sum_vec);\n        sum_low = vadd_s32(sum_low, sum_high);\n        sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        sum += abs(arr[i]);\n        if (arr[i] < 0) prod_sign *= -1;\n        else if (arr[i] == 0) prod_sign = 0;\n    }\n    \n    return sum * prod_sign;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    const int n = arr.size();\n    int sign_prod = 1;\n    int32_t sum = 0;\n    \n    // Process 4 elements at a time\n    int i = 0;\n    if (n >= 4) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        int32x4_t sign_vec = vdupq_n_s32(1);\n        \n        for (; i <= n-4; i+=4) {\n            int32x4_t vec = vld1q_s32(&arr[i]);\n            \n            // Get absolute values\n            int32x4_t abs_vec = vabsq_s32(vec);\n            sum_vec = vaddq_s32(sum_vec, abs_vec);\n            \n            // Get signs\n            int32x4_t zero = vdupq_n_s32(0);\n            uint32x4_t gt_mask = vcgtq_s32(vec, zero);\n            uint32x4_t lt_mask = vcltq_s32(vec, zero);\n            \n            int32x4_t signs = vbslq_s32(gt_mask, vdupq_n_s32(1), \n                                       vbslq_s32(lt_mask, vdupq_n_s32(-1), zero));\n            \n            sign_vec = vmulq_s32(sign_vec, signs);\n        }\n        \n        // Horizontal sum\n        int32x2_t sum_2 = vadd_s32(vget_low_s32(sum_vec), vget_high_s32(sum_vec));\n        sum = vget_lane_s32(vpadd_s32(sum_2, sum_2), 0);\n        \n        // Multiply signs\n        int32x2_t sign_2 = vmul_s32(vget_low_s32(sign_vec), vget_high_s32(sign_vec));\n        sign_prod = vget_lane_s32(vmul_s32(sign_2, sign_2), 0);\n        if (sign_prod > 1) sign_prod = 1;\n        if (sign_prod < -1) sign_prod = -1;\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        sum += std::abs(arr[i]);\n        if (arr[i] > 0) sign_prod *= 1;\n        else if (arr[i] < 0) sign_prod *= -1;\n        else sign_prod = 0;\n    }\n    \n    return sum * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    const int n = arr.size();\n    int sign_prod = 1;\n    int32_t sum = 0;\n    \n    // Process 4 elements at a time\n    int i = 0;\n    if (n >= 4) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        \n        for (; i <= n-4; i += 4) {\n            int32x4_t vec = vld1q_s32(&arr[i]);\n            \n            // Get signs\n            uint32x4_t zero_mask = vceqq_s32(vec, vdupq_n_s32(0));\n            int32x4_t signs = vshrq_n_s32(vec, 31);\n            signs = vorrq_s32(signs, vreinterpretq_s32_u32(zero_mask));\n            signs = vsubq_s32(vdupq_n_s32(1), signs);\n            \n            // Multiply signs\n            int32x2_t signs_low = vget_low_s32(signs);\n            int32x2_t signs_high = vget_high_s32(signs);\n            signs_low = vmul_s32(signs_low, signs_high);\n            sign_prod *= vget_lane_s32(signs_low, 0) * vget_lane_s32(signs_low, 1);\n            \n            // Add magnitudes\n            sum_vec = vaddq_s32(sum_vec, vabsq_s32(vec));\n        }\n        \n        int32x2_t sum_low = vget_low_s32(sum_vec);\n        int32x2_t sum_high = vget_high_s32(sum_vec);\n        sum_low = vadd_s32(sum_low, sum_high);\n        sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (arr[i] == 0) {\n            sign_prod = 0;\n        } else {\n            sign_prod *= (arr[i] > 0) ? 1 : -1;\n        }\n        sum += abs(arr[i]);\n    }\n    \n    return sign_prod * sum;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    const int n = arr.size();\n    int prod_sign = 1;\n    int32_t sum = 0;\n    \n    // Process 4 elements at a time\n    int i = 0;\n    if (n >= 4) {\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        \n        for (; i <= n-4; i += 4) {\n            int32x4_t vec = vld1q_s32(&arr[i]);\n            \n            // Get signs\n            int32x4_t signs = vshrq_n_s32(vec, 31);\n            signs = vorrq_s32(signs, vreinterpretq_s32_u32(vcltq_s32(vec, vdupq_n_s32(0))));\n            \n            // Multiply signs\n            int32x2_t signs_low = vget_low_s32(signs);\n            int32x2_t signs_high = vget_high_s32(signs);\n            int32x2_t prod = vmul_s32(signs_low, signs_high);\n            prod_sign *= vget_lane_s32(prod, 0) * vget_lane_s32(prod, 1);\n            \n            // Get absolute values and add\n            vec = vabsq_s32(vec);\n            sum_vec = vaddq_s32(sum_vec, vec);\n        }\n        \n        // Reduce sum vector\n        int32x2_t sum_low = vget_low_s32(sum_vec);\n        int32x2_t sum_high = vget_high_s32(sum_vec);\n        sum_low = vadd_s32(sum_low, sum_high);\n        sum += vget_lane_s32(sum_low, 0) + vget_lane_s32(sum_low, 1);\n    }\n    \n    // Process remaining elements\n    for (; i < n; i++) {\n        if (arr[i] < 0) prod_sign *= -1;\n        else if (arr[i] == 0) prod_sign = 0;\n        sum += abs(arr[i]);\n    }\n    \n    return sum * prod_sign;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = INT_MAX;\n        int32x4_t minVec = vdupq_n_s32(INT_MAX);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j + 4 <= n; j += 4) {\n                int32x4_t currVec = vld1q_s32(&grid[i][j]);\n                minVec = vminq_s32(minVec, currVec);\n            }\n            \n            // Handle remaining elements\n            for (int j = (n/4)*4; j < n; j++) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        \n        // Find minimum across vector lanes\n        int32_t minArray[4];\n        vst1q_s32(minArray, minVec);\n        for (int i = 0; i < 4; i++) {\n            minVal = std::min(minVal, minArray[i]);\n        }\n        \n        result[0] = minVal;\n        return result;\n    }\n    \n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<int> dx = {-1, 0, 1, 0};\n    std::vector<int> dy = {0, 1, 0, -1};\n    std::vector<int> bestPath;\n    int minPathVal = INT_MAX;\n    \n    std::function<void(int,int,int,std::vector<int>&)> dfs = \n        [&](int x, int y, int len, std::vector<int>& path) {\n        path.push_back(grid[x][y]);\n        \n        if (len == k) {\n            if (path < bestPath || bestPath.empty()) {\n                bestPath = path;\n            }\n            path.pop_back();\n            return;\n        }\n        \n        int32x4_t currVal = vdupq_n_s32(grid[x][y]);\n        for (int d = 0; d + 4 <= 4; d += 4) {\n            int32x4_t newX = {x + dx[d], x + dx[d+1], x + dx[d+2], x + dx[d+3]};\n            int32x4_t newY = {y + dy[d], y + dy[d+1], y + dy[d+2], y + dy[d+3]};\n            \n            uint32x4_t validX = vcgeq_s32(newX, vdupq_n_s32(0));\n            validX = vandq_u32(validX, vcltq_s32(newX, vdupq_n_s32(n)));\n            \n            uint32x4_t validY = vcgeq_s32(newY, vdupq_n_s32(0));\n            validY = vandq_u32(validY, vcltq_s32(newY, vdupq_n_s32(n)));\n            \n            uint32x4_t valid = vandq_u32(validX, validY);\n            \n            uint32_t validMask = vgetq_lane_u32(valid, 0) | \n                                (vgetq_lane_u32(valid, 1) << 1) |\n                                (vgetq_lane_u32(valid, 2) << 2) |\n                                (vgetq_lane_u32(valid, 3) << 3);\n                                \n            while (validMask) {\n                int idx = __builtin_ctz(validMask);\n                int nx = x + dx[d + idx];\n                int ny = y + dy[d + idx];\n                \n                if (dp[nx][ny] > len + 1) {\n                    dp[nx][ny] = len + 1;\n                    dfs(nx, ny, len + 1, path);\n                }\n                \n                validMask &= ~(1 << idx);\n            }\n        }\n        \n        path.pop_back();\n    };\n    \n    std::vector<int> path;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = 1;\n            dfs(i, j, 1, path);\n        }\n    }\n    \n    return bestPath;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result;\n    if (k == 1) {\n        int minVal = INT_MAX;\n        int32x4_t minVec = vdupq_n_s32(INT_MAX);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n-3; j+=4) {\n                int32x4_t gridVec = vld1q_s32((const int32_t*)&grid[i][j]);\n                minVec = vminq_s32(minVec, gridVec);\n            }\n            \n            // Handle remaining elements\n            for (int j = n-n%4; j < n; j++) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        \n        // Find minimum across vector lanes\n        int32_t minArray[4];\n        vst1q_s32(minArray, minVec);\n        for (int i = 0; i < 4; i++) {\n            minVal = std::min(minVal, minArray[i]);\n        }\n        \n        result.push_back(minVal);\n        return result;\n    }\n\n    std::vector<std::vector<int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    std::vector<int> curr_path;\n    std::vector<int> min_path(k, INT_MAX);\n    \n    auto isValid = [&](int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    };\n    \n    std::function<void(int,int,int)> dfs = [&](int x, int y, int len) {\n        curr_path.push_back(grid[x][y]);\n        \n        if (len == k) {\n            if (curr_path < min_path) {\n                min_path = curr_path;\n            }\n        } else {\n            for (const auto& dir : dirs) {\n                int nx = x + dir[0];\n                int ny = y + dir[1];\n                if (isValid(nx, ny)) {\n                    dfs(nx, ny, len + 1);\n                }\n            }\n        }\n        \n        curr_path.pop_back();\n    };\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dfs(i, j, 1);\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = INT_MAX;\n        int32x4_t minVec = vdupq_n_s32(INT_MAX);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j + 4 <= n; j += 4) {\n                int32x4_t currVec = vld1q_s32(&grid[i][j]);\n                minVec = vminq_s32(minVec, currVec);\n            }\n            \n            // Handle remaining elements\n            for (int j = (n/4)*4; j < n; j++) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        \n        // Find minimum across vector lanes\n        int32_t minArray[4];\n        vst1q_s32(minArray, minVec);\n        for (int i = 0; i < 4; i++) {\n            minVal = std::min(minVal, minArray[i]);\n        }\n        \n        result[0] = minVal;\n        return result;\n    }\n\n    std::vector<std::vector<int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    std::vector<int> bestPath(k, INT_MAX);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::vector<int> currPath;\n            std::function<void(int,int,int)> dfs = [&](int row, int col, int len) {\n                currPath.push_back(grid[row][col]);\n                \n                if (len == k) {\n                    if (currPath < bestPath) {\n                        bestPath = currPath;\n                    }\n                } else {\n                    for (auto& dir : dirs) {\n                        int newRow = row + dir[0];\n                        int newCol = col + dir[1];\n                        if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                            dfs(newRow, newCol, len + 1);\n                        }\n                    }\n                }\n                currPath.pop_back();\n            };\n            \n            dfs(i, j, 1);\n        }\n    }\n    \n    return bestPath;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = INT_MAX;\n        int rows = (n + 3) / 4 * 4;\n        \n        for (int i = 0; i < n; i++) {\n            int j = 0;\n            for (; j + 4 <= n; j += 4) {\n                int32x4_t v = vld1q_s32((const int32_t*)&grid[i][j]);\n                int32x4_t minv = vminvq_s32(v);\n                minVal = std::min(minVal, vgetq_lane_s32(minv, 0));\n            }\n            for (; j < n; j++) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        result[0] = minVal;\n        return result;\n    }\n\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<std::vector<std::pair<int,int>>> prev(n, std::vector<std::pair<int,int>>(n));\n    \n    int minRow = 0, minCol = 0;\n    int32x4_t vmin = vdupq_n_s32(INT_MAX);\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            if (dp[i][j] < vgetq_lane_s32(vmin, 0)) {\n                minRow = i;\n                minCol = j;\n                vmin = vdupq_n_s32(dp[i][j]);\n            }\n        }\n    }\n\n    result[0] = grid[minRow][minCol];\n    \n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n    \n    for (int step = 1; step < k; step++) {\n        int nextRow = -1, nextCol = -1;\n        int32x4_t currMin = vdupq_n_s32(INT_MAX);\n        \n        for (int d = 0; d < 4; d++) {\n            int newRow = minRow + dx[d];\n            int newCol = minCol + dy[d];\n            \n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                int32x4_t val = vdupq_n_s32(grid[newRow][newCol]);\n                if (vgetq_lane_s32(val, 0) < vgetq_lane_s32(currMin, 0)) {\n                    nextRow = newRow;\n                    nextCol = newCol;\n                    currMin = val;\n                }\n            }\n        }\n        \n        result[step] = grid[nextRow][nextCol];\n        minRow = nextRow;\n        minCol = nextCol;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = INT_MAX;\n        int32x4_t minVec = vdupq_n_s32(INT_MAX);\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j + 4 <= n; j += 4) {\n                int32x4_t currVec = vld1q_s32(&grid[i][j]);\n                minVec = vminq_s32(minVec, currVec);\n            }\n            \n            // Handle remaining elements\n            for (int j = (n/4)*4; j < n; j++) {\n                minVal = std::min(minVal, grid[i][j]);\n            }\n        }\n        \n        // Find minimum across vector lanes\n        int32_t minArray[4];\n        vst1q_s32(minArray, minVec);\n        for (int i = 0; i < 4; i++) {\n            minVal = std::min(minVal, minArray[i]);\n        }\n        \n        result[0] = minVal;\n        return result;\n    }\n    \n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<int> curr_path;\n    std::pair<int,int> start_pos;\n    int min_start = INT_MAX;\n    \n    // Find starting position with minimum value\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < min_start) {\n                min_start = grid[i][j];\n                start_pos = {i,j};\n            }\n        }\n    }\n    \n    std::function<void(int,int,int)> dfs = [&](int x, int y, int len) {\n        if (len == k) {\n            if (curr_path < result) {\n                result = curr_path;\n            }\n            return;\n        }\n        \n        const int dx[] = {-1, 0, 1, 0};\n        const int dy[] = {0, 1, 0, -1};\n        \n        int32x4_t curr_val = vdupq_n_s32(grid[x][y]);\n        int32x4_t next_x = {x+dx[0], x+dx[1], x+dx[2], x+dx[3]};\n        int32x4_t next_y = {y+dy[0], y+dy[1], y+dy[2], y+dy[3]};\n        \n        uint32x4_t valid_x = vcgeq_s32(next_x, vdupq_n_s32(0));\n        valid_x = vandq_u32(valid_x, vcltq_s32(next_x, vdupq_n_s32(n)));\n        \n        uint32x4_t valid_y = vcgeq_s32(next_y, vdupq_n_s32(0));\n        valid_y = vandq_u32(valid_y, vcltq_s32(next_y, vdupq_n_s32(n)));\n        \n        uint32x4_t valid = vandq_u32(valid_x, valid_y);\n        \n        int valid_moves[4];\n        vst1q_u32((uint32_t*)valid_moves, valid);\n        \n        for (int i = 0; i < 4; i++) {\n            if (valid_moves[i]) {\n                int nx = x + dx[i];\n                int ny = y + dy[i];\n                curr_path.push_back(grid[nx][ny]);\n                dfs(nx, ny, len+1);\n                curr_path.pop_back();\n            }\n        }\n    };\n    \n    curr_path.push_back(grid[start_pos.first][start_pos.second]);\n    dfs(start_pos.first, start_pos.second, 1);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Load digits into NEON registers\n    uint8x16_t vec_digits;\n    if (len <= 16) {\n        vec_digits = vld1q_u8((uint8_t*)digits);\n    } else {\n        return 0; // Handle larger numbers\n    }\n    \n    // Convert ASCII to actual digits\n    vec_digits = vsubq_u8(vec_digits, vdupq_n_u8('0'));\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vandq_u8(vec_digits, vdupq_n_u8(1));\n    odd_mask = vceqq_u8(odd_mask, vdupq_n_u8(1));\n    \n    // Zero out even digits\n    vec_digits = vandq_u8(vec_digits, odd_mask);\n    \n    // Multiply odd digits\n    uint64_t result = 1;\n    uint8_t* ptr = (uint8_t*)&vec_digits;\n    bool found_odd = false;\n    \n    for(int i = 0; i < len; i++) {\n        if(ptr[i] > 0) {\n            result *= ptr[i];\n            found_odd = true;\n        }\n    }\n    \n    return found_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = snprintf(digits, sizeof(digits), \"%lu\", n);\n    \n    // Load digits into NEON registers\n    uint8x16_t vec_digits = vld1q_u8((uint8_t*)digits);\n    \n    // Convert ASCII to actual digit values\n    vec_digits = vsubq_u8(vec_digits, vdupq_n_u8('0'));\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vandq_u8(vec_digits, vdupq_n_u8(1));\n    odd_mask = vceqq_u8(odd_mask, vdupq_n_u8(1));\n    \n    // Zero out even digits\n    vec_digits = vandq_u8(vec_digits, odd_mask);\n    \n    // Multiply odd digits\n    uint8x16_t prod = vec_digits;\n    uint8x8_t prod_low = vget_low_u8(prod);\n    uint8x8_t prod_high = vget_high_u8(prod);\n    \n    // Multiply elements within each half\n    while (vget_lane_u8(prod_low, 1) != 0 || vget_lane_u8(prod_high, 1) != 0) {\n        prod_low = vmul_u8(prod_low, vext_u8(prod_low, prod_low, 1));\n        prod_high = vmul_u8(prod_high, vext_u8(prod_high, prod_high, 1));\n    }\n    \n    uint64_t result = vget_lane_u8(prod_low, 0);\n    if (result == 0) {\n        result = vget_lane_u8(prod_high, 0);\n    }\n    \n    return result == 0 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    uint8_t digits[16] = {0};\n    int len = 0;\n    \n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n    \n    uint8x16_t vec = vld1q_u8(digits);\n    uint8x16_t odd_mask = vdupq_n_u8(1);\n    uint8x16_t zero = vdupq_n_u8(0);\n    \n    uint8x16_t is_odd = vandq_u8(vec, odd_mask);\n    uint8x16_t odd_digits = vbslq_u8(vceqq_u8(is_odd, odd_mask), vec, zero);\n    \n    uint64_t product = 1;\n    uint8_t* ptr = (uint8_t*)&odd_digits;\n    \n    bool has_odd = false;\n    for(int i = 0; i < len; i++) {\n        if(ptr[i] > 0) {\n            product *= ptr[i];\n            has_odd = true;\n        }\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    uint8_t digits[16] = {0};\n    int len = 0;\n    \n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n    \n    uint8x16_t vec = vld1q_u8(digits);\n    uint8x16_t odd_mask = vdupq_n_u8(1);\n    uint8x16_t zero = vdupq_n_u8(0);\n    \n    uint8x16_t is_odd = vandq_u8(vec, odd_mask);\n    uint8x16_t odd_digits = vbslq_u8(vceqq_u8(is_odd, odd_mask), vec, zero);\n    \n    uint64_t result = 1;\n    uint8_t* ptr = (uint8_t*)&odd_digits;\n    \n    bool has_odd = false;\n    for(int i = 0; i < len; i++) {\n        if(ptr[i] > 0) {\n            result *= ptr[i];\n            has_odd = true;\n        }\n    }\n    \n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = snprintf(digits, sizeof(digits), \"%lu\", n);\n    \n    // Load digits into NEON registers\n    uint8x16_t vec_digits = vld1q_u8((uint8_t*)digits);\n    \n    // Convert ASCII to actual digit values\n    vec_digits = vsubq_u8(vec_digits, vdupq_n_u8('0'));\n    \n    // Create mask for odd digits\n    uint8x16_t odd_mask = vandq_u8(vec_digits, vdupq_n_u8(1));\n    \n    // Zero out even digits\n    vec_digits = vmulq_u8(vec_digits, odd_mask);\n    \n    // Initialize product\n    uint64_t product = 1;\n    uint8_t* digit_ptr = (uint8_t*)&vec_digits;\n    \n    // Multiply odd digits\n    for(int i = 0; i < len; i++) {\n        if(digit_ptr[i] != 0) {\n            product *= digit_ptr[i];\n        }\n    }\n    \n    return (product == 1) ? 0 : product;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t vec_size = size - (size % 4);\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        float32x4_t sum_vec = vdupq_n_f32(0);\n        \n        for (size_t i = 0; i < vec_size; i += 4) {\n            float32x4_t v = vld1q_f32(&lst[i]);\n            // Ceiling\n            float32x4_t ceil_v = vceilq_f32(v);\n            // Square\n            sum_vec = vmlaq_f32(sum_vec, ceil_v, ceil_v);\n        }\n        \n        float32x2_t sum_2 = vadd_f32(vget_high_f32(sum_vec), vget_low_f32(sum_vec));\n        sum_2 = vpadd_f32(sum_2, sum_2);\n        sum = (uint64_t)vget_lane_f32(sum_2, 0);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        float ceil_val = ceilf(lst[i]);\n        sum += (uint64_t)(ceil_val * ceil_val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t vec_size = size - (size % 4);\n    uint64_t sum = 0;\n\n    float32x4_t sum_vec = vdupq_n_f32(0);\n    \n    for(size_t i = 0; i < vec_size; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        \n        // Ceiling\n        float32x4_t ceil_v = vrndpq_f32(v);\n        \n        // Square\n        float32x4_t square = vmulq_f32(ceil_v, ceil_v);\n        \n        // Accumulate\n        sum_vec = vaddq_f32(sum_vec, square);\n    }\n    \n    // Horizontal sum\n    float32x2_t sum_2 = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n    sum_2 = vpadd_f32(sum_2, sum_2);\n    sum = (uint64_t)vget_lane_f32(sum_2, 0);\n\n    // Handle remaining elements\n    for(size_t i = vec_size; i < size; i++) {\n        float ceil_val = ceilf(lst[i]);\n        sum += (uint64_t)(ceil_val * ceil_val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t vec_size = size - (size % 4);\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        float32x4_t sum_vec = vdupq_n_f32(0);\n        \n        for (size_t i = 0; i < vec_size; i += 4) {\n            float32x4_t v = vld1q_f32(&lst[i]);\n            // Ceiling\n            float32x4_t ceil_v = vceilq_f32(v);\n            // Square\n            sum_vec = vmlaq_f32(sum_vec, ceil_v, ceil_v);\n        }\n        \n        float32x2_t sum_2 = vadd_f32(vget_high_f32(sum_vec), vget_low_f32(sum_vec));\n        sum_2 = vpadd_f32(sum_2, sum_2);\n        sum = (uint64_t)vget_lane_f32(sum_2, 0);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        float ceil_val = ceilf(lst[i]);\n        sum += (uint64_t)(ceil_val * ceil_val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    int size = lst.size();\n    int step = 4;\n    int i = 0;\n\n    if (size >= step) {\n        float32x4_t sum = vdupq_n_f32(0);\n        \n        for (; i <= size - step; i += step) {\n            float32x4_t vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vceilq_f32(vec);\n            float32x4_t square = vmulq_f32(ceil_vec, ceil_vec);\n            sum = vaddq_f32(sum, square);\n        }\n        \n        float32x4_t tmp = sum;\n        result = vgetq_lane_f32(tmp, 0) + vgetq_lane_f32(tmp, 1) + \n                 vgetq_lane_f32(tmp, 2) + vgetq_lane_f32(tmp, 3);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        float ceil_val = ceilf(lst[i]);\n        result += ceil_val * ceil_val;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t vec_size = size - (size % 4);\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        float32x4_t sum_vec = vdupq_n_f32(0);\n        \n        for (size_t i = 0; i < vec_size; i += 4) {\n            float32x4_t v = vld1q_f32(&lst[i]);\n            // Ceiling\n            float32x4_t ceil_v = vrndpq_f32(v);\n            // Square\n            float32x4_t square = vmulq_f32(ceil_v, ceil_v);\n            // Accumulate\n            sum_vec = vaddq_f32(sum_vec, square);\n        }\n        \n        float32x2_t sum_2 = vadd_f32(vget_low_f32(sum_vec), vget_high_f32(sum_vec));\n        float32x2_t sum_1 = vpadd_f32(sum_2, sum_2);\n        sum = (uint64_t)vget_lane_f32(sum_1, 0);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size; i < size; i++) {\n        float ceil_val = ceilf(lst[i]);\n        sum += (uint64_t)(ceil_val * ceil_val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int result = -1;\n    \n    for (int i = 0; i <= n-4; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        uint32x4_t comp = vcgeq_s32(next, curr);\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(comp), 0) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 1) << 1) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 2) << 2) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 3) << 3);\n        \n        if (~mask & 0xF) {\n            int idx = i + __builtin_ctz(~mask);\n            result = std::max(result, idx + 1);\n        }\n    }\n    \n    for (int i = ((n-1)/4)*4; i < n-1; i++) {\n        if (arr[i+1] < arr[i]) {\n            result = std::max(result, i + 1);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int i;\n    \n    for (i = 0; i + 4 <= n - 1; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        uint32x4_t comp = vcgeq_s32(next, curr);\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(comp), 0) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 1) << 1) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 2) << 2) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 3) << 3);\n                       \n        if (mask != 0xF) {\n            for (int j = 0; j < 4; j++) {\n                if (arr[i+j+1] < arr[i+j]) {\n                    return i+j+1;\n                }\n            }\n        }\n    }\n    \n    for (; i < n-1; i++) {\n        if (arr[i+1] < arr[i]) {\n            return i+1;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int result = -1;\n    \n    for (int i = 0; i <= n-4; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        uint32x4_t comp = vcgeq_s32(next, curr);\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(comp), 0) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 1) << 1) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 2) << 2) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 3) << 3);\n        \n        if (mask != 0xF) {\n            for (int j = 0; j < 4; j++) {\n                if (!(mask & (1 << j))) {\n                    result = i + j + 1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    \n    if (result == -1) {\n        for (int i = ((n-1)/4)*4; i < n-1; i++) {\n            if (arr[i+1] < arr[i]) {\n                return i+1;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    int n = arr.size();\n    if (n <= 1) return -1;\n\n    int result = -1;\n    int i;\n    \n    for (i = 0; i <= n-4; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        uint32x4_t comp = vcgeq_s32(next, curr);\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(comp), 0) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 1) << 1) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 2) << 2) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 3) << 3);\n        \n        if (mask != 0xF) {\n            for (int j = 0; j < 4; j++) {\n                if (!(mask & (1 << j))) {\n                    result = i + j + 1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    \n    if (result == -1) {\n        for (; i < n-1; i++) {\n            if (arr[i+1] < arr[i]) {\n                result = i+1;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int result = -1;\n    \n    for (int i = 0; i < n-4; i += 4) {\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        \n        uint32x4_t comp = vcgeq_s32(next, curr);\n        uint32_t mask = vgetq_lane_u32(vreinterpretq_u32_s32(comp), 0) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 1) << 1) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 2) << 2) |\n                       (vgetq_lane_u32(vreinterpretq_u32_s32(comp), 3) << 3);\n        \n        if (mask != 0xF) {\n            for (int j = 0; j < 4; j++) {\n                if (!(mask & (1 << j))) {\n                    result = i + j + 1;\n                    break;\n                }\n            }\n            break;\n        }\n    }\n    \n    if (result == -1) {\n        for (int i = ((n-1)/4)*4; i < n-1; i++) {\n            if (arr[i+1] < arr[i]) {\n                return i+1;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n    \n    // Process 4 elements at a time\n    for (size_t i = 0; i <= lst.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create masks for negative and positive numbers\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n        \n        // Update max negative using mask\n        int32x4_t neg_vals = vandq_s32(vreinterpretq_s32_u32(neg_mask), vec);\n        max_neg = vmaxq_s32(max_neg, neg_vals);\n        \n        // Update min positive using mask\n        int32x4_t pos_vals = vorrq_s32(vandq_s32(vreinterpretq_s32_u32(pos_mask), vec),\n                                      vandq_s32(vmvnq_s32(vreinterpretq_s32_u32(pos_mask)), \n                                              vdupq_n_s32(INT32_MAX)));\n        min_pos = vminq_s32(min_pos, pos_vals);\n    }\n    \n    // Process remaining elements\n    int max_neg_val = 0;\n    int min_pos_val = INT32_MAX;\n    \n    // Reduce vector results\n    int32_t neg_arr[4], pos_arr[4];\n    vst1q_s32(neg_arr, max_neg);\n    vst1q_s32(pos_arr, min_pos);\n    \n    for (int i = 0; i < 4; i++) {\n        if (neg_arr[i] < 0) max_neg_val = std::max(max_neg_val, neg_arr[i]);\n        if (pos_arr[i] > 0) min_pos_val = std::min(min_pos_val, pos_arr[i]);\n    }\n    \n    // Process remaining elements sequentially\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size(); i++) {\n        if (lst[i] < 0) max_neg_val = std::max(max_neg_val, lst[i]);\n        else if (lst[i] > 0) min_pos_val = std::min(min_pos_val, lst[i]);\n    }\n    \n    return {max_neg_val, min_pos_val == INT32_MAX ? 0 : min_pos_val};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(INT_MAX);\n    \n    for (size_t i = 0; i < lst.size() - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create masks for negative and positive numbers\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n        \n        // Update max negative using mask\n        int32x4_t neg_vals = vandq_s32(vreinterpretq_s32_u32(neg_mask), vec);\n        max_neg = vmaxq_s32(max_neg, neg_vals);\n        \n        // Update min positive using mask\n        int32x4_t pos_vals = vorrq_s32(vreinterpretq_s32_u32(pos_mask), vdupq_n_s32(INT_MAX));\n        pos_vals = vandq_s32(pos_vals, vec);\n        min_pos = vminq_s32(min_pos, pos_vals);\n    }\n\n    // Handle remaining elements\n    int max_neg_val = 0;\n    int min_pos_val = INT_MAX;\n    \n    // Extract max negative from SIMD vector\n    int32_t neg_arr[4];\n    vst1q_s32(neg_arr, max_neg);\n    for (int i = 0; i < 4; i++) {\n        if (neg_arr[i] < 0) {\n            max_neg_val = std::max(max_neg_val, neg_arr[i]);\n        }\n    }\n    \n    // Extract min positive from SIMD vector\n    int32_t pos_arr[4];\n    vst1q_s32(pos_arr, min_pos);\n    for (int i = 0; i < 4; i++) {\n        if (pos_arr[i] > 0) {\n            min_pos_val = std::min(min_pos_val, pos_arr[i]);\n        }\n    }\n    \n    // Process remaining elements\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            max_neg_val = std::max(max_neg_val, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_val = std::min(min_pos_val, lst[i]);\n        }\n    }\n    \n    return {max_neg_val, min_pos_val == INT_MAX ? 0 : min_pos_val};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(INT_MAX);\n    \n    // Process 4 elements at a time\n    for (size_t i = 0; i <= lst.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create masks for negative and positive numbers\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n        \n        // Update max negative using mask\n        int32x4_t neg_vals = vandq_s32(vreinterpretq_s32_u32(neg_mask), vec);\n        max_neg = vmaxq_s32(max_neg, neg_vals);\n        \n        // Update min positive using mask\n        int32x4_t pos_vals = vorrq_s32(vreinterpretq_s32_u32(pos_mask), vdupq_n_s32(INT_MAX));\n        pos_vals = vandq_s32(pos_vals, vec);\n        min_pos = vminq_s32(min_pos, pos_vals);\n    }\n    \n    // Process remaining elements\n    int max_neg_val = 0;\n    int min_pos_val = INT_MAX;\n    \n    // Reduce vector results\n    int32_t neg_arr[4], pos_arr[4];\n    vst1q_s32(neg_arr, max_neg);\n    vst1q_s32(pos_arr, min_pos);\n    \n    for (int i = 0; i < 4; i++) {\n        if (neg_arr[i] < 0) {\n            max_neg_val = std::max(max_neg_val, neg_arr[i]);\n        }\n        if (pos_arr[i] > 0) {\n            min_pos_val = std::min(min_pos_val, pos_arr[i]);\n        }\n    }\n    \n    // Process remaining elements sequentially\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            max_neg_val = std::max(max_neg_val, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_val = std::min(min_pos_val, lst[i]);\n        }\n    }\n    \n    return {max_neg_val, min_pos_val == INT_MAX ? 0 : min_pos_val};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(INT_MAX);\n    \n    for (size_t i = 0; i < lst.size() - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create masks for negative and positive numbers\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n        \n        // Update max negative using mask\n        int32x4_t neg_vals = vandq_s32(vreinterpretq_s32_u32(neg_mask), vec);\n        max_neg = vmaxq_s32(max_neg, neg_vals);\n        \n        // Update min positive using mask\n        int32x4_t pos_vals = vandq_s32(vreinterpretq_s32_u32(pos_mask), vec);\n        min_pos = vminq_s32(vbslq_s32(vceqq_s32(pos_vals, vdupq_n_s32(0)), min_pos, pos_vals));\n    }\n\n    // Process remaining elements\n    int max_neg_val = 0;\n    int min_pos_val = INT_MAX;\n    \n    // Reduce vector to scalar\n    int32_t neg_arr[4];\n    int32_t pos_arr[4];\n    vst1q_s32(neg_arr, max_neg);\n    vst1q_s32(pos_arr, min_pos);\n    \n    for (int i = 0; i < 4; i++) {\n        if (neg_arr[i] < 0) max_neg_val = std::max(max_neg_val, neg_arr[i]);\n        if (pos_arr[i] > 0) min_pos_val = std::min(min_pos_val, pos_arr[i]);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size(); i++) {\n        if (lst[i] < 0) max_neg_val = std::max(max_neg_val, lst[i]);\n        if (lst[i] > 0) min_pos_val = std::min(min_pos_val, lst[i]);\n    }\n    \n    if (min_pos_val == INT_MAX) min_pos_val = 0;\n    \n    return {max_neg_val, min_pos_val};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t max_neg = vdupq_n_s32(0);\n    int32x4_t min_pos = vdupq_n_s32(INT32_MAX);\n    \n    // Process 4 elements at a time\n    for (size_t i = 0; i <= lst.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        \n        // Create masks for negative and positive numbers\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        uint32x4_t pos_mask = vcgtq_s32(vec, vdupq_n_s32(0));\n        \n        // Update max negative using mask\n        int32x4_t neg_vals = vandq_s32(vreinterpretq_s32_u32(neg_mask), vec);\n        max_neg = vmaxq_s32(max_neg, neg_vals);\n        \n        // Update min positive using mask\n        int32x4_t pos_vals = vorrq_s32(vreinterpretq_s32_u32(pos_mask), \n                                      vdupq_n_s32(INT32_MAX));\n        pos_vals = vandq_s32(vreinterpretq_s32_u32(pos_mask), vminq_s32(vec, pos_vals));\n        min_pos = vminq_s32(min_pos, pos_vals);\n    }\n    \n    // Extract results\n    int max_neg_val = 0;\n    int min_pos_val = INT32_MAX;\n    \n    int32_t neg_arr[4];\n    int32_t pos_arr[4];\n    vst1q_s32(neg_arr, max_neg);\n    vst1q_s32(pos_arr, min_pos);\n    \n    // Find max negative and min positive from SIMD results\n    for (int i = 0; i < 4; i++) {\n        if (neg_arr[i] < 0) {\n            max_neg_val = std::max(max_neg_val, neg_arr[i]);\n        }\n        if (pos_arr[i] > 0 && pos_arr[i] != INT32_MAX) {\n            min_pos_val = std::min(min_pos_val, pos_arr[i]);\n        }\n    }\n    \n    // Process remaining elements\n    for (size_t i = (lst.size() / 4) * 4; i < lst.size(); i++) {\n        if (lst[i] < 0) {\n            max_neg_val = std::max(max_neg_val, lst[i]);\n        } else if (lst[i] > 0) {\n            min_pos_val = std::min(min_pos_val, lst[i]);\n        }\n    }\n    \n    return {max_neg_val, min_pos_val == INT32_MAX ? 0 : min_pos_val};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t result = 1;\n    uint64x2_t acc = vdupq_n_u64(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64x2_t fact_vec = vdupq_n_u64(1);\n        \n        for (uint64_t j = 1; j <= i; j += 2) {\n            uint64x2_t mul = {j, (j+1) <= i ? (j+1) : 1};\n            fact_vec = vmulq_u64(fact_vec, mul);\n        }\n        \n        factorial = vgetq_lane_u64(fact_vec, 0) * vgetq_lane_u64(fact_vec, 1);\n        acc = vmulq_n_u64(acc, factorial);\n        result = vgetq_lane_u64(acc, 0) * vgetq_lane_u64(acc, 1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t result = 1;\n    uint64x2_t vec_result = vdupq_n_u64(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64x2_t vec_factorial = vdupq_n_u64(1);\n        \n        for (uint64_t j = 2; j <= i; j += 2) {\n            uint64x2_t vec_nums;\n            if (j + 1 <= i) {\n                vec_nums = vcombine_u64(vcreate_u64(j), vcreate_u64(j + 1));\n            } else {\n                vec_nums = vcombine_u64(vcreate_u64(j), vcreate_u64(1));\n            }\n            vec_factorial = vmulq_u64(vec_factorial, vec_nums);\n        }\n        \n        uint64x1_t low = vget_low_u64(vec_factorial);\n        uint64x1_t high = vget_high_u64(vec_factorial);\n        factorial = vget_lane_u64(low, 0) * vget_lane_u64(high, 0);\n        \n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t result = 1;\n    uint64x2_t acc = vdupq_n_u64(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64x2_t curr = vdupq_n_u64(1);\n        \n        for (uint64_t j = 1; j <= i; j++) {\n            uint64x2_t j_vec = vdupq_n_u64(j);\n            curr = vmulq_u64(curr, j_vec);\n        }\n        \n        acc = vmulq_u64(acc, curr);\n    }\n    \n    uint64_t temp[2];\n    vst1q_u64(temp, acc);\n    result = temp[0] * temp[1];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t result = 1;\n    uint64x2_t vec_result = vdupq_n_u64(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64x2_t vec_factorial = vdupq_n_u64(1);\n        \n        for (uint64_t j = 2; j <= i; j += 2) {\n            uint64x2_t vec_multiplier;\n            if (j + 1 <= i) {\n                vec_multiplier = vcombine_u64(vcreate_u64(j), vcreate_u64(j + 1));\n            } else {\n                vec_multiplier = vcombine_u64(vcreate_u64(j), vcreate_u64(1));\n            }\n            vec_factorial = vmulq_u64(vec_factorial, vec_multiplier);\n        }\n        \n        uint64x1_t low = vget_low_u64(vec_factorial);\n        uint64x1_t high = vget_high_u64(vec_factorial);\n        factorial = vget_lane_u64(low, 0) * vget_lane_u64(high, 0);\n        \n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t result = 1;\n    uint64x2_t acc = vdupq_n_u64(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64x2_t fact_vec = vdupq_n_u64(1);\n        \n        for (uint64_t j = 1; j <= i; j += 2) {\n            uint64x2_t mul = {j, (j + 1) <= i ? (j + 1) : 1};\n            fact_vec = vmulq_u64(fact_vec, mul);\n        }\n        \n        factorial = vgetq_lane_u64(fact_vec, 0) * vgetq_lane_u64(fact_vec, 1);\n        acc = vmulq_n_u64(acc, factorial);\n    }\n    \n    result = vgetq_lane_u64(acc, 0) * vgetq_lane_u64(acc, 1);\n    return result;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n\n    int sum = 0;\n    int i = 0;\n    const int step = 4;\n\n    // Process 4 elements at a time using NEON\n    for (; i + step <= lst.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t idx = {i, i+1, i+2, i+3};\n        \n        // Create masks for multiples of 3 and 4\n        int32x4_t mod3 = vdupq_n_s32(3);\n        int32x4_t mod4 = vdupq_n_s32(4);\n        uint32x4_t mask3 = vceqq_s32(vshlq_n_s32(vdivq_s32(idx, mod3), 0), vdivq_s32(idx, mod3));\n        uint32x4_t mask4 = vceqq_s32(vshlq_n_s32(vdivq_s32(idx, mod4), 0), vdivq_s32(idx, mod4));\n        \n        // Square elements at multiples of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        int32x4_t result = vbslq_s32(mask3, squared, vec);\n        \n        // Cube elements at multiples of 4 (not multiples of 3)\n        int32x4_t cubed = vmulq_s32(squared, vec);\n        mask4 = vandq_u32(mask4, vmvnq_u32(mask3));\n        result = vbslq_s32(mask4, cubed, result);\n        \n        // Add to sum\n        sum += vgetq_lane_s32(result, 0);\n        sum += vgetq_lane_s32(result, 1);\n        sum += vgetq_lane_s32(result, 2);\n        sum += vgetq_lane_s32(result, 3);\n    }\n\n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time\n    for (; i + 3 < lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i+1, i+2, i+3};\n        \n        // Create masks for multiples of 3 and 4\n        int32x4_t mod3 = vdupq_n_s32(3);\n        int32x4_t mod4 = vdupq_n_s32(4);\n        uint32x4_t mask3 = vceqq_s32(vshlq_n_s32(vdivq_s32(indices, mod3), 2), indices);\n        uint32x4_t mask4 = vceqq_s32(vshlq_n_s32(vdivq_s32(indices, mod4), 2), indices);\n        \n        // Square elements at multiples of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask3, squared, vec);\n        \n        // Cube elements at multiples of 4 (not multiples of 3)\n        int32x4_t cubed = vmulq_s32(squared, vec);\n        mask4 = vandq_u32(mask4, vmvnq_u32(mask3));\n        vec = vbslq_s32(mask4, cubed, vec);\n        \n        // Add to sum\n        sum += vgetq_lane_s32(vec, 0) + vgetq_lane_s32(vec, 1) + \n               vgetq_lane_s32(vec, 2) + vgetq_lane_s32(vec, 3);\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    const int step = 4;\n    \n    // Process 4 elements at a time using NEON\n    for (; i + step <= lst.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t idx = {i, i+1, i+2, i+3};\n        \n        // Create masks for multiples of 3 and 4\n        int32x4_t mod3 = vdupq_n_s32(3);\n        int32x4_t mod4 = vdupq_n_s32(4);\n        uint32x4_t mask3 = vceqq_s32(vshlq_n_s32(vdivq_s32(idx, mod3), 2), idx);\n        uint32x4_t mask4 = vceqq_s32(vshlq_n_s32(vdivq_s32(idx, mod4), 2), idx);\n        \n        // Square elements at multiples of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        vec = vbslq_s32(mask3, squared, vec);\n        \n        // Cube elements at multiples of 4 (not multiples of 3)\n        int32x4_t cubed = vmulq_s32(squared, vec);\n        mask4 = vandq_u32(mask4, vmvnq_u32(mask3));\n        vec = vbslq_s32(mask4, cubed, vec);\n        \n        // Add to running sum\n        sum += vgetq_lane_s32(vec, 0) + vgetq_lane_s32(vec, 1) + \n               vgetq_lane_s32(vec, 2) + vgetq_lane_s32(vec, 3);\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    const int step = 4;\n    \n    for (; i + step <= lst.size(); i += step) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t idx = {i, i+1, i+2, i+3};\n        \n        int32x4_t mod3 = vdupq_n_s32(3);\n        int32x4_t mod4 = vdupq_n_s32(4);\n        \n        uint32x4_t is_mult3 = vceqq_s32(vshlq_n_s32(vdivq_s32(idx, mod3), 0), vdivq_s32(idx, mod3));\n        uint32x4_t is_mult4 = vceqq_s32(vshlq_n_s32(vdivq_s32(idx, mod4), 0), vdivq_s32(idx, mod4));\n        \n        int32x4_t squared = vmulq_s32(vec, vec);\n        int32x4_t cubed = vmulq_s32(squared, vec);\n        \n        int32x4_t result = vec;\n        result = vbslq_s32(is_mult3, squared, result);\n        result = vbslq_s32(vandq_u32(is_mult4, vmvnq_u32(is_mult3)), cubed, result);\n        \n        sum += vgetq_lane_s32(result, 0) + vgetq_lane_s32(result, 1) + \n               vgetq_lane_s32(result, 2) + vgetq_lane_s32(result, 3);\n    }\n    \n    for (; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n    \n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i+1, i+2, i+3};\n        \n        // Create masks for multiples of 3 and 4\n        int32x4_t mod3 = vdupq_n_s32(3);\n        int32x4_t mod4 = vdupq_n_s32(4);\n        uint32x4_t mask3 = vceqq_s32(vshlq_n_s32(vdivq_s32(indices, mod3), 2), indices);\n        uint32x4_t mask4 = vceqq_s32(vshlq_n_s32(vdivq_s32(indices, mod4), 2), indices);\n        \n        // Square elements at multiples of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        int32x4_t result = vbslq_s32(mask3, squared, vec);\n        \n        // Cube elements at multiples of 4 (not multiples of 3)\n        int32x4_t cubed = vmulq_s32(squared, vec);\n        mask4 = vandq_u32(mask4, vmvnq_u32(mask3));\n        result = vbslq_s32(mask4, cubed, result);\n        \n        // Add to sum\n        sum += vgetq_lane_s32(result, 0);\n        sum += vgetq_lane_s32(result, 1);\n        sum += vgetq_lane_s32(result, 2);\n        sum += vgetq_lane_s32(result, 3);\n    }\n    \n    // Handle remaining elements\n    for (; i < lst.size(); i++) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int size = nums.size();\n    \n    // Process 4 elements at a time\n    for (int i = 0; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        \n        // Check if greater than 10\n        uint32x4_t mask1 = vcgtq_s32(vec, vdupq_n_s32(10));\n        \n        // Get absolute values for digit extraction\n        int32x4_t abs_vec = vabsq_s32(vec);\n        \n        // Get first digits by repeated division by 10\n        int32x4_t first_digits = abs_vec;\n        int32x4_t ten = vdupq_n_s32(10);\n        while (vmaxvq_s32(first_digits) >= 10) {\n            first_digits = vdivq_s32(first_digits, ten);\n        }\n        \n        // Get last digits using modulo 10\n        int32x4_t last_digits = vmodq_s32(abs_vec, ten);\n        \n        // Check if first and last digits are odd\n        uint32x4_t mask2 = vandq_u32(\n            vceqq_s32(vandq_s32(first_digits, vdupq_n_s32(1)), vdupq_n_s32(1)),\n            vceqq_s32(vandq_s32(last_digits, vdupq_n_s32(1)), vdupq_n_s32(1))\n        );\n        \n        // Combine conditions\n        uint32x4_t final_mask = vandq_u32(mask1, mask2);\n        \n        // Count matching elements\n        uint32_t lanes[4];\n        vst1q_u32(lanes, final_mask);\n        for(int j = 0; j < 4; j++) {\n            count += (lanes[j] != 0);\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = size - (size % 4); i < size; i++) {\n        int num = abs(nums[i]);\n        if (nums[i] > 10) {\n            int first = num;\n            while (first >= 10) {\n                first /= 10;\n            }\n            int last = num % 10;\n            if (first % 2 == 1 && last % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int len = nums.size();\n    \n    // Process 4 elements at a time\n    for (int i = 0; i <= len-4; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        \n        // Check if greater than 10\n        uint32x4_t mask1 = vcgtq_s32(vec, vdupq_n_s32(10));\n        \n        // Get first digit by repeated division by 10\n        int32x4_t temp = vabsq_s32(vec);\n        while (1) {\n            int32x4_t div = vdupq_n_s32(10);\n            int32x4_t next = vdivq_s32(temp, div);\n            int32x4_t check = vmulq_s32(next, div);\n            uint32x4_t done = vceqq_s32(check, vdupq_n_s32(0));\n            if (vgetq_lane_u32(done, 0) && vgetq_lane_u32(done, 1) && \n                vgetq_lane_u32(done, 2) && vgetq_lane_u32(done, 3))\n                break;\n            temp = next;\n        }\n        \n        // Check if first digit is odd\n        int32x4_t two = vdupq_n_s32(2);\n        uint32x4_t mask2 = vtstq_s32(temp, vdupq_n_s32(1));\n        \n        // Get last digit\n        int32x4_t last = vandq_s32(vabsq_s32(vec), vdupq_n_s32(0xF));\n        \n        // Check if last digit is odd\n        uint32x4_t mask3 = vtstq_s32(last, vdupq_n_s32(1));\n        \n        // Combine all conditions\n        uint32x4_t final_mask = vandq_u32(vandq_u32(mask1, mask2), mask3);\n        \n        // Count number of true values\n        count += vgetq_lane_u32(final_mask, 0) + vgetq_lane_u32(final_mask, 1) + \n                 vgetq_lane_u32(final_mask, 2) + vgetq_lane_u32(final_mask, 3);\n    }\n    \n    // Handle remaining elements\n    for (int i = len - (len%4); i < len; i++) {\n        int num = abs(nums[i]);\n        if (nums[i] <= 10) continue;\n        \n        // Get first digit\n        int first = num;\n        while (first >= 10) {\n            first /= 10;\n        }\n        \n        // Get last digit\n        int last = num % 10;\n        \n        if ((first % 2 == 1) && (last % 2 == 1)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int len = nums.size();\n    \n    // Process 4 elements at a time\n    for (int i = 0; i < len - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        \n        // Check if greater than 10\n        uint32x4_t mask1 = vcgtq_s32(vec, vdupq_n_s32(10));\n        \n        // Get absolute values to handle negatives\n        int32x4_t abs_vec = vabsq_s32(vec);\n        \n        // Get first digits by repeatedly dividing by 10\n        int32x4_t first_digits = abs_vec;\n        int32x4_t ten = vdupq_n_s32(10);\n        while (vmaxvq_s32(first_digits) >= 10) {\n            first_digits = vdivq_s32(first_digits, ten);\n        }\n        \n        // Get last digits using modulo 10\n        int32x4_t last_digits = vmodq_s32(abs_vec, ten);\n        \n        // Check if first and last digits are odd\n        uint32x4_t mask2 = vandq_u32(\n            vceqq_s32(vandq_s32(first_digits, vdupq_n_s32(1)), vdupq_n_s32(1)),\n            vceqq_s32(vandq_s32(last_digits, vdupq_n_s32(1)), vdupq_n_s32(1))\n        );\n        \n        // Combine conditions\n        uint32x4_t final_mask = vandq_u32(mask1, mask2);\n        \n        // Count matching elements\n        uint32_t bits = vaddvq_u32(final_mask);\n        count += __builtin_popcount(bits);\n    }\n    \n    // Handle remaining elements\n    for (int i = len - (len % 4); i < len; i++) {\n        int num = abs(nums[i]);\n        if (nums[i] > 10) {\n            int first = num;\n            while (first >= 10) first /= 10;\n            int last = num % 10;\n            if (first % 2 == 1 && last % 2 == 1) count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int len = nums.size();\n    \n    // Process 4 elements at a time\n    for (int i = 0; i <= len-4; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        \n        // Compare greater than 10\n        uint32x4_t mask1 = vcgtq_s32(vec, vdupq_n_s32(10));\n        \n        // Get first digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digits = abs_vec;\n        int32x4_t ten = vdupq_n_s32(10);\n        \n        uint32x4_t gt_mask = vcgtq_s32(first_digits, ten);\n        while(vmaxvq_u32(gt_mask)) {\n            first_digits = vdivq_s32(first_digits, ten);\n            gt_mask = vcgtq_s32(first_digits, ten);\n        }\n        \n        // Get last digits\n        int32x4_t last_digits = vmodq_s32(abs_vec, ten);\n        \n        // Check if first and last digits are odd\n        uint32x4_t first_odd = vandq_u32(vmodq_s32(first_digits, vdupq_n_s32(2)), vdupq_n_u32(1));\n        uint32x4_t last_odd = vandq_u32(vmodq_s32(last_digits, vdupq_n_s32(2)), vdupq_n_u32(1));\n        uint32x4_t both_odd = vandq_u32(first_odd, last_odd);\n        \n        // Combine all conditions\n        uint32x4_t final_mask = vandq_u32(mask1, both_odd);\n        \n        // Count matching elements\n        count += vaddvq_u32(final_mask);\n    }\n    \n    // Handle remaining elements\n    for (int i = len - (len%4); i < len; i++) {\n        int num = abs(nums[i]);\n        if (num <= 10) continue;\n        \n        // Get first digit\n        int first = num;\n        while (first >= 10) {\n            first /= 10;\n        }\n        \n        // Get last digit\n        int last = num % 10;\n        \n        if (nums[i] > 10 && first % 2 == 1 && last % 2 == 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int len = nums.size();\n    \n    // Process 4 elements at a time\n    for (int i = 0; i < len - 3; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        \n        // Check if greater than 10\n        uint32x4_t mask1 = vcgtq_s32(vec, vdupq_n_s32(10));\n        \n        // Get first digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digits = abs_vec;\n        int32x4_t ten = vdupq_n_s32(10);\n        \n        while (vgetq_lane_s32(vminq_s32(first_digits, ten), 0) != vgetq_lane_s32(first_digits, 0) ||\n               vgetq_lane_s32(vminq_s32(first_digits, ten), 1) != vgetq_lane_s32(first_digits, 1) ||\n               vgetq_lane_s32(vminq_s32(first_digits, ten), 2) != vgetq_lane_s32(first_digits, 2) ||\n               vgetq_lane_s32(vminq_s32(first_digits, ten), 3) != vgetq_lane_s32(first_digits, 3)) {\n            first_digits = vdivq_s32(first_digits, ten);\n        }\n        \n        // Get last digits\n        int32x4_t last_digits = vmodq_s32(abs_vec, ten);\n        \n        // Check if first and last digits are odd\n        uint32x4_t first_odd = vandq_u32(vreinterpretq_u32_s32(first_digits), vdupq_n_u32(1));\n        uint32x4_t last_odd = vandq_u32(vreinterpretq_u32_s32(last_digits), vdupq_n_u32(1));\n        uint32x4_t mask2 = vandq_u32(first_odd, last_odd);\n        \n        // Combine conditions\n        uint32x4_t final_mask = vandq_u32(mask1, mask2);\n        \n        // Count matches\n        uint32_t mask = vgetq_lane_u32(final_mask, 0) + \n                       vgetq_lane_u32(final_mask, 1) + \n                       vgetq_lane_u32(final_mask, 2) + \n                       vgetq_lane_u32(final_mask, 3);\n        count += __builtin_popcount(mask);\n    }\n    \n    // Handle remaining elements\n    for (int i = len - (len % 4); i < len; i++) {\n        int num = abs(nums[i]);\n        if (nums[i] > 10) {\n            int first = num;\n            while (first >= 10) {\n                first /= 10;\n            }\n            int last = num % 10;\n            if ((first % 2 == 1) && (last % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t result = 0;\n    uint64_t* a = new uint64_t[n];\n    \n    // Generate array values\n    uint32x4_t idx = vdupq_n_u32(0);\n    uint32x4_t inc = vdupq_n_u32(1);\n    \n    for (uint64_t i = 0; i < n-3; i+=4) {\n        idx = vaddq_u32(idx, inc);\n        uint32x4_t square = vmulq_u32(idx, idx);\n        uint32x4_t term = vsubq_u32(square, idx);\n        uint32x4_t result_vec = vaddq_u32(term, vdupq_n_u32(1));\n        \n        vst1q_u32((uint32_t*)(a+i), result_vec);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = (n/4)*4; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Check triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            uint32x4_t sum_ij = vdupq_n_u32(a[i] + a[j]);\n            uint32x4_t k_vec = vld1q_u32((uint32_t*)(a+j+1));\n            \n            for (uint64_t k = j+1; k < n-3; k+=4) {\n                uint32x4_t total = vaddq_u32(sum_ij, k_vec);\n                uint32x4_t mod3 = vdupq_n_u32(3);\n                uint32x4_t remainder = vmodq_u32(total, mod3);\n                uint32x4_t is_zero = vceqq_u32(remainder, vdupq_n_u32(0));\n                \n                uint32_t mask = vaddvq_u32(is_zero);\n                result += __builtin_popcount(mask);\n                \n                k_vec = vld1q_u32((uint32_t*)(a+k+4));\n            }\n            \n            // Handle remaining elements\n            for (uint64_t k = ((n-j-1)/4)*4 + j+1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    result++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = new uint64_t[n];\n    \n    // Generate array values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    \n    // Process 2 elements at a time using NEON\n    uint64x2_t three = vdupq_n_u64(3);\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            uint64_t remaining = n - j - 1;\n            uint64_t k = j + 1;\n            \n            while (remaining >= 2) {\n                uint64x2_t vk = vld1q_u64(&a[k]);\n                uint64x2_t sum = vaddq_u64(vdupq_n_u64(a[i] + a[j]), vk);\n                uint64x2_t mod = vreinterpretq_u64_s64(\n                    vandq_s64(vreinterpretq_s64_u64(sum), \n                             vreinterpretq_s64_u64(vsubq_u64(three, vdupq_n_u64(1)))));\n                \n                uint64_t mask = vgetq_lane_u64(vceqq_u64(mod, vdupq_n_u64(0)), 0) |\n                               (vgetq_lane_u64(vceqq_u64(mod, vdupq_n_u64(0)), 1) << 1);\n                \n                count += __builtin_popcountll(mask);\n                \n                k += 2;\n                remaining -= 2;\n            }\n            \n            // Handle remaining element\n            if (remaining) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = new uint64_t[n];\n    \n    // Generate array values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    \n    // Process 2 elements at a time using NEON\n    uint64x2_t three = vdupq_n_u64(3);\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            uint64_t ij_sum = a[i] + a[j];\n            \n            uint64_t remaining = n - j - 1;\n            uint64_t k = j + 1;\n            \n            while (remaining >= 2) {\n                uint64x2_t avec = vld1q_u64(&a[k]);\n                uint64x2_t sum = vdupq_n_u64(ij_sum);\n                sum = vaddq_u64(sum, avec);\n                \n                uint64x2_t mod = vmodq_u64(sum, three);\n                uint64x2_t mask = vceqzq_u64(mod);\n                \n                uint64_t bits = vgetq_lane_u64(mask, 0) & 1;\n                bits += (vgetq_lane_u64(mask, 1) & 1);\n                \n                count += bits;\n                \n                k += 2;\n                remaining -= 2;\n            }\n            \n            // Handle remaining element\n            if (remaining) {\n                if ((ij_sum + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t result = 0;\n    uint64_t* a = new uint64_t[n];\n    \n    // Generate array values\n    uint32x4_t idx = vdupq_n_u32(0);\n    uint32x4_t inc = vdupq_n_u32(1);\n    uint32x4_t ones = vdupq_n_u32(1);\n    \n    for (uint64_t i = 0; i < n-3; i+=4) {\n        idx = vaddq_u32(idx, ones);\n        uint32x4_t squares = vmulq_u32(idx, idx);\n        uint32x4_t terms = vsubq_u32(squares, idx);\n        terms = vaddq_u32(terms, ones);\n        \n        vst1q_u32((uint32_t*)&a[i], terms);\n    }\n    \n    // Handle remaining elements\n    for (uint64_t i = (n/4)*4; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Check triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            uint32x4_t sum_ij = vdupq_n_u32(a[i] + a[j]);\n            uint32x4_t idx_k = vdupq_n_u32(j+1);\n            \n            for (uint64_t k = j+1; k < n-3; k+=4) {\n                idx_k = vaddq_u32(idx_k, inc);\n                uint32x4_t squares = vmulq_u32(idx_k, idx_k); \n                uint32x4_t terms = vsubq_u32(squares, idx_k);\n                terms = vaddq_u32(terms, ones);\n                \n                uint32x4_t sums = vaddq_u32(sum_ij, terms);\n                uint32x4_t mod3 = vdupq_n_u32(3);\n                uint32x4_t remainders = vmodq_u32(sums, mod3);\n                uint32x4_t zeros = vdupq_n_u32(0);\n                uint32x4_t matches = vceqq_u32(remainders, zeros);\n                \n                uint32_t mask = vaddvq_u32(matches);\n                result += __builtin_popcount(mask);\n            }\n            \n            // Handle remaining elements\n            for (uint64_t k = ((n-j-1)/4)*4 + j+1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    result++;\n                }\n            }\n        }\n    }\n    \n    delete[] a;\n    return result;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t result = 0;\n    uint64_t* a = new uint64_t[n];\n    \n    // Calculate array values using SIMD\n    uint64x2_t idx, one, two;\n    for (uint64_t i = 0; i < n-1; i+=2) {\n        idx = vcreate_u64((uint64_t)(i+1) | ((uint64_t)(i+2) << 32));\n        one = vdup_n_u64(1);\n        two = vmul_u64(idx, idx);\n        two = vsub_u64(two, idx);\n        two = vadd_u64(two, one);\n        vst1_u64(&a[i], two);\n    }\n    \n    // Handle remaining element if n is odd\n    if (n % 2) {\n        a[n-1] = (n * n) - n + 1;\n    }\n\n    // Check triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            uint64x2_t sum_ij = vdup_n_u64(a[i] + a[j]);\n            \n            for (uint64_t k = j+1; k < n-1; k+=2) {\n                uint64x2_t ak = vld1_u64(&a[k]);\n                uint64x2_t sum = vadd_u64(sum_ij, ak);\n                uint64x2_t mod3 = vsub_u64(sum, vmul_u64(vdiv_u64(sum, vdup_n_u64(3)), vdup_n_u64(3)));\n                uint64x2_t mask = vceq_u64(mod3, vdup_n_u64(0));\n                \n                result += vget_lane_u64(mask, 0) & (k < n ? 1 : 0);\n                result += vget_lane_u64(mask, 1) & (k+1 < n ? 1 : 0);\n            }\n            \n            // Handle last element if odd number of elements remain\n            if ((n-j-1) % 2) {\n                uint64_t sum = a[i] + a[j] + a[n-1];\n                if (sum % 3 == 0) result++;\n            }\n        }\n    }\n    \n    delete[] a;\n    return result;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    int limit = sqrt(n);\n    int remaining = limit / 4;\n    int leftover = limit % 4;\n    \n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t divisors;\n    uint32x4_t result;\n    uint32_t is_prime = 1;\n    \n    for(int i = 2; i <= remaining; i++) {\n        divisors = vdupq_n_u32(i*4);\n        divisors = vaddq_u32(divisors, vld1q_u32((uint32_t[]){0,1,2,3}));\n        result = vmodq_u32(num, divisors);\n        uint32x4_t zero = vdupq_n_u32(0);\n        uint32x4_t compare = vceqq_u32(result, zero);\n        if(vgetq_lane_u32(compare, 0) || vgetq_lane_u32(compare, 1) || \n           vgetq_lane_u32(compare, 2) || vgetq_lane_u32(compare, 3)) {\n            is_prime = 0;\n            break;\n        }\n    }\n    \n    for(int i = remaining*4 + 1; i <= limit; i++) {\n        if(n % i == 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n    \n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    int limit = sqrt(n);\n    int blocks = (limit + 3) / 4;\n    uint32x4_t num = vdupq_n_u32(n);\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t one = vdupq_n_u32(1);\n    \n    for (int i = 0; i < blocks; i++) {\n        uint32x4_t divs = {2 + i*4, 3 + i*4, 4 + i*4, 5 + i*4};\n        uint32x4_t rem = vmodq_u32(num, divs);\n        uint32x4_t cmp = vceqq_u32(rem, zero);\n        uint32_t mask = vaddvq_u32(vandq_u32(cmp, one));\n        if (mask > 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    int limit = sqrt(n);\n    int blocks = (limit + 3) / 4;\n    \n    uint32x4_t n_vec = vdupq_n_u32(n);\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t one = vdupq_n_u32(1);\n    \n    for (int i = 0; i < blocks; i++) {\n        uint32x4_t nums = {2 + i*4, 3 + i*4, 4 + i*4, 5 + i*4};\n        uint32x4_t div = vdivq_u32(n_vec, nums);\n        uint32x4_t mul = vmulq_u32(div, nums);\n        uint32x4_t cmp = vceqq_u32(mul, n_vec);\n        uint32x4_t result = vandq_u32(cmp, one);\n        \n        uint32_t sum = vaddvq_u32(result);\n        if (sum > 0) return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    uint32x4_t vec_n = vdupq_n_u32(n);\n    uint32x4_t divisors = {2, 3, 4, 5};\n    uint32x4_t remainders = vmodq_u32(vec_n, divisors);\n    uint32x4_t zero = vdupq_n_u32(0);\n    uint32x4_t compare = vceqq_u32(remainders, zero);\n    uint32_t result = vaddvq_u32(compare);\n    \n    if (result > 0 || n % 6 != 1 && n % 6 != 5) {\n        return y;\n    }\n    \n    int i = 7;\n    int limit = sqrt(n);\n    \n    while (i <= limit) {\n        uint32x4_t vec_i = vdupq_n_u32(i);\n        uint32x4_t increments = {0, 2, 4, 6};\n        vec_i = vaddq_u32(vec_i, increments);\n        \n        remainders = vmodq_u32(vec_n, vec_i);\n        compare = vceqq_u32(remainders, zero);\n        result = vaddvq_u32(compare);\n        \n        if (result > 0) {\n            return y;\n        }\n        i += 8;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    int limit = sqrt(n);\n    int blocks = (limit + 3) / 4;\n    \n    uint32x4_t vn = vdupq_n_u32(n);\n    uint32x4_t vzero = vdupq_n_u32(0);\n    uint32_t result = 1;\n    \n    for (int i = 0; i < blocks; i++) {\n        uint32x4_t vi = vaddq_u32(vmovq_n_u32(i*4 + 2), \n                                 vld1q_u32((uint32_t[]){0,1,2,3}));\n        \n        uint32x4_t vrem = vmodq_u32(vn, vi);\n        uint32x4_t vcmp = vceqq_u32(vrem, vzero);\n        uint32_t mask = vaddvq_u32(vcmp);\n        \n        if (mask) {\n            result = 0;\n            break;\n        }\n    }\n    \n    return result ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    int len = lst.size();\n    int vec_size = len - (len % 4);\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n    \n    for (int i = 0; i < vec_size; i += 4) {\n        // Load 4 floats\n        float32x4_t nums = vld1q_f32(&lst[i]);\n        \n        // Check if numbers are negative\n        uint32x4_t neg_mask = vcltq_f32(nums, zero);\n        \n        // Check if numbers are integers\n        float32x4_t floor_nums = vrndmq_f32(nums);\n        uint32x4_t int_mask = vceqq_f32(nums, floor_nums);\n        \n        // Convert to integers\n        int32x4_t ints = vcvtq_s32_f32(nums);\n        \n        // Check for odd numbers\n        int32x4_t odd_mask = vandq_s32(ints, one);\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(vmvnq_u32(neg_mask), int_mask);\n        valid_mask = vandq_u32(valid_mask, vreinterpretq_u32_s32(odd_mask));\n        \n        // Zero out invalid numbers\n        float32x4_t valid_nums = vreinterpretq_f32_u32(\n            vandq_u32(vreinterpretq_u32_f32(nums), valid_mask)\n        );\n        \n        // Square the numbers\n        float32x4_t squares = vmulq_f32(valid_nums, valid_nums);\n        \n        // Horizontal sum\n        float32x2_t sum2 = vadd_f32(vget_low_f32(squares), vget_high_f32(squares));\n        sum2 = vpadd_f32(sum2, sum2);\n        sum += (uint64_t)vget_lane_f32(sum2, 0);\n    }\n    \n    // Handle remaining elements\n    for (int i = vec_size; i < len; i++) {\n        float num = lst[i];\n        if (num >= 0 && floor(num) == num && (int)num % 2 == 1) {\n            sum += (uint64_t)(num * num);\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    int len = lst.size();\n    int vec_size = len - (len % 4);\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n    \n    for (int i = 0; i < vec_size; i += 4) {\n        // Load 4 floats\n        float32x4_t nums = vld1q_f32(&lst[i]);\n        \n        // Check if numbers are negative\n        uint32x4_t neg_mask = vcltq_f32(nums, zero);\n        \n        // Check if numbers are integers\n        float32x4_t floor_nums = vrndmq_f32(nums);\n        uint32x4_t int_mask = vceqq_f32(nums, floor_nums);\n        \n        // Convert to integers\n        int32x4_t ints = vcvtq_s32_f32(nums);\n        \n        // Check for odd numbers\n        int32x4_t odd_mask = vandq_s32(ints, one);\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(vmvnq_u32(neg_mask), int_mask);\n        valid_mask = vandq_u32(valid_mask, vreinterpretq_u32_s32(odd_mask));\n        \n        // Zero out invalid numbers\n        float32x4_t valid_nums = vreinterpretq_f32_u32(\n            vandq_u32(vreinterpretq_u32_f32(nums), valid_mask)\n        );\n        \n        // Square the numbers\n        float32x4_t squares = vmulq_f32(valid_nums, valid_nums);\n        \n        // Horizontal sum\n        float32x2_t sum2 = vadd_f32(vget_low_f32(squares), vget_high_f32(squares));\n        sum2 = vpadd_f32(sum2, sum2);\n        sum += (uint64_t)vget_lane_f32(sum2, 0);\n    }\n    \n    // Handle remaining elements\n    for (int i = vec_size; i < len; i++) {\n        float num = lst[i];\n        if (num >= 0 && floor(num) == num && (int)num % 2 == 1) {\n            sum += (uint64_t)(num * num);\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    int len = lst.size();\n    int vec_size = len - (len % 4);\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n    \n    for (int i = 0; i < vec_size; i += 4) {\n        // Load 4 floats\n        float32x4_t nums = vld1q_f32(&lst[i]);\n        \n        // Check if numbers are negative\n        uint32x4_t pos_mask = vcgeq_f32(nums, zero);\n        \n        // Convert to integers\n        int32x4_t ints = vcvtq_s32_f32(nums);\n        float32x4_t floats = vcvtq_f32_s32(ints);\n        \n        // Check if numbers are integers\n        uint32x4_t int_mask = vceqq_f32(nums, floats);\n        \n        // Check if numbers are odd\n        int32x4_t odd_check = vandq_s32(ints, one);\n        uint32x4_t odd_mask = vceqq_s32(odd_check, one);\n        \n        // Combine all masks\n        uint32x4_t final_mask = vandq_u32(vandq_u32(pos_mask, int_mask), odd_mask);\n        \n        // Convert mask to float\n        float32x4_t mask = vcvtq_f32_u32(final_mask);\n        \n        // Multiply valid numbers by themselves\n        float32x4_t squares = vmulq_f32(nums, nums);\n        \n        // Apply mask\n        float32x4_t masked = vmulq_f32(squares, mask);\n        \n        // Add to sum\n        float32x2_t sum2 = vadd_f32(vget_low_f32(masked), vget_high_f32(masked));\n        sum += vget_lane_f32(vpadd_f32(sum2, sum2), 0);\n    }\n    \n    // Handle remaining elements\n    for (int i = vec_size; i < len; i++) {\n        float num = lst[i];\n        if (num >= 0 && floor(num) == num && (int)num % 2 == 1) {\n            sum += num * num;\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    int len = lst.size();\n    int vec_size = len - (len % 4);\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n    \n    for (int i = 0; i < vec_size; i += 4) {\n        // Load 4 floats\n        float32x4_t v = vld1q_f32(&lst[i]);\n        \n        // Check if numbers are non-negative\n        uint32x4_t mask1 = vcgeq_f32(v, zero);\n        \n        // Check if numbers are integers\n        float32x4_t floor_v = vrndmq_f32(v);\n        uint32x4_t mask2 = vceqq_f32(v, floor_v);\n        \n        // Convert to integers\n        int32x4_t ints = vcvtq_s32_f32(v);\n        \n        // Check if numbers are odd\n        int32x4_t mod2 = vandq_s32(ints, one);\n        uint32x4_t mask3 = vceqq_s32(mod2, one);\n        \n        // Combine all masks\n        uint32x4_t final_mask = vandq_u32(vandq_u32(mask1, mask2), mask3);\n        \n        // Zero out non-qualifying numbers\n        float32x4_t masked = vreinterpretq_f32_u32(vandq_u32(final_mask, vreinterpretq_u32_f32(v)));\n        \n        // Square the numbers\n        float32x4_t squared = vmulq_f32(masked, masked);\n        \n        // Add to sum\n        float32x2_t sum2 = vadd_f32(vget_low_f32(squared), vget_high_f32(squared));\n        sum += vget_lane_f32(vpadd_f32(sum2, sum2), 0);\n    }\n    \n    // Handle remaining elements\n    for (int i = vec_size; i < len; i++) {\n        float val = lst[i];\n        if (val >= 0 && val == (int)val && (int)val % 2 == 1) {\n            sum += val * val;\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    int len = lst.size();\n    int vec_size = len - (len % 4);\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n    \n    for (int i = 0; i < vec_size; i += 4) {\n        // Load 4 floats\n        float32x4_t nums = vld1q_f32(&lst[i]);\n        \n        // Check if numbers are negative\n        uint32x4_t neg_mask = vcltq_f32(nums, zero);\n        \n        // Check if numbers are integers\n        float32x4_t rounded = vrndq_f32(nums);\n        uint32x4_t int_mask = vceqq_f32(nums, rounded);\n        \n        // Check if numbers are odd\n        int32x4_t ints = vcvtq_s32_f32(nums);\n        uint32x4_t odd_mask = vtstq_s32(ints, one);\n        \n        // Combine masks\n        uint32x4_t valid_mask = vandq_u32(int_mask, vmvnq_u32(neg_mask));\n        valid_mask = vandq_u32(valid_mask, odd_mask);\n        \n        // Square valid numbers\n        float32x4_t squared = vmulq_f32(nums, nums);\n        squared = vbslq_f32(valid_mask, squared, zero);\n        \n        // Sum squares\n        float32x2_t sum2 = vadd_f32(vget_low_f32(squared), vget_high_f32(squared));\n        sum2 = vpadd_f32(sum2, sum2);\n        sum += (uint64_t)vget_lane_f32(sum2, 0);\n    }\n    \n    // Handle remaining elements\n    for (int i = vec_size; i < len; i++) {\n        float num = lst[i];\n        if (num >= 0 && num == (int)num && (int)num % 2 == 1) {\n            sum += (uint64_t)(num * num);\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    \n    int i = 0;\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 elements from each vector\n        int32x4_t v1 = vld1q_s32(&game[i]);\n        int32x4_t v2 = vld1q_s32(&guess[i]);\n        \n        // Calculate differences\n        int32x4_t diff = vsubq_s32(v1, v2);\n        \n        // Get absolute values\n        int32x4_t abs_diff = vabsq_s32(diff);\n        \n        // Store results\n        vst1q_s32(&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    \n    int i = 0;\n    for (; i + 4 <= game.size(); i += 4) {\n        // Load 4 elements from each vector\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        \n        // Calculate difference\n        int32x4_t diff = vsubq_s32(game_vec, guess_vec);\n        \n        // Get absolute values\n        int32x4_t abs_diff = vabsq_s32(diff);\n        \n        // Store result\n        vst1q_s32(&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    \n    int i = 0;\n    for (; i <= game.size() - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&game[i]);\n        int32x4_t v2 = vld1q_s32(&guess[i]);\n        \n        // Calculate difference\n        int32x4_t diff = vsubq_s32(v1, v2);\n        \n        // Get absolute values\n        int32x4_t abs_diff = vabsq_s32(diff);\n        \n        // Store result\n        vst1q_s32(&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    \n    int i = 0;\n    for (; i <= game.size() - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&game[i]);\n        int32x4_t v2 = vld1q_s32(&guess[i]);\n        \n        // Calculate differences\n        int32x4_t diff = vsubq_s32(v1, v2);\n        \n        // Get absolute values\n        int32x4_t abs_diff = vabsq_s32(diff);\n        \n        // Store result\n        vst1q_s32(&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    \n    int i = 0;\n    for (; i <= game.size() - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&game[i]);\n        int32x4_t v2 = vld1q_s32(&guess[i]);\n        \n        // Calculate difference\n        int32x4_t diff = vsubq_s32(v1, v2);\n        \n        // Get absolute values\n        int32x4_t abs_diff = vabsq_s32(diff);\n        \n        // Store result\n        vst1q_s32(&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}

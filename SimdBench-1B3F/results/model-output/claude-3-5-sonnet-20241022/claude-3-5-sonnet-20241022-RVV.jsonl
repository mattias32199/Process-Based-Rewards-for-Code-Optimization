{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    vbool64_t vmask;\n    vint64m1_t vsrc;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vmask = vlm_v_b64(mask + i, vl);\n        vsrc = vle64_v_i64m1(src + i, vl);\n        vse64_v_i64m1_m(vmask, dst + i, vsrc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    vbool64_t vmask;\n    vint64m1_t vsrc;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vmask = vlm_v_b64(mask + i, vl);\n        vsrc = vle64_v_i64m1(src + i, vl);\n        vse64_v_i64m1_m(vmask, dst + i, vsrc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    vint64m8_t v_src;\n    vbool8_t v_mask;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        v_mask = vlm_v_b8(mask + i, vl);\n        v_src = vle64_v_i64m8(src + i, vl);\n        vsse64_v_i64m8_m(v_mask, dst + i, sizeof(int64_t), v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    vbool64_t vmask;\n    vint64m1_t vsrc;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vmask = vlm_v_b64(mask + i, vl);\n        vsrc = vle64_v_i64m1(src + i, vl);\n        vse64_v_i64m1_m(vmask, dst + i, vsrc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_0_RVV", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl;\n    vbool64_t vmask;\n    vint64m1_t vsrc;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m1(length - i);\n        vmask = vlm_v_b64(mask + i, vl);\n        vsrc = vle64_v_i64m1(src + i, vl);\n        vse64_v_i64m1_m(vmask, dst + i, vsrc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        v_tmp1 = vmul_vx_i32m8(v_src, scale, vl);\n        v_tmp1 = vsra_vx_i32m8(v_tmp1, 3, vl);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        v_tmp2 = vmul_vx_i32m8(v_src, scale, vl);\n        v_tmp2 = vsll_vx_i32m8(v_tmp2, 3, vl);\n        \n        // Calculate element * scale\n        v_result = vmul_vx_i32m8(v_src, scale, vl);\n        \n        // Add tmp1 * tmp2\n        v_result = vmacc_vv_i32m8(v_result, v_tmp1, v_tmp2, vl);\n        \n        // Divide by 7\n        v_result = vdiv_vx_i32m8(v_result, 7, vl);\n        \n        // Store result\n        vse32_v_i32m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source elements\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Multiply by scale\n        v_src = vmul_vx_i32m8(v_src, scale, vl);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        v_tmp1 = vsra_vx_i32m8(v_src, 3, vl);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        v_tmp2 = vsll_vx_i32m8(v_src, 3, vl);\n        \n        // Calculate tmp1 * tmp2\n        v_tmp1 = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        \n        // Add original scaled value\n        v_result = vadd_vv_i32m8(v_src, v_tmp1, vl);\n        \n        // Divide by 7\n        v_result = vdiv_vx_i32m8(v_result, 7, vl);\n        \n        // Store results\n        vse32_v_i32m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        v_tmp1 = vmul_vx_i32m8(v_src, scale, vl);\n        v_tmp1 = vsra_vx_i32m8(v_tmp1, 3, vl);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        v_tmp2 = vmul_vx_i32m8(v_src, scale, vl);\n        v_tmp2 = vsll_vx_i32m8(v_tmp2, 3, vl);\n        \n        // Calculate element * scale\n        v_result = vmul_vx_i32m8(v_src, scale, vl);\n        \n        // Add tmp1 * tmp2\n        v_tmp1 = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        v_result = vadd_vv_i32m8(v_result, v_tmp1, vl);\n        \n        // Divide by 7\n        v_result = vdiv_vx_i32m8(v_result, 7, vl);\n        \n        // Store result\n        vse32_v_i32m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_result;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source elements\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        v_tmp1 = vmul_vx_i32m8(v_src, scale, vl);\n        v_tmp1 = vsra_vx_i32m8(v_tmp1, 3, vl);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        v_tmp2 = vmul_vx_i32m8(v_src, scale, vl);\n        v_tmp2 = vsll_vx_i32m8(v_tmp2, 3, vl);\n        \n        // Calculate element * scale\n        v_result = vmul_vx_i32m8(v_src, scale, vl);\n        \n        // Add tmp1 * tmp2\n        v_tmp1 = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        v_result = vadd_vv_i32m8(v_result, v_tmp1, vl);\n        \n        // Divide by 7\n        v_result = vdiv_vx_i32m8(v_result, 7, vl);\n        \n        // Store results\n        vse32_v_i32m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_1_RVV", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_tmp1, v_tmp2, v_scaled, v_result;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Calculate scaled value\n        v_scaled = vmul_vx_i32m8(v_src, scale, vl);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        v_tmp1 = vsra_vx_i32m8(v_scaled, 3, vl);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        v_tmp2 = vsll_vx_i32m8(v_scaled, 3, vl);\n        \n        // Calculate tmp1 * tmp2\n        v_tmp1 = vmul_vv_i32m8(v_tmp1, v_tmp2, vl);\n        \n        // Add scaled value\n        v_result = vadd_vv_i32m8(v_scaled, v_tmp1, vl);\n        \n        // Divide by 7\n        v_result = vdiv_vx_i32m8(v_result, 7, vl);\n        \n        // Store result\n        vse32_v_i32m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vl = vsetvl_e64m8(rows);\n    \n    while (rows > 0) {\n        vint64m8_t vid = vid_v_i64m8(vl);\n        vint64m8_t voffset = vmul_vx_i64m8(vid, cols, vl);\n        voffset = vadd_vx_i64m8(voffset, stride, vl);\n        \n        vfloat64m8_t vdata = vluxei64_v_f64m8(src, voffset, vl);\n        vse64_v_f64m8(dst, vdata, vl);\n        \n        src += cols * vl;\n        dst += vl;\n        rows -= vl;\n        vl = vsetvl_e64m8(rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vl = vsetvl_e64m8(rows);\n    \n    while (rows > 0) {\n        vint64m8_t vidx = vid_v_i64m8(vl);\n        vidx = vmul_vx_i64m8(vidx, cols, vl);\n        vidx = vadd_vx_i64m8(vidx, stride, vl);\n        \n        vfloat64m8_t vdata = vluxei64_v_f64m8(src, vidx, vl);\n        vse64_v_f64m8(dst, vdata, vl);\n        \n        src += cols * vl;\n        dst += vl;\n        rows -= vl;\n        vl = vsetvl_e64m8(rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vl = vsetvl_e64m8(rows);\n    \n    while (rows > 0) {\n        vint64m8_t vidx = vid_v_i64m8(vl);\n        vint64m8_t voffset = vmul_vx_i64m8(vidx, cols, vl);\n        voffset = vadd_vx_i64m8(voffset, stride, vl);\n        \n        vfloat64m8_t vdata = vloxei64_v_f64m8(src, voffset, vl);\n        vse64_v_f64m8(dst, vdata, vl);\n        \n        src += cols * vl;\n        dst += vl;\n        rows -= vl;\n        vl = vsetvl_e64m8(rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vl = vsetvl_e64m8(rows);\n    \n    while (rows > 0) {\n        vint64m8_t vidx = vid_v_i64m8(vl);\n        vidx = vmul_vx_i64m8(vidx, cols, vl);\n        vidx = vadd_vx_i64m8(vidx, stride, vl);\n        \n        vfloat64m8_t vdata = vluxei64_v_f64m8(src, vidx, vl);\n        vse64_v_f64m8(dst, vdata, vl);\n        \n        src += cols * vl;\n        dst += vl;\n        rows -= vl;\n        vl = vsetvl_e64m8(rows);\n    }\n}\n```"}
{"task_id": "SimdBench_2_RVV", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl;\n    vl = vsetvl_e64m8(rows);\n    \n    while (rows > 0) {\n        vint64m8_t vidx = vid_v_i64m8(vl);\n        vidx = vmul_vx_i64m8(vidx, cols, vl);\n        vidx = vadd_vx_i64m8(vidx, stride, vl);\n        \n        vfloat64m8_t vdata = vloxei64_v_f64m8(src, vidx, vl);\n        vse64_v_f64m8(dst, vdata, vl);\n        \n        src += cols * vl;\n        dst += vl;\n        rows -= vl;\n        vl = vsetvl_e64m8(rows);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_data;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_data = vluxei32_v_f32m1(src, v_indices, vl);\n        vse32_v_f32m1(&dst[i], v_data, vl);\n    }\n\n    // Scatter operation \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_data = vle32_v_f32m1(&src[i], vl);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        vsuxei32_v_f32m1(dst, v_indices, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_data;\n    vuint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load indices\n        v_indices = vle32_v_u32m1(&indices[i], vl);\n        \n        // Gather values from src using indices\n        v_data = vluxei32_v_f32m1(src, v_indices, vl);\n        \n        // Store gathered values to dst\n        vse32_v_f32m1(&dst[i], v_data, vl);\n    }\n\n    // Scatter operation \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source values\n        v_data = vle32_v_f32m1(&src[i], vl);\n        \n        // Load indices\n        v_indices = vle32_v_u32m1(&indices[i], vl);\n        \n        // Scatter values to dst using indices\n        vsuxei32_v_f32m1(dst, v_indices, v_data, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_gather;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_gather = vluxei32_v_f32m1(src, v_indices, vl);\n        vse32_v_f32m1(&dst[i], v_gather, vl);\n    }\n\n    // Scatter operation \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_gather = vle32_v_f32m1(&src[i], vl);\n        vsuxei32_v_f32m1(dst, v_indices, v_gather, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_gather;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_gather = vluxei32_v_f32m1(src, v_indices, vl);\n        vse32_v_f32m1(&dst[i], v_gather, vl);\n    }\n\n    // Scatter operation \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_gather = vle32_v_f32m1(&src[i], vl);\n        vsuxei32_v_f32m1(dst, v_indices, v_gather, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_3_RVV", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_gather;\n    vint32m1_t v_indices;\n\n    // Gather operation\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_gather = vluxei32_v_f32m1(src, v_indices, vl);\n        vse32_v_f32m1(&dst[i], v_gather, vl);\n    }\n\n    // Scatter operation \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        v_indices = vle32_v_i32m1(&indices[i], vl);\n        v_gather = vle32_v_f32m1(&src[i], vl);\n        vsuxei32_v_f32m1(dst, v_indices, v_gather, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    size_t left = start;\n    size_t right = end;\n    \n    while (left < right) {\n        vl = vsetvl_e16m8(right - left + 1);\n        size_t step = vl / 2;\n        \n        vint16m8_t v_left = vle16_v_i16m8(&arr[left], step);\n        vint16m8_t v_right = vle16_v_i16m8(&arr[right - step + 1], step);\n        \n        vse16_v_i16m8(&arr[right - step + 1], v_left);\n        vse16_v_i16m8(&arr[left], v_right);\n        \n        left += step;\n        right -= step;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    while (i < j) {\n        vl = vsetvl_e16m8(j - i + 1);\n        size_t step = vl / 2;\n        \n        vint16m8_t v_front = vle16_v_i16m8(&arr[i], step);\n        vint16m8_t v_back = vle16_v_i16m8(&arr[j - step + 1], step);\n        \n        vse16_v_i16m8(&arr[j - step + 1], v_front);\n        vse16_v_i16m8(&arr[i], v_back);\n        \n        i += step;\n        j -= step;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    while (i < j) {\n        vl = vsetvl_e16m8(j - i + 1);\n        size_t step = vl / 2;\n        \n        vint16m8_t v_front = vle16_v_i16m8(&arr[i], step);\n        vint16m8_t v_back = vle16_v_i16m8(&arr[j - step + 1], step);\n        \n        vse16_v_i16m8(&arr[j - step + 1], v_front);\n        vse16_v_i16m8(&arr[i], v_back);\n        \n        i += step;\n        j -= step;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    while (i < j) {\n        vl = vsetvl_e16m8(j - i + 1);\n        size_t step = vl / 2;\n        \n        vint16m8_t v_front = vle16_v_i16m8(&arr[i], step);\n        vint16m8_t v_back = vle16_v_i16m8(&arr[j - step + 1], step);\n        \n        vse16_v_i16m8(&arr[j - step + 1], v_front);\n        vse16_v_i16m8(&arr[i], v_back);\n        \n        i += step;\n        j -= step;\n    }\n}\n```"}
{"task_id": "SimdBench_4_RVV", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    size_t vl;\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    while (i < j) {\n        vl = vsetvl_e16m8(j - i + 1);\n        size_t step = vl / 2;\n        \n        vint16m8_t v_front = vle16_v_i16m8(&arr[i], step);\n        vint16m8_t v_back = vle16_v_i16m8(&arr[j - step + 1], step);\n        \n        vse16_v_i16m8(&arr[j - step + 1], v_front);\n        vse16_v_i16m8(&arr[i], v_back);\n        \n        i += step;\n        j -= step;\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * dim1 * dim2;\n    \n    size_t vl;\n    for (size_t i = 0; i < slice_size; i += vl) {\n        vl = vsetvl_e8m8(slice_size - i);\n        vuint8m8_t v = vle8_v_u8m8(&tensor[offset + i], vl);\n        vse8_v_u8m8(&slice[i], v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * dim1 * dim2;\n    \n    size_t vl;\n    for (size_t i = 0; i < slice_size; i += vl) {\n        vl = vsetvl_e8m8(slice_size - i);\n        vuint8m8_t v = vle8_v_u8m8(&tensor[offset + i], vl);\n        vse8_v_u8m8(&slice[i], v, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * dim1 * dim2;\n    \n    size_t vl;\n    for (size_t i = 0; i < slice_size; i += vl) {\n        vl = vsetvl_e8m8(slice_size - i);\n        vuint8m8_t v_slice = vle8_v_u8m8(&tensor[offset + i], vl);\n        vse8_v_u8m8(&slice[i], v_slice, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * dim1 * dim2;\n    \n    size_t vl;\n    for (size_t i = 0; i < slice_size; i += vl) {\n        vl = vsetvl_e8m8(slice_size - i);\n        vuint8m8_t v_slice = vle8_v_u8m8(&tensor[offset + i], vl);\n        vse8_v_u8m8(&slice[i], v_slice, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_5_RVV", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * dim1 * dim2;\n    \n    size_t vl;\n    for (size_t i = 0; i < slice_size; i += vl) {\n        vl = vsetvl_e8m8(slice_size - i);\n        vuint8m8_t v_slice = vle8_v_u8m8(&tensor[offset + i], vl);\n        vse8_v_u8m8(&slice[i], v_slice, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_ii = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_jj = (j + block_size < cols) ? j + block_size : cols;\n            \n            for (size_t ii = i; ii < max_ii; ii++) {\n                size_t avl = max_jj - j;\n                size_t vl;\n                const int16_t* src_ptr = src + ii * cols + j;\n                int16_t* dst_ptr = dst + j * rows + ii;\n                \n                for (size_t offset = 0; offset < avl; offset += vl) {\n                    vl = vsetvl_e16m8(avl - offset);\n                    vint16m8_t vec = vle16_v_i16m8(src_ptr + offset, vl);\n                    \n                    for (size_t k = 0; k < vl; k++) {\n                        dst_ptr[k * rows] = vmv_x_s_i16m8_i16(vslidedown_vx_i16m8(vec, k, vl));\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_ii = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_jj = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < max_ii; ii++) {\n                size_t avl = max_jj - j;\n                size_t vl;\n                const int16_t* src_ptr = src + ii * cols + j;\n                int16_t* dst_ptr = dst + j * rows + ii;\n\n                for (size_t offset = 0; offset < avl; offset += vl) {\n                    vl = vsetvl_e16m8(avl - offset);\n                    vint16m8_t vec = vle16_v_i16m8(src_ptr + offset, vl);\n                    \n                    // Store elements one by one with stride\n                    for (size_t k = 0; k < vl; k++) {\n                        int16_t element = vmv_x_s_i16m1_i16(vget_v_i16m8_i16m1(vec, k));\n                        *(dst_ptr + k * rows) = element;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_ii = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_jj = (j + block_size < cols) ? j + block_size : cols;\n            \n            for (size_t ii = i; ii < max_ii; ii++) {\n                size_t avl = max_jj - j;\n                size_t vl;\n                const int16_t* src_ptr = src + ii * cols + j;\n                int16_t* dst_ptr = dst + j * rows + ii;\n                \n                for (size_t offset = 0; offset < avl; offset += vl) {\n                    vl = vsetvl_e16m8(avl - offset);\n                    vint16m8_t vec = vle16_v_i16m8(src_ptr + offset, vl);\n                    \n                    // Store elements one by one with stride\n                    for (size_t k = 0; k < vl; k++) {\n                        int16_t element = vmv_x_s_i16m1_i16(vget_v_i16m8_i16m1(vec, k));\n                        *(dst_ptr + k * rows) = element;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_ii = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_jj = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < max_ii; ii++) {\n                size_t avl = max_jj - j;\n                size_t vl;\n                const int16_t* src_ptr = src + ii * cols + j;\n                int16_t* dst_ptr = dst + j * rows + ii;\n\n                for (size_t offset = 0; offset < avl; offset += vl) {\n                    vl = vsetvl_e16m8(avl - offset);\n                    vint16m8_t vec = vle16_v_i16m8(src_ptr + offset, vl);\n                    \n                    // Store elements one by one with stride\n                    for (size_t k = 0; k < vl; k++) {\n                        int16_t element = vmv_x_s_i16m1_i16(vget_v_i16m8_i16m1(vec, k));\n                        *(dst_ptr + k * rows) = element;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_RVV", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_ii = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_jj = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t ii = i; ii < max_ii; ii++) {\n                size_t avl = max_jj - j;\n                size_t vl;\n                const int16_t* src_ptr = src + ii * cols + j;\n                int16_t* dst_ptr = dst + j * rows + ii;\n\n                while (avl > 0) {\n                    vl = vsetvl_e16m8(avl);\n                    vint16m8_t v_src = vle16_v_i16m8(src_ptr, vl);\n                    \n                    // Store elements one by one with stride\n                    for (size_t k = 0; k < vl; k++) {\n                        int16_t element = vmv_x_s_i16m1_i16(vget_v_i16m8_i16m1(v_src, k));\n                        dst_ptr[k * rows] = element;\n                    }\n                    \n                    src_ptr += vl;\n                    dst_ptr += vl * rows;\n                    avl -= vl;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vlmax);\n    \n    size_t diagonal_elements = dim;\n    size_t step = dim * dim + dim + 1;\n    \n    for (size_t i = 0; i < diagonal_elements;) {\n        size_t vl = vsetvl_e32m8(diagonal_elements - i);\n        vfloat32m8_t v_diag = vlse32_v_f32m8(&array[i * step], step * sizeof(float), vl);\n        v_sum = vfadd_vv_f32m8(v_sum, v_diag, vl);\n        i += vl;\n    }\n    \n    return vfredsum_vs_f32m8_f32m1(v_sum, v_sum, vlmax);\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vlmax);\n    \n    size_t diagonal_elements = dim;\n    size_t diagonal_stride = dim * dim + dim + 1;\n    \n    for (size_t i = 0; i < diagonal_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m8(diagonal_elements - i);\n        \n        // Load diagonal elements with strided access\n        vfloat32m8_t v_diag = vlse32_v_f32m8(&array[i * diagonal_stride], \n                                             sizeof(float) * diagonal_stride, \n                                             vl);\n        \n        // Accumulate into vector sum\n        v_sum = vfadd_vv_f32m8(v_sum, v_diag, vl);\n    }\n    \n    // Reduce vector sum to scalar\n    sum = vfredsum_vs_f32m8_f32m1(v_sum, v_sum, vlmax);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vlmax);\n    \n    size_t total_diag = dim;\n    size_t index = 0;\n    \n    for (size_t i = 0; i < total_diag; i += vlmax) {\n        size_t vl = vsetvl_e32m8(total_diag - i);\n        \n        vint32m8_t v_indices;\n        v_indices = vid_v_i32m8(vl);\n        v_indices = vmul_vx_i32m8(v_indices, dim * dim + dim + 1, vl);\n        v_indices = vadd_vx_i32m8(v_indices, i * (dim * dim + dim + 1), vl);\n        \n        vfloat32m8_t v_diag = vluxei32_v_f32m8(array, v_indices, vl);\n        v_sum = vfadd_vv_f32m8(v_sum, v_diag, vl);\n    }\n    \n    sum = vfredsum_vs_f32m8_f32m1(v_sum, v_sum, vlmax);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vlmax);\n    \n    size_t diag_elements = dim;\n    size_t diag_stride = dim * dim + dim + 1;\n    \n    for (size_t i = 0; i < diag_elements; i += vlmax) {\n        size_t vl = vsetvl_e32m8(diag_elements - i);\n        \n        vfloat32m8_t v_diag;\n        size_t idx = i * diag_stride;\n        \n        // Gather diagonal elements with strided load\n        v_diag = vlse32_v_f32m8(&array[idx], sizeof(float) * diag_stride, vl);\n        \n        // Accumulate into vector sum\n        v_sum = vfadd_vv_f32m8(v_sum, v_diag, vl);\n    }\n    \n    // Reduce vector sum to scalar\n    sum = vfredsum_vs_f32m8_f32m1(v_sum, v_sum, vlmax);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_RVV", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, vlmax);\n    \n    size_t diagonal_elements = dim;\n    size_t vl;\n    \n    for (size_t i = 0; i < diagonal_elements; i += vl) {\n        vl = vsetvl_e32m8(diagonal_elements - i);\n        \n        // Calculate indices for diagonal elements\n        size_t *indices = (size_t*)malloc(vl * sizeof(size_t));\n        for (size_t j = 0; j < vl; j++) {\n            size_t idx = i + j;\n            indices[j] = idx * dim * dim + idx * dim + idx;\n        }\n        \n        // Load diagonal elements using indexed load\n        vfloat32m8_t v_diag = vluxei64_v_f32m8(array, (vuint64m8_t)indices, vl);\n        \n        // Accumulate sum\n        v_sum = vfadd_vv_f32m8(v_sum, v_diag, vl);\n        \n        free(indices);\n    }\n    \n    // Reduce vector to scalar\n    sum = vfredsum_vs_f32m8_f32m1(v_sum, v_sum, vlmax);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n    \n    vfloat64m8_t v_src;\n    vfloat64m8_t v_scaled;\n    vbool8_t mask;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        \n        v_src = vle64_v_f64m8(&src[i], vl);\n        \n        // Create mask for elements > threshold\n        mask = vmfgt_vf_f64m8_b8(v_src, threshold, vl);\n        \n        // Scale elements where mask is true\n        v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n        \n        // Select between original and scaled based on mask\n        v_src = vmerge_vvm_f64m8(mask, v_src, v_scaled, vl);\n        \n        // Store result\n        vse64_v_f64m8(&dst[i], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        \n        vfloat64m8_t v_src = vle64_v_f64m8(&src[index], vl);\n        \n        // Create mask for elements > threshold\n        vbool8_t mask = vmfgt_vf_f64m8_b8(v_src, threshold, vl);\n        \n        // Scale elements where mask is true\n        vfloat64m8_t v_scaled = vfmul_vf_f64m8_m(mask, v_src, v_src, scale, vl);\n        \n        // Select between scaled and original based on mask\n        vfloat64m8_t v_result = vmerge_vvm_f64m8(mask, v_src, v_scaled, vl);\n        \n        // Store result\n        vse64_v_f64m8(&dst[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t vlmax = vsetvlmax_e64m8();\n    size_t total_elements = rows * cols;\n    size_t vl;\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        \n        vfloat64m8_t v_src = vle64_v_f64m8(&src[i], vl);\n        vbool8_t mask = vmfgt_vf_f64m8_b8(v_src, threshold, vl);\n        vfloat64m8_t v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n        vfloat64m8_t v_result = vmerge_vvm_f64m8(mask, v_src, v_scaled, vl);\n        \n        vse64_v_f64m8(&dst[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t vl;\n    size_t total = rows * cols;\n    size_t index = 0;\n\n    while (index < total) {\n        vl = vsetvl_e64m8(total - index);\n        \n        vfloat64m8_t v_src = vle64_v_f64m8(&src[index], vl);\n        \n        vbool8_t mask = vmfgt_vf_f64m8_b8(v_src, threshold, vl);\n        \n        vfloat64m8_t v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n        \n        vfloat64m8_t v_result = vmerge_vvm_f64m8(mask, v_src, v_scaled, vl);\n        \n        vse64_v_f64m8(&dst[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_8_RVV", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl;\n    \n    vfloat64m8_t v_src;\n    vfloat64m8_t v_scaled;\n    vbool8_t mask;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        \n        v_src = vle64_v_f64m8(&src[i], vl);\n        \n        mask = vmfgt_vf_f64m8_b8(v_src, threshold, vl);\n        v_scaled = vfmul_vf_f64m8(v_src, scale, vl);\n        \n        v_src = vmerge_vvm_f64m8(mask, v_src, v_scaled, vl);\n        \n        vse64_v_f64m8(&dst[i], v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v = vle64_v_f64m8(&src[src_offset + j], vl);\n            vse64_v_f64m8(&dst[dst_offset + j], v, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v_src = vle64_v_f64m8(&src[src_offset + j], vl);\n            vse64_v_f64m8(&dst[dst_offset + j], v_src, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v = vle64_v_f64m8(&src[src_offset + j], vl);\n            vse64_v_f64m8(&dst[dst_offset + j], v, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v = vle64_v_f64m8(&src[src_offset + j], vl);\n            vse64_v_f64m8(&dst[dst_offset + j], v, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_RVV", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v = vle64_v_f64m8(&src[src_offset + j], vl);\n            vse64_v_f64m8(&dst[dst_offset + j], v, vl);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vl = vsetvl_e64m8(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        vint64m8_t v1 = vle64_v_i64m8(&src1[i], vl);\n        vint64m8_t v2 = vle64_v_i64m8(&src2[i], vl);\n        \n        // Add vectors\n        vint64m8_t sum = vadd_vv_i64m8(v1, v2, vl);\n        \n        // Add scalar\n        vint64m8_t with_scalar = vadd_vx_i64m8(sum, scalar, vl);\n        \n        // Divide by 2 (arithmetic right shift by 1)\n        vint64m8_t result = vsra_vx_i64m8(with_scalar, 1, vl);\n        \n        // Store result\n        vse64_v_i64m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m8_t v1, v2, vadd, vscalar, vresult;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        v1 = vle64_v_i64m8(&src1[i], vl);\n        v2 = vle64_v_i64m8(&src2[i], vl);\n        \n        vadd = vadd_vv_i64m8(v1, v2, vl);\n        \n        vscalar = vmv_v_x_i64m8(scalar, vl);\n        vresult = vadd_vv_i64m8(vadd, vscalar, vl);\n        \n        vresult = vsra_vx_i64m8(vresult, 1, vl);\n        \n        vse64_v_i64m8(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m8_t v1, v2, vadd, vscalar, vfinal;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        v1 = vle64_v_i64m8(&src1[i], vl);\n        v2 = vle64_v_i64m8(&src2[i], vl);\n        \n        vadd = vadd_vv_i64m8(v1, v2, vl);\n        \n        vscalar = vmv_v_x_i64m8(scalar, vl);\n        vadd = vadd_vv_i64m8(vadd, vscalar, vl);\n        \n        vfinal = vsra_vx_i64m8(vadd, 1, vl);\n        \n        vse64_v_i64m8(&dst[i], vfinal, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m8_t v1, v2, vadd, vscalar, vfinal;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        v1 = vle64_v_i64m8(&src1[i], vl);\n        v2 = vle64_v_i64m8(&src2[i], vl);\n        \n        vadd = vadd_vv_i64m8(v1, v2, vl);\n        \n        vscalar = vmv_v_x_i64m8(scalar, vl);\n        vadd = vadd_vv_i64m8(vadd, vscalar, vl);\n        \n        vfinal = vsra_vx_i64m8(vadd, 1, vl);\n        \n        vse64_v_i64m8(&dst[i], vfinal, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_10_RVV", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t vl;\n    vint64m8_t v1, v2, vadd, vscalar, vresult;\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        v1 = vle64_v_i64m8(&src1[i], vl);\n        v2 = vle64_v_i64m8(&src2[i], vl);\n        \n        vadd = vadd_vv_i64m8(v1, v2, vl);\n        \n        vscalar = vmv_v_x_i64m8(scalar, vl);\n        vresult = vadd_vv_i64m8(vadd, vscalar, vl);\n        \n        vresult = vsra_vx_i64m8(vresult, 1, vl);\n        \n        vse64_v_i64m8(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    size_t vl;\n    vint32m1_t v_min = vmv_v_x_i32m1(INT_MAX, 1);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1((length - i + 1) / 2);\n        \n        // Load even elements with strided load\n        vint32m1_t v_data = vlse32_v_i32m1(&src[i], 8, vl);\n        \n        // Find minimum\n        v_min = vmin_vv_i32m1(v_min, v_data, vl);\n    }\n    \n    // Reduce to get final minimum\n    min_val = vredmin_vs_i32m1_i32m1(v_min, v_min, vl);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    size_t vl;\n    int min_val = INT_MAX;\n    size_t index = 0;\n    \n    vint32m1_t v_min = vmv_v_x_i32m1(INT_MAX, 1);\n    \n    while (index < length) {\n        vl = vsetvl_e32m1((length - index) / 2);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vid_v_i32m1(vl), 0, vl);\n        vint32m1_t v_data = vlse32_v_i32m1(src + index, 8, vl);\n        v_min = vmin_vv_i32m1_m(mask, v_min, v_min, v_data, vl);\n        index += vl * 2;\n    }\n    \n    vl = vsetvl_e32m1(1);\n    min_val = vmv_x_s_i32m1_i32(v_min);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    size_t vl;\n    vint32m1_t v_min = vmv_v_x_i32m1(INT_MAX, 1);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1((length - i + 1) / 2);\n        vint32m1_t v_src = vlse32_v_i32m1(&src[i], 8, vl);\n        v_min = vmin_vv_i32m1(v_min, v_src, vl);\n    }\n    \n    min_val = vredmin_vs_i32m1_i32m1(v_min, v_min, vl);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    size_t vl;\n    vint32m1_t v_min = vmv_v_x_i32m1(INT_MAX, 1);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1((length - i + 1) / 2);\n        vint32m1_t v_src = vlse32_v_i32m1(&src[i], 8, vl);\n        v_min = vmin_vv_i32m1(v_min, v_src, vl);\n    }\n    \n    min_val = vredmin_vs_i32m1_i32m1(v_min, v_min, vl);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_RVV", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    int min_val = INT_MAX;\n    size_t vl;\n    vint32m1_t v_min = vmv_v_x_i32m1(INT_MAX, 1);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1((length - i + 1) / 2);\n        \n        // Load even elements with strided load\n        vint32m1_t v_data = vlse32_v_i32m1(&src[i], 8, vl);\n        \n        // Find minimum\n        v_min = vmin_vv_i32m1(v_min, v_data, vl);\n    }\n    \n    // Reduce to get final minimum\n    min_val = vredmin_vs_i32m1_i32m1(v_min, v_min, vl);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_arith;\n    vuint32m8_t v_src_u, v_logic;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source data\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Arithmetic right shift\n        v_arith = vsra_vx_i32m8(v_src, shift, vl);\n        \n        // Logical right shift\n        v_src_u = vreinterpret_v_i32m8_u32m8(v_src);\n        v_logic = vsrl_vx_u32m8(v_src_u, shift, vl);\n        \n        // Add results and store\n        v_arith = vadd_vv_i32m8(v_arith, vreinterpret_v_u32m8_i32m8(v_logic), vl);\n        vse32_v_i32m8(dst + i, v_arith, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_arith;\n    vuint32m8_t v_uint, v_logic;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source data\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Arithmetic right shift\n        v_arith = vsra_vx_i32m8(v_src, shift, vl);\n        \n        // Logical right shift - first convert to unsigned\n        v_uint = vreinterpret_v_i32m8_u32m8(v_src);\n        v_logic = vsrl_vx_u32m8(v_uint, shift, vl);\n        \n        // Convert logical shift result back to signed and add\n        v_src = vadd_vv_i32m8(v_arith, vreinterpret_v_u32m8_i32m8(v_logic), vl);\n        \n        // Store result\n        vse32_v_i32m8(dst + i, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_arith;\n    vuint32m8_t v_uint, v_logic;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source data\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Arithmetic right shift\n        v_arith = vsra_vx_i32m8(v_src, shift, vl);\n        \n        // Logical right shift - first convert to unsigned\n        v_uint = vreinterpret_v_i32m8_u32m8(v_src);\n        v_logic = vsrl_vx_u32m8(v_uint, shift, vl);\n        \n        // Convert logical shift result back to signed and add\n        v_src = vadd_vv_i32m8(v_arith, vreinterpret_v_u32m8_i32m8(v_logic), vl);\n        \n        // Store result\n        vse32_v_i32m8(dst + i, v_src, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_arith;\n    vuint32m8_t v_uint, v_logic;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source data\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Arithmetic right shift\n        v_arith = vsra_vx_i32m8(v_src, shift, vl);\n        \n        // Logical right shift\n        v_uint = vreinterpret_v_i32m8_u32m8(v_src);\n        v_logic = vsrl_vx_u32m8(v_uint, shift, vl);\n        \n        // Add results and store\n        v_arith = vadd_vv_i32m8(v_arith, vreinterpret_v_u32m8_i32m8(v_logic), vl);\n        vse32_v_i32m8(dst + i, v_arith, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_12_RVV", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl;\n    vint32m8_t v_src, v_arithmetic;\n    vuint32m8_t v_logical;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        // Load source data\n        v_src = vle32_v_i32m8(src + i, vl);\n        \n        // Arithmetic right shift\n        v_arithmetic = vsra_vx_i32m8(v_src, shift, vl);\n        \n        // Logical right shift - first convert to unsigned\n        v_logical = vreinterpret_v_i32m8_u32m8(v_src);\n        v_logical = vsrl_vx_u32m8(v_logical, shift, vl);\n        \n        // Add arithmetic and logical results\n        v_arithmetic = vadd_vv_i32m8(v_arithmetic, \n                                   vreinterpret_v_u32m8_i32m8(v_logical),\n                                   vl);\n        \n        // Store result\n        vse32_v_i32m8(dst + i, v_arithmetic, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    vint32m8_t v_data;\n    vint64m8_t v_sum;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        v_data = vle32_v_i32m8(&matrix[i], vl);\n        v_sum = vwadd_vx_i64m8(v_data, 0, vl);\n        sum += vredsum_vs_i64m8_i64m1(vzero_i64m8(vl), v_sum, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    \n    vint32m1_t v_data;\n    vint64m2_t v_sum = vmv_v_x_i64m2(0, 1);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m1(total_elements - i);\n        v_data = vle32_v_i32m1(&matrix[i], vl);\n        v_sum = vwaddsw_vv_i64m2(v_sum, v_data, vl);\n    }\n    \n    v_sum = vredsum_vs_i64m2_i64m1(v_sum, v_sum, vmv_v_x_i64m1(0, 1), vl);\n    sum = vmv_x_s_i64m1_i64(v_sum);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    \n    vint32m8_t v_data;\n    vint64m8_t v_sum;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        v_data = vle32_v_i32m8(&matrix[i], vl);\n        v_sum = vwadd_vx_i64m8(v_data, 0, vl);\n        sum += vredsum_vs_i64m8_i64m1(vzero_i64m1(), v_sum, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    \n    vint32m1_t v_data;\n    vint64m2_t v_sum = vmv_v_x_i64m2(0, 1);\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m1(total_elements - i);\n        v_data = vle32_v_i32m1(&matrix[i], vl);\n        v_sum = vwredsum_vs_i32m1_i64m2(v_sum, v_data, v_sum, vl);\n    }\n    \n    sum = vmv_x_s_i64m2_i64(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_RVV", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t total_elements = rows * cols;\n    int64_t sum = 0;\n    \n    vint32m8_t v_sum = __riscv_vmv_v_x_i32m8(0, vlen);\n    \n    for (size_t i = 0; i < total_elements; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(total_elements - i);\n        vint32m8_t v_elements = __riscv_vle32_v_i32m8(&matrix[i], vl);\n        v_sum = __riscv_vadd_vv_i32m8(v_sum, v_elements, vl);\n    }\n    \n    // Horizontal sum of vector\n    vint64m4_t v_sum_64 = __riscv_vwredsum_vs_i32m8_i64m4(v_sum, \n                          __riscv_vmv_v_x_i64m4(0, 1), vlen);\n    sum = __riscv_vmv_x_s_i64m4_i64(v_sum_64);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t vl;\n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    \n    vint8m8_t v_data;\n    vint8m8_t v_max;\n    vbool1_t mask;\n    \n    size_t index = 0;\n    while (index < length) {\n        vl = vsetvl_e8m8(length - index);\n        \n        v_data = vle8_v_i8m8(&src[index], vl);\n        v_max = vmv_v_x_i8m8(max_val, vl);\n        \n        mask = vmsgt_vv_i8m8_b1(v_data, v_max, vl);\n        \n        if (vmany_m_b1(mask, vl)) {\n            size_t first_idx = vfirst_m_b1(mask, vl);\n            if (src[index + first_idx] > max_val) {\n                max_val = src[index + first_idx];\n                max_idx = index + first_idx;\n            }\n        }\n        \n        index += vl;\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t vl;\n    size_t index = 0;\n    int8_t max_val = src[0];\n    size_t max_idx = 0;\n    \n    vint8m8_t v_data;\n    vint8m8_t v_max;\n    vbool1_t mask;\n    \n    size_t curr_idx = 0;\n    while (curr_idx < length) {\n        vl = vsetvl_e8m8(length - curr_idx);\n        \n        v_data = vle8_v_i8m8(&src[curr_idx], vl);\n        \n        if (curr_idx == 0) {\n            v_max = v_data;\n        } else {\n            mask = vmsgt_vx_i8m8_b1(v_data, max_val, vl);\n            if (vmany_m_b1(mask, vl)) {\n                vint8m8_t v_new_max = vmax_vv_i8m8(v_data, v_max, vl);\n                int8_t temp_max = vmv_x_s_i8m1_i8(vredmax_vs_i8m8_i8m1(v_new_max, v_new_max, vl));\n                \n                if (temp_max > max_val) {\n                    max_val = temp_max;\n                    mask = vmseq_vx_i8m8_b1(v_data, max_val, vl);\n                    vint8m8_t v_idx = vid_v_i8m8(vl);\n                    vint8m8_t v_masked_idx = vmerge_vxm_i8m8(v_data, mask, 0, v_idx, vl);\n                    max_idx = curr_idx + vmv_x_s_i8m1_i8(vredmax_vs_i8m8_i8m1(v_masked_idx, v_masked_idx, vl));\n                }\n            }\n        }\n        curr_idx += vl;\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t vl;\n    size_t index = 0;\n    int8_t max_val = src[0];\n    size_t max_idx = 0;\n    \n    vint8m8_t v_data;\n    vint8m8_t v_max;\n    vbool1_t mask;\n    \n    size_t curr_idx = 0;\n    while (curr_idx < length) {\n        vl = vsetvl_e8m8(length - curr_idx);\n        \n        v_data = vle8_v_i8m8(&src[curr_idx], vl);\n        \n        if (curr_idx == 0) {\n            v_max = v_data;\n        } else {\n            mask = vmsgt_vx_i8m8_b1(v_data, max_val, vl);\n            if (vmany_m_b1(mask, vl)) {\n                vint8m8_t v_new_max = vmax_vv_i8m8(v_data, v_max, vl);\n                int8_t temp_max = vmv_x_s_i8m8_i8(v_new_max);\n                \n                if (temp_max > max_val) {\n                    max_val = temp_max;\n                    for (size_t i = 0; i < vl; i++) {\n                        if (src[curr_idx + i] == max_val) {\n                            max_idx = curr_idx + i;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        \n        curr_idx += vl;\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t vl;\n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    \n    vint8m8_t v_data;\n    vint8m8_t v_max;\n    vbool1_t mask;\n    size_t index = 0;\n    \n    while (index < length) {\n        vl = vsetvl_e8m8(length - index);\n        \n        v_data = vle8_v_i8m8(&src[index], vl);\n        v_max = vmv_v_x_i8m8(max_val, vl);\n        \n        mask = vmsgt_vv_i8m8_b1(v_data, v_max, vl);\n        \n        if (vmany_m_b1(mask, vl)) {\n            size_t i;\n            for (i = 0; i < vl; i++) {\n                if (src[index + i] > max_val) {\n                    max_val = src[index + i];\n                    max_idx = index + i;\n                }\n            }\n        }\n        \n        index += vl;\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_RVV", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t vl;\n    size_t index = 0;\n    int8_t max_val = src[0];\n    size_t max_idx = 0;\n    \n    vint8m8_t v_max;\n    vuint64m8_t v_idx, v_max_idx;\n    \n    size_t avl = length;\n    size_t curr_idx = 0;\n    \n    // Initialize vector with first max value\n    v_max = vmv_v_x_i8m8(max_val, avl);\n    \n    while (avl > 0) {\n        vl = vsetvl_e8m8(avl);\n        \n        // Load vector of current values\n        vint8m8_t v_curr = vle8_v_i8m8(src + curr_idx, vl);\n        \n        // Create vector of indices\n        v_idx = vid_v_u64m8(vl);\n        v_idx = vadd_vx_u64m8(v_idx, curr_idx, vl);\n        \n        // Compare current values with max\n        vbool1_t mask = vmsgt_vv_i8m8_b1(v_curr, v_max, vl);\n        \n        // Update max values and indices where needed\n        v_max = vmerge_vvm_i8m8(mask, v_max, v_curr, vl);\n        v_max_idx = vmerge_vvm_u64m8(mask, v_max_idx, v_idx, vl);\n        \n        curr_idx += vl;\n        avl -= vl;\n    }\n    \n    // Find max across vector elements\n    for (size_t i = 0; i < curr_idx; i += vl) {\n        vl = vsetvl_e8m8(curr_idx - i);\n        \n        int8_t temp_max = vmv_x_s_i8m1_i8(vredmax_vs_i8m8_i8m1(v_max, v_max, vl));\n        \n        if (temp_max > max_val) {\n            max_val = temp_max;\n            vbool1_t mask = vmseq_vx_i8m8_b1(v_max, temp_max, vl);\n            size_t temp_idx = vmv_x_s_u64m1_u64(vredmin_vs_u64m8_u64m1_m(mask, v_max_idx, v_max_idx, vl));\n            max_idx = temp_idx;\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t index = 0;\n    \n    while (index < length) {\n        // Get maximum vector length for this iteration\n        vl = vsetvl_e16m8(length - index);\n        \n        // Generate index vector\n        vint32m16_t vid = vid_v_i32m16(vl);\n        vid = vadd_vx_i32m16(vid, index, vl);\n        \n        // Create mask by ANDing indices with mask value\n        vbool2_t vmask = vmseq_vx_i32m16_b2(vand_vx_i32m16(vid, mask, vl), 0, vl);\n        \n        // Load vectors\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + index, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + index, vl);\n        \n        // Blend based on mask\n        vuint16m8_t v_result = vmerge_vvm_u16m8(vmask, v_src1, v_src2, vl);\n        \n        // Store result\n        vse16_v_u16m8(dst + index, v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t index = 0;\n    \n    while (index < length) {\n        // Get maximum vector length for this iteration\n        vl = vsetvl_e16m8(length - index);\n        \n        // Generate index vector\n        vint32m16_t vid = vid_v_i32m16(vl);\n        vid = vadd_vx_i32m16(vid, index, vl);\n        \n        // Create mask by ANDing indices with mask value\n        vbool2_t vmask = vmseq_vx_i32m16_b2(vand_vx_i32m16(vid, mask, vl), 0, vl);\n        \n        // Load vectors from src1 and src2\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + index, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + index, vl);\n        \n        // Blend based on mask\n        vuint16m8_t v_result = vmerge_vvm_u16m8(vmask, v_src1, v_src2, vl);\n        \n        // Store result\n        vse16_v_u16m8(dst + index, v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t index = 0;\n    \n    while (index < length) {\n        // Get maximum vector length for this iteration\n        vl = vsetvl_e16m8(length - index);\n        \n        // Generate index vector\n        vint32m16_t vid = vid_v_i32m16(vl);\n        vint32m16_t vindex = vadd_vx_i32m16(vid, index, vl);\n        \n        // Create mask by ANDing indices with mask value\n        vbool2_t vmask = vmseq_vx_i32m16_b2(vand_vx_i32m16(vindex, mask, vl), 0, vl);\n        \n        // Load source vectors\n        vuint16m8_t vsrc1 = vle16_v_u16m8(src1 + index, vl);\n        vuint16m8_t vsrc2 = vle16_v_u16m8(src2 + index, vl);\n        \n        // Blend based on mask\n        vuint16m8_t vresult = vmerge_vvm_u16m8(vmask, vsrc1, vsrc2, vl);\n        \n        // Store result\n        vse16_v_u16m8(dst + index, vresult, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t index = 0;\n    \n    while (index < length) {\n        // Get maximum vector length for this iteration\n        vl = vsetvl_e16m8(length - index);\n        \n        // Generate vector of indices\n        vint32m16_t vid = vid_v_i32m16(vl);\n        vid = vadd_vx_i32m16(vid, index, vl);\n        \n        // Create mask by ANDing indices with mask value\n        vbool2_t vmask = vmseq_vx_i32m16_b2(vand_vx_i32m16(vid, mask, vl), 0, vl);\n        \n        // Load vectors from src1 and src2\n        vuint16m8_t v_src1 = vle16_v_u16m8(src1 + index, vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(src2 + index, vl);\n        \n        // Blend based on mask\n        vuint16m8_t v_result = vmerge_vvm_u16m8(vmask, v_src1, v_src2, vl);\n        \n        // Store result\n        vse16_v_u16m8(dst + index, v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_RVV", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t vl;\n    size_t index = 0;\n    \n    while (index < length) {\n        // Get maximum vector length for this iteration\n        vl = vsetvl_e16m8(length - index);\n        \n        // Generate index vector\n        vint32m16_t vid = vid_v_i32m16(vl);\n        vid = vadd_vx_i32m16(vid, index, vl);\n        \n        // Create mask by ANDing indices with mask value\n        vbool2_t vmask = vmseq_vx_i32m16_b2(vand_vx_i32m16(vid, mask, vl), 0, vl);\n        \n        // Load vectors from both sources\n        vuint16m8_t v_src1 = vle16_v_u16m8(&src1[index], vl);\n        vuint16m8_t v_src2 = vle16_v_u16m8(&src2[index], vl);\n        \n        // Blend based on mask\n        vuint16m8_t v_result = vmerge_vvm_u16m8(vmask, v_src1, v_src2, vl);\n        \n        // Store result\n        vse16_v_u16m8(&dst[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    vl = vsetvl_e32m8(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(src + i, vl);\n        vuint32m8_t v_count = vmv_v_x_u32m8(0, vl);\n        \n        for (int j = 0; j < 32; j++) {\n            vuint32m8_t v_bit = vand_vx_u32m8(v_input, 1, vl);\n            v_count = vadd_vv_u32m8(v_count, v_bit, vl);\n            v_input = vsrl_vx_u32m8(v_input, 1, vl);\n        }\n        \n        vse32_v_u32m8(dst + i, v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    vl = vsetvl_e32m8(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(src + i, vl);\n        vuint32m8_t v_count = vmv_v_x_u32m8(0, vl);\n        \n        for (int j = 0; j < 32; j++) {\n            vuint32m8_t v_bit = vand_vx_u32m8(v_input, 1, vl);\n            v_count = vadd_vv_u32m8(v_count, v_bit, vl);\n            v_input = vsrl_vx_u32m8(v_input, 1, vl);\n        }\n        \n        vse32_v_u32m8(dst + i, v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    vl = vsetvl_e32m8(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t v_input = vle32_v_u32m8(src + i, vl);\n        \n        vuint32m8_t v_count = vmv_v_x_u32m8(0, vl);\n        \n        for (int bit = 0; bit < 32; bit++) {\n            vuint32m8_t v_bit = vand_vx_u32m8(v_input, 1, vl);\n            v_count = vadd_vv_u32m8(v_count, v_bit, vl);\n            v_input = vsrl_vx_u32m8(v_input, 1, vl);\n        }\n        \n        vse32_v_u32m8(dst + i, v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    vl = vsetvl_e32m8(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(&src[i], vl);\n        vuint32m8_t v_count = vmv_v_x_u32m8(0, vl);\n        \n        for (int j = 0; j < 32; j++) {\n            vuint32m8_t v_bit = vand_vx_u32m8(v_input, 1, vl);\n            v_count = vadd_vv_u32m8(v_count, v_bit, vl);\n            v_input = vsrl_vx_u32m8(v_input, 1, vl);\n        }\n        \n        vse32_v_u32m8(&dst[i], v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_16_RVV", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl;\n    vl = vsetvl_e32m8(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(src + i, vl);\n        vuint32m8_t v_count = vmv_v_x_u32m8(0, vl);\n        \n        for (int j = 0; j < 32; j++) {\n            vuint32m8_t v_bit = vand_vx_u32m8(v_input, 1, vl);\n            v_count = vadd_vv_u32m8(v_count, v_bit, vl);\n            v_input = vsrl_vx_u32m8(v_input, 1, vl);\n        }\n        \n        vse32_v_u32m8(dst + i, v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    while (length > 0) {\n        vl = vsetvl_e16m8(length);\n        \n        vuint16m8_t v1 = vle16_v_u16m8(src1, vl);\n        vuint16m8_t v2 = vle16_v_u16m8(src2, vl);\n        \n        vuint16m8_t result = vsaddu_vv_u16m8(v1, v2, vl);\n        \n        vse16_v_u16m8(dst, result, vl);\n        \n        src1 += vl;\n        src2 += vl;\n        dst += vl;\n        length -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v1 = vle16_v_u16m8(&src1[i], vl);\n        vuint16m8_t v2 = vle16_v_u16m8(&src2[i], vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(v1, v2, vl);\n        vse16_v_u16m8(&dst[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v2 = vle16_v_u16m8(src2 + i, vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(v1, v2, vl);\n        vse16_v_u16m8(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t v1 = vle16_v_u16m8(src1 + i, vl);\n        vuint16m8_t v2 = vle16_v_u16m8(src2 + i, vl);\n        vuint16m8_t result = vsaddu_vv_u16m8(v1, v2, vl);\n        vse16_v_u16m8(dst + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_17_RVV", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t vl;\n    while (length > 0) {\n        vl = vsetvl_e16m8(length);\n        \n        vuint16m8_t v1 = vle16_v_u16m8(src1, vl);\n        vuint16m8_t v2 = vle16_v_u16m8(src2, vl);\n        \n        vuint16m8_t result = vsaddu_vv_u16m8(v1, v2, vl);\n        \n        vse16_v_u16m8(dst, result, vl);\n        \n        src1 += vl;\n        src2 += vl;\n        dst += vl;\n        length -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            size_t k = 0;\n            \n            vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, n);\n            \n            while (k < n) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t v_a = vle64_v_f64m8(&A[i * n + k], vl);\n                vfloat64m8_t v_b = vle64_v_f64m8(&B[k * p + j], vl);\n                \n                // Create masks for range check\n                vbool8_t mask_a = vmfge_vf_f64m8_b8(v_a, -100.0, vl);\n                mask_a = vmand_mm_b8(mask_a, vmfle_vf_f64m8_b8(v_a, 100.0, vl), vl);\n                \n                vbool8_t mask_b = vmfge_vf_f64m8_b8(v_b, -100.0, vl);\n                mask_b = vmand_mm_b8(mask_b, vmfle_vf_f64m8_b8(v_b, 100.0, vl), vl);\n                \n                // Combine masks\n                vbool8_t mask = vmand_mm_b8(mask_a, mask_b, vl);\n                \n                // Multiply and accumulate only masked elements\n                vfloat64m8_t v_prod = vfmul_vv_f64m8_m(mask, v_a, v_a, v_b, vl);\n                v_sum = vfadd_vv_f64m8(v_sum, v_prod, vl);\n                \n                k += vl;\n            }\n            \n            // Reduce vector sum\n            sum = vfredsum_vs_f64m8_f64m1(v_sum, v_sum, vfmv_v_f_f64m1(0.0, 1), n);\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl;\n    vfloat64m8_t va, vb, vc;\n    vbool8_t vmask_a, vmask_b;\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            size_t k = 0;\n            \n            while (k < n) {\n                vl = vsetvl_e64m8(n - k);\n                \n                // Load vectors\n                va = vle64_v_f64m8(&A[i * n + k], vl);\n                vb = vle64_v_f64m8(&B[k * p + j], p);\n                \n                // Create masks for range check\n                vmask_a = vfgt_vf_f64m8_b8(va, -100.0, vl);\n                vmask_a = vand_mm_b8(vmask_a, vflt_vf_f64m8_b8(va, 100.0, vl));\n                \n                vmask_b = vfgt_vf_f64m8_b8(vb, -100.0, vl); \n                vmask_b = vand_mm_b8(vmask_b, vflt_vf_f64m8_b8(vb, 100.0, vl));\n                \n                // Combine masks\n                vbool8_t vmask = vand_mm_b8(vmask_a, vmask_b);\n                \n                // Multiply under mask and accumulate\n                vc = vfmul_vv_f64m8_m(vmask, vc, va, vb, vl);\n                sum += vfredsum_vs_f64m8_f64m1(vc, vc, vfmv_s_f_f64m1(0.0, 1), vl);\n                \n                k += vl;\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m8_t vsum = vfmv_v_f_f64m8(0.0, n);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t va = vle64_v_f64m8(&A[i * n + k], vl);\n                vfloat64m8_t vb = vle64_v_f64m8(&B[k * p + j], vl);\n                \n                // Create masks for range check\n                vbool8_t vmask_a = vfgt_vf_f64m8_b8(va, -100.0, vl);\n                vmask_a = vand_mm_b8(vmask_a, vflt_vf_f64m8_b8(va, 100.0, vl));\n                \n                vbool8_t vmask_b = vfgt_vf_f64m8_b8(vb, -100.0, vl);\n                vmask_b = vand_mm_b8(vmask_b, vflt_vf_f64m8_b8(vb, 100.0, vl));\n                \n                vbool8_t vmask = vand_mm_b8(vmask_a, vmask_b);\n                \n                // Multiply elements within range and accumulate\n                vfloat64m8_t vprod = vfmul_vv_f64m8_m(vmask, vfmv_v_f_f64m8(0.0, vl), va, vb, vl);\n                vsum = vfadd_vv_f64m8(vsum, vprod, vl);\n            }\n            \n            // Reduce sum\n            double sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vfmv_v_f_f64m1(0.0, 1), vsum, 1));\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```c\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            size_t k = 0;\n            \n            vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, n);\n            \n            while (k < n) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t v_a = vle64_v_f64m8(&A[i * n + k], vl);\n                vfloat64m8_t v_b = vle64_v_f64m8(&B[k * p + j], vl);\n                \n                // Create masks for range check\n                vbool8_t mask_a = vmfge_vf_f64m8_b8(v_a, -100.0, vl);\n                mask_a = vmand_mm_b8(mask_a, vmfle_vf_f64m8_b8(v_a, 100.0, vl), vl);\n                \n                vbool8_t mask_b = vmfge_vf_f64m8_b8(v_b, -100.0, vl);\n                mask_b = vmand_mm_b8(mask_b, vmfle_vf_f64m8_b8(v_b, 100.0, vl), vl);\n                \n                // Combine masks\n                vbool8_t mask = vmand_mm_b8(mask_a, mask_b, vl);\n                \n                // Multiply and accumulate under mask\n                v_sum = vfmacc_vv_f64m8_m(mask, v_sum, v_a, v_b, vl);\n                \n                k += vl;\n            }\n            \n            // Reduce vector to scalar\n            sum = vfredsum_vs_f64m8_f64m1(v_sum, v_sum, vfmv_v_f_f64m1(0.0, 1), n);\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_RVV", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vlmax = __riscv_vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            size_t k = 0;\n            \n            vfloat64m8_t v_sum = __riscv_vfmv_v_f_f64m8(0.0, vlmax);\n            \n            for (; k + vlmax <= n; k += vlmax) {\n                vfloat64m8_t v_a = __riscv_vle64_v_f64m8(&A[i * n + k], vlmax);\n                vfloat64m8_t v_b = __riscv_vle64_v_f64m8(&B[k * p + j], vlmax);\n                \n                // Create masks for valid range [-100, 100]\n                vbool8_t mask_a = __riscv_vmfge_vf_f64m8_b8(v_a, -100.0, vlmax);\n                mask_a = __riscv_vmand_mm_b8(mask_a, __riscv_vmfle_vf_f64m8_b8(v_a, 100.0, vlmax), vlmax);\n                \n                vbool8_t mask_b = __riscv_vmfge_vf_f64m8_b8(v_b, -100.0, vlmax);\n                mask_b = __riscv_vmand_mm_b8(mask_b, __riscv_vmfle_vf_f64m8_b8(v_b, 100.0, vlmax), vlmax);\n                \n                // Combine masks\n                vbool8_t mask = __riscv_vmand_mm_b8(mask_a, mask_b, vlmax);\n                \n                // Multiply and accumulate under mask\n                vfloat64m8_t v_prod = __riscv_vfmul_vv_f64m8_m(mask, v_a, v_b, vlmax);\n                v_sum = __riscv_vfadd_vv_f64m8(v_sum, v_prod, vlmax);\n            }\n            \n            // Reduce vector sum\n            sum = __riscv_vfmv_f_s_f64m8_f64(v_sum);\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            \n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e64m8(total_size - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e64m8(total_size - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e64m8(total_size - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e64m8(total_size - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_19_RVV", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e64m8(total_size - i);\n        vint64m8_t va = vle64_v_i64m8(&A[i], vl);\n        vint64m8_t vb = vle64_v_i64m8(&B[i], vl);\n        vint64m8_t vc = vadd_vv_i64m8(va, vb, vl);\n        vse64_v_i64m8(&C[i], vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m8_t v_src1, v_src2, v_sum;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        v_src1 = vle32_v_f32m8(&src1[i], vl);\n        v_src2 = vle32_v_f32m8(&src2[i], vl);\n        \n        v_sum = vfadd_vv_f32m8(v_src1, v_src2, vl);\n        v_sum = vfround_v_f32m8(v_sum, vl);\n        \n        vse32_v_f32m8(&dst[i], v_sum, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m8_t v1, v2, vadd;\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        v1 = vle32_v_f32m8(&src1[i], vl);\n        v2 = vle32_v_f32m8(&src2[i], vl);\n        \n        vadd = vfadd_vv_f32m8(v1, v2, vl);\n        vadd = vfround_v_f32m8(vadd, vl);\n        \n        vse32_v_f32m8(&dst[i], vadd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v1, v2, vadd;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        v1 = vle32_v_f32m1(&src1[i], vl);\n        v2 = vle32_v_f32m1(&src2[i], vl);\n        \n        vadd = vfadd_vv_f32m1(v1, v2, vl);\n        vadd = vfround_v_f32m1(vadd, vl);\n        \n        vse32_v_f32m1(&dst[i], vadd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vfloat32m8_t v_src1 = vle32_v_f32m8(&src1[i], vl);\n        vfloat32m8_t v_src2 = vle32_v_f32m8(&src2[i], vl);\n        \n        vfloat32m8_t v_sum = vfadd_vv_f32m8(v_src1, v_src2, vl);\n        vfloat32m8_t v_rounded = vfround_v_f32m8(v_sum, vl);\n        \n        vse32_v_f32m8(&dst[i], v_rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_20_RVV", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m8_t v1, v2, vadd;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        v1 = vle32_v_f32m8(&src1[i], vl);\n        v2 = vle32_v_f32m8(&src2[i], vl);\n        vadd = vfadd_vv_f32m8(v1, v2, vl);\n        vadd = vfround_v_f32m8(vadd, vl);\n        vse32_v_f32m8(&dst[i], vadd, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    \n    vfloat32m1_t v_src1, v_src2;\n    vfloat32m1_t v_diff, v_mul;\n    vbool32_t mask1, mask2, mask;\n    vfloat32m1_t v_minus_one;\n    \n    while (i < length) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load vectors\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n        \n        // Calculate difference and abs\n        v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        v_diff = vfabs_v_f32m1(v_diff, vl);\n        \n        // Check if diff <= 50\n        mask1 = vmfle_vf_f32m1_b32(v_diff, 50.0f, vl);\n        \n        // Create index mask for multiples of 2\n        vuint32m1_t v_idx = vid_v_u32m1(vl);\n        v_idx = vadd_vx_u32m1(v_idx, i, vl);\n        vuint32m1_t v_rem = vand_vx_u32m1(v_idx, 1, vl);\n        mask2 = vmseq_vx_u32m1_b32(v_rem, 0, vl);\n        \n        // Combine masks\n        mask = vmand_mm_b32(mask1, mask2, vl);\n        \n        // Multiply under mask\n        v_mul = vfmul_vv_f32m1_m(mask, v_src1, v_src1, v_src2, vl);\n        \n        // Round up result\n        v_mul = vfcvt_f_x_v_f32m1_m(mask, v_mul, vfcvt_x_f_v_i32m1(v_mul, vl), vl);\n        \n        // Set -1 for unmasked elements\n        v_minus_one = vfmv_v_f_f32m1(-1.0f, vl);\n        v_mul = vmerge_vvm_f32m1(mask, v_minus_one, v_mul, vl);\n        \n        // Store result\n        vse32_v_f32m1(dst + i, v_mul, vl);\n        \n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_result;\n    vbool32_t mask1, mask2;\n    vint32m1_t v_idx;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load vectors\n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n        \n        // Create index vector\n        v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i, vl);\n        \n        // Check if index is multiple of 2\n        mask1 = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_idx, 1, vl), 1, vl);\n        \n        // Calculate absolute difference and check if within 50\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        v_diff = vfabs_v_f32m1(v_diff, vl);\n        mask2 = vmfle_vf_f32m1_b32(v_diff, 50.0f, vl);\n        \n        // Combine masks\n        mask1 = vmand_mm_b32(mask1, mask2, vl);\n        \n        // Multiply elements that meet conditions and round up\n        v_result = vfmul_vv_f32m1(v_src1, v_src2, vl);\n        v_result = vfceil_v_f32m1(v_result, vl);\n        \n        // Set -1 for elements that don't meet conditions\n        v_result = vmerge_vfm_f32m1(mask1, vfmv_v_f_f32m1(-1.0f, vl), v_result, vl);\n        \n        // Store results\n        vse32_v_f32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    \n    vfloat32m1_t v_neg_one = vfmv_v_f_f32m1(-1.0f, 1);\n    \n    while (i < length) {\n        vl = vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t v_src1 = vle32_v_f32m1(&src1[i], vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(&src2[i], vl);\n        \n        // Calculate absolute difference\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfabs_v_f32m1(v_diff, vl);\n        \n        // Check if difference is within 50\n        vbool32_t mask_diff = vmfle_vf_f32m1_b32(v_abs_diff, 50.0f, vl);\n        \n        // Check if index is multiple of 2\n        vint32m1_t v_indices = vid_v_i32m1(vl);\n        vint32m1_t v_indices_offset = vadd_vx_i32m1(v_indices, i, vl);\n        vbool32_t mask_even = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_indices_offset, 1, vl), 1, vl);\n        \n        // Combine masks\n        vbool32_t mask_final = vmand_mm_b32(mask_diff, mask_even, vl);\n        \n        // Multiply and round up for valid elements\n        vfloat32m1_t v_mul = vfmul_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_ceil = vfceil_v_f32m1(v_mul, vl);\n        \n        // Select between rounded result and -1 based on mask\n        vfloat32m1_t v_result = vmerge_vvm_f32m1(mask_final, v_neg_one, v_ceil, vl);\n        \n        // Store results\n        vse32_v_f32m1(&dst[i], v_result, vl);\n        \n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    vfloat32m1_t v_src1, v_src2, v_mul, v_result;\n    vbool32_t mask1, mask2, mask;\n    vint32m1_t v_idx;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        v_src1 = vle32_v_f32m1(src1 + i, vl);\n        v_src2 = vle32_v_f32m1(src2 + i, vl);\n        \n        // Create index vector\n        v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i, vl);\n        \n        // Check if index is multiple of 2\n        mask1 = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_idx, 1, vl), 1, vl);\n        \n        // Check if absolute difference is within 50\n        v_result = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        mask2 = vmfle_vf_f32m1_b32(vfabs_v_f32m1(v_result, vl), 50.0f, vl);\n        \n        // Combine masks\n        mask = vmand_mm_b32(mask1, mask2, vl);\n        \n        // Multiply elements that meet conditions and round up\n        v_mul = vfmul_vv_f32m1(v_src1, v_src2, vl);\n        v_mul = vfcvt_f_f_v_f32m1(vfcvt_x_f_v_f32m1(v_mul, vl, vl), vl);\n        \n        // Set -1 for elements that don't meet conditions\n        v_result = vfmv_v_f_f32m1(-1.0f, vl);\n        v_result = vmerge_vvm_f32m1(mask, v_result, v_mul, vl);\n        \n        vse32_v_f32m1(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_21_RVV", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    \n    vfloat32m1_t v_minus_one = vfmv_v_f_f32m1(-1.0f, 1);\n    \n    while (i < length) {\n        vl = vsetvl_e32m1(length - i);\n        \n        vfloat32m1_t v_src1 = vle32_v_f32m1(src1 + i, vl);\n        vfloat32m1_t v_src2 = vle32_v_f32m1(src2 + i, vl);\n        \n        // Calculate absolute difference\n        vfloat32m1_t v_diff = vfsub_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_abs_diff = vfabs_v_f32m1(v_diff, vl);\n        \n        // Check if difference is within 50\n        vbool32_t mask_diff = vmfle_vf_f32m1_b32(v_abs_diff, 50.0f, vl);\n        \n        // Create index mask for multiples of 2\n        vuint32m1_t v_idx = vid_v_u32m1(vl);\n        vuint32m1_t v_idx_offset = vadd_vx_u32m1(v_idx, i, vl);\n        vbool32_t mask_idx = vmseq_vx_u32m1_b32(vand_vx_u32m1(v_idx_offset, 1, vl), 0, vl);\n        \n        // Combine masks\n        vbool32_t mask_final = vmand_mm_b32(mask_diff, mask_idx, vl);\n        \n        // Multiply and round up for valid elements\n        vfloat32m1_t v_mul = vfmul_vv_f32m1(v_src1, v_src2, vl);\n        vfloat32m1_t v_ceil = vfceil_v_f32m1(v_mul, vl);\n        \n        // Select between -1 and computed result based on mask\n        vfloat32m1_t v_result = vmerge_vvm_f32m1(mask_final, v_minus_one, v_ceil, vl);\n        \n        // Store results\n        vse32_v_f32m1(dst + i, v_result, vl);\n        \n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total = m * n;\n    size_t index = 0;\n\n    while (index < total) {\n        vl = vsetvl_e64m8(total - index);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[index], vl);\n        vfloat64m8_t v_result = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse64_v_f64m8(&dst[index], v_result, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[index], vl);\n        vfloat64m8_t v_result = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse64_v_f64m8(&dst[index], v_result, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[index], vl);\n        vfloat64m8_t v_result = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse64_v_f64m8(&dst[index], v_result, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total = m * n;\n    size_t index = 0;\n    \n    while (index < total) {\n        vl = vsetvl_e64m8(total - index);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[index], vl);\n        vfloat64m8_t v_result = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse64_v_f64m8(&dst[index], v_result, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_22_RVV", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v_mat = vle64_v_f64m8(&mat[index], vl);\n        vfloat64m8_t v_result = vfmul_vf_f64m8(v_mat, scalar, vl);\n        vse64_v_f64m8(&dst[index], v_result, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m8_t v_row;\n    vfloat32m1_t v_sum;\n    \n    for (size_t i = 0; i < m; i++) {\n        float row_sum = 0.0f;\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares for the row\n        v_sum = vfmv_v_f_f32m1(0.0f, 1);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m8(n - j);\n            v_row = vle32_v_f32m8(row + j, vl);\n            v_sum = vfredosum_vs_f32m8_f32m1(v_sum, vfmul_vv_f32m8(v_row, v_row, vl), v_sum, vl);\n        }\n        \n        float l2_norm = sqrt(vfmv_f_s_f32m1_f32(v_sum));\n\n        // Normalize the row\n        for (size_t j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m8(n - j);\n            v_row = vle32_v_f32m8(row + j, vl);\n            v_row = vfdiv_vf_f32m8(v_row, l2_norm, vl);\n            vse32_v_f32m8(row + j, v_row, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, 1);\n        size_t j;\n        \n        for (j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t v_row = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t v_square = vfmul_vv_f32m1(v_row, v_row, vl);\n            v_sum = vfredsum_vs_f32m1_f32m1(v_square, v_sum, vl);\n        }\n        \n        // Get L2 norm\n        float sum = vfmv_f_s_f32m1_f32(v_sum);\n        float norm = sqrtf(sum);\n        \n        // Normalize row elements\n        vfloat32m1_t v_norm = vfmv_v_f_f32m1(norm, 1);\n        \n        for (j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t v_row = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t v_normalized = vfdiv_vf_f32m1(v_row, norm, vl);\n            vse32_v_f32m1(row + j, v_normalized, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl;\n    float* row;\n    \n    for (size_t i = 0; i < m; i++) {\n        row = mat + i * n;\n        \n        // Calculate sum of squares\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, 1);\n        \n        size_t j = 0;\n        while (j < n) {\n            vl = vsetvl_e32m8(n - j);\n            \n            vfloat32m8_t v_row = vle32_v_f32m8(row + j, vl);\n            vfloat32m8_t v_square = vfmul_vv_f32m8(v_row, v_row, vl);\n            \n            v_sum = vfredsum_vs_f32m8_f32m1(v_sum, v_square, v_sum, vl);\n            \n            j += vl;\n        }\n        \n        // Calculate L2 norm\n        float sum = vfmv_f_s_f32m1_f32(v_sum);\n        float norm = 1.0f / sqrtf(sum);\n        \n        // Normalize row\n        j = 0;\n        while (j < n) {\n            vl = vsetvl_e32m8(n - j);\n            \n            vfloat32m8_t v_row = vle32_v_f32m8(row + j, vl);\n            vfloat32m8_t v_normalized = vfmul_vf_f32m8(v_row, norm, vl);\n            \n            vse32_v_f32m8(row + j, v_normalized, vl);\n            \n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, 1);\n        size_t j;\n        \n        for (j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t v_elements = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t v_squared = vfmul_vv_f32m1(v_elements, v_elements, vl);\n            v_sum = vfadd_vv_f32m1(v_sum, v_squared, vl);\n        }\n        \n        // Reduce sum\n        float sum = vfmv_f_s_f32m1_f32(vfredsum_vs_f32m1_f32m1(v_sum, v_sum, v_sum, vl));\n        \n        // Calculate L2 norm\n        float norm = sqrtf(sum);\n        \n        // Normalize row elements\n        vfloat32m1_t v_norm = vfmv_v_f_f32m1(norm, 1);\n        \n        for (j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t v_elements = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t v_normalized = vfdiv_vv_f32m1(v_elements, v_norm, vl);\n            vse32_v_f32m1(row + j, v_normalized, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_RVV", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate sum of squares\n        vfloat32m1_t v_sum = vfmv_v_f_f32m1(0.0f, 1);\n        size_t j;\n        \n        for (j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t v_row = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t v_square = vfmul_vv_f32m1(v_row, v_row, vl);\n            v_sum = vfredsum_vs_f32m1_f32m1(v_square, v_sum, vl);\n        }\n        \n        // Get L2 norm\n        float norm = sqrtf(vfmv_f_s_f32m1_f32(v_sum));\n        \n        // Normalize row elements\n        vfloat32m1_t v_norm = vfmv_v_f_f32m1(norm, 1);\n        \n        for (j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            vfloat32m1_t v_row = vle32_v_f32m1(row + j, vl);\n            vfloat32m1_t v_normalized = vfdiv_vf_f32m1(v_row, norm, vl);\n            vse32_v_f32m1(row + j, v_normalized, vl);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m8_t vacc = vfmv_v_f_f64m8(0.0, n);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t v1 = vle64_v_f64m8(&mat1[i * n + k], vl);\n                vfloat64m8_t v2 = vle64_v_f64m8(&mat2[k * p + j], vl);\n                \n                vacc = vfmacc_vv_f64m8(vacc, v1, v2, vl);\n            }\n            \n            double sum = vfredsum_vs_f64m8_f64m1(vacc, vacc, vl);\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m8_t vacc = vfmv_v_f_f64m8(0.0, n);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t vx = vle64_v_f64m8(&mat1[i * n + k], vl);\n                vfloat64m8_t vy = vle64_v_f64m8(&mat2[k * p + j], vl);\n                \n                vacc = vfmacc_vv_f64m8(vacc, vx, vy, vl);\n            }\n            \n            double sum = vfredsum_vs_f64m8_f64m1(vacc, vacc, vl);\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m8_t vacc = vfmv_v_f_f64m8(0.0, n);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t v1 = vle64_v_f64m8(&mat1[i * n + k], vl);\n                vfloat64m8_t v2 = vle64_v_f64m8(&mat2[k * p + j], vl);\n                \n                vacc = vfmacc_vv_f64m8(vacc, v1, v2, vl);\n            }\n            \n            double sum = vfredsum_vs_f64m8_f64m1(vacc, vacc, vl);\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m8_t vacc = vfmv_v_f_f64m8(0.0, n);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t va = vle64_v_f64m8(&mat1[i * n + k], vl);\n                vfloat64m8_t vb = vle64_v_f64m8(&mat2[k * p + j], vl);\n                \n                vacc = vfmacc_vv_f64m8(vacc, va, vb, vl);\n            }\n            \n            double sum = vfredsum_vs_f64m8_f64m1(vacc, vacc, vl);\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_RVV", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            vfloat64m8_t vacc = vfmv_v_f_f64m8(0.0, n);\n            \n            for (size_t k = 0; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                \n                vfloat64m8_t vx = vle64_v_f64m8(&mat1[i * n + k], vl);\n                vfloat64m8_t vy = vle64_v_f64m8(&mat2[k * p + j], vl);\n                \n                vacc = vfmacc_vv_f64m8(vacc, vx, vy, vl);\n            }\n            \n            double sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vfmv_v_f_f64m1(0.0, 1), vacc, vfmv_v_f_f64m1(0.0, 1), n));\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    const float quarter = 4.0f;\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            // Get vector length for this iteration\n            vl = vsetvl_e32m8(cols - j);\n            \n            // Load vector from source matrix\n            vfloat32m8_t v_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            \n            // Multiply by 4 to convert to quarters\n            vfloat32m8_t v_quarters = vfmul_vf_f32m8(v_src, quarter, vl);\n            \n            // Round to nearest integer\n            vfloat32m8_t v_rounded = vfround_v_f32m8(v_quarters, vl);\n            \n            // Divide by 4 to get back to original scale\n            vfloat32m8_t v_result = vfmul_vf_f32m8(v_rounded, 0.25f, vl);\n            \n            // Store transposed result\n            for (size_t k = 0; k < vl; k++) {\n                dst[j * rows + i] = vfmv_f_s_f32m1_f32(vget_f32m1_f32m8(v_result, k));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    const float quarter = 4.0f;\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            // Get vector length for this iteration\n            vl = vsetvl_e32m8(cols - j);\n            \n            // Load vector from source matrix\n            vfloat32m8_t v_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            \n            // Multiply by 4 to convert to quarters\n            vfloat32m8_t v_quarters = vfmul_vf_f32m8(v_src, quarter, vl);\n            \n            // Round to nearest integer\n            vfloat32m8_t v_rounded = vfcvt_f_x_v_f32m8(vfcvt_x_f_v_i32m8(v_quarters, vl), vl);\n            \n            // Divide by 4 to get back to original scale\n            vfloat32m8_t v_result = vfmul_vf_f32m8(v_rounded, 0.25f, vl);\n            \n            // Store transposed result\n            for (size_t k = 0; k < vl; k++) {\n                dst[j * rows + i] = vfmv_f_s_f32m1_f32(vget_f32m1_f32m8(v_result, k));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    const float quarter = 4.0f;\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m8(cols - j);\n            \n            // Load vector from source matrix row\n            vfloat32m8_t v_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            \n            // Multiply by 4 to convert to quarters\n            vfloat32m8_t v_quarters = vfmul_vf_f32m8(v_src, quarter, vl);\n            \n            // Round to nearest integer\n            vfloat32m8_t v_rounded = vfround_v_f32m8(v_quarters, vl);\n            \n            // Divide by 4 to convert back to original scale\n            vfloat32m8_t v_result = vfdiv_vf_f32m8(v_rounded, quarter, vl);\n            \n            // Store transposed - each element goes to corresponding column\n            for (size_t k = 0; k < vl; k++) {\n                dst[(j + k) * rows + i] = vfmv_f_s_f32m1_f32(vget_f32m8_f32m1(v_result, k));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    const float quarter = 4.0f;\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            // Get vector length for this iteration\n            vl = vsetvl_e32m8(cols - j);\n            \n            // Load vector from source matrix\n            vfloat32m8_t v_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            \n            // Multiply by 4 to convert to quarters\n            vfloat32m8_t v_quarters = vfmul_vf_f32m8(v_src, quarter, vl);\n            \n            // Round to nearest integer\n            vfloat32m8_t v_rounded = vfround_v_f32m8(v_quarters, vl);\n            \n            // Divide by 4 to get back to original scale\n            vfloat32m8_t v_result = vfdiv_vf_f32m8(v_rounded, quarter, vl);\n            \n            // Store transposed result\n            for (size_t k = 0; k < vl; k++) {\n                dst[j * rows + i] = vfmv_f_s_f32m1_f32(vget_f32m8_f32m1(v_result, k));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_RVV", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl;\n    const float quarter = 4.0f;\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += vl) {\n            // Get vector length for this iteration\n            vl = vsetvl_e32m8(cols - j);\n            \n            // Load vector from source matrix\n            vfloat32m8_t v_src = vle32_v_f32m8(&src[i * cols + j], vl);\n            \n            // Multiply by 4 to convert to quarters\n            vfloat32m8_t v_quarters = vfmul_vf_f32m8(v_src, quarter, vl);\n            \n            // Round to nearest integer\n            vfloat32m8_t v_rounded = vfround_v_f32m8(v_quarters, vl);\n            \n            // Divide by 4 to get back to original scale\n            vfloat32m8_t v_result = vfdiv_vf_f32m8(v_rounded, quarter, vl);\n            \n            // Store transposed - each element goes to (j,i) instead of (i,j)\n            for (size_t k = 0; k < vl; k++) {\n                dst[(j + k) * rows + i] = vfmv_f_s_f32m1_f32(vget_f32m8_f32m1(v_result, k));\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vfloat32m8_t v1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v2 = vle32_v_f32m8(&tensor2[i], vl);\n        \n        // Perform subtraction\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(v1, v2, vl);\n        \n        // Round towards zero\n        vfloat32m8_t vrounded = vfcvt_rtz_x_f_v_f32m8(vdiff, vl);\n        \n        // Store result\n        vse32_v_f32m8(&dst[i], vrounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vfloat32m8_t v1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v2 = vle32_v_f32m8(&tensor2[i], vl);\n        \n        // Perform subtraction\n        vfloat32m8_t diff = vfsub_vv_f32m8(v1, v2, vl);\n        \n        // Round towards zero\n        vfloat32m8_t rounded = vfcvt_rtz_x_f_v_f32m8(diff, vl);\n        \n        // Store result\n        vse32_v_f32m8(&dst[i], rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vfloat32m8_t v1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v2 = vle32_v_f32m8(&tensor2[i], vl);\n        \n        // Perform subtraction\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(v1, v2, vl);\n        \n        // Round towards zero by truncating\n        vfloat32m8_t vresult = vfcvt_rtz_x_f_v_f32m8(vdiff, vl);\n        \n        // Store result\n        vse32_v_f32m8(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vfloat32m8_t v1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v2 = vle32_v_f32m8(&tensor2[i], vl);\n        \n        // Perform subtraction\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(v1, v2, vl);\n        \n        // Round towards zero by truncating\n        vfloat32m8_t vresult = vfcvt_rtz_x_f_v_f32m8(vdiff, vl);\n        \n        // Store result\n        vse32_v_f32m8(&dst[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_26_RVV", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vfloat32m8_t v1 = vle32_v_f32m8(&tensor1[i], vl);\n        vfloat32m8_t v2 = vle32_v_f32m8(&tensor2[i], vl);\n        \n        // Perform subtraction\n        vfloat32m8_t diff = vfsub_vv_f32m8(v1, v2, vl);\n        \n        // Round towards zero by truncating\n        vfloat32m8_t rounded = vfcvt_rtz_x_f_v_f32m8(diff, vl);\n        \n        // Store result\n        vse32_v_f32m8(&dst[i], rounded, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v1 = vle64_v_f64m8(&mat1[index], vl);\n        vfloat64m8_t v2 = vle64_v_f64m8(&mat2[index], vl);\n        vfloat64m8_t vd = vfmul_vv_f64m8(v1, v2, vl);\n        vse64_v_f64m8(&dst[index], vd, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v1 = vle64_v_f64m8(&mat1[index], vl);\n        vfloat64m8_t v2 = vle64_v_f64m8(&mat2[index], vl);\n        vfloat64m8_t vdst = vfmul_vv_f64m8(v1, v2, vl);\n        vse64_v_f64m8(&dst[index], vdst, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v1 = vle64_v_f64m8(&mat1[index], vl);\n        vfloat64m8_t v2 = vle64_v_f64m8(&mat2[index], vl);\n        vfloat64m8_t vd = vfmul_vv_f64m8(v1, v2, vl);\n        vse64_v_f64m8(&dst[index], vd, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v1 = vle64_v_f64m8(&mat1[index], vl);\n        vfloat64m8_t v2 = vle64_v_f64m8(&mat2[index], vl);\n        vfloat64m8_t vd = vfmul_vv_f64m8(v1, v2, vl);\n        vse64_v_f64m8(&dst[index], vd, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_27_RVV", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t v1 = vle64_v_f64m8(&mat1[index], vl);\n        vfloat64m8_t v2 = vle64_v_f64m8(&mat2[index], vl);\n        vfloat64m8_t vd = vfmul_vv_f64m8(v1, v2, vl);\n        vse64_v_f64m8(&dst[index], vd, vl);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, 1);\n    \n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t v_sum = v_zero;\n        \n        size_t j = 0;\n        while (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t v_mat = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t v_vec = vle32_v_f32m1(&vec[j], vl);\n            \n            v_sum = vfmacc_vv_f32m1(v_sum, v_mat, v_vec, vl);\n            \n            j += vl;\n        }\n        \n        dst[i] = vfredsum_vs_f32m1_f32m1(v_sum, v_sum, v_zero, n);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, 1);\n    \n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t v_sum = v_zero;\n        \n        size_t j = 0;\n        while (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t v_mat = vle32_v_f32m1(&mat[i * n + j], vl);\n            vfloat32m1_t v_vec = vle32_v_f32m1(&vec[j], vl);\n            \n            v_sum = vfmacc_vv_f32m1(v_sum, v_mat, v_vec, vl);\n            \n            j += vl;\n        }\n        \n        dst[i] = vfredsum_vs_f32m1_f32m1(v_sum, v_sum, v_zero, n);\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        vfloat32m1_t sum = vfmv_v_f_f32m1(0.0f, 1);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m1(n - j);\n            \n            vfloat32m1_t v_vec = vle32_v_f32m1(&vec[j], vl);\n            vfloat32m1_t v_mat = vle32_v_f32m1(&mat[i * n + j], vl);\n            \n            vfloat32m1_t v_mul = vfmul_vv_f32m1(v_mat, v_vec, vl);\n            sum = vfadd_vv_f32m1(sum, v_mul, vl);\n        }\n        \n        dst[i] = vfmv_f_s_f32m1_f32(vfredusum_vs_f32m1_f32m1(sum, sum, vfmv_v_f_f32m1(0.0f, 1), 1));\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        vfloat32m8_t v_sum = vfmv_v_f_f32m8(0.0f, n);\n        \n        for (size_t j = 0; j < n; j += vl) {\n            vl = vsetvl_e32m8(n - j);\n            vfloat32m8_t v_mat = vle32_v_f32m8(&mat[i * n + j], vl);\n            vfloat32m8_t v_vec = vle32_v_f32m8(&vec[j], vl);\n            v_sum = vfmacc_vv_f32m8(v_sum, v_mat, v_vec, vl);\n        }\n        \n        sum = vfredsum_vs_f32m8_f32m1(v_sum, v_sum, vl);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_RVV", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl;\n    vfloat32m1_t v_sum;\n    vfloat32m1_t v_vec;\n    vfloat32m1_t v_mat;\n\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        v_sum = vfmv_v_f_f32m1(0.0f, 1);\n        \n        size_t j = 0;\n        while (j < n) {\n            vl = vsetvl_e32m1(n - j);\n            v_vec = vle32_v_f32m1(&vec[j], vl);\n            v_mat = vle32_v_f32m1(&mat[i * n + j], vl);\n            v_sum = vfmacc_vv_f32m1(v_sum, v_vec, v_mat, vl);\n            j += vl;\n        }\n        \n        sum = vfredsum_vs_f32m1_f32m1(v_sum, v_sum, vl);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t vlen = __riscv_vsetvlmax_e64m8();\n    vfloat64m8_t vsum = __riscv_vfmv_v_f_f64m8(0.0, vlen);\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        size_t vl = __riscv_vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vmat = __riscv_vle64_v_f64m8(&mat[index], vl);\n        vsum = __riscv_vfadd_vv_f64m8(vsum, vmat, vl);\n        index += vl;\n    }\n\n    double sum = __riscv_vfmv_f_s_f64m1_f64(__riscv_vfredsum_vs_f64m8_f64m1(\n        __riscv_vfmv_v_f_f64m1(0.0, 1), vsum, __riscv_vfmv_v_f_f64m1(0.0, 1), vlen));\n\n    return sum / (double)(m * n);\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t vlen = __riscv_vsetvlmax_e64m8();\n    vfloat64m8_t vsum = __riscv_vfmv_v_f_f64m8(0.0, vlen);\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        size_t vl = __riscv_vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vmat = __riscv_vle64_v_f64m8(&mat[index], vl);\n        vsum = __riscv_vfadd_vv_f64m8(vsum, vmat, vl);\n        index += vl;\n    }\n\n    double sum = __riscv_vfmv_f_s_f64m1_f64(__riscv_vfredsum_vs_f64m8_f64m1(\n        __riscv_vfmv_v_f_f64m1(0.0, 1),\n        vsum,\n        1\n    ));\n\n    return sum / (double)(m * n);\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t vlen = __riscv_vsetvlmax_e64m8();\n    vfloat64m8_t vsum = __riscv_vfmv_v_f_f64m8(0.0, vlen);\n    size_t total_elements = m * n;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        size_t vl = __riscv_vsetvl_e64m8(total_elements - index);\n        vfloat64m8_t vmat = __riscv_vle64_v_f64m8(&mat[index], vl);\n        vsum = __riscv_vfadd_vv_f64m8(vsum, vmat, vl);\n        index += vl;\n    }\n\n    double sum = __riscv_vfmv_f_s_f64m1_f64(__riscv_vfredsum_vs_f64m8_f64m1(\n        __riscv_vfmv_v_f_f64m1(0.0, 1),\n        vsum,\n        1\n    ));\n\n    return sum / (double)(m * n);\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    size_t vl;\n    vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, vsetvlmax_e64m8());\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_elements = vle64_v_f64m8(&mat[i], vl);\n        v_sum = vfadd_vv_f64m8(v_sum, v_elements, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vfmv_s_f_f64m1(vfmv_v_f_f64m1(0.0, 1), 0.0), v_sum, vsetvlmax_e64m8()));\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_RVV", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t vl;\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    vfloat64m8_t v_sum;\n    \n    v_sum = vfmv_v_f_f64m8(0.0, vsetvlmax_e64m8());\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e64m8(total_elements - i);\n        vfloat64m8_t v_elements = vle64_v_f64m8(&mat[i], vl);\n        v_sum = vfadd_vv_f64m8(v_sum, v_elements, vl);\n    }\n    \n    sum = vfredsum_vs_f64m8_f64m1(v_sum, v_sum, vsetvl_e64m8(1));\n    \n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        size_t vl;\n        vint32m1_t v1, v2;\n        vbool32_t mask;\n        bool row_sorted = true;\n        \n        for (size_t j = 0; j < cols-1; j += vl) {\n            vl = vsetvl_e32m1(cols-1-j);\n            \n            v1 = vle32_v_i32m1(row + j, vl);\n            v2 = vle32_v_i32m1(row + j + 1, vl);\n            \n            if (ascending) {\n                mask = vmsle_vv_i32m1_b32(v1, v2, vl);\n            } else {\n                mask = vmsge_vv_i32m1_b32(v1, v2, vl);\n            }\n            \n            if (!vmand_m_b32(mask, vl)) {\n                row_sorted = false;\n                break;\n            }\n        }\n        \n        if (!row_sorted) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        for (size_t j = 0; j < cols-1; j += vl) {\n            vl = vsetvl_e32m8(cols-1-j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask;\n            if (ascending) {\n                mask = vmsle_vv_i32m8_b4(v1, v2, vl);\n            } else {\n                mask = vmsge_vv_i32m8_b4(v1, v2, vl);\n            }\n            \n            if (!vmandnot_mm_b4(mask, mask, vl)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        for (size_t j = 0; j < cols-1; j += vl) {\n            vl = vsetvl_e32m8(cols-1-j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask;\n            if (ascending) {\n                mask = vmsle_vv_i32m8_b4(v1, v2, vl);\n            } else {\n                mask = vmsge_vv_i32m8_b4(v1, v2, vl);\n            }\n            \n            if (!vmandnot_mm_b4(mask, mask, vl)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        size_t j = 0;\n        while (j < cols - 1) {\n            vl = vsetvl_e32m8(cols - 1 - j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask;\n            if (ascending) {\n                mask = vmsgt_vv_i32m8_b4(v1, v2, vl);\n            } else {\n                mask = vmslt_vv_i32m8_b4(v1, v2, vl);\n            }\n            \n            if (vmany_m_b4(mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_30_RVV", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        for (size_t j = 0; j < cols-1; j += vl) {\n            vl = vsetvl_e32m8(cols-1-j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask;\n            if (ascending) {\n                mask = vmsle_vv_i32m8_b4(v1, v2, vl);\n            } else {\n                mask = vmsge_vv_i32m8_b4(v1, v2, vl);\n            }\n            \n            if (!vmandnot_mm_b4(mask, mask, vl)) {\n                result = false;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m8_t v_src;\n    vint16m8_t v_dst;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        \n        // Load source vector\n        v_src = vle16_v_i16m8(src + i, vl);\n        \n        // Divide by base\n        v_dst = vdiv_vx_i16m8(v_src, base, vl);\n        \n        // Multiply back by base to get nearest multiple\n        v_dst = vmul_vx_i16m8(v_dst, base, vl);\n        \n        // Store result\n        vse16_v_i16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m8_t v_src;\n    vint16m8_t v_dst;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        \n        // Load vector\n        v_src = vle16_v_i16m8(src + i, vl);\n        \n        // Divide by base\n        v_dst = vdiv_vx_i16m8(v_src, base, vl);\n        \n        // Multiply back by base\n        v_dst = vmul_vx_i16m8(v_dst, base, vl);\n        \n        // Store result\n        vse16_v_i16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m8_t v_src;\n    vint16m8_t v_dst;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        \n        // Load vector\n        v_src = vle16_v_i16m8(src + i, vl);\n        \n        // Divide by base\n        v_dst = vdiv_vx_i16m8(v_src, base, vl);\n        \n        // Multiply back by base to get nearest multiple\n        v_dst = vmul_vx_i16m8(v_dst, base, vl);\n        \n        // Store result\n        vse16_v_i16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m8_t v_src, v_dst;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        \n        // Load source vector\n        v_src = vle16_v_i16m8(src + i, vl);\n        \n        // Divide by base\n        v_dst = vdiv_vx_i16m8(v_src, base, vl);\n        \n        // Multiply back by base to get nearest multiple\n        v_dst = vmul_vx_i16m8(v_dst, base, vl);\n        \n        // Store result\n        vse16_v_i16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_31_RVV", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t vl;\n    vint16m8_t v_src;\n    vint16m8_t v_dst;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        \n        // Load vector\n        v_src = vle16_v_i16m8(src + i, vl);\n        \n        // Divide by base\n        v_dst = vdiv_vx_i16m8(v_src, base, vl);\n        \n        // Multiply back by base to get nearest multiple\n        v_dst = vmul_vx_i16m8(v_dst, base, vl);\n        \n        // Store result\n        vse16_v_i16m8(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl;\n    bool found = false;\n    \n    for (size_t i = 0; i < rows && !found; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            \n            vfloat64m8_t v_row = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t v_vec = vle64_v_f64m8(vector + j, vl);\n            \n            vbool8_t v_cmp = vmfeq_vv_f64m8_b8(v_row, v_vec, vl);\n            \n            if (!vmandfs_m_b8(v_cmp, vl)) {\n                row_match = false;\n                break;\n            }\n            \n            j += vl;\n        }\n        \n        if (row_match) {\n            found = true;\n        }\n    }\n    \n    return found;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl;\n    bool found = false;\n    \n    for (size_t i = 0; i < rows && !found; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            \n            vfloat64m8_t v_row = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t v_vec = vle64_v_f64m8(vector + j, vl);\n            \n            vbool8_t v_cmp = vmfeq_vv_f64m8_b8(v_row, v_vec, vl);\n            \n            if (!vmandfs_m_b8(v_cmp, vl)) {\n                row_match = false;\n                break;\n            }\n            \n            j += vl;\n        }\n        \n        if (row_match) {\n            found = true;\n        }\n    }\n    \n    return found;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl;\n    bool found = false;\n    \n    for (size_t i = 0; i < rows && !found; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            \n            vfloat64m8_t v_row = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t v_vec = vle64_v_f64m8(vector + j, vl);\n            \n            vbool8_t v_mask = vmfeq_vv_f64m8_b8(v_row, v_vec, vl);\n            \n            if (!vmand_m_b8(v_mask, vl)) {\n                row_match = false;\n                break;\n            }\n            \n            j += vl;\n        }\n        \n        if (row_match) {\n            found = true;\n        }\n    }\n    \n    return found;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl;\n    bool found = false;\n    \n    for (size_t i = 0; i < rows && !found; i++) {\n        bool row_match = true;\n        size_t j = 0;\n        \n        vfloat64m8_t v_row, v_vec;\n        vbool8_t v_cmp;\n        \n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            \n            v_row = vle64_v_f64m8(&matrix[i * cols + j], vl);\n            v_vec = vle64_v_f64m8(&vector[j], vl);\n            \n            v_cmp = vmfeq_vv_f64m8_b8(v_row, v_vec, vl);\n            \n            if (!vmand_m_b8(v_cmp, vl)) {\n                row_match = false;\n                break;\n            }\n            \n            j += vl;\n        }\n        \n        if (row_match) {\n            found = true;\n        }\n    }\n    \n    return found;\n}\n```"}
{"task_id": "SimdBench_32_RVV", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl;\n    bool found = false;\n    \n    for (size_t i = 0; i < rows && !found; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        size_t j = 0;\n        while (j < cols) {\n            vl = vsetvl_e64m8(cols - j);\n            \n            vfloat64m8_t v_row = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t v_vec = vle64_v_f64m8(vector + j, vl);\n            \n            vbool8_t v_mask = vmfeq_vv_f64m8_b8(v_row, v_vec, vl);\n            \n            if (!vmand_m_b8(v_mask, vl)) {\n                row_match = false;\n                break;\n            }\n            \n            j += vl;\n        }\n        \n        if (row_match) {\n            found = true;\n        }\n    }\n    \n    return found;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n    \n    vint8m1_t v_a, v_b;\n    vbool8_t v_mask;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e8m1(total_size - i);\n        \n        v_a = vle8_v_i8m1(&A[i], vl);\n        v_b = vle8_v_i8m1(&B[i], vl);\n        \n        v_mask = vmseq_vv_i8m1_b8(v_a, v_b, vl);\n        count += vcpop_m_b8(v_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n    \n    vint8m8_t v_a, v_b;\n    vbool1_t vmask;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e8m8(total_size - i);\n        \n        v_a = vle8_v_i8m8(A + i, vl);\n        v_b = vle8_v_i8m8(B + i, vl);\n        \n        vmask = vmseq_vv_i8m8_b1(v_a, v_b, vl);\n        count += vcpop_m_b1(vmask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n    \n    vint8m8_t v_a, v_b;\n    vbool1_t vmask;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e8m8(total_size - i);\n        \n        v_a = vle8_v_i8m8(&A[i], vl);\n        v_b = vle8_v_i8m8(&B[i], vl);\n        \n        vmask = vmseq_vv_i8m8_b1(v_a, v_b, vl);\n        count += vcpop_m_b1(vmask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n    \n    vint8m1_t v_a, v_b;\n    vbool8_t v_mask;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e8m1(total_size - i);\n        \n        v_a = vle8_v_i8m1(&A[i], vl);\n        v_b = vle8_v_i8m1(&B[i], vl);\n        \n        v_mask = vmseq_vv_i8m1_b8(v_a, v_b, vl);\n        count += vcpop_m_b8(v_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_RVV", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t vl;\n    \n    vint8m8_t v_a, v_b;\n    vbool1_t vmask;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e8m8(total_size - i);\n        \n        v_a = vle8_v_i8m8(A + i, vl);\n        v_b = vle8_v_i8m8(B + i, vl);\n        \n        vmask = vmseq_vv_i8m8_b1(v_a, v_b, vl);\n        count += vcpop_m_b1(vmask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        // Load vectors\n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n        \n        // Multiply scalar a with vector x\n        vx = vmul_vx_i64m8(vx, a, vl);\n        \n        // Get absolute value of y\n        vy = vabs_v_i64m8(vy, vl);\n        \n        // Subtract abs(y) from a*x\n        vres = vsub_vv_i64m8(vx, vy, vl);\n        \n        // Store result\n        vse64_v_i64m8(y + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n        \n        // Multiply scalar a with vector x\n        vx = vmul_vx_i64m8(vx, a, vl);\n        \n        // Get absolute value of y\n        vy = vabs_v_i64m8(vy, vl);\n        \n        // Subtract abs(y) from a*x\n        vres = vsub_vv_i64m8(vx, vy, vl);\n        \n        // Store result\n        vse64_v_i64m8(y + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vres;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n        \n        // Multiply scalar a with vector x\n        vx = vmul_vx_i64m8(vx, a, vl);\n        \n        // Get absolute value of y\n        vy = vabs_v_i64m8(vy, vl);\n        \n        // Subtract abs(y) from a*x\n        vres = vsub_vv_i64m8(vx, vy, vl);\n        \n        // Store result\n        vse64_v_i64m8(y + i, vres, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vz;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        // Load vectors\n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n        \n        // Multiply scalar a with vector x\n        vx = vmul_vx_i64m8(vx, a, vl);\n        \n        // Get absolute value of y\n        vy = vabs_v_i64m8(vy, vl);\n        \n        // Subtract abs(y) from a*x\n        vz = vsub_vv_i64m8(vx, vy, vl);\n        \n        // Store result\n        vse64_v_i64m8(y + i, vz, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_34_RVV", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl;\n    vint64m8_t vx, vy, vz;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        \n        vx = vle64_v_i64m8(x + i, vl);\n        vy = vle64_v_i64m8(y + i, vl);\n        \n        // Multiply scalar a with vector x\n        vz = vmul_vx_i64m8(vx, a, vl);\n        \n        // Take absolute value of y\n        vy = vabs_v_i64m8(vy, vl);\n        \n        // Subtract abs(y) from a*x\n        vz = vsub_vv_i64m8(vz, vy, vl);\n        \n        // Store result\n        vse64_v_i64m8(y + i, vz, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    vint16m8_t v_vec;\n    vint16m1_t v_min, v_max;\n    \n    // Initialize min/max with first element\n    v_min = __riscv_vmv_v_x_i16m1(vec[0], 1);\n    v_max = __riscv_vmv_v_x_i16m1(vec[0], 1);\n    \n    // Process vector elements\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m8(length - i);\n        v_vec = __riscv_vle16_v_i16m8(&vec[i], vl);\n        \n        v_min = __riscv_vredmin_vs_i16m8_i16m1(v_vec, v_min, vl);\n        v_max = __riscv_vredmax_vs_i16m8_i16m1(v_vec, v_max, vl);\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(v_min);\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(v_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl;\n    vint16m8_t v_vec;\n    vint16m1_t v_min, v_max;\n    \n    // Initialize min/max with first vector values\n    vl = vsetvl_e16m8(length);\n    v_vec = vle16_v_i16m8(vec, vl);\n    v_min = vredmin_vs_i16m8_i16m1(v_vec, v_vec, vl);\n    v_max = vredmax_vs_i16m8_i16m1(v_vec, v_vec, vl);\n    \n    // Process remaining elements\n    for (size_t i = vl; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        v_vec = vle16_v_i16m8(vec + i, vl);\n        v_min = vredmin_vs_i16m8_i16m1(v_vec, v_min, vl);\n        v_max = vredmax_vs_i16m8_i16m1(v_vec, v_max, vl);\n    }\n    \n    MinMaxPair result;\n    result.min_num = vmv_x_s_i16m1_i16(v_min);\n    result.max_num = vmv_x_s_i16m1_i16(v_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    vint16m8_t v_vec;\n    vint16m1_t v_min, v_max;\n    \n    v_min = __riscv_vfmv_s_f_v_i16m1(vec[0], 1);\n    v_max = __riscv_vfmv_s_f_v_i16m1(vec[0], 1);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m8(length - i);\n        v_vec = __riscv_vle16_v_i16m8(&vec[i], vl);\n        \n        v_min = __riscv_vredmin_vs_i16m8_i16m1(v_vec, v_min, vl);\n        v_max = __riscv_vredmax_vs_i16m8_i16m1(v_vec, v_max, vl);\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(v_min);\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(v_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    size_t vl;\n    vint16m8_t v_vec;\n    vint16m1_t v_min, v_max;\n    \n    v_min = __riscv_vfmv_s_f_v_i16m1(vec[0], 1);\n    v_max = __riscv_vfmv_s_f_v_i16m1(vec[0], 1);\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m8(length - i);\n        v_vec = __riscv_vle16_v_i16m8(&vec[i], vl);\n        \n        v_min = __riscv_vredmin_vs_i16m8_i16m1(v_vec, v_min, vl);\n        v_max = __riscv_vredmax_vs_i16m8_i16m1(v_vec, v_max, vl);\n    }\n    \n    result.min_num = __riscv_vmv_x_s_i16m1_i16(v_min);\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(v_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_RVV", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    size_t vl;\n    vint16m8_t v_vec;\n    vint16m1_t v_min, v_max;\n    \n    // Initialize min/max with first element\n    v_min = __riscv_vfmv_s_f_v_i16m1(vec[0], 1);\n    v_max = __riscv_vfmv_s_f_v_i16m1(vec[0], 1);\n    \n    // Process vector elements\n    for (size_t i = 0; i < length; i += vl) {\n        vl = __riscv_vsetvl_e16m8(length - i);\n        v_vec = __riscv_vle16_v_i16m8(vec + i, vl);\n        \n        v_min = __riscv_vredmin_vs_i16m8_i16m1(v_vec, v_min, vl);\n        v_max = __riscv_vredmax_vs_i16m8_i16m1(v_vec, v_max, vl);\n    }\n    \n    MinMaxPair result;\n    result.min_num = __riscv_vmv_x_s_i16m1_i16(v_min);\n    result.max_num = __riscv_vmv_x_s_i16m1_i16(v_max);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        \n        while (j < cols - 1) {\n            vl = vsetvl_e32m8(cols - 1 - j);\n            \n            vint32m8_t v_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v_next = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask = vmle_vv_i32m8_b4(v_next, v_curr, vl);\n            \n            if (vmany_m_b4(mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        \n        while (j < cols - 1) {\n            vl = vsetvl_e32m8(cols - 1 - j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask = vmle_vv_i32m8_b4(v2, v1, vl);\n            \n            if (vmany_m_b4(mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        \n        while (j < cols - 1) {\n            vl = vsetvl_e32m8(cols - 1 - j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask = vmle_vv_i32m8_b4(v2, v1, vl);\n            \n            if (vmany_m_b4(mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        \n        while (j < cols - 1) {\n            vl = vsetvl_e32m8(cols - 1 - j);\n            \n            vint32m8_t v_curr = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v_next = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask = vmle_vv_i32m8_b4(v_next, v_curr, vl);\n            \n            if (vmany_m_b4(mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_RVV", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    bool result = true;\n    \n    for (size_t i = 0; i < rows && result; i++) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n        \n        while (j < cols - 1) {\n            vl = vsetvl_e32m8(cols - 1 - j);\n            \n            vint32m8_t v1 = vle32_v_i32m8(row + j, vl);\n            vint32m8_t v2 = vle32_v_i32m8(row + j + 1, vl);\n            \n            vbool4_t mask = vmsleu_vv_i32m8_b4(v2, v1, vl);\n            \n            if (vmany_m_b4(mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Get first block as reference\n    const int* first_block = matrix;\n\n    size_t vl;\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            if (i == 0 && j == 0) continue;\n\n            const int* curr_block = matrix + i * block_size * cols + j * block_size;\n\n            // Compare blocks row by row\n            for (size_t r = 0; r < block_size; r++) {\n                const int* ref_row = first_block + r * cols;\n                const int* curr_row = curr_block + r * cols;\n                \n                size_t width = block_size;\n                while (width > 0) {\n                    vl = vsetvl_e32m8(width);\n                    \n                    vint32m8_t v_ref = vle32_v_i32m8(ref_row, vl);\n                    vint32m8_t v_curr = vle32_v_i32m8(curr_row, vl);\n                    \n                    vbool4_t mask = vmseq_vv_i32m8_b4(v_ref, v_curr, vl);\n                    if (!vmandvs_e32m8_b4(mask, vl)) {\n                        return false;\n                    }\n                    \n                    ref_row += vl;\n                    curr_row += vl;\n                    width -= vl;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Get first block as reference\n    const int* first_block = matrix;\n\n    size_t vl;\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            if (i == 0 && j == 0) continue;\n\n            const int* curr_block = matrix + i * cols * block_size + j * block_size;\n\n            // Compare blocks row by row\n            for (size_t r = 0; r < block_size; r++) {\n                const int* ref_row = first_block + r * cols;\n                const int* curr_row = curr_block + r * cols;\n                \n                size_t k = 0;\n                while (k < block_size) {\n                    vl = vsetvl_e32m8(block_size - k);\n                    \n                    vint32m8_t v_ref = vle32_v_i32m8(ref_row + k, vl);\n                    vint32m8_t v_curr = vle32_v_i32m8(curr_row + k, vl);\n                    \n                    vbool4_t v_mask = vmseq_vv_i32m8_b4(v_ref, v_curr, vl);\n                    if (!vmandnot_mm_b4(v_mask, v_mask, vl)) {\n                        return false;\n                    }\n                    \n                    k += vl;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Get first block as reference\n    const int* first_block = matrix;\n\n    // Compare each block with first block\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            // Skip first block\n            if (i == 0 && j == 0) continue;\n\n            const int* curr_block = matrix + i * block_size * cols + j * block_size;\n\n            // Compare blocks row by row\n            for (size_t r = 0; r < block_size; r++) {\n                size_t vl;\n                const int* first_row = first_block + r * cols;\n                const int* curr_row = curr_block + r * cols;\n                size_t elements = block_size;\n\n                while (elements > 0) {\n                    vl = vsetvl_e32m8(elements);\n                    vint32m8_t v_first = vle32_v_i32m8(first_row, vl);\n                    vint32m8_t v_curr = vle32_v_i32m8(curr_row, vl);\n                    vbool4_t mask = vmseq_vv_i32m8_b4(v_first, v_curr, vl);\n                    if (!vmandor_m_b4(mask, vl)) {\n                        return false;\n                    }\n                    first_row += vl;\n                    curr_row += vl;\n                    elements -= vl;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Get first block as reference\n    const int* first_block = matrix;\n    \n    size_t vl;\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            if (i == 0 && j == 0) continue;\n            \n            const int* curr_block = matrix + i * block_size * cols + j * block_size;\n            \n            for (size_t r = 0; r < block_size; r++) {\n                size_t offset = r * cols;\n                const int* first_row = first_block + offset;\n                const int* curr_row = curr_block + offset;\n                \n                size_t k = 0;\n                while (k < block_size) {\n                    vl = vsetvl_e32m8(block_size - k);\n                    vint32m8_t v_first = vle32_v_i32m8(first_row + k, vl);\n                    vint32m8_t v_curr = vle32_v_i32m8(curr_row + k, vl);\n                    vbool4_t v_cmp = vmseq_vv_i32m8_b4(v_first, v_curr, vl);\n                    if (!vmandvs_e32m8_b4(v_cmp, vl)) {\n                        return false;\n                    }\n                    k += vl;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_RVV", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Get first block as reference\n    const int* first_block = matrix;\n    \n    size_t vl;\n    vint32m8_t v_first, v_curr;\n    \n    // Compare each block with first block\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            // Skip first block\n            if (i == 0 && j == 0) continue;\n            \n            const int* curr_block = matrix + i * block_size * cols + j * block_size;\n            \n            // Compare each row in blocks\n            for (size_t r = 0; r < block_size; r++) {\n                const int* first_row = first_block + r * cols;\n                const int* curr_row = curr_block + r * cols;\n                \n                size_t k = 0;\n                while (k < block_size) {\n                    vl = vsetvl_e32m8(block_size - k);\n                    \n                    v_first = vle32_v_i32m8(first_row + k, vl);\n                    v_curr = vle32_v_i32m8(curr_row + k, vl);\n                    \n                    vbool4_t mask = vmseq_vv_i32m8_b4(v_first, v_curr, vl);\n                    if (!vmandor_m_b4(mask, vl)) {\n                        return false;\n                    }\n                    \n                    k += vl;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    vfloat64m8_t v_block1, v_block2, v_diff;\n    vbool8_t v_mask;\n\n    for (size_t block = 1; block < num_blocks; block++) {\n        size_t offset = 0;\n        while (offset < block_size) {\n            vl = vsetvl_e64m8(block_size - offset);\n            \n            v_block1 = vle64_v_f64m8(&vec[offset], vl);\n            v_block2 = vle64_v_f64m8(&vec[block * block_size + offset], vl);\n            \n            v_diff = vfsub_vv_f64m8(v_block1, v_block2, vl);\n            v_diff = vfabs_v_f64m8(v_diff, vl);\n            \n            v_mask = vmfgt_vf_f64m8_b8(v_diff, tolerance, vl);\n            \n            if (vfirst_m_b8(v_mask, vl) != -1) {\n                return false;\n            }\n            \n            offset += vl;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    vfloat64m8_t v_first, v_curr;\n    vbool8_t v_mask;\n\n    for (size_t block = 1; block < num_blocks; block++) {\n        size_t offset = 0;\n        while (offset < block_size) {\n            vl = vsetvl_e64m8(block_size - offset);\n            \n            v_first = vle64_v_f64m8(&vec[offset], vl);\n            v_curr = vle64_v_f64m8(&vec[block * block_size + offset], vl);\n\n            // Check if absolute difference is within tolerance\n            v_mask = vmfgt_vv_f64m8_b8(vfsub_vv_f64m8(vfmax_vv_f64m8(v_first, v_curr, vl),\n                                                      vfmin_vv_f64m8(v_first, v_curr, vl), vl),\n                                      vfmv_v_f_f64m8(tolerance, vl), vl);\n\n            // If any element exceeds tolerance, return false\n            if (vfirst_m_b8(v_mask, vl) != -1) {\n                return false;\n            }\n\n            offset += vl;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    vfloat64m8_t v_block1, v_block2, v_diff, v_abs, v_cmp;\n    vbool8_t v_mask;\n    bool result = true;\n\n    // For each element position within a block\n    for (size_t i = 0; i < block_size; i += vl) {\n        // Get vector length for this iteration\n        vl = vsetvl_e64m8(block_size - i);\n\n        // Load first block elements at current position\n        v_block1 = vle64_v_f64m8(&vec[i], vl);\n\n        // Compare with same position in all other blocks\n        for (size_t b = 1; b < num_blocks; b++) {\n            // Load elements from current block\n            v_block2 = vle64_v_f64m8(&vec[b * block_size + i], vl);\n\n            // Calculate absolute difference\n            v_diff = vfsub_vv_f64m8(v_block1, v_block2, vl);\n            v_abs = vfabs_v_f64m8(v_diff, vl);\n\n            // Compare with tolerance\n            v_mask = vmfgt_vf_f64m8_b8(v_abs, tolerance, vl);\n\n            // If any element exceeds tolerance, return false\n            if (vmany_m_b8(v_mask, vl)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    vfloat64m8_t v_block1, v_block2, v_diff, v_abs, v_cmp;\n    vbool8_t v_mask;\n    bool result = true;\n\n    // For each position within blocks\n    for (size_t pos = 0; pos < block_size; pos++) {\n        // Reference value from first block\n        double ref = vec[pos];\n        \n        // Compare with same position in other blocks\n        size_t remaining = num_blocks - 1;\n        size_t offset = block_size + pos;\n        \n        while (remaining > 0) {\n            vl = vsetvl_e64m8(remaining);\n            \n            // Load values from corresponding positions in subsequent blocks\n            v_block2 = vlse64_v_f64m8(&vec[offset], block_size * sizeof(double), vl);\n            \n            // Broadcast reference value\n            v_block1 = vfmv_v_f_f64m8(ref, vl);\n            \n            // Calculate absolute difference\n            v_diff = vfsub_vv_f64m8(v_block1, v_block2, vl);\n            v_abs = vfabs_v_f64m8(v_diff, vl);\n            \n            // Compare with tolerance\n            v_cmp = vfgt_vf_f64m8(v_abs, tolerance, vl);\n            v_mask = vmseq_vx_f64m8_b8(v_cmp, 0, vl);\n            \n            // Check if any comparison failed\n            if (!vmand_m_b8(v_mask, vl)) {\n                result = false;\n                break;\n            }\n            \n            remaining -= vl;\n            offset += vl * block_size;\n        }\n        \n        if (!result) break;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_38_RVV", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    size_t vl;\n    vfloat64m8_t v_block1, v_block2, v_diff, v_tol;\n    vbool8_t v_mask;\n    \n    // Load tolerance vector\n    v_tol = vfmv_v_f_f64m8(tolerance, block_size);\n    \n    // Process each block\n    for (size_t block = 1; block < num_blocks; block++) {\n        size_t remaining = block_size;\n        size_t offset = 0;\n        \n        // Process current block in chunks\n        while (remaining > 0) {\n            vl = vsetvl_e64m8(remaining);\n            \n            // Load vectors from first block and current block\n            v_block1 = vle64_v_f64m8(&vec[offset], vl);\n            v_block2 = vle64_v_f64m8(&vec[block * block_size + offset], vl);\n            \n            // Calculate absolute difference\n            v_diff = vfsub_vv_f64m8(v_block1, v_block2, vl);\n            v_diff = vfabs_v_f64m8(v_diff, vl);\n            \n            // Compare with tolerance\n            v_mask = vmfgt_vv_f64m8_b8(v_diff, v_tol, vl);\n            \n            // If any element exceeds tolerance, return false\n            if (vfirst_m_b8(v_mask, vl) != -1) {\n                return false;\n            }\n            \n            remaining -= vl;\n            offset += vl;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    vl = vsetvl_e64m8(cols);\n    \n    for (size_t i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        const double* row = matrix + i * cols;\n        \n        vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, vl);\n        \n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v_elements = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_elements, v_elements, vl);\n            v_sum = vfadd_vv_f64m8(v_sum, v_squared, vl);\n        }\n        \n        // Reduce vector sum\n        double temp_sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vfmv_s_f_f64m1(0.0, vl), v_sum, vl));\n        row_sum = sqrt(temp_sum);\n        \n        // Compare with threshold\n        result[i] = (row_sum > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    vfloat64m8_t v_row;\n    vfloat64m1_t v_sum;\n    \n    for (size_t i = 0; i < rows; i++) {\n        double sum = 0.0;\n        size_t j = 0;\n        \n        // Initialize accumulator\n        v_sum = vfmv_v_f_f64m1(0.0, 1);\n        \n        // Process elements in vector chunks\n        for (; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            v_row = vle64_v_f64m8(&matrix[i * cols + j], vl);\n            \n            // Square each element\n            v_row = vfmul_vv_f64m8(v_row, v_row, vl);\n            \n            // Reduce sum into scalar\n            v_sum = vfredusum_vs_f64m8_f64m1(v_sum, v_row, v_sum, vl);\n        }\n        \n        // Extract final sum and take square root\n        double norm = sqrt(__riscv_vfmv_f_s_f64m1_f64(v_sum));\n        \n        // Compare with threshold\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        const double* row = matrix + i * cols;\n        \n        // Initialize accumulator vector register to zero\n        vfloat64m8_t v_acc = vfmv_v_f_f64m8(0.0, cols);\n        \n        // Process elements in chunks of maximum vector length\n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            \n            // Load vector of elements\n            vfloat64m8_t v_elements = vle64_v_f64m8(row + j, vl);\n            \n            // Square elements\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_elements, v_elements, vl);\n            \n            // Accumulate sum\n            v_acc = vfadd_vv_f64m8(v_acc, v_squared, vl);\n        }\n        \n        // Reduce vector to scalar sum\n        row_sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(v_acc, v_acc, vl));\n        \n        // Take square root and compare with threshold\n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    size_t i, j;\n    \n    for (i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        const double* row = matrix + i * cols;\n        \n        vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, cols);\n        \n        for (j = 0; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v_elements = vle64_v_f64m8(row + j, vl);\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_elements, v_elements, vl);\n            v_sum = vfadd_vv_f64m8(v_sum, v_squared, vl);\n        }\n        \n        // Horizontal sum reduction\n        double temp[8];\n        vse64_v_f64m8(temp, v_sum, vl);\n        for (j = 0; j < vl; j++) {\n            row_sum += temp[j];\n        }\n        \n        // Compare with threshold\n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_RVV", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl;\n    for (size_t i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        size_t j = 0;\n        \n        vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, cols);\n        \n        for (; j < cols; j += vl) {\n            vl = vsetvl_e64m8(cols - j);\n            vfloat64m8_t v_elements = vle64_v_f64m8(&matrix[i * cols + j], vl);\n            vfloat64m8_t v_squared = vfmul_vv_f64m8(v_elements, v_elements, vl);\n            v_sum = vfadd_vv_f64m8(v_sum, v_squared, vl);\n        }\n        \n        // Reduce sum\n        double temp_sum[8];\n        vse64_v_f64m8(temp_sum, v_sum, vl);\n        for(size_t k = 0; k < vl; k++) {\n            row_sum += temp_sum[k];\n        }\n        \n        // Compare with threshold\n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    while (length > 0) {\n        vl = vsetvl_e32m8(length);\n        \n        vuint32m8_t va = vle32_v_u32m8(A, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C, vc, vl);\n\n        A += vl;\n        B += vl;\n        C += vl;\n        length -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_40_RVV", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        vuint32m8_t vb = vle32_v_u32m8(B + i, vl);\n        vuint32m8_t vc = vor_vv_u32m8(va, vb, vl);\n        vse32_v_u32m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    vint16m2_t v_a, v_b;\n    vint32m4_t v_a_sq, v_b_sq, v_prod;\n    vint64m8_t v_sum_sq, v_sum_prod;\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        // Load vectors and widen to 16-bit\n        v_a = vwcvt_x_x_v_i16m2(vle8_v_i8m1(A + i, vl));\n        v_b = vwcvt_x_x_v_i16m2(vle8_v_i8m1(B + i, vl));\n        \n        // Compute squares and products, widening to 32-bit\n        v_a_sq = vwmul_vv_i32m4(v_a, v_a, vl);\n        v_b_sq = vwmul_vv_i32m4(v_b, v_b, vl);\n        v_prod = vwmul_vv_i32m4(v_a, v_b, vl);\n        \n        // Widen to 64-bit and accumulate\n        v_sum_sq = vwredsum_vs_i32m4_i64m8(v_sum_sq, v_a_sq, vmv_v_x_i64m8(0, 1), vl);\n        v_sum_sq = vwredsum_vs_i32m4_i64m8(v_sum_sq, v_b_sq, vmv_v_x_i64m8(0, 1), vl);\n        v_sum_prod = vwredsum_vs_i32m4_i64m8(v_sum_prod, v_prod, vmv_v_x_i64m8(0, 1), vl);\n        \n        sum_squares += vmv_x_s_i64m8_i64(v_sum_sq);\n        sum_products += vmv_x_s_i64m8_i64(v_sum_prod);\n    }\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    vint16m2_t v_a, v_b;\n    vint32m4_t v_a_sq, v_b_sq, v_prod;\n    vint64m8_t v_sum_sq, v_sum_prod;\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        // Load vectors and widen to 16-bit\n        v_a = vwcvt_x_x_v_i16m2(vle8_v_i8m1((int8_t*)&A[i], vl));\n        v_b = vwcvt_x_x_v_i16m2(vle8_v_i8m1((int8_t*)&B[i], vl));\n        \n        // Compute squares and products, widening to 32-bit\n        v_a_sq = vwmul_vv_i32m4(v_a, v_a, vl);\n        v_b_sq = vwmul_vv_i32m4(v_b, v_b, vl);\n        v_prod = vwmul_vv_i32m4(v_a, v_b, vl);\n        \n        // Widen to 64-bit and reduce\n        v_sum_sq = vwredsum_vs_i32m4_i64m8(v_sum_sq, v_a_sq, vmv_v_x_i64m8(0, 1), vl);\n        v_sum_sq = vwredsum_vs_i32m4_i64m8(v_sum_sq, v_b_sq, v_sum_sq, vl);\n        v_sum_prod = vwredsum_vs_i32m4_i64m8(v_sum_prod, v_prod, vmv_v_x_i64m8(0, 1), vl);\n        \n        sum_squares += vmv_x_s_i64m8_i64(v_sum_sq);\n        sum_products += vmv_x_s_i64m8_i64(v_sum_prod);\n    }\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    vint16m2_t v_a_16, v_b_16;\n    vint32m4_t v_a_32, v_b_32;\n    vint32m4_t v_squares_a, v_squares_b;\n    vint32m4_t v_products;\n    vint64m8_t v_sum_squares, v_sum_products;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        // Load and sign extend to 16-bit\n        v_a_16 = vsext_vf2_i16m2(vle8_v_i8m1(&A[i], vl), vl);\n        v_b_16 = vsext_vf2_i16m2(vle8_v_i8m1(&B[i], vl), vl);\n        \n        // Sign extend to 32-bit\n        v_a_32 = vsext_vf2_i32m4(v_a_16, vl);\n        v_b_32 = vsext_vf2_i32m4(v_b_16, vl);\n        \n        // Calculate squares\n        v_squares_a = vmul_vv_i32m4(v_a_32, v_a_32, vl);\n        v_squares_b = vmul_vv_i32m4(v_b_32, v_b_32, vl);\n        \n        // Calculate products\n        v_products = vmul_vv_i32m4(v_a_32, v_b_32, vl);\n        \n        // Widen to 64-bit and reduce\n        v_sum_squares = vwredsum_vs_i32m4_i64m8(v_sum_squares, vadd_vv_i32m4(v_squares_a, v_squares_b, vl), vmv_v_x_i64m8(0, 1), vl);\n        v_sum_products = vwredsum_vs_i32m4_i64m8(v_sum_products, v_products, vmv_v_x_i64m8(0, 1), vl);\n        \n        sum_squares += vmv_x_s_i64m8_i64(v_sum_squares);\n        sum_products += vmv_x_s_i64m8_i64(v_sum_products);\n    }\n    \n    return sum_squares - (2 * sum_products);\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    size_t vl;\n    vint16m2_t v_a, v_b;\n    vint32m4_t v_a_sq, v_b_sq, v_prod;\n    vint64m8_t v_sum_sq, v_sum_prod;\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        // Load vectors\n        v_a = vwsext_vf2_i16m2(vle8_v_i8m1(A + i, vl), vl);\n        v_b = vwsext_vf2_i16m2(vle8_v_i8m1(B + i, vl), vl);\n        \n        // Calculate squares and products\n        v_a_sq = vwmul_vv_i32m4(v_a, v_a, vl);\n        v_b_sq = vwmul_vv_i32m4(v_b, v_b, vl);\n        v_prod = vwmul_vv_i32m4(v_a, v_b, vl);\n        \n        // Widen to 64-bit and reduce\n        v_sum_sq = vwredsum_vs_i32m4_i64m8(v_sum_sq, vadd_vv_i32m4(v_a_sq, v_b_sq, vl), v_sum_sq, vl);\n        v_sum_prod = vwredsum_vs_i32m4_i64m8(v_sum_prod, v_prod, v_sum_prod, vl);\n    }\n    \n    sum_squares = vmv_x_s_i64m1_i64(v_sum_sq);\n    sum_products = vmv_x_s_i64m1_i64(v_sum_prod);\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_RVV", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    size_t vl;\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    vint16m2_t v_a, v_b;\n    vint32m4_t v_a_sq, v_b_sq, v_prod;\n    vint64m8_t v_a_sq_w, v_b_sq_w, v_prod_w;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        // Load vectors and widen to 16-bit\n        v_a = vwcvt_x_x_v_i16m2(vle8_v_i8m1(&A[i], vl));\n        v_b = vwcvt_x_x_v_i16m2(vle8_v_i8m1(&B[i], vl));\n        \n        // Compute squares and products (32-bit)\n        v_a_sq = vwmul_vv_i32m4(v_a, v_a, vl);\n        v_b_sq = vwmul_vv_i32m4(v_b, v_b, vl);\n        v_prod = vwmul_vv_i32m4(v_a, v_b, vl);\n        \n        // Widen to 64-bit for accumulation\n        v_a_sq_w = vwcvt_x_x_v_i64m8(v_a_sq, vl);\n        v_b_sq_w = vwcvt_x_x_v_i64m8(v_b_sq, vl);\n        v_prod_w = vwcvt_x_x_v_i64m8(v_prod, vl);\n        \n        // Accumulate sums\n        sum_squares += vredsum_vs_i64m8_i64m1(vzero_i64m1(1), v_a_sq_w, vzero_i64m1(1), vl);\n        sum_squares += vredsum_vs_i64m8_i64m1(vzero_i64m1(1), v_b_sq_w, vzero_i64m1(1), vl);\n        sum_products += vredsum_vs_i64m8_i64m1(vzero_i64m1(1), v_prod_w, vzero_i64m1(1), vl);\n    }\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n        \n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        \n        vb = vnot_v_u64m8(vb, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vb, vl);\n        \n        vse64_v_u64m8(C + i, vc, vl);\n        \n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vb_not = vnot_v_u64m8(vb, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vb_not, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < length) {\n        vl = vsetvl_e64m8(length - i);\n        \n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        \n        vb = vnot_v_u64m8(vb, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vb, vl);\n        \n        vse64_v_u64m8(C + i, vc, vl);\n        \n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vb_not = vnot_v_u64m8(vb, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vb_not, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_42_RVV", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t vl;\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e64m8(length - i);\n        vuint64m8_t va = vle64_v_u64m8(A + i, vl);\n        vuint64m8_t vb = vle64_v_u64m8(B + i, vl);\n        vuint64m8_t vb_not = vnot_v_u64m8(vb, vl);\n        vuint64m8_t vc = vand_vv_u64m8(va, vb_not, vl);\n        vse64_v_u64m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb, vc;\n    vbool8_t mask_pos, mask_neg;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        va = vle8_v_i8m1(A + i, vl);\n        vb = vle8_v_i8m1(B + i, vl);\n        \n        // Get masks for positive and negative values\n        mask_pos = vmsgt_vx_i8m1_b8(va, 0, vl);\n        mask_pos = vmand_mm_b8(mask_pos, vmsgt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        mask_neg = vmslt_vx_i8m1_b8(va, 0, vl);\n        mask_neg = vmand_mm_b8(mask_neg, vmslt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        // Initialize result vector with zeros\n        vc = vmv_v_x_i8m1(0, vl);\n        \n        // Set 1 where both positive\n        vc = vmerge_vxm_i8m1(vc, mask_pos, 1, vl);\n        \n        // Set -1 where both negative  \n        vc = vmerge_vxm_i8m1(vc, mask_neg, -1, vl);\n        \n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb, vc;\n    vbool8_t both_pos, both_neg;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        va = vle8_v_i8m1(A + i, vl);\n        vb = vle8_v_i8m1(B + i, vl);\n        \n        both_pos = vmsgt_vx_i8m1_b8(va, 0, vl);\n        both_pos = vmand_mm_b8(both_pos, vmsgt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        both_neg = vmslt_vx_i8m1_b8(va, 0, vl);\n        both_neg = vmand_mm_b8(both_neg, vmslt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        vc = vmv_v_x_i8m1(0, vl);\n        vc = vmerge_vxm_i8m1(vc, both_pos, 1, vl);\n        vc = vmerge_vxm_i8m1(vc, both_neg, -1, vl);\n        \n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb, vc;\n    vbool8_t mask_pos, mask_neg;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        va = vle8_v_i8m1(A + i, vl);\n        vb = vle8_v_i8m1(B + i, vl);\n        \n        // Create masks for positive and negative values\n        mask_pos = vmsgt_vx_i8m1_b8(va, 0, vl);\n        mask_pos = vmand_mm_b8(mask_pos, vmsgt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        mask_neg = vmslt_vx_i8m1_b8(va, 0, vl);\n        mask_neg = vmand_mm_b8(mask_neg, vmslt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        // Initialize result vector with zeros\n        vc = vmv_v_x_i8m1(0, vl);\n        \n        // Set 1 where both positive\n        vc = vmerge_vxm_i8m1(vc, mask_pos, 1, vl);\n        \n        // Set -1 where both negative  \n        vc = vmerge_vxm_i8m1(vc, mask_neg, -1, vl);\n        \n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    const int8_t one = 1;\n    const int8_t neg_one = -1;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m8(length - i);\n        \n        vint8m8_t va = vle8_v_i8m8(A + i, vl);\n        vint8m8_t vb = vle8_v_i8m8(B + i, vl);\n        \n        // Create masks for positive and negative values\n        vbool1_t pos_mask = vmsgt_vx_i8m8_b1(va, 0, vl);\n        pos_mask = vmand_mm_b1(pos_mask, vmsgt_vx_i8m8_b1(vb, 0, vl), vl);\n        \n        vbool1_t neg_mask = vmslt_vx_i8m8_b1(va, 0, vl);\n        neg_mask = vmand_mm_b1(neg_mask, vmslt_vx_i8m8_b1(vb, 0, vl), vl);\n        \n        // Initialize result vector with zeros\n        vint8m8_t vc = vmv_v_x_i8m8(0, vl);\n        \n        // Set 1 where both positive\n        vc = vmerge_vxm_i8m8(vc, pos_mask, one, vl);\n        \n        // Set -1 where both negative\n        vc = vmerge_vxm_i8m8(vc, neg_mask, neg_one, vl);\n        \n        // Store result\n        vse8_v_i8m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_43_RVV", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl;\n    vint8m1_t va, vb, vc;\n    vbool8_t mask_pos, mask_neg;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e8m1(length - i);\n        \n        va = vle8_v_i8m1(A + i, vl);\n        vb = vle8_v_i8m1(B + i, vl);\n        \n        // Initialize C with zeros\n        vc = vmv_v_x_i8m1(0, vl);\n        \n        // Create masks for positive and negative cases\n        mask_pos = vmsgt_vx_i8m1_b8(va, 0, vl);\n        mask_pos = vmand_mm_b8(mask_pos, vmsgt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        mask_neg = vmslt_vx_i8m1_b8(va, 0, vl);\n        mask_neg = vmand_mm_b8(mask_neg, vmslt_vx_i8m1_b8(vb, 0, vl), vl);\n        \n        // Set values based on masks\n        vc = vmerge_vxm_i8m1(vc, mask_pos, 1, vl);\n        vc = vmerge_vxm_i8m1(vc, mask_neg, -1, vl);\n        \n        vse8_v_i8m1(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n    \n    // Process elements before midpoint (XOR)\n    size_t i = 0;\n    while (i < midpoint) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n\n    // Set midpoint element\n    C[midpoint] = A[midpoint];\n\n    // Process elements after midpoint (AND)\n    i = midpoint + 1;\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n    \n    // Process elements before midpoint using XOR\n    size_t i = 0;\n    while (i < midpoint) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n\n    // Handle middle element\n    C[midpoint] = A[midpoint];\n\n    // Process elements after midpoint using AND\n    i = midpoint + 1;\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n    \n    // Process elements before midpoint using XOR\n    size_t i = 0;\n    while (i < midpoint) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n\n    // Set midpoint element directly from A\n    C[midpoint] = A[midpoint];\n\n    // Process elements after midpoint using AND\n    i = midpoint + 1;\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n    \n    // Process elements before midpoint using XOR\n    size_t i = 0;\n    for (; i < midpoint; i += vl) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n    }\n\n    // Set midpoint element directly from A\n    C[midpoint] = A[midpoint];\n\n    // Process elements after midpoint using AND\n    i = midpoint + 1;\n    for (; i < length; i += vl) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_44_RVV", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t vl;\n    \n    // Process elements before midpoint using XOR\n    size_t i = 0;\n    while (i < midpoint) {\n        vl = vsetvl_e16m8(midpoint - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vxor_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n\n    // Handle middle element\n    C[midpoint] = A[midpoint];\n\n    // Process elements after midpoint using AND\n    i = midpoint + 1;\n    while (i < length) {\n        vl = vsetvl_e16m8(length - i);\n        vuint16m8_t va = vle16_v_u16m8(A + i, vl);\n        vuint16m8_t vb = vle16_v_u16m8(B + i, vl);\n        vuint16m8_t vc = vand_vv_u16m8(va, vb, vl);\n        vse16_v_u16m8(C + i, vc, vl);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vbool4_t vmask1 = vlm_v_b4(cond1 + i, vl);\n        vbool4_t vmask2 = vlm_v_b4(cond2 + i, vl);\n        \n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vc = vle32_v_f32m8(C + i, vl);\n        vfloat32m8_t vd = vle32_v_f32m8(D + i, vl);\n        \n        // First select between A and B based on cond2 when cond1 is true\n        vfloat32m8_t v_true = vmerge_vvm_f32m8(vmask2, vb, va, vl);\n        \n        // Then select between C and D based on cond2 when cond1 is false  \n        vfloat32m8_t v_false = vmerge_vvm_f32m8(vmask2, vd, vc, vl);\n        \n        // Final selection based on cond1\n        vfloat32m8_t v_result = vmerge_vvm_f32m8(vmask1, v_false, v_true, vl);\n        \n        vse32_v_f32m8(out + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vbool4_t mask1 = vle1_v_b4(cond1 + i, vl);\n        vbool4_t mask2 = vle1_v_b4(cond2 + i, vl);\n        \n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vc = vle32_v_f32m8(C + i, vl);\n        vfloat32m8_t vd = vle32_v_f32m8(D + i, vl);\n        \n        // Select between A and B based on cond2 when cond1 is true\n        vfloat32m8_t v_ab = vmerge_vvm_f32m8(mask2, vb, va, vl);\n        \n        // Select between C and D based on cond2 when cond1 is false  \n        vfloat32m8_t v_cd = vmerge_vvm_f32m8(mask2, vd, vc, vl);\n        \n        // Final selection based on cond1\n        vfloat32m8_t result = vmerge_vvm_f32m8(mask1, v_cd, v_ab, vl);\n        \n        vse32_v_f32m8(out + i, result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        // Load conditions\n        vbool4_t vmask1 = vlm_v_b4(cond1 + i, vl);\n        vbool4_t vmask2 = vlm_v_b4(cond2 + i, vl);\n        \n        // Load input vectors\n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vc = vle32_v_f32m8(C + i, vl);\n        vfloat32m8_t vd = vle32_v_f32m8(D + i, vl);\n        \n        // Initialize output with D values\n        vfloat32m8_t vout = vd;\n        \n        // If cond1 is false and cond2 is true, use C\n        vout = vmerge_vvm_f32m8(vmask1, vout, vc, vmask2, vl);\n        \n        // If cond1 is true and cond2 is false, use B\n        vbool4_t vmask_b = vmnot_m_b4(vmask2, vl);\n        vout = vmerge_vvm_f32m8(vmask_b, vout, vb, vmask1, vl);\n        \n        // If both cond1 and cond2 are true, use A\n        vbool4_t vmask_a = vand_mm_b4(vmask1, vmask2, vl);\n        vout = vmerge_vvm_f32m8(vmask_a, vout, va, vmask_a, vl);\n        \n        // Store result\n        vse32_v_f32m8(out + i, vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, \n                            const bool* cond1, const bool* cond2, float* out,\n                            size_t dim1, size_t dim2, size_t dim3) {\n    \n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vbool4_t vmask1 = vlm_v_b4(cond1 + i, vl);\n        vbool4_t vmask2 = vlm_v_b4(cond2 + i, vl);\n        \n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vc = vle32_v_f32m8(C + i, vl);\n        vfloat32m8_t vd = vle32_v_f32m8(D + i, vl);\n        \n        vfloat32m8_t vresult = vd;\n        \n        // If cond1 false and cond2 true -> C\n        vresult = vmerge_vvm_f32m8(vmask2, vresult, vc, vl);\n        \n        // If cond1 true -> A (if cond2 true) or B (if cond2 false)\n        vfloat32m8_t vab = vmerge_vvm_f32m8(vmask2, vb, va, vl);\n        vresult = vmerge_vvm_f32m8(vmask1, vresult, vab, vl);\n        \n        vse32_v_f32m8(out + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_45_RVV", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vbool4_t vmask1 = vlm_v_b4(cond1 + i, vl);\n        vbool4_t vmask2 = vlm_v_b4(cond2 + i, vl);\n        \n        vfloat32m8_t va = vle32_v_f32m8(A + i, vl);\n        vfloat32m8_t vb = vle32_v_f32m8(B + i, vl);\n        vfloat32m8_t vc = vle32_v_f32m8(C + i, vl);\n        vfloat32m8_t vd = vle32_v_f32m8(D + i, vl);\n        \n        // First select between A and B based on cond2 when cond1 is true\n        vfloat32m8_t v_ab = vmerge_vvm_f32m8(vmask2, vb, va, vl);\n        \n        // Then select between C and D based on cond2 when cond1 is false \n        vfloat32m8_t v_cd = vmerge_vvm_f32m8(vmask2, vd, vc, vl);\n        \n        // Final selection between (A/B) and (C/D) based on cond1\n        vfloat32m8_t v_result = vmerge_vvm_f32m8(vmask1, v_cd, v_ab, vl);\n        \n        vse32_v_f32m8(out + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(&A[i], vl);\n        \n        // Count bits using parallel population count\n        vuint32m8_t v_count = vcpop_v_u32m8(v_input, vl);\n        \n        // Narrow 32-bit counts to 8-bit\n        vuint16m4_t v_narrow16 = vncvt_x_x_w_u16m4(v_count, vl);\n        vuint8m2_t v_narrow8 = vncvt_x_x_w_u8m2(v_narrow16, vl);\n        \n        // Store results\n        vse8_v_u8m2(&out[i], v_narrow8, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(&A[i], vl);\n        \n        // Count bits using parallel population count\n        vuint32m8_t v_count = vcpop_v_u32m8(v_input, vl);\n        \n        // Narrow 32-bit counts to 8-bit\n        vuint16m4_t v_narrow16 = vncvt_x_x_w_u16m4(v_count, vl);\n        vuint8m2_t v_narrow8 = vncvt_x_x_w_u8m2(v_narrow16, vl);\n        \n        // Store results\n        vse8_v_u8m2(&out[i], v_narrow8, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(&A[i], vl);\n        \n        // Count bits using parallel popcount\n        vuint32m8_t v_count = vcpop_m_u32m8(v_input, vl);\n        \n        // Convert 32-bit counts to 8-bit\n        vuint8m2_t v_out = vncvt_x_x_w_u8m2(v_count, vl);\n        \n        // Store results\n        vse8_v_u8m2(&out[i], v_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_size; i += vl) {\n        vl = vsetvl_e32m8(total_size - i);\n        \n        vuint32m8_t v_input = vle32_v_u32m8(&A[i], vl);\n        \n        // Count bits using parallel population count\n        vuint32m8_t v_count = vcpop_m_u32m8(v_input, vl);\n        \n        // Convert 32-bit counts to 8-bit\n        vuint8m2_t v_out = vncvt_x_x_w_u8m2(v_count, vl);\n        \n        // Store results\n        vse8_v_u8m2(&out[i], v_out, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_46_RVV", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl;\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        vl = vsetvl_e32m8(total_elements - i);\n        \n        // Load vector of uint32 elements\n        vuint32m8_t v_in = vle32_v_u32m8(&A[i], vl);\n        \n        // Initialize accumulator for popcount\n        vuint8m2_t v_count = vmv_v_x_u8m2(0, vl);\n        \n        // Count bits using a loop\n        for (int bit = 0; bit < 32; bit++) {\n            // Extract bit and add to running count\n            vuint32m8_t v_bit = vand_vx_u32m8(v_in, (1U << bit), vl);\n            v_bit = vsrl_vx_u32m8(v_bit, bit, vl);\n            v_count = vadd_vv_u8m2(v_count, vncvt_x_x_w_u8m2(vncvt_x_x_w_u16m4(v_bit, vl), vl), vl);\n        }\n        \n        // Store results\n        vse8_v_u8m2(out + i, v_count, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t total = rows * cols;\n    \n    for (size_t i = 0; i < total; i += vlen) {\n        vlen = __riscv_vsetvl_e32m8(total - i);\n        \n        vint32m8_t va = __riscv_vle32_v_i32m8(&A[i], vlen);\n        \n        // Calculate divisibility by 3\n        vint32m8_t vrem = __riscv_vrem_vx_i32m8(va, 3, vlen);\n        vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(vrem, 0, vlen);\n        \n        // Calculate absolute values\n        vint32m8_t vabs = __riscv_vabs_v_i32m8(va, vlen);\n        \n        // Select between original and absolute based on mask\n        vint32m8_t vresult = __riscv_vmerge_vvm_i32m8(va, vabs, mask, vlen);\n        \n        __riscv_vse32_v_i32m8(B + i, vresult, vlen);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e32m8(total_elements - index);\n        \n        vint32m8_t v_a = vle32_v_i32m8(&A[index], vl);\n        \n        // Create mask for elements divisible by 3\n        vbool4_t mask = vmsne_vx_i32m8_b4(vrem_vx_i32m8(v_a, 3, vl), 0, vl);\n        \n        // Get absolute values where needed\n        vint32m8_t v_abs = vabs_v_i32m8(v_a, vl);\n        \n        // Select between original and absolute values based on mask\n        vint32m8_t v_result = vmerge_vvm_i32m8(mask, v_a, v_abs, vl);\n        \n        // Store results\n        vse32_v_i32m8(&B[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vlmax = vsetvlmax_e32m8();\n    size_t total = rows * cols;\n    size_t vl;\n    \n    for (size_t i = 0; i < total; i += vl) {\n        vl = vsetvl_e32m8(total - i);\n        \n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        \n        // Calculate divisibility by 3\n        vint32m8_t vrem = vrem_vx_i32m8(va, 3, vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem, 0, vl);\n        \n        // Get absolute values where needed\n        vint32m8_t vabs = vabs_v_i32m8(va, vl);\n        \n        // Select between original and absolute values based on mask\n        vint32m8_t vresult = vmerge_vvm_i32m8(mask, va, vabs, vl);\n        \n        // Store results\n        vse32_v_i32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        vl = vsetvl_e32m8(total_elements - index);\n        \n        vint32m8_t v_a = vle32_v_i32m8(&A[index], vl);\n        \n        // Create mask for elements divisible by 3\n        vbool4_t mask = vmsne_vx_i32m8_b4(vrem_vx_i32m8(v_a, 3, vl), 0, vl);\n        \n        // Get absolute values\n        vint32m8_t v_abs = vabs_v_i32m8(v_a, vl);\n        \n        // Select between original and absolute values based on mask\n        vint32m8_t v_result = vmerge_vvm_i32m8(mask, v_a, v_abs, vl);\n        \n        // Store results\n        vse32_v_i32m8(&B[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_47_RVV", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t vl;\n    size_t total = rows * cols;\n    size_t index = 0;\n    \n    while (index < total) {\n        vl = vsetvl_e32m8(total - index);\n        \n        vint32m8_t va = vle32_v_i32m8(&A[index], vl);\n        \n        // Calculate divisibility by 3\n        vint32m8_t vrem = vrem_vx_i32m8(va, 3, vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem, 0, vl);\n        \n        // Get absolute values where needed\n        vint32m8_t vabs = vabs_v_i32m8(va, vl);\n        \n        // Select between original and absolute values based on mask\n        vint32m8_t vresult = vmerge_vvm_i32m8(mask, va, vabs, vl);\n        \n        // Store results\n        vse32_v_i32m8(&B[index], vresult, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vint32m1_t v_src;\n    vint32m1_t v_rotated;\n    vint32m1_t v_negated;\n    vbool32_t mask;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m1(&src[i], vl);\n        \n        // Create mask for elements where low 4 bits are all 1\n        mask = vmseq_vx_u32m1_b32(vand_vx_u32m1(v_src, 0xF, vl), 0xF, vl);\n        \n        // Perform rotation for elements where condition is true\n        v_rotated = vor_vv_i32m1(vsrl_vx_u32m1(v_src, rotate_bits, vl),\n                                vsll_vx_u32m1(v_src, 32 - rotate_bits, vl), \n                                vl);\n        \n        // Perform bitwise NOT for elements where condition is false\n        v_negated = vnot_v_i32m1(v_src, vl);\n        \n        // Select between rotated and negated based on mask\n        vmerge_vvm_i32m1(v_negated, mask, v_rotated, v_negated, vl);\n        \n        // Store result\n        vse32_v_i32m1(&dst[i], v_negated, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    const uint32_t mask = 0xF;\n    const uint32_t check = 0xF;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vuint32m8_t v_src = vle32_v_u32m8(src + i, vl);\n        \n        // Get low 4 bits\n        vuint32m8_t v_low4 = vand_vx_u32m8(v_src, mask, vl);\n        \n        // Check if low 4 bits are all 1\n        vbool4_t mask_low4 = vmseq_vx_u32m8_b4(v_low4, check, vl);\n        \n        // Perform rotation for elements where condition is true\n        vuint32m8_t v_rot = vsrl_vx_u32m8(v_src, rotate_bits, vl);\n        vuint32m8_t v_rot_wrap = vsll_vx_u32m8(v_src, 32 - rotate_bits, vl);\n        vuint32m8_t v_rotated = vor_vv_u32m8(v_rot, v_rot_wrap, vl);\n        \n        // Perform bitwise NOT for elements where condition is false\n        vuint32m8_t v_not = vnot_v_u32m8(v_src, vl);\n        \n        // Select between rotated and NOT based on mask\n        vuint32m8_t v_result = vmerge_vvm_u32m8(mask_low4, v_not, v_rotated, vl);\n        \n        vse32_v_u32m8(dst + i, v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vint32m1_t v_src, v_rotated, v_negated;\n    vbool32_t mask;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m1(src + i, vl);\n        \n        // Create mask for elements where low 4 bits are all 1\n        mask = vmseq_vx_u32m1_b32(vand_vx_u32m1(v_src, 0xF, vl), 0xF, vl);\n        \n        // Perform rotation on all elements\n        v_rotated = vor_vv_u32m1(vsrl_vx_u32m1(v_src, rotate_bits, vl),\n                                vsll_vx_u32m1(v_src, 32 - rotate_bits, vl), \n                                vl);\n        \n        // Perform bitwise NOT on all elements\n        v_negated = vnot_v_u32m1(v_src, vl);\n        \n        // Select between rotated and negated based on mask\n        vmerge_vvm_u32m1(dst + i, mask, v_negated, v_rotated, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vint32m1_t v_src, v_rotated, v_negated;\n    vbool32_t mask;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m1(src + i, vl);\n        \n        // Create mask for elements where low 4 bits are all 1\n        mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v_src, 0xF, vl), 0xF, vl);\n        \n        // Perform rotation for true condition\n        v_rotated = vor_vv_i32m1(vsrl_vx_i32m1(v_src, rotate_bits, vl),\n                                vsll_vx_i32m1(v_src, 32 - rotate_bits, vl),\n                                vl);\n        \n        // Perform bitwise NOT for false condition\n        v_negated = vnot_v_i32m1(v_src, vl);\n        \n        // Select between rotated and negated based on mask\n        vmerge_vvm_i32m1(v_negated, mask, v_rotated, v_negated, vl);\n        \n        // Store result\n        vse32_v_i32m1(dst + i, v_negated, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_48_RVV", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t vl;\n    vint32m1_t v_src, v_rotated, v_negated;\n    vbool32_t mask;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load source vector\n        v_src = vle32_v_i32m1(&src[i], vl);\n        \n        // Create mask for elements where low 4 bits are all 1\n        mask = vmseq_vx_i32m1_b32(vand_vx_i32m1(v_src, 0xF, vl), 0xF, vl);\n        \n        // Calculate rotated values\n        v_rotated = vor_vv_i32m1(vsrl_vx_i32m1(v_src, rotate_bits, vl),\n                                vsll_vx_i32m1(v_src, 32 - rotate_bits, vl), \n                                vl);\n        \n        // Calculate negated values\n        v_negated = vnot_v_i32m1(v_src, vl);\n        \n        // Select between rotated and negated based on mask\n        vsse32_v_i32m1(dst + i, sizeof(uint32_t), \n                       vmerge_vvm_i32m1(mask, v_negated, v_rotated, vl), \n                       vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        \n        // Calculate A - B\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(va, vb, vl);\n        \n        // Compare with +epsilon\n        vbool4_t mask_gt = vmfgt_vf_f32m8_b4(vdiff, abs_epsilon, vl);\n        vbool4_t mask_lt = vmflt_vf_f32m8_b4(vdiff, -abs_epsilon, vl);\n        \n        // Initialize output with zeros\n        vint8m2_t vresult = vmv_v_x_i8m2(0, vl);\n        \n        // Set 1 where diff > epsilon\n        vresult = vmerge_vxm_i8m2(mask_gt, vresult, 1, vl);\n        \n        // Set -1 where diff < -epsilon\n        vresult = vmerge_vxm_i8m2(mask_lt, vresult, -1, vl);\n        \n        // Store results\n        vse8_v_i8m2(&out[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        \n        // Calculate A - B\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(va, vb, vl);\n        \n        // Compare with +epsilon\n        vbool4_t mask_gt = vmfgt_vf_f32m8_b4(vdiff, abs_epsilon, vl);\n        vbool4_t mask_lt = vmflt_vf_f32m8_b4(vdiff, -abs_epsilon, vl);\n        \n        // Initialize output with zeros\n        vint8m2_t vresult = vmv_v_x_i8m2(0, vl);\n        \n        // Set 1 where diff > epsilon\n        vresult = vmerge_vxm_i8m2(mask_gt, vresult, 1, vl);\n        \n        // Set -1 where diff < -epsilon\n        vresult = vmerge_vxm_i8m2(mask_lt, vresult, -1, vl);\n        \n        // Store results\n        vse8_v_i8m2(&out[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        \n        // Calculate A - B\n        vfloat32m8_t diff = vfsub_vv_f32m8(va, vb, vl);\n        \n        // Compare with epsilon\n        vbool4_t gt_mask = vmfgt_vf_f32m8_b4(diff, abs_epsilon, vl);\n        vbool4_t lt_mask = vmflt_vf_f32m8_b4(diff, -abs_epsilon, vl);\n        \n        // Initialize output with zeros\n        vint8m2_t result = vmv_v_x_i8m2(0, vl);\n        \n        // Set 1 where diff > epsilon\n        result = vmerge_vxm_i8m2(gt_mask, result, 1, vl);\n        \n        // Set -1 where diff < -epsilon\n        result = vmerge_vxm_i8m2(lt_mask, result, -1, vl);\n        \n        // Store results\n        vse8_v_i8m2(&out[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    float abs_eps = epsilon < 0 ? -epsilon : epsilon;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        \n        // Calculate A - B\n        vfloat32m8_t diff = vfsub_vv_f32m8(va, vb, vl);\n        \n        // Compare with +epsilon\n        vbool4_t gt_mask = vmfgt_vf_f32m8_b4(diff, abs_eps, vl);\n        \n        // Compare with -epsilon\n        vbool4_t lt_mask = vmflt_vf_f32m8_b4(diff, -abs_eps, vl);\n        \n        // Initialize output with zeros\n        vint8m2_t result = vmv_v_x_i8m2(0, vl);\n        \n        // Set 1 where diff > epsilon\n        result = vmerge_vxm_i8m2(gt_mask, result, 1, vl);\n        \n        // Set -1 where diff < -epsilon\n        result = vmerge_vxm_i8m2(lt_mask, result, -1, vl);\n        \n        // Store results\n        vse8_v_i8m2(&out[i], result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_49_RVV", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t vl;\n    float abs_epsilon = epsilon > 0 ? epsilon : -epsilon;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m8(length - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vfloat32m8_t vb = vle32_v_f32m8(&B[i], vl);\n        \n        // Calculate A - B\n        vfloat32m8_t vdiff = vfsub_vv_f32m8(va, vb, vl);\n        \n        // Compare with +epsilon\n        vbool4_t mask_gt = vmfgt_vf_f32m8_b4(vdiff, abs_epsilon, vl);\n        vbool4_t mask_lt = vmflt_vf_f32m8_b4(vdiff, -abs_epsilon, vl);\n        \n        // Initialize output with zeros\n        vint8m2_t vout = vmv_v_x_i8m2(0, vl);\n        \n        // Set 1 where diff > epsilon\n        vout = vmerge_vxm_i8m2(mask_gt, vout, 1, vl);\n        \n        // Set -1 where diff < -epsilon\n        vout = vmerge_vxm_i8m2(mask_lt, vout, -1, vl);\n        \n        // Store results\n        vse8_v_i8m2(&out[i], vout, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        v_float = vle32_v_f32m1(&A[i], vl);\n        \n        // Convert float to int with saturation\n        v_int = vfcvt_rtz_x_f_v_i32m1(v_float, vl);\n        \n        // Handle saturation for values > INT32_MAX\n        vbool32_t mask_max = vfgt_vf_f32m1_b32(v_float, (float)INT32_MAX, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_max, INT32_MAX, vl);\n        \n        // Handle saturation for values < INT32_MIN\n        vbool32_t mask_min = vflt_vf_f32m1_b32(v_float, (float)INT32_MIN, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_min, INT32_MIN, vl);\n        \n        vse32_v_i32m1(&B[i], v_int, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        v_float = vle32_v_f32m1(&A[i], vl);\n        \n        // Convert float to int with saturation\n        v_int = vfcvt_rtz_x_f_v_i32m1(v_float, vl);\n        \n        // Handle saturation for values > INT32_MAX\n        vbool32_t mask_max = vfgt_vf_f32m1_b32(v_float, (float)INT32_MAX, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_max, INT32_MAX, vl);\n        \n        // Handle saturation for values < INT32_MIN\n        vbool32_t mask_min = vflt_vf_f32m1_b32(v_float, (float)INT32_MIN, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_min, INT32_MIN, vl);\n        \n        vse32_v_i32m1(&B[i], v_int, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        v_float = vle32_v_f32m1(&A[i], vl);\n        \n        // Convert float to int with saturation\n        v_int = vfcvt_rtz_x_f_v_i32m1(v_float, vl);\n        \n        // Handle saturation for values > INT32_MAX\n        vbool32_t mask_max = vfgt_vf_f32m1_b32(v_float, (float)INT32_MAX, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_max, INT32_MAX, vl);\n        \n        // Handle saturation for values < INT32_MIN\n        vbool32_t mask_min = vflt_vf_f32m1_b32(v_float, (float)INT32_MIN, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_min, INT32_MIN, vl);\n        \n        vse32_v_i32m1(&B[i], v_int, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        v_float = vle32_v_f32m1(&A[i], vl);\n        \n        // Convert float to int with saturation\n        v_int = vfcvt_rtz_x_f_v_i32m1(v_float, vl);\n        \n        // Handle saturation for values > INT32_MAX\n        vbool32_t mask_max = vfgt_vf_f32m1_b32(v_float, (float)INT32_MAX, vl);\n        v_int = vmerge_vxm_i32m1(mask_max, v_int, INT32_MAX, vl);\n        \n        // Handle saturation for values < INT32_MIN\n        vbool32_t mask_min = vflt_vf_f32m1_b32(v_float, (float)INT32_MIN, vl);\n        v_int = vmerge_vxm_i32m1(mask_min, v_int, INT32_MIN, vl);\n        \n        vse32_v_i32m1(&B[i], v_int, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_50_RVV", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        v_float = vle32_v_f32m1(&A[i], vl);\n        \n        // Convert float to int with saturation\n        v_int = vfcvt_rtz_x_f_v_i32m1(v_float, vl);\n        \n        // Handle saturation for values > INT32_MAX\n        vbool32_t mask_max = vfgt_vf_f32m1_b32(v_float, (float)INT32_MAX, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_max, INT32_MAX, vl);\n        \n        // Handle saturation for values < INT32_MIN\n        vbool32_t mask_min = vflt_vf_f32m1_b32(v_float, (float)INT32_MIN, vl);\n        v_int = vmerge_vxm_i32m1(v_int, mask_min, INT32_MIN, vl);\n        \n        vse32_v_i32m1(&B[i], v_int, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    float scale_f = (float)scale;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        v_int = vle32_v_i32m1(&A[i], vl);\n        v_float = vfcvt_f_x_v_f32m1(v_int, vl);\n        v_float = vfmul_vf_f32m1(v_float, scale_f, vl);\n        vse32_v_f32m1(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    float scale_f = (float)scale;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        v_int = vle32_v_i32m1(&A[i], vl);\n        v_float = vfcvt_f_x_v_f32m1(v_int, vl);\n        v_float = vfmul_vf_f32m1(v_float, scale_f, vl);\n        vse32_v_f32m1(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_float;\n    vint32m1_t v_int;\n    float scale_f = (float)scale;\n    \n    for(size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        v_int = vle32_v_i32m1(&A[i], vl);\n        v_float = vfcvt_f_x_v_f32m1(v_int, vl);\n        v_float = vfmul_vf_f32m1(v_float, scale_f, vl);\n        vse32_v_f32m1(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    float scale_f = (float)scale;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vfloat32m8_t vf = vfcvt_f_x_v_f32m8(va, vl);\n        vfloat32m8_t vresult = vfmul_vf_f32m8(vf, scale_f, vl);\n        \n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_51_RVV", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t vl;\n    float scale_f = (float)scale;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vint32m8_t va = vle32_v_i32m8(&A[i], vl);\n        vfloat32m8_t vb = vfcvt_f_x_v_f32m8(va, vl);\n        vfloat32m8_t vresult = vfmul_vf_f32m8(vb, scale_f, vl);\n        \n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiv;\n    vint32m1_t vresult;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        \n        vdiv = vfdiv_vv_f32m1(va, vb, vl);\n        vresult = vfcvt_rtz_x_f_v_i32m1(vdiv, vl);\n        \n        vse32_v_i32m1(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m1_t va, vb, vdiv;\n    vint32m1_t vresult;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        va = vle32_v_f32m1(&A[i], vl);\n        vb = vle32_v_f32m1(&B[i], vl);\n        \n        vdiv = vfdiv_vv_f32m1(va, vb, vl);\n        vresult = vfcvt_rtz_x_f_v_i32m1(vdiv, vl);\n        \n        vse32_v_i32m1(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m8_t va, vb, vdiv;\n    vint32m8_t vresult;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        va = vle32_v_f32m8(&A[i], vl);\n        vb = vle32_v_f32m8(&B[i], vl);\n        \n        vdiv = vfdiv_vv_f32m8(va, vb, vl);\n        vresult = vfcvt_rtz_x_f_v_i32m8(vdiv, vl);\n        \n        vse32_v_i32m8(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m8_t va, vb, vdiv;\n    vint32m8_t vresult;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        va = vle32_v_f32m8(&A[i], vl);\n        vb = vle32_v_f32m8(&B[i], vl);\n        \n        vdiv = vfdiv_vv_f32m8(va, vb, vl);\n        vresult = vfcvt_rtz_x_f_v_i32m8(vdiv, vl);\n        \n        vse32_v_i32m8(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_52_RVV", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl;\n    vfloat32m8_t va, vb, vdiv;\n    vint32m8_t vresult;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        va = vle32_v_f32m8(&A[i], vl);\n        vb = vle32_v_f32m8(&B[i], vl);\n        \n        vdiv = vfdiv_vv_f32m8(va, vb, vl);\n        vresult = vfcvt_rtz_x_f_v_i32m8(vdiv, vl);\n        \n        vse32_v_i32m8(&C[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const double flt_max = (double)FLT_MAX;\n    const double neg_flt_max = (double)-FLT_MAX;\n    vfloat64m2_t v_a;\n    vfloat32m1_t v_b;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m2(size - i);\n        \n        v_a = vle64_v_f64m2(A + i, vl);\n        \n        // Clamp values to FLT_MAX range\n        v_a = vfmin_vf_f64m2(v_a, flt_max, vl);\n        v_a = vfmax_vf_f64m2(v_a, neg_flt_max, vl);\n        \n        // Convert double to float\n        v_b = vfncvt_f_f_w_f32m1(v_a, vl);\n        \n        vse32_v_f32m1(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    float max_val = FLT_MAX;\n    float min_val = -FLT_MAX;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m2(size - i);\n        \n        vfloat64m2_t va = vle64_v_f64m2(A + i, vl);\n        \n        // Convert double to float\n        vfloat32m1_t vb = vfncvt_f_f_w_f32m1(va, vl);\n        \n        // Load max and min values into vectors\n        vfloat32m1_t vmax = vfmv_v_f_f32m1(max_val, vl);\n        vfloat32m1_t vmin = vfmv_v_f_f32m1(min_val, vl);\n        \n        // Apply max threshold\n        vbool32_t mask_max = vmfgt_vf_f32m1_b32(vb, max_val, vl);\n        vb = vmerge_vvm_f32m1(mask_max, vb, vmax, vl);\n        \n        // Apply min threshold\n        vbool32_t mask_min = vmflt_vf_f32m1_b32(vb, min_val, vl);\n        vb = vmerge_vvm_f32m1(mask_min, vb, vmin, vl);\n        \n        // Store result\n        vse32_v_f32m1(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const double flt_max = (double)FLT_MAX;\n    const double neg_flt_max = (double)-FLT_MAX;\n    vfloat64m2_t v_a;\n    vfloat32m1_t v_b;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m2(size - i);\n        \n        v_a = vle64_v_f64m2(A + i, vl);\n        \n        // Clamp values to FLT_MAX range\n        v_a = vfmin_vf_f64m2(v_a, flt_max, vl);\n        v_a = vfmax_vf_f64m2(v_a, neg_flt_max, vl);\n        \n        // Narrow double to float\n        v_b = vfncvt_f_f_w_f32m1(v_a, vl);\n        \n        vse32_v_f32m1(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    vfloat32m1_t v_fmax = vfmv_v_f_f32m1(FLT_MAX, 1);\n    vfloat32m1_t v_fmin = vfmv_v_f_f32m1(-FLT_MAX, 1);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m2(size - i);\n        \n        vfloat64m2_t v_double = vle64_v_f64m2(&A[i], vl);\n        vfloat32m1_t v_float = vfncvt_f_f_w_f32m1(v_double, vl);\n        \n        // Apply max threshold\n        vbool32_t mask_max = vmfgt_vf_f32m1_b32(v_float, FLT_MAX, vl);\n        v_float = vmerge_vvm_f32m1(v_float, mask_max, v_fmax, vl);\n        \n        // Apply min threshold  \n        vbool32_t mask_min = vmflt_vf_f32m1_b32(v_float, -FLT_MAX, vl);\n        v_float = vmerge_vvm_f32m1(v_float, mask_min, v_fmin, vl);\n        \n        vse32_v_f32m1(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_53_RVV", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t vl;\n    const double max_float = (double)FLT_MAX;\n    const double min_float = (double)-FLT_MAX;\n    vfloat32m1_t v_result;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e64m2_size_t(size - i);\n        \n        vfloat64m2_t v_input = vle64_v_f64m2(&A[i], vl);\n        \n        // Clamp values to float range\n        vfloat64m2_t v_max = vfmin_vf_f64m2(v_input, max_float, vl);\n        vfloat64m2_t v_clamped = vfmax_vf_f64m2(v_max, min_float, vl);\n        \n        // Convert to float\n        v_result = vfncvt_f_f_w_f32m1(v_clamped, vl);\n        \n        // Store result\n        vse32_v_f32m1(&B[i], v_result, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m1(size - i);\n        vint16m1_t v_a = vle16_v_i16m1(A + i, vl);\n        vint32m2_t v_b = vsext_vf2_i32m2(v_a, vl);\n        vse32_v_i32m2(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for(size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m1(size - i);\n        vint16m1_t v_a = vle16_v_i16m1(A + i, vl);\n        vint32m2_t v_b = vsext_vf2_i32m2(v_a, vl);\n        vse32_v_i32m2(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m1(size - i);\n        vint16m1_t va = vle16_v_i16m1(A + i, vl);\n        vint32m2_t vb = vwcvt_x_x_v_i32m2(va, vl);\n        vse32_v_i32m2(B + i, vb, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m1(size - i);\n        vint16m1_t v_a = vle16_v_i16m1(A + i, vl);\n        vint32m2_t v_b = vsext_vf2_i32m2(v_a, vl);\n        vse32_v_i32m2(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_RVV", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e16m1(size - i);\n        vint16m1_t v_a = vle16_v_i16m1(A + i, vl);\n        vint32m2_t v_b = vwcvt_x_x_v_i32m2(v_a, vl);\n        vse32_v_i32m2(B + i, v_b, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float range = max_val - min_val;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vint32m8_t vcontrol = vle32_v_i32m8(&control[i], vl);\n        \n        // Create mask for control > 0\n        vbool4_t mask = vmsgt_vx_i32m8_b4(vcontrol, 0, vl);\n        \n        // Calculate normalized values\n        vfloat32m8_t vsub = vfsub_vf_f32m8(va, min_val, vl);\n        vfloat32m8_t vnorm = vfdiv_vf_f32m8(vsub, range, vl);\n        \n        // Clamp to [0,1]\n        vfloat32m8_t vclamp = vfmax_vf_f32m8(vnorm, 0.0f, vl);\n        vclamp = vfmin_vf_f32m8(vclamp, 1.0f, vl);\n        \n        // Select between normalized and original based on mask\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(mask, va, vclamp, vl);\n        \n        // Store result\n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float range = max_val - min_val;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vint32m8_t vcontrol = vle32_v_i32m8(&control[i], vl);\n        \n        // Create mask for control > 0\n        vbool4_t mask = vmsgt_vx_i32m8_b4(vcontrol, 0, vl);\n        \n        // Calculate normalized values\n        vfloat32m8_t vsub = vfsub_vf_f32m8(va, min_val, vl);\n        vfloat32m8_t vnorm = vfdiv_vf_f32m8(vsub, range, vl);\n        \n        // Clamp to [0,1]\n        vfloat32m8_t vclamp = vfmax_vf_f32m8(vnorm, 0.0f, vl);\n        vclamp = vfmin_vf_f32m8(vclamp, 1.0f, vl);\n        \n        // Select between normalized and original based on mask\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(mask, va, vclamp, vl);\n        \n        // Store result\n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float range = max_val - min_val;\n    \n    for(size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vint32m8_t vcontrol = vle32_v_i32m8(&control[i], vl);\n        \n        // Create mask for control > 0\n        vbool4_t mask = vmsgt_vx_i32m8_b4(vcontrol, 0, vl);\n        \n        // Calculate normalized values\n        vfloat32m8_t vsub = vfsub_vf_f32m8(va, min_val, vl);\n        vfloat32m8_t vnorm = vfdiv_vf_f32m8(vsub, range, vl);\n        \n        // Clamp between 0 and 1\n        vfloat32m8_t vclamp = vfmax_vf_f32m8(vnorm, 0.0f, vl);\n        vclamp = vfmin_vf_f32m8(vclamp, 1.0f, vl);\n        \n        // Select between normalized and original based on mask\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(mask, va, vclamp, vl);\n        \n        // Store result\n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float range = max_val - min_val;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vint32m8_t vcontrol = vle32_v_i32m8(&control[i], vl);\n        \n        // Create mask for positive control values\n        vbool4_t mask = vmsgt_vx_i32m8_b4(vcontrol, 0, vl);\n        \n        // Normalize values where control > 0\n        vfloat32m8_t vsub = vfsub_vf_f32m8(va, min_val, vl);\n        vfloat32m8_t vnorm = vfdiv_vf_f32m8(vsub, range, vl);\n        \n        // Clamp normalized values between 0 and 1\n        vfloat32m8_t vclamp = vfmax_vf_f32m8(vnorm, 0.0f, vl);\n        vclamp = vfmin_vf_f32m8(vclamp, 1.0f, vl);\n        \n        // Select between normalized and original values based on mask\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(mask, va, vclamp, vl);\n        \n        // Store results\n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_RVV", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    size_t vl;\n    float range = max_val - min_val;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        vfloat32m8_t va = vle32_v_f32m8(&A[i], vl);\n        vint32m8_t vcontrol = vle32_v_i32m8(&control[i], vl);\n        \n        // Create mask for control > 0\n        vbool4_t mask = vmsgt_vx_i32m8_b4(vcontrol, 0, vl);\n        \n        // Calculate normalized values\n        vfloat32m8_t vsub = vfsub_vf_f32m8(va, min_val, vl);\n        vfloat32m8_t vnorm = vfdiv_vf_f32m8(vsub, range, vl);\n        \n        // Clamp to [0,1]\n        vfloat32m8_t vclamp = vfmax_vf_f32m8(vnorm, 0.0f, vl);\n        vclamp = vfmin_vf_f32m8(vclamp, 1.0f, vl);\n        \n        // Select between normalized and original based on mask\n        vfloat32m8_t vresult = vmerge_vvm_f32m8(mask, va, vclamp, vl);\n        \n        // Store result\n        vse32_v_f32m8(&B[i], vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vl = vsetvl_e32m8(size);\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        // Load uint32 values\n        vuint32m8_t va = vle32_v_u32m8(A + i, vl);\n        \n        // Shift right by 16 to get high 16 bits\n        vuint32m8_t vhigh = vsrl_vx_u32m8(va, 16, vl);\n        \n        // Convert uint32 to float\n        vfloat32m8_t vf = vfcvt_f_xu_v_f32m8(vhigh, vl);\n        \n        // Calculate square root\n        vfloat32m8_t vresult = vfsqrt_v_f32m8(vf, vl);\n        \n        // Store results\n        vse32_v_f32m8(B + i, vresult, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vint32m1_t v_int;\n    vfloat32m1_t v_float;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        // Load uint32 values\n        v_int = vle32_v_i32m1((const int32_t*)(A + i), vl);\n        \n        // Shift right by 16 to get high 16 bits\n        v_int = vsrl_vx_i32m1(v_int, 16, vl);\n        \n        // Convert to float\n        v_float = vfcvt_f_xu_v_f32m1(v_int, vl);\n        \n        // Calculate square root\n        v_float = vfsqrt_v_f32m1(v_float, vl);\n        \n        // Store results\n        vse32_v_f32m1(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vlen = vsetvlmax_e32m8();\n    for (size_t i = 0; i < size; i += vlen) {\n        vlen = vsetvl_e32m8(size - i);\n        \n        // Load uint32 values\n        vuint32m8_t va = vle32_v_u32m8(A + i, vlen);\n        \n        // Shift right by 16 to get high 16 bits\n        vuint32m8_t vshifted = vsrl_vx_u32m8(va, 16, vlen);\n        \n        // Convert uint32 to float\n        vfloat32m8_t vf = vfcvt_f_xu_v_f32m8(vshifted, vlen);\n        \n        // Calculate square root\n        vfloat32m8_t vresult = vfsqrt_v_f32m8(vf, vlen);\n        \n        // Store results\n        vse32_v_f32m8(B + i, vresult, vlen);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vint32m1_t v_int;\n    vfloat32m1_t v_float;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        // Load uint32 values\n        v_int = vle32_v_i32m1((const int32_t*)(A + i), vl);\n        \n        // Shift right by 16 to get high 16 bits\n        v_int = vsrl_vx_i32m1(v_int, 16, vl);\n        \n        // Convert to float\n        v_float = vfcvt_f_xu_v_f32m1(v_int, vl);\n        \n        // Calculate square root\n        v_float = vfsqrt_v_f32m1(v_float, vl);\n        \n        // Store results\n        vse32_v_f32m1(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_56_RVV", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vint32m1_t v_int;\n    vfloat32m1_t v_float;\n    \n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m1(size - i);\n        \n        // Load uint32 values\n        v_int = vle32_v_i32m1((int32_t*)(A + i), vl);\n        \n        // Shift right by 16 to get high 16 bits\n        v_int = vsrl_vx_i32m1(v_int, 16, vl);\n        \n        // Convert to float\n        v_float = vfcvt_f_xu_v_f32m1(v_int, vl);\n        \n        // Calculate square root\n        v_float = vfsqrt_v_f32m1(v_float, vl);\n        \n        // Store results\n        vse32_v_f32m1(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_int = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t v_float = vreinterpret_v_u32m8_f32m8(v_int);\n        vse32_v_f32m8(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vl = vsetvl_e32m8(size);\n    \n    for(size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_int = vle32_v_u32m8(A + i, vl);\n        vfloat32m8_t v_float = vreinterpret_v_u32m8_f32m8(v_int);\n        vse32_v_f32m8(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t v_int = vle32_v_u32m8(&A[i], vl);\n        vfloat32m8_t v_float = vreinterpret_v_u32m8_f32m8(v_int);\n        vse32_v_f32m8(&B[i], v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    for (size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        vuint32m8_t va = vle32_v_u32m8(&A[i], vl);\n        vse32_v_f32m8((float*)&B[i], vreinterpret_v_u32m8_f32m8(va), vl);\n    }\n}\n```"}
{"task_id": "SimdBench_57_RVV", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t vl;\n    vl = vsetvl_e32m8(size);\n    \n    for(size_t i = 0; i < size; i += vl) {\n        vl = vsetvl_e32m8(size - i);\n        \n        // Load uint32 values\n        vuint32m8_t v_int = vle32_v_u32m8(A + i, vl);\n        \n        // Reinterpret as float without conversion\n        vfloat32m8_t v_float = vreinterpret_v_u32m8_f32m8(v_int);\n        \n        // Store float values\n        vse32_v_f32m8(B + i, v_float, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0\n    diff[0] = 0.0f;\n    \n    size_t vl;\n    vl = vsetvl_e32m1(size-1);\n    \n    // Process rest of array\n    size_t i;\n    for (i = 1; i < size; i += vl) {\n        vl = vsetvl_e32m1(size-i);\n        \n        // Load vectors\n        vint32m1_t v_curr = vle32_v_i32m1(&A[i], vl);\n        vint32m1_t v_prev = vle32_v_i32m1(&A[i-1], vl);\n        vbool32_t v_mask = vle1_v_b32(cond + i, vl);\n        \n        // Calculate difference\n        vint32m1_t v_diff = vsub_vv_i32m1(v_curr, v_prev, vl);\n        \n        // Convert to float under mask\n        vfloat32m1_t v_fdiff = vfcvt_f_x_v_f32m1_m(v_mask, \n                                                    vfmv_v_f_f32m1(0.0f, vl),\n                                                    v_diff,\n                                                    vl);\n                                                    \n        // Store result\n        vse32_v_f32m1(diff + i, v_fdiff, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0\n    diff[0] = 0.0f;\n    \n    size_t vl;\n    size_t index = 1;\n    \n    while (index < size) {\n        // Get vector length\n        vl = vsetvl_e32m8(size - index);\n        \n        // Load vectors\n        vint32m8_t v_curr = vle32_v_i32m8(&A[index], vl);\n        vint32m8_t v_prev = vle32_v_i32m8(&A[index-1], vl);\n        vbool4_t v_mask = vle1_v_b4(&cond[index], vl);\n        \n        // Calculate difference\n        vint32m8_t v_diff = vsub_vv_i32m8(v_curr, v_prev, vl);\n        \n        // Convert to float under mask\n        vfloat32m8_t v_fdiff = vfcvt_f_x_v_f32m8_m(v_mask, \n                                                    vfmv_v_f_f32m8(0.0f, vl),\n                                                    v_diff, \n                                                    vl);\n        \n        // Store result\n        vse32_v_f32m8(&diff[index], v_fdiff, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0\n    diff[0] = 0.0f;\n    \n    size_t vl;\n    size_t index = 1;\n    \n    while (index < size) {\n        vl = vsetvl_e32m8(size - index);\n        \n        // Load vectors\n        vint32m8_t v_curr = vle32_v_i32m8(&A[index], vl);\n        vint32m8_t v_prev = vle32_v_i32m8(&A[index-1], vl);\n        vbool4_t v_mask = vle1_v_b4(&cond[index], vl);\n        \n        // Calculate difference\n        vint32m8_t v_diff = vsub_vv_i32m8(v_curr, v_prev, vl);\n        \n        // Convert to float under mask\n        vfloat32m8_t v_fdiff = vfcvt_f_x_v_f32m8(v_diff, vl);\n        \n        // Store result with masking (0.0f where mask is false)\n        vfloat32m8_t v_zero = vfmv_v_f_f32m8(0.0f, vl);\n        vfloat32m8_t v_result = vmerge_vvm_f32m8(v_mask, v_zero, v_fdiff, vl);\n        \n        vse32_v_f32m8(&diff[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0\n    diff[0] = 0.0f;\n    \n    size_t vl;\n    size_t index = 1;\n    \n    while (index < size) {\n        vl = vsetvl_e32m8(size - index);\n        \n        // Load vectors\n        vint32m8_t v_curr = vle32_v_i32m8(&A[index], vl);\n        vint32m8_t v_prev = vle32_v_i32m8(&A[index-1], vl);\n        vbool4_t v_mask = vle1_v_b4(&cond[index], vl);\n        \n        // Calculate differences\n        vint32m8_t v_diff = vsub_vv_i32m8(v_curr, v_prev, vl);\n        \n        // Convert to float under mask, else 0\n        vfloat32m8_t v_fdiff = vfcvt_f_x_v_f32m8(v_diff, vl);\n        vfloat32m8_t v_result = vfmv_v_f_f32m8(0.0f, vl);\n        v_result = vmerge_vvm_f32m8(v_mask, v_result, v_fdiff, vl);\n        \n        // Store results\n        vse32_v_f32m8(&diff[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_RVV", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    // Set first element to 0\n    diff[0] = 0.0f;\n    \n    size_t vl;\n    size_t index = 1;\n    \n    while (index < size) {\n        vl = vsetvl_e32m8(size - index);\n        \n        // Load vectors\n        vint32m8_t v_curr = vle32_v_i32m8(&A[index], vl);\n        vint32m8_t v_prev = vle32_v_i32m8(&A[index-1], vl);\n        vbool4_t v_mask = vle1_v_b4(&cond[index], vl);\n        \n        // Calculate difference\n        vint32m8_t v_diff = vsub_vv_i32m8(v_curr, v_prev, vl);\n        \n        // Convert to float under mask, else 0\n        vfloat32m8_t v_fdiff = vfcvt_f_x_v_f32m8(v_diff, vl);\n        vfloat32m8_t v_zero = vfmv_v_f_f32m8(0.0f, vl);\n        vfloat32m8_t v_result = vmerge_vvm_f32m8(v_mask, v_zero, v_fdiff, vl);\n        \n        // Store result\n        vse32_v_f32m8(&diff[index], v_result, vl);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    vl = vsetvl_e32m1(length);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        // Load 32-bit values\n        vuint32m1_t v_src = vle32_v_u32m1(src + i, vl);\n        \n        // Zero-extend to 64-bit\n        vuint64m2_t v_dst = vwaddu_vx_u64m2(v_src, 0, vl);\n        \n        // Set high 32-bits to all 1s\n        v_dst = vor_vx_u64m2(v_dst, 0xFFFFFFFF00000000ULL, vl);\n        \n        // Store results\n        vse64_v_u64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    const uint64_t mask = 0xFFFFFFFF00000000ULL;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        vuint32m1_t v_src = vle32_v_u32m1(&src[i], vl);\n        vuint64m2_t v_dst = vwaddu_vx_u64m2(v_src, 0, vl);\n        v_dst = vor_vx_u64m2(v_dst, mask, vl);\n        \n        vse64_v_u64m2(&dst[i], v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    const uint64_t mask = 0xFFFFFFFF00000000ULL;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m2(length - i);\n        \n        vuint32m2_t v_src = vle32_v_u32m2(src + i, vl);\n        vuint64m4_t v_dst = vwaddu_vx_u64m4(v_src, 0, vl);\n        v_dst = vor_vx_u64m4(v_dst, mask, vl);\n        \n        vse64_v_u64m4(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    const uint64_t mask = 0xFFFFFFFF00000000ULL;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m1(length - i);\n        \n        vuint32m1_t v_src = vle32_v_u32m1(src + i, vl);\n        vuint64m2_t v_dst = vwaddu_vx_u64m2(v_src, 0, vl);\n        v_dst = vor_vx_u64m2(v_dst, mask, vl);\n        \n        vse64_v_u64m2(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_59_RVV", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t vl;\n    const uint64_t mask = 0xFFFFFFFF00000000ULL;\n    \n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e32m2(length - i);\n        \n        vuint32m2_t v_src = vle32_v_u32m2(src + i, vl);\n        vuint64m4_t v_dst = vwaddu_vx_u64m4(v_src, 0, vl);\n        v_dst = vor_vx_u64m4(v_dst, mask, vl);\n        \n        vse64_v_u64m4(dst + i, v_dst, vl);\n    }\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        \n        // Load indices\n        vint16m1_t v_idx = vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to 64-bit for gathering\n        vint64m4_t v_idx_64 = vwwcvt_x_x_v_i64m4(v_idx, vl);\n        \n        // Gather elements using indices\n        vfloat64m4_t v_gathered = vluxei64_v_f64m4(vec, v_idx_64, vl);\n        \n        // Reduce gathered elements\n        v_sum = vfredsum_vs_f64m4_f64m1(v_sum, v_gathered, v_sum, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, 1);\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        \n        // Load indices\n        vint16m1_t v_idx = vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to 64-bit for gathering\n        vint64m4_t v_idx_64 = vwwcvt_x_x_v_i64m4(v_idx, vl);\n        \n        // Gather elements using indices\n        vfloat64m4_t v_gathered = vluxei64_v_f64m4(vec, v_idx_64, vl);\n        \n        // Reduce gathered elements\n        v_sum = vfadd_vv_f64m1(v_sum, vfredsum_vs_f64m4_f64m1(v_sum, v_gathered, v_sum, vl), 1);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, 1);\n    \n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        \n        // Load indices\n        vint16m1_t v_idx = vle16_v_i16m1(index + i, vl);\n        \n        // Convert indices to 64-bit for gathering\n        vint64m4_t v_idx_64 = vwwcvt_x_x_v_i64m4(v_idx, vl);\n        \n        // Gather elements using indices\n        vfloat64m4_t v_gathered = vluxei64_v_f64m4(vec, v_idx_64, vl);\n        \n        // Reduce gathered elements\n        v_sum = vfredsum_vs_f64m4_f64m1(v_sum, v_gathered, v_sum, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, 1);\n\n    for (size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        \n        // Load indices\n        vint16m1_t v_idx = vle16_v_i16m1(index + i, vl);\n        \n        // Widen indices to 64-bit\n        vint64m4_t v_idx_wide = vwwcvt_x_x_v_i64m4(v_idx, vl);\n        \n        // Gather load elements using indices\n        vfloat64m4_t v_gather = vluxei64_v_f64m4(vec, v_idx_wide, vl);\n        \n        // Reduce sum\n        v_sum = vfredsum_vs_f64m4_f64m1(v_sum, v_gather, v_sum, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_RVV", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m1_t v_sum = vfmv_v_f_f64m1(0.0, 1);\n\n    for(size_t i = 0; i < length; i += vl) {\n        vl = vsetvl_e16m1(length - i);\n        \n        // Load indices\n        vint16m1_t v_idx = vle16_v_i16m1(index + i, vl);\n        \n        // Widen indices to 64-bit\n        vint64m4_t v_idx_wide = vwwcvt_x_x_v_i64m4(v_idx, vl);\n        \n        // Gather load elements using indices\n        vfloat64m4_t v_vec = vluxei64_v_f64m4(vec, v_idx_wide, vl);\n        \n        // Reduce sum\n        v_sum = vfredsum_vs_f64m4_f64m1(v_sum, v_vec, v_sum, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            size_t vl;\n            double sum = 0.0;\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_offset = (i + ki) * input_size + j;\n                size_t kernel_offset = ki * kernel_size;\n                \n                vfloat64m8_t v_input, v_kernel;\n                vfloat64m8_t v_mul;\n                vfloat64m1_t v_red;\n                \n                for (size_t kj = 0; kj < kernel_size; kj += vl) {\n                    vl = vsetvl_e64m8(kernel_size - kj);\n                    \n                    v_input = vle64_v_f64m8(&input[input_offset + kj], vl);\n                    v_kernel = vle64_v_f64m8(&kernel[kernel_offset + kj], vl);\n                    \n                    v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    v_red = vfredsum_vs_f64m8_f64m1(v_red, v_mul, v_red, vl);\n                }\n                \n                sum += vfmv_f_s_f64m1_f64(v_red);\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            size_t vl;\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_offset = (i + ki) * input_size + j;\n                size_t kernel_offset = ki * kernel_size;\n                \n                vfloat64m8_t v_input, v_kernel;\n                vfloat64m8_t v_mul;\n                vfloat64m1_t v_red;\n                \n                for (size_t kj = 0; kj < kernel_size; kj += vl) {\n                    vl = vsetvl_e64m8(kernel_size - kj);\n                    \n                    v_input = vle64_v_f64m8(&input[input_offset + kj], vl);\n                    v_kernel = vle64_v_f64m8(&kernel[kernel_offset + kj], vl);\n                    \n                    v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    v_red = vfredsum_vs_f64m8_f64m1(v_red, v_mul, v_red, vl);\n                }\n                \n                sum += vfmv_f_s_f64m1_f64(v_red);\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            size_t vl;\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_offset = (i + ki) * input_size + j;\n                size_t kernel_offset = ki * kernel_size;\n                \n                vfloat64m8_t v_input, v_kernel;\n                vfloat64m8_t v_mul;\n                vfloat64m1_t v_sum;\n                \n                size_t k = 0;\n                while (k < kernel_size) {\n                    vl = vsetvl_e64m8(kernel_size - k);\n                    \n                    v_input = vle64_v_f64m8(&input[input_offset + k], vl);\n                    v_kernel = vle64_v_f64m8(&kernel[kernel_offset + k], vl);\n                    \n                    v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    v_sum = vfredsum_vs_f64m8_f64m1(v_sum, v_mul, v_sum, vl);\n                    \n                    k += vl;\n                }\n                \n                sum += vfmv_f_s_f64m1_f64(v_sum);\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            size_t vl;\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_offset = (i + ki) * input_size + j;\n                size_t kernel_offset = ki * kernel_size;\n                \n                vfloat64m8_t v_input, v_kernel;\n                vfloat64m8_t v_mul;\n                vfloat64m1_t v_red;\n                \n                for (size_t kj = 0; kj < kernel_size; kj += vl) {\n                    vl = vsetvl_e64m8(kernel_size - kj);\n                    \n                    v_input = vle64_v_f64m8(&input[input_offset + kj], vl);\n                    v_kernel = vle64_v_f64m8(&kernel[kernel_offset + kj], vl);\n                    \n                    v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    v_red = vfredsum_vs_f64m8_f64m1(v_red, v_mul, v_red, vl);\n                }\n                \n                sum += vfmv_f_s_f64m1_f64(v_red);\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_RVV", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            size_t vl;\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_offset = (i + ki) * input_size + j;\n                size_t kernel_offset = ki * kernel_size;\n                \n                vfloat64m8_t v_input, v_kernel;\n                vfloat64m8_t v_mul;\n                vfloat64m1_t v_sum;\n                \n                size_t k = 0;\n                while (k < kernel_size) {\n                    vl = vsetvl_e64m8(kernel_size - k);\n                    \n                    v_input = vle64_v_f64m8(&input[input_offset + k], vl);\n                    v_kernel = vle64_v_f64m8(&kernel[kernel_offset + k], vl);\n                    \n                    v_mul = vfmul_vv_f64m8(v_input, v_kernel, vl);\n                    v_sum = vfredsum_vs_f64m8_f64m1(v_sum, v_mul, v_sum, vl);\n                    \n                    k += vl;\n                }\n                \n                sum += vfmv_f_s_f64m1_f64(v_sum);\n            }\n            \n            // ReLU activation\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vlen = __riscv_vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        double current = numbers[i];\n        size_t remaining = n - i - 1;\n        size_t vl;\n        \n        for (size_t j = 0; j < remaining; j += vlen) {\n            vl = __riscv_vsetvl_e64m8(remaining - j);\n            \n            vfloat64m8_t vec = __riscv_vle64_v_f64m8(&numbers[i+1+j], vl);\n            vfloat64m8_t diff = __riscv_vfsub_vf_f64m8(vec, current, vl);\n            vfloat64m8_t abs_diff = __riscv_vfabs_v_f64m8(diff, vl);\n            \n            vbool8_t mask = __riscv_vmflt_vf_f64m8_b8(abs_diff, threshold, vl);\n            \n            if (__riscv_vfirst_m_b8(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        double current = numbers[i];\n        size_t remaining = n - i - 1;\n        size_t vl = vsetvl_e64m8(remaining);\n        \n        vfloat64m8_t vec_nums = vle64_v_f64m8(&numbers[i+1], vl);\n        vfloat64m8_t vec_curr = vfmv_v_f_f64m8(current, vl);\n        vfloat64m8_t vec_diff = vfsub_vv_f64m8(vec_nums, vec_curr, vl);\n        vfloat64m8_t vec_abs = vfabs_v_f64m8(vec_diff, vl);\n        \n        vbool8_t mask = vmflt_vf_f64m8_b8(vec_abs, threshold, vl);\n        if (vmany_m_b8(mask, vl)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        double current = numbers[i];\n        \n        size_t j = i + 1;\n        size_t vl = vsetvl_e64m8(n - j);\n        \n        while (vl > 0) {\n            vfloat64m8_t v_nums = vle64_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t v_curr = vfmv_v_f_f64m8(current, vl);\n            \n            vfloat64m8_t v_diff = vfsub_vv_f64m8(v_nums, v_curr, vl);\n            vfloat64m8_t v_abs = vfabs_v_f64m8(v_diff, vl);\n            \n            vbool8_t mask = vmflt_vf_f64m8_b8(v_abs, threshold, vl);\n            \n            if (vfirst_m_b8(mask, vl) >= 0) {\n                return true;\n            }\n            \n            j += vl;\n            vl = vsetvl_e64m8(n - j);\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        double current = numbers[i];\n        size_t remaining = n - i - 1;\n        size_t vl = vsetvl_e64m8(remaining);\n        \n        vfloat64m8_t vec_nums = vle64_v_f64m8(&numbers[i+1], vl);\n        vfloat64m8_t vec_curr = vfmv_v_f_f64m8(current, vl);\n        \n        vfloat64m8_t vec_diff = vfsub_vv_f64m8(vec_nums, vec_curr, vl);\n        vfloat64m8_t vec_abs = vfabs_v_f64m8(vec_diff, vl);\n        \n        vbool8_t mask = vmflt_vf_f64m8_b8(vec_abs, threshold, vl);\n        \n        if (vmany_m_b8(mask, vl)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_RVV", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        double current = numbers[i];\n        \n        size_t j = i + 1;\n        size_t vl;\n        while (j < n) {\n            vl = vsetvl_e64m8(n - j);\n            \n            vfloat64m8_t v_nums = vle64_v_f64m8(&numbers[j], vl);\n            vfloat64m8_t v_curr = vfmv_v_f_f64m8(current, vl);\n            \n            vfloat64m8_t v_diff = vfsub_vv_f64m8(v_nums, v_curr, vl);\n            v_diff = vfabs_v_f64m8(v_diff, vl);\n            \n            vbool8_t mask = vmflt_vf_f64m8_b8(v_diff, threshold, vl);\n            \n            if (vmany_m_b8(mask, vl)) {\n                return true;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n    \n    int balance = 0;\n    size_t vl;\n    int *sums = new int[n];\n    \n    vint32m1_t v_sum = vmv_v_x_i32m1(0, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        vint32m1_t v_ops = vle32_v_i32m1(&operations[i], vl);\n        v_sum = vadd_vv_i32m1(v_sum, v_ops, vl);\n        vse32_v_i32m1(&sums[i], v_sum, vl);\n        \n        for (size_t j = i; j < i + vl && j < n; j++) {\n            balance += operations[j];\n            if (balance < 0) {\n                delete[] sums;\n                return true;\n            }\n        }\n    }\n    \n    delete[] sums;\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n\n    // Running sum array to store intermediate balances\n    std::vector<int> running_sum(n);\n    running_sum[0] = operations[0];\n\n    size_t vl;\n    vint32m1_t v_ops, v_sum;\n    int first_val = operations[0];\n    \n    // Process rest of array in vector chunks\n    size_t i;\n    for (i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector of operations\n        v_ops = vle32_v_i32m1(&operations[i], vl);\n        \n        // Get running sum up to previous element\n        int prev_sum = running_sum[i-1];\n        \n        // Add previous sum to first element\n        v_sum = vadd_vx_i32m1(v_ops, prev_sum, vl);\n        \n        // Store running sums\n        vse32_v_i32m1(&running_sum[i], v_sum, vl);\n        \n        // Check if any balance goes below 0\n        vbool32_t mask = vmslt_vx_i32m1_b32(v_sum, 0, vl);\n        if (vmany_m_b32(mask, vl)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t vlen = operations.size();\n    if (vlen == 0) return false;\n    \n    int balance = 0;\n    size_t i = 0;\n    \n    vint32m8_t v_balance;\n    \n    while (i < vlen) {\n        size_t vl = vsetvl_e32m8(vlen - i);\n        \n        // Load vector of operations\n        vint32m8_t v_ops = vle32_v_i32m8(&operations[i], vl);\n        \n        // Running sum using vector reduction\n        vint32m1_t v_sum = vredsum_vs_i32m8_i32m1(v_ops, v_ops, vmv_v_x_i32m1(balance, 1), vl);\n        balance += vmv_x_s_i32m1_i32(v_sum);\n        \n        // Check if balance goes below zero\n        v_balance = vmv_v_x_i32m8(balance, vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(v_balance, 0, vl);\n        \n        if (vmany_m_b4(mask, vl)) {\n            return true;\n        }\n        \n        i += vl;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n    \n    int balance = 0;\n    size_t vl;\n    int *sums = new int[n];\n    \n    vint32m1_t v_sum = vmv_v_x_i32m1(0, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        vint32m1_t v_ops = vle32_v_i32m1(&operations[i], vl);\n        v_sum = vadd_vv_i32m1(v_sum, v_ops, vl);\n        vse32_v_i32m1(&sums[i], v_sum, vl);\n        \n        for (size_t j = i; j < i + vl && j < n; j++) {\n            if (sums[j] < 0) {\n                delete[] sums;\n                return true;\n            }\n        }\n    }\n    \n    delete[] sums;\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_RVV", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    size_t n = operations.size();\n    if (n == 0) return false;\n    \n    int balance = 0;\n    size_t vl;\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1); // Initialize accumulator\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_ops = vle32_v_i32m1(&operations[i], vl);\n        \n        // Calculate running sum\n        v_sum = vadd_vx_i32m1(v_sum, balance, vl);\n        v_sum = vadd_vv_i32m1(v_sum, v_ops, vl);\n        \n        // Check if any element is negative\n        vbool32_t mask = vmslt_vx_i32m1_b32(v_sum, 0, vl);\n        if (vmany_m_b32(mask, vl)) {\n            return true;\n        }\n        \n        // Update balance with last element\n        balance = vmv_x_s_i32m1_i32(vslide1down_vx_i32m1(v_sum, 0, vl));\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n    \n    // Calculate mean first\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t v_nums = vle64_v_f64m8(&numbers[i], vl);\n        v_sum = vfadd_vv_f64m8(v_sum, v_nums, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vfmv_v_f_f64m1(0.0, 1), v_sum, 1));\n    double mean = sum / n;\n    \n    // Calculate absolute deviations\n    double mad_sum = 0.0;\n    vfloat64m8_t v_mad_sum = vfmv_v_f_f64m8(0.0, n);\n    vfloat64m8_t v_mean = vfmv_v_f_f64m8(mean, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t v_nums = vle64_v_f64m8(&numbers[i], vl);\n        vfloat64m8_t v_diff = vfsub_vv_f64m8(v_nums, v_mean, vl);\n        vfloat64m8_t v_abs = vfabs_v_f64m8(v_diff, vl);\n        v_mad_sum = vfadd_vv_f64m8(v_mad_sum, v_abs, vl);\n    }\n    \n    mad_sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vfmv_v_f_f64m1(0.0, 1), v_mad_sum, 1));\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n    \n    // Calculate mean first\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t v_nums = vle64_v_f64m8(&numbers[i], vl);\n        v_sum = vfadd_vv_f64m8(v_sum, v_nums, vl);\n    }\n    \n    sum = vfredsum_vs_f64m8_f64m1(v_sum, v_sum, vl);\n    double mean = sum / n;\n    \n    // Calculate absolute deviations\n    double mad = 0.0;\n    vfloat64m8_t v_mad = vfmv_v_f_f64m8(0.0, n);\n    vfloat64m8_t v_mean = vfmv_v_f_f64m8(mean, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t v_nums = vle64_v_f64m8(&numbers[i], vl);\n        vfloat64m8_t v_diff = vfsub_vv_f64m8(v_nums, v_mean, vl);\n        vfloat64m8_t v_abs = vfsgnjx_vv_f64m8(v_diff, v_diff, vl);\n        v_mad = vfadd_vv_f64m8(v_mad, v_abs, vl);\n    }\n    \n    mad = vfredsum_vs_f64m8_f64m1(v_mad, v_mad, vl);\n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n    \n    size_t vlen = vsetvlmax_e64m8();\n    vfloat64m8_t vzero = vfmv_v_f_f64m8(0.0, vlen);\n    \n    // Calculate mean\n    double sum = 0.0;\n    vfloat64m8_t vsum = vzero;\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t vx = vle64_v_f64m8(&numbers[i], vl);\n        vsum = vfadd_vv_f64m8(vsum, vx, vl);\n    }\n    \n    sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vzero, vsum, vzero, vlen));\n    double mean = sum / n;\n    \n    // Calculate absolute deviations\n    vfloat64m8_t vmean = vfmv_v_f_f64m8(mean, vlen);\n    vfloat64m8_t vabssum = vzero;\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t vx = vle64_v_f64m8(&numbers[i], vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(vx, vmean, vl);\n        vfloat64m8_t vabs = vfabs_v_f64m8(vdiff, vl);\n        vabssum = vfadd_vv_f64m8(vabssum, vabs, vl);\n    }\n    \n    double abs_sum = vfmv_f_s_f64m1_f64(vfredsum_vs_f64m8_f64m1(vzero, vabssum, vzero, vlen));\n    \n    return abs_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    // Calculate mean first\n    double sum = 0.0;\n    size_t vl;\n    vfloat64m8_t v_sum = vfmv_v_f_f64m8(0.0, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t v_num = vle64_v_f64m8(&numbers[i], vl);\n        v_sum = vfadd_vv_f64m8(v_sum, v_num, vl);\n    }\n    \n    sum = vfredsum_vs_f64m8_f64m1(v_sum, v_sum, n);\n    double mean = sum / n;\n\n    // Calculate absolute deviations\n    double mad_sum = 0.0;\n    vfloat64m8_t v_mad_sum = vfmv_v_f_f64m8(0.0, n);\n    vfloat64m8_t v_mean = vfmv_v_f_f64m8(mean, n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vfloat64m8_t v_num = vle64_v_f64m8(&numbers[i], vl);\n        vfloat64m8_t v_diff = vfsub_vv_f64m8(v_num, v_mean, vl);\n        vfloat64m8_t v_abs = vfabs_v_f64m8(v_diff, vl);\n        v_mad_sum = vfadd_vv_f64m8(v_mad_sum, v_abs, vl);\n    }\n    \n    mad_sum = vfredsum_vs_f64m8_f64m1(v_mad_sum, v_mad_sum, n);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_RVV", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t vlen = numbers.size();\n    double* data = numbers.data();\n    \n    // Calculate mean first\n    size_t vlmax = vsetvlmax_e64m8();\n    vfloat64m8_t vsum = vfmv_v_f_f64m8(0.0, vlmax);\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlen - i);\n        vfloat64m8_t v = vle64_v_f64m8(data + i, vl);\n        vsum = vfadd_vv_f64m8(vsum, v, vl);\n    }\n    \n    double sum = vfredsum_vs_f64m8_f64m1(vsum, vsum, vlmax);\n    double mean = sum / vlen;\n    \n    // Calculate absolute deviations\n    vfloat64m8_t vmean = vfmv_v_f_f64m8(mean, vlmax);\n    vfloat64m8_t vabssum = vfmv_v_f_f64m8(0.0, vlmax);\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlen - i);\n        vfloat64m8_t v = vle64_v_f64m8(data + i, vl);\n        vfloat64m8_t vdiff = vfsub_vv_f64m8(v, vmean, vl);\n        vfloat64m8_t vabs = vfabs_v_f64m8(vdiff, vl);\n        vabssum = vfadd_vv_f64m8(vabssum, vabs, vl);\n    }\n    \n    double abs_sum = vfredsum_vs_f64m8_f64m1(vabssum, vabssum, vlmax);\n    return abs_sum / vlen;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t n = numbers.size();\n    std::vector<int> result(2*n - 1);\n    \n    size_t vl;\n    vint32m1_t v_delim;\n    \n    // Process original elements\n    for (size_t i = 0; i < n; i++) {\n        result[i*2] = numbers[i];\n    }\n    \n    // Process delimiters\n    for (size_t i = 0; i < result.size(); i += 2*vl) {\n        vl = vsetvl_e32m1((result.size()-1-i)/2);\n        v_delim = vmv_v_x_i32m1(delimeter, vl);\n        vse32_v_i32m1(&result[i+1], v_delim, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t n = numbers.size();\n    std::vector<int> result(2*n - 1);\n    \n    size_t vl;\n    vint32m1_t v_delim;\n    \n    // Process original elements\n    for (size_t i = 0; i < n; i++) {\n        result[i*2] = numbers[i];\n    }\n    \n    // Process delimiters\n    for (size_t i = 0; i < n-1; i += vl) {\n        vl = vsetvl_e32m1(n-1 - i);\n        v_delim = vmv_v_x_i32m1(delimeter, vl);\n        vse32_v_i32m1(&result[i*2 + 1], v_delim, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t n = numbers.size();\n    std::vector<int> result(2 * n - 1);\n    \n    size_t vl;\n    vint32m1_t v_delim;\n    \n    // Process pairs of elements and insert delimeter between them\n    for (size_t i = 0; i < n-1; i += vl) {\n        vl = vsetvl_e32m1(n-1-i);\n        \n        // Load source elements\n        vint32m1_t v_src = vle32_v_i32m1(&numbers[i], vl);\n        \n        // Store to result with stride 2\n        vsse32_v_i32m1(&result[2*i], 2*sizeof(int), v_src, vl);\n        \n        // Store delimeter values\n        v_delim = vmv_v_x_i32m1(delimeter, vl);\n        vsse32_v_i32m1(&result[2*i+1], 2*sizeof(int), v_delim, vl);\n    }\n    \n    // Store last element\n    result[2*n-2] = numbers[n-1];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t n = numbers.size();\n    std::vector<int> result(2 * n - 1);\n    \n    size_t vl;\n    vint32m1_t v_delim;\n    \n    // Process original elements\n    for (size_t i = 0; i < n; i++) {\n        result[i * 2] = numbers[i];\n    }\n    \n    // Process delimiters\n    size_t delim_pos = 1;\n    while (delim_pos < result.size()) {\n        vl = vsetvl_e32m1(result.size() - delim_pos);\n        v_delim = vmv_v_x_i32m1(delimeter, vl);\n        vse32_v_i32m1(&result[delim_pos], v_delim, vl);\n        delim_pos += 2 * vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_RVV", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t n = numbers.size();\n    std::vector<int> result(2 * n - 1);\n    \n    size_t vl;\n    vint32m1_t v_delim;\n    \n    // Process original elements\n    for (size_t i = 0; i < n; i++) {\n        result[i * 2] = numbers[i];\n    }\n    \n    // Process delimiters using vector operations\n    for (size_t i = 0; i < n - 1; i += vl) {\n        vl = vsetvl_e32m1(n - 1 - i);\n        v_delim = vmv_v_x_i32m1(delimeter, vl);\n        vse32_v_i32m1(&result[i * 2 + 1], v_delim, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlen = numbers.size();\n    if (vlen == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vlmax = vsetvlmax_e16m1();\n    vint16m1_t v_input;\n    vint64m1_t v_sum = vmv_v_x_i64m1(0, 1);\n    vint64m1_t v_prod = vmv_v_x_i64m1(1, 1);\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlen - i);\n        v_input = vle16_v_i16m1(&numbers[i], vl);\n        \n        // Widen to 64-bit\n        vint32m2_t v_wide1 = vwcvt_x_x_v_i32m2(v_input, vl);\n        vint64m4_t v_wide2 = vwcvt_x_x_v_i64m4(v_wide1, vl);\n        \n        // Accumulate sum\n        v_sum = vredsum_vs_i64m4_i64m1(v_sum, v_wide2, v_sum, vl);\n        \n        // Accumulate product \n        v_prod = vredmul_vs_i64m4_i64m1(v_prod, v_wide2, v_prod, vl);\n    }\n    \n    sum = vmv_x_s_i64m1_i64(v_sum);\n    product = vmv_x_s_i64m1_i64(v_prod);\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlen = numbers.size();\n    std::vector<int64_t> result(2);\n    \n    if (vlen == 0) {\n        result[0] = 0;\n        result[1] = 1;\n        return result;\n    }\n\n    size_t vlmax = vsetvlmax_e16m1();\n    vint16m1_t v_zero = vmv_v_x_i16m1(0, vlmax);\n    vint16m1_t v_one = vmv_v_x_i16m1(1, vlmax);\n    \n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e16m1(vlen);\n        vint16m1_t v_input = vle16_v_i16m1(numbers.data(), vl);\n        \n        // Calculate sum\n        vint32m2_t v_sum_wide = vwredsum_vs_i16m1_i32m1(v_zero, v_input, v_zero, vl);\n        sum += (int64_t)vmv_x_s_i32m1_i32(v_sum_wide);\n        \n        // Calculate product\n        vint32m2_t v_prod_wide = vwmul_vv_i32m2(v_input, v_one, vl);\n        vint32m1_t v_prod_red = vredmul_vs_i32m2_i32m1(v_prod_wide, v_prod_wide, v_one, vl);\n        product *= vmv_x_s_i32m1_i32(v_prod_red);\n        \n        numbers.data() += vl;\n    }\n    \n    result[0] = sum;\n    result[1] = product;\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlen = numbers.size();\n    std::vector<int64_t> result(2);\n    \n    if (vlen == 0) {\n        result[0] = 0;\n        result[1] = 1;\n        return result;\n    }\n\n    size_t vlmax = vsetvlmax_e16m1();\n    vint16m1_t v_zero = vmv_v_x_i16m1(0, vlmax);\n    vint16m1_t v_one = vmv_v_x_i16m1(1, vlmax);\n    \n    vint64m1_t v_sum = vmv_v_x_i64m1(0, 1);\n    vint64m1_t v_prod = vmv_v_x_i64m1(1, 1);\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlen - i);\n        vint16m1_t v_input = vle16_v_i16m1(&numbers[i], vl);\n        \n        // Accumulate sum\n        vint64m1_t v_widened = vwadd_vx_i64m1(v_input, 0, vl);\n        v_sum = vadd_vv_i64m1(v_sum, v_widened, vl);\n        \n        // Accumulate product\n        if (i == 0) {\n            v_prod = vwmul_vx_i64m1(v_input, 1, vl);\n        } else {\n            v_prod = vwmul_vv_i64m1(v_input, v_prod, vl);\n        }\n    }\n    \n    // Store results\n    result[0] = vmv_x_s_i64m1_i64(v_sum);\n    result[1] = vmv_x_s_i64m1_i64(v_prod);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlen = numbers.size();\n    if (vlen == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vlmax = vsetvlmax_e16m1();\n    vint16m1_t v_input;\n    vint64m1_t v_sum = vmv_v_x_i64m1(0, 1);\n    vint64m1_t v_prod = vmv_v_x_i64m1(1, 1);\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlen - i);\n        v_input = vle16_v_i16m1(&numbers[i], vl);\n        \n        // Widen to 64-bit\n        vint64m1_t v_wide = vwcvt_x_x_v_i64m1(v_input, vl);\n        \n        // Accumulate sum\n        v_sum = vadd_vv_i64m1(v_sum, v_wide, vl);\n        \n        // Accumulate product \n        v_prod = vmul_vv_i64m1(v_prod, v_wide, vl);\n    }\n    \n    // Reduce sum and product\n    sum = vredsum_vs_i64m1_i64m1(v_sum, v_sum, vmv_v_x_i64m1(0, 1), 1);\n    product = vredmul_vs_i64m1_i64m1(v_prod, v_prod, vmv_v_x_i64m1(1, 1), 1);\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_RVV", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t vlen = numbers.size();\n    if (vlen == 0) {\n        return {0, 1};\n    }\n\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    size_t vlmax = vsetvlmax_e16m1();\n    vint16m1_t v_input;\n    vint64m1_t v_sum = vmv_v_x_i64m1(0, 1);\n    vint64m1_t v_prod = vmv_v_x_i64m1(1, 1);\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e16m1(vlen - i);\n        v_input = vle16_v_i16m1(&numbers[i], vl);\n        \n        // Widen to 64-bit and accumulate sum\n        vint32m2_t v_wide1 = vwext_vf2_i32m2(v_input, 1, vl);\n        vint64m4_t v_wide2 = vwext_vf2_i64m4(v_wide1, 1, vl);\n        v_sum = vadd_vv_i64m1(v_sum, vredsum_vs_i64m4_i64m1(v_sum, v_wide2, v_sum, vl));\n        \n        // Accumulate product\n        vint32m2_t v_prod32 = vwmul_vx_i32m2(v_input, 1, vl);\n        vint64m4_t v_prod64 = vwmul_vx_i64m4(v_prod32, 1, vl);\n        v_prod = vmul_vv_i64m1(v_prod, vredmul_vs_i64m4_i64m1(v_prod, v_prod64, v_prod, vl));\n    }\n    \n    sum = vmv_x_s_i64m1_i64(v_sum);\n    product = vmv_x_s_i64m1_i64(v_prod);\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    size_t vl;\n    vint32m1_t v_max;\n    \n    for (size_t i = 1; i < n;) {\n        vl = vsetvl_e32m1(n - i);\n        v_max = vle32_v_i32m1(&numbers[i], vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            int curr_max = vmv_x_s_i32m1_i32(v_max);\n            curr_max = std::max(curr_max, result[i+j-1]);\n            result[i+j] = curr_max;\n            \n            if (j < vl-1) {\n                v_max = vslide1down_vx_i32m1(v_max, numbers[i+j+1], vl-j);\n            }\n        }\n        \n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    size_t vlen = vsetvlmax_e32m8();\n    \n    for (size_t i = 1; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        \n        vint32m8_t v_prev = vle32_v_i32m8(&result[i-1], 1);\n        vint32m8_t v_curr = vle32_v_i32m8(&numbers[i], vl);\n        \n        vint32m8_t v_max = vmax_vv_i32m8(v_curr, v_prev, vl);\n        \n        for (size_t j = 1; j < vl; j++) {\n            vint32m8_t v_shift = vslide1up_vx_i32m8(v_max, vse32_v_i32m8(&result[i+j-1], v_max, 1), vl-j);\n            v_max = vmax_vv_i32m8(v_max, v_shift, vl-j);\n        }\n        \n        vse32_v_i32m8(&result[i], v_max, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    size_t vl;\n    vint32m1_t v_max;\n    \n    for (size_t i = 1; i < n;) {\n        vl = vsetvl_e32m1(n - i);\n        v_max = vle32_v_i32m1(&numbers[i], vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            int curr_max = result[i + j - 1];\n            vint32m1_t v_curr = vmv_v_x_i32m1(curr_max, vl);\n            v_max = vmax_vv_i32m1(v_max, v_curr, vl);\n            vse32_v_i32m1(&result[i], v_max, vl);\n        }\n        \n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    size_t vl;\n    vint32m1_t v_max;\n    \n    for (size_t i = 1; i < n;) {\n        vl = vsetvl_e32m1(n - i);\n        v_max = vle32_v_i32m1(&numbers[i], vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            int prev_max = result[i + j - 1];\n            int curr = numbers[i + j];\n            result[i + j] = (curr > prev_max) ? curr : prev_max;\n        }\n        \n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_RVV", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    size_t vlen = vsetvlmax_e32m8();\n    for (size_t i = 1; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        \n        vint32m8_t v_prev = vle32_v_i32m8(&result[i-1], 1);\n        vint32m8_t v_curr = vle32_v_i32m8(&numbers[i], vl);\n        \n        vint32m8_t v_max = vmax_vv_i32m8(v_curr, v_prev, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            result[i+j] = vmv_x_s_i32m8_i32(vslidedown_vx_i32m8(v_max, j, vl));\n            if (j < vl-1) {\n                v_max = vmax_vv_i32m8(v_max, vslidedown_vx_i32m8(v_max, j+1, vl), vl);\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.length();\n    std::string result(n, '0');\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e8m8(n - i);\n        \n        vuint8m8_t va = __riscv_vle8_v_u8m8((uint8_t*)&a[i], vl);\n        vuint8m8_t vb = __riscv_vle8_v_u8m8((uint8_t*)&b[i], vl);\n        \n        // Convert '0'/'1' chars to 0/1 integers\n        va = __riscv_vsub_vx_u8m8(va, '0', vl);\n        vb = __riscv_vsub_vx_u8m8(vb, '0', vl);\n        \n        // XOR operation\n        vuint8m8_t vxor = __riscv_vxor_vv_u8m8(va, vb, vl);\n        \n        // Convert back to '0'/'1' chars\n        vxor = __riscv_vadd_vx_u8m8(vxor, '0', vl);\n        \n        // Store result\n        __riscv_vse8_v_u8m8((uint8_t*)&result[i], vxor, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.length();\n    std::string result(n, '0');\n    \n    size_t vl;\n    vint8m8_t va, vb, vxor;\n    \n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m8(n - i);\n        \n        va = vle8_v_i8m8((int8_t*)&a[i], vl);\n        vb = vle8_v_i8m8((int8_t*)&b[i], vl);\n        \n        // Convert '0'/'1' chars to 0/1 integers\n        va = vsub_vx_i8m8(va, '0', vl);\n        vb = vsub_vx_i8m8(vb, '0', vl);\n        \n        // Perform XOR\n        vxor = vxor_vv_i8m8(va, vb, vl);\n        \n        // Convert back to '0'/'1' chars\n        vxor = vadd_vx_i8m8(vxor, '0', vl);\n        \n        // Store result\n        vse8_v_i8m8((int8_t*)&result[i], vxor, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.length();\n    std::string result(n, '0');\n    \n    size_t vl;\n    vint8m8_t va, vb, vxor;\n    \n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m8(n - i);\n        \n        va = vle8_v_i8m8((int8_t*)&a[i], vl);\n        vb = vle8_v_i8m8((int8_t*)&b[i], vl);\n        \n        // Convert '0'/'1' chars to 0/1 integers\n        va = vsub_vx_i8m8(va, '0', vl);\n        vb = vsub_vx_i8m8(vb, '0', vl);\n        \n        // Perform XOR\n        vxor = vxor_vv_i8m8(va, vb, vl);\n        \n        // Convert back to '0'/'1' chars\n        vxor = vadd_vx_i8m8(vxor, '0', vl);\n        \n        // Store result\n        vse8_v_i8m8((int8_t*)&result[i], vxor, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.length();\n    std::string result(n, '0');\n    \n    size_t vl;\n    vint8m8_t va, vb, vxor;\n    \n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m8(n - i);\n        \n        va = vle8_v_i8m8((int8_t*)&a[i], vl);\n        vb = vle8_v_i8m8((int8_t*)&b[i], vl);\n        \n        // Convert '0'/'1' chars to 0/1 integers\n        va = vsub_vx_i8m8(va, '0', vl);\n        vb = vsub_vx_i8m8(vb, '0', vl);\n        \n        // Perform XOR\n        vxor = vxor_vv_i8m8(va, vb, vl);\n        \n        // Convert back to '0'/'1' chars\n        vxor = vadd_vx_i8m8(vxor, '0', vl);\n        \n        // Store result\n        vse8_v_i8m8((int8_t*)&result[i], vxor, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_RVV", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t vlen = vsetvlmax_e8m8();\n    for(size_t i = 0; i < len; i += vlen) {\n        size_t vl = vsetvl_e8m8(len - i);\n        \n        vuint8m8_t va = vle8_v_u8m8((uint8_t*)&a[i], vl);\n        vuint8m8_t vb = vle8_v_u8m8((uint8_t*)&b[i], vl);\n        \n        // Convert '0'/'1' chars to 0/1 integers\n        va = vsub_vx_u8m8(va, '0', vl);\n        vb = vsub_vx_u8m8(vb, '0', vl);\n        \n        // XOR operation\n        vuint8m8_t vresult = vxor_vv_u8m8(va, vb, vl);\n        \n        // Convert back to '0'/'1' chars\n        vresult = vadd_vx_u8m8(vresult, '0', vl);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&result[i], vresult, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vl;\n    size_t n = strings.size();\n\n    vint32m8_t vec_lens;\n    size_t avl = n;\n\n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        vec_lens = vle32_v_i32m8(reinterpret_cast<const int32_t*>(&strings[n - avl]), vl);\n        \n        vbool4_t mask = vmfgt_vx_i32m8_b4(vec_lens, max_len, vl);\n        \n        if (vfirst_m_b4(mask, vl) >= 0) {\n            vint32m8_t idx_vec = vid_v_i32m8(vl);\n            vint32m8_t masked_idx = vmerge_vxm_i32m8(vundefined_i32m8(), mask, idx_vec, 0, vl);\n            int32_t first_idx = vmv_x_s_i32m8_i32(masked_idx);\n            \n            max_len = strings[n - avl + first_idx].length();\n            max_idx = n - avl + first_idx;\n        }\n        \n        avl -= vl;\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vl;\n    size_t n = strings.size();\n    \n    vint32m8_t vec_lens;\n    size_t avl = n;\n    \n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        vec_lens = vle32_v_i32m8(reinterpret_cast<const int32_t*>(&strings[n - avl]), vl);\n        \n        vbool4_t mask = vmsleu_vx_i32m8_b4(vec_lens, max_len, vl);\n        \n        if (!vmany_m_b4(mask, vl)) {\n            vint32m8_t indices = vid_v_i32m8(vl);\n            vint32m8_t masked_indices = vmerge_vxm_i32m8(mask, indices, -1, vl);\n            \n            int32_t first_idx = vmv_x_s_i32m1_i32(vredmin_vs_i32m8_i32m1(\n                vmv_v_x_i32m1(-1, 1),\n                masked_indices,\n                vmv_v_x_i32m1(-1, 1),\n                vl\n            ));\n            \n            if (first_idx >= 0) {\n                max_len = strings[n - avl + first_idx].length();\n                max_idx = n - avl + first_idx;\n            }\n        }\n        \n        avl -= vl;\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vl;\n    \n    size_t n = strings.size();\n    size_t i = 0;\n    \n    vint32m8_t vec_lens;\n    \n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        \n        vec_lens = vmv_v_x_i32m8(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            if (i + j < n) {\n                vec_lens = vslide_up_vx_i32m8(vec_lens, strings[i + j].length(), 1, vl);\n            }\n        }\n        \n        vbool4_t mask = vmfgt_vx_i32m8_b4(vec_lens, max_len, vl);\n        \n        if (vfirst_m_b4(mask, vl) >= 0) {\n            vint32m8_t idx_vec = vid_v_i32m8(vl);\n            vint32m8_t masked_idx = vmerge_vxm_i32m8(mask, vmv_v_x_i32m8(n, vl), idx_vec, vl);\n            int32_t first_idx = vmv_x_s_i32m8_i32(vredmin_vs_i32m8_i32m8(masked_idx, masked_idx, vl));\n            \n            if (first_idx < n) {\n                max_len = strings[i + first_idx].length();\n                max_idx = i + first_idx;\n            }\n        }\n        \n        i += vl;\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vl;\n    \n    size_t n = strings.size();\n    size_t i = 0;\n    \n    vuint32m8_t v_lens;\n    vuint32m8_t v_idx;\n    vuint32m8_t v_max;\n    vbool4_t mask;\n    \n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Load string lengths into vector\n        v_lens = vmv_v_x_u32m8(0, vl);\n        for (size_t j = 0; j < vl; j++) {\n            v_lens = vset_v_u32m8(v_lens, j, strings[i + j].length());\n        }\n        \n        // Load indices into vector\n        v_idx = vid_v_u32m8(vl);\n        v_idx = vadd_vx_u32m8(v_idx, i, vl);\n        \n        // Find max length in this chunk\n        v_max = vmv_v_x_u32m8(max_len, vl);\n        mask = vmsgt_vv_u32m8_b4(v_lens, v_max, vl);\n        \n        // Update max length and index if needed\n        if (vmany_m_b4(mask, vl)) {\n            size_t first_max_idx = 0;\n            for (size_t j = 0; j < vl; j++) {\n                uint32_t len = vget_v_u32m8_u32(v_lens, j);\n                if (len > max_len) {\n                    max_len = len;\n                    first_max_idx = j;\n                }\n            }\n            max_idx = i + first_max_idx;\n        }\n        \n        i += vl;\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_RVV", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vl;\n    \n    vint32m8_t vec_lens;\n    size_t n = strings.size();\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Load string lengths into vector register\n        vec_lens = vle32_v_i32m8(reinterpret_cast<const int32_t*>(&strings[i].length()), vl);\n        \n        // Find max length in current vector chunk\n        vbool4_t mask = vmfgt_vx_i32m8_b4(vec_lens, max_len, vl);\n        \n        if (vfirst_m_b4(mask, vl) != -1) {\n            // Update max length and index if larger found\n            vint32m8_t idx_vec = vid_v_i32m8(vl);\n            vint32m8_t masked_idx = vmerge_vxm_i32m8(vundefined_i32m8(), mask, idx_vec, 0, vl);\n            \n            size_t first_idx = vfirst_m_b4(mask, vl);\n            max_len = strings[i + first_idx].length();\n            max_idx = i + first_idx;\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vint64m1_t va = __riscv_vmv_v_x_i64m1(a, vlen);\n    vint64m1_t vb = __riscv_vmv_v_x_i64m1(b, vlen);\n    \n    while (b != 0) {\n        vint64m1_t vt = __riscv_vmv_v_v_i64m1(vb, vlen);\n        vint64m1_t vrem = __riscv_vrem_vv_i64m1(va, vb, vlen);\n        va = vt;\n        vb = vrem;\n        b = __riscv_vmv_x_s_i64m1_i64(vrem);\n    }\n    \n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vint64m1_t va = __riscv_vmv_v_x_i64m1(a, vlen);\n    vint64m1_t vb = __riscv_vmv_v_x_i64m1(b, vlen);\n    \n    while (b != 0) {\n        vint64m1_t vt = __riscv_vmv_v_v_i64m1(vb, vlen);\n        vint64m1_t vrem = __riscv_vrem_vv_i64m1(va, vb, vlen);\n        va = vt;\n        vb = vrem;\n        a = __riscv_vmv_x_s_i64m1_i64(va);\n        b = __riscv_vmv_x_s_i64m1_i64(vb);\n    }\n    \n    return a;\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vint64m1_t va = __riscv_vmv_v_x_i64m1(a, vlen);\n    vint64m1_t vb = __riscv_vmv_v_x_i64m1(b, vlen);\n    vbool64_t mask = __riscv_vmsne_vx_i64m1_b64(vb, 0, vlen);\n    \n    while(__riscv_vfirst_m_b64(mask, vlen) != -1) {\n        vint64m1_t vt = __riscv_vrem_vv_i64m1(va, vb, vlen);\n        va = vb;\n        vb = vt;\n        mask = __riscv_vmsne_vx_i64m1_b64(vb, 0, vlen);\n    }\n    \n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vint64m1_t va = __riscv_vmv_v_x_i64m1(a, vlen);\n    vint64m1_t vb = __riscv_vmv_v_x_i64m1(b, vlen);\n    vbool64_t mask = __riscv_vmseq_vx_i64m1_b64(vb, 0, vlen);\n    \n    while (!__riscv_vmfirst_m_b64(mask, vlen)) {\n        vint64m1_t vt = __riscv_vrem_vv_i64m1(va, vb, vlen);\n        va = vb;\n        vb = vt;\n        mask = __riscv_vmseq_vx_i64m1_b64(vb, 0, vlen);\n    }\n    \n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_70_RVV", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    size_t vlen = __riscv_vsetvlmax_e64m1();\n    vint64m1_t va = __riscv_vmv_v_x_i64m1(a, vlen);\n    vint64m1_t vb = __riscv_vmv_v_x_i64m1(b, vlen);\n    \n    while (b != 0) {\n        vint64m1_t vt = __riscv_vmv_v_x_i64m1(b, vlen);\n        vint64m1_t vrem = __riscv_vrem_vv_i64m1(va, vb, vlen);\n        va = vb;\n        vb = vrem;\n        b = __riscv_vmv_x_s_i64m1_i64(vrem);\n    }\n    \n    return __riscv_vmv_x_s_i64m1_i64(va);\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    size_t vl;\n    vfloat32m1_t v_min = vfmv_v_f_f32m1(min_diff, 1);\n    \n    for(size_t i = 0; i < n-1; i++) {\n        size_t remaining = n - i - 1;\n        float current = numbers[i];\n        \n        while(remaining > 0) {\n            vl = vsetvl_e32m8(remaining);\n            \n            vfloat32m8_t v_vec = vle32_v_f32m8(&numbers[i+1], vl);\n            vfloat32m8_t v_curr = vfmv_v_f_f32m8(current, vl);\n            \n            // Calculate absolute differences\n            vfloat32m8_t v_diff = vfsub_vv_f32m8(v_vec, v_curr, vl);\n            v_diff = vfabs_v_f32m8(v_diff, vl);\n            \n            // Find minimum difference in this vector\n            vfloat32m1_t v_red = vfredmin_vs_f32m8_f32m1(v_diff, v_diff, v_min, vl);\n            float min_in_vec = vfmv_f_s_f32m1_f32(v_red);\n            \n            if(min_in_vec < min_diff) {\n                // Find index where minimum occurred\n                vbool4_t mask = vmfeq_vf_f32m8_b4(v_diff, min_in_vec, vl);\n                size_t idx = 0;\n                for(size_t j = 0; j < vl; j++) {\n                    if(vmfirst_m_b4(mask, vl) == j) {\n                        idx = j;\n                        break;\n                    }\n                }\n                \n                min_diff = min_in_vec;\n                num1 = std::min(current, numbers[i+1+idx]);\n                num2 = std::max(current, numbers[i+1+idx]);\n            }\n            \n            remaining -= vl;\n            numbers += vl;\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    \n    for(size_t i = 0; i < n-1; i++) {\n        size_t vlmax = vsetvl_e32m8(n-i-1);\n        \n        vfloat32m8_t v_curr = vfmv_v_f_f32m8(numbers[i], vlmax);\n        vfloat32m8_t v_next = vle32_v_f32m8(&numbers[i+1], vlmax);\n        \n        // Calculate absolute differences\n        vfloat32m8_t v_diff = vfsub_vv_f32m8(v_next, v_curr, vlmax);\n        v_diff = vfabs_v_f32m8(v_diff, vlmax);\n        \n        // Find minimum difference\n        vfloat32m1_t v_min = vfredmin_vs_f32m8_f32m1(v_diff, v_diff, vlmax);\n        float curr_min = vfmv_f_s_f32m1_f32(v_min);\n        \n        if(curr_min < min_diff) {\n            // Find index of minimum difference\n            vbool4_t mask = vmfeq_vf_f32m8_b4(v_diff, curr_min, vlmax);\n            size_t idx = 0;\n            for(size_t j = 0; j < vlmax; j++) {\n                if(vmfirst_m_b4(mask)) {\n                    idx = j;\n                    break;\n                }\n                mask = vmsrl_vx_b4(mask, 1, vlmax);\n            }\n            \n            min_diff = curr_min;\n            num1 = numbers[i];\n            num2 = numbers[i+1+idx];\n        }\n    }\n    \n    if(num1 > num2) {\n        std::swap(num1, num2);\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    size_t vl;\n    vfloat32m1_t v_min_diff = vfmv_v_f_f32m1(min_diff, 1);\n    \n    for(size_t i = 0; i < n-1; i++) {\n        size_t remaining = n - i - 1;\n        float current = numbers[i];\n        \n        while(remaining > 0) {\n            vl = vsetvl_e32m8(remaining);\n            \n            vfloat32m8_t v_vec = vle32_v_f32m8(&numbers[i+1], vl);\n            vfloat32m8_t v_current = vfmv_v_f_f32m8(current, vl);\n            \n            // Calculate absolute differences\n            vfloat32m8_t v_diff = vfsub_vv_f32m8(v_vec, v_current, vl);\n            v_diff = vfabs_v_f32m8(v_diff, vl);\n            \n            // Find minimum difference in this vector\n            vfloat32m1_t v_red_diff = vfredmin_vs_f32m8_f32m1(v_diff, v_diff, v_min_diff, vl);\n            float current_min = vfmv_f_s_f32m1_f32(v_red_diff);\n            \n            if(current_min < min_diff) {\n                // Find index of minimum difference\n                vbool4_t mask = vmfeq_vf_f32m8_b4(v_diff, current_min, vl);\n                size_t idx = 0;\n                for(size_t j = 0; j < vl; j++) {\n                    if(vmfirst_m_b4(mask, vl) == j) {\n                        idx = j;\n                        break;\n                    }\n                }\n                \n                min_diff = current_min;\n                num1 = std::min(current, numbers[i+1+idx]);\n                num2 = std::max(current, numbers[i+1+idx]);\n            }\n            \n            remaining -= vl;\n            numbers.data() += vl;\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    size_t vl;\n    vfloat32m1_t v_min_diff = vfmv_v_f_f32m1(min_diff, 1);\n\n    for(size_t i = 0; i < n-1; i++) {\n        size_t remaining = n - i - 1;\n        float current = numbers[i];\n        \n        while(remaining > 0) {\n            vl = vsetvl_e32m1(remaining);\n            \n            vfloat32m1_t v_current = vfmv_v_f_f32m1(current, vl);\n            vfloat32m1_t v_nums = vle32_v_f32m1(&numbers[i+1], vl);\n            \n            // Calculate absolute differences\n            vfloat32m1_t v_diff = vfsub_vv_f32m1(v_nums, v_current, vl);\n            v_diff = vfabs_v_f32m1(v_diff, vl);\n            \n            // Find minimum difference in this vector\n            vfloat32m1_t v_min = vfredmin_vs_f32m1_f32m1(v_diff, v_diff, v_min_diff, vl);\n            float min_val = vfmv_f_s_f32m1_f32(v_min);\n            \n            if(min_val < min_diff) {\n                // Find index where minimum occurred\n                vbool32_t mask = vmfeq_vf_f32m1_b32(v_diff, min_val, vl);\n                size_t idx = 0;\n                for(size_t j = 0; j < vl; j++) {\n                    if(vmfirst_m_b32(mask)) {\n                        idx = j;\n                        break;\n                    }\n                    mask = vmsrl_vx_b32(mask, 1, vl);\n                }\n                \n                min_diff = min_val;\n                num1 = std::min(current, numbers[i+1+idx]);\n                num2 = std::max(current, numbers[i+1+idx]);\n            }\n            \n            remaining -= vl;\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_RVV", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    \n    for(size_t i = 0; i < n-1; i++) {\n        size_t vlmax = vsetvl_e32m8(n-i-1);\n        vfloat32m8_t v1 = vfmv_v_f_f32m8(numbers[i], vlmax);\n        vfloat32m8_t v2 = vle32_v_f32m8(&numbers[i+1], vlmax);\n        \n        vfloat32m8_t diff = vfsub_vv_f32m8(v2, v1, vlmax);\n        vfloat32m8_t abs_diff = vfabs_v_f32m8(diff, vlmax);\n        \n        vbool4_t mask = vmflt_vf_f32m8_b4(abs_diff, min_diff, vlmax);\n        \n        vfloat32m8_t min_vals = vfredmin_vs_f32m8_f32m8(abs_diff, abs_diff, vlmax);\n        float curr_min = vfmv_f_s_f32m8_f32(min_vals);\n        \n        if(curr_min < min_diff) {\n            size_t idx = 0;\n            vbool4_t first_min = vmfeq_vf_f32m8_b4(abs_diff, curr_min, vlmax);\n            \n            for(size_t j = 0; j < vlmax; j++) {\n                if(first_min.v[j]) {\n                    idx = j;\n                    break;\n                }\n            }\n            \n            min_diff = curr_min;\n            num1 = numbers[i];\n            num2 = numbers[i+1+idx];\n            if(num2 < num1) std::swap(num1, num2);\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float* data = numbers.data();\n    \n    // Find min and max using vector operations\n    size_t vlen = vsetvlmax_e32m8();\n    vfloat32m8_t vmax = vfmv_v_f_f32m8(data[0], vlen);\n    vfloat32m8_t vmin = vfmv_v_f_f32m8(data[0], vlen);\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        vlen = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(&data[i], vlen);\n        vmax = vfmax_vv_f32m8(vmax, v, vlen);\n        vmin = vfmin_vv_f32m8(vmin, v, vlen);\n    }\n    \n    // Reduce max and min across vector\n    float max_val = vfmv_f_s_f32m1_f32(vfredmax_vs_f32m8_f32m1(vfmv_s_f_f32m1(vfmv_v_f_f32m1(0.f, 1), 0.f), vmax, vlen));\n    float min_val = vfmv_f_s_f32m1_f32(vfredmin_vs_f32m8_f32m1(vfmv_s_f_f32m1(vfmv_v_f_f32m1(0.f, 1), data[0]), vmin, vlen));\n    \n    float range = max_val - min_val;\n    \n    // Apply transformation using vectors\n    for(size_t i = 0; i < n; i += vlen) {\n        vlen = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(&data[i], vlen);\n        \n        // x = (x - min) / (max - min)\n        v = vfsub_vf_f32m8(v, min_val, vlen);\n        v = vfdiv_vf_f32m8(v, range, vlen);\n        \n        vse32_v_f32m8(&data[i], v, vlen);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    \n    // Get vlen\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Find min and max values using vector reduction\n    vfloat32m8_t v_min = vfmv_v_f_f32m8(numbers[0], vlen);\n    vfloat32m8_t v_max = vfmv_v_f_f32m8(numbers[0], vlen);\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(&numbers[i], vl);\n        v_min = vfmin_vv_f32m8(v_min, v, vl);\n        v_max = vfmax_vv_f32m8(v_max, v, vl);\n    }\n    \n    float min_val = vfmv_f_s_f32m1_f32(vfredmin_vs_f32m8_f32m1(vfmv_s_f_f32m1(0.0f, 1), v_min, vlen));\n    float max_val = vfmv_f_s_f32m1_f32(vfredmax_vs_f32m8_f32m1(vfmv_s_f_f32m1(0.0f, 1), v_max, vlen));\n    \n    float range = max_val - min_val;\n    \n    // Apply transformation\n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(&numbers[i], vl);\n        \n        // x = (x - min) / (max - min)\n        v = vfsub_vf_f32m8(v, min_val, vl);\n        v = vfdiv_vf_f32m8(v, range, vl);\n        \n        vse32_v_f32m8(&numbers[i], v, vl);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    \n    // Find min and max using vector instructions\n    size_t vl;\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&numbers[i], vl);\n        \n        min_val = vfmin_vf_f32m1(min_val, v, vl);\n        max_val = vfmax_vf_f32m1(max_val, v, vl);\n    }\n    \n    float range = max_val - min_val;\n    \n    // Rescale values using vector instructions\n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&numbers[i], vl);\n        \n        // Subtract min\n        v = vfsub_vf_f32m1(v, min_val, vl);\n        \n        // Divide by range \n        v = vfdiv_vf_f32m1(v, range, vl);\n        \n        // Store result\n        vse32_v_f32m1(&numbers[i], v, vl);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    \n    // Get vector length\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Find min and max values using vector reduction\n    vfloat32m8_t v_min = vfmv_v_f_f32m8(numbers[0], vlen);\n    vfloat32m8_t v_max = vfmv_v_f_f32m8(numbers[0], vlen);\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(&numbers[i], vl);\n        v_min = vfmin_vv_f32m8(v_min, v, vl);\n        v_max = vfmax_vv_f32m8(v_max, v, vl);\n    }\n    \n    float min_val = vfmv_f_s_f32m1_f32(vfredmin_vs_f32m8_f32m1(vfmv_v_f_f32m1(numbers[0], 1), v_min, vlen));\n    float max_val = vfmv_f_s_f32m1_f32(vfredmax_vs_f32m8_f32m1(vfmv_v_f_f32m1(numbers[0], 1), v_max, vlen));\n    \n    float range = max_val - min_val;\n    \n    // Apply transformation\n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t v = vle32_v_f32m8(&numbers[i], vl);\n        \n        // x = (x - min) / (max - min)\n        v = vfsub_vf_f32m8(v, min_val, vl);\n        v = vfdiv_vf_f32m8(v, range, vl);\n        \n        vse32_v_f32m8(&numbers[i], v, vl);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_RVV", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    \n    // Find min and max using vector instructions\n    size_t vl;\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&numbers[i], vl);\n        \n        min_val = vfmin_vf_f32m1(min_val, v, vl);\n        max_val = vfmax_vf_f32m1(max_val, v, vl);\n    }\n    \n    float range = max_val - min_val;\n    \n    // Apply transformation using vector instructions\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v = vle32_v_f32m1(&numbers[i], vl);\n        \n        // Subtract min\n        v = vfsub_vf_f32m1(v, min_val, vl);\n        \n        // Divide by range\n        v = vfdiv_vf_f32m1(v, range, vl);\n        \n        // Store result\n        vse32_v_f32m1(&numbers[i], v, vl);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlen = vsetvlmax_e64m8();\n    vlen = vlen > (n/2) ? (n/2) : vlen;\n    \n    vuint64m8_t vec_indices;\n    vuint64m8_t vec_divisors;\n    vuint64m8_t vec_remainders;\n    vbool8_t mask;\n    \n    uint64_t max_divisor = 1;\n    \n    for(uint64_t i = 1; i < n/2; i += vlen) {\n        size_t avl = (i + vlen) > (n/2) ? (n/2 - i + 1) : vlen;\n        \n        // Generate vector of potential divisors\n        vec_indices = vid_v_u64m8(vlen);\n        vec_divisors = vadd_vx_u64m8(vec_indices, i, avl);\n        \n        // Calculate remainders\n        vec_remainders = vrem_vx_u64m8(vmv_v_x_u64m8(n, avl), vec_divisors, avl);\n        \n        // Find where remainder is 0\n        mask = vmseq_vx_u64m8_b8(vec_remainders, 0, avl);\n        \n        // Get max divisor from this chunk\n        vuint64m8_t masked_divisors = vmerge_vxm_u64m8(vmv_v_x_u64m8(0, avl), mask, vec_divisors, avl);\n        uint64_t chunk_max = vmv_x_s_u64m1_u64(vredmax_vs_u64m8_u64m1(vmv_s_x_u64m1(0), masked_divisors, avl));\n        \n        max_divisor = chunk_max > max_divisor ? chunk_max : max_divisor;\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlen = __riscv_vsetvlmax_e64m8();\n    uint64_t max_divisor = 1;\n    \n    vint64m8_t v_indices;\n    vbool8_t v_mask;\n    vint64m8_t v_n = __riscv_vmv_v_x_i64m8(n, vlen);\n    \n    for(uint64_t i = 2; i <= n/2; i += vlen) {\n        size_t vl = __riscv_vsetvl_e64m8(n/2 - i + 1);\n        v_indices = __riscv_vid_v_i64m8(vl);\n        v_indices = __riscv_vadd_vx_i64m8(v_indices, i, vl);\n        \n        vint64m8_t v_rem = __riscv_vrem_vv_i64m8(v_n, v_indices, vl);\n        v_mask = __riscv_vmseq_vx_i64m8_b8(v_rem, 0, vl);\n        \n        vint64m8_t v_divisors = __riscv_vmerge_vxm_i64m8(\n            __riscv_vmv_v_x_i64m8(0, vl), \n            v_indices, \n            v_mask, \n            vl\n        );\n        \n        max_divisor = __riscv_vmv_x_s_i64m8_i64(\n            __riscv_vredmax_vs_i64m8_i64m8(\n                v_divisors,\n                __riscv_vmv_v_x_i64m8(max_divisor, vl),\n                vl\n            )\n        );\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlen = vsetvlmax_e64m8();\n    vint64m8_t vec_indices;\n    uint64_t max_divisor = 1;\n    \n    for(uint64_t i = 0; i < n/2; i += vlen) {\n        size_t avl = vsetvl_e64m8(n/2 - i);\n        \n        // Generate vector of consecutive numbers\n        vec_indices = vid_v_i64m8(avl);\n        vint64m8_t vec_nums = vadd_vx_i64m8(vec_indices, i + 1, avl);\n        \n        // Calculate remainders\n        vint64m8_t vec_remainders = vrem_vx_i64m8(vle64_v_i64m8(&n, avl), vec_nums, avl);\n        \n        // Create mask where remainder is 0 (valid divisors)\n        vbool8_t mask = vmseq_vx_i64m8_b8(vec_remainders, 0, avl);\n        \n        // Get max value among valid divisors\n        vint64m8_t vec_masked_nums = vmerge_vxm_i64m8(vec_nums, mask, 0, avl);\n        int64_t max_val = vredmax_vs_i64m8_i64m8(vec_masked_nums, vec_masked_nums, avl);\n        \n        if(max_val > max_divisor) {\n            max_divisor = max_val;\n        }\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlen = __riscv_vsetvlmax_e64m8();\n    vlen = vlen > (n/2) ? (n/2) : vlen;\n    \n    vuint64m8_t v_indices = __riscv_vid_v_u64m8(vlen);\n    v_indices = __riscv_vadd_vx_u64m8(v_indices, 1, vlen);\n    \n    vuint64m8_t v_n = __riscv_vmv_v_x_u64m8(n, vlen);\n    vuint64m8_t v_remainders = __riscv_vrem_vv_u64m8(v_n, v_indices, vlen);\n    vbool8_t v_mask = __riscv_vmseq_vx_u64m8_b8(v_remainders, 0, vlen);\n    \n    vuint64m8_t v_divisors = __riscv_vmerge_vxm_u64m8(\n        __riscv_vmv_v_x_u64m8(0, vlen), \n        v_mask, \n        __riscv_vle64_v_u64m8(v_indices, vlen), \n        vlen\n    );\n    \n    uint64_t max_divisor = 1;\n    for (size_t i = 0; i < vlen; i++) {\n        uint64_t divisor = __riscv_vmv_x_s_u64m8_u64(\n            __riscv_vslidedown_vx_u64m8(v_divisors, i, vlen)\n        );\n        if (divisor > max_divisor) {\n            max_divisor = divisor;\n        }\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_RVV", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    size_t vlen = vsetvlmax_e64m8();\n    vint64m8_t vec_i, vec_div;\n    vbool8_t mask;\n    uint64_t result = 1;\n    \n    for (uint64_t i = 0; i < n/2; i += vlen) {\n        size_t avl = vsetvl_e64m8(n/2 - i);\n        \n        vec_i = vid_v_i64m8(avl);\n        vec_i = vadd_vx_i64m8(vec_i, i + 1, avl);\n        \n        vec_div = vdivu_vx_i64m8(vid_v_i64m8(1, avl), n, avl);\n        vec_div = vmul_vx_i64m8(vec_div, n, avl);\n        \n        mask = vmseq_vx_i64m8_b8(vec_div, 0, avl);\n        \n        vint64m8_t masked_i = vmerge_vxm_i64m8(mask, vec_i, 0, avl);\n        \n        vint64m1_t red = vredmax_vs_i64m8_i64m1(masked_i, masked_i, avl);\n        int64_t max_val = vmv_x_s_i64m1_i64(red);\n        \n        if (max_val > result) {\n            result = max_val;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n/2;\n    }\n    \n    size_t vl;\n    vint32m1_t vid;\n    \n    // Get max vector length for 32-bit integers\n    vl = vsetvlmax_e32m1();\n    \n    // Create vector of sequential integers starting from 3\n    vid = vid_v_i32m1(0, vl);\n    vint32m1_t v_threes = vmul_vx_i32m1(vid, 2, vl);\n    v_threes = vadd_vx_i32m1(v_threes, 3, vl);\n    \n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n/i;\n        }\n        \n        // Update vector of odd numbers\n        v_threes = vadd_vx_i32m1(v_threes, 2, vl);\n    }\n    \n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle special cases\n    if (n <= 1) return factors;\n    \n    size_t vl;\n    \n    // Try dividing by 2 first\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n/2;\n    }\n    \n    // Try odd numbers up to sqrt(n)\n    int sqrt_n = sqrt(n);\n    \n    // Initialize vector registers\n    vint32m1_t v_i, v_div, v_rem;\n    vbool32_t v_mask;\n    \n    // Process 8 potential factors at a time\n    for (int i = 3; i <= sqrt_n; i += 8) {\n        \n        // Get vector length\n        vl = vsetvl_e32m1(8);\n        \n        // Create vector of potential factors\n        v_i = vid_v_i32m1(vl);\n        v_i = vadd_vx_i32m1(v_i, i, vl);\n        \n        while (1) {\n            // Try dividing n by each factor\n            v_div = vdivu_vx_i32m1(n, v_i, vl);\n            v_rem = vrem_vx_i32m1(n, v_i, vl);\n            \n            // Check which divisions had remainder 0\n            v_mask = vmseq_vx_i32m1_b32(v_rem, 0, vl);\n            \n            // If no factors found, break\n            if (!vmany_m_b32(v_mask, vl)) break;\n            \n            // Get first factor that divided evenly\n            int factor = vfirst_m_b32(v_mask, vl);\n            factor += i;\n            \n            // Add factor and divide n\n            factors.push_back(factor);\n            n = n/factor;\n            sqrt_n = sqrt(n);\n        }\n    }\n    \n    // Add remaining prime if any\n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle special cases\n    if (n <= 1) return factors;\n    \n    // Get vector length\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Create vector of potential factors from 2 to sqrt(n)\n    int sqrt_n = sqrt(n);\n    std::vector<int> potential_factors(vlen);\n    for (int i = 0; i < vlen; i++) {\n        potential_factors[i] = i + 2;\n    }\n    \n    while (n > 1) {\n        // Load potential factors into vector register\n        vint32m8_t v_factors = vle32_v_i32m8(potential_factors.data(), vlen);\n        \n        // Create mask for factors that divide n\n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(v_factors, n), 0, vlen);\n        \n        // Find first factor\n        int first_factor = 0;\n        for (size_t i = 0; i < vlen; i++) {\n            if (mask.v[i]) {\n                first_factor = potential_factors[i];\n                break;\n            }\n        }\n        \n        // If no factor found in current range, check next range\n        if (first_factor == 0) {\n            for (int i = 0; i < vlen; i++) {\n                potential_factors[i] += vlen;\n            }\n            if (potential_factors[0] > sqrt_n) {\n                factors.push_back(n);\n                break;\n            }\n            continue;\n        }\n        \n        // Add factor and divide n\n        factors.push_back(first_factor);\n        n /= first_factor;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle special cases\n    if (n <= 1) return factors;\n    \n    // Get vector length\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Create vector of potential factors from 2 to sqrt(n)\n    int sqrtn = sqrt(n);\n    std::vector<int> candidates(vlen);\n    for (int i = 0; i < vlen; i++) {\n        candidates[i] = i + 2;\n    }\n    \n    vint32m8_t vcand = vle32_v_i32m8(candidates.data(), vlen);\n    \n    while (n > 1) {\n        // Create mask for divisible numbers\n        vbool4_t mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(vbroadcast_vx_i32m8(n, vlen), vcand, vlen), 0, vlen);\n        \n        // Find first divisible factor\n        int first_div = 0;\n        for (int i = 0; i < vlen; i++) {\n            if (n % candidates[i] == 0) {\n                first_div = candidates[i];\n                break;\n            }\n        }\n        \n        if (first_div == 0) {\n            // No divisors found - n is prime\n            factors.push_back(n);\n            break;\n        }\n        \n        // Add factor and divide n\n        factors.push_back(first_div);\n        n /= first_div;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_RVV", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n/2;\n    }\n\n    size_t vl;\n    vint32m1_t v_i, v_rem;\n    vbool32_t vmask;\n    \n    // Get maximum vector length\n    size_t max_vl = vsetvlmax_e32m1();\n    \n    // Start checking from 3 up to sqrt(n)\n    int sqrt_n = sqrt(n);\n    int i = 3;\n    \n    while (i <= sqrt_n) {\n        // Set vector length for remaining elements\n        vl = vsetvl_e32m1(sqrt_n - i + 1);\n        \n        // Create vector of consecutive odd numbers starting from i\n        v_i = vid_v_i32m1(vl);\n        v_i = vmul_vx_i32m1(v_i, 2, vl);\n        v_i = vadd_vx_i32m1(v_i, i, vl);\n        \n        while (n % i == 0) {\n            factors.push_back(i);\n            n = n/i;\n            sqrt_n = sqrt(n);\n        }\n        \n        i += 2 * vl;\n    }\n    \n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vl;\n    size_t i = 0;\n    size_t n = l.size();\n    \n    while (i < n) {\n        vl = vsetvl_e32m8(n - i);\n        \n        vfloat32m8_t v_input = vle32_v_f32m8(&l[i], vl);\n        \n        // Create mask for positive numbers\n        vbool4_t mask = vmfgt_vf_f32m8_b4(v_input, 0.0f, vl);\n        \n        // Compress positive elements\n        vfloat32m8_t v_pos = vcompress_vm_f32m8(mask, v_input, vl);\n        \n        // Get number of positive elements\n        size_t pos_count = vcpop_m_b4(mask, vl);\n        \n        // Resize result vector to fit new elements\n        size_t old_size = result.size();\n        result.resize(old_size + pos_count);\n        \n        // Store compressed positive elements\n        vse32_v_f32m8(&result[old_size], v_pos, pos_count);\n        \n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < l.size()) {\n        vl = vsetvl_e32m8(l.size() - i);\n        \n        vfloat32m8_t v_input = vle32_v_f32m8(&l[i], vl);\n        \n        // Create mask for positive numbers\n        vbool4_t mask = vmfgt_vf_f32m8_b4(v_input, 0.0f, vl);\n        \n        // Count number of positive elements\n        size_t pos_count = vcpop_m_b4(mask, vl);\n        \n        // Compress positive elements\n        vfloat32m8_t v_pos = vfmv_v_f_f32m8(0.0f, vl);\n        v_pos = vcompress_vm_f32m8(v_pos, mask, v_input, vl);\n        \n        // Store positive elements\n        float temp[vl];\n        vse32_v_f32m8(temp, v_pos, pos_count);\n        \n        result.insert(result.end(), temp, temp + pos_count);\n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < l.size()) {\n        // Get maximum vector length for this iteration\n        vl = vsetvl_e32m1(l.size() - i);\n        \n        // Load vector elements\n        vfloat32m1_t v = vle32_v_f32m1(&l[i], vl);\n        \n        // Create mask for positive numbers\n        vbool32_t mask = vmfgt_vf_f32m1_b32(v, 0.0f, vl);\n        \n        // Count number of positive elements\n        size_t popcnt = vcpop_m_b32(mask, vl);\n        \n        // Compress vector based on mask\n        vfloat32m1_t compressed = vcompress_vm_f32m1(mask, v, vl);\n        \n        // Resize result vector to accommodate new elements\n        size_t old_size = result.size();\n        result.resize(old_size + popcnt);\n        \n        // Store compressed results\n        vse32_v_f32m1(&result[old_size], compressed, popcnt);\n        \n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    size_t vl;\n    size_t n = l.size();\n    std::vector<float> result;\n    result.reserve(n);\n\n    // Process vector elements\n    size_t index = 0;\n    while (index < n) {\n        // Set vector length\n        vl = vsetvl_e32m8(n - index);\n\n        // Load vector\n        vfloat32m8_t v = vle32_v_f32m8(&l[index], vl);\n\n        // Create mask for positive numbers\n        vbool4_t mask = vmfgt_vf_f32m8_b4(v, 0.0f, vl);\n\n        // Compress vector using mask\n        vfloat32m8_t v_compressed = vcompress_vm_f32m8(v, mask, vl);\n        \n        // Get number of positive elements\n        size_t count = vcpop_m_b4(mask, vl);\n\n        // Store compressed results\n        float temp[count];\n        vse32_v_f32m8(temp, v_compressed, count);\n\n        // Add to result vector\n        result.insert(result.end(), temp, temp + count);\n\n        index += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_RVV", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    size_t vl;\n    size_t n = l.size();\n    std::vector<float> result;\n    \n    // Get maximum vector length\n    size_t vlmax = vsetvlmax_e32m8();\n    \n    // Process input vector in chunks\n    for (size_t i = 0; i < n; i += vlmax) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Load vector elements\n        vfloat32m8_t v = vle32_v_f32m8(&l[i], vl);\n        \n        // Create mask for positive numbers\n        vbool4_t mask = vmfgt_vf_f32m8_b4(v, 0.0f, vl);\n        \n        // Count positive numbers in this chunk\n        size_t popcnt = vcpop_m_b4(mask, vl);\n        \n        if (popcnt > 0) {\n            // Compress vector using mask to get only positive numbers\n            vfloat32m8_t v_pos = vcompress_vm_f32m8(v, mask, vl);\n            \n            // Extend result vector\n            size_t old_size = result.size();\n            result.resize(old_size + popcnt);\n            \n            // Store compressed positive numbers\n            vse32_v_f32m8(&result[old_size], v_pos, popcnt);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    int64_t sqrt_n = sqrt(n);\n    \n    vint64m8_t vinc = vid_v_i64m8(vlen);\n    vint64m8_t v6 = vmul_vx_i64m8(vinc, 6, vlen);\n    \n    for (int64_t i = 5; i <= sqrt_n; i += vlen * 6) {\n        vint64m8_t vi = vadd_vx_i64m8(v6, i, vlen);\n        vint64m8_t vi_plus_2 = vadd_vx_i64m8(vi, 2, vlen);\n        \n        vbool8_t mask1 = vmseq_vx_i64m8_b8(vrem_vx_i64m8(v6, n, vlen), 0, vlen);\n        vbool8_t mask2 = vmseq_vx_i64m8_b8(vrem_vx_i64m8(vadd_vx_i64m8(v6, 2, vlen), n, vlen), 0, vlen);\n        \n        if (vfirst_m_b8(mask1, vlen) != -1 || vfirst_m_b8(mask2, vlen) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    vint64m8_t vec_i, vec_div;\n    vbool8_t mask;\n    \n    int64_t i = 5;\n    int64_t limit = sqrt(n);\n    \n    while (i <= limit) {\n        size_t vl = vsetvl_e64m8(limit - i + 1);\n        \n        // Generate vector of consecutive numbers starting from i\n        vec_i = vid_v_i64m8(vl);\n        vec_i = vadd_vx_i64m8(vec_i, i, vl);\n        \n        // Check divisibility by i and i+2\n        vec_div = vrem_vx_i64m8(vec_i, n, vl);\n        mask = vmseq_vx_i64m8_b8(vec_div, 0, vl);\n        \n        if (vfirst_m_b8(mask, vl) != -1) {\n            return false;\n        }\n        \n        i += 6;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    int64_t sqrtn = sqrt(n);\n    \n    vint64m8_t vinc = vid_v_i64m8(vlen);\n    vint64m8_t v6 = vmul_vx_i64m8(vinc, 6, vlen);\n    \n    for (int64_t i = 5; i <= sqrtn; i += vlen * 6) {\n        vint64m8_t vidx = vadd_vx_i64m8(v6, i, vlen);\n        \n        // Check i+0 divisors\n        vbool8_t mask1 = vmsne_vx_i64m8_b8(vrem_vv_i64m8(vbroadcast_vx_i64m8(n, vlen), \n                                                         vidx, vlen), 0, vlen);\n        \n        // Check i+2 divisors  \n        vbool8_t mask2 = vmsne_vx_i64m8_b8(vrem_vv_i64m8(vbroadcast_vx_i64m8(n, vlen),\n                                                         vadd_vx_i64m8(vidx, 2, vlen), vlen), 0, vlen);\n        \n        vbool8_t final_mask = vand_mm_b8(mask1, mask2, vlen);\n        \n        if (!vmand_m_b8(final_mask, vlen)) {\n            return false;\n        }\n        \n        if (i + vlen * 6 > sqrtn) break;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    int64_t sqrtn = sqrt(n);\n    \n    vint64m8_t vinc = vid_v_i64m8(vlen);\n    vint64m8_t v6 = vmul_vx_i64m8(vinc, 6, vlen);\n    \n    for (int64_t i = 5; i <= sqrtn; i += vlen * 6) {\n        vint64m8_t vidx = vadd_vx_i64m8(v6, i, vlen);\n        \n        // Check i +/- 1\n        vint64m8_t vtest1 = vsub_vx_i64m8(vidx, 1, vlen);\n        vint64m8_t vtest2 = vadd_vx_i64m8(vidx, 1, vlen);\n        \n        vbool8_t vmask1 = vmsle_vx_i64m8_b8(vtest1, sqrtn, vlen);\n        vbool8_t vmask2 = vmsle_vx_i64m8_b8(vtest2, sqrtn, vlen);\n        \n        // Check if n is divisible by any number in vectors\n        vbool8_t vdiv1 = vmseq_vx_i64m8_b8(vrem_vv_i64m8(vmv_v_x_i64m8(n, vlen), vtest1, vlen), 0, vlen);\n        vbool8_t vdiv2 = vmseq_vx_i64m8_b8(vrem_vv_i64m8(vmv_v_x_i64m8(n, vlen), vtest2, vlen), 0, vlen);\n        \n        // Combine results\n        if (vany_m_b8(vand_mm_b8(vmask1, vdiv1, vlen)) || \n            vany_m_b8(vand_mm_b8(vmask2, vdiv2, vlen))) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_RVV", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m8();\n    vint64m8_t vec_i, vec_rem;\n    vbool8_t mask;\n    \n    int64_t i = 5;\n    int64_t limit = sqrt(n);\n    \n    while (i <= limit) {\n        size_t vl = vsetvl_e64m8(limit - i + 1);\n        \n        // Generate vector of consecutive numbers starting from i\n        vec_i = vid_v_i64m8(vl);\n        vec_i = vadd_vx_i64m8(vec_i, i, vl);\n        \n        // Calculate remainders\n        vec_rem = vrem_vx_i64m8(vec_i, n, vl);\n        \n        // Check if any remainder is 0\n        mask = vmseq_vx_i64m8_b8(vec_rem, 0, vl);\n        if (vfirst_m_b8(mask, vl) != -1) {\n            return false;\n        }\n        \n        i += vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    bool has_letter = false;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Check if character is letter\n        vbool1_t v_is_upper = vmsgtu_vx_u8m8_b1(v_chars, 64, vlen) & \n                             vmsle_vx_u8m8_b1(v_chars, 90, vlen);\n        vbool1_t v_is_lower = vmsgtu_vx_u8m8_b1(v_chars, 96, vlen) & \n                             vmsle_vx_u8m8_b1(v_chars, 122, vlen);\n        \n        // Convert case for letters\n        vuint8m8_t v_upper_to_lower = vadd_vx_u8m8_m(v_is_upper, v_chars, v_chars, 32, vlen);\n        vuint8m8_t v_lower_to_upper = vsub_vx_u8m8_m(v_is_lower, v_chars, v_chars, 32, vlen);\n        \n        // Merge results\n        vuint8m8_t v_result = v_chars;\n        v_result = vmerge_vvm_u8m8(v_is_upper, v_result, v_upper_to_lower, vlen);\n        v_result = vmerge_vvm_u8m8(v_is_lower, v_result, v_lower_to_upper, vlen);\n        \n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vlen);\n        \n        // Check if any letters found\n        vbool1_t v_any_letter = v_is_upper | v_is_lower;\n        has_letter |= vcpop_m_b1(v_any_letter, vlen) > 0;\n    }\n    \n    // Handle remaining elements\n    for (; i < s.length(); i++) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n    \n    // If no letters found, reverse the string\n    if (!has_letter) {\n        size_t len = s.length();\n        for (i = 0; i + vlen <= len/2; i += vlen) {\n            vuint8m8_t v_front = vle8_v_u8m8((uint8_t*)&result[i], vlen);\n            vuint8m8_t v_back = vle8_v_u8m8((uint8_t*)&result[len-i-vlen], vlen);\n            \n            vse8_v_u8m8((uint8_t*)&result[i], v_back, vlen);\n            vse8_v_u8m8((uint8_t*)&result[len-i-vlen], v_front, vlen);\n        }\n        \n        // Handle remaining elements\n        for (; i < len/2; i++) {\n            std::swap(result[i], result[len-1-i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    size_t vlen = vsetvlmax_e8m8();\n    size_t n = s.length();\n    size_t i;\n\n    bool has_letter = false;\n    \n    for (i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m8(n - i);\n        vuint8m8_t v_str = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Check if character is letter\n        vbool1_t is_upper = vmslt_vx_u8m8_b1(v_str, 91, vl) & \n                           vmsge_vx_u8m8_b1(v_str, 65, vl);\n        vbool1_t is_lower = vmslt_vx_u8m8_b1(v_str, 123, vl) & \n                           vmsge_vx_u8m8_b1(v_str, 97, vl);\n        \n        // Convert case for letters\n        vuint8m8_t v_result = v_str;\n        v_result = vmerge_vxm_u8m8(is_upper, v_result, v_str ^ 32, vl);\n        v_result = vmerge_vxm_u8m8(is_lower, v_result, v_str ^ 32, vl);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vl);\n        \n        // Check if any letters found\n        has_letter |= vany_m_b1(is_upper | is_lower, vl);\n    }\n\n    // If no letters found, reverse the string\n    if (!has_letter) {\n        for (i = 0; i < n/2; i += vlen) {\n            size_t vl = vsetvl_e8m8(std::min(vlen, n/2 - i));\n            \n            vuint8m8_t v_front = vle8_v_u8m8((uint8_t*)&result[i], vl);\n            vuint8m8_t v_back = vle8_v_u8m8((uint8_t*)&result[n-i-vl], vl);\n            \n            vse8_v_u8m8((uint8_t*)&result[n-i-vl], v_front, vl);\n            vse8_v_u8m8((uint8_t*)&result[i], v_back, vl);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    size_t i;\n    bool has_letter = false;\n\n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Check if character is letter\n        vbool1_t v_is_upper = __riscv_vmsge_vx_u8m8_b1(v_chars, 'A', vlen) && \n                             __riscv_vmsle_vx_u8m8_b1(v_chars, 'Z', vlen);\n        vbool1_t v_is_lower = __riscv_vmsge_vx_u8m8_b1(v_chars, 'a', vlen) && \n                             __riscv_vmsle_vx_u8m8_b1(v_chars, 'z', vlen);\n        \n        // Convert case for letters\n        vuint8m8_t v_upper_to_lower = __riscv_vadd_vx_u8m8_m(v_is_upper, v_chars, v_chars, 32, vlen);\n        vuint8m8_t v_lower_to_upper = __riscv_vsub_vx_u8m8_m(v_is_lower, v_chars, v_chars, 32, vlen);\n        \n        // Merge results\n        vuint8m8_t v_result = __riscv_vor_vv_u8m8(v_upper_to_lower, v_lower_to_upper, vlen);\n        v_result = __riscv_vmerge_vvm_u8m8(v_is_upper || v_is_lower, v_chars, v_result, vlen);\n        \n        // Store result\n        __riscv_vse8_v_u8m8((uint8_t*)&result[i], v_result, vlen);\n        \n        // Check if any letters found\n        has_letter |= __riscv_vany_b1(v_is_upper || v_is_lower, vlen);\n    }\n\n    // Handle remaining elements\n    for (; i < s.length(); i++) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n\n    // If no letters found, reverse the string\n    if (!has_letter) {\n        size_t left = 0;\n        size_t right = s.length() - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    bool has_letters = false;\n\n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Check if character is a letter\n        vbool1_t v_is_upper = vmsgtu_vx_u8m8_b1(v_chars, 64, vlen) & \n                             vmsltu_vx_u8m8_b1(v_chars, 91, vlen);\n        vbool1_t v_is_lower = vmsgtu_vx_u8m8_b1(v_chars, 96, vlen) & \n                             vmsltu_vx_u8m8_b1(v_chars, 123, vlen);\n        \n        // Convert uppercase to lowercase\n        vuint8m8_t v_to_lower = vadd_vx_u8m8_m(v_is_upper, v_chars, v_chars, 32, vlen);\n        \n        // Convert lowercase to uppercase  \n        vuint8m8_t v_result = vsub_vx_u8m8_m(v_is_lower, v_to_lower, v_chars, 32, vlen);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vlen);\n        \n        // Check if any letters found\n        vbool1_t v_any_letter = v_is_upper | v_is_lower;\n        has_letters |= vcpop_m_b1(v_any_letter, vlen) > 0;\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        if (isupper(s[i])) {\n            result[i] = tolower(s[i]);\n            has_letters = true;\n        }\n        else if (islower(s[i])) {\n            result[i] = toupper(s[i]);\n            has_letters = true;\n        }\n    }\n\n    // If no letters found, reverse the string\n    if (!has_letters) {\n        size_t len = s.length();\n        for (i = 0; i + vlen <= len/2; i += vlen) {\n            vuint8m8_t v_front = vle8_v_u8m8((uint8_t*)&result[i], vlen);\n            vuint8m8_t v_back = vle8_v_u8m8((uint8_t*)&result[len-i-vlen], vlen);\n            \n            vse8_v_u8m8((uint8_t*)&result[len-i-vlen], v_front, vlen);\n            vse8_v_u8m8((uint8_t*)&result[i], v_back, vlen);\n        }\n        \n        // Handle remaining characters\n        for (; i < len/2; i++) {\n            std::swap(result[i], result[len-1-i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_RVV", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    size_t i;\n    bool has_letter = false;\n\n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_str = __riscv_vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Check if character is letter\n        vbool1_t v_is_upper = __riscv_vmsgt_vx_u8m8_b1(v_str, 64, vlen);\n        vbool1_t v_is_lower = __riscv_vmsgt_vx_u8m8_b1(v_str, 96, vlen);\n        vbool1_t v_less_91 = __riscv_vmsle_vx_u8m8_b1(v_str, 90, vlen);\n        vbool1_t v_less_123 = __riscv_vmsle_vx_u8m8_b1(v_str, 122, vlen);\n        \n        vbool1_t v_is_upper_letter = __riscv_vmand_mm_b1(v_is_upper, v_less_91, vlen);\n        vbool1_t v_is_lower_letter = __riscv_vmand_mm_b1(v_is_lower, v_less_123, vlen);\n        vbool1_t v_is_letter = __riscv_vmor_mm_b1(v_is_upper_letter, v_is_lower_letter, vlen);\n\n        // Convert case if letter\n        vuint8m8_t v_upper = __riscv_vsub_vx_u8m8_m(v_is_lower_letter, v_str, 32, vlen);\n        vuint8m8_t v_lower = __riscv_vadd_vx_u8m8_m(v_is_upper_letter, v_str, 32, vlen);\n        \n        vuint8m8_t v_result = __riscv_vmerge_vvm_u8m8(v_str, v_upper, v_is_lower_letter, vlen);\n        v_result = __riscv_vmerge_vvm_u8m8(v_result, v_lower, v_is_upper_letter, vlen);\n        \n        __riscv_vse8_v_u8m8((uint8_t*)&result[i], v_result, vlen);\n\n        // Check if any letters found\n        vint8m8_t v_ones = __riscv_vmv_v_x_i8m8(1, vlen);\n        vint8m8_t v_letter_mask = __riscv_vmerge_vxm_i8m8(__riscv_vmv_v_x_i8m8(0, vlen), v_ones, v_is_letter, vlen);\n        if (__riscv_vredsum_vs_i8m8_i8m1(v_letter_mask, v_letter_mask, __riscv_vmv_s_x_i8m1(0, 1), vlen) > 0) {\n            has_letter = true;\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < s.length(); i++) {\n        if (isalpha(s[i])) {\n            has_letter = true;\n            result[i] = isupper(s[i]) ? tolower(s[i]) : toupper(s[i]);\n        }\n    }\n\n    // If no letters found, reverse the string\n    if (!has_letter) {\n        size_t len = s.length();\n        for (i = 0; i < len/2; i++) {\n            std::swap(result[i], result[len-1-i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Copy input to result\n    size_t vl;\n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n-i);\n        vint32m1_t v = vle32_v_i32m1(&l[i], vl);\n        vse32_v_i32m1(&result[i], v, vl);\n    }\n\n    // Count elements at indices divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    size_t idx = 0;\n    \n    for(size_t i = 0; i < n; i += 3) {\n        thirds[idx++] = l[i];\n    }\n    \n    // Sort the elements at indices divisible by 3\n    std::sort(thirds.begin(), thirds.begin() + idx);\n    \n    // Put sorted elements back\n    idx = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        result[i] = thirds[idx++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 3) return l;\n    \n    // Count elements at indices divisible by 3\n    size_t third_count = (n + 2) / 3;\n    std::vector<int> thirds(third_count);\n    \n    // Extract elements at indices divisible by 3\n    size_t vl;\n    size_t index = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        thirds[index++] = l[i];\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Put sorted elements back\n    index = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        l[i] = thirds[index++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n    \n    // Get number of elements divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    \n    // Extract elements at indices divisible by 3\n    size_t vl;\n    size_t index = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        vl = vsetvl_e32m1(third_size - index);\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        v_idx = vmul_vx_i32m1(v_idx, 3, vl);\n        vint32m1_t v_data = vlxei32_v_i32m1(&l[0], v_idx, vl);\n        vse32_v_i32m1(&thirds[index], v_data, vl);\n        index += vl;\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.begin() + ((n + 2) / 3));\n    \n    // Put sorted elements back\n    index = 0;\n    for (size_t i = 0; i < n; i += 3) {\n        vl = vsetvl_e32m1(third_size - index);\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        v_idx = vmul_vx_i32m1(v_idx, 3, vl);\n        vint32m1_t v_data = vle32_v_i32m1(&thirds[index], vl);\n        vsxei32_v_i32m1(&result[0], v_idx, v_data, vl);\n        index += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n    \n    // Get number of elements divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    \n    // Extract elements at indices divisible by 3\n    size_t vl;\n    size_t i = 0;\n    size_t third_idx = 0;\n    \n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        vint32m1_t v_add = vadd_vx_i32m1(v_idx, i, vl);\n        vbool32_t mask = vmsne_vx_i32m1_b32(vrem_vx_i32m1(v_add, 3, vl), 0, vl);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&l[i], vl);\n        vint32m1_t v_masked = vmerge_vxm_i32m1(mask, v_data, 0, vl);\n        \n        vse32_v_i32m1(&thirds[third_idx], v_masked, vl);\n        \n        i += vl;\n        third_idx += vl/3;\n    }\n    \n    // Sort the elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Put sorted elements back\n    i = 0;\n    third_idx = 0;\n    \n    while (i < n) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        vint32m1_t v_add = vadd_vx_i32m1(v_idx, i, vl);\n        vbool32_t mask = vmseq_vx_i32m1_b32(vrem_vx_i32m1(v_add, 3, vl), 0, vl);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&result[i], vl);\n        vint32m1_t v_thirds = vle32_v_i32m1(&thirds[third_idx], vl);\n        \n        vint32m1_t v_result = vmerge_vvm_i32m1(mask, v_data, v_thirds, vl);\n        vse32_v_i32m1(&result[i], v_result, vl);\n        \n        i += vl;\n        third_idx += vl/3;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_RVV", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result = l;\n    \n    // Get number of elements divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    \n    // Extract elements at indices divisible by 3\n    size_t vl;\n    size_t i = 0;\n    for(size_t idx = 0; idx < n; idx += 3) {\n        if(idx < n) {\n            thirds[i++] = l[idx];\n        }\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.begin() + i);\n    \n    // Put back sorted elements\n    i = 0;\n    for(size_t idx = 0; idx < n; idx += 3) {\n        if(idx < n) {\n            result[idx] = thirds[i++];\n        }\n    }\n    \n    // Process remaining elements using vectors\n    size_t avl = n;\n    vint32m1_t v_mask, v_idx, v_result;\n    \n    while(avl > 0) {\n        vl = vsetvl_e32m1(avl);\n        \n        // Create index vector\n        v_idx = vid_v_i32m1(vl);\n        \n        // Create mask for non-divisible-by-3 elements\n        v_mask = vmsne_vx_i32m1_b32(vrem_vx_i32m1(v_idx, 3, vl), 0, vl);\n        \n        // Load original elements where mask is 1\n        v_result = vle32_v_i32m1(&l[n-avl], vl);\n        vse32_v_i32m1(&result[n-avl], v_result, vl);\n        \n        avl -= vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlen = l.size();\n    float max_val = l[0];\n    float *ptr = l.data();\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t vmax = vfmv_v_f_f32m8(max_val, vlmax);\n    \n    for(size_t vl; vlen > 0; vlen -= vl, ptr += vl) {\n        vl = vsetvl_e32m8(vlen);\n        vfloat32m8_t vec = vle32_v_f32m8(ptr, vl);\n        vmax = vfmax_vv_f32m8(vmax, vec, vl);\n    }\n    \n    return vfmv_f_s_f32m8_f32(vredmax_vs_f32m8_f32m8(vmax, vmax, vmax, vlmax));\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlen = l.size();\n    float max_val = l[0];\n    float *ptr = l.data();\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t vmax = vfmv_v_f_f32m8(max_val, vlmax);\n    \n    for(size_t vl; vlen > 0; vlen -= vl, ptr += vl) {\n        vl = vsetvl_e32m8(vlen);\n        vfloat32m8_t vec = vle32_v_f32m8(ptr, vl);\n        vmax = vfmax_vv_f32m8(vmax, vec, vl);\n    }\n    \n    float result = max_val;\n    for(size_t i = 0; i < vlmax; i++) {\n        float temp = vfmv_f_s_f32m1_f32(vget_f32m1_f32m8(vmax, i));\n        result = fmax(result, temp);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlen = vsetvlmax_e32m8();\n    float max_val = l[0];\n    size_t n = l.size();\n    float *ptr = l.data();\n    \n    vfloat32m8_t vmax = vfmv_v_f_f32m8(max_val, vlen);\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vfloat32m8_t vec = vle32_v_f32m8(ptr + i, vl);\n        vmax = vfmax_vv_f32m8(vmax, vec, vl);\n    }\n    \n    float result = max_val;\n    for(size_t i = 0; i < vlen; i++) {\n        float temp = vfmv_f_s_f32m1_f32(vget_v_f32m8_f32m1(vmax, i));\n        result = (temp > result) ? temp : result;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t vlen = l.size();\n    float max_val = l[0];\n    float *ptr = l.data();\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t vmax = vfmv_v_f_f32m8(max_val, vlmax);\n    \n    for(size_t vl; vlen > 0; vlen -= vl, ptr += vl) {\n        vl = vsetvl_e32m8(vlen);\n        vfloat32m8_t vec = vle32_v_f32m8(ptr, vl);\n        vmax = vfmax_vv_f32m8(vmax, vec, vl);\n    }\n    \n    float result = max_val;\n    for(size_t i = 0; i < vlmax; i++) {\n        result = fmax(result, vfmv_f_s_f32m1_f32(vget_f32m1_f32m8(vmax, i)));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_RVV", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t vl;\n    float max_val = l[0];\n    size_t n = l.size();\n    float *ptr = l.data();\n    \n    vfloat32m1_t v_max = vfmv_v_f_f32m1(max_val, 1);\n    \n    for(size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vfloat32m1_t v_input = vle32_v_f32m1(ptr + i, vl);\n        v_max = vfmax_vv_f32m1(v_max, v_input, vl);\n    }\n    \n    max_val = vfmv_f_s_f32m1_f32(v_max);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl;\n    \n    // Process 8 elements at a time\n    vint32m8_t vid;\n    vbool4_t vmask11, vmask13;\n    \n    for(int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Generate vector of consecutive integers\n        vid = vid_v_i32m8(i, vl);\n        \n        // Check divisibility by 11 or 13\n        vmask11 = vmsgt_vx_i32m8_b4(vid, -1, vl);\n        vmask13 = vmsgt_vx_i32m8_b4(vid, -1, vl);\n        \n        vint32m8_t vrem11 = vrem_vx_i32m8(vid, 11, vl);\n        vint32m8_t vrem13 = vrem_vx_i32m8(vid, 13, vl);\n        \n        vmask11 = vmseq_vx_i32m8_b4(vrem11, 0, vl);\n        vmask13 = vmseq_vx_i32m8_b4(vrem13, 0, vl);\n        \n        vbool4_t vmask = vmor_mm_b4(vmask11, vmask13, vl);\n        \n        // Count digits equal to 7 for numbers passing the mask\n        vint32m8_t vtemp = vid;\n        vbool4_t vhas7;\n        \n        do {\n            vint32m8_t vdigit = vrem_vx_i32m8(vtemp, 10, vl);\n            vhas7 = vmseq_vx_i32m8_b4(vdigit, 7, vl);\n            vhas7 = vmandn_mm_b4(vhas7, vmask, vl);\n            count += vcpop_m_b4(vhas7, vl);\n            vtemp = vdiv_vx_i32m8(vtemp, 10, vl);\n        } while (vcpop_m_b4(vmseq_vx_i32m8_b4(vtemp, 0, vl), vl) < vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vlen = vsetvlmax_e32m8();\n    \n    vint32m8_t vid = vid_v_i32m8(vlen);\n    vint32m8_t vzero = vmv_v_x_i32m8(0, vlen);\n    \n    for(int i = 0; i < n; i += vlen) {\n        size_t avl = vsetvl_e32m8(n - i);\n        vint32m8_t vindex = vadd_vx_i32m8(vid, i, avl);\n        \n        // Check if divisible by 11\n        vbool4_t div11_mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(vindex, 11, avl), 0, avl);\n        // Check if divisible by 13  \n        vbool4_t div13_mask = vmseq_vx_i32m8_b4(vrem_vx_i32m8(vindex, 13, avl), 0, avl);\n        // Combine masks\n        vbool4_t div_mask = vmor_mm_b4(div11_mask, div13_mask, avl);\n        \n        // Get numbers that pass the divisibility check\n        vint32m8_t valid_nums = vmerge_vxm_i32m8(vzero, div_mask, vindex, avl);\n        \n        // Count 7s in each valid number\n        vint32m8_t count7 = vzero;\n        vbool4_t nonzero_mask = vmsgtu_vx_i32m8_b4(valid_nums, 0, avl);\n        \n        while(vany_m_b4(nonzero_mask, avl)) {\n            vint32m8_t digit = vrem_vx_i32m8(valid_nums, 10, avl);\n            vbool4_t is_seven = vmseq_vx_i32m8_b4(digit, 7, avl);\n            count7 = vadd_vx_i32m8_m(nonzero_mask, count7, count7, 1, avl);\n            valid_nums = vdiv_vx_i32m8(valid_nums, 10, avl);\n            nonzero_mask = vmsgtu_vx_i32m8_b4(valid_nums, 0, avl);\n        }\n        \n        // Sum up all counts\n        count += vredsum_vs_i32m8_i32m1(count7, vzero, avl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl;\n    \n    // Process 8 numbers at a time\n    vint32m1_t vid;\n    vbool32_t vmask11, vmask13;\n    vint32m1_t v7 = vmv_v_x_i32m1(7, 8);\n    vint32m1_t v10 = vmv_v_x_i32m1(10, 8);\n    vint32m1_t v0 = vmv_v_x_i32m1(0, 8);\n    \n    for(int i = 0; i < n; i += 8) {\n        vl = vsetvl_e32m1(min(8, n-i));\n        \n        // Generate vector of consecutive numbers\n        vid = vid_v_i32m1(vl);\n        vid = vadd_vx_i32m1(vid, i, vl);\n        \n        // Check if numbers are divisible by 11 or 13\n        vmask11 = vmseq_vx_i32m1_b32(vrem_vx_i32m1(vid, 11, vl), 0, vl);\n        vmask13 = vmseq_vx_i32m1_b32(vrem_vx_i32m1(vid, 13, vl), 0, vl);\n        vbool32_t vmask = vmor_mm_b32(vmask11, vmask13, vl);\n        \n        // For matching numbers, count 7s in each digit\n        vint32m1_t vnum = vid;\n        while(vrgather_vx_i32m1_m(vmask, v0, vnum, 0, vl) != v0) {\n            vint32m1_t vdigit = vrem_vx_i32m1_m(vmask, v0, vnum, 10, vl);\n            count += vcpop_m_b32(vmask && vmseq_vv_i32m1_b32(vdigit, v7, vl), vl);\n            vnum = vdiv_vv_i32m1_m(vmask, vnum, v10, vl);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl;\n    \n    // Process 8 elements at a time\n    vint32m8_t vid;\n    vbool4_t vmask11, vmask13;\n    vint32m8_t v7 = vmv_v_x_i32m8(7, 8);\n    vint32m8_t v10 = vmv_v_x_i32m8(10, 8);\n    vint32m8_t v0 = vmv_v_x_i32m8(0, 8);\n    \n    for(int i = 0; i < n; i += 8) {\n        vl = vsetvl_e32m8(min(8, n-i));\n        \n        // Generate vector of consecutive integers\n        vid = vid_v_i32m8(vl);\n        vid = vadd_vx_i32m8(vid, i, vl);\n        \n        // Check if divisible by 11 or 13\n        vmask11 = vmseq_vx_i32m8_b4(vrem_vx_i32m8(vid, 11, vl), 0, vl);\n        vmask13 = vmseq_vx_i32m8_b4(vrem_vx_i32m8(vid, 13, vl), 0, vl);\n        vbool4_t vmask = vmor_mm_b4(vmask11, vmask13, vl);\n        \n        // For numbers that match condition, count 7s\n        vint32m8_t vnum = vid;\n        vbool4_t has_digit;\n        \n        while(vrgather_vx_i32m8_m(vmask, v0, vnum, 0, vl) != v0) {\n            // Extract last digit\n            vint32m8_t vdigit = vrem_vx_i32m8_m(vmask, v0, vnum, 10, vl);\n            \n            // Count 7s\n            has_digit = vmseq_vv_i32m8_b4_m(vmask, vdigit, v7, vl);\n            count += vcpop_m_b4(has_digit, vl);\n            \n            // Divide by 10\n            vnum = vdiv_vv_i32m8_m(vmask, v0, vnum, v10, vl);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_RVV", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    size_t vl;\n    \n    // Process 8 elements at a time\n    vint32m1_t vid;\n    vbool32_t vmask11, vmask13;\n    vint32m1_t v7 = vmv_v_x_i32m1(7, 8);\n    \n    for(int i = 0; i < n; i += 8) {\n        vl = vsetvl_e32m1(min(8, n-i));\n        \n        // Generate vector of consecutive integers\n        vid = vid_v_i32m1(vl);\n        vid = vadd_vx_i32m1(vid, i, vl);\n        \n        // Check divisibility by 11 or 13\n        vmask11 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid, 11, vl), 0, vl);\n        vmask13 = vmsne_vx_i32m1_b32(vrem_vx_i32m1(vid, 13, vl), 0, vl);\n        vbool32_t vmask = vmnor_mm_b32(vmask11, vmask13, vl);\n        \n        // For numbers divisible by 11 or 13, count 7s\n        vint32m1_t vnum = vid;\n        vbool32_t has_seven;\n        \n        while(vmfirst_m_b32(vmask, vl) >= 0) {\n            has_seven = vmseq_vx_i32m1_b32(vrem_vx_i32m1(vnum, 10, vl), 7, vl);\n            has_seven = vmand_mm_b32(has_seven, vmask, vl);\n            count += vcpop_m_b32(has_seven, vl);\n            vnum = vdiv_vx_i32m1(vnum, 10, vl);\n            vmask = vmand_mm_b32(vmask, vmsne_vx_i32m1_b32(vnum, 0, vl), vl);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Create vector for even indices\n    std::vector<float> even;\n    for (size_t i = 0; i < n; i += 2) {\n        even.push_back(l[i]);\n    }\n    \n    // Sort even indices\n    std::sort(even.begin(), even.end());\n    \n    // Create result vector\n    std::vector<float> result(n);\n    \n    // Set vector length\n    size_t vl = vsetvlmax_e32m8();\n    \n    // Process even indices\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2*vl) {\n        size_t avl = std::min(vl, (n-i)/2);\n        vfloat32m8_t v_even = vle32_v_f32m8(&even[even_idx], avl);\n        \n        // Scatter even values to result\n        vint32m8_t v_indices = vid_v_i32m8(avl);\n        v_indices = vmul_vx_i32m8(v_indices, 2, avl);\n        vsse32_v_f32m8(&result[i], 8, v_even, avl);\n        \n        even_idx += avl;\n    }\n    \n    // Process odd indices using RVV\n    for (size_t i = 1; i < n; i += 2*vl) {\n        size_t avl = std::min(vl, (n-i)/2);\n        vfloat32m8_t v_odd = vle32_v_f32m8(&l[i], 2*avl);\n        \n        // Scatter odd values to result\n        vint32m8_t v_indices = vid_v_i32m8(avl); \n        v_indices = vadd_vx_i32m8(vmul_vx_i32m8(v_indices, 2, avl), 1, avl);\n        vsse32_v_f32m8(&result[i], 8, v_odd, avl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Create vector for even indices\n    std::vector<float> even;\n    for (size_t i = 0; i < n; i += 2) {\n        even.push_back(l[i]);\n    }\n    \n    // Sort even indices\n    std::sort(even.begin(), even.end());\n    \n    // Put sorted values back into even positions\n    size_t vl = vsetvlmax_e32m1();\n    size_t even_idx = 0;\n    \n    for (size_t i = 0; i < n; i += vl * 2) {\n        size_t avl = std::min(vl, (n-i)/2);\n        if (avl == 0) break;\n        \n        vfloat32m1_t v_even = vle32_v_f32m1(&even[even_idx], avl);\n        vfloat32m1_t v_orig = vle32_v_f32m1(&l[i], avl*2);\n        \n        // Store even elements\n        vsse32_v_f32m1(&l[i], 2*sizeof(float), v_even, avl);\n        \n        even_idx += avl;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Extract even indices into separate vector\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < n; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    \n    // Sort even values using RVV\n    size_t even_size = even_vals.size();\n    size_t vl = vsetvlmax_e32m8();\n    \n    for (size_t i = 0; i < even_size; i++) {\n        for (size_t j = 0; j < even_size - i - 1; j += vl) {\n            vl = vsetvl_e32m8(even_size - j - 1);\n            \n            vfloat32m8_t v1 = vle32_v_f32m8(&even_vals[j], vl);\n            vfloat32m8_t v2 = vle32_v_f32m8(&even_vals[j+1], vl);\n            \n            vbool4_t mask = vmfgt_vv_f32m8_b4(v1, v2, vl);\n            \n            vfloat32m8_t tmp = v1;\n            v1 = vmerge_vvm_f32m8(mask, v1, v2, vl);\n            v2 = vmerge_vvm_f32m8(mask, v2, tmp, vl);\n            \n            vse32_v_f32m8(&even_vals[j], v1, vl);\n            vse32_v_f32m8(&even_vals[j+1], v2, vl);\n        }\n    }\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_vals[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Extract even indices into separate vector\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < n; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    \n    // Sort even values\n    size_t even_size = even_vals.size();\n    size_t vl;\n    \n    for (size_t i = 0; i < even_size - 1; i++) {\n        for (size_t j = 0; j < even_size - i - 1; j++) {\n            vfloat32m1_t v1, v2;\n            vbool32_t mask;\n            \n            vl = 1;\n            v1 = vle32_v_f32m1(&even_vals[j], vl);\n            v2 = vle32_v_f32m1(&even_vals[j+1], vl);\n            \n            mask = vmfgt_vv_f32m1_b32(v1, v2, vl);\n            \n            if (vmfirst_m_b32(mask, vl)) {\n                float temp = even_vals[j];\n                even_vals[j] = even_vals[j+1]; \n                even_vals[j+1] = temp;\n            }\n        }\n    }\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_vals[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_RVV", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Create vector for even indices\n    std::vector<float> even_vals;\n    for (size_t i = 0; i < n; i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    \n    // Sort even values\n    size_t even_size = even_vals.size();\n    size_t vl;\n    \n    for (size_t i = 0; i < even_size - 1; i++) {\n        for (size_t j = 0; j < even_size - i - 1; j++) {\n            vfloat32m1_t v1, v2;\n            vl = 1;\n            \n            v1 = vle32_v_f32m1(&even_vals[j], vl);\n            v2 = vle32_v_f32m1(&even_vals[j+1], vl);\n            \n            vbool32_t mask = vmflt_vv_f32m1_b32(v1, v2, vl);\n            \n            if (!vmfirst_m_b32(mask, vl)) {\n                float temp = even_vals[j];\n                even_vals[j] = even_vals[j+1];\n                even_vals[j+1] = temp;\n            }\n        }\n    }\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_vals[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-2; i++) {\n        for (size_t j = i+1; j < n-1; j++) {\n            int sum2 = l[i] + l[j];\n            \n            size_t vl;\n            for (size_t k = j+1; k < n; k += vlen) {\n                vl = vsetvl_e32m8(n-k);\n                \n                vint32m8_t v_vec = vle32_v_i32m8(&l[k], vl);\n                vbool4_t vmask = vmseq_vx_i32m8_b4(v_vec, -sum2, vl);\n                \n                if (vfirst_m_b4(vmask, vl) >= 0) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-2; i++) {\n        for (size_t j = i+1; j < n-1; j++) {\n            int sum2 = l[i] + l[j];\n            \n            size_t vlmax = __riscv_vsetvlmax_e32m8();\n            vint32m8_t v_sum2 = __riscv_vmv_v_x_i32m8(sum2, vlmax);\n            \n            for (size_t k = j+1; k < n; k += vlen) {\n                size_t vl = __riscv_vsetvl_e32m8(n-k);\n                \n                vint32m8_t v_nums = __riscv_vle32_v_i32m8(&l[k], vl);\n                vbool4_t mask = __riscv_vmadc_vv_i32m8_b4(v_nums, v_sum2, vl);\n                \n                if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-2; i++) {\n        for (size_t j = i+1; j < n-1; j++) {\n            int sum2 = l[i] + l[j];\n            \n            size_t vlmax = __riscv_vsetvlmax_e32m8();\n            vint32m8_t v_sum2 = __riscv_vmv_v_x_i32m8(sum2, vlmax);\n            \n            for (size_t k = j+1; k < n; k += vlen) {\n                size_t vl = __riscv_vsetvl_e32m8(n-k);\n                \n                vint32m8_t v_nums = __riscv_vle32_v_i32m8(&l[k], vl);\n                vbool4_t mask = __riscv_vmseq_vv_i32m8_b4(v_nums, __riscv_vneg_v_i32m8(v_sum2, vl), vl);\n                \n                if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n\n    for (size_t i = 0; i < n-2; i++) {\n        for (size_t j = i+1; j < n-1; j++) {\n            int sum2 = l[i] + l[j];\n            \n            size_t vlmax = __riscv_vsetvlmax_e32m8();\n            vint32m8_t v_sum2 = __riscv_vmv_v_x_i32m8(sum2, vlmax);\n            \n            for (size_t k = j+1; k < n; k += vlen) {\n                size_t vl = __riscv_vsetvl_e32m8(n-k);\n                \n                vint32m8_t v_nums = __riscv_vle32_v_i32m8(&l[k], vl);\n                vbool4_t mask = __riscv_vmseq_vv_i32m8_b4(v_nums, __riscv_vneg_v_i32m8(v_sum2, vl), vl);\n                \n                if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_RVV", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m1();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-2; i++) {\n        for (size_t j = i+1; j < n-1; j++) {\n            int sum2 = l[i] + l[j];\n            \n            size_t vlmax = __riscv_vsetvlmax_e32m1();\n            vint32m1_t v_sum2 = __riscv_vmv_v_x_i32m1(sum2, vlmax);\n            \n            for (size_t k = j+1; k < n; k += vlen) {\n                size_t vl = __riscv_vsetvl_e32m1(n-k);\n                \n                vint32m1_t v_nums = __riscv_vle32_v_i32m1(&l[k], vl);\n                vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(v_nums, __riscv_vneg_v_i32m1(v_sum2, vl), vl);\n                \n                if (__riscv_vfirst_m_b32(mask, vl) != -1) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlen = l.size();\n    std::vector<int> result(vlen);\n    \n    size_t i = 0;\n    size_t vlmax;\n    \n    while (i < vlen) {\n        vlmax = vsetvl_e32m8(vlen - i);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vlmax);\n        vint32m8_t one = vmv_v_x_i32m8(1, vlmax);\n        vint32m8_t sum = vadd_vv_i32m8(vec, one, vlmax);\n        \n        vse32_v_i32m8(&result[i], sum, vlmax);\n        \n        i += vlmax;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlen = l.size();\n    std::vector<int> result(vlen);\n    \n    size_t i = 0;\n    size_t vlmax;\n    while (i < vlen) {\n        vlmax = vsetvl_e32m8(vlen - i);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vlmax);\n        vec = vadd_vx_i32m8(vec, 1, vlmax);\n        vse32_v_i32m8(&result[i], vec, vlmax);\n        \n        i += vlmax;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlen = l.size();\n    std::vector<int> result(vlen);\n    \n    size_t i = 0;\n    size_t vlmax;\n    \n    while (i < vlen) {\n        vlmax = vsetvl_e32m8(vlen - i);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vlmax);\n        vec = vadd_vx_i32m8(vec, 1, vlmax);\n        vse32_v_i32m8(&result[i], vec, vlmax);\n        \n        i += vlmax;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlen = l.size();\n    std::vector<int> result(vlen);\n    \n    size_t i = 0;\n    size_t vlmax;\n    \n    while (i < vlen) {\n        vlmax = vsetvl_e32m8(vlen - i);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vlmax);\n        vec = vadd_vx_i32m8(vec, 1, vlmax);\n        vse32_v_i32m8(&result[i], vec, vlmax);\n        \n        i += vlmax;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_RVV", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t vlen = l.size();\n    std::vector<int> result(vlen);\n    \n    size_t i = 0;\n    vint32m1_t v1;\n    size_t vlmax = vsetvlmax_e32m1();\n    \n    for (; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        v1 = vle32_v_i32m1(&l[i], vl);\n        v1 = vadd_vx_i32m1(v1, 1, vl);\n        vse32_v_i32m1(&result[i], v1, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) return false;\n\n    size_t vlen = vsetvlmax_e32m8();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        int target = -l[i];\n        \n        size_t vl;\n        for (size_t j = i+1; j < n; j += vlen) {\n            vl = vsetvl_e32m8(n-j);\n            \n            vint32m8_t vec = vle32_v_i32m8(&l[j], vl);\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, target, vl);\n            \n            if (vmany_m_b4(mask, vl)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        int target = -l[i];\n        \n        size_t vl;\n        for (size_t j = i+1; j < n; j += vlen) {\n            vl = __riscv_vsetvl_e32m8(n - j);\n            \n            vint32m8_t vec = __riscv_vle32_v_i32m8(&l[j], vl);\n            vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(vec, target, vl);\n            \n            if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        int target = -l[i];\n        size_t vl;\n        \n        for (size_t j = i+1; j < n; j += vlen) {\n            vl = __riscv_vsetvl_e32m8(n - j);\n            \n            vint32m8_t vec = __riscv_vle32_v_i32m8(&l[j], vl);\n            vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(vec, target, vl);\n            \n            if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        int target = -l[i];\n        size_t vl;\n        \n        for (size_t j = i+1; j < n; j += vlen) {\n            vl = __riscv_vsetvl_e32m8(n - j);\n            \n            vint32m8_t vec = __riscv_vle32_v_i32m8(&l[j], vl);\n            vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(vec, target, vl);\n            \n            if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_RVV", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        int target = -l[i];\n        size_t vl;\n        \n        for (size_t j = i+1; j < n; j += vlen) {\n            vl = __riscv_vsetvl_e32m8(n - j);\n            \n            vint32m8_t v_data = __riscv_vle32_v_i32m8(&l[j], vl);\n            vbool4_t mask = __riscv_vmseq_vx_i32m8_b4(v_data, target, vl);\n            \n            if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n    \n    size_t vl;\n    vint64m8_t v_quotients;\n    vint64m8_t v_remainders;\n    \n    while (x > 0) {\n        vl = vsetvl_e64m8(1);\n        \n        v_quotients = vmv_v_x_i64m8(x / base, vl);\n        v_remainders = vmv_v_x_i64m8(x % base, vl);\n        \n        int64_t remainder;\n        vse64_v_i64m8(&remainder, v_remainders, vl);\n        \n        result = std::to_string(remainder) + result;\n        \n        x = x / base;\n    }\n    \n    if (negative) {\n        result = \"-\" + result;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    size_t vlen = vsetvlmax_e8m8();\n    vint8m8_t v_digits = vundefined_i8m8();\n    \n    while (x > 0) {\n        size_t avl = vlen;\n        vint8m8_t v_remainders = vundefined_i8m8();\n        \n        // Process multiple divisions in parallel\n        while (avl > 0 && x > 0) {\n            int8_t remainder = x % base;\n            x /= base;\n            vse8_v_i8m8(&v_remainders[vlen - avl], vmv_v_x_i8m8(remainder, 1), 1);\n            avl--;\n        }\n        \n        // Convert remainders to ASCII digits\n        size_t processed = vlen - avl;\n        vint8m8_t v_ascii = vadd_vx_i8m8(v_remainders, '0', processed);\n        \n        // Store digits\n        char digits[processed];\n        vse8_v_i8m8(digits, v_ascii, processed);\n        \n        // Append digits to result\n        result.append(digits, processed);\n    }\n    \n    if (negative) {\n        result += '-';\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    size_t vlen = vsetvlmax_e8m8();\n    vint8m8_t v_digits = vmv_v_x_i8m8(0, vlen);\n    size_t pos = 0;\n\n    while (x > 0) {\n        int8_t remainder = x % base;\n        x /= base;\n        \n        // Store digit in vector\n        vslide_up_vx_i8m8(v_digits, v_digits, 1, vlen);\n        v_digits = vfirst_m_i8m8(vmseq_vx_i8m8_b1(v_digits, 0, vlen));\n        vse8_v_i8m8(&remainder, v_digits, 1);\n        pos++;\n    }\n\n    // Convert digits to characters\n    result.resize(pos);\n    for (size_t i = 0; i < pos; i++) {\n        int8_t digit;\n        vle8_v_i8m8(&digit, v_digits + i, 1);\n        result[pos - 1 - i] = '0' + digit;\n    }\n\n    if (negative) {\n        result = \"-\" + result;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    size_t vl;\n    vint64m8_t v_quotients;\n    vint64m8_t v_remainders;\n    \n    while (x > 0) {\n        // Set vector length\n        vl = vsetvl_e64m8(1);\n        \n        // Create vector with quotient and remainder\n        v_quotients = vmv_v_x_i64m8(x / base, vl);\n        v_remainders = vmv_v_x_i64m8(x % base, vl);\n        \n        // Extract scalar values\n        int64_t remainder = vmv_x_s_i64m8_i64(v_remainders);\n        x = vmv_x_s_i64m8_i64(v_quotients);\n        \n        // Convert remainder to character and prepend to result\n        result = char('0' + remainder) + result;\n    }\n    \n    if (negative) {\n        result = \"-\" + result;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_RVV", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    size_t vlen = vsetvlmax_e8m8();\n    vint8m8_t v_digits = vundefined_i8m8();\n    vbool1_t v_mask = vundefined_b1();\n    \n    while (x > 0) {\n        size_t count = 0;\n        vint8m8_t v_remainders = vundefined_i8m8();\n        \n        while (count < vlen && x > 0) {\n            int8_t remainder = x % base;\n            vse8_v_i8m8(&v_remainders[count], remainder, 1);\n            x /= base;\n            count++;\n        }\n        \n        if (count > 0) {\n            size_t vl = vsetvl_e8m8(count);\n            v_digits = vadd_vx_i8m8(v_remainders, '0', vl);\n            \n            for (size_t i = 0; i < count; i++) {\n                result.push_back(v_digits[i]);\n            }\n        }\n    }\n    \n    if (negative) {\n        result.push_back('-');\n    }\n    \n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        size_t vl = vsetvl_e8m8(j - i + 1);\n        \n        vuint8m8_t v1 = vle8_v_u8m8((uint8_t*)&str[i], vl);\n        vuint8m8_t v2 = vlse8_v_u8m8((uint8_t*)&str[j], -1, vl);\n        \n        vbool1_t mask = vmseq_vv_u8m8_b1(v1, v2, vl);\n        if (!vmandfs_m_b1(mask, vl)) {\n            return false;\n        }\n        \n        i += vl;\n        j -= vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        size_t vl = vsetvl_e8m8(j - i + 1);\n        \n        vuint8m8_t v1 = vle8_v_u8m8((uint8_t*)&str[i], vl);\n        \n        // Load characters from end in reverse\n        vuint8m8_t v2;\n        for(size_t k = 0; k < vl; k++) {\n            uint8_t c = str[j-k];\n            v2 = vset_v_u8m8_u8m8(v2, k, c);\n        }\n\n        // Compare vectors\n        vbool1_t mask = vmseq_vv_u8m8_b1(v1, v2, vl);\n        \n        // Check if any characters differ\n        if (!vmandfs_m_b1(mask, vl)) {\n            return false;\n        }\n\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n    \n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    while (i < j) {\n        size_t batch_size = std::min(vlen, (j - i + 1) / 2);\n        size_t vl = __riscv_vsetvl_e8m8(batch_size);\n        \n        vuint8m8_t v1 = __riscv_vle8_v_u8m8((uint8_t*)(str + i), vl);\n        vuint8m8_t v2 = __riscv_vle8_v_u8m8((uint8_t*)(str + j - vl + 1), vl);\n        v2 = __riscv_vrgather_vv_u8m8(v2, __riscv_vid_v_u8m8(vl, vl), vl);\n        \n        vbool1_t mask = __riscv_vmseq_vv_u8m8_b1(v1, v2, vl);\n        if (!__riscv_vmandnot_mm_b1(mask, mask, vl)) {\n            return false;\n        }\n        \n        i += vl;\n        j -= vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        size_t vl = vsetvl_e8m8(j - i + 1);\n        \n        vuint8m8_t v1 = vle8_v_u8m8((uint8_t*)&str[i], vl);\n        vuint8m8_t v2 = vlse8_v_u8m8((uint8_t*)&str[j], -1, vl);\n        \n        vbool1_t mask = vmseq_vv_u8m8_b1(v1, v2, vl);\n        if (!vmandfs_m_b1(mask, vl)) {\n            return false;\n        }\n        \n        i += vl;\n        j -= vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_RVV", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        size_t vl = vsetvl_e8m8(j - i + 1);\n        \n        vuint8m8_t v1 = vle8_v_u8m8((uint8_t*)&str[i], vl);\n        vuint8m8_t v2 = vlse8_v_u8m8((uint8_t*)&str[j], -1, vl);\n        \n        vbool1_t mask = vmseq_vv_u8m8_b1(v1, v2, vl);\n        if (!vmandfs_m_b1(mask, vl)) {\n            return false;\n        }\n        \n        i += vl;\n        j -= vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_in = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Subtract 5 from each character\n        vuint8m8_t v_sub = vsub_vx_u8m8(v_in, 5, vl);\n        \n        // Handle wrap around for values that go below 'a'\n        vbool1_t mask = vmsltu_vx_u8m8_b1(v_sub, 'a', vl);\n        vuint8m8_t v_wrap = vadd_vx_u8m8_m(mask, v_sub, v_sub, 26, vl);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&out[i], v_wrap, vl);\n        \n        i += vl;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Subtract 5 from each character\n        v_chars = vsub_vx_u8m8(v_chars, 5, vl);\n        \n        // Add 26 to handle underflow when going below 'a'\n        vuint8m8_t v_below_a = vmsltu_vx_u8m8(v_chars, 'a', vl);\n        v_chars = vadd_vx_u8m8_m(v_below_a, v_chars, v_chars, 26, vl);\n        \n        // Store results\n        vse8_v_u8m8((uint8_t*)&out[i], v_chars, vl);\n        \n        i += vl;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_in = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Subtract 5 from each character\n        vuint8m8_t v_shifted = vsub_vx_u8m8(v_in, 5, vl);\n        \n        // Handle wraparound for characters that go below 'a'\n        vbool1_t mask = vmsltu_vx_u8m8_b1(v_shifted, 'a', vl);\n        vuint8m8_t v_wrapped = vadd_vx_u8m8_m(mask, v_shifted, v_shifted, 26, vl);\n        \n        // Store results\n        vse8_v_u8m8((uint8_t*)&out[i], v_wrapped, vl);\n        \n        i += vl;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), '\\0');\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Subtract 5 from each character\n        v_chars = vsub_vx_u8m8(v_chars, 5, vl);\n        \n        // Handle wraparound for values that go below 'a'\n        vuint8m8_t v_below_a = vmsltu_vx_u8m8_b1(v_chars, 'a', vl);\n        v_chars = vadd_vx_u8m8_m(v_below_a, v_chars, v_chars, 26, vl);\n        \n        // Store results\n        vse8_v_u8m8((uint8_t*)&out[i], v_chars, vl);\n        \n        i += vl;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_RVV", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_in = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Subtract 5 from each character\n        vuint8m8_t v_shifted = vsub_vx_u8m8(v_in, 5, vl);\n        \n        // Handle wrap around for values that go below 'a'\n        vbool1_t mask = vmsltu_vx_u8m8_b1(v_shifted, 'a', vl);\n        v_shifted = vadd_vx_u8m8_m(mask, v_shifted, v_shifted, 26, vl);\n        \n        vse8_v_u8m8((uint8_t*)&out[i], v_shifted, vl);\n        i += vl;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlen = l.size();\n    size_t i;\n    bool result = true;\n    \n    vint32m1_t v_data;\n    vbool32_t v_mask;\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        v_data = vle32_v_i32m1(&l[i], vl);\n        v_mask = vmsgt_vx_i32m1_b32(v_data, t, vl);\n        \n        if (vmany_m_b32(v_mask, vl)) {\n            result = false;\n            break;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlen = l.size();\n    size_t i = 0;\n    bool result = true;\n\n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m1(avl);\n        \n        vint32m1_t vec = vle32_v_i32m1(&l[i], vl);\n        vbool32_t mask = vmslt_vx_i32m1_b32(vec, t, vl);\n        \n        if (!vmand_m_b32(mask, vl)) {\n            result = false;\n            break;\n        }\n        \n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlen = l.size();\n    size_t i = 0;\n    vbool_t mask;\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        mask = vmslt_vx_i32m8_b1(vec, t, vl);\n        \n        if (!vmandm_m_b1(mask, mask, vl)) {\n            return false;\n        }\n        \n        i += vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlen = l.size();\n    size_t i = 0;\n    bool result = true;\n\n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(vec, t, vl);\n        \n        if (!vmand_m_b4(mask, vl)) {\n            result = false;\n            break;\n        }\n        \n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_RVV", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t vlen = l.size();\n    size_t i = 0;\n    bool result = true;\n\n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t vec = vle32_v_i32m8(&l[i], vl);\n        vbool4_t mask = vmslt_vx_i32m8_b4(vec, t, vl);\n        \n        if (!vmand_m_b4(mask, vl)) {\n            result = false;\n            break;\n        }\n        \n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_str;\n    \n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m8(len - i);\n        v_str = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        // Count '<' as +1 and '>' as -1\n        vbool1_t mask_open = vmseq_vx_i8m8_b1(v_str, '<', vl);\n        vbool1_t mask_close = vmseq_vx_i8m8_b1(v_str, '>', vl);\n        \n        count += vcpop_m_b1(mask_open, vl);\n        count -= vcpop_m_b1(mask_close, vl);\n        \n        // Early termination if count becomes negative\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_str;\n    vint8m8_t v_lt, v_gt;\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m8(n - i);\n        v_str = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        // Check for '<'\n        v_lt = vmseq_vx_i8m8(v_str, '<', vl);\n        // Check for '>'\n        v_gt = vmseq_vx_i8m8(v_str, '>', vl);\n        \n        // Add 1 for '<', subtract 1 for '>'\n        count += vredusum_vs_i8m8_i32m1(v_lt, v_lt, vl);\n        count -= vredusum_vs_i8m8_i32m1(v_gt, v_gt, vl);\n        \n        // Early termination if count becomes negative\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_str;\n    vint8m8_t v_lt, v_gt;\n    vbool1_t vmask_lt, vmask_gt;\n    \n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m8(len - i);\n        \n        v_str = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        vmask_lt = vmseq_vx_i8m8_b1(v_str, '<', vl);\n        vmask_gt = vmseq_vx_i8m8_b1(v_str, '>', vl);\n        \n        count += vcpop_m_b1(vmask_lt, vl);\n        count -= vcpop_m_b1(vmask_gt, vl);\n        \n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_str;\n    vint8m8_t v_lt, v_gt;\n    vbool1_t vmask;\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m8(n - i);\n        \n        v_str = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        // Count '<' as +1\n        v_lt = vmsne_vx_i8m8_m(vmset_e8m8(vl), v_str, '>', vl);\n        count += vcpop_m_b1(vmseq_vx_i8m8_b1(v_lt, 1, vl), vl);\n        \n        // Count '>' as -1\n        v_gt = vmseq_vx_i8m8_b1(v_str, '>', vl);\n        count -= vcpop_m_b1(v_gt, vl);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_str;\n    \n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m8(len - i);\n        v_str = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        // Count '<' as +1 and '>' as -1\n        vbool1_t mask_open = vmseq_vx_i8m8_b1(v_str, '<', vl);\n        vbool1_t mask_close = vmseq_vx_i8m8_b1(v_str, '>', vl);\n        \n        int open_count = vcpop_m_b1(mask_open, vl);\n        int close_count = vcpop_m_b1(mask_close, vl);\n        \n        count += open_count - close_count;\n        \n        // Early termination if count becomes negative\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    int count = 0;\n    size_t i;\n\n    for (i = 0; i + vlen <= brackets.length(); i += vlen) {\n        vint8m8_t v = __riscv_vle8_v_i8m8((int8_t*)&brackets[i], vlen);\n        \n        // Convert '(' to 1 and ')' to -1\n        vint8m8_t ones = __riscv_vsub_vx_i8m8(v, '(', vlen);\n        vbool1_t mask = __riscv_vmsne_vx_i8m8_b1(ones, 0, vlen);\n        ones = __riscv_vsub_vx_i8m8(ones, ')', vlen);\n        ones = __riscv_vneg_v_i8m8(ones, vlen);\n        \n        // Sum the values\n        count += __riscv_vredsum_vs_i8m8_i8m1(ones, __riscv_vmv_v_x_i8m1(0, 1), vlen);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n    }\n\n    // Handle remaining elements\n    for (; i < brackets.length(); i++) {\n        count += (brackets[i] == '(') ? 1 : -1;\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2 != 0) return false;\n\n    int count = 0;\n    size_t vl;\n    size_t i = 0;\n\n    while (i < n) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t v_brackets = vle8_v_i8m1((int8_t*)&brackets[i], vl);\n        \n        // Convert '(' to 1 and ')' to -1\n        vbool8_t mask_open = vmseq_vx_i8m1_b8(v_brackets, '(', vl);\n        vbool8_t mask_close = vmseq_vx_i8m1_b8(v_brackets, ')', vl);\n        \n        vint8m1_t v_ones = vmv_v_x_i8m1(1, vl);\n        vint8m1_t v_neg_ones = vmv_v_x_i8m1(-1, vl);\n        \n        vint8m1_t v_values = vmerge_vxm_i8m1(vmerge_vxm_i8m1(vmv_v_x_i8m1(0, vl), mask_close, -1, vl), mask_open, 1, vl);\n        \n        // Sum the values\n        vint8m1_t v_sum = v_values;\n        count += vredsum_vs_i8m1_i8m1(v_sum, v_values, vmv_v_x_i8m1(0, 1), vl);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        i += vl;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_brackets;\n    \n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m8(len - i);\n        v_brackets = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        // Convert '(' to 1 and ')' to -1\n        vbool1_t mask_open = vmseq_vx_i8m8_b1(v_brackets, '(', vl);\n        vbool1_t mask_close = vmseq_vx_i8m8_b1(v_brackets, ')', vl);\n        \n        v_brackets = vsub_vx_i8m8(v_brackets, v_brackets, vl);\n        v_brackets = vmerge_vxm_i8m8(v_brackets, mask_open, 1, vl);\n        v_brackets = vmerge_vxm_i8m8(v_brackets, mask_close, -1, vl);\n        \n        // Sum the values\n        vint8m8_t v_sum = v_brackets;\n        count += vredsum_vs_i8m8_i32m1(v_sum, v_sum, vl);\n        \n        // Early termination if count becomes negative\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\n#include <riscv_vector.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    int count = 0;\n    size_t i;\n\n    for (i = 0; i + vlen <= brackets.length(); i += vlen) {\n        vint8m8_t v = __riscv_vle8_v_i8m8((int8_t*)&brackets[i], vlen);\n        \n        // Convert '(' to 1 and ')' to -1\n        vint8m8_t ones = __riscv_vmv_v_x_i8m8(1, vlen);\n        vbool1_t mask = __riscv_vmseq_vx_i8m8_b1(v, '(', vlen);\n        v = __riscv_vmerge_vxm_i8m8(v, -1, mask, vlen);\n        mask = __riscv_vmseq_vx_i8m8_b1(v, ')', vlen);\n        v = __riscv_vmerge_vxm_i8m8(v, 1, mask, vlen);\n        \n        // Sum the values\n        count += __riscv_vredsum_vs_i8m8_i8m1(v, __riscv_vmv_v_x_i8m1(0, 1), vlen);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n    }\n\n    // Handle remaining elements\n    for (; i < brackets.length(); i++) {\n        if (brackets[i] == '(') count++;\n        else count--;\n        if (count < 0) return false;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_RVV", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    size_t vl;\n    vint8m8_t v_brackets;\n    \n    for (size_t i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m8(len - i);\n        v_brackets = vle8_v_i8m8((int8_t*)&brackets[i], vl);\n        \n        // Convert '(' to 1 and ')' to -1\n        vbool1_t mask_open = vmseq_vx_i8m8_b1(v_brackets, '(', vl);\n        vbool1_t mask_close = vmseq_vx_i8m8_b1(v_brackets, ')', vl);\n        \n        v_brackets = vsub_vx_i8m8(v_brackets, v_brackets, vl);\n        v_brackets = vmerge_vxm_i8m8(v_brackets, mask_open, 1, vl);\n        v_brackets = vmerge_vxm_i8m8(v_brackets, mask_close, -1, vl);\n        \n        // Sum the values\n        vint8m8_t v_sum = v_brackets;\n        count += vredsum_vs_i8m8_i8m1(v_sum, v_brackets, vl);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t out_size = xs.size() - 1;\n    std::vector<float> result(out_size);\n    \n    size_t vl;\n    float *out_ptr = result.data();\n    float *in_ptr = xs.data() + 1;\n    \n    vfloat32m1_t v_coef;\n    size_t index = 0;\n    \n    for (size_t i = 0; i < out_size; i += vl) {\n        vl = vsetvl_e32m1(out_size - i);\n        \n        // Load input values\n        v_coef = vle32_v_f32m1(in_ptr + i, vl);\n        \n        // Generate indices 1,2,3,...\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i + 1, vl);\n        \n        // Convert indices to float\n        vfloat32m1_t v_float_idx = vfcvt_f_x_v_f32m1(v_idx, vl);\n        \n        // Multiply coefficient by index\n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_coef, v_float_idx, vl);\n        \n        // Store result\n        vse32_v_f32m1(out_ptr + i, v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t out_size = xs.size() - 1;\n    std::vector<float> result(out_size);\n    \n    size_t vlen = vsetvlmax_e32m8();\n    float coeffs[vlen];\n    \n    for (size_t i = 0; i < out_size; i += vlen) {\n        size_t vl = vsetvl_e32m8(out_size - i);\n        \n        // Load indices\n        vint32m8_t indices = vid_v_i32m8(vl);\n        indices = vadd_vx_i32m8(indices, i + 1, vl);\n        \n        // Load input values\n        vfloat32m8_t v_in = vle32_v_f32m8(&xs[i+1], vl);\n        \n        // Multiply by coefficients\n        vfloat32m8_t v_coeff = vfmul_vf_f32m8(v_in, 1.0f, vl);\n        v_coeff = vfmul_vx_f32m8(v_coeff, indices, vl);\n        \n        // Store results\n        vse32_v_f32m8(&result[i], v_coeff, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n    \n    size_t vlen = vsetvlmax_e32m8();\n    float coeffs[vlen];\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        \n        // Load indices\n        vint32m8_t indices = vid_v_i32m8(vl);\n        indices = vadd_vx_i32m8(indices, i + 1, vl);\n        \n        // Load polynomial coefficients\n        vfloat32m8_t v_xs = vle32_v_f32m8(&xs[i + 1], vl);\n        \n        // Multiply coefficients by their indices\n        vfloat32m8_t v_result = vfmul_vf_f32m8(v_xs, 1.0f, vl);\n        v_result = vfmul_vx_f32m8(v_result, indices, vl);\n        \n        // Store results\n        vse32_v_f32m8(&result[i], v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n    \n    size_t vl;\n    vfloat32m1_t v_coef, v_idx;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load coefficients starting from index 1\n        v_coef = vle32_v_f32m1(&xs[i + 1], vl);\n        \n        // Generate vector of indices [1,2,3,...]\n        v_idx = vfmv_v_f_f32m1(1.0f, vl);\n        v_idx = vfadd_vf_f32m1(v_idx, (float)i, vl);\n        \n        // Multiply coefficient by index\n        vfloat32m1_t v_result = vfmul_vv_f32m1(v_coef, v_idx, vl);\n        \n        // Store result\n        vse32_v_f32m1(&result[i], v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_RVV", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t out_size = xs.size() - 1;\n    std::vector<float> result(out_size);\n    \n    size_t vlen = vsetvlmax_e32m8();\n    float coeffs[vlen];\n    \n    for (size_t i = 0; i < out_size; i += vlen) {\n        size_t vl = vsetvl_e32m8(out_size - i);\n        \n        // Load indices\n        for (size_t j = 0; j < vl; j++) {\n            coeffs[j] = j + i + 1;\n        }\n        \n        vfloat32m8_t vec_coeff = vle32_v_f32m8(coeffs, vl);\n        vfloat32m8_t vec_xs = vle32_v_f32m8(&xs[i+1], vl);\n        \n        // Multiply each coefficient by its index\n        vfloat32m8_t vec_result = vfmul_vv_f32m8(vec_coeff, vec_xs, vl);\n        \n        // Store result\n        vse32_v_f32m8(&result[i], vec_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    size_t vlen = __riscv_vsetvlmax_e8m1();\n    int count = 0;\n    size_t str_len = s.length();\n    const char* str = s.c_str();\n    \n    vint8m1_t v_a = __riscv_vmv_v_x_i8m1('a', vlen);\n    vint8m1_t v_e = __riscv_vmv_v_x_i8m1('e', vlen);\n    vint8m1_t v_i = __riscv_vmv_v_x_i8m1('i', vlen);\n    vint8m1_t v_o = __riscv_vmv_v_x_i8m1('o', vlen);\n    vint8m1_t v_u = __riscv_vmv_v_x_i8m1('u', vlen);\n    vint8m1_t v_A = __riscv_vmv_v_x_i8m1('A', vlen);\n    vint8m1_t v_E = __riscv_vmv_v_x_i8m1('E', vlen);\n    vint8m1_t v_I = __riscv_vmv_v_x_i8m1('I', vlen);\n    vint8m1_t v_O = __riscv_vmv_v_x_i8m1('O', vlen);\n    vint8m1_t v_U = __riscv_vmv_v_x_i8m1('U', vlen);\n    \n    for (size_t i = 0; i < str_len; i += vlen) {\n        size_t vl = __riscv_vsetvl_e8m1(str_len - i);\n        vint8m1_t v_str = __riscv_vle8_v_i8m1((int8_t*)str + i, vl);\n        \n        vbool8_t mask_a = __riscv_vmseq_vv_i8m1_b8(v_str, v_a, vl);\n        vbool8_t mask_e = __riscv_vmseq_vv_i8m1_b8(v_str, v_e, vl);\n        vbool8_t mask_i = __riscv_vmseq_vv_i8m1_b8(v_str, v_i, vl);\n        vbool8_t mask_o = __riscv_vmseq_vv_i8m1_b8(v_str, v_o, vl);\n        vbool8_t mask_u = __riscv_vmseq_vv_i8m1_b8(v_str, v_u, vl);\n        vbool8_t mask_A = __riscv_vmseq_vv_i8m1_b8(v_str, v_A, vl);\n        vbool8_t mask_E = __riscv_vmseq_vv_i8m1_b8(v_str, v_E, vl);\n        vbool8_t mask_I = __riscv_vmseq_vv_i8m1_b8(v_str, v_I, vl);\n        vbool8_t mask_O = __riscv_vmseq_vv_i8m1_b8(v_str, v_O, vl);\n        vbool8_t mask_U = __riscv_vmseq_vv_i8m1_b8(v_str, v_U, vl);\n        \n        vbool8_t mask_vowels = __riscv_vmor_mm_b8(\n            __riscv_vmor_mm_b8(\n                __riscv_vmor_mm_b8(\n                    __riscv_vmor_mm_b8(\n                        __riscv_vmor_mm_b8(\n                            __riscv_vmor_mm_b8(\n                                __riscv_vmor_mm_b8(\n                                    __riscv_vmor_mm_b8(\n                                        __riscv_vmor_mm_b8(mask_a, mask_e, vl),\n                                        mask_i, vl),\n                                    mask_o, vl),\n                                mask_u, vl),\n                            mask_A, vl),\n                        mask_E, vl),\n                    mask_I, vl),\n                mask_O, vl),\n            mask_U, vl);\n            \n        count += __riscv_vcpop_m_b8(mask_vowels, vl);\n    }\n    \n    // Check for 'y' or 'Y' at the end\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    size_t vl;\n    size_t count = 0;\n    size_t n = s.length();\n    const char* str = s.c_str();\n    \n    vint8m1_t v_a = vmv_v_x_i8m1('a', 1);\n    vint8m1_t v_e = vmv_v_x_i8m1('e', 1);\n    vint8m1_t v_i = vmv_v_x_i8m1('i', 1);\n    vint8m1_t v_o = vmv_v_x_i8m1('o', 1);\n    vint8m1_t v_u = vmv_v_x_i8m1('u', 1);\n    vint8m1_t v_A = vmv_v_x_i8m1('A', 1);\n    vint8m1_t v_E = vmv_v_x_i8m1('E', 1);\n    vint8m1_t v_I = vmv_v_x_i8m1('I', 1);\n    vint8m1_t v_O = vmv_v_x_i8m1('O', 1);\n    vint8m1_t v_U = vmv_v_x_i8m1('U', 1);\n\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e8m1(n - i);\n        vint8m1_t v_str = vle8_v_i8m1((int8_t*)str + i, vl);\n        \n        vbool8_t mask_a = vmseq_vv_i8m1_b8(v_str, v_a, vl);\n        vbool8_t mask_e = vmseq_vv_i8m1_b8(v_str, v_e, vl);\n        vbool8_t mask_i = vmseq_vv_i8m1_b8(v_str, v_i, vl);\n        vbool8_t mask_o = vmseq_vv_i8m1_b8(v_str, v_o, vl);\n        vbool8_t mask_u = vmseq_vv_i8m1_b8(v_str, v_u, vl);\n        vbool8_t mask_A = vmseq_vv_i8m1_b8(v_str, v_A, vl);\n        vbool8_t mask_E = vmseq_vv_i8m1_b8(v_str, v_E, vl);\n        vbool8_t mask_I = vmseq_vv_i8m1_b8(v_str, v_I, vl);\n        vbool8_t mask_O = vmseq_vv_i8m1_b8(v_str, v_O, vl);\n        vbool8_t mask_U = vmseq_vv_i8m1_b8(v_str, v_U, vl);\n        \n        vbool8_t mask_vowels = vmor_mm_b8(\n            vmor_mm_b8(\n                vmor_mm_b8(\n                    vmor_mm_b8(\n                        vmor_mm_b8(\n                            vmor_mm_b8(\n                                vmor_mm_b8(\n                                    vmor_mm_b8(\n                                        vmor_mm_b8(mask_a, mask_e, vl),\n                                        mask_i, vl),\n                                    mask_o, vl),\n                                mask_u, vl),\n                            mask_A, vl),\n                        mask_E, vl),\n                    mask_I, vl),\n                mask_O, vl),\n            mask_U, vl);\n            \n        count += vcpop_m_b8(mask_vowels, vl);\n    }\n    \n    // Check for 'y' or 'Y' at the end\n    if (n > 0 && (s[n-1] == 'y' || s[n-1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    size_t vl;\n    size_t count = 0;\n    size_t str_len = s.length();\n    const char* str = s.c_str();\n    \n    vint8m1_t v_a = vmv_v_x_i8m1('a', 1);\n    vint8m1_t v_e = vmv_v_x_i8m1('e', 1);\n    vint8m1_t v_i = vmv_v_x_i8m1('i', 1);\n    vint8m1_t v_o = vmv_v_x_i8m1('o', 1);\n    vint8m1_t v_u = vmv_v_x_i8m1('u', 1);\n    vint8m1_t v_A = vmv_v_x_i8m1('A', 1);\n    vint8m1_t v_E = vmv_v_x_i8m1('E', 1);\n    vint8m1_t v_I = vmv_v_x_i8m1('I', 1);\n    vint8m1_t v_O = vmv_v_x_i8m1('O', 1);\n    vint8m1_t v_U = vmv_v_x_i8m1('U', 1);\n    \n    for (size_t i = 0; i < str_len; i += vl) {\n        vl = vsetvl_e8m1(str_len - i);\n        vint8m1_t v_str = vle8_v_i8m1((int8_t*)&str[i], vl);\n        \n        vbool8_t mask_a = vmseq_vv_i8m1_b8(v_str, v_a, vl);\n        vbool8_t mask_e = vmseq_vv_i8m1_b8(v_str, v_e, vl);\n        vbool8_t mask_i = vmseq_vv_i8m1_b8(v_str, v_i, vl);\n        vbool8_t mask_o = vmseq_vv_i8m1_b8(v_str, v_o, vl);\n        vbool8_t mask_u = vmseq_vv_i8m1_b8(v_str, v_u, vl);\n        vbool8_t mask_A = vmseq_vv_i8m1_b8(v_str, v_A, vl);\n        vbool8_t mask_E = vmseq_vv_i8m1_b8(v_str, v_E, vl);\n        vbool8_t mask_I = vmseq_vv_i8m1_b8(v_str, v_I, vl);\n        vbool8_t mask_O = vmseq_vv_i8m1_b8(v_str, v_O, vl);\n        vbool8_t mask_U = vmseq_vv_i8m1_b8(v_str, v_U, vl);\n        \n        vbool8_t mask_vowels = vmor_mm_b8(\n            vmor_mm_b8(\n                vmor_mm_b8(\n                    vmor_mm_b8(\n                        vmor_mm_b8(\n                            vmor_mm_b8(\n                                vmor_mm_b8(\n                                    vmor_mm_b8(\n                                        vmor_mm_b8(mask_a, mask_e, vl),\n                                        mask_i, vl),\n                                    mask_o, vl),\n                                mask_u, vl),\n                            mask_A, vl),\n                        mask_E, vl),\n                    mask_I, vl),\n                mask_O, vl),\n            mask_U, vl);\n            \n        count += vcpop_m_b8(mask_vowels, vl);\n    }\n    \n    // Check for 'y' or 'Y' at the end\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m1();\n    size_t n = s.length();\n    int count = 0;\n    \n    // Create vectors for vowels\n    vuint8m1_t va = vmv_v_x_u8m1('a', vlen);\n    vuint8m1_t ve = vmv_v_x_u8m1('e', vlen);\n    vuint8m1_t vi = vmv_v_x_u8m1('i', vlen);\n    vuint8m1_t vo = vmv_v_x_u8m1('o', vlen);\n    vuint8m1_t vu = vmv_v_x_u8m1('u', vlen);\n    vuint8m1_t vA = vmv_v_x_u8m1('A', vlen);\n    vuint8m1_t vE = vmv_v_x_u8m1('E', vlen);\n    vuint8m1_t vI = vmv_v_x_u8m1('I', vlen);\n    vuint8m1_t vO = vmv_v_x_u8m1('O', vlen);\n    vuint8m1_t vU = vmv_v_x_u8m1('U', vlen);\n\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m1(n - i);\n        \n        // Load string chunk\n        vuint8m1_t vstr = vle8_v_u8m1((uint8_t*)&s[i], vl);\n        \n        // Compare with each vowel\n        vbool8_t mask_a = vmseq_vv_u8m1_b8(vstr, va, vl);\n        vbool8_t mask_e = vmseq_vv_u8m1_b8(vstr, ve, vl);\n        vbool8_t mask_i = vmseq_vv_u8m1_b8(vstr, vi, vl);\n        vbool8_t mask_o = vmseq_vv_u8m1_b8(vstr, vo, vl);\n        vbool8_t mask_u = vmseq_vv_u8m1_b8(vstr, vu, vl);\n        vbool8_t mask_A = vmseq_vv_u8m1_b8(vstr, vA, vl);\n        vbool8_t mask_E = vmseq_vv_u8m1_b8(vstr, vE, vl);\n        vbool8_t mask_I = vmseq_vv_u8m1_b8(vstr, vI, vl);\n        vbool8_t mask_O = vmseq_vv_u8m1_b8(vstr, vO, vl);\n        vbool8_t mask_U = vmseq_vv_u8m1_b8(vstr, vU, vl);\n        \n        // Combine masks\n        vbool8_t mask = vmor_mm_b8(\n            vmor_mm_b8(\n                vmor_mm_b8(\n                    vmor_mm_b8(mask_a, mask_e, vl),\n                    vmor_mm_b8(mask_i, mask_o, vl), vl),\n                vmor_mm_b8(mask_u, mask_A, vl), vl),\n            vmor_mm_b8(\n                vmor_mm_b8(mask_E, mask_I, vl),\n                vmor_mm_b8(mask_O, mask_U, vl), vl), vl);\n        \n        // Count matches\n        count += vcpop_m_b8(mask, vl);\n    }\n\n    // Check for 'y' or 'Y' at the end\n    if (n > 0 && (s[n-1] == 'y' || s[n-1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_RVV", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m8();\n    int count = 0;\n    size_t str_len = s.length();\n    const char* str = s.c_str();\n    \n    vuint8m8_t v_a = vmv_v_x_u8m8('a', vlen);\n    vuint8m8_t v_e = vmv_v_x_u8m8('e', vlen);\n    vuint8m8_t v_i = vmv_v_x_u8m8('i', vlen);\n    vuint8m8_t v_o = vmv_v_x_u8m8('o', vlen);\n    vuint8m8_t v_u = vmv_v_x_u8m8('u', vlen);\n    vuint8m8_t v_A = vmv_v_x_u8m8('A', vlen);\n    vuint8m8_t v_E = vmv_v_x_u8m8('E', vlen);\n    vuint8m8_t v_I = vmv_v_x_u8m8('I', vlen);\n    vuint8m8_t v_O = vmv_v_x_u8m8('O', vlen);\n    vuint8m8_t v_U = vmv_v_x_u8m8('U', vlen);\n    \n    for (size_t i = 0; i < str_len; i += vlen) {\n        size_t vl = vsetvl_e8m8(str_len - i);\n        vuint8m8_t v_str = vle8_v_u8m8((uint8_t*)str + i, vl);\n        \n        vbool1_t mask_a = vmseq_vv_u8m8_b1(v_str, v_a, vl);\n        vbool1_t mask_e = vmseq_vv_u8m8_b1(v_str, v_e, vl);\n        vbool1_t mask_i = vmseq_vv_u8m8_b1(v_str, v_i, vl);\n        vbool1_t mask_o = vmseq_vv_u8m8_b1(v_str, v_o, vl);\n        vbool1_t mask_u = vmseq_vv_u8m8_b1(v_str, v_u, vl);\n        vbool1_t mask_A = vmseq_vv_u8m8_b1(v_str, v_A, vl);\n        vbool1_t mask_E = vmseq_vv_u8m8_b1(v_str, v_E, vl);\n        vbool1_t mask_I = vmseq_vv_u8m8_b1(v_str, v_I, vl);\n        vbool1_t mask_O = vmseq_vv_u8m8_b1(v_str, v_O, vl);\n        vbool1_t mask_U = vmseq_vv_u8m8_b1(v_str, v_U, vl);\n        \n        count += vcpop_m_b1(mask_a, vl);\n        count += vcpop_m_b1(mask_e, vl);\n        count += vcpop_m_b1(mask_i, vl);\n        count += vcpop_m_b1(mask_o, vl);\n        count += vcpop_m_b1(mask_u, vl);\n        count += vcpop_m_b1(mask_A, vl);\n        count += vcpop_m_b1(mask_E, vl);\n        count += vcpop_m_b1(mask_I, vl);\n        count += vcpop_m_b1(mask_O, vl);\n        count += vcpop_m_b1(mask_U, vl);\n    }\n    \n    // Check for 'y' or 'Y' at the end\n    if (!s.empty() && (s.back() == 'y' || s.back() == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m8();\n    int sum = 0;\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_str = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        vbool1_t mask = vmsge_vx_u8m8_b1(v_str, 65, vlen);\n        mask = vmand_mm_b1(mask, vmsle_vx_u8m8_b1(v_str, 90, vlen), vlen);\n        \n        // Zero out non-uppercase characters\n        vuint8m8_t v_upper = vand_vx_u8m8_m(mask, v_str, v_str, 0xFF, vlen);\n        \n        // Sum the remaining values\n        sum += vredusum_vs_u8m8_u32m1(vzero_vv_u32m1(1), v_upper, vzero_vv_u32m1(1), vlen);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m8();\n    int sum = 0;\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_str = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        vbool1_t mask = vmsgtu_vx_u8m8_b1(v_str, 64, vlen);\n        mask = vmslt_vx_u8m8_b1_mask(mask, v_str, 91, vlen);\n        \n        // Zero out non-uppercase chars\n        vuint8m8_t v_upper = vmerge_vxm_u8m8(mask, v_str, 0, vlen);\n        \n        // Sum the ASCII codes\n        vint16m8_t v_sum = vwcvt_x_x_v_i16m8(v_upper, vlen);\n        sum += vredsum_vs_i16m8_i16m1(v_sum, v_sum, vlen);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m8();\n    int sum = 0;\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        vbool1_t mask = vmsgtu_vx_u8m8_b1(v, 64, vlen);\n        mask = vmslt_vx_u8m8_b1_mask(mask, v, 91, vlen);\n        \n        // Zero out non-uppercase characters\n        vuint8m8_t upper = vmerge_vxm_u8m8(mask, v, 0, vlen);\n        \n        // Horizontal sum\n        sum += vredusum_vs_u8m8_u32m1(vzero_u32m1(), upper, vlen);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m8();\n    int sum = 0;\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        vbool1_t mask = vmsgtu_vx_u8m8_b1(v, 64, vlen);\n        mask = vmslt_vx_u8m8_b1_mask(mask, v, 91, vlen);\n        \n        // Zero out non-uppercase characters\n        vuint8m8_t upper = vmerge_vxm_u8m8(mask, v, 0, vlen);\n        \n        // Horizontal sum\n        sum += vredusum_vs_u8m8_u32m1(vzero_u32m1(1), upper, vzero_u32m1(1), vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_RVV", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    size_t vlen = vsetvlmax_e8m8();\n    int sum = 0;\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_str = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        vbool1_t mask = vmsgtu_vx_u8m8_b1(v_str, 64, vlen);\n        mask = vmslt_vx_u8m8_b1_mask(mask, v_str, 91, vlen);\n        \n        // Zero out non-uppercase characters\n        vuint8m8_t v_upper = vmerge_vxm_u8m8(mask, vuint8m8_t(), 0, vlen);\n        v_upper = vand_vv_u8m8(v_str, v_upper, vlen);\n        \n        // Horizontal sum\n        vuint32m1_t v_sum = vwredsumu_vs_u8m8_u32m1(v_upper, vuint32m1_t(), vlen);\n        sum += vmv_x_s_u32m1_u32(v_sum);\n    }\n    \n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    size_t vlen = arr.size();\n    size_t min_even_idx = -1;\n    int min_even_val = INT_MAX;\n    \n    // Process vector elements in chunks\n    size_t index = 0;\n    while (index < vlen) {\n        size_t avl = vlen - index;\n        vint32m8_t vec = vle32_v_i32m8(&arr[index], avl);\n        \n        // Create mask for even numbers\n        vbool4_t even_mask = vmsgt_vx_i32m8_b4(vec, -1);\n        even_mask = vmand_mm_b4(even_mask, \n                               vmeq_vx_i32m8_b4(vand_vx_i32m8(vec, 1, avl), 0, avl));\n        \n        // Find minimum even value in this chunk\n        vint32m8_t min_vals = vmerge_vxm_i32m8(even_mask, vec, INT_MAX, avl);\n        int chunk_min = vredmin_vs_i32m8_i32m1(min_vals, min_vals, avl);\n        \n        // If we found a smaller even value, update result\n        if (chunk_min < min_even_val && chunk_min != INT_MAX) {\n            // Find first occurrence of min value in this chunk\n            vbool4_t min_mask = vmeq_vx_i32m8_b4(vec, chunk_min, avl);\n            min_mask = vmand_mm_b4(min_mask, even_mask);\n            \n            size_t first_idx = 0;\n            while (!vmfirst_m_b4(min_mask)) {\n                first_idx++;\n                min_mask = vsrl_vx_b4(min_mask, 1, avl);\n            }\n            \n            min_even_val = chunk_min;\n            min_even_idx = index + first_idx;\n        }\n        \n        index += avl;\n    }\n    \n    if (min_even_idx == -1) return {};\n    return {min_even_val, (int)min_even_idx};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    size_t vlen = arr.size();\n    size_t min_even_idx = vlen;\n    int min_even_val = INT_MAX;\n    \n    size_t vl;\n    vint32m1_t v_data, v_even_mask;\n    vbool32_t v_mask;\n    \n    for (size_t i = 0; i < vlen; i += vl) {\n        vl = vsetvl_e32m1(vlen - i);\n        \n        // Load vector data\n        v_data = vle32_v_i32m1(&arr[i], vl);\n        \n        // Create mask for even numbers\n        v_even_mask = vand_vx_i32m1(v_data, 1, vl);\n        v_mask = vmseq_vx_i32m1_b32(v_even_mask, 0, vl);\n        \n        // Find minimum even value in current chunk\n        vint32m1_t v_min = vfirst_m_b32(v_mask, vl);\n        \n        // Process found even values\n        size_t first_idx;\n        while ((first_idx = vfirst_m_b32(v_mask, vl)) != -1) {\n            int curr_val = arr[i + first_idx];\n            if (curr_val < min_even_val) {\n                min_even_val = curr_val;\n                min_even_idx = i + first_idx;\n            }\n            // Clear the found bit to find next\n            v_mask = vmclr_m_b32(v_mask, first_idx, vl);\n        }\n    }\n    \n    if (min_even_idx == vlen) {\n        return {};\n    }\n    \n    return {min_even_val, (int)min_even_idx};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    size_t vl;\n    size_t n = arr.size();\n    size_t min_even = INT_MAX;\n    size_t min_idx = n;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Load vector\n        vint32m8_t v = vle32_v_i32m8(&arr[i], vl);\n        \n        // Create mask for even numbers\n        vbool4_t even_mask = vmsgt_vx_i32m8_b4(v, -1, vl);  // Get positive numbers\n        even_mask = vmand_mm_b4(even_mask, \n                   vmseq_vx_i32m8_b4(vand_vx_i32m8(v, 1, vl), 0, vl)); // AND with even check\n        \n        // Get first index where mask is true\n        vint32m8_t vidx = vid_v_i32m8(vl);\n        vidx = vadd_vx_i32m8(vidx, i, vl);\n        \n        // Find min even value and its index under mask\n        vint32m8_t v_masked = vmerge_vxm_i32m8(even_mask, v, INT_MAX, vl);\n        vint32m1_t vmin = vredmin_vs_i32m8_i32m1(v_masked, v_masked, vl);\n        int curr_min = vmv_x_s_i32m1_i32(vmin);\n        \n        if (curr_min != INT_MAX) {\n            // Find first occurrence of min value\n            vbool4_t min_mask = vmseq_vx_i32m8_b4(v, curr_min, vl);\n            min_mask = vmand_mm_b4(min_mask, even_mask);\n            \n            size_t first_idx = i;\n            for (size_t j = 0; j < vl; j++) {\n                if (vcpop_m_b4(min_mask, vl) > 0 && \n                    vfirst_m_b4(min_mask, vl) == j) {\n                    first_idx += j;\n                    break;\n                }\n            }\n            \n            if (curr_min < min_even) {\n                min_even = curr_min;\n                min_idx = first_idx;\n            }\n        }\n    }\n    \n    if (min_idx == n) {\n        return {};\n    }\n    \n    return {(int)min_even, (int)min_idx};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    size_t vl;\n    size_t n = arr.size();\n    size_t min_even_val = UINT32_MAX;\n    size_t min_even_idx = UINT32_MAX;\n    \n    // Process vector in chunks\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Load vector chunk\n        vint32m8_t v_data = vle32_v_i32m8(&arr[i], vl);\n        \n        // Create mask for even numbers\n        vbool4_t even_mask = vmsgt_vx_i32m8_b4(v_data, -1, vl);\n        even_mask = vmand_mm_b4(even_mask, \n                               vmseq_vx_i32m8_b4(vand_vx_i32m8(v_data, 1, vl), 0, vl), \n                               vl);\n        \n        // Find minimum even value in this chunk\n        vint32m8_t v_min = vmerge_vxm_i32m8(even_mask, v_data, INT32_MAX, vl);\n        int chunk_min = vredmin_vs_i32m8_i32m1(v_min, v_min, vl);\n        \n        // If we found a smaller even value, update result\n        if (chunk_min != INT32_MAX && (size_t)chunk_min < min_even_val) {\n            min_even_val = chunk_min;\n            \n            // Find first occurrence of min value in this chunk\n            vbool4_t min_mask = vmseq_vx_i32m8_b4(v_data, chunk_min, vl);\n            min_mask = vmand_mm_b4(min_mask, even_mask, vl);\n            \n            // Find first set bit position\n            for (size_t j = 0; j < vl; j++) {\n                if (vmfirst_m_b4(min_mask, vl) == j) {\n                    min_even_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (min_even_val == UINT32_MAX) {\n        return {};\n    }\n    \n    return {(int)min_even_val, (int)min_even_idx};\n}\n```"}
{"task_id": "SimdBench_94_RVV", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    size_t vl;\n    size_t n = arr.size();\n    size_t min_even_val = UINT32_MAX;\n    size_t min_even_idx = UINT32_MAX;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        \n        // Load vector\n        vint32m8_t v_data = vle32_v_i32m8(&arr[i], vl);\n        \n        // Create mask for even numbers\n        vbool4_t even_mask = vmsgt_vx_i32m8_b4(v_data, -1, vl);  // Get positive numbers\n        even_mask = vmand_mm_b4(even_mask, \n                               vmseq_vx_i32m8_b4(vand_vx_i32m8(v_data, 1, vl), 0, vl), vl);\n        \n        // Find first occurrence of even number in this chunk\n        vint32m8_t v_idx = vid_v_i32m8(vl);\n        v_idx = vadd_vx_i32m8(v_idx, i, vl);\n        \n        // Extract values and indices under mask\n        vint32m8_t v_masked_vals = vmerge_vxm_i32m8(even_mask, v_data, INT32_MAX, vl);\n        vint32m8_t v_masked_idx = vmerge_vxm_i32m8(even_mask, v_idx, INT32_MAX, vl);\n        \n        // Find minimum even value in this chunk\n        int32_t chunk_min_val = vredmin_vs_i32m8_i32m1(v_masked_vals, v_masked_vals, vl);\n        \n        // If we found a smaller even value, update both value and index\n        if (chunk_min_val != INT32_MAX && chunk_min_val < min_even_val) {\n            min_even_val = chunk_min_val;\n            \n            // Find index of minimum value\n            vbool4_t min_mask = vmseq_vx_i32m8_b4(v_data, chunk_min_val, vl);\n            min_mask = vmand_mm_b4(min_mask, even_mask, vl);\n            \n            // Get first matching index\n            vint32m8_t v_min_idx = vmerge_vxm_i32m8(min_mask, v_idx, INT32_MAX, vl);\n            min_even_idx = vredmin_vs_i32m8_i32m1(v_min_idx, v_min_idx, vl);\n        }\n    }\n\n    if (min_even_val == UINT32_MAX) {\n        return {};\n    }\n    \n    return {(int)min_even_val, (int)min_even_idx};\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine histogram size\n    size_t vl;\n    int max_val = lst[0];\n    const int* ptr = lst.data();\n    size_t n = lst.size();\n    \n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t v = vle32_v_i32m8(ptr, vl);\n        max_val = vmaxvr_s32m8(max_val, v, vl);\n        ptr += vl;\n        n -= vl;\n    }\n\n    // Create histogram\n    std::vector<int> freq(max_val + 1, 0);\n    ptr = lst.data();\n    n = lst.size();\n    \n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t v = vle32_v_i32m8(ptr, vl);\n        \n        // Increment frequency counts\n        for (size_t i = 0; i < vl; i++) {\n            freq[ptr[i]]++;\n        }\n        \n        ptr += vl;\n        n -= vl;\n    }\n\n    // Find largest number with frequency >= value\n    int result = -1;\n    for (int i = 1; i <= max_val; i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine histogram size\n    size_t vl;\n    int max_val = lst[0];\n    const int* ptr = lst.data();\n    size_t n = lst.size();\n    \n    vint32m1_t v_max = vmv_v_x_i32m1(lst[0], 1);\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_input = vle32_v_i32m1(ptr + i, vl);\n        v_max = vmax_vv_i32m1(v_max, v_input, vl);\n    }\n    max_val = vmv_x_s_i32m1_i32(v_max);\n\n    // Create histogram array\n    std::vector<int> freq(max_val + 1, 0);\n    int* freq_ptr = freq.data();\n\n    // Count frequencies using vector instructions\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_input = vle32_v_i32m1(ptr + i, vl);\n        \n        // Increment frequencies one by one since atomic operations not available\n        for (size_t j = 0; j < vl; j++) {\n            int val = vmv_x_s_i32m1_i32(vslidedown_vx_i32m1(v_input, j, vl));\n            freq[val]++;\n        }\n    }\n\n    // Find largest number where frequency >= number\n    for (int i = max_val; i >= 1; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine count array size\n    size_t vl;\n    int max_val = lst[0];\n    const int* ptr = lst.data();\n    size_t n = lst.size();\n    \n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t v = vle32_v_i32m8(ptr, vl);\n        max_val = vmaxvr_s32m8(max_val, v, vl);\n        ptr += vl;\n        n -= vl;\n    }\n\n    // Initialize count array\n    std::vector<int> count(max_val + 1, 0);\n    \n    // Count frequencies\n    ptr = lst.data();\n    n = lst.size();\n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t v = vle32_v_i32m8(ptr, vl);\n        \n        // Increment counts\n        for (size_t i = 0; i < vl; i++) {\n            int val = vextract_i32m8(v, i);\n            if (val >= 0 && val <= max_val) {\n                count[val]++;\n            }\n        }\n        \n        ptr += vl;\n        n -= vl;\n    }\n    \n    // Find largest number with frequency >= value\n    int result = -1;\n    for (int i = 1; i <= max_val; i++) {\n        if (count[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n    \n    size_t vl;\n    const int* ptr = lst.data();\n    size_t n = lst.size();\n    \n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t vec = vle32_v_i32m8(ptr, vl);\n        \n        for (int i = 0; i <= max_val; i++) {\n            vbool4_t mask = vmseq_vx_i32m8_b4(vec, i, vl);\n            int count = vcpop_m_b4(mask, vl);\n            freq[i] += count;\n        }\n        \n        ptr += vl;\n        n -= vl;\n    }\n    \n    for (int i = max_val; i >= 1; i--) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_RVV", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine histogram size\n    size_t vl;\n    int max_val = lst[0];\n    const int* ptr = lst.data();\n    size_t n = lst.size();\n    \n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t v = vle32_v_i32m8(ptr, vl);\n        max_val = vmaxvr_s32m8(max_val, v, vl);\n        ptr += vl;\n        n -= vl;\n    }\n\n    // Create histogram array initialized to 0\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Count frequencies\n    ptr = lst.data();\n    n = lst.size();\n    while (n > 0) {\n        vl = vsetvl_e32m8(n);\n        vint32m8_t v = vle32_v_i32m8(ptr, vl);\n        \n        // Increment frequencies one by one since scatter operations aren't atomic\n        for (size_t i = 0; i < vl; i++) {\n            freq[ptr[i]]++;\n        }\n        \n        ptr += vl;\n        n -= vl;\n    }\n\n    // Find largest number where frequency >= number\n    int result = -1;\n    for (int i = 1; i < freq.size(); i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Calculate sum\n    vint32m8_t v_sum = vmv_v_x_i32m8(0, vlen);\n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t v = vle32_v_i32m8(&q[i], vl);\n        v_sum = vadd_vv_i32m8(v_sum, v, vl);\n    }\n    \n    int sum = 0;\n    for(size_t i = 0; i < vlen; i++) {\n        sum += vmv_x_s_i32m8_i32(vslidedown_vx_i32m8(v_sum, v_sum, i, vlen));\n    }\n    \n    if(sum > w) return false;\n    \n    // Check palindrome\n    size_t half = n/2;\n    for(size_t i = 0; i < half; i += vlen) {\n        size_t vl = vsetvl_e32m8(std::min(vlen, half - i));\n        vint32m8_t v1 = vle32_v_i32m8(&q[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&q[n-i-vl], vl);\n        vbool4_t mask = vmseq_vv_i32m8_b4(v1, v2, vl);\n        if(!vmall_m_b4(mask, vl)) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n    \n    // Calculate sum\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vlen);\n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t v = __riscv_vle32_v_i32m1(&q[i], vl);\n        v_sum = __riscv_vredsum_vs_i32m1_i32m1(v, v_sum, vl);\n    }\n    int sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    if(sum > w) return false;\n    \n    // Check palindrome\n    size_t half = n/2;\n    for(size_t i = 0; i < half; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m1(std::min(vlen, half - i));\n        vint32m1_t v1 = __riscv_vle32_v_i32m1(&q[i], vl);\n        vint32m1_t v2 = __riscv_vle32_v_i32m1(&q[n-i-vl], vl);\n        vbool32_t mask = __riscv_vmseq_vv_i32m1_b32(v1, v2, vl);\n        if(!__riscv_vmand_m_b32(mask, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Check sum <= w\n    vint32m8_t v_sum = vmv_v_x_i32m8(0, vlen);\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_q = vle32_v_i32m8(&q[i], vl);\n        v_sum = vredsum_vs_i32m8_i32m8(v_sum, v_q, v_sum, vl);\n    }\n    \n    int sum = vmv_x_s_i32m8_i32(v_sum);\n    if(sum > w) return false;\n    \n    // Check palindrome\n    size_t half = n/2;\n    for(size_t i = 0; i < half; i += vlen) {\n        size_t vl = vsetvl_e32m8(std::min(vlen, half - i));\n        \n        vint32m8_t v_left = vle32_v_i32m8(&q[i], vl);\n        vint32m8_t v_right = vle32_v_i32m8(&q[n-i-vl], vl);\n        \n        vbool4_t v_mask = vmseq_vv_i32m8_b4(v_left, v_right, vl);\n        if(!vmandnot_mm_b4(v_mask, v_mask, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Calculate sum\n    vint32m8_t vsum = vmv_v_x_i32m8(0, vlen);\n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t v = vle32_v_i32m8(&q[i], vl);\n        vsum = vadd_vv_i32m8(vsum, v, vl);\n    }\n    \n    int sum = 0;\n    for(size_t i = 0; i < vlen; i++) {\n        sum += vmv_x_s_i32m8_i32(vslidedown_vx_i32m8(vsum, i, 1));\n    }\n    \n    if(sum > w) return false;\n    \n    // Check palindrome\n    size_t half = n/2;\n    for(size_t i = 0; i < half; i += vlen) {\n        size_t vl = vsetvl_e32m8(std::min(vlen, half - i));\n        vint32m8_t v1 = vle32_v_i32m8(&q[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&q[n-i-vl], vl);\n        vbool4_t mask = vmseq_vv_i32m8_b4(v1, v2, vl);\n        if(!vmall_m_b4(mask, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_RVV", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    size_t vlen = __riscv_vsetvlmax_e32m1();\n    \n    // Calculate sum\n    int sum = 0;\n    vint32m1_t v_sum = __riscv_vmv_v_x_i32m1(0, vlen);\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m1(n - i);\n        vint32m1_t v_q = __riscv_vle32_v_i32m1(&q[i], vl);\n        v_sum = __riscv_vredsum_vs_i32m1_i32m1(v_q, v_sum, vl);\n    }\n    sum = __riscv_vmv_x_s_i32m1_i32(v_sum);\n    \n    if(sum > w) return false;\n    \n    // Check palindrome\n    size_t half = n/2;\n    for(size_t i = 0; i < half; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m1(std::min(vlen, half - i));\n        vint32m1_t v_front = __riscv_vle32_v_i32m1(&q[i], vl);\n        vint32m1_t v_back = __riscv_vle32_v_i32m1(&q[n-i-vl], vl);\n        vbool32_t v_mask = __riscv_vmseq_vv_i32m1_b32(v_front, v_back, vl);\n        if(!__riscv_vmand_m_b32(v_mask, vl)) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    size_t vl = vsetvl_e32m8(n/2);\n    \n    // Process elements from both ends towards middle\n    for(size_t i = 0; i < n/2; i += vl) {\n        // Adjust vl for remaining elements\n        vl = vsetvl_e32m8(n/2 - i);\n        \n        // Load elements from start\n        vint32m8_t v_start = vle32_v_i32m8(&arr[i], vl);\n        \n        // Load elements from end in reverse\n        vint32m8_t v_end = vle32_v_i32m8(&arr[n-i-vl], vl);\n        \n        // Compare elements\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_start, v_end, vl);\n        \n        // Count mismatches\n        changes += vl - vcpop_m_b4(mask, vl);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    size_t vl = vsetvl_e32m8(n/2);\n    \n    // Process elements from both ends towards middle\n    for(int i = 0; i < n/2; i += vl) {\n        // Adjust vl for remaining elements\n        vl = vsetvl_e32m8(n/2 - i);\n        \n        // Load elements from start\n        vint32m8_t v_start = vle32_v_i32m8(&arr[i], vl);\n        \n        // Load elements from end in reverse\n        vint32m8_t v_end = vle32_v_i32m8(&arr[n-i-vl], vl);\n        \n        // Compare elements\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_start, v_end, vl);\n        \n        // Count mismatches\n        changes += vl - vcpop_m_b4(mask, vl);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n <= 1) return 0;\n    \n    int changes = 0;\n    size_t i = 0;\n    size_t j = n - 1;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    \n    while (i < j) {\n        size_t batch_size = std::min(vlen, (j - i + 1) / 2);\n        vlen = vsetvl_e32m8(batch_size);\n        \n        // Load elements from front\n        vint32m8_t v_front = vle32_v_i32m8(&arr[i], vlen);\n        \n        // Load elements from back in reverse\n        vint32m8_t v_back;\n        for (size_t k = 0; k < batch_size; k++) {\n            v_back = vse32_v_i32m8(&arr[j-k], vlen);\n        }\n        \n        // Compare elements\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_front, v_back, vlen);\n        \n        // Count mismatches\n        changes += vlen - vcpop_m_b4(mask, vlen);\n        \n        i += batch_size;\n        j -= batch_size;\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int changes = 0;\n    size_t vl;\n    \n    // Get maximum vector length for this platform\n    size_t max_vl = vsetvlmax_e32m8();\n    \n    // Process elements from both ends towards middle\n    for (size_t i = 0; i < n/2; i += vl) {\n        // Set vector length for this iteration\n        vl = vsetvl_e32m8(std::min(max_vl, n/2 - i));\n        \n        // Load vector of elements from start\n        vint32m8_t v_start = vle32_v_i32m8(&arr[i], vl);\n        \n        // Load vector of elements from end in reverse\n        vint32m8_t v_end = vle32_v_i32m8(&arr[n-i-vl], vl);\n        \n        // Compare vectors element-wise\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_start, v_end, vl);\n        \n        // Count number of mismatches\n        changes += vl - vcpop_m_b4(mask, vl);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_RVV", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    int changes = 0;\n    size_t vl;\n    \n    // Get maximum vector length for this platform\n    size_t max_vl = vsetvlmax_e32m8();\n    \n    // Process elements from both ends towards middle\n    for (size_t i = 0; i < n/2; i += vl) {\n        // Set vector length for this iteration\n        vl = vsetvl_e32m8(std::min(max_vl, n/2 - i));\n        \n        // Load vector elements from start\n        vint32m8_t v_start = vle32_v_i32m8(&arr[i], vl);\n        \n        // Load vector elements from end in reverse\n        vint32m8_t v_end = vle32_v_i32m8(&arr[n-i-vl], vl);\n        \n        // Compare elements\n        vbool4_t mask = vmseq_vv_i32m8_b4(v_start, v_end, vl);\n        \n        // Count mismatches\n        changes += vl - vcpop_m_b4(mask, vl);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    size_t vl;\n    vint32m1_t v_sum1, v_sum2;\n    \n    // Process lst1\n    size_t i = 0;\n    while (i < lst1.size()) {\n        vl = vsetvl_e32m1(lst1.size() - i);\n        v_sum1 = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            v_sum1 = vadd_vx_i32m1(v_sum1, lst1[i+j].length(), vl);\n        }\n        \n        // Reduce sum\n        total1 += vredsum_vs_i32m1_i32m1(v_sum1, v_sum1, vl);\n        i += vl;\n    }\n\n    // Process lst2 \n    i = 0;\n    while (i < lst2.size()) {\n        vl = vsetvl_e32m1(lst2.size() - i);\n        v_sum2 = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            v_sum2 = vadd_vx_i32m1(v_sum2, lst2[i+j].length(), vl);\n        }\n        \n        // Reduce sum\n        total2 += vredsum_vs_i32m1_i32m1(v_sum2, v_sum2, vl);\n        i += vl;\n    }\n\n    if (total2 < total1) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    size_t vl;\n    vint32m1_t v_sum1, v_sum2;\n    \n    // Process lst1\n    size_t i = 0;\n    while (i < lst1.size()) {\n        vl = vsetvl_e32m1(lst1.size() - i);\n        v_sum1 = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            v_sum1 = vadd_vx_i32m1(v_sum1, lst1[i + j].length(), vl);\n        }\n        \n        // Horizontal sum\n        total1 += vredsum_vs_i32m1_i32m1(v_sum1, v_sum1, v_sum1, vl);\n        i += vl;\n    }\n    \n    // Process lst2  \n    i = 0;\n    while (i < lst2.size()) {\n        vl = vsetvl_e32m1(lst2.size() - i);\n        v_sum2 = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            v_sum2 = vadd_vx_i32m1(v_sum2, lst2[i + j].length(), vl);\n        }\n        \n        // Horizontal sum\n        total2 += vredsum_vs_i32m1_i32m1(v_sum2, v_sum2, v_sum2, vl);\n        i += vl;\n    }\n\n    if (total2 < total1) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    size_t vl;\n    vint32m1_t v_sum;\n\n    // Calculate sum of chars in lst1\n    size_t n1 = lst1.size();\n    vl = vsetvl_e32m1(n1);\n    v_sum = vmv_v_x_i32m1(0, vl);\n    \n    for (size_t i = 0; i < n1; i += vl) {\n        vl = vsetvl_e32m1(n1 - i);\n        for (size_t j = 0; j < vl; j++) {\n            total1 += lst1[i + j].length();\n        }\n    }\n\n    // Calculate sum of chars in lst2  \n    size_t n2 = lst2.size();\n    vl = vsetvl_e32m1(n2);\n    v_sum = vmv_v_x_i32m1(0, vl);\n    \n    for (size_t i = 0; i < n2; i += vl) {\n        vl = vsetvl_e32m1(n2 - i);\n        for (size_t j = 0; j < vl; j++) {\n            total2 += lst2[i + j].length();\n        }\n    }\n\n    // Return vector with smaller total chars\n    if (total2 < total1) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    size_t vl;\n    vint32m1_t v_sum1, v_sum2;\n    \n    // Process lst1\n    size_t i = 0;\n    while (i < lst1.size()) {\n        vl = vsetvl_e32m1(lst1.size() - i);\n        v_sum1 = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            v_sum1 = vadd_vx_i32m1(v_sum1, lst1[i + j].length(), vl);\n        }\n        \n        // Reduce sum\n        total1 += vredsum_vs_i32m1_i32m1(v_sum1, v_sum1, vl);\n        i += vl;\n    }\n\n    // Process lst2 \n    i = 0;\n    while (i < lst2.size()) {\n        vl = vsetvl_e32m1(lst2.size() - i);\n        v_sum2 = vmv_v_x_i32m1(0, vl);\n        \n        for (size_t j = 0; j < vl; j++) {\n            v_sum2 = vadd_vx_i32m1(v_sum2, lst2[i + j].length(), vl);\n        }\n        \n        // Reduce sum\n        total2 += vredsum_vs_i32m1_i32m1(v_sum2, v_sum2, vl);\n        i += vl;\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_RVV", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    size_t vl;\n    vsetvli_e8m8(&vl, lst1.size());\n    \n    // Calculate total chars in lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        size_t i;\n        for (i = 0; i + vl <= len; i += vl) {\n            vuint8m8_t v = vle8_v_u8m8((uint8_t*)&str[i], vl);\n            total1 += vl;\n        }\n        total1 += len - i;\n    }\n\n    // Calculate total chars in lst2 \n    vsetvli_e8m8(&vl, lst2.size());\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        size_t i;\n        for (i = 0; i + vl <= len; i += vl) {\n            vuint8m8_t v = vle8_v_u8m8((uint8_t*)&str[i], vl);\n            total2 += vl;\n        }\n        total2 += len - i;\n    }\n\n    // Return vector with smaller total chars\n    if (total2 < total1) {\n        return lst2;\n    }\n    return lst1;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n == 1) return false;\n    if (n == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m1();\n    vbool64_t vmask;\n    vuint64m1_t vx, vn;\n    uint64_t result = x;\n    \n    vx = vmv_v_x_u64m1(x, vlen);\n    vn = vmv_v_x_u64m1(n, vlen);\n\n    while (result >= n) {\n        if (result % n != 0) {\n            return false;\n        }\n        result /= n;\n    }\n\n    vmask = vmseq_vx_u64m1_b64(vx, result, vlen);\n    if (result == 1 && vfirst_m_b64(vmask, vlen) >= 0) {\n        return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n == 1) return false;\n    if (n == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m1();\n    vuint64m1_t v_power = vmv_v_x_u64m1(1, vlen);\n    vuint64m1_t v_n = vmv_v_x_u64m1(n, vlen);\n    \n    while (1) {\n        v_power = vmul_vx_u64m1(v_power, n, vlen);\n        \n        vbool64_t mask = vmseq_vx_u64m1_b64(v_power, x, vlen);\n        if (vfirst_m_b64(mask, vlen) >= 0) {\n            return true;\n        }\n        \n        vbool64_t overflow = vmsgtu_vx_u64m1_b64(v_power, x, vlen);\n        if (vfirst_m_b64(overflow, vlen) >= 0) {\n            return false;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    size_t vlen = vsetvlmax_e64m1();\n    vbool64_t vmask;\n    vuint64m1_t vx, vn;\n    \n    vx = vmv_v_x_u64m1(x, vlen);\n    vn = vmv_v_x_u64m1(n, vlen);\n\n    while (x > 1) {\n        if (x % n != 0) return false;\n        x = x / n;\n    }\n\n    vmask = vmseq_vx_u64m1_b64(vx, 1, vlen);\n    if (vfirst_m_b64(vmask, vlen) != -1) {\n        return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n == 1) return false;\n    if (n == 0) return false;\n\n    size_t vlen = vsetvlmax_e64m1();\n    vuint64m1_t v_power = vmv_v_x_u64m1(1, vlen);\n    vuint64m1_t v_n = vmv_v_x_u64m1(n, vlen);\n    \n    while (1) {\n        v_power = vmul_vx_u64m1(v_power, n, vlen);\n        \n        vbool64_t mask = vmseq_vx_u64m1_b64(v_power, x, vlen);\n        if (vfirst_m_b64(mask, vlen) >= 0) {\n            return true;\n        }\n        \n        if (vfirst_m_b64(vmsgtu_vx_u64m1_b64(v_power, x, vlen), vlen) >= 0) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_RVV", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    size_t vlen = vsetvlmax_e64m1();\n    vbool64_t vmask;\n    vuint64m1_t vx = vmv_v_x_u64m1(x, vlen);\n    vuint64m1_t vn = vmv_v_x_u64m1(n, vlen);\n    vuint64m1_t vtemp = vmv_v_x_u64m1(1, vlen);\n    \n    while (1) {\n        vtemp = vmul_vv_u64m1(vtemp, vn, vlen);\n        vmask = vmseq_vx_u64m1_b64(vtemp, x, vlen);\n        if (vfirst_m_b64(vmask, vlen) >= 0) return true;\n        \n        vmask = vmsgt_vx_u64m1_b64(vtemp, x, vlen);\n        if (vfirst_m_b64(vmask, vlen) >= 0) return false;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if(num.empty()) return 0;\n    \n    size_t vlen = num.length();\n    const uint8_t *str = (const uint8_t*)num.c_str();\n    \n    // Initialize result vector\n    uint8_t *result = (uint8_t*)malloc(vlen);\n    size_t vlmax = vsetvlmax_e8m1();\n    \n    // Process string in chunks\n    for(size_t vl; vlen > 0; vlen -= vl, str += vl) {\n        vl = vsetvl_e8m1(vlen);\n        \n        // Load vector of characters\n        vuint8m1_t v_chars = vle8_v_u8m1(str, vl);\n        \n        // Convert ASCII hex digits to values\n        vuint8m1_t v_vals = v_chars;\n        \n        // For A-F, subtract 'A'-10\n        vbool8_t v_af_mask = vmsgtu_vx_u8m1_b8(v_chars, (uint8_t)'9', vl);\n        v_vals = vsub_vx_u8m1_m(v_af_mask, v_vals, v_vals, 'A'-10, vl);\n        \n        // For 0-9, subtract '0'\n        vbool8_t v_09_mask = vmsle_vx_u8m1_b8(v_chars, (uint8_t)'9', vl);\n        v_vals = vsub_vx_u8m1_m(v_09_mask, v_vals, v_vals, '0', vl);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        vbool8_t v_prime_mask = vmseq_vx_u8m1_b8(v_vals, 2, vl);\n        v_prime_mask = vmor_mm_b8(v_prime_mask, \n                      vmseq_vx_u8m1_b8(v_vals, 3, vl), vl);\n        v_prime_mask = vmor_mm_b8(v_prime_mask,\n                      vmseq_vx_u8m1_b8(v_vals, 5, vl), vl);\n        v_prime_mask = vmor_mm_b8(v_prime_mask,\n                      vmseq_vx_u8m1_b8(v_vals, 7, vl), vl);\n        v_prime_mask = vmor_mm_b8(v_prime_mask,\n                      vmseq_vx_u8m1_b8(v_vals, 11, vl), vl);\n        v_prime_mask = vmor_mm_b8(v_prime_mask,\n                      vmseq_vx_u8m1_b8(v_vals, 13, vl), vl);\n                      \n        // Store result\n        vse8_v_u8m1(result + (str - (const uint8_t*)num.c_str()), \n                    vmerge_vxm_u8m1(v_prime_mask, vuint8m1_t(), 1, vl), vl);\n    }\n    \n    // Count total number of prime digits\n    int count = 0;\n    for(size_t i = 0; i < num.length(); i++) {\n        count += result[i];\n    }\n    \n    free(result);\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    size_t vlen = vsetvlmax_e8m8();\n    size_t n = num.length();\n    size_t count = 0;\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m8(n - i);\n        \n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&num[i], vl);\n        \n        // Convert ASCII hex chars to values\n        vuint8m8_t v_vals = v_chars;\n        \n        // For A-F: subtract 55 to get decimal 10-15\n        vbool1_t v_is_letter = vmsgtu_vx_u8m8_b1(v_chars, 64, vl);\n        v_vals = vsub_vx_u8m8_m(v_is_letter, v_vals, v_vals, 55, vl);\n        \n        // For 0-9: subtract 48 to get decimal 0-9  \n        vbool1_t v_is_digit = vmsle_vx_u8m8_b1(v_chars, 57, vl);\n        v_vals = vsub_vx_u8m8_m(v_is_digit, v_vals, v_vals, 48, vl);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        vbool1_t v_is_2 = vmseq_vx_u8m8_b1(v_vals, 2, vl);\n        vbool1_t v_is_3 = vmseq_vx_u8m8_b1(v_vals, 3, vl);\n        vbool1_t v_is_5 = vmseq_vx_u8m8_b1(v_vals, 5, vl);\n        vbool1_t v_is_7 = vmseq_vx_u8m8_b1(v_vals, 7, vl);\n        vbool1_t v_is_11 = vmseq_vx_u8m8_b1(v_vals, 11, vl);\n        vbool1_t v_is_13 = vmseq_vx_u8m8_b1(v_vals, 13, vl);\n        \n        // Combine all prime matches\n        vbool1_t v_is_prime = vmor_mm_b1(v_is_2, v_is_3, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_5, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_7, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_11, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_13, vl);\n        \n        // Count matches\n        count += vcpop_m_b1(v_is_prime, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    size_t vlen = vsetvlmax_e8m8();\n    size_t n = num.length();\n    size_t count = 0;\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m8(n - i);\n        \n        vuint8m8_t v_input = vle8_v_u8m8((uint8_t*)&num[i], vl);\n        \n        // Convert ASCII hex digits to values\n        vuint8m8_t v_values = v_input;\n        vbool1_t v_is_digit = vmsgtu_vx_u8m8_b1(v_input, 47, vl);\n        vbool1_t v_is_letter = vmsgtu_vx_u8m8_b1(v_input, 64, vl);\n        \n        // For digits 0-9\n        v_values = vsub_vx_u8m8_m(v_is_digit, v_values, v_values, 48, vl);\n        \n        // For letters A-F\n        v_values = vsub_vx_u8m8_m(v_is_letter, v_values, v_values, 55, vl);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        vbool1_t v_is_2 = vmseq_vx_u8m8_b1(v_values, 2, vl);\n        vbool1_t v_is_3 = vmseq_vx_u8m8_b1(v_values, 3, vl);\n        vbool1_t v_is_5 = vmseq_vx_u8m8_b1(v_values, 5, vl);\n        vbool1_t v_is_7 = vmseq_vx_u8m8_b1(v_values, 7, vl);\n        vbool1_t v_is_11 = vmseq_vx_u8m8_b1(v_values, 11, vl);\n        vbool1_t v_is_13 = vmseq_vx_u8m8_b1(v_values, 13, vl);\n        \n        // Combine all prime checks\n        vbool1_t v_is_prime = vmor_mm_b1(v_is_2, v_is_3, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_5, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_7, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_11, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_13, vl);\n        \n        // Count prime digits\n        count += vcpop_m_b1(v_is_prime, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    size_t vlen = vsetvlmax_e8m8();\n    size_t n = num.length();\n    size_t count = 0;\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m8(n - i);\n        \n        vuint8m8_t v_input = vle8_v_u8m8((uint8_t*)&num[i], vl);\n        \n        // Convert ASCII hex digits to values\n        vuint8m8_t v_values = v_input;\n        vbool1_t v_is_digit = vmsleu_vx_u8m8_b1(v_input, 57, vl);  // <= '9'\n        v_values = vsub_vx_u8m8_m(v_is_digit, v_values, v_values, 48, vl); // '0'-'9' -> 0-9\n        \n        vbool1_t v_is_letter = vmsgt_vx_u8m8_b1(v_input, 64, vl);  // > '@'\n        v_values = vsub_vx_u8m8_m(v_is_letter, v_values, v_input, 55, vl); // 'A'-'F' -> 10-15\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        vbool1_t v_is_2 = vmseq_vx_u8m8_b1(v_values, 2, vl);\n        vbool1_t v_is_3 = vmseq_vx_u8m8_b1(v_values, 3, vl);\n        vbool1_t v_is_5 = vmseq_vx_u8m8_b1(v_values, 5, vl);\n        vbool1_t v_is_7 = vmseq_vx_u8m8_b1(v_values, 7, vl);\n        vbool1_t v_is_11 = vmseq_vx_u8m8_b1(v_values, 11, vl);\n        vbool1_t v_is_13 = vmseq_vx_u8m8_b1(v_values, 13, vl);\n        \n        // Combine all prime matches\n        vbool1_t v_is_prime = vmor_mm_b1(v_is_2, v_is_3, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_5, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_7, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_11, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_13, vl);\n        \n        // Count matches\n        count += vcpop_m_b1(v_is_prime, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_RVV", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    size_t vlen = num.length();\n    size_t count = 0;\n    \n    // Get vector length\n    size_t avl = vsetvlmax_e8m8();\n    \n    // Process string in chunks of vector length\n    for (size_t i = 0; i < vlen; i += avl) {\n        size_t vl = vsetvl_e8m8(vlen - i);\n        \n        // Load chunk of string into vector\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&num[i], vl);\n        \n        // Create mask vectors for different character ranges\n        vbool1_t v_num_mask = vmsgtu_vx_u8m8_b1(v_chars, '0'-1, vl);\n        vbool1_t v_num_mask2 = vmsleu_vx_u8m8_b1(v_chars, '9', vl);\n        vbool1_t v_alpha_mask = vmsgtu_vx_u8m8_b1(v_chars, 'A'-1, vl);\n        vbool1_t v_alpha_mask2 = vmsleu_vx_u8m8_b1(v_chars, 'F', vl);\n        \n        // Combine masks\n        vbool1_t v_valid_num = vand_mm_b1(v_num_mask, v_num_mask2, vl);\n        vbool1_t v_valid_alpha = vand_mm_b1(v_alpha_mask, v_alpha_mask2, vl);\n        \n        // Convert characters to values\n        vuint8m8_t v_values;\n        v_values = vsub_vx_u8m8_m(v_valid_num, v_chars, v_chars, '0', vl);\n        v_values = vsub_vx_u8m8_m(v_valid_alpha, v_values, v_chars, 'A'-10, vl);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        vbool1_t v_is_2 = vmseq_vx_u8m8_b1(v_values, 2, vl);\n        vbool1_t v_is_3 = vmseq_vx_u8m8_b1(v_values, 3, vl);\n        vbool1_t v_is_5 = vmseq_vx_u8m8_b1(v_values, 5, vl);\n        vbool1_t v_is_7 = vmseq_vx_u8m8_b1(v_values, 7, vl);\n        vbool1_t v_is_11 = vmseq_vx_u8m8_b1(v_values, 11, vl);\n        vbool1_t v_is_13 = vmseq_vx_u8m8_b1(v_values, 13, vl);\n        \n        // Combine prime masks\n        vbool1_t v_is_prime = vmor_mm_b1(v_is_2, v_is_3, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_5, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_7, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_11, vl);\n        v_is_prime = vmor_mm_b1(v_is_prime, v_is_13, vl);\n        \n        // Count primes in this chunk\n        count += vcpop_m_b1(v_is_prime, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m1();\n    size_t n = s.length() - 2;\n    const uint8_t* ptr = (const uint8_t*)s.data();\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        \n        vuint8m1_t v1 = __riscv_vle8_v_u8m1(ptr + i, vl);\n        vuint8m1_t v2 = __riscv_vle8_v_u8m1(ptr + i + 1, vl); \n        vuint8m1_t v3 = __riscv_vle8_v_u8m1(ptr + i + 2, vl);\n\n        vbool8_t eq12 = __riscv_vmseq_vv_u8m1_b8(v1, v2, vl);\n        vbool8_t eq23 = __riscv_vmseq_vv_u8m1_b8(v2, v3, vl);\n        vbool8_t eq13 = __riscv_vmseq_vv_u8m1_b8(v1, v3, vl);\n        \n        vbool8_t any_equal = __riscv_vmor_mm_b8(eq12, eq23, vl);\n        any_equal = __riscv_vmor_mm_b8(any_equal, eq13, vl);\n\n        if (__riscv_vfirst_m_b8(any_equal, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m1();\n    size_t n = s.length() - 2;\n    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(s.data());\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        \n        vuint8m1_t v1 = __riscv_vle8_v_u8m1(ptr + i, vl);\n        vuint8m1_t v2 = __riscv_vle8_v_u8m1(ptr + i + 1, vl);\n        vuint8m1_t v3 = __riscv_vle8_v_u8m1(ptr + i + 2, vl);\n        \n        vbool8_t eq12 = __riscv_vmseq_vv_u8m1_b8(v1, v2, vl);\n        vbool8_t eq23 = __riscv_vmseq_vv_u8m1_b8(v2, v3, vl);\n        vbool8_t eq13 = __riscv_vmseq_vv_u8m1_b8(v1, v3, vl);\n        \n        vbool8_t any_equal = __riscv_vmor_mm_b8(eq12, eq23, vl);\n        any_equal = __riscv_vmor_mm_b8(any_equal, eq13, vl);\n        \n        if (__riscv_vfirst_m_b8(any_equal, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t vlen = vsetvlmax_e8m1();\n    size_t n = s.length() - 2;\n    const uint8_t* ptr = (const uint8_t*)s.data();\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m1(n - i);\n        \n        vuint8m1_t v1 = vle8_v_u8m1(ptr + i, vl);\n        vuint8m1_t v2 = vle8_v_u8m1(ptr + i + 1, vl); \n        vuint8m1_t v3 = vle8_v_u8m1(ptr + i + 2, vl);\n        \n        vbool8_t eq12 = vmseq_vv_u8m1_b8(v1, v2, vl);\n        vbool8_t eq23 = vmseq_vv_u8m1_b8(v2, v3, vl);\n        vbool8_t eq13 = vmseq_vv_u8m1_b8(v1, v3, vl);\n        \n        vbool8_t any_equal = vmor_mm_b8(vmor_mm_b8(eq12, eq23, vl), eq13, vl);\n        \n        if (vfirst_m_b8(any_equal, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m1();\n    size_t n = s.length() - 2;\n    const uint8_t* ptr = (const uint8_t*)s.data();\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e8m1(n - i);\n        \n        vuint8m1_t v1 = __riscv_vle8_v_u8m1(ptr + i, vl);\n        vuint8m1_t v2 = __riscv_vle8_v_u8m1(ptr + i + 1, vl);\n        vuint8m1_t v3 = __riscv_vle8_v_u8m1(ptr + i + 2, vl);\n        \n        vbool8_t eq12 = __riscv_vmseq_vv_u8m1_b8(v1, v2, vl);\n        vbool8_t eq23 = __riscv_vmseq_vv_u8m1_b8(v2, v3, vl);\n        vbool8_t eq13 = __riscv_vmseq_vv_u8m1_b8(v1, v3, vl);\n        \n        vbool8_t any_equal = __riscv_vmor_mm_b8(eq12, eq23, vl);\n        any_equal = __riscv_vmor_mm_b8(any_equal, eq13, vl);\n        \n        if (__riscv_vfirst_m_b8(any_equal, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_RVV", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    size_t vlen = vsetvlmax_e8m1();\n    size_t n = s.length() - 2;\n    const uint8_t* ptr = (const uint8_t*)s.data();\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m1(n - i);\n        \n        vuint8m1_t v1 = vle8_v_u8m1(ptr + i, vl);\n        vuint8m1_t v2 = vle8_v_u8m1(ptr + i + 1, vl); \n        vuint8m1_t v3 = vle8_v_u8m1(ptr + i + 2, vl);\n        \n        vbool8_t eq12 = vmseq_vv_u8m1_b8(v1, v2, vl);\n        vbool8_t eq23 = vmseq_vv_u8m1_b8(v2, v3, vl);\n        vbool8_t eq13 = vmseq_vv_u8m1_b8(v1, v3, vl);\n        \n        vbool8_t any_equal = vmor_mm_b8(eq12, vmor_mm_b8(eq23, eq13, vl), vl);\n        \n        if (vfirst_m_b8(any_equal, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    size_t vl;\n    \n    vint32m1_t vid = vid_v_i32m1(vsetvlmax_e32m1());\n    vint32m1_t vinc = vmul_vx_i32m1(vid, 2, vsetvlmax_e32m1());\n    vint32m1_t vbase = vadd_vx_i32m1(vinc, 3, vsetvlmax_e32m1());\n    \n    while ((vl = vsetvl_e32m1(sqrt_len)) > 0) {\n        vint32m1_t vdivisors = vslide_vx_i32m1(vbase, 0, vl);\n        vbool32_t vmask = vmseq_vx_i32m1_b32(vrem_vx_i32m1(vint32m1_t(len), vdivisors, vl), 0, vl);\n        \n        if (vmfirst_m_b32(vmask, vl) >= 0) {\n            return false;\n        }\n        \n        vbase = vadd_vx_i32m1(vbase, 2 * vl, vl);\n        sqrt_len -= vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    size_t vl;\n    \n    vint32m1_t vid = vid_v_i32m1(vsetvlmax_e32m1());\n    vint32m1_t vinc = vmul_vx_i32m1(vid, 2, vsetvlmax_e32m1());\n    vint32m1_t vdivisors = vadd_vx_i32m1(vinc, 3, vsetvlmax_e32m1());\n    \n    for (size_t i = 3; i <= sqrt_len;) {\n        vl = vsetvl_e32m1(sqrt_len - i + 1);\n        vbool32_t vmask = vmseq_vx_i32m1_b32(vslide1down_vx_i32m1(vdivisors, 0, vl), 0, vl);\n        vint32m1_t vrem = vrem_vx_i32m1(vreinterpret_v_i32m1(len), i, vl);\n        \n        if (vmfirst_m_b32(vmseq_vx_i32m1_b32(vrem, 0, vl))) {\n            return false;\n        }\n        \n        i += vl * 2;\n        vdivisors = vadd_vx_i32m1(vdivisors, vl * 2, vl);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    size_t avl = sqrt_len - 2;\n    \n    vint32m1_t divisors;\n    vbool32_t mask;\n    vint32m1_t remainders;\n    \n    size_t vl;\n    bool is_prime = true;\n    \n    for (size_t i = 3; i <= sqrt_len; i += vl) {\n        vl = vsetvl_e32m1(avl);\n        \n        divisors = vid_v_i32m1(vl);\n        divisors = vadd_vx_i32m1(divisors, i, vl);\n        \n        remainders = vrem_vx_i32m1(divisors, len, vl);\n        mask = vmseq_vx_i32m1_b32(remainders, 0, vl);\n        \n        if (vcpop_m_b32(mask, vl) > 0) {\n            is_prime = false;\n            break;\n        }\n        \n        avl -= vl;\n    }\n    \n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    size_t avl = sqrt_len - 2;\n    \n    bool is_prime = true;\n    size_t vl;\n    \n    vint32m8_t indices;\n    vbool4_t mask;\n    \n    size_t start = 3;\n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        indices = vid_v_i32m8(vl);\n        indices = vadd_vx_i32m8(indices, start, vl);\n        \n        vint32m8_t remainders = vrem_vx_i32m8(len, indices, vl);\n        mask = vmseq_vx_i32m8_b4(remainders, 0, vl);\n        \n        if (vcpop_m_b4(mask, vl) > 0) {\n            is_prime = false;\n            break;\n        }\n        \n        start += vl;\n        avl -= vl;\n    }\n    \n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_RVV", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    size_t vl;\n    size_t avl = sqrt_len - 2;\n    \n    vint32m1_t divisors;\n    vbool32_t mask;\n    vint32m1_t remainders;\n    \n    bool is_prime = true;\n    size_t index = 3;\n    \n    while (avl > 0) {\n        vl = vsetvl_e32m1(avl);\n        \n        divisors = vid_v_i32m1(vl);\n        divisors = vadd_vx_i32m1(divisors, index, vl);\n        \n        remainders = vrem_vx_i32m1(vreinterpret_v_i32m1(vmv_v_x_i32m1(len, vl)), \n                                 divisors, vl);\n        \n        mask = vmseq_vx_i32m1_b32(remainders, 0, vl);\n        \n        if (vmany_m_b32(mask, vl)) {\n            is_prime = false;\n            break;\n        }\n        \n        index += vl;\n        avl -= vl;\n    }\n    \n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    size_t vlen = vsetvlmax_e8m1();\n    uint8_t digits[20];\n    int len = 0;\n    \n    // Convert to decimal digits\n    while (N) {\n        digits[len++] = N % 10;\n        N /= 10;\n    }\n    \n    // Sum digits using vector instructions\n    vint8m1_t v_sum = vmv_v_x_i8m1(0, vlen);\n    \n    for (int i = 0; i < len; i += vlen) {\n        size_t vl = vsetvl_e8m1(len - i);\n        vint8m1_t v_digits = vle8_v_i8m1(&digits[i], vl);\n        v_sum = vadd_vv_i8m1(v_sum, v_digits, vl);\n    }\n    \n    // Horizontal sum\n    int sum = 0;\n    uint8_t temp[vlen];\n    vse8_v_i8m1(temp, v_sum, vlen);\n    for (size_t i = 0; i < vlen; i++) {\n        sum += temp[i];\n    }\n    \n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum) {\n        result = (sum & 1 ? '1' : '0') + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    size_t vlen = vsetvlmax_e8m8();\n    uint8_t digits[20];\n    int len = 0;\n    \n    // Convert to decimal digits\n    while (N > 0) {\n        digits[len++] = N % 10;\n        N /= 10;\n    }\n    \n    // Sum digits using vector reduction\n    vint8m8_t v_digits;\n    vint8m8_t v_sum = vmv_v_x_i8m8(0, vlen);\n    \n    size_t vl = vsetvl_e8m8(len);\n    v_digits = vle8_v_i8m8(digits, vl);\n    v_sum = vredsum_vs_i8m8_i8m8(v_sum, v_digits, v_sum, vl);\n    \n    int sum = vmv_x_s_i8m8_i8(v_sum);\n    \n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = ((sum & 1) ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    size_t vlen = vsetvlmax_e8m8();\n    uint8_t digits[20];\n    int len = 0;\n    \n    // Convert to decimal digits\n    while (N > 0) {\n        digits[len++] = N % 10;\n        N /= 10;\n    }\n    \n    // Sum digits using vector instructions\n    vint8m8_t v_sum = vmv_v_x_i8m8(0, vlen);\n    \n    for (int i = 0; i < len; i += vlen) {\n        size_t vl = vsetvl_e8m8(len - i);\n        vint8m8_t v_digits = vle8_v_i8m8(&digits[i], vl);\n        v_sum = vadd_vv_i8m8(v_sum, v_digits, vl);\n    }\n    \n    // Horizontal sum\n    int sum = 0;\n    int8_t temp[vlen];\n    vse8_v_i8m8(temp, v_sum, vlen);\n    for (size_t i = 0; i < vlen; i++) {\n        sum += temp[i];\n    }\n    \n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = (sum & 1 ? '1' : '0') + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    size_t vlen = vsetvlmax_e8m8();\n    uint8_t digits[20];\n    int len = 0;\n    \n    // Convert to decimal digits\n    while (N > 0) {\n        digits[len++] = N % 10;\n        N /= 10;\n    }\n    \n    // Calculate sum using vector instructions\n    vint8m8_t v_sum = vmv_v_x_i8m8(0, vlen);\n    \n    for (int i = 0; i < len; i += vlen) {\n        size_t vl = vsetvl_e8m8(len - i);\n        vint8m8_t v_digits = vle8_v_i8m8(&digits[i], vl);\n        v_sum = vadd_vv_i8m8(v_sum, v_digits, vl);\n    }\n    \n    // Horizontal sum\n    int sum = 0;\n    int8_t temp_sum[vlen];\n    vse8_v_i8m8(temp_sum, v_sum, vlen);\n    for(size_t i = 0; i < vlen; i++) {\n        sum += temp_sum[i];\n    }\n    \n    // Convert sum to binary string\n    if(sum == 0) return \"0\";\n    \n    std::string result;\n    while(sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_RVV", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    size_t vlen = vsetvlmax_e8m8();\n    uint8_t digits[20];\n    int idx = 0;\n    \n    // Convert to decimal digits\n    while (N > 0) {\n        digits[idx++] = N % 10;\n        N /= 10;\n    }\n    \n    // Sum digits using vector instructions\n    uint8_t sum = 0;\n    while (idx > 0) {\n        size_t vl = vsetvl_e8m8(idx);\n        vuint8m8_t vec = vle8_v_u8m8(digits, vl);\n        \n        // Horizontal sum\n        vuint8m4_t vec_m4 = vundefined_u8m4();\n        vuint8m2_t vec_m2 = vundefined_u8m2();\n        vuint8m1_t vec_m1 = vundefined_u8m1();\n        \n        vec_m4 = vredsum_vs_u8m8_u8m4(vec_m4, vec, vuint8m4_t(), vl);\n        vec_m2 = vredsum_vs_u8m4_u8m2(vec_m2, vec_m4, vuint8m2_t(), vl);\n        vec_m1 = vredsum_vs_u8m2_u8m1(vec_m1, vec_m2, vuint8m1_t(), vl);\n        \n        sum += vmv_x_s_u8m1_u8(vec_m1);\n        idx = 0;\n    }\n\n    // Convert sum to binary string\n    if (sum == 0) return \"0\";\n    \n    std::string result;\n    while (sum > 0) {\n        result = (sum & 1 ? '1' : '0') + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m8();\n    \n    vint32m8_t v_mask, v_data;\n    vbool4_t vmask;\n    \n    for (size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        v_data = vle32_v_i32m8(&lst[0], vl);\n        \n        // Create mask for odd indices\n        v_mask = vid_v_i32m8(vl);\n        vmask = vmsne_vx_i32m8_b4(v_mask, 0, vl);\n        \n        // Mask for even numbers\n        vmask = vmand_mm_b4(vmask, vmsne_vx_i32m8_b4(vand_vx_i32m8(v_data, 1, vl), 1, vl), vl);\n        \n        // Add elements where mask is true\n        sum += vredsum_vs_i32m8_i32m1(v_data, v_data, vmask, vl);\n        \n        lst.erase(lst.begin(), lst.begin() + vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t vl;\n    size_t n = lst.size();\n    int sum = 0;\n    \n    vint32m1_t v_mask;\n    vint32m1_t v_data;\n    vbool32_t v_even;\n    vbool32_t v_odd_idx;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for even numbers\n        v_even = vmslt_vx_i32m1_b32(vand_vx_i32m1(v_data, 1, vl), 1, vl);\n        \n        // Create mask for odd indices\n        v_odd_idx = vmseq_vx_i32m1_b32(vand_vx_i32m1(vid_v_i32m1(vl), 1, vl), 1, vl);\n        \n        // Combine masks\n        v_even = vmand_mm_b32(v_even, v_odd_idx, vl);\n        \n        // Mask and reduce\n        v_data = vmerge_vxm_i32m1(v_even, v_data, 0, vl);\n        sum += vredsum_vs_i32m1_i32m1(vzero_vint32m1(vl), v_data, vzero_vint32m1(vl), vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t vl;\n    size_t n = lst.size();\n    int sum = 0;\n    \n    vint32m1_t v_mask;\n    vint32m1_t v_data;\n    vbool32_t v_even;\n    vbool32_t v_odd_idx;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for even numbers\n        v_even = vmslt_vx_i32m1_b32(vand_vx_i32m1(v_data, 1, vl), 1, vl);\n        \n        // Create mask for odd indices\n        vint32m1_t v_indices = vadd_vx_i32m1(vid_v_i32m1(vl), i, vl);\n        v_odd_idx = vmsgt_vx_i32m1_b32(vand_vx_i32m1(v_indices, 1, vl), 0, vl);\n        \n        // Combine masks and accumulate\n        vbool32_t v_final_mask = vmand_mm_b32(v_even, v_odd_idx, vl);\n        sum += vredsum_vs_i32m1_i32m1(v_data, vmv_v_x_i32m1(0, vl), \n                                     vmerge_vxm_i32m1(vmv_v_x_i32m1(0, vl), v_data, v_final_mask, vl), vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t i;\n\n    vint32m1_t v_mask;\n    vint32m1_t v_data;\n    vbool32_t v_even_mask;\n    vbool32_t v_odd_idx;\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        \n        v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create mask for even numbers\n        v_even_mask = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_data, 1, vl), 1, vl);\n        \n        // Create mask for odd indices\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i, vl);\n        v_odd_idx = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_idx, 1, vl), 0, vl);\n        \n        // Combine masks and sum matching elements\n        vbool32_t v_final_mask = vmand_mm_b32(v_even_mask, v_odd_idx, vl);\n        sum += vredsum_vs_i32m1_i32m1(v_data, vmv_v_x_i32m1(0, vl), \n                                     vmerge_vxm_i32m1(vmv_v_x_i32m1(0, vl), v_data, v_final_mask, vl), vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_RVV", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t vlmax = vsetvlmax_e32m1();\n    \n    for (size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m1(vlen);\n        vint32m1_t v = vle32_v_i32m1(&lst[0], vl);\n        \n        // Create mask for odd indices\n        vbool32_t odd_mask = vmsltu_vx_i32m1_b32(vrgather_vx_i32m1(v, 0, vl), 1, vl);\n        \n        // Create mask for even values \n        vbool32_t even_mask = vmslt_vx_i32m1_b32(vand_vx_i32m1(v, 1, vl), 1, vl);\n        \n        // Combine masks\n        vbool32_t mask = vand_mm_b32(odd_mask, even_mask);\n        \n        // Sum masked elements\n        vint32m1_t masked = vmerge_vxm_i32m1(vmv_v_x_i32m1(0, vl), v, mask, vl);\n        sum += vredsum_vs_i32m1_i32m1(vmv_v_x_i32m1(0, vl), masked, vmv_v_x_i32m1(0, vl), vl);\n        \n        lst.erase(lst.begin(), lst.begin() + vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_input = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Multiply by 2\n        vuint8m8_t v_shift = vmul_vx_u8m8(v_input, 2, vlen);\n        \n        // Multiply result by 2 again\n        v_shift = vmul_vx_u8m8(v_shift, 2, vlen);\n        \n        // Add to original chars to get rotated values\n        vuint8m8_t v_result = vadd_vv_u8m8(v_input, v_shift, vlen);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < s.length(); i++) {\n        result[i] = s[i] + ((s[i] * 2) * 2);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    size_t n = s.length();\n    std::string result(n, 0);\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e8m8(n - i);\n        \n        vuint8m8_t v_input = __riscv_vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Multiply by 2\n        vuint8m8_t v_shift = __riscv_vmul_vx_u8m8(v_input, 2, vl);\n        \n        // Add the shift to get final encrypted value\n        vuint8m8_t v_result = __riscv_vadd_vv_u8m8(v_input, v_shift, vl);\n        \n        __riscv_vse8_v_u8m8((uint8_t*)&result[i], v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s.length(), 0);\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_input = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Calculate shift amount: (x * 2) * 2 = x * 4\n        vuint8m8_t v_shift = vmul_vx_u8m8(v_input, 4, vl);\n        \n        // Add shift to input\n        vuint8m8_t v_result = vadd_vv_u8m8(v_input, v_shift, vl);\n        \n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vl);\n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s.length(), 0);\n    size_t vl;\n    size_t i = 0;\n    \n    while (i < s.length()) {\n        vl = vsetvl_e8m8(s.length() - i);\n        \n        vuint8m8_t v_input = vle8_v_u8m8((uint8_t*)&s[i], vl);\n        \n        // Multiply by 2\n        vuint8m8_t v_shift = vmul_vx_u8m8(v_input, 2, vl);\n        \n        // Multiply result by 2 again\n        v_shift = vmul_vx_u8m8(v_shift, 2, vl);\n        \n        // Add to original chars to get final shift\n        vuint8m8_t v_result = vadd_vv_u8m8(v_input, v_shift, vl);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vl);\n        \n        i += vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_RVV", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= s.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&s[i], vlen);\n        \n        // Calculate shift amount (2 * 2 = 4)\n        vuint8m8_t v_shift = vmv_v_x_u8m8(4, vlen);\n        \n        // Add shift to each character\n        vuint8m8_t v_result = vadd_vv_u8m8(v_chars, v_shift, vlen);\n        \n        // Store result\n        vse8_v_u8m8((uint8_t*)&result[i], v_result, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < s.length(); i++) {\n        result[i] = s[i] + 4;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= message.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&message[i], vlen);\n        \n        // Create masks for different character ranges\n        vbool1_t v_lower_mask = vmsgtu_vx_u8m8_b1(v_chars, 96);\n        vbool1_t v_upper_mask = vmsgtu_vx_u8m8_b1(v_chars, 64);\n        vbool1_t v_letter_mask = vmsle_vx_u8m8_b1(v_chars, 122);\n        v_letter_mask = vand_mm_b1(v_letter_mask, vmsgtu_vx_u8m8_b1(v_chars, 64));\n        \n        // Swap case\n        vuint8m8_t v_case_swap = v_chars;\n        v_case_swap = vadd_vx_u8m8_m(v_lower_mask, v_case_swap, v_chars, -32);\n        v_case_swap = vadd_vx_u8m8_m(vand_mm_b1(v_upper_mask, vmsleu_vx_u8m8_b1(v_chars, 90)), \n                                    v_case_swap, v_chars, 32);\n        \n        // Create vowel mask\n        vbool1_t v_a_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 65);\n        vbool1_t v_e_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 69);\n        vbool1_t v_i_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 73);\n        vbool1_t v_o_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 79);\n        vbool1_t v_u_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 85);\n        \n        // Replace vowels\n        v_case_swap = vmerge_vxm_u8m8(v_a_mask, v_case_swap, 67);  // A->C\n        v_case_swap = vmerge_vxm_u8m8(v_e_mask, v_case_swap, 71);  // E->G\n        v_case_swap = vmerge_vxm_u8m8(v_i_mask, v_case_swap, 75);  // I->K\n        v_case_swap = vmerge_vxm_u8m8(v_o_mask, v_case_swap, 81);  // O->Q\n        v_case_swap = vmerge_vxm_u8m8(v_u_mask, v_case_swap, 87);  // U->W\n        \n        vse8_v_u8m8((uint8_t*)&result[i], v_case_swap, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < message.length(); i++) {\n        char c = message[i];\n        if (isalpha(c)) {\n            // Swap case\n            c = isupper(c) ? tolower(c) : toupper(c);\n            \n            // Replace vowels\n            c = toupper(c);\n            if (c == 'A') c = 'C';\n            else if (c == 'E') c = 'G';\n            else if (c == 'I') c = 'K';\n            else if (c == 'O') c = 'Q';\n            else if (c == 'U') c = 'W';\n            if (islower(message[i])) c = tolower(c);\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= message.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&message[i], vlen);\n        \n        // Create masks for different cases\n        vbool1_t v_upper_mask = vmsgtu_vx_u8m8_b1(v_chars, 64);\n        vbool1_t v_lower_mask = vmsgtu_vx_u8m8_b1(v_chars, 96);\n        \n        // Swap case\n        vuint8m8_t v_case_swapped = v_chars;\n        v_case_swapped = vadd_vx_u8m8_m(v_upper_mask, v_case_swapped, v_chars, 32);\n        v_case_swapped = vsub_vx_u8m8_m(v_lower_mask, v_case_swapped, v_chars, 32);\n        \n        // Create vowel masks\n        vbool1_t v_a_mask = vmseq_vx_u8m8_b1(v_chars, 'a') || vmseq_vx_u8m8_b1(v_chars, 'A');\n        vbool1_t v_e_mask = vmseq_vx_u8m8_b1(v_chars, 'e') || vmseq_vx_u8m8_b1(v_chars, 'E');\n        vbool1_t v_i_mask = vmseq_vx_u8m8_b1(v_chars, 'i') || vmseq_vx_u8m8_b1(v_chars, 'I');\n        vbool1_t v_o_mask = vmseq_vx_u8m8_b1(v_chars, 'o') || vmseq_vx_u8m8_b1(v_chars, 'O');\n        vbool1_t v_u_mask = vmseq_vx_u8m8_b1(v_chars, 'u') || vmseq_vx_u8m8_b1(v_chars, 'U');\n        \n        // Replace vowels\n        v_case_swapped = vmerge_vxm_u8m8(v_a_mask, v_case_swapped, 'C');\n        v_case_swapped = vmerge_vxm_u8m8(v_e_mask, v_case_swapped, 'G');\n        v_case_swapped = vmerge_vxm_u8m8(v_i_mask, v_case_swapped, 'K');\n        v_case_swapped = vmerge_vxm_u8m8(v_o_mask, v_case_swapped, 'Q');\n        v_case_swapped = vmerge_vxm_u8m8(v_u_mask, v_case_swapped, 'W');\n        \n        vse8_v_u8m8((uint8_t*)&result[i], v_case_swapped, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < message.length(); i++) {\n        char c = message[i];\n        if (std::isupper(c)) {\n            c = std::tolower(c);\n        } else if (std::islower(c)) {\n            c = std::toupper(c);\n        }\n        \n        switch(std::tolower(c)) {\n            case 'a': c = 'C'; break;\n            case 'e': c = 'G'; break;\n            case 'i': c = 'K'; break;\n            case 'o': c = 'Q'; break;\n            case 'u': c = 'W'; break;\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result(message);\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= message.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&message[i], vlen);\n        \n        // Create masks for different character ranges\n        vbool1_t v_lower_mask = vmsgtu_vx_u8m8_b1(v_chars, 96) && vmsleu_vx_u8m8_b1(v_chars, 122);\n        vbool1_t v_upper_mask = vmsgtu_vx_u8m8_b1(v_chars, 64) && vmsleu_vx_u8m8_b1(v_chars, 90);\n        \n        // Convert lowercase to uppercase\n        vuint8m8_t v_to_upper = vsub_vx_u8m8_m(v_lower_mask, v_chars, v_chars, 32);\n        \n        // Convert uppercase to lowercase\n        vuint8m8_t v_to_lower = vadd_vx_u8m8_m(v_upper_mask, v_chars, v_chars, 32);\n        \n        // Merge the case conversions\n        v_chars = vmerge_vvm_u8m8(v_lower_mask, v_chars, v_to_upper);\n        v_chars = vmerge_vvm_u8m8(v_upper_mask, v_chars, v_to_lower);\n        \n        // Handle vowels (a/A -> c/C, e/E -> g/G, i/I -> k/K, o/O -> q/Q, u/U -> w/W)\n        vbool1_t v_vowel_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, ~32), 65) || // A/a\n                               vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, ~32), 69) || // E/e\n                               vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, ~32), 73) || // I/i\n                               vmseq_vx_u8m8_b1(vand_vx_u8m8_v_chars, ~32), 79) || // O/o\n                               vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, ~32), 85);   // U/u\n                               \n        vuint8m8_t v_vowel_shift = vadd_vx_u8m8_m(v_vowel_mask, v_chars, v_chars, 2);\n        v_chars = vmerge_vvm_u8m8(v_vowel_mask, v_chars, v_vowel_shift);\n        \n        // Store results\n        vse8_v_u8m8((uint8_t*)&result[i], v_chars, vlen);\n    }\n    \n    // Handle remaining characters serially\n    for (; i < message.length(); i++) {\n        char c = message[i];\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n        \n        if (toupper(c) == 'A' || toupper(c) == 'E' || toupper(c) == 'I' || \n            toupper(c) == 'O' || toupper(c) == 'U') {\n            c = (c & ~32) | (c & 32); // Preserve case\n            c += 2;\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= message.length(); i += vlen) {\n        vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)&message[i], vlen);\n        \n        // Create masks for different character ranges\n        vbool1_t v_lower = __riscv_vmsgtu_vx_u8m8_b1(v_chars, 96, vlen) && \n                          __riscv_vmsleu_vx_u8m8_b1(v_chars, 122, vlen);\n        vbool1_t v_upper = __riscv_vmsgtu_vx_u8m8_b1(v_chars, 64, vlen) && \n                          __riscv_vmsleu_vx_u8m8_b1(v_chars, 90, vlen);\n        \n        // Convert to opposite case\n        vuint8m8_t v_case_converted = v_chars;\n        v_case_converted = __riscv_vsub_vx_u8m8_m(v_lower, v_case_converted, v_chars, 32, vlen);\n        v_case_converted = __riscv_vadd_vx_u8m8_m(v_upper, v_case_converted, v_chars, 32, vlen);\n        \n        // Create vowel masks (both lower and upper case)\n        vbool1_t v_vowels = __riscv_vmseq_vx_u8m8_b1(v_chars, 'a', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'e', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'i', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'o', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'u', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'A', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'E', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'I', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'O', vlen) ||\n                           __riscv_vmseq_vx_u8m8_b1(v_chars, 'U', vlen);\n        \n        // Replace vowels with char 2 places ahead\n        vuint8m8_t v_vowel_replaced = v_case_converted;\n        v_vowel_replaced = __riscv_vadd_vx_u8m8_m(v_vowels, v_vowel_replaced, v_case_converted, 2, vlen);\n        \n        __riscv_vse8_v_u8m8((uint8_t*)&result[i], v_vowel_replaced, vlen);\n    }\n    \n    // Handle remaining characters\n    for (; i < message.length(); i++) {\n        char c = message[i];\n        if (islower(c)) {\n            c = toupper(c);\n        } else if (isupper(c)) {\n            c = tolower(c);\n        }\n        \n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            c += 2;\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_RVV", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t vlen = vsetvlmax_e8m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= message.length(); i += vlen) {\n        vuint8m8_t v_chars = vle8_v_u8m8((uint8_t*)&message[i], vlen);\n        \n        // Create masks for different character ranges\n        vbool1_t v_lower_mask = vmsgtu_vx_u8m8_b1(v_chars, 96);\n        vbool1_t v_upper_mask = vmsgtu_vx_u8m8_b1(v_chars, 64);\n        vbool1_t v_letter_mask = vmsle_vx_u8m8_b1(v_chars, 122);\n        v_letter_mask = vand_mm_b1(v_letter_mask, vmsgtu_vx_u8m8_b1(v_chars, 64));\n        \n        // Swap case\n        vuint8m8_t v_case_swapped = v_chars;\n        v_case_swapped = vadd_vx_u8m8_m(v_lower_mask, v_case_swapped, v_chars, -32);\n        v_case_swapped = vadd_vx_u8m8_m(vand_mm_b1(v_upper_mask, vmsleu_vx_u8m8_b1(v_chars, 90)), \n                                       v_case_swapped, v_chars, 32);\n        \n        // Create vowel masks\n        vbool1_t v_a_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 65);\n        vbool1_t v_e_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 69);\n        vbool1_t v_i_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 73);\n        vbool1_t v_o_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 79);\n        vbool1_t v_u_mask = vmseq_vx_u8m8_b1(vand_vx_u8m8(v_chars, 0xDF), 85);\n        \n        // Replace vowels\n        v_case_swapped = vmerge_vxm_u8m8(v_a_mask, v_case_swapped, 'C');\n        v_case_swapped = vmerge_vxm_u8m8(v_e_mask, v_case_swapped, 'G');\n        v_case_swapped = vmerge_vxm_u8m8(v_i_mask, v_case_swapped, 'K');\n        v_case_swapped = vmerge_vxm_u8m8(v_o_mask, v_case_swapped, 'Q');\n        v_case_swapped = vmerge_vxm_u8m8(v_u_mask, v_case_swapped, 'W');\n        \n        vse8_v_u8m8((uint8_t*)&result[i], v_case_swapped, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < message.length(); i++) {\n        char c = message[i];\n        if (isalpha(c)) {\n            // Swap case\n            c = isupper(c) ? tolower(c) : toupper(c);\n            \n            // Replace vowels\n            char upper_c = toupper(c);\n            if (upper_c == 'A') c = 'C';\n            else if (upper_c == 'E') c = 'G';\n            else if (upper_c == 'I') c = 'K';\n            else if (upper_c == 'O') c = 'Q';\n            else if (upper_c == 'U') c = 'W';\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    bool all_upper = true;\n    bool all_lower = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        const char* str = key.c_str();\n        \n        for (size_t i = 0; i < len; i += vlen) {\n            size_t vl = __riscv_vsetvl_e8m8(len - i);\n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)str + i, vl);\n            \n            // Check if characters are alphabets\n            vuint8m8_t v_alpha = __riscv_vand_vx_u8m8(v_chars, 0x80, vl);\n            vbool1_t v_is_alpha = __riscv_vmseq_vx_u8m8_b1(v_alpha, 0, vl);\n            if (!__riscv_vmand_m_b1(v_is_alpha, vl)) {\n                return false;\n            }\n            \n            // Check for uppercase\n            vuint8m8_t v_upper = __riscv_vand_vx_u8m8(v_chars, 0x20, vl);\n            vbool1_t v_is_upper = __riscv_vmseq_vx_u8m8_b1(v_upper, 0, vl);\n            if (!__riscv_vmand_m_b1(v_is_upper, vl)) {\n                all_upper = false;\n            }\n            \n            // Check for lowercase\n            vbool1_t v_is_lower = __riscv_vmsne_vx_u8m8_b1(v_upper, 0, vl);\n            if (!__riscv_vmand_m_b1(v_is_lower, vl)) {\n                all_lower = false;\n            }\n            \n            if (!all_upper && !all_lower) {\n                return false;\n            }\n        }\n    }\n    \n    return all_upper || all_lower;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        const char* str = key.c_str();\n        \n        for (size_t i = 0; i < len; i += vlen) {\n            size_t vl = __riscv_vsetvl_e8m8(len - i);\n            vuint8m8_t v_str = __riscv_vle8_v_u8m8((uint8_t*)(str + i), vl);\n            \n            // Check if characters are alphabets\n            vuint8m8_t v_alpha = __riscv_vand_vx_u8m8(v_str, 0x80, vl);\n            vbool1_t v_not_alpha = __riscv_vmseq_vx_u8m8_b1(v_alpha, 0, vl);\n            if (!__riscv_vmand_mm_b1(v_not_alpha, v_not_alpha, vl)) {\n                return false;\n            }\n\n            // Check for lowercase\n            vuint8m8_t v_lower = __riscv_vand_vx_u8m8(v_str, 0x20, vl);\n            vbool1_t v_not_lower = __riscv_vmseq_vx_u8m8_b1(v_lower, 0, vl);\n            if (!__riscv_vmand_mm_b1(v_not_lower, v_not_lower, vl)) {\n                all_upper = false;\n            }\n\n            // Check for uppercase  \n            vbool1_t v_not_upper = __riscv_vmsne_vx_u8m8_b1(v_lower, 0x20, vl);\n            if (!__riscv_vmand_mm_b1(v_not_upper, v_not_upper, vl)) {\n                all_lower = false;\n            }\n\n            if (!all_lower && !all_upper) {\n                return false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        const char* str = key.c_str();\n        \n        for (size_t i = 0; i < len; i += vlen) {\n            size_t vl = __riscv_vsetvl_e8m8(len - i);\n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)(str + i), vl);\n            \n            // Check if any char is not lowercase\n            vuint8m8_t v_lower_mask = __riscv_vmslt_vx_u8m8_b8(v_chars, 'a', vl);\n            v_lower_mask = __riscv_vmor_mm_b8(v_lower_mask, \n                __riscv_vmsgt_vx_u8m8_b8(v_chars, 'z', vl), vl);\n            if (__riscv_vfirst_m_b8(v_lower_mask, vl) != -1) {\n                all_lower = false;\n            }\n            \n            // Check if any char is not uppercase\n            vuint8m8_t v_upper_mask = __riscv_vmslt_vx_u8m8_b8(v_chars, 'A', vl);\n            v_upper_mask = __riscv_vmor_mm_b8(v_upper_mask,\n                __riscv_vmsgt_vx_u8m8_b8(v_chars, 'Z', vl), vl);\n            if (__riscv_vfirst_m_b8(v_upper_mask, vl) != -1) {\n                all_upper = false;\n            }\n            \n            if (!all_lower && !all_upper) {\n                return false;\n            }\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        const char* str = key.c_str();\n        \n        for (size_t i = 0; i < len; i += vlen) {\n            size_t vl = __riscv_vsetvl_e8m8(len - i);\n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)(str + i), vl);\n            \n            // Check if any char is not alphabetic\n            vuint8m8_t v_alpha_mask = __riscv_vand_vx_u8m8(v_chars, 0x80, vl);\n            if (__riscv_vfirst_m_b8(v_alpha_mask, vl) != -1) {\n                return false;\n            }\n            \n            // Check for lowercase\n            vuint8m8_t v_lower_mask = __riscv_vmslt_vx_u8m8_b8(v_chars, 'a', vl);\n            vuint8m8_t v_lower_mask2 = __riscv_vmsgt_vx_u8m8_b8(v_chars, 'z', vl);\n            vuint8m8_t v_lower = __riscv_vmor_mm_b8(v_lower_mask, v_lower_mask2, vl);\n            if (__riscv_vfirst_m_b8(v_lower, vl) != -1) {\n                all_lower = false;\n            }\n            \n            // Check for uppercase  \n            vuint8m8_t v_upper_mask = __riscv_vmslt_vx_u8m8_b8(v_chars, 'A', vl);\n            vuint8m8_t v_upper_mask2 = __riscv_vmsgt_vx_u8m8_b8(v_chars, 'Z', vl);\n            vuint8m8_t v_upper = __riscv_vmor_mm_b8(v_upper_mask, v_upper_mask2, vl);\n            if (__riscv_vfirst_m_b8(v_upper, vl) != -1) {\n                all_upper = false;\n            }\n            \n            if (!all_lower && !all_upper) {\n                return false;\n            }\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_RVV", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        size_t len = key.length();\n        const char* str = key.c_str();\n        \n        for (size_t i = 0; i < len; i += vlen) {\n            size_t vl = __riscv_vsetvl_e8m8(len - i);\n            vuint8m8_t v_str = __riscv_vle8_v_u8m8((uint8_t*)(str + i), vl);\n            \n            // Check if characters are alphabets\n            vuint8m8_t v_alpha = __riscv_vand_vx_u8m8(v_str, 0x80, vl);\n            vbool1_t non_alpha_mask = __riscv_vmsne_vx_u8m8_b1(v_alpha, 0, vl);\n            if (__riscv_vfirst_m_b1(non_alpha_mask, vl) != -1) {\n                return false;\n            }\n            \n            // Check for lowercase\n            vuint8m8_t v_lower = __riscv_vand_vx_u8m8(v_str, 0x20, vl);\n            vbool1_t not_lower_mask = __riscv_vmseq_vx_u8m8_b1(v_lower, 0, vl);\n            if (__riscv_vfirst_m_b1(not_lower_mask, vl) != -1) {\n                all_lower = false;\n            }\n            \n            // Check for uppercase\n            vbool1_t not_upper_mask = __riscv_vmsne_vx_u8m8_b1(v_lower, 0x20, vl);\n            if (__riscv_vfirst_m_b1(not_upper_mask, vl) != -1) {\n                all_upper = false;\n            }\n            \n            if (!all_lower && !all_upper) {\n                return false;\n            }\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    size_t vl;\n    vint32m8_t vid;\n    \n    // Mark non-prime numbers\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            // Get maximum vector length\n            vl = vsetvl_e32m8(n - i * i);\n            \n            while (vl > 0) {\n                // Generate vector of indices\n                vid = vid_v_i32m8(0, vl);\n                \n                // Calculate multiples\n                vint32m8_t multiples = vmul_vx_i32m8(vid, i, vl);\n                multiples = vadd_vx_i32m8(multiples, i * i, vl);\n                \n                // Mark indices that are multiples as non-prime\n                vbool4_t mask = vmsltu_vx_i32m8_b4(multiples, n, vl);\n                vint32m8_t indices = multiples;\n                \n                // Set non-prime flags\n                for (size_t j = 0; j < vl; j++) {\n                    if (mask.val[j] && indices.v[j] < n) {\n                        is_prime[indices.v[j]] = false;\n                    }\n                }\n                \n                vl = vsetvl_e32m8(n - i * i - vl);\n            }\n        }\n    }\n\n    // Collect prime numbers\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    size_t vl;\n    vint32m8_t vid;\n    \n    // Mark non-prime numbers\n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n        \n        // Get maximum vector length\n        vl = vsetvl_e32m8(n - i * i);\n        \n        while (vl > 0) {\n            // Generate vector of indices\n            vid = vid_v_i32m8(0, vl);\n            \n            // Calculate actual indices for marking\n            vint32m8_t indices = vmul_vx_i32m8(vid, i, vl);\n            indices = vadd_vx_i32m8(indices, i * i, vl);\n            \n            // Mark numbers as non-prime where indices are in range\n            vbool4_t mask = vmsltu_vx_i32m8_b4(indices, n, vl);\n            vint32m8_t offsets = vsub_vx_i32m8(indices, 0, vl);\n            \n            // Store false for non-prime numbers\n            vsse8_v_u8m2_m(mask, &is_prime[0], sizeof(bool), \n                          vmv_v_x_u8m2(0, vl), vl);\n            \n            // Move to next set of numbers\n            vl = vsetvl_e32m8(n - (i * i + i * vl));\n        }\n    }\n\n    // Collect prime numbers\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n    \n    size_t vlen = vsetvlmax_e8m8();\n    \n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n        \n        int j = i * i;\n        while (j < n) {\n            size_t vl = vsetvl_e8m8(n - j);\n            vint8m8_t vid = vid_v_i8m8(vl);\n            vbool1_t vmask = vmseq_vx_i8m8_b1(vid, 0, vl);\n            \n            vbool1_t vfalse = vmclr_m_b1(vl);\n            vbool1_t result = vmerge_vvm_b1(vmask, vfalse, vmask, vl);\n            \n            for (size_t k = 0; k < vl; k++) {\n                if (j + k < n) {\n                    is_prime[j + k] = false;\n                }\n            }\n            \n            j += vl;\n        }\n    }\n    \n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    size_t vl;\n    vint32m8_t vid;\n    \n    // Mark non-prime numbers\n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n        \n        // Get maximum vector length\n        vl = vsetvl_e32m8(n - i * i);\n        \n        while (vl > 0) {\n            // Generate vector of indices\n            vid = vid_v_i32m8(0, vl);\n            \n            // Calculate actual indices for marking\n            vint32m8_t indices = vmul_vx_i32m8(vid, i, vl);\n            indices = vadd_vx_i32m8(indices, i * i, vl);\n            \n            // Mark numbers that are multiples\n            for (size_t j = 0; j < vl; j++) {\n                int idx = i * i + j * i;\n                if (idx < n) {\n                    is_prime[idx] = false;\n                }\n            }\n            \n            vl = vsetvl_e32m8(n - (i * i + vl * i));\n        }\n    }\n\n    // Collect prime numbers\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_RVV", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    size_t vl;\n    vint32m8_t vid;\n    \n    // Mark non-prime numbers\n    for (int i = 2; i * i < n; i++) {\n        if (!is_prime[i]) continue;\n        \n        // Get maximum vector length\n        vl = vsetvl_e32m8(n - i * i);\n        \n        while (vl > 0) {\n            // Generate vector of indices\n            vid = vid_v_i32m8(0, vl);\n            \n            // Calculate actual indices for marking\n            vint32m8_t indices = vmul_vx_i32m8(vid, i, vl);\n            indices = vadd_vx_i32m8(indices, i * i, vl);\n            \n            // Mark numbers as non-prime where indices are in range\n            vbool4_t mask = vmsltu_vx_i32m8_b4(indices, n, vl);\n            vint8m2_t v_false = vmv_v_x_i8m2(0, vl);\n            \n            // Store results\n            vsse8_v_i8m2_m(mask, &is_prime[i * i], i * sizeof(bool), v_false, vl);\n            \n            // Move to next chunk\n            vl = vsetvl_e32m8(n - i * i - vl * i);\n        }\n    }\n\n    // Collect prime numbers\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    size_t vlen = vsetvlmax_e8m1();\n    size_t n = s.length();\n    size_t count = 0;\n    const uint8_t* str = (const uint8_t*)s.c_str();\n    \n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e8m1(n - i);\n        \n        vuint8m1_t v_str = vle8_v_u8m1(str + i, vl);\n        \n        // Create mask for even indices\n        vbool8_t even_mask = vmseq_vx_u8m1_b8(vand_vx_u8m1(vid_v_u8m1(vl, vl), 1, vl), 0, vl);\n        \n        // Check for uppercase vowels (A,E,I,O,U)\n        vbool8_t is_A = vmseq_vx_u8m1_b8(v_str, 'A', vl);\n        vbool8_t is_E = vmseq_vx_u8m1_b8(v_str, 'E', vl);\n        vbool8_t is_I = vmseq_vx_u8m1_b8(v_str, 'I', vl);\n        vbool8_t is_O = vmseq_vx_u8m1_b8(v_str, 'O', vl);\n        vbool8_t is_U = vmseq_vx_u8m1_b8(v_str, 'U', vl);\n        \n        // Combine vowel checks\n        vbool8_t is_vowel = vmor_mm_b8(vmor_mm_b8(vmor_mm_b8(vmor_mm_b8(is_A, is_E, vl), is_I, vl), is_O, vl), is_U, vl);\n        \n        // Final mask combining even indices and vowels\n        vbool8_t final_mask = vmand_mm_b8(even_mask, is_vowel, vl);\n        \n        // Count matches\n        count += vcpop_m_b8(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    size_t vl;\n    size_t count = 0;\n    size_t str_len = s.length();\n    const uint8_t* str = (const uint8_t*)s.c_str();\n    \n    vint8m1_t v_vowels = __riscv_vmv_v_x_i8m1('A', 1);\n    vbool8_t v_mask_A = __riscv_vmseq_vx_i8m1_b8(v_vowels, 'A', 1);\n    v_vowels = __riscv_vmv_v_x_i8m1('E', 1);\n    vbool8_t v_mask_E = __riscv_vmseq_vx_i8m1_b8(v_vowels, 'E', 1);\n    v_vowels = __riscv_vmv_v_x_i8m1('I', 1);\n    vbool8_t v_mask_I = __riscv_vmseq_vx_i8m1_b8(v_vowels, 'I', 1);\n    v_vowels = __riscv_vmv_v_x_i8m1('O', 1);\n    vbool8_t v_mask_O = __riscv_vmseq_vx_i8m1_b8(v_vowels, 'O', 1);\n    v_vowels = __riscv_vmv_v_x_i8m1('U', 1);\n    vbool8_t v_mask_U = __riscv_vmseq_vx_i8m1_b8(v_vowels, 'U', 1);\n\n    for (size_t i = 0; i < str_len; i += vl) {\n        vl = __riscv_vsetvl_e8m1(str_len - i);\n        vint8m1_t v_str = __riscv_vle8_v_i8m1(str + i, vl);\n        \n        vbool8_t v_is_vowel = __riscv_vmor_mm_b8(\n            __riscv_vmor_mm_b8(\n                __riscv_vmor_mm_b8(\n                    __riscv_vmor_mm_b8(v_mask_A, v_mask_E, vl),\n                    v_mask_I, vl),\n                v_mask_O, vl),\n            v_mask_U, vl);\n            \n        vint8m1_t v_even_indices = __riscv_vid_v_i8m1(vl);\n        vbool8_t v_is_even = __riscv_vmseq_vx_i8m1_b8(__riscv_vand_vx_i8m1(v_even_indices, 1, vl), 0, vl);\n        \n        vbool8_t v_is_upper = __riscv_vmsgtu_vx_i8m1_b8(v_str, 64, vl);\n        v_is_upper = __riscv_vmslt_vx_i8m1_b8(v_str, 91, vl);\n        \n        vbool8_t v_final_mask = __riscv_vmand_mm_b8(\n            __riscv_vmand_mm_b8(v_is_vowel, v_is_even, vl),\n            v_is_upper, vl);\n            \n        count += __riscv_vcpop_m_b8(v_final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    size_t vl;\n    size_t count = 0;\n    size_t str_len = s.length();\n    const uint8_t* str = (const uint8_t*)s.c_str();\n    \n    vint8m1_t v_vowels, v_str;\n    vbool8_t v_mask, v_even_mask, v_vowel_mask, v_upper_mask;\n    \n    for (size_t i = 0; i < str_len; i += vl) {\n        vl = vsetvl_e8m1(str_len - i);\n        \n        // Load string characters\n        v_str = vle8_v_i8m1(str + i, vl);\n        \n        // Create mask for even indices\n        v_even_mask = vmseq_vx_i8m1_b8(vseq_vx_i8m1(0, vl), 0, vl);\n        \n        // Create mask for uppercase letters (A-Z)\n        v_upper_mask = vand_vx_i8m1_b8(\n            vmsge_vx_i8m1_b8(v_str, 'A', vl),\n            vmsle_vx_i8m1_b8(v_str, 'Z', vl),\n            vl\n        );\n        \n        // Create mask for vowels (A,E,I,O,U)\n        v_vowel_mask = vmor_mm_b8(\n            vmor_mm_b8(\n                vmor_mm_b8(\n                    vmeq_vx_i8m1_b8(v_str, 'A', vl),\n                    vmeq_vx_i8m1_b8(v_str, 'E', vl),\n                    vl\n                ),\n                vmor_mm_b8(\n                    vmeq_vx_i8m1_b8(v_str, 'I', vl),\n                    vmeq_vx_i8m1_b8(v_str, 'O', vl),\n                    vl\n                ),\n                vl\n            ),\n            vmeq_vx_i8m1_b8(v_str, 'U', vl),\n            vl\n        );\n        \n        // Combine all masks\n        v_mask = vand_mm_b8(\n            vand_mm_b8(v_even_mask, v_upper_mask, vl),\n            v_vowel_mask,\n            vl\n        );\n        \n        // Count matches\n        count += vcpop_m_b8(v_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    size_t vl;\n    size_t count = 0;\n    size_t str_len = s.length();\n    const uint8_t* str = (const uint8_t*)s.c_str();\n    \n    vint8m1_t v_vowels, v_str;\n    vbool8_t v_mask, v_even_mask, v_upper_mask, v_vowel_mask;\n    \n    for (size_t i = 0; i < str_len; i += vl) {\n        vl = vsetvl_e8m1(str_len - i);\n        \n        // Load string characters\n        v_str = vle8_v_i8m1(str + i, vl);\n        \n        // Create mask for even indices\n        v_even_mask = vmseq_vx_i8m1_b8(vslide1up_vx_i8m1(vid_v_i8m1(vl, vl), 0, vl), 0, vl);\n        \n        // Check for uppercase letters (A-Z)\n        v_upper_mask = vand_mm_b8(\n            vmsleu_vx_i8m1_b8(v_str, 'Z', vl),\n            vmsge_vx_i8m1_b8(v_str, 'A', vl)\n        );\n        \n        // Check for vowels (A,E,I,O,U)\n        v_vowel_mask = vmseq_vx_i8m1_b8(v_str, 'A', vl);\n        v_mask = vmor_mm_b8(v_vowel_mask, vmseq_vx_i8m1_b8(v_str, 'E', vl), vl);\n        v_mask = vmor_mm_b8(v_mask, vmseq_vx_i8m1_b8(v_str, 'I', vl), vl);\n        v_mask = vmor_mm_b8(v_mask, vmseq_vx_i8m1_b8(v_str, 'O', vl), vl);\n        v_mask = vmor_mm_b8(v_mask, vmseq_vx_i8m1_b8(v_str, 'U', vl), vl);\n        \n        // Combine masks for even indices, uppercase and vowels\n        v_mask = vand_mm_b8(v_even_mask, vand_mm_b8(v_upper_mask, v_mask, vl), vl);\n        \n        // Count matches\n        count += vcpop_m_b8(v_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_RVV", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    size_t vl;\n    size_t count = 0;\n    size_t str_len = s.length();\n    const char* str = s.c_str();\n    \n    vint8m1_t v_str, v_mask;\n    vbool8_t v_vowels, v_upper, v_even, v_result;\n    \n    for (size_t i = 0; i < str_len; i += vl) {\n        vl = vsetvl_e8m1(str_len - i);\n        \n        // Load string characters\n        v_str = vle8_v_i8m1((int8_t*)str + i, vl);\n        \n        // Create even indices mask\n        v_mask = vid_v_i8m1(vl);\n        v_even = vmseq_vx_i8m1_b8(v_mask, 0, vl);\n        \n        // Check for uppercase letters (ASCII 65-90)\n        v_upper = vmge_vx_i8m1_b8(v_str, 65, vl);\n        v_upper = vmand_mm_b8(v_upper, vmle_vx_i8m1_b8(v_str, 90, vl), vl);\n        \n        // Check for vowels (A,E,I,O,U)\n        v_vowels = vmseq_vx_i8m1_b8(v_str, 'A', vl);\n        v_vowels = vmor_mm_b8(v_vowels, vmseq_vx_i8m1_b8(v_str, 'E', vl), vl);\n        v_vowels = vmor_mm_b8(v_vowels, vmseq_vx_i8m1_b8(v_str, 'I', vl), vl);\n        v_vowels = vmor_mm_b8(v_vowels, vmseq_vx_i8m1_b8(v_str, 'O', vl), vl);\n        v_vowels = vmor_mm_b8(v_vowels, vmseq_vx_i8m1_b8(v_str, 'U', vl), vl);\n        \n        // Combine conditions\n        v_result = vmand_mm_b8(v_even, vmand_mm_b8(v_upper, v_vowels, vl), vl);\n        \n        // Count matches\n        count += vcpop_m_b8(v_result, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    size_t vl;\n    vint32m1_t v_idx, v_vals;\n    \n    // Get vector length\n    vl = vsetvl_e32m1(n-1);\n    \n    // Create vector of indices starting from 1\n    v_idx = vid_v_i32m1(vl);\n    v_idx = vadd_vx_i32m1(v_idx, 1, vl);\n    \n    // Multiply indices by 2 to get step size\n    v_vals = vmul_vx_i32m1(v_idx, 2, vl);\n    \n    // Add base value to get final values\n    v_vals = vadd_vx_i32m1(v_vals, n, vl);\n    \n    // Store results\n    vse32_v_i32m1(&result[1], v_vals, vl);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    size_t vl;\n    vint32m1_t v_idx, v_val;\n    \n    // Initialize first value\n    int start = n;\n    if (n % 2 == 0) {\n        start += 2;\n    } else {\n        start += 1;\n    }\n    \n    for (size_t i = 1; i < n; i += vl) {\n        // Get vector length\n        vl = vsetvl_e32m1(n - i);\n        \n        // Create index vector\n        v_idx = vid_v_i32m1(vl);\n        \n        // Add offset to index\n        v_idx = vadd_vx_i32m1(v_idx, i, vl);\n        \n        // Multiply by 2 to get step size\n        v_val = vmul_vx_i32m1(v_idx, 2, vl);\n        \n        // Add start value\n        v_val = vadd_vx_i32m1(v_val, start-2, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], v_val, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    size_t vl;\n    vint32m1_t v_idx, v_vals;\n    \n    // Get maximum vector length for 32-bit integers\n    vl = vsetvlmax_e32m1();\n    \n    for (size_t i = 0; i < n-1; i += vl) {\n        // Adjust vector length for remaining elements\n        vl = vsetvl_e32m1(n-1-i);\n        \n        // Create vector of indices\n        v_idx = vid_v_i32m1(vl);\n        \n        // Add offset to indices\n        v_idx = vadd_vx_i32m1(v_idx, i+1, vl);\n        \n        // Load previous values\n        v_vals = vle32_v_i32m1(&result[i], vl);\n        \n        // Add 2 to each value\n        v_vals = vadd_vx_i32m1(v_vals, 2, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i+1], v_vals, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    size_t vl;\n    vint32m1_t v_indices, v_values;\n    \n    // Initialize vector with indices 1 to n-1\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        v_indices = vid_v_i32m1(vl);\n        v_indices = vadd_vx_i32m1(v_indices, i, vl);\n        \n        // Get previous values\n        v_values = vle32_v_i32m1(&result[i-1], vl);\n        \n        // Add 2 to get next number in sequence\n        v_values = vadd_vx_i32m1(v_values, 2, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], v_values, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_RVV", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    size_t vl;\n    vint32m1_t vec_idx, vec_val;\n    \n    // Initialize vector with indices 1,2,3,...\n    for (size_t i = 1; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vec_idx = vid_v_i32m1(vl);\n        vec_idx = vadd_vx_i32m1(vec_idx, i, vl);\n        \n        // Get previous value\n        int prev = result[i-1];\n        \n        // Calculate next value based on previous value being odd/even\n        if (prev % 2 == 0) {\n            // Previous was even, next should be even\n            vec_val = vmul_vx_i32m1(vec_idx, 2, vl);\n        } else {\n            // Previous was odd, next should be odd  \n            vec_val = vmul_vx_i32m1(vec_idx, 2, vl);\n            vec_val = vadd_vx_i32m1(vec_val, -1, vl);\n        }\n        \n        // Store results\n        vse32_v_i32m1(&result[i], vec_val, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    size_t vlen = vsetvlmax_e64m8();\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n    \n    while (n <= m) {\n        size_t vl = vsetvl_e64m8(m - n + 1);\n        vint64m8_t vec;\n        \n        // Generate sequence from n to n+vl-1\n        vec = vid_v_i64m8(vl);\n        vec = vadd_vx_i64m8(vec, n, vl);\n        \n        // Sum the vector elements\n        sum += vredsum_vs_i64m8_i64m8(vzero_i64m8(vl), vec, vzero_i64m8(vl), vl);\n        \n        n += vl;\n    }\n    \n    // Calculate average and round down\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg & 1 ? \"1\" : \"0\") + result;\n        avg >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    size_t vlen = vsetvlmax_e64m8();\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n    \n    while (n <= m) {\n        size_t vl = vsetvl_e64m8(m - n + 1);\n        \n        vint64m8_t vec_nums;\n        vint64m8_t vec_seq = vid_v_i64m8(vl);\n        vec_nums = vadd_vx_i64m8(vec_seq, n, vl);\n        \n        vint64m1_t vec_sum = vredsum_vs_i64m8_i64m1(vec_nums, vec_nums, vl);\n        sum += vmv_x_s_i64m1_i64(vec_sum);\n        \n        n += vl;\n    }\n    \n    int64_t avg = sum / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    size_t vlen = vsetvlmax_e64m8();\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n    \n    // Initialize vector with sequence n, n+1, n+2, ...\n    vint64m8_t vec_seq;\n    int64_t start = n;\n    \n    while (count > 0) {\n        size_t vl = vsetvl_e64m8(count);\n        vec_seq = vid_v_i64m8(vl);\n        vec_seq = vadd_vx_i64m8(vec_seq, start, vl);\n        \n        // Sum the vector elements\n        sum += vredsum_vs_i64m8_i64m1(vzero_i64m1(1), vec_seq, vzero_i64m1(1), vl);\n        \n        start += vl;\n        count -= vl;\n    }\n    \n    // Calculate average and round down\n    int64_t avg = sum / (m - n + 1);\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg & 1 ? '1' : '0') + result;\n        avg >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    size_t vlen = vsetvlmax_e64m8();\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    \n    vint64m8_t v_sum = vmv_v_x_i64m8(0, vlen);\n    \n    for (int64_t i = n; i <= m; i += vlen) {\n        size_t avl = (m - i + 1) < vlen ? (m - i + 1) : vlen;\n        vint64m8_t v_idx = vadd_vx_i64m8(vid_v_i64m8(avl), i, avl);\n        v_sum = vadd_vv_i64m8(v_sum, v_idx, avl);\n    }\n    \n    sum = vredsum_vs_i64m8_i64m1(v_sum, v_sum, vlen);\n    int64_t avg = sum / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg % 2 ? \"1\" : \"0\") + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_RVV", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    size_t vlen = vsetvlmax_e64m8();\n    vint64m8_t vec_sum = vmv_v_x_i64m8(0, vlen);\n    vint64m8_t vec_count = vmv_v_x_i64m8(0, vlen);\n    \n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n    \n    // Process elements in vector chunks\n    for (int64_t i = n; i <= m; i += vlen) {\n        size_t vl = vsetvl_e64m8(m - i + 1);\n        vint64m8_t vec_nums = vid_v_i64m8(vl);\n        vec_nums = vadd_vx_i64m8(vec_nums, i, vl);\n        \n        // Accumulate sum\n        vec_sum = vadd_vv_i64m8(vec_sum, vec_nums, vl);\n    }\n    \n    // Reduce vector sum\n    sum = vredsum_vs_i64m8_i64m1(vec_sum, vec_sum, vlen);\n    \n    // Calculate average and round down\n    int64_t avg = sum / count;\n    \n    // Convert to binary string\n    if (avg == 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg % 2 ? \"1\" : \"0\") + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    size_t vl;\n    vint32m1_t v_idx, v_fact, v_sum, v_mask;\n    vint32m1_t v_one = vmv_v_x_i32m1(1, n);\n    vint32m1_t v_mod = vmv_v_x_i32m1(10000, n);\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Generate indices starting from i+1\n        v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i + 1, vl);\n        \n        // Initialize factorial and sum accumulators\n        v_fact = vmv_v_x_i32m1(1, vl);\n        v_sum = vmv_v_x_i32m1(0, vl);\n        \n        // Calculate factorial and sum for each index\n        for (int j = 1; j <= n; j++) {\n            // Update factorial (only for indices >= j)\n            vbool32_t fact_mask = vmsle_vx_i32m1_b32(v_idx, j, vl);\n            v_fact = vmul_vx_i32m1_m(fact_mask, v_fact, v_fact, j, vl);\n            v_fact = vrem_vx_i32m1(v_fact, 10000, vl);\n            \n            // Update sum (only for indices >= j)\n            vbool32_t sum_mask = vmsle_vx_i32m1_b32(v_idx, j, vl);\n            v_sum = vadd_vx_i32m1_m(sum_mask, v_sum, v_sum, j, vl);\n        }\n        \n        // Create mask for even/odd indices\n        v_mask = vand_vx_i32m1(v_idx, 1, vl);\n        vbool32_t even_mask = vmseq_vx_i32m1_b32(v_mask, 0, vl);\n        \n        // Select factorial for even indices, sum for odd indices\n        vint32m1_t v_result = vmerge_vvm_i32m1(even_mask, v_sum, v_fact, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    size_t vl;\n    vint32m1_t v_indices, v_values;\n    vbool32_t vmask;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Generate indices starting from i+1\n        v_indices = vid_v_i32m1(vl);\n        v_indices = vadd_vx_i32m1(v_indices, i + 1, vl);\n        \n        // Check if indices are even\n        vmask = vmslt_vx_i32m1_b32(vand_vx_i32m1(v_indices, 1, vl), 1, vl);\n        \n        // For even indices: calculate factorial\n        vint32m1_t v_fact = vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= n; j++) {\n            vbool32_t vcmp = vmsle_vx_i32m1_b32(v_indices, j, vl);\n            v_fact = vmerge_vvm_i32m1(vcmp, v_fact, \n                                     vmul_vx_i32m1_m(vcmp, v_fact, v_fact, j, vl), vl);\n            // Keep values within mod 10000\n            v_fact = vrem_vx_i32m1(v_fact, 10000, vl);\n        }\n        \n        // For odd indices: calculate sum\n        vint32m1_t v_sum = vmv_v_x_i32m1(0, vl);\n        for (int j = 1; j <= n; j++) {\n            vbool32_t vcmp = vmsle_vx_i32m1_b32(v_indices, j, vl);\n            v_sum = vadd_vx_i32m1_m(vcmp, v_sum, v_sum, j, vl);\n        }\n        \n        // Merge results based on even/odd mask\n        v_values = vmerge_vvm_i32m1(vmask, v_sum, v_fact, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], v_values, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    size_t vl;\n    \n    // Initialize indices vector\n    vint32m1_t indices;\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        indices = vid_v_i32m1(vl);\n        indices = vadd_vx_i32m1(indices, i + 1, vl);\n        \n        // Calculate factorial for even indices\n        vint32m1_t fact = vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= n; j++) {\n            vbool32_t mask = vmseq_vx_i32m1_b32(indices, j, vl);\n            fact = vmerge_vxm_i32m1(mask, fact, j, vl);\n        }\n        \n        // Calculate sum for odd indices\n        vint32m1_t sum = vmul_vx_i32m1(indices, (indices + 1), vl);\n        sum = vsrl_vx_i32m1(sum, 1, vl);\n        \n        // Select between factorial and sum based on even/odd\n        vbool32_t even_mask = vmsgt_vx_i32m1_b32(indices, 0, vl);\n        even_mask = vmxor_mm_b32(even_mask, vmand_mm_b32(even_mask, even_mask, vl), vl);\n        \n        vint32m1_t final = vmerge_vvm_i32m1(even_mask, sum, fact, vl);\n        \n        // Apply modulo 10000 to factorial results\n        final = vrem_vx_i32m1(final, 10000, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], final, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    size_t vl;\n    vint32m1_t v_idx, v_ones, v_mask;\n    vint32m1_t v_result;\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Generate indices starting from i+1\n        v_idx = vid_v_i32m1(vl);\n        v_ones = vmv_v_x_i32m1(1, vl);\n        v_idx = vadd_vx_i32m1(v_idx, i + 1, vl);\n        \n        // Create mask for even/odd indices\n        v_mask = vand_vx_i32m1(v_idx, 1, vl);\n        v_mask = vmseq_vx_i32m1_b32(v_mask, 0, vl);\n        \n        // Calculate factorial for even indices\n        vint32m1_t v_fact = vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= n; j++) {\n            vint32m1_t v_j = vmv_v_x_i32m1(j, vl);\n            vbool32_t v_mask_j = vmsleu_vx_i32m1_b32(v_j, v_idx, vl);\n            v_fact = vmerge_vvm_i32m1(v_mask_j, v_fact, \n                                     vmul_vx_i32m1(v_fact, j, vl), vl);\n            v_fact = vrem_vx_i32m1(v_fact, 10000, vl);\n        }\n        \n        // Calculate sum for odd indices\n        vint32m1_t v_sum = vmv_v_x_i32m1(0, vl);\n        for (int j = 1; j <= n; j++) {\n            vint32m1_t v_j = vmv_v_x_i32m1(j, vl);\n            vbool32_t v_mask_j = vmsleu_vx_i32m1_b32(v_j, v_idx, vl);\n            v_sum = vmerge_vvm_i32m1(v_mask_j, v_sum,\n                                    vadd_vx_i32m1(v_sum, j, vl), vl);\n        }\n        \n        // Select factorial or sum based on even/odd mask\n        v_result = vmerge_vvm_i32m1(v_mask, v_sum, v_fact, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_RVV", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    size_t vl;\n    vint32m1_t v_idx, v_mask;\n    vint32m1_t v_ones = vmv_v_x_i32m1(1, n);\n    vint32m1_t v_result;\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Generate indices starting from i+1\n        v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i + 1, vl);\n        \n        // Create mask for even/odd indices\n        v_mask = vand_vx_i32m1(v_idx, 1, vl);\n        v_mask = vmseq_vx_i32m1_b32(v_mask, 0, vl);\n        \n        // Calculate factorial for even indices\n        vint32m1_t v_fact = vmv_v_x_i32m1(1, vl);\n        for (int j = 1; j <= n; j++) {\n            vbool32_t v_less = vmsle_vx_i32m1_b32(v_idx, j, vl);\n            v_fact = vmerge_vvm_i32m1(v_less, v_fact,\n                                     vmul_vx_i32m1_m(v_less, v_fact, v_fact, j, vl), vl);\n            v_fact = vrem_vx_i32m1(v_fact, 10000, vl);\n        }\n        \n        // Calculate sum for odd indices\n        vint32m1_t v_sum = vmv_v_x_i32m1(0, vl);\n        for (int j = 1; j <= n; j++) {\n            vbool32_t v_less = vmsle_vx_i32m1_b32(v_idx, j, vl);\n            v_sum = vadd_vx_i32m1_m(v_less, v_sum, v_sum, j, vl);\n        }\n        \n        // Select factorial or sum based on mask\n        v_result = vmerge_vvm_i32m1(v_mask, v_sum, v_fact, vl);\n        \n        // Store results\n        vse32_v_i32m1(&result[i], v_result, vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    size_t vl;\n    \n    // Create vectors to store numbers and results\n    vint32m1_t v_nums, v_rev;\n    vbool32_t v_mask;\n    \n    // Process numbers in chunks\n    for(int i = 1; i <= n; i += vl) {\n        // Set vector length\n        vl = vsetvl_e32m1(n - i + 1);\n        \n        // Generate sequence of numbers\n        v_nums = vid_v_i32m1(vl);\n        v_nums = vadd_vx_i32m1(v_nums, i, vl);\n        \n        // For each number, check if it's a palindrome\n        for(size_t j = 0; j < vl; j++) {\n            int num = i + j;\n            if(num > n) break;\n            \n            // Convert to palindrome check\n            int rev = 0;\n            int temp = num;\n            while(temp > 0) {\n                rev = rev * 10 + temp % 10;\n                temp /= 10;\n            }\n            \n            if(num == rev) {\n                // Increment even/odd count\n                result[num % 2]++;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Create vector of sequential integers from 1 to n\n    std::vector<int> nums(n);\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t vid = vadd_vx_i32m8(vid_v_i32m8(vl), i + 1, vl);\n        vse32_v_i32m8(&nums[i], vid, vl);\n    }\n\n    // Check palindromes in parallel\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_nums = vle32_v_i32m8(&nums[i], vl);\n        \n        // Convert numbers to strings to check palindromes\n        vbool4_t palindrome_mask = vmclr_m_b4(vl);\n        \n        for (size_t j = i; j < i + vl; j++) {\n            std::string num_str = std::to_string(nums[j]);\n            int left = 0, right = num_str.length() - 1;\n            bool is_palindrome = true;\n            \n            while (left < right) {\n                if (num_str[left] != num_str[right]) {\n                    is_palindrome = false;\n                    break;\n                }\n                left++;\n                right--;\n            }\n            \n            if (is_palindrome) {\n                palindrome_mask = vset_v_b4_i32m8(palindrome_mask, j - i);\n            }\n        }\n        \n        // Count even/odd palindromes\n        vint32m8_t v_even_mask = vand_vx_i32m8_m(palindrome_mask, v_nums, 1, vl);\n        vint32m8_t v_ones = vmv_v_x_i32m8(1, vl);\n        \n        // Add to even count where num % 2 == 0\n        vbool4_t even_mask = vmseq_vx_i32m8_b4(v_even_mask, 0, vl);\n        result[0] += vcpop_m_b4(even_mask, vl);\n        \n        // Add to odd count where num % 2 == 1 \n        vbool4_t odd_mask = vmsne_vx_i32m8_b4(v_even_mask, 0, vl);\n        result[1] += vcpop_m_b4(odd_mask, vl);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    size_t vl;\n    \n    // Initialize vectors for processing numbers in parallel\n    vint32m1_t v_nums, v_temp, v_rev;\n    vbool32_t v_mask;\n    \n    // Process numbers in chunks of vector length\n    for (int i = 1; i <= n; i += vl) {\n        // Set vector length for this iteration\n        vl = vsetvl_e32m1(n - i + 1);\n        \n        // Generate vector of consecutive numbers\n        v_nums = vid_v_i32m1(vl);\n        v_nums = vadd_vx_i32m1(v_nums, i, vl);\n        \n        // Initialize reverse number calculation\n        v_rev = vmv_v_x_i32m1(0, vl);\n        v_temp = vmv_v_v_i32m1(v_nums, vl);\n        \n        // Reverse digits\n        while (vmax_vs_i32m1_i32m1(v_temp, vl) > 0) {\n            v_rev = vmul_vx_i32m1(v_rev, 10, vl);\n            v_rev = vadd_vv_i32m1(v_rev, vrem_vx_i32m1(v_temp, 10, vl), vl);\n            v_temp = vdiv_vx_i32m1(v_temp, 10, vl);\n        }\n        \n        // Check which numbers are palindromes\n        v_mask = vmseq_vv_i32m1_b32(v_nums, v_rev, vl);\n        \n        // Count even palindromes\n        vint32m1_t v_even_mask = vand_vx_i32m1_m(v_mask, vmv_v_x_i32m1(0, vl), v_nums, 1, vl);\n        result[0] += vcpop_m_b32(vmseq_vx_i32m1_b32(v_even_mask, 0, vl), vl);\n        \n        // Count odd palindromes\n        vint32m1_t v_odd_mask = vand_vx_i32m1_m(v_mask, vmv_v_x_i32m1(0, vl), v_nums, 1, vl);\n        result[1] += vcpop_m_b32(vmsne_vx_i32m1_b32(v_odd_mask, 0, vl), vl);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Create vector of indices from 1 to n\n    vint32m8_t indices;\n    for(int i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i);\n        indices = vid_v_i32m8(vl);\n        indices = vadd_vx_i32m8(indices, i + 1, vl);\n        \n        // Check if each number is palindrome\n        vbool4_t palindrome_mask = vmfirst_m_b4(vl);\n        vint32m8_t nums = indices;\n        \n        while(vl > 0) {\n            vint32m8_t rev = vzero_v_i32m8(vl);\n            vint32m8_t temp = nums;\n            \n            // Reverse digits\n            while(vmfne_vx_i32m8_b4(temp, 0, vl)) {\n                rev = vmul_vx_i32m8(rev, 10, vl);\n                vint32m8_t digit = vrem_vx_i32m8(temp, 10, vl);\n                rev = vadd_vv_i32m8(rev, digit, vl);\n                temp = vdiv_vx_i32m8(temp, 10, vl);\n            }\n            \n            // Compare original and reversed\n            vbool4_t is_palindrome = vmseq_vv_i32m8_b4(nums, rev, vl);\n            \n            // Count even/odd palindromes\n            vbool4_t is_even = vmseq_vx_i32m8_b4(vrem_vx_i32m8(nums, 2, vl), 0, vl);\n            \n            result[0] += vcpop_m_b4(vand_mm_b4(is_palindrome, is_even, vl), vl);\n            result[1] += vcpop_m_b4(vandnot_mm_b4(is_palindrome, is_even, vl), vl);\n            \n            vl = 0;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_RVV", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    size_t vlen = vsetvlmax_e32m8();\n    \n    // Create vector of sequential numbers from 1 to n\n    vint32m8_t nums = vid_v_i32m8(vlen);\n    \n    // Process numbers in chunks of vlen\n    for (int i = 1; i <= n; i += vlen) {\n        size_t vl = vsetvl_e32m8(n - i + 1);\n        vint32m8_t curr_nums = vadd_vx_i32m8(nums, i-1, vl);\n        \n        // Check which numbers are palindromes\n        vbool4_t palindrome_mask = vmseq_vv_i32m8_b4(curr_nums, curr_nums, vl);\n        \n        // For each palindrome number, check if even/odd\n        vint32m8_t rem = vrem_vx_i32m8(curr_nums, 2, vl);\n        vbool4_t even_mask = vmseq_vx_i32m8_b4(rem, 0, vl);\n        \n        // Count even palindromes\n        int even_count = vcpop_m_b4(vand_mm_b4(palindrome_mask, even_mask, vl), vl);\n        result[0] += even_count;\n        \n        // Count odd palindromes  \n        int odd_count = vcpop_m_b4(vand_mm_b4(palindrome_mask, \n                                  vmnot_m_b4(even_mask, vl), vl), vl);\n        result[1] += odd_count;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    size_t vlen = n.size();\n    int count = 0;\n    \n    // Process vector elements\n    size_t vl;\n    vint32m1_t v_nums;\n    vbool32_t mask;\n    \n    for (size_t i = 0; i < vlen; i += vl) {\n        vl = vsetvl_e32m1(vlen - i);\n        \n        // Load vector elements\n        v_nums = vle32_v_i32m1(&n[i], vl);\n        \n        // Initialize sum vector\n        vint32m1_t v_sums = vmv_v_x_i32m1(0, vl);\n        \n        // Process each number's digits\n        vint32m1_t v_temp = v_nums;\n        \n        while (1) {\n            // Get mask for non-zero numbers\n            mask = vmsne_vx_i32m1_b32(v_temp, 0, vl);\n            \n            // Break if all numbers are zero\n            if (!vmany_m_b32(mask, vl)) break;\n            \n            // Get last digit\n            vint32m1_t v_digit = vrem_vx_i32m1_m(mask, v_temp, v_temp, 10, vl);\n            \n            // Add digit to sum\n            v_sums = vadd_vv_i32m1(v_sums, v_digit, vl);\n            \n            // Divide by 10 for next iteration\n            v_temp = vdiv_vx_i32m1_m(mask, v_temp, v_temp, 10, vl);\n        }\n        \n        // Count numbers with non-zero digit sum\n        mask = vmsne_vx_i32m1_b32(v_sums, 0, vl);\n        count += vcpop_m_b32(mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    size_t vlen = n.size();\n    int count = 0;\n    size_t i = 0;\n    \n    vint32m8_t v_zero = vmv_v_x_i32m8(0, vlen);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t v_nums = vle32_v_i32m8(&n[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(v_nums, 0, vl);\n        vint32m8_t v_temp = v_nums;\n        \n        while (1) {\n            vint32m8_t v_rem = vremu_vx_i32m8(v_temp, 10, vl);\n            v_temp = vdiv_vx_i32m8(v_temp, 10, vl);\n            v_zero = vadd_vv_i32m8(v_zero, v_rem, vl);\n            \n            vbool4_t done = vmseq_vx_i32m8_b4(v_temp, 0, vl);\n            if (vcpop_m_b4(done, vl) == vl) break;\n        }\n        \n        vbool4_t nonzero = vmsne_vx_i32m8_b4(v_zero, 0, vl);\n        count += vcpop_m_b4(nonzero, vl);\n        \n        i += vl;\n        v_zero = vmv_v_x_i32m8(0, vlen);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    size_t vlen = n.size();\n    int count = 0;\n    size_t i = 0;\n    \n    vint32m8_t v_zero = vmv_v_x_i32m8(0, vlen);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t v_nums = vle32_v_i32m8(&n[i], vl);\n        vbool4_t mask = vmseq_vx_i32m8_b4(v_nums, 0, vl);\n        vint32m8_t v_temp = v_nums;\n        \n        while (1) {\n            vint32m8_t v_rem = vremu_vx_i32m8(v_temp, 10, vl);\n            v_temp = vdiv_vx_i32m8(v_temp, 10, vl);\n            v_zero = vadd_vv_i32m8(v_zero, v_rem, vl);\n            \n            vbool4_t done = vmseq_vx_i32m8_b4(v_temp, 0, vl);\n            if (vcpop_m_b4(done, vl) == vl) break;\n        }\n        \n        vbool4_t nonzero = vmsne_vx_i32m8_b4(v_zero, 0, vl);\n        count += vcpop_m_b4(nonzero, vl);\n        \n        i += vl;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    size_t vl;\n    size_t count = 0;\n    size_t i = 0;\n    \n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    \n    while (i < n.size()) {\n        vl = vsetvl_e32m1(n.size() - i);\n        vint32m1_t v_nums = vle32_v_i32m1(&n[i], vl);\n        \n        vint32m1_t v_temp = vmv_v_v_i32m1(v_nums, vl);\n        vbool32_t v_mask = vmseq_vx_i32m1_b32(v_temp, 0, vl);\n        \n        while (1) {\n            v_temp = vdiv_vx_i32m1(v_temp, 10, vl);\n            vint32m1_t v_rem = vrem_vx_i32m1(v_nums, 10, vl);\n            v_nums = vdiv_vx_i32m1(v_nums, 10, vl);\n            v_temp = vadd_vv_i32m1(v_temp, v_rem, vl);\n            \n            vbool32_t v_done = vmseq_vx_i32m1_b32(v_nums, 0, vl);\n            if (vcpop_m_b32(v_done, vl) == vl) break;\n        }\n        \n        vbool32_t v_nonzero = vmsne_vv_i32m1_b32(v_temp, v_zero, vl);\n        count += vcpop_m_b32(v_nonzero, vl);\n        \n        i += vl;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_RVV", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    size_t vlen = n.size();\n    int count = 0;\n    \n    // Process vector elements\n    size_t vl;\n    for (size_t i = 0; i < vlen; i += vl) {\n        vl = vsetvl_e32m8(vlen - i);\n        \n        // Load vector elements\n        vint32m8_t v_nums = vle32_v_i32m8(&n[i], vl);\n        \n        // Initialize mask for positive/negative numbers\n        vbool4_t mask = vmfgt_vx_i32m8_b4(v_nums, 0, vl);\n        vbool4_t neg_mask = vmflt_vx_i32m8_b4(v_nums, 0, vl);\n        \n        // Get absolute values\n        vint32m8_t v_abs = vabs_v_i32m8(v_nums, vl);\n        \n        // Initialize sum vector\n        vint32m8_t v_sums = vmv_v_x_i32m8(0, vl);\n        \n        // Process each digit\n        while (1) {\n            // Get last digit\n            vint32m8_t v_digit = vrem_vx_i32m8(v_abs, 10, vl);\n            \n            // Add/subtract digit based on sign\n            v_sums = vadd_vv_i32m8(v_sums, v_digit, vl);\n            \n            // Divide by 10 for next iteration\n            v_abs = vdiv_vx_i32m8(v_abs, 10, vl);\n            \n            // Check if all elements are 0\n            vbool4_t done = vmsne_vx_i32m8_b4(v_abs, 0, vl);\n            if (!vcpop_m_b4(done, vl)) break;\n        }\n        \n        // Make first digit negative for negative numbers\n        vint32m8_t neg_sums = vsub_vx_i32m8(vmv_v_x_i32m8(0, vl), v_sums, vl);\n        v_sums = vmerge_vvm_i32m8(neg_mask, v_sums, neg_sums, vl);\n        \n        // Count elements with non-zero sum\n        vbool4_t nonzero = vmsne_vx_i32m8_b4(v_sums, 0, vl);\n        count += vcpop_m_b4(nonzero, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    if (n == 1) return true;\n\n    // Find position of minimum element\n    size_t vl;\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m8(n - i);\n        vint32m8_t v_arr = vle32_v_i32m8(&arr[i], vl);\n        \n        // Find minimum in this chunk\n        vbool4_t mask = vmflt_vx_i32m8_b4(v_arr, min_val, vl);\n        if (vmany_m_b4(mask, vl)) {\n            // Update min if found smaller element\n            vint32m8_t v_min = vmin_vx_i32m8(v_arr, min_val, vl);\n            min_val = vmv_x_s_i32m8_i32(v_min);\n            \n            // Find index of minimum\n            for (size_t j = 0; j < vl; j++) {\n                if (arr[i + j] == min_val) {\n                    min_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Check if array can be sorted with rotations\n    bool sorted = true;\n    size_t curr_idx = min_idx;\n    int prev = arr[curr_idx];\n    \n    for (size_t i = 1; i < n; i++) {\n        curr_idx = (curr_idx + 1) % n;\n        if (arr[curr_idx] < prev) {\n            sorted = false;\n            break;\n        }\n        prev = arr[curr_idx];\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    if (n == 1) return true;\n\n    // Find the minimum element and its index\n    size_t vl;\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    vint32m1_t v_min = vmv_v_x_i32m1(arr[0], 1);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_arr = vle32_v_i32m1(&arr[i], vl);\n        vbool32_t mask = vmslt_vx_i32m1_b32(v_arr, min_val, vl);\n        \n        if (vmany_m_b32(mask, vl)) {\n            vint32m1_t v_masked = vmerge_vxm_i32m1(vmv_v_x_i32m1(min_val, vl), mask, v_arr, vl);\n            min_val = vmv_x_s_i32m1_i32(vredmin_vs_i32m1_i32m1(v_masked, v_masked, vl));\n            \n            // Find index of min value\n            for (size_t j = i; j < i + vl; j++) {\n                if (arr[j] == min_val) {\n                    min_idx = j;\n                    break;\n                }\n            }\n        }\n    }\n\n    // Check if array can be sorted with rotations\n    bool increasing = true;\n    size_t curr = min_idx;\n    \n    for (size_t i = 1; i < n; i++) {\n        size_t next = (curr + 1) % n;\n        if (arr[next] < arr[curr]) {\n            increasing = false;\n            break;\n        }\n        curr = next;\n    }\n\n    return increasing;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.size() <= 1) return true;\n    \n    size_t n = arr.size();\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    // Find first decreasing point\n    int dec_point = -1;\n    for (size_t i = 0; i < n-1; i++) {\n        if (arr[i] > arr[i+1]) {\n            dec_point = i;\n            break;\n        }\n    }\n    \n    if (dec_point == -1) return true;\n    \n    // Check if array can be sorted by right rotation\n    bool can_sort = true;\n    \n    // Check first part - from dec_point+1 to end\n    for (size_t i = dec_point+1; i < n-1; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n-1-i);\n        vint32m8_t v1 = __riscv_vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t v2 = __riscv_vle32_v_i32m8(&arr[i+1], vl);\n        vbool4_t mask = __riscv_vmsgt_vv_i32m8_b4(v1, v2, vl);\n        if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n            can_sort = false;\n            break;\n        }\n    }\n    \n    if (!can_sort) return false;\n    \n    // Check wrap around - last element with first element\n    if (arr[n-1] > arr[0]) return false;\n    \n    // Check second part - from start to dec_point\n    for (size_t i = 0; i < dec_point; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(dec_point-i);\n        vint32m8_t v1 = __riscv_vle32_v_i32m8(&arr[i], vl);\n        vint32m8_t v2 = __riscv_vle32_v_i32m8(&arr[i+1], vl);\n        vbool4_t mask = __riscv_vmsgt_vv_i32m8_b4(v1, v2, vl);\n        if (__riscv_vfirst_m_b4(mask, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    if (n == 1) return true;\n\n    // Find minimum element and its index\n    size_t vl;\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    vint32m1_t v_min = vmv_v_x_i32m1(arr[0], 1);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_arr = vle32_v_i32m1(&arr[i], vl);\n        vbool32_t mask = vmslt_vx_i32m1_b32(v_arr, min_val, vl);\n        \n        if (vmany_m_b32(mask, vl)) {\n            vint32m1_t v_idx = vid_v_i32m1(vl);\n            vint32m1_t v_masked_idx = vmerge_vxm_i32m1(vmv_v_x_i32m1(-1, vl), v_idx, mask, vl);\n            int32_t first_idx = vredmin_vs_i32m1_i32m1(v_masked_idx, v_masked_idx, vl);\n            \n            if (first_idx >= 0) {\n                min_idx = i + first_idx;\n                min_val = arr[min_idx];\n            }\n        }\n    }\n\n    // Check if array can be sorted with rotations\n    bool sorted = true;\n    int prev = min_val;\n    \n    // Check first segment\n    for (size_t i = (min_idx + 1) % n; i != min_idx; i = (i + 1) % n) {\n        if (arr[i] < prev) {\n            sorted = false;\n            break;\n        }\n        prev = arr[i];\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_115_RVV", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    size_t n = arr.size();\n    if (n == 1) return true;\n\n    // Find min element and its index\n    size_t vl;\n    size_t min_idx = 0;\n    int min_val = arr[0];\n    \n    vint32m1_t v_min = vmv_v_x_i32m1(arr[0], 1);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_arr = vle32_v_i32m1(&arr[i], vl);\n        vbool32_t mask = vmslt_vv_i32m1_b32(v_arr, v_min, vl);\n        \n        if (vmany_m_b32(mask, vl)) {\n            vint32m1_t v_min_new = vmin_vv_i32m1(v_min, v_arr, vl);\n            min_val = vmv_x_s_i32m1_i32(v_min_new);\n            for (size_t j = i; j < i + vl; j++) {\n                if (arr[j] == min_val) {\n                    min_idx = j;\n                    break;\n                }\n            }\n            v_min = vmv_v_x_i32m1(min_val, 1);\n        }\n    }\n\n    // Check if array can be sorted by right rotations\n    size_t curr = min_idx;\n    int prev = min_val;\n    \n    for (size_t i = 1; i < n; i++) {\n        curr = (curr + 1) % n;\n        if (arr[curr] < prev) {\n            return false;\n        }\n        prev = arr[curr];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v1 = __riscv_vle32_v_i32m8(&lst1[i], vl);\n        vint32m8_t v2 = __riscv_vle32_v_i32m8(&lst2[i], vl);\n        \n        // Count odd numbers in lst1\n        vint32m8_t v1_mod = __riscv_vand_vx_i32m8(v1, 1, vl);\n        vbool4_t odd_mask1 = __riscv_vmsne_vx_i32m8_b4(v1_mod, 0, vl);\n        odd_count1 += __riscv_vcpop_m_b4(odd_mask1, vl);\n        \n        // Count even numbers in lst2\n        vint32m8_t v2_mod = __riscv_vand_vx_i32m8(v2, 1, vl);\n        vbool4_t even_mask2 = __riscv_vmseq_vx_i32m8_b4(v2_mod, 0, vl);\n        even_count2 += __riscv_vcpop_m_b4(even_mask2, vl);\n    }\n    \n    // If there are enough even numbers in lst2 to replace odd numbers in lst1\n    if(even_count2 >= odd_count1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v1 = __riscv_vle32_v_i32m8(&lst1[i], vl);\n        vint32m8_t v2 = __riscv_vle32_v_i32m8(&lst2[i], vl);\n        \n        // Count odd numbers in lst1\n        vint32m8_t v1_mod = __riscv_vand_vx_i32m8(v1, 1, vl);\n        vbool4_t odd_mask1 = __riscv_vmsne_vx_i32m8_b4(v1_mod, 0, vl);\n        odd_count1 += __riscv_vcpop_m_b4(odd_mask1, vl);\n        \n        // Count even numbers in lst2\n        vint32m8_t v2_mod = __riscv_vand_vx_i32m8(v2, 1, vl);\n        vbool4_t even_mask2 = __riscv_vmseq_vx_i32m8_b4(v2_mod, 0, vl);\n        even_count2 += __riscv_vcpop_m_b4(even_mask2, vl);\n    }\n    \n    // If there are enough even numbers in lst2 to replace odd numbers in lst1\n    if(even_count2 >= odd_count1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t vlen = lst1.size();\n    size_t odd_count = 0;\n    size_t even_count = 0;\n    \n    // Get vector length\n    size_t vlmax = vsetvlmax_e32m8();\n    \n    // Count odd numbers in lst1\n    for (size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        vint32m8_t v_lst1 = vle32_v_i32m8(lst1.data() + (lst1.size() - vlen), vl);\n        \n        // Create mask for odd numbers\n        vbool4_t mask = vmsne_vx_i32m8_b4(vand_vx_i32m8(v_lst1, 1, vl), 0, vl);\n        \n        // Count odd numbers\n        odd_count += vcpop_m_b4(mask, vl);\n    }\n    \n    vlen = lst2.size();\n    \n    // Count even numbers in lst2\n    for (size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        vint32m8_t v_lst2 = vle32_v_i32m8(lst2.data() + (lst2.size() - vlen), vl);\n        \n        // Create mask for even numbers\n        vbool4_t mask = vmseq_vx_i32m8_b4(vand_vx_i32m8(v_lst2, 1, vl), 0, vl);\n        \n        // Count even numbers\n        even_count += vcpop_m_b4(mask, vl);\n    }\n    \n    // If there are enough even numbers in lst2 to replace odd numbers in lst1\n    return (even_count >= odd_count) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v1 = __riscv_vle32_v_i32m8(&lst1[i], vl);\n        vint32m8_t v2 = __riscv_vle32_v_i32m8(&lst2[i], vl);\n        \n        // Count odd numbers in lst1\n        vint32m8_t odd1 = __riscv_vand_vx_i32m8(v1, 1, vl);\n        vbool4_t mask1 = __riscv_vmsne_vx_i32m8_b4(odd1, 0, vl);\n        odd_count1 += __riscv_vcpop_m_b4(mask1, vl);\n        \n        // Count even numbers in lst2  \n        vint32m8_t odd2 = __riscv_vand_vx_i32m8(v2, 1, vl);\n        vbool4_t mask2 = __riscv_vmseq_vx_i32m8_b4(odd2, 0, vl);\n        even_count2 += __riscv_vcpop_m_b4(mask2, vl);\n    }\n\n    // If number of odd elements in lst1 is less than or equal to \n    // number of even elements in lst2, exchange is possible\n    return (odd_count1 <= even_count2) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_RVV", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n = lst1.size();\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    for(size_t i = 0; i < n; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v1 = __riscv_vle32_v_i32m8(&lst1[i], vl);\n        vint32m8_t v2 = __riscv_vle32_v_i32m8(&lst2[i], vl);\n        \n        // Count odd numbers in lst1\n        vint32m8_t v1_mod = __riscv_vand_vx_i32m8(v1, 1, vl);\n        vbool4_t odd_mask1 = __riscv_vmsne_vx_i32m8_b4(v1_mod, 0, vl);\n        odd_count1 += __riscv_vcpop_m_b4(odd_mask1, vl);\n        \n        // Count even numbers in lst2\n        vint32m8_t v2_mod = __riscv_vand_vx_i32m8(v2, 1, vl);\n        vbool4_t even_mask2 = __riscv_vmseq_vx_i32m8_b4(v2_mod, 0, vl);\n        even_count2 += __riscv_vcpop_m_b4(even_mask2, vl);\n    }\n    \n    // If we have enough even numbers in lst2 to replace odd numbers in lst1\n    if(even_count2 >= odd_count1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.data();\n        size_t str_len = str.length();\n        \n        while (str_len > 0) {\n            size_t vl = __riscv_vsetvl_e8m8(str_len);\n            \n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)ptr, vl);\n            \n            // Subtract '0' to get actual digit values\n            vuint8m8_t v_digits = __riscv_vsub_vx_u8m8(v_chars, '0', vl);\n            \n            // Check for odd digits (digit & 1)\n            vbool1_t v_odd = __riscv_vand_vx_u8m8_b1(v_digits, 1, vl);\n            \n            // Count odd digits\n            odd_count += __riscv_vcpop_m_b1(v_odd, vl);\n            \n            ptr += vl;\n            str_len -= vl;\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" + \n                                 std::to_string(odd_count) + \n                                 \"ng \" + \n                                 std::to_string(odd_count) + \n                                 \" of the \" + \n                                 std::to_string(odd_count) + \n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for(const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.c_str();\n        size_t str_len = str.length();\n        \n        while(str_len > 0) {\n            size_t vl = __riscv_vsetvl_e8m8(str_len);\n            \n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)ptr, vl);\n            \n            // Subtract '0' to get actual digit values\n            vuint8m8_t v_digits = __riscv_vsub_vx_u8m8(v_chars, '0', vl);\n            \n            // Check for odd digits (digit & 1)\n            vbool1_t v_odd = __riscv_vand_vx_u8m8_b1(v_digits, 1, vl);\n            \n            // Count odd digits\n            odd_count += __riscv_vcpop_m_b1(v_odd, vl);\n            \n            ptr += vl;\n            str_len -= vl;\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" +\n                                 std::to_string(odd_count) +\n                                 \"ng \" +\n                                 std::to_string(odd_count) +\n                                 \" of the \" +\n                                 std::to_string(odd_count) +\n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.c_str();\n        size_t str_len = str.length();\n        \n        while (str_len > 0) {\n            size_t vl = __riscv_vsetvl_e8m8(str_len);\n            \n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)ptr, vl);\n            \n            // Subtract '0' to get actual digit values\n            vuint8m8_t v_digits = __riscv_vsub_vx_u8m8(v_chars, '0', vl);\n            \n            // Check for odd digits (digit & 1)\n            vbool1_t v_odd = __riscv_vand_vx_u8m8_b1(v_digits, 1, vl);\n            \n            // Count odd digits\n            odd_count += __riscv_vcpop_m_b1(v_odd, vl);\n            \n            ptr += vl;\n            str_len -= vl;\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" + \n                                 std::to_string(odd_count) + \n                                 \"ng \" + \n                                 std::to_string(odd_count) + \n                                 \" of the \" + \n                                 std::to_string(odd_count) + \n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for(const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.data();\n        size_t str_len = str.length();\n        \n        while(str_len > 0) {\n            size_t vl = __riscv_vsetvl_e8m8(str_len);\n            \n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)ptr, vl);\n            \n            // Convert chars to digits by subtracting '0'\n            vuint8m8_t v_digits = __riscv_vsub_vx_u8m8(v_chars, '0', vl);\n            \n            // Check which digits are odd using AND with 1\n            vbool1_t v_odd = __riscv_vmslt_vx_u8m8_b1(\n                __riscv_vand_vx_u8m8(v_digits, 1, vl),\n                1, vl\n            );\n            \n            // Count odd digits\n            odd_count += __riscv_vcpop_m_b1(v_odd, vl);\n            \n            ptr += vl;\n            str_len -= vl;\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" +\n                                 std::to_string(odd_count) +\n                                 \"ng \" +\n                                 std::to_string(odd_count) +\n                                 \" of the \" +\n                                 std::to_string(odd_count) +\n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_RVV", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    size_t vlen = __riscv_vsetvlmax_e8m8();\n    \n    for(const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.data();\n        size_t str_len = str.length();\n        \n        while(str_len > 0) {\n            size_t vl = __riscv_vsetvl_e8m8(str_len);\n            \n            vuint8m8_t v_chars = __riscv_vle8_v_u8m8((uint8_t*)ptr, vl);\n            \n            // Subtract '0' to get actual digit values\n            vuint8m8_t v_digits = __riscv_vsub_vx_u8m8(v_chars, '0', vl);\n            \n            // Create mask for odd digits\n            vbool1_t odd_mask = __riscv_vand_vx_u8m8_b1(v_digits, 1, vl);\n            \n            // Count odd digits in this chunk\n            odd_count += __riscv_vcpop_m_b1(odd_mask, vl);\n            \n            ptr += vl;\n            str_len -= vl;\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" +\n                                 std::to_string(odd_count) +\n                                 \"ng \" +\n                                 std::to_string(odd_count) +\n                                 \" of the \" +\n                                 std::to_string(odd_count) +\n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlen = nums.size();\n    if (vlen == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    size_t gvl;\n    vint64m8_t v_nums, v_curr_sum;\n    \n    for (size_t i = 0; i < vlen; i += gvl) {\n        gvl = vsetvl_e64m8(vlen - i);\n        \n        // Load vector elements\n        v_nums = vle64_v_i64m8(&nums[i], gvl);\n        \n        // Add to current sum\n        v_curr_sum = vadd_vx_i64m8(v_nums, curr_sum, gvl);\n        \n        // Update curr_sum with max of 0 and curr_sum + nums[i]\n        v_curr_sum = vmax_vx_i64m8(v_curr_sum, 0, gvl);\n        \n        // Find minimum across the vector\n        vint64m1_t v_min = vredmin_vs_i64m8_i64m1(v_curr_sum, v_curr_sum, gvl);\n        int64_t local_min = vmv_x_s_i64m1_i64(v_min);\n        \n        min_sum = std::min(min_sum, local_min);\n        \n        // Get last element's curr_sum for next iteration\n        curr_sum = vmv_x_s_i64m8_i64(vslide1down_vx_i64m8(v_curr_sum, 0, gvl));\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlen = nums.size();\n    if (vlen == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    size_t vl;\n    vint64m8_t v_nums, v_curr_sum;\n    \n    while (vlen > 0) {\n        vl = vsetvl_e64m8(vlen);\n        \n        v_nums = vle64_v_i64m8(&nums[nums.size() - vlen], vl);\n        \n        // Calculate running sum\n        v_curr_sum = vadd_vx_i64m8(v_nums, curr_sum, vl);\n        \n        // Update curr_sum for next iteration\n        curr_sum = v_curr_sum[vl-1];\n        \n        // Find minimum of curr_sum\n        vbool8_t mask = vmflt_vx_i64m8_b8(v_curr_sum, min_sum, vl);\n        min_sum = vfirst_m_b8(mask, vl) >= 0 ? \n                  vredmin_vs_i64m8_i64m1(v_curr_sum, v_curr_sum, vl)[0] :\n                  min_sum;\n        \n        vlen -= vl;\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlen = nums.size();\n    if (vlen == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    size_t vl;\n    vl = vsetvl_e64m8(vlen);\n    \n    vint64m8_t v_nums, v_curr_sum;\n    vbool8_t vmask;\n    \n    for (size_t i = 0; i < vlen; i += vl) {\n        vl = vsetvl_e64m8(vlen - i);\n        \n        // Load vector chunk\n        v_nums = vle64_v_i64m8(&nums[i], vl);\n        \n        // Add to current sum\n        curr_sum = curr_sum + vredsum_vs_i64m8_i64m1(v_nums, v_nums, vl);\n        \n        // Update running sum vector\n        v_curr_sum = vmv_v_x_i64m8(curr_sum, vl);\n        \n        // Find minimum\n        min_sum = vmin(min_sum, vredmin_vs_i64m8_i64m1(v_curr_sum, v_curr_sum, vl));\n        \n        // Reset curr_sum if negative\n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlen = nums.size();\n    if (vlen == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    size_t gvl;\n    vint64m8_t v_nums, v_curr_sum;\n    \n    for (size_t i = 0; i < vlen; i += gvl) {\n        gvl = vsetvl_e64m8(vlen - i);\n        \n        v_nums = vle64_v_i64m8(&nums[i], gvl);\n        \n        // Update current sum\n        v_curr_sum = vadd_vx_i64m8(v_nums, curr_sum, gvl);\n        \n        // Find minimum in current vector chunk\n        int64_t v_min = vredmin_vs_i64m8_i64m1(v_curr_sum, v_curr_sum, gvl);\n        min_sum = std::min(min_sum, v_min);\n        \n        // Update curr_sum for next iteration\n        curr_sum = v_curr_sum[gvl-1];\n        \n        // Reset curr_sum to 0 if it becomes positive\n        curr_sum = std::min(curr_sum, (int64_t)0);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_RVV", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t vlen = nums.size();\n    if (vlen == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    size_t vlmax = vsetvlmax_e64m8();\n    \n    for (size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e64m8(vlen - i);\n        \n        vint64m8_t v_nums = vle64_v_i64m8(&nums[i], vl);\n        \n        // Calculate running sum\n        vint64m8_t v_curr = vadd_vx_i64m8(v_nums, curr_sum, vl);\n        \n        // Update curr_sum with last element\n        curr_sum = vmv_x_s_i64m8_i64(vget_v_i64m8_i64m8(v_curr, vl-1));\n        \n        // Find minimum in current chunk\n        int64_t chunk_min = vredmin_vs_i64m8_i64m1(v_curr, v_curr, vl);\n        \n        // Update global minimum\n        min_sum = std::min(min_sum, chunk_min);\n        \n        // Reset curr_sum if negative\n        curr_sum = std::max(curr_sum, (int64_t)0);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    std::vector<int> water_counts(rows, 0);\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    // Count water units in each row\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j += vlen) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t v_row = __riscv_vle32_v_i32m8(&grid[i][j], vl);\n            vint32m8_t v_ones = __riscv_vmv_v_x_i32m8(1, vl);\n            vint32m8_t v_masked = __riscv_vand_vv_i32m8(v_row, v_ones, vl);\n            v_masked = __riscv_vredsum_vs_i32m8_i32m1(v_masked, __riscv_vmv_v_x_i32m1(0, 1), vl);\n            sum += __riscv_vmv_x_s_i32m1_i32(v_masked);\n        }\n        water_counts[i] = sum;\n    }\n    \n    // Calculate total trips needed\n    int total_trips = 0;\n    for (int i = 0; i < rows; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(rows - i);\n        vint32m8_t v_counts = __riscv_vle32_v_i32m8(&water_counts[i], vl);\n        vint32m8_t v_capacity = __riscv_vmv_v_x_i32m8(capacity, vl);\n        vint32m8_t v_div = __riscv_vdiv_vx_i32m8(v_counts, capacity, vl);\n        vint32m8_t v_rem = __riscv_vrem_vx_i32m8(v_counts, capacity, vl);\n        vbool4_t v_mask = __riscv_vmsne_vx_i32m8_b4(v_rem, 0, vl);\n        vint32m8_t v_add = __riscv_vadd_vx_i32m8_m(v_mask, v_div, v_div, 1, vl);\n        v_add = __riscv_vredsum_vs_i32m8_i32m1(v_add, __riscv_vmv_v_x_i32m1(0, 1), vl);\n        total_trips += __riscv_vmv_x_s_i32m1_i32(v_add);\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Count total water units in each row\n    std::vector<int> row_sums(rows, 0);\n    \n    size_t vl;\n    vint32m1_t v_sum;\n    \n    for (int i = 0; i < rows; i++) {\n        v_sum = vmv_v_x_i32m1(0, 1); // Initialize accumulator to 0\n        \n        for (int j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m1(cols - j);\n            vint32m1_t v_row = vle32_v_i32m1(&grid[i][j], vl);\n            v_sum = vredsum_vs_i32m1_i32m1(v_sum, v_row, v_sum, vl);\n        }\n        \n        row_sums[i] = vmv_x_s_i32m1_i32(v_sum);\n    }\n    \n    // Find max number of bucket lowerings needed\n    int max_lowerings = 0;\n    \n    for (int i = 0; i < rows; i += vl) {\n        vl = vsetvl_e32m1(rows - i);\n        vint32m1_t v_sums = vle32_v_i32m1(&row_sums[i], vl);\n        \n        // Divide by capacity and round up\n        vint32m1_t v_lowerings = vdiv_vx_i32m1(v_sums, capacity, vl);\n        vbool32_t v_remainder = vmsne_vx_i32m1_b32(vrem_vx_i32m1(v_sums, capacity, vl), 0, vl);\n        v_lowerings = vadd_vx_i32m1_m(v_remainder, v_lowerings, v_lowerings, 1, vl);\n        \n        // Find max\n        vint32m1_t v_max = vredmax_vs_i32m1_i32m1(v_lowerings, v_lowerings, vmv_v_x_i32m1(max_lowerings, 1), vl);\n        max_lowerings = vmv_x_s_i32m1_i32(v_max);\n    }\n    \n    return max_lowerings;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    std::vector<int> water_counts(rows, 0);\n    size_t vl;\n    \n    // Count water units in each row\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n        \n        for (int j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m1(cols - j);\n            vint32m1_t v_elements = vle32_v_i32m1(&grid[i][j], vl);\n            v_sum = vadd_vv_i32m1(v_sum, v_elements, vl);\n        }\n        \n        // Reduce vector sum\n        vl = 1;\n        water_counts[i] = vmv_x_s_i32m1_i32(v_sum);\n    }\n    \n    // Calculate total fills needed\n    int total_fills = 0;\n    for (int i = 0; i < rows; i++) {\n        total_fills += (water_counts[i] + capacity - 1) / capacity;\n    }\n    \n    return total_fills;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> >& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    std::vector<int> water_counts(rows, 0);\n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    \n    // Count water units in each row\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        for (int j = 0; j < cols; j += vlen) {\n            size_t vl = __riscv_vsetvl_e32m8(cols - j);\n            vint32m8_t v_row = __riscv_vle32_v_i32m8(&grid[i][j], vl);\n            vint32m8_t v_ones = __riscv_vmv_v_x_i32m8(1, vl);\n            vint32m8_t v_masked = __riscv_vmul_vv_i32m8(v_row, v_ones, vl);\n            vint32m1_t v_sum = __riscv_vredsum_vs_i32m8_i32m1(v_masked, __riscv_vmv_v_x_i32m1(0, 1), vl);\n            sum += __riscv_vmv_x_s_i32m1_i32(v_sum);\n        }\n        water_counts[i] = sum;\n    }\n\n    // Calculate total trips needed\n    int total_trips = 0;\n    for (int i = 0; i < rows; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(rows - i);\n        vint32m8_t v_counts = __riscv_vle32_v_i32m8(&water_counts[i], vl);\n        vint32m8_t v_capacity = __riscv_vmv_v_x_i32m8(capacity, vl);\n        vint32m8_t v_div = __riscv_vdiv_vx_i32m8(v_counts, capacity, vl);\n        vint32m8_t v_rem = __riscv_vrem_vx_i32m8(v_counts, capacity, vl);\n        vbool4_t v_mask = __riscv_vmsne_vx_i32m8_b4(v_rem, 0, vl);\n        vint32m8_t v_trips = __riscv_vadd_vx_i32m8_m(v_mask, v_div, v_div, 1, vl);\n        vint32m1_t v_sum = __riscv_vredsum_vs_i32m8_i32m1(v_trips, __riscv_vmv_v_x_i32m1(0, 1), vl);\n        total_trips += __riscv_vmv_x_s_i32m1_i32(v_sum);\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_RVV", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    // Count water units in each row using vector instructions\n    std::vector<int> row_sums(rows, 0);\n    \n    size_t vl;\n    for (int i = 0; i < rows; i++) {\n        int sum = 0;\n        const int* row = grid[i].data();\n        \n        vint32m8_t v_sum = vmv_v_x_i32m8(0, 1);\n        \n        for (size_t j = 0; j < cols; j += vl) {\n            vl = vsetvl_e32m8(cols - j);\n            vint32m8_t v_elements = vle32_v_i32m8(row + j, vl);\n            v_sum = vadd_vv_i32m8(v_sum, v_elements, vl);\n        }\n        \n        // Reduce vector sum\n        vl = vsetvl_e32m8(8);\n        v_sum = vredsum_vs_i32m8_i32m1(v_sum, v_sum, vmv_v_x_i32m1(0, vl), vl);\n        row_sums[i] = vmv_x_s_i32m1_i32(v_sum);\n    }\n    \n    // Calculate total trips needed\n    int total_trips = 0;\n    for (int sum : row_sums) {\n        total_trips += (sum + capacity - 1) / capacity;\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlen = lst.size();\n    const int16_t* ptr = lst.data();\n    int64_t sum = 0;\n    \n    size_t gvl;\n    vint16m1_t v_data;\n    vbool16_t mask;\n    vint16m1_t v_masked;\n    \n    for (size_t i = 0; i < vlen; i += gvl) {\n        gvl = vsetvl_e16m1(vlen - i);\n        \n        // Load vector data\n        v_data = vle16_v_i16m1(ptr + i, gvl);\n        \n        // Create mask for even positions\n        vint16m1_t v_idx = vid_v_i16m1(gvl);\n        mask = vmseq_vx_i16m1_b16(vand_vx_i16m1(v_idx, 1, gvl), 0, gvl);\n        \n        // Mask for odd values\n        vbool16_t odd_mask = vmsne_vx_i16m1_b16(vand_vx_i16m1(v_data, 1, gvl), 0, gvl);\n        \n        // Combine masks\n        mask = vmand_mm_b16(mask, odd_mask, gvl);\n        \n        // Apply mask and sum\n        v_masked = vmerge_vxm_i16m1(vzero_vx_i16m1(gvl), mask, v_data, gvl);\n        sum += vredsum_vs_i16m1_i16m1(vzero_vx_i16m1(gvl), v_masked, vzero_vx_i16m1(gvl), gvl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlen = lst.size();\n    const int16_t* ptr = lst.data();\n    int64_t sum = 0;\n    \n    size_t gvl;\n    vint16m1_t v_data;\n    vbool16_t mask;\n    vint16m1_t v_ones;\n    vint16m1_t v_masked;\n    \n    // Initialize vector with all ones for masking\n    v_ones = vmv_v_x_i16m1(1, vsetvlmax_e16m1());\n    \n    // Process 2 elements at a time (even positions)\n    for(size_t i = 0; i < vlen; i += 2*gvl) {\n        // Set vector length\n        gvl = vsetvl_e16m1((vlen-i)/2);\n        \n        // Load elements at even positions with strided load\n        v_data = vlse16_v_i16m1(ptr + i, 2*sizeof(int16_t), gvl);\n        \n        // Create mask for odd numbers\n        mask = vmsne_vx_i16m1_b16(vand_vx_i16m1(v_data, v_ones, gvl), 0, gvl);\n        \n        // Zero out even numbers\n        v_masked = vmerge_vxm_i16m1(mask, vmv_v_x_i16m1(0, gvl), v_data, gvl);\n        \n        // Add to running sum\n        sum += vredsum_vs_i16m1_i16m1(vmv_v_x_i16m1(0, gvl), v_masked, vmv_v_x_i16m1(0, gvl), gvl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlen = lst.size();\n    const int16_t* ptr = lst.data();\n    int64_t sum = 0;\n    \n    size_t gvl;\n    vint16m1_t v_data;\n    vbool16_t mask;\n    vint16m1_t v_masked;\n    \n    // Process 2 elements at a time to get even positions\n    for(size_t i = 0; i < vlen; i += 2) {\n        // Get vector length for remaining elements\n        gvl = vsetvl_e16m1(vlen - i);\n        \n        // Load vector data\n        v_data = vle16_v_i16m1(ptr + i, gvl);\n        \n        // Create mask for odd numbers\n        mask = vmslt_vx_i16m1_b16(v_data, 0, gvl);\n        mask = vmxor_mm_b16(mask, vmsltu_vx_i16m1_b16(v_data, 0, gvl));\n        \n        // Apply mask to get odd numbers\n        v_masked = vmerge_vxm_i16m1(mask, v_data, 0, gvl);\n        \n        // Reduce sum\n        sum += vredsum_vs_i16m1_i16m1(v_masked, v_masked, gvl);\n        \n        // Skip odd positions\n        ptr += 2;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlen = lst.size();\n    int64_t sum = 0;\n    size_t index = 0;\n    \n    vint16m1_t v_mask;\n    vint16m1_t v_data;\n    vbool16_t odd_mask;\n    \n    while (index < vlen) {\n        size_t avl = vlen - index;\n        size_t vl = vsetvl_e16m1(avl);\n        \n        // Load vector data starting from even indices\n        v_data = vle16_v_i16m1(&lst[index], vl);\n        \n        // Create mask for odd numbers\n        odd_mask = vmslt_vx_i16m1_b16(vand_vx_i16m1(v_data, 1, vl), 0, vl);\n        \n        // Sum odd numbers\n        sum += vredsum_vs_i16m1_i16m1(v_data, vmv_v_x_i16m1(0, vl), vl);\n        \n        index += vl * 2; // Skip to next even positions\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_RVV", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t vlen = lst.size();\n    int64_t sum = 0;\n    \n    size_t index = 0;\n    vint16m1_t v_mask;\n    \n    while (index < vlen) {\n        size_t avl = vlen - index;\n        size_t vl = vsetvl_e16m1(avl);\n        \n        vint16m1_t v_data = vle16_v_i16m1(&lst[index], vl);\n        \n        // Create mask for even positions\n        vbool16_t pos_mask = vmseq_vx_i16m1_b16(vrgather_vx_i16m1(v_data, 0, vl), 0, vl);\n        for (size_t i = 2; i < vl; i += 2) {\n            pos_mask = vmor_mm_b16(pos_mask, \n                                 vmseq_vx_i16m1_b16(vrgather_vx_i16m1(v_data, i, vl), 0, vl), \n                                 vl);\n        }\n        \n        // Create mask for odd values\n        vbool16_t odd_mask = vmsne_vx_i16m1_b16(vand_vx_i16m1(v_data, 1, vl), 0, vl);\n        \n        // Combine masks\n        vbool16_t final_mask = vmand_mm_b16(pos_mask, odd_mask, vl);\n        \n        // Extract values using mask\n        vint16m1_t v_masked = vmerge_vxm_i16m1(vzero_vint16m1(vl), final_mask, v_data, vl);\n        \n        // Sum the masked values\n        sum += vredsum_vs_i16m1_i16m1(vzero_vint16m1(vl), v_masked, vzero_vint16m1(vl), vl);\n        \n        index += vl;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    size_t vl;\n    int sum = 0;\n    int n = std::min(k, (int)arr.size());\n    \n    vint32m1_t v_data;\n    vbool32_t mask;\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector elements\n        v_data = vle32_v_i32m1(&arr[i], vl);\n        \n        // Create mask for elements < 100\n        mask = vmsltu_vx_i32m1_b32(v_data, 100, vl);\n        \n        // Create mask for elements >= -99 \n        mask = vand_mm_b32(mask, vmsgt_vx_i32m1_b32(v_data, -100, vl), vl);\n        \n        // Add masked elements\n        sum += vredsum_vs_i32m1_i32m1_m(mask, v_data, vmv_v_x_i32m1(0, vl), vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    size_t vl;\n    int sum = 0;\n    int *ptr = arr.data();\n    size_t n = std::min(k, (int)arr.size());\n    \n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_99 = vmv_v_x_i32m1(99, 1);\n    vint32m1_t v_neg99 = vmv_v_x_i32m1(-99, 1);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        vint32m1_t v_data = vle32_v_i32m1(ptr + i, vl);\n        \n        // Check if numbers are between -99 and 99 (two digits)\n        vbool32_t mask = vand_vv_b32(\n            vmsle_vv_i32m1_b32(v_neg99, v_data, vl),\n            vmsle_vv_i32m1_b32(v_data, v_99, vl),\n            vl\n        );\n        \n        // Zero out numbers that don't meet the criteria\n        v_data = vmerge_vvm_i32m1(mask, v_zero, v_data, vl);\n        \n        // Horizontal sum of remaining numbers\n        sum += vredsum_vs_i32m1_i32m1(v_zero, v_data, v_zero, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    size_t vl;\n    int sum = 0;\n    int n = std::min(k, (int)arr.size());\n    \n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_99 = vmv_v_x_i32m1(99, 1);\n    vint32m1_t v_neg99 = vmv_v_x_i32m1(-99, 1);\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&arr[i], vl);\n        \n        // Check if numbers are between -99 and 99 (two digits)\n        vbool32_t mask = vand_vv_b32(\n            vmsle_vv_i32m1_b32(v_neg99, v_data, vl),\n            vmsle_vv_i32m1_b32(v_data, v_99, vl),\n            vl\n        );\n        \n        // Zero out numbers that don't meet the criteria\n        v_data = vmerge_vvm_i32m1(mask, v_zero, v_data, vl);\n        \n        // Horizontal sum of remaining valid numbers\n        sum += vredsum_vs_i32m1_i32m1(v_zero, v_data, v_zero, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    size_t vl;\n    int sum = 0;\n    int *ptr = arr.data();\n    size_t n = std::min(k, (int)arr.size());\n    \n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        // Load vector\n        vint32m1_t v_data = vle32_v_i32m1(ptr + i, vl);\n        \n        // Create mask for numbers < 100\n        vbool32_t mask = vmsltu_vx_i32m1_b32(vabs_v_i32m1(v_data, vl), 100, vl);\n        \n        // Add masked elements\n        v_sum = vadd_vv_i32m1_m(mask, v_sum, v_sum, v_data, vl);\n    }\n    \n    // Horizontal sum\n    sum = vredsum_vs_i32m1_i32m1(v_sum, v_sum, vmv_v_x_i32m1(0, 1), n);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_RVV", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    size_t vl;\n    int sum = 0;\n    int n = std::min(k, (int)arr.size());\n    \n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_ten = vmv_v_x_i32m1(10, 1);\n    vint32m1_t v_hundred = vmv_v_x_i32m1(100, 1);\n    \n    for (int i = 0; i < n; i += vl) {\n        vl = vsetvl_e32m1(n - i);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&arr[i], vl);\n        \n        // Get absolute values\n        vint32m1_t v_abs = vabs_v_i32m1(v_data, vl);\n        \n        // Check if numbers are less than 100 (two digits)\n        vbool32_t mask = vmsltu_vx_i32m1_b32(v_abs, 100, vl);\n        \n        // Zero out elements that have more than 2 digits\n        vint32m1_t v_masked = vmerge_vvm_i32m1(mask, v_zero, v_data, vl);\n        \n        // Horizontal sum of masked values\n        sum += vredsum_vs_i32m1_i32m1(v_zero, v_masked, v_zero, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    \n    // Check if sorted in ascending order\n    for (size_t i = 0; i < n-1; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-1);\n        \n        // Load current and next elements\n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        \n        // Compare if v1 >= v2\n        vbool4_t mask = vmge_vv_i32m8_b4(v1, v2, vl);\n        \n        // If any element is greater or equal to next, not sorted\n        if (vfirst_m_b4(mask, vl) != -1) {\n            return false;\n        }\n    }\n    \n    // Check for more than 1 duplicate\n    for (size_t i = 0; i < n-2; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-2);\n        \n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        vint32m8_t v3 = vle32_v_i32m8(&lst[i+2], vl);\n        \n        // Check if three consecutive elements are equal\n        vbool4_t mask1 = vmseq_vv_i32m8_b4(v1, v2, vl);\n        vbool4_t mask2 = vmseq_vv_i32m8_b4(v2, v3, vl);\n        vbool4_t mask = vmand_mm_b4(mask1, mask2, vl);\n        \n        if (vfirst_m_b4(mask, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    \n    // Check if sorted in ascending order\n    for (size_t i = 0; i < n-1; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-1);\n        \n        // Load current and next elements\n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        \n        // Compare if current > next\n        vbool4_t mask = vmsgt_vv_i32m8_b4(v1, v2, vl);\n        \n        // If any comparison is true, array is not sorted\n        if (vmany_m_b4(mask, vl)) {\n            return false;\n        }\n    }\n    \n    // Check for more than 1 duplicate\n    for (size_t i = 0; i < n-2; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-2);\n        \n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        vint32m8_t v3 = vle32_v_i32m8(&lst[i+2], vl);\n        \n        // Check if 3 consecutive elements are equal\n        vbool4_t mask1 = vmseq_vv_i32m8_b4(v1, v2, vl);\n        vbool4_t mask2 = vmseq_vv_i32m8_b4(v2, v3, vl);\n        vbool4_t mask = vmand_mm_b4(mask1, mask2, vl);\n        \n        if (vmany_m_b4(mask, vl)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    \n    // Check if sorted in ascending order\n    for (size_t i = 0; i < n-1; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-1);\n        \n        // Load current and next elements\n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        \n        // Compare if current > next\n        vbool4_t mask = vmsgt_vv_i32m8_b4(v1, v2, vl);\n        \n        // If any element is greater than next, not sorted\n        if (vmany_m_b4(mask, vl)) {\n            return false;\n        }\n        \n        // Check for more than 1 duplicate\n        for (size_t j = i; j < std::min(i+vl, n-1); j++) {\n            int count = 1;\n            for (size_t k = j+1; k < n; k++) {\n                if (lst[j] == lst[k]) {\n                    count++;\n                    if (count > 2) return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t vlen = lst.size();\n    const int* ptr = lst.data();\n    \n    // Check if sorted in ascending order\n    bool is_sorted = true;\n    size_t index = 0;\n    \n    while (index < vlen-1) {\n        size_t vl = vsetvl_e32m8(vlen-1-index);\n        \n        vint32m8_t v1 = vle32_v_i32m8(ptr + index, vl);\n        vint32m8_t v2 = vle32_v_i32m8(ptr + index + 1, vl);\n        \n        vbool4_t mask = vmsleu_vv_i32m8_b4(v1, v2, vl);\n        if (!vmandfs_m_b4(mask, vl)) {\n            is_sorted = false;\n            break;\n        }\n        \n        index += vl;\n    }\n    \n    // Check for more than 1 duplicate\n    if (is_sorted) {\n        index = 0;\n        int count = 1;\n        int prev = lst[0];\n        \n        for (size_t i = 1; i < vlen; i++) {\n            if (lst[i] == prev) {\n                count++;\n                if (count > 2) return false;\n            } else {\n                count = 1;\n                prev = lst[i];\n            }\n        }\n    }\n    \n    return is_sorted;\n}\n```"}
{"task_id": "SimdBench_122_RVV", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t vlen = vsetvlmax_e32m8();\n    size_t n = lst.size();\n    \n    // Check if sorted in ascending order\n    for (size_t i = 0; i < n-1; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-1);\n        \n        // Load current and next elements\n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        \n        // Compare if v1 >= v2\n        vbool4_t mask = vmge_vv_i32m8_b4(v1, v2, vl);\n        \n        // If any element is greater or equal to next, not sorted\n        if (vfirst_m_b4(mask, vl) != -1) {\n            return false;\n        }\n    }\n    \n    // Check for more than 1 duplicate\n    for (size_t i = 0; i < n-2; i += vlen) {\n        size_t vl = vsetvl_e32m8(n-i-2);\n        \n        vint32m8_t v1 = vle32_v_i32m8(&lst[i], vl);\n        vint32m8_t v2 = vle32_v_i32m8(&lst[i+1], vl);\n        vint32m8_t v3 = vle32_v_i32m8(&lst[i+2], vl);\n        \n        // Check if three consecutive elements are equal\n        vbool4_t mask1 = vmseq_vv_i32m8_b4(v1, v2, vl);\n        vbool4_t mask2 = vmseq_vv_i32m8_b4(v2, v3, vl);\n        vbool4_t mask = vmand_mm_b4(mask1, mask2, vl);\n        \n        if (vfirst_m_b4(mask, vl) != -1) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    size_t vlen = arr.size();\n    const int *ptr = arr.data();\n    \n    int sign_prod = 1;\n    int sum_mag = 0;\n    \n    size_t vl;\n    vint32m1_t v_data;\n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vbool32_t v_mask;\n    \n    while (vlen > 0) {\n        vl = vsetvl_e32m1(vlen);\n        \n        v_data = vle32_v_i32m1(ptr, vl);\n        \n        // Check for zeros\n        v_mask = vmseq_vx_i32m1_b32(v_data, 0, vl);\n        if (vmany_m_b32(v_mask, vl)) {\n            sign_prod = 0;\n            break;\n        }\n        \n        // Get signs\n        v_mask = vmslt_vx_i32m1_b32(v_data, 0, vl);\n        int neg_count = vcpop_m_b32(v_mask, vl);\n        sign_prod *= (neg_count % 2 == 0) ? 1 : -1;\n        \n        // Get magnitudes\n        v_data = vabs_v_i32m1(v_data, vl);\n        int32_t temp_sum = vredsum_vs_i32m1_i32m1(v_zero, v_data, v_zero, vl);\n        sum_mag += temp_sum;\n        \n        ptr += vl;\n        vlen -= vl;\n    }\n    \n    return sign_prod * sum_mag;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int>& arr) {\n    if (arr.empty()) return -32768;\n    \n    size_t vlen = arr.size();\n    const int* ptr = arr.data();\n    \n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_sign = vmv_v_x_i32m1(1, 1);\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    size_t vl;\n    while (vlen > 0) {\n        vl = vsetvl_e32m1(vlen);\n        \n        vint32m1_t v_data = vle32_v_i32m1(ptr, vl);\n        \n        // Get signs (-1, 0, 1)\n        vbool32_t mask_neg = vmslt_vx_i32m1_b32(v_data, 0, vl);\n        vbool32_t mask_zero = vmseq_vx_i32m1_b32(v_data, 0, vl);\n        \n        vint32m1_t v_curr_sign = vmv_v_x_i32m1(1, vl);\n        v_curr_sign = vmerge_vvm_i32m1(mask_neg, v_curr_sign, vmv_v_x_i32m1(-1, vl), vl);\n        v_curr_sign = vmerge_vvm_i32m1(mask_zero, v_curr_sign, v_zero, vl);\n        \n        // Multiply running sign\n        v_sign = vmul_vv_i32m1(v_sign, v_curr_sign, vl);\n        \n        // Add magnitudes\n        v_data = vabs_v_i32m1(v_data, vl);\n        v_sum = vadd_vv_i32m1(v_sum, v_data, vl);\n        \n        ptr += vl;\n        vlen -= vl;\n    }\n    \n    // Reduce sum and get final sign\n    int total_sum = vredsum_vs_i32m1_i32m1(v_sum, v_sum, vl);\n    int final_sign = vmv_x_s_i32m1_i32(v_sign);\n    \n    return total_sum * final_sign;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    size_t vlen = arr.size();\n    const int* ptr = arr.data();\n    \n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_sign = vmv_v_x_i32m1(1, 1);\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    size_t vl;\n    while (vlen > 0) {\n        vl = vsetvl_e32m1(vlen);\n        \n        vint32m1_t v_input = vle32_v_i32m1(ptr, vl);\n        \n        // Get signs (-1, 0, 1)\n        vbool32_t mask_neg = vmslt_vx_i32m1_b32(v_input, 0, vl);\n        vbool32_t mask_zero = vmseq_vx_i32m1_b32(v_input, 0, vl);\n        \n        vint32m1_t v_curr_sign = vmv_v_x_i32m1(1, vl);\n        v_curr_sign = vmerge_vvm_i32m1(v_curr_sign, vmv_v_x_i32m1(-1, vl), mask_neg, vl);\n        v_curr_sign = vmerge_vvm_i32m1(v_curr_sign, v_zero, mask_zero, vl);\n        \n        // Multiply signs\n        v_sign = vmul_vv_i32m1(v_sign, v_curr_sign, vl);\n        \n        // Sum magnitudes\n        vint32m1_t v_abs = vabs_v_i32m1(v_input, vl);\n        v_sum = vadd_vv_i32m1(v_sum, v_abs, vl);\n        \n        ptr += vl;\n        vlen -= vl;\n    }\n    \n    // Reduce sign product and sum\n    int sign_prod = vmv_x_s_i32m1_i32(v_sign);\n    int magnitude_sum = vmv_x_s_i32m1_i32(v_sum);\n    \n    return sign_prod * magnitude_sum;\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    size_t vlen = arr.size();\n    const int* ptr = arr.data();\n    \n    int sign_prod = 1;\n    int sum_mag = 0;\n    \n    size_t vl;\n    vint32m1_t v_data;\n    vint32m1_t v_zero = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    vbool32_t v_mask;\n    \n    while (vlen > 0) {\n        vl = vsetvl_e32m1(vlen);\n        \n        v_data = vle32_v_i32m1(ptr, vl);\n        \n        // Check for zeros\n        v_mask = vmseq_vx_i32m1_b32(v_data, 0, vl);\n        if (vfirst_m_b32(v_mask, vl) != -1) {\n            return 0;\n        }\n        \n        // Get signs\n        v_mask = vmslt_vx_i32m1_b32(v_data, 0, vl);\n        int neg_count = vcpop_m_b32(v_mask, vl);\n        sign_prod *= (neg_count % 2 == 0) ? 1 : -1;\n        \n        // Get magnitudes\n        v_data = vabs_v_i32m1(v_data, vl);\n        v_sum = vredsum_vs_i32m1_i32m1(v_sum, v_data, v_zero, vl);\n        \n        ptr += vl;\n        vlen -= vl;\n    }\n    \n    return sign_prod * vmv_x_s_i32m1_i32(v_sum);\n}\n```"}
{"task_id": "SimdBench_123_RVV", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    size_t vlen = arr.size();\n    const int* ptr = arr.data();\n    \n    int sign_prod = 1;\n    int sum_mag = 0;\n    \n    size_t vl;\n    vint32m1_t v_data;\n    vint32m1_t v_zeros = vmv_v_x_i32m1(0, 1);\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    vbool32_t v_mask;\n    \n    while (vlen > 0) {\n        vl = vsetvl_e32m1(vlen);\n        \n        v_data = vle32_v_i32m1(ptr, vl);\n        \n        // Check for zeros\n        v_mask = vmseq_vx_i32m1_b32(v_data, 0, vl);\n        if (vmany_m_b32(v_mask, vl)) {\n            sign_prod = 0;\n            break;\n        }\n        \n        // Multiply sign product\n        v_mask = vmslt_vx_i32m1_b32(v_data, 0, vl);\n        sign_prod *= 1 - 2 * vfirst_m_b32(v_mask, vl) % 2;\n        \n        // Add magnitudes\n        v_data = vabs_v_i32m1(v_data, vl);\n        v_sum = vadd_vv_i32m1(v_sum, v_data, vl);\n        \n        ptr += vl;\n        vlen -= vl;\n    }\n    \n    // Reduce sum\n    sum_mag = vmv_x_s_i32m1_i32(v_sum);\n    \n    return sign_prod * sum_mag;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result(k);\n    std::vector<std::pair<int,int>> curr_path;\n    std::vector<int> min_path;\n    int min_path_found = 0;\n\n    // Helper function to check if coordinates are valid\n    auto isValid = [n](int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    };\n\n    // Directions: right, left, down, up\n    const int dx[] = {0, 0, 1, -1};\n    const int dy[] = {1, -1, 0, 0};\n\n    // DFS function\n    std::function<void(int,int)> dfs = [&](int x, int y) {\n        curr_path.push_back({x,y});\n        \n        if(curr_path.size() == k) {\n            std::vector<int> path_values;\n            size_t vl;\n            vsetvli_e32m8(&vl, k);\n            \n            // Get values along current path\n            for(const auto& p : curr_path) {\n                path_values.push_back(grid[p.first][p.second]);\n            }\n            \n            // If first valid path found or current path is lexicographically smaller\n            if(!min_path_found || path_values < min_path) {\n                min_path = path_values;\n                min_path_found = 1;\n            }\n            \n            curr_path.pop_back();\n            return;\n        }\n\n        // Try all 4 directions\n        for(int i = 0; i < 4; i++) {\n            int new_x = x + dx[i];\n            int new_y = y + dy[i];\n            \n            if(isValid(new_x, new_y)) {\n                dfs(new_x, new_y);\n            }\n        }\n        \n        curr_path.pop_back();\n    };\n\n    // Try all starting positions\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dfs(i,j);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result(k);\n    std::vector<std::vector<int>> dp(k, std::vector<int>(n * n, INT_MAX));\n    \n    // Initialize first step\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[0][i*n + j] = grid[i][j];\n        }\n    }\n    \n    // For each step\n    for(int step = 1; step < k; step++) {\n        size_t vl;\n        vint32m8_t v_min;\n        \n        // For each cell\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                int idx = i*n + j;\n                int curr_val = grid[i][j];\n                \n                // Get vector length\n                vl = vsetvlmax_e32m8();\n                v_min = vmv_v_x_i32m8(INT_MAX, vl);\n                \n                // Check neighbors\n                if(i > 0) { // Up\n                    vint32m8_t v_up = vle32_v_i32m8(&dp[step-1][(i-1)*n + j], 1);\n                    v_min = vmin_vv_i32m8(v_min, v_up, vl);\n                }\n                if(i < n-1) { // Down \n                    vint32m8_t v_down = vle32_v_i32m8(&dp[step-1][(i+1)*n + j], 1);\n                    v_min = vmin_vv_i32m8(v_min, v_down, vl);\n                }\n                if(j > 0) { // Left\n                    vint32m8_t v_left = vle32_v_i32m8(&dp[step-1][i*n + j-1], 1);\n                    v_min = vmin_vv_i32m8(v_min, v_left, vl);\n                }\n                if(j < n-1) { // Right\n                    vint32m8_t v_right = vle32_v_i32m8(&dp[step-1][i*n + j+1], 1);\n                    v_min = vmin_vv_i32m8(v_min, v_right, vl);\n                }\n                \n                // Store minimum value\n                int min_val;\n                vse32_v_i32m8(&min_val, v_min, 1);\n                if(min_val != INT_MAX) {\n                    dp[step][idx] = curr_val;\n                }\n            }\n        }\n    }\n    \n    // Find minimum path\n    int min_val = INT_MAX;\n    int min_idx = 0;\n    size_t vl = vsetvlmax_e32m8();\n    \n    for(int i = 0; i < n*n; i += vl) {\n        vl = vsetvl_e32m8(n*n - i);\n        vint32m8_t v_vals = vle32_v_i32m8(&dp[k-1][i], vl);\n        vbool4_t mask = vmflt_vx_i32m8_b4(v_vals, min_val, vl);\n        \n        if(vmany_m_b4(mask, vl)) {\n            vint32m8_t v_idx = vid_v_i32m8(vl);\n            vint32m8_t v_masked_idx = vmerge_vxm_i32m8(mask, vmv_v_x_i32m8(min_idx, vl), v_idx, vl);\n            min_idx = vmv_x_s_i32m8_i32(v_masked_idx);\n            min_val = dp[k-1][min_idx];\n        }\n    }\n    \n    // Reconstruct path\n    int curr_idx = min_idx;\n    result[k-1] = grid[curr_idx/n][curr_idx%n];\n    \n    for(int step = k-2; step >= 0; step--) {\n        int i = curr_idx/n;\n        int j = curr_idx%n;\n        int next_val = INT_MAX;\n        int next_idx = curr_idx;\n        \n        if(i > 0 && dp[step][(i-1)*n + j] < next_val) {\n            next_val = dp[step][(i-1)*n + j];\n            next_idx = (i-1)*n + j;\n        }\n        if(i < n-1 && dp[step][(i+1)*n + j] < next_val) {\n            next_val = dp[step][(i+1)*n + j];\n            next_idx = (i+1)*n + j;\n        }\n        if(j > 0 && dp[step][i*n + j-1] < next_val) {\n            next_val = dp[step][i*n + j-1];\n            next_idx = i*n + j-1;\n        }\n        if(j < n-1 && dp[step][i*n + j+1] < next_val) {\n            next_val = dp[step][i*n + j+1];\n            next_idx = i*n + j+1;\n        }\n        \n        curr_idx = next_idx;\n        result[step] = grid[curr_idx/n][curr_idx%n];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result(k);\n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<std::vector<std::vector<int>>> paths(n, std::vector<std::vector<int>>(n));\n    \n    // Initialize paths with first cell value\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            paths[i][j].push_back(grid[i][j]);\n        }\n    }\n\n    // Directions for neighbor cells\n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n    \n    // For each path length\n    for(int len = 1; len < k; len++) {\n        std::vector<std::vector<std::vector<int>>> new_paths(n, std::vector<std::vector<int>>(n));\n        \n        // Process rows in parallel using RVV\n        size_t vl;\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                std::vector<int> min_path = paths[i][j];\n                int min_next = INT_MAX;\n                \n                // Check all neighbors\n                for(int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    \n                    if(ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                        vint32m1_t v_curr, v_next;\n                        \n                        // Load current path and neighbor value\n                        vl = vsetvl_e32m1(len);\n                        v_curr = vle32_v_i32m1(&paths[i][j][0], vl);\n                        \n                        // Compare paths\n                        if(min_path.empty() || grid[ni][nj] < min_next) {\n                            min_next = grid[ni][nj];\n                            min_path = paths[i][j];\n                            min_path.push_back(grid[ni][nj]);\n                        }\n                    }\n                }\n                \n                new_paths[i][j] = min_path;\n            }\n        }\n        \n        paths = new_paths;\n    }\n    \n    // Find minimum path among all cells\n    std::vector<int> min_path;\n    int min_val = INT_MAX;\n    \n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            if(paths[i][j].size() == k) {\n                if(min_path.empty() || paths[i][j][0] < min_val) {\n                    min_val = paths[i][j][0];\n                    min_path = paths[i][j];\n                }\n            }\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<std::vector<int>> dp(n * n + 1, std::vector<int>(k + 1, INT_MAX));\n    std::vector<std::vector<std::vector<int>>> paths(n * n + 1, std::vector<std::vector<int>>(k + 1));\n    \n    // Initialize for k=1\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            int val = grid[i][j];\n            dp[val][1] = val;\n            paths[val][1] = {val};\n        }\n    }\n    \n    // For each length\n    for(int len = 2; len <= k; len++) {\n        // For each value\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                int curr = grid[i][j];\n                \n                // Get neighbors\n                const int dx[4] = {-1, 1, 0, 0};\n                const int dy[4] = {0, 0, -1, 1};\n                \n                size_t vl;\n                vint32m1_t vx, vy, vmask;\n                \n                // Process neighbors in parallel\n                vl = vsetvl_e32m1(4);\n                vx = vle32_v_i32m1(dx, vl);\n                vy = vle32_v_i32m1(dy, vl);\n                \n                // Create mask for valid neighbors\n                vbool32_t valid_x = vmsle_vx_i32m1_b32(vadd_vx_i32m1(vx, i, vl), n-1, vl);\n                vbool32_t valid_y = vmsle_vx_i32m1_b32(vadd_vx_i32m1(vy, j, vl), n-1, vl);\n                vbool32_t valid = vand_mm_b32(valid_x, valid_y, vl);\n                \n                // For each valid neighbor\n                for(int d = 0; d < 4; d++) {\n                    if(!vmfirst_m_b32(valid, vl)) continue;\n                    \n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    \n                    if(ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                        int nval = grid[ni][nj];\n                        \n                        if(dp[nval][len-1] != INT_MAX) {\n                            std::vector<int> new_path = paths[nval][len-1];\n                            new_path.push_back(curr);\n                            \n                            if(dp[curr][len] == INT_MAX || new_path < paths[curr][len]) {\n                                dp[curr][len] = curr;\n                                paths[curr][len] = new_path;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Find minimum path of length k\n    std::vector<int> min_path;\n    int min_val = INT_MAX;\n    \n    size_t vl = vsetvl_e32m1(n*n);\n    vint32m1_t vdp = vle32_v_i32m1(&dp[0][k], vl);\n    vint32m1_t vmin = vmmin_vv_i32m1(vdp, vdp, vl);\n    int min_idx = 0;\n    \n    for(int i = 1; i <= n*n; i++) {\n        if(dp[i][k] != INT_MAX && (min_val == INT_MAX || paths[i][k] < min_path)) {\n            min_val = dp[i][k];\n            min_path = paths[i][k];\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_RVV", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result(k);\n    std::vector<std::vector<int>> dp(n * n + 1, std::vector<int>(k + 1, INT_MAX));\n    \n    // Initialize dp for k=1\n    for(int i = 0; i < n; i++) {\n        for(int j = 0; j < n; j++) {\n            dp[grid[i][j]][1] = grid[i][j];\n        }\n    }\n\n    // For each length from 2 to k\n    for(int len = 2; len <= k; len++) {\n        for(int i = 0; i < n; i++) {\n            for(int j = 0; j < n; j++) {\n                int curr = grid[i][j];\n                \n                // Vector length\n                size_t vlen = vsetvlmax_e32m8();\n                \n                // Directions: up, right, down, left\n                int di[4] = {-1, 0, 1, 0};\n                int dj[4] = {0, 1, 0, -1};\n                \n                vint32m8_t vmin = vmv_v_x_i32m8(INT_MAX, vlen);\n                \n                // Process neighbors in parallel\n                for(int d = 0; d < 4; d += vlen) {\n                    size_t vl = vsetvl_e32m8(4 - d);\n                    \n                    // Load neighbor indices\n                    vint32m8_t vi = vadd_vx_i32m8(vle32_v_i32m8(&di[d], vl), i, vl);\n                    vint32m8_t vj = vadd_vx_i32m8(vle32_v_i32m8(&dj[d], vl), j, vl);\n                    \n                    // Check bounds\n                    vbool4_t vmask = vand_mm_b4(vmsge_vx_i32m8_b4(vi, 0, vl),\n                                               vmslt_vx_i32m8_b4(vi, n, vl), vl);\n                    vmask = vand_mm_b4(vmask, \n                                     vand_mm_b4(vmsge_vx_i32m8_b4(vj, 0, vl),\n                                              vmslt_vx_i32m8_b4(vj, n, vl), vl));\n                                              \n                    // Get neighbor values\n                    vint32m8_t vvals;\n                    under_vmask(vmask, vl) {\n                        vvals = vle32_v_i32m8(&dp[grid[vi[d]][vj[d]]][len-1], vl);\n                    }\n                    \n                    // Update minimum\n                    vmin = vmin_vv_i32m8(vmin, vvals, vl);\n                }\n                \n                // Reduce to find minimum\n                int min_val = vredmin_vs_i32m8_i32m1(vmin, vmin, vlen);\n                \n                if(min_val != INT_MAX) {\n                    dp[curr][len] = min(dp[curr][len], min_val);\n                }\n            }\n        }\n    }\n    \n    // Find minimum path\n    int min_val = INT_MAX;\n    int min_start = 0;\n    for(int i = 1; i <= n*n; i++) {\n        if(dp[i][k] < min_val) {\n            min_val = dp[i][k];\n            min_start = i;\n        }\n    }\n    \n    // Reconstruct path\n    result[0] = min_start;\n    int curr = min_start;\n    for(int len = k; len > 1; len--) {\n        min_val = INT_MAX;\n        int next = 0;\n        for(int i = 1; i <= n*n; i++) {\n            if(dp[i][len-1] < min_val) {\n                min_val = dp[i][len-1];\n                next = i;\n            }\n        }\n        result[k-len+1] = next;\n        curr = next;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to digits array\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize vector variables\n    size_t vl;\n    uint64_t result = 1;\n    bool has_odd = false;\n    \n    // Process digits in vector chunks\n    vint8m1_t v_digits;\n    vbool8_t v_mask;\n    \n    for (int i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        \n        // Load digits into vector\n        v_digits = vle8_v_i8m1(&digits[i], vl);\n        \n        // Create mask for odd digits\n        v_mask = vmslt_vx_i8m1_b8(vand_vx_i8m1(v_digits, 1, vl), 2, vl);\n        \n        // Extract odd digits\n        vint8m1_t v_odd = vcompress_vm_i8m1(v_digits, v_mask, vl);\n        \n        // Get number of odd digits found\n        size_t odd_count = vcpop_m_b8(v_mask, vl);\n        \n        // Multiply odd digits\n        for (size_t j = 0; j < odd_count; j++) {\n            uint8_t odd_digit = vmv_x_s_i8m1_i8(vslidedown_vx_i8m1(v_odd, j, vl));\n            if (odd_digit > 0) {\n                result *= odd_digit;\n                has_odd = true;\n            }\n        }\n    }\n\n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to digits array\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize vector variables\n    size_t vl;\n    vint8m1_t v_digits;\n    vbool8_t mask;\n    vint8m1_t v_ones = vmv_v_x_i8m1(1, len);\n    vint8m1_t v_result;\n    \n    // Load digits into vector\n    v_digits = vle8_v_i8m1(digits, len);\n    \n    // Create mask for odd digits\n    mask = vmslt_vx_i8m1_b8(vand_vx_i8m1(v_digits, 1, len), 1, len);\n    \n    // Set even digits to 1 to not affect product\n    v_result = vmerge_vxm_i8m1(mask, v_digits, 1, len);\n    \n    // Calculate product using vector reduction\n    int8_t prod = vredmul_vs_i8m1_i8m1(v_result, v_result, v_ones, len);\n    \n    // Return 0 if all digits were even\n    bool has_odd = false;\n    for(int i = 0; i < len; i++) {\n        if(digits[i] & 1) {\n            has_odd = true;\n            break;\n        }\n    }\n    \n    return has_odd ? prod : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    uint8_t digits[20];\n    int len = 0;\n    \n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    size_t vl;\n    uint64_t product = 1;\n    bool has_odd = false;\n    \n    vint8m1_t v_digits;\n    vbool8_t v_mask;\n    \n    for (int i = 0; i < len; i += vl) {\n        vl = vsetvl_e8m1(len - i);\n        \n        v_digits = vle8_v_i8m1(&digits[i], vl);\n        \n        // Create mask for odd digits\n        v_mask = vmslt_vx_i8m1_b8(vand_vx_i8m1(v_digits, 1, vl), 1, vl);\n        \n        // If any odd digits found\n        if (vmany_m_b8(v_mask, vl)) {\n            has_odd = true;\n            \n            // Multiply odd digits\n            vint8m1_t v_masked = vmerge_vxm_i8m1(v_digits, v_mask, 1, vl);\n            \n            for (size_t j = 0; j < vl; j++) {\n                uint8_t digit = v_masked[j];\n                if (digit & 1) {\n                    product *= digit;\n                }\n            }\n        }\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to array of digits\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize vector variables\n    size_t vl;\n    vint8m1_t v_digits;\n    vbool8_t mask;\n    vint8m1_t v_ones;\n    vint8m1_t v_result;\n    \n    // Load digits into vector\n    v_digits = vle8_v_i8m1(digits, len);\n    \n    // Create mask for odd digits\n    v_ones = vmv_v_x_i8m1(1, len);\n    mask = vand_vx_i8m1_b8(v_digits, 1, len);\n    \n    // Zero out even digits\n    v_result = vmerge_vxm_i8m1(mask, vmv_v_x_i8m1(0, len), v_digits, len);\n    \n    // Multiply odd digits\n    uint64_t result = 1;\n    uint8_t *temp = (uint8_t*)&v_result;\n    \n    bool has_odd = false;\n    for (int i = 0; i < len; i++) {\n        if (temp[i] > 0) {\n            result *= temp[i];\n            has_odd = true;\n        }\n    }\n    \n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_RVV", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to array of digits\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Initialize vector registers and set vector length\n    size_t vl;\n    vint8m1_t v_digits;\n    vbool8_t vmask;\n    vint8m1_t v_ones = vmv_v_x_i8m1(1, len);\n    vint8m1_t v_result;\n    \n    // Load digits into vector register\n    v_digits = vle8_v_i8m1(digits, len);\n    \n    // Create mask for odd digits\n    vmask = vmslt_vx_i8m1_b8(vand_vx_i8m1(v_digits, 1, len), 1, len);\n    \n    // Initialize result vector with 1s\n    v_result = vmv_v_x_i8m1(1, len);\n    \n    // Multiply only odd digits\n    v_result = vmerge_vvm_i8m1(vmask, v_result, v_digits, len);\n    \n    // Horizontal multiplication of result vector\n    uint64_t result = 1;\n    uint8_t *res_arr = (uint8_t*)&v_result;\n    \n    bool has_odd = false;\n    for (int i = 0; i < len; i++) {\n        if (digits[i] & 1) {\n            result *= digits[i];\n            has_odd = true;\n        }\n    }\n    \n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t vlen = lst.size();\n    const float* ptr = lst.data();\n    \n    uint64_t sum = 0;\n    size_t gvl;\n    \n    vfloat32m8_t v_data;\n    vfloat32m8_t v_ceil;\n    vint32m8_t v_int;\n    \n    for (size_t i = 0; i < vlen; i += gvl) {\n        gvl = vsetvl_e32m8(vlen - i);\n        \n        // Load vector data\n        v_data = vle32_v_f32m8(ptr + i, gvl);\n        \n        // Ceiling operation\n        v_ceil = vfcvt_f_x_v_f32m8(vfcvt_x_f_v_i32m8(v_data, gvl), gvl);\n        v_ceil = vfmax_vv_f32m8(v_ceil, v_data, gvl);\n        \n        // Convert to integer\n        v_int = vfcvt_x_f_v_i32m8(v_ceil, gvl);\n        \n        // Square and accumulate\n        for (size_t j = 0; j < gvl; j++) {\n            int32_t val = v_int[j];\n            sum += (uint64_t)(val * val);\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t vlen = lst.size();\n    const float* ptr = lst.data();\n    \n    uint64_t sum = 0;\n    size_t gvl;\n    \n    vfloat32m8_t v_data;\n    vfloat32m8_t v_ceil;\n    vfloat32m8_t v_square;\n    \n    for(size_t i = 0; i < vlen; i += gvl) {\n        gvl = vsetvl_e32m8(vlen - i);\n        \n        // Load vector data\n        v_data = vle32_v_f32m8(ptr + i, gvl);\n        \n        // Ceiling operation\n        v_ceil = vfcvt_f_x_v_f32m8(vfcvt_x_f_v_i32m8(v_data, VRM_RUP, gvl), gvl);\n        \n        // Square the values\n        v_square = vfmul_vv_f32m8(v_ceil, v_ceil, gvl);\n        \n        // Horizontal sum\n        sum += vfredsum_vs_f32m8_f32m1(vfmv_s_f_f32m1(vfloat32m1_t(), 0.f, 1),\n                                      v_square, \n                                      vfmv_s_f_f32m1(vfloat32m1_t(), 0.f, 1),\n                                      gvl);\n    }\n    \n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t vlen = lst.size();\n    const float* ptr = lst.data();\n    uint64_t sum = 0;\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    vfloat32m8_t v_zero = vfmv_v_f_f32m8(0.0f, vlmax);\n    \n    for(size_t i = 0; i < vlen; i += vlmax) {\n        size_t vl = vsetvl_e32m8(vlen - i);\n        \n        // Load vector\n        vfloat32m8_t v = vle32_v_f32m8(ptr + i, vl);\n        \n        // Ceiling operation\n        vfloat32m8_t v_ceil = vfcvt_f_x_v_f32m8(vfcvt_x_f_v_i32m8(v, vl), vl);\n        \n        // Square the values\n        vfloat32m8_t v_square = vfmul_vv_f32m8(v_ceil, v_ceil, vl);\n        \n        // Horizontal sum\n        vfloat32m1_t v_sum = vfredsum_vs_f32m8_f32m1(v_square, v_zero, vl);\n        \n        // Add to final sum\n        sum += (uint64_t)vfmv_f_s_f32m1_f32(v_sum);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t vlen = lst.size();\n    const float* ptr = lst.data();\n    \n    uint64_t sum = 0;\n    size_t gvl;\n    \n    vfloat32m1_t v_data;\n    vint32m1_t v_ceil;\n    vint32m1_t v_square;\n    \n    for(size_t i = 0; i < vlen; i += gvl) {\n        gvl = vsetvl_e32m1(vlen - i);\n        \n        // Load vector data\n        v_data = vle32_v_f32m1(ptr + i, gvl);\n        \n        // Ceil operation\n        v_ceil = vfcvt_x_f_v_i32m1(vfceil_v_f32m1(v_data, gvl), gvl);\n        \n        // Square the values\n        v_square = vmul_vv_i32m1(v_ceil, v_ceil, gvl);\n        \n        // Reduce sum\n        sum += vredsum_vs_i32m1_i32m1(v_square, v_square, vmv_v_x_i32m1(0, 1), gvl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_RVV", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t vlen = lst.size();\n    const float* ptr = lst.data();\n    \n    uint64_t sum = 0;\n    size_t gvl;\n    \n    vfloat32m1_t v_data;\n    vfloat32m1_t v_ceil;\n    vfloat32m1_t v_square;\n    \n    while (vlen > 0) {\n        gvl = vsetvl_e32m1(vlen);\n        \n        // Load vector data\n        v_data = vle32_v_f32m1(ptr, gvl);\n        \n        // Ceiling operation\n        v_ceil = vfcvt_f_x_v_f32m1(vfcvt_x_f_v_i32m1(v_data, VRM_RUP, gvl), gvl);\n        \n        // Square the values\n        v_square = vfmul_vv_f32m1(v_ceil, v_ceil, gvl);\n        \n        // Reduce sum\n        sum += vfredsum_vs_f32m1_f32m1(v_square, v_square, vfmv_v_f_f32m1(0.f, 1), gvl);\n        \n        ptr += gvl;\n        vlen -= gvl;\n    }\n    \n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    size_t n = arr.size();\n    if (n <= 1) return -1;\n\n    size_t vl;\n    size_t avl = n-1;\n    int result = -1;\n\n    const int* ptr = arr.data();\n    \n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t v1 = vle32_v_i32m8(ptr, vl);\n        vint32m8_t v2 = vle32_v_i32m8(ptr + 1, vl);\n        \n        vbool4_t mask = vmsleu_vv_i32m8_b4(v2, v1, vl);\n        \n        if (vmfirst_m_b4(mask) != -1) {\n            int index = vmfirst_m_b4(mask);\n            result = index + (ptr - arr.data()) + 1;\n            break;\n        }\n        \n        ptr += vl;\n        avl -= vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    size_t n = arr.size();\n    if (n <= 1) return -1;\n\n    size_t vl;\n    size_t avl = n-1;\n    int result = -1;\n    \n    const int* ptr = arr.data();\n    \n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t v1 = vle32_v_i32m8(ptr, vl);\n        vint32m8_t v2 = vle32_v_i32m8(ptr + 1, vl);\n        \n        vbool4_t mask = vmsltu_vv_i32m8_b4(v2, v1, vl);\n        \n        int first_true = vfirst_m_b4(mask, vl);\n        \n        if (first_true != -1) {\n            result = first_true + (n - 1 - avl);\n            break;\n        }\n        \n        ptr += vl;\n        avl -= vl;\n    }\n    \n    return result >= 0 ? result + 1 : -1;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    size_t n = arr.size();\n    if (n <= 1) return -1;\n\n    size_t vl;\n    size_t avl = n-1;\n    int result = -1;\n    \n    const int* ptr = arr.data();\n    \n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t v1 = vle32_v_i32m8(ptr, vl);\n        vint32m8_t v2 = vle32_v_i32m8(ptr + 1, vl);\n        \n        vbool4_t mask = vmsleu_vv_i32m8_b4(v2, v1, vl);\n        \n        if (vmfirst_m_b4(mask) != -1) {\n            result = vmfirst_m_b4(mask) + (n - 1 - avl);\n            break;\n        }\n        \n        ptr++;\n        avl--;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    size_t n = arr.size();\n    if (n <= 1) return -1;\n\n    size_t vl;\n    size_t avl = n-1;\n    int result = -1;\n\n    const int* ptr = arr.data();\n    \n    while (avl > 0) {\n        vl = vsetvl_e32m8(avl);\n        \n        vint32m8_t v1 = vle32_v_i32m8(ptr, vl);\n        vint32m8_t v2 = vle32_v_i32m8(ptr + 1, vl);\n        \n        vbool4_t mask = vmsleu_vv_i32m8_b4(v2, v1, vl);\n        \n        if (vmfirst_m_b4(mask) != -1) {\n            result = vmfirst_m_b4(mask) + (ptr - arr.data());\n            break;\n        }\n        \n        ptr += vl;\n        avl -= vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_RVV", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    size_t vlen = arr.size();\n    if (vlen <= 1) return -1;\n\n    size_t i;\n    vint32m1_t v1, v2;\n    vbool32_t mask;\n    size_t gvl;\n\n    for (i = 0; i < vlen-1; i += gvl) {\n        gvl = vsetvl_e32m1(vlen-1-i);\n        \n        // Load vectors with offset of 1 between them\n        v1 = vle32_v_i32m1(&arr[i], gvl);\n        v2 = vle32_v_i32m1(&arr[i+1], gvl);\n        \n        // Compare if next element is less than current\n        mask = vmslt_vv_i32m1_b32(v2, v1, gvl);\n        \n        // Find first true in mask\n        if (vfirst_m_b32(mask, gvl) != -1) {\n            return i + vfirst_m_b32(mask, gvl) + 1;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_max_neg = vmv_v_x_i32m1(INT32_MIN, vlen);\n    vint32m1_t v_min_pos = vmv_v_x_i32m1(INT32_MAX, vlen);\n    vbool32_t v_found_neg = vmclr_m_b32(vlen);\n    vbool32_t v_found_pos = vmclr_m_b32(vlen);\n\n    size_t vl;\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        vl = vsetvl_e32m1(lst.size() - i);\n        vint32m1_t v_input = vle32_v_i32m1(&lst[i], vl);\n\n        vbool32_t v_neg = vmslt_vx_i32m1_b32(v_input, 0, vl);\n        vbool32_t v_pos = vmsgt_vx_i32m1_b32(v_input, 0, vl);\n\n        v_max_neg = vmax_vv_i32m1_m(v_neg, v_max_neg, v_max_neg, v_input, vl);\n        v_min_pos = vmin_vv_i32m1_m(v_pos, v_min_pos, v_min_pos, v_input, vl);\n\n        v_found_neg = vmor_mm_b32(v_found_neg, v_neg, vl);\n        v_found_pos = vmor_mm_b32(v_found_pos, v_pos, vl);\n    }\n\n    int max_neg = 0;\n    int min_pos = 0;\n\n    if (vfirst_m_b32(v_found_neg, vlen) != -1) {\n        max_neg = vmv_x_s_i32m1_i32(v_max_neg);\n    }\n    if (vfirst_m_b32(v_found_pos, vlen) != -1) {\n        min_pos = vmv_x_s_i32m1_i32(v_min_pos);\n    }\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_neg_max = vmv_v_x_i32m1(INT32_MIN, vlen);\n    vint32m1_t v_pos_min = vmv_v_x_i32m1(INT32_MAX, vlen);\n    \n    size_t n = lst.size();\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e32m1(n - i);\n        vint32m1_t v_input = vle32_v_i32m1(&lst[i], vl);\n        \n        // Create masks for negative and positive numbers\n        vbool32_t neg_mask = vmslt_vx_i32m1_b32(v_input, 0, vl);\n        vbool32_t pos_mask = vmsgt_vx_i32m1_b32(v_input, 0, vl);\n        \n        // Update max negative number\n        v_neg_max = vmax_vv_i32m1_m(neg_mask, v_neg_max, v_neg_max, v_input, vl);\n        \n        // Update min positive number\n        v_pos_min = vmin_vv_i32m1_m(pos_mask, v_pos_min, v_pos_min, v_input, vl);\n    }\n    \n    // Reduce to find final results\n    int neg_max = 0;\n    int pos_min = 0;\n    \n    // Only update if we found valid values\n    if (vredmaxu_vs_i32m1_i32m1(v_neg_max, v_neg_max, vlen) > INT32_MIN) {\n        neg_max = vmv_x_s_i32m1_i32(v_neg_max);\n    }\n    \n    if (vredminu_vs_i32m1_i32m1(v_pos_min, v_pos_min, vlen) < INT32_MAX) {\n        pos_min = vmv_x_s_i32m1_i32(v_pos_min);\n    }\n    \n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_max_neg = vmv_v_x_i32m1(INT32_MIN, vlen);\n    vint32m1_t v_min_pos = vmv_v_x_i32m1(INT32_MAX, vlen);\n    vbool32_t v_found_neg = vmclr_m_b32(vlen);\n    vbool32_t v_found_pos = vmclr_m_b32(vlen);\n\n    size_t vl;\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        vl = vsetvl_e32m1(lst.size() - i);\n        vint32m1_t v_input = vle32_v_i32m1(&lst[i], vl);\n\n        vbool32_t v_neg = vmslt_vx_i32m1_b32(v_input, 0, vl);\n        vbool32_t v_pos = vmsgt_vx_i32m1_b32(v_input, 0, vl);\n\n        v_found_neg = vmor_mm_b32(v_found_neg, v_neg, vl);\n        v_found_pos = vmor_mm_b32(v_found_pos, v_pos, vl);\n\n        v_max_neg = vmax_vv_i32m1_m(v_neg, v_max_neg, v_input, v_max_neg, vl);\n        v_min_pos = vmin_vv_i32m1_m(v_pos, v_min_pos, v_input, v_min_pos, vl);\n    }\n\n    int max_neg = 0;\n    int min_pos = 0;\n\n    if (vcpop_m_b32(v_found_neg, vlen) > 0) {\n        max_neg = vmv_x_s_i32m1_i32(v_max_neg);\n    }\n    if (vcpop_m_b32(v_found_pos, vlen) > 0) {\n        min_pos = vmv_x_s_i32m1_i32(v_min_pos);\n    }\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_max_neg = vmv_v_x_i32m1(INT32_MIN, vlen);\n    vint32m1_t v_min_pos = vmv_v_x_i32m1(INT32_MAX, vlen);\n    vbool32_t v_found_neg = vmclr_m_b32(vlen);\n    vbool32_t v_found_pos = vmclr_m_b32(vlen);\n\n    size_t vl;\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        vl = vsetvl_e32m1(lst.size() - i);\n        vint32m1_t v_input = vle32_v_i32m1(&lst[i], vl);\n\n        vbool32_t v_is_neg = vmslt_vx_i32m1_b32(v_input, 0, vl);\n        vbool32_t v_is_pos = vmsgt_vx_i32m1_b32(v_input, 0, vl);\n\n        v_max_neg = vmax_vv_i32m1_m(v_is_neg, v_max_neg, v_max_neg, v_input, vl);\n        v_min_pos = vmin_vv_i32m1_m(v_is_pos, v_min_pos, v_min_pos, v_input, vl);\n\n        v_found_neg = vmor_mm_b32(v_found_neg, v_is_neg, vl);\n        v_found_pos = vmor_mm_b32(v_found_pos, v_is_pos, vl);\n    }\n\n    int max_neg = 0;\n    int min_pos = 0;\n\n    if (vfirst_m_b32(v_found_neg, vlen) != -1) {\n        max_neg = vmv_x_s_i32m1_i32(v_max_neg);\n    }\n    if (vfirst_m_b32(v_found_pos, vlen) != -1) {\n        min_pos = vmv_x_s_i32m1_i32(v_min_pos);\n    }\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_RVV", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_max_neg = vmv_v_x_i32m1(INT32_MIN, vlen);\n    vint32m1_t v_min_pos = vmv_v_x_i32m1(INT32_MAX, vlen);\n    \n    size_t n = lst.size();\n    size_t i;\n    \n    for (i = 0; i < n; i += vlen) {\n        vlen = vsetvl_e32m1(n - i);\n        vint32m1_t v_input = vle32_v_i32m1(&lst[i], vlen);\n        \n        // Create masks for negative and positive numbers\n        vbool32_t neg_mask = vmslt_vx_i32m1_b32(v_input, 0, vlen);\n        vbool32_t pos_mask = vmsgt_vx_i32m1_b32(v_input, 0, vlen);\n        \n        // Update max negative under mask\n        v_max_neg = vmax_vv_i32m1_m(neg_mask, v_max_neg, v_max_neg, v_input, vlen);\n        \n        // Update min positive under mask\n        v_min_pos = vmin_vv_i32m1_m(pos_mask, v_min_pos, v_min_pos, v_input, vlen);\n    }\n    \n    // Horizontal reduction to find final results\n    int max_neg = 0;\n    int min_pos = 0;\n    \n    // Only update if we found valid values\n    if (vredmaxu_vs_i32m1_i32m1(v_max_neg, v_max_neg, vlen) > INT32_MIN) {\n        max_neg = vredmax_vs_i32m1_i32m1(v_max_neg, v_max_neg, vlen);\n    }\n    \n    if (vredminu_vs_i32m1_i32m1(v_min_pos, v_min_pos, vlen) < INT32_MAX) {\n        min_pos = vredmin_vs_i32m1_i32m1(v_min_pos, v_min_pos, vlen);\n    }\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    size_t vl;\n    \n    // Initialize vector of factorials from 1 to n\n    vint64m8_t v_nums;\n    vint64m8_t v_facts = vmv_v_x_i64m8(1, n); // Initialize with 1s\n    \n    // Calculate factorials for each number 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        vl = vsetvl_e64m8(n);\n        v_nums = vid_v_i64m8(vl);  // Generate index vector\n        v_nums = vadd_vx_i64m8(v_nums, 1, vl); // Add 1 to get 1-based index\n        \n        // Mask for elements <= i\n        vbool8_t mask = vmsleu_vx_i64m8_b8(v_nums, i, vl);\n        \n        // Multiply factorials by i where mask is true\n        v_facts = vmul_vx_i64m8_m(mask, v_facts, v_facts, i, vl);\n    }\n    \n    // Multiply all factorials together\n    for (uint64_t i = 0; i < n; i++) {\n        result *= vgetelem_i64m8(v_facts, i);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    size_t vlen = vsetvlmax_e64m8();\n    uint64_t result = 1;\n    \n    // Pre-calculate factorials from 1 to n\n    uint64_t factorials[n+1];\n    factorials[0] = 1;\n    factorials[1] = 1;\n    \n    for(uint64_t i = 2; i <= n; i++) {\n        factorials[i] = factorials[i-1] * i;\n    }\n    \n    // Multiply all factorials from 1 to n\n    vint64m8_t v_result = vmv_v_x_i64m8(1, vlen);\n    \n    for(uint64_t i = 0; i < n; i += vlen) {\n        size_t vl = vsetvl_e64m8(n - i);\n        vint64m8_t v_fact = vle64_v_i64m8(&factorials[i+1], vl);\n        v_result = vmul_vv_i64m8(v_result, v_fact, vl);\n    }\n    \n    // Reduce vector to scalar\n    uint64_t temp[vlen];\n    vse64_v_i64m8(temp, v_result, vlen);\n    \n    for(size_t i = 0; i < vlen; i++) {\n        result *= temp[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    size_t vl;\n    \n    // Vector of factorials from 1! to n!\n    uint64_t factorials[n];\n    factorials[0] = 1;\n    \n    // Calculate factorials using vector operations\n    vint64m8_t v_fact = vmv_v_x_i64m8(1, n);\n    for(size_t i = 1; i <= n; i++) {\n        vl = vsetvl_e64m8(n-i+1);\n        v_fact = vmul_vx_i64m8(v_fact, i, vl);\n        vse64_v_i64m8(&factorials[i-1], v_fact, vl);\n    }\n    \n    // Multiply all factorials together\n    vint64m8_t v_result = vmv_v_x_i64m8(1, n);\n    vl = vsetvl_e64m8(n);\n    v_result = vmul_vv_i64m8(v_result, vle64_v_i64m8(factorials, vl), vl);\n    \n    // Reduce vector to scalar\n    for(size_t i = 0; i < n; i++) {\n        result *= factorials[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    size_t vl;\n    \n    // Initialize vector of factorials from 1 to n\n    uint64_t factorials[n];\n    factorials[0] = 1;\n    \n    // Calculate factorials using vector operations\n    vuint64m8_t v_fact = vmv_v_x_u64m8(1, n);\n    vuint64m8_t v_idx = vid_v_u64m8(n);\n    \n    for(size_t i = 1; i <= n; i++) {\n        vl = vsetvl_e64m8(n-i+1);\n        v_fact = vmul_vx_u64m8(v_fact, i, vl);\n        vse64_v_u64m8(factorials + i - 1, v_fact, vl);\n    }\n    \n    // Multiply all factorials together\n    vuint64m8_t v_result = vmv_v_x_u64m8(1, n);\n    vl = vsetvl_e64m8(n);\n    \n    for(size_t i = 0; i < n; i++) {\n        v_result = vmul_vx_u64m8(v_result, factorials[i], vl);\n    }\n    \n    // Reduce vector to scalar\n    vuint64m1_t v_reduced;\n    for(size_t i = 0; i < n; i++) {\n        vl = vsetvl_e64m8(1);\n        uint64_t temp;\n        vse64_v_u64m1(&temp, vget_v_u64m8_u64m1(v_result, i), vl);\n        result *= temp;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_RVV", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) return 1;\n    \n    uint64_t result = 1;\n    size_t vlen = vsetvlmax_e64m8();\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        uint64_t nums[vlen];\n        size_t vlength = vsetvl_e64m8(i);\n        \n        for (size_t j = 0; j < i; j += vlength) {\n            vlength = vsetvl_e64m8(i - j);\n            for (size_t k = 0; k < vlength; k++) {\n                nums[k] = j + k + 1;\n            }\n            \n            vuint64m8_t v_nums = vle64_v_u64m8(nums, vlength);\n            vuint64m8_t v_fact = vmul_vx_u64m8(v_nums, factorial, vlength);\n            \n            factorial = 1;\n            for (size_t k = 0; k < vlength; k++) {\n                factorial *= ((uint64_t*)&v_fact)[k];\n            }\n        }\n        \n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t i = 0;\n    \n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m1(avl);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i, vl);\n        \n        vbool32_t mask3 = vmsne_vx_i32m1_b32((vdivu_vx_i32m1(v_idx, 3, vl)), 0, vl);\n        vbool32_t mask4 = vmsne_vx_i32m1_b32((vdivu_vx_i32m1(v_idx, 4, vl)), 0, vl);\n        \n        vint32m1_t v_squares = vmul_vv_i32m1(v_data, v_data, vl);\n        vint32m1_t v_cubes = vmul_vv_i32m1(v_squares, v_data, vl);\n        \n        v_data = vmerge_vvm_i32m1(mask3, v_data, v_squares, vl);\n        v_data = vmerge_vvm_i32m1(mask4, v_data, v_cubes, vl);\n        \n        v_sum = vadd_vv_i32m1(v_sum, v_data, vl);\n        \n        i += vl;\n    }\n    \n    vint32m1_t v_red = vredsum_vs_i32m1_i32m1(v_sum, v_sum, vmv_v_x_i32m1(0, 1), vlen);\n    sum = vmv_x_s_i32m1_i32(v_red);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t i;\n\n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        vbool32_t mask3 = vmseq_vx_i32m1_b32((vint32m1_t)vmod_vx_u32m1(vid_v_u32m1(vl), 3, vl), 0, vl);\n        vbool32_t mask4 = vmseq_vx_i32m1_b32((vint32m1_t)vmod_vx_u32m1(vid_v_u32m1(vl), 4, vl), 0, vl);\n        \n        vint32m1_t v_squared = vmul_vv_i32m1(v_data, v_data, vl);\n        vint32m1_t v_cubed = vmul_vv_i32m1(v_squared, v_data, vl);\n        \n        v_data = vmerge_vvm_i32m1(mask3, v_data, v_squared, vl);\n        vbool32_t mask4_not3 = vmandn_mm_b32(mask4, mask3, vl);\n        v_data = vmerge_vvm_i32m1(mask4_not3, v_data, v_cubed, vl);\n        \n        v_sum = vredsum_vs_i32m1_i32m1(v_sum, v_data, v_sum, vl);\n    }\n    \n    sum = vmv_x_s_i32m1_i32(v_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t i;\n\n    // Get vector length\n    size_t vlmax = vsetvlmax_e32m8();\n    \n    // Create vectors for storing results\n    vint32m8_t v_data, v_result;\n    vbool4_t mask3, mask4;\n    \n    for (i = 0; i < vlen; i += vlmax) {\n        // Set vector length for remaining elements\n        size_t vl = vsetvl_e32m8(vlen - i);\n        \n        // Load data into vector register\n        v_data = vle32_v_i32m8(&lst[i], vl);\n        \n        // Create index vector\n        vint32m8_t v_idx = vid_v_i32m8(vl);\n        v_idx = vadd_vx_i32m8(v_idx, i, vl);\n        \n        // Create masks for multiples of 3 and 4\n        mask3 = vmseq_vx_i32m8_b4((vrem_vx_i32m8(v_idx, 3, vl)), 0, vl);\n        mask4 = vmseq_vx_i32m8_b4((vrem_vx_i32m8(v_idx, 4, vl)), 0, vl);\n        \n        // Square elements at indices divisible by 3\n        vint32m8_t v_squared = vmul_vv_i32m8(v_data, v_data, vl);\n        v_result = vmerge_vvm_i32m8(mask3, v_data, v_squared, vl);\n        \n        // Cube elements at indices divisible by 4 but not by 3\n        vint32m8_t v_cubed = vmul_vv_i32m8(v_squared, v_data, vl);\n        vbool4_t mask4_not3 = vmandnot_mm_b4(mask4, mask3, vl);\n        v_result = vmerge_vvm_i32m8(mask4_not3, v_result, v_cubed, vl);\n        \n        // Reduce sum\n        sum += vredsum_vs_i32m8_i32m1(v_result, v_result, vl);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t i = 0;\n    \n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m1(avl);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        vint32m1_t v_idx = vid_v_i32m1(vl);\n        v_idx = vadd_vx_i32m1(v_idx, i, vl);\n        \n        vbool32_t mask3 = vmsne_vx_i32m1_b32((vremu_vx_i32m1(v_idx, 3, vl)), 0, vl);\n        vbool32_t mask4 = vmsne_vx_i32m1_b32((vremu_vx_i32m1(v_idx, 4, vl)), 0, vl);\n        \n        vint32m1_t v_squares = vmul_vv_i32m1(v_data, v_data, vl);\n        vint32m1_t v_cubes = vmul_vv_i32m1(v_squares, v_data, vl);\n        \n        vint32m1_t v_result = v_data;\n        v_result = vmerge_vvm_i32m1(mask3, v_result, v_squares, vl);\n        \n        vbool32_t mask_cube = vmand_mm_b32(vmnot_m_b32(mask3, vl), vmnot_m_b32(mask4, vl), vl);\n        v_result = vmerge_vvm_i32m1(mask_cube, v_result, v_cubes, vl);\n        \n        v_sum = vadd_vv_i32m1(v_sum, v_result, vl);\n        \n        i += vl;\n    }\n    \n    sum = vredsum_vs_i32m1_i32m1(v_sum, v_sum, vsetvl_e32m1(1));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_RVV", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    int sum = 0;\n    size_t i = 0;\n    \n    vint32m1_t v_sum = vmv_v_x_i32m1(0, 1);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        size_t vl = vsetvl_e32m1(avl);\n        \n        vint32m1_t v_data = vle32_v_i32m1(&lst[i], vl);\n        \n        vbool32_t mask3 = vmseq_vx_i32m1_b32((vint32m1_t)vmod_vx_u32m1(vid_v_u32m1(vl), 3, vl), 0, vl);\n        vbool32_t mask4 = vmseq_vx_i32m1_b32((vint32m1_t)vmod_vx_u32m1(vid_v_u32m1(vl), 4, vl), 0, vl);\n        \n        vint32m1_t v_squared = vmul_vv_i32m1(v_data, v_data, vl);\n        vint32m1_t v_cubed = vmul_vv_i32m1(v_squared, v_data, vl);\n        \n        v_data = vmerge_vvm_i32m1(mask3, v_data, v_squared, vl);\n        vbool32_t mask4_not3 = vmandn_mm_b32(mask4, mask3, vl);\n        v_data = vmerge_vvm_i32m1(mask4_not3, v_data, v_cubed, vl);\n        \n        v_sum = vadd_vv_i32m1(v_sum, v_data, vl);\n        \n        i += vl;\n    }\n    \n    sum = vredsum_vs_i32m1_i32m1(v_sum, v_sum, vmv_v_x_i32m1(0, 1), vsetvl_e32m1(1));\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t vlen = nums.size();\n    int count = 0;\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    \n    for(size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        vint32m8_t v_nums = vle32_v_i32m8(&nums[count], vl);\n        \n        // Check if > 10\n        vbool4_t mask = vmsgt_vx_i32m8_b4(v_nums, 10, vl);\n        \n        // Get first digit\n        vint32m8_t v_temp = v_nums;\n        vint32m8_t v_abs = vabs_v_i32m8(v_temp, vl);\n        \n        while(1) {\n            vbool4_t big = vmsgt_vx_i32m8_b4(v_abs, 9, vl);\n            v_abs = vdiv_vx_i32m8_m(big, v_abs, v_abs, 10, vl);\n            if(vmfirst_m_b4(big, vl) < 0) break;\n        }\n        vint32m8_t first_digit = v_abs;\n        \n        // Get last digit\n        v_abs = vabs_v_i32m8(v_temp, vl);\n        vint32m8_t last_digit = vrem_vx_i32m8(v_abs, 10, vl);\n        \n        // Check if first and last digits are odd\n        vbool4_t first_odd = vmsne_vx_i32m8_b4(vrem_vx_i32m8(first_digit, 2, vl), 0, vl);\n        vbool4_t last_odd = vmsne_vx_i32m8_b4(vrem_vx_i32m8(last_digit, 2, vl), 0, vl);\n        \n        // Combine all conditions\n        mask = vmand_mm_b4(mask, first_odd, vl);\n        mask = vmand_mm_b4(mask, last_odd, vl);\n        \n        count += vcpop_m_b4(mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t vlen = nums.size();\n    int count = 0;\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    \n    for(size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        vint32m8_t v_nums = vle32_v_i32m8(&nums[nums.size() - vlen], vl);\n        \n        // Check if > 10\n        vbool4_t mask1 = vmgt_vx_i32m8_b4(v_nums, 10, vl);\n        \n        // Get first digit\n        vint32m8_t v_temp = v_nums;\n        vint32m8_t v_first = v_nums;\n        \n        // Keep dividing by 10 until single digit\n        for(int i = 0; i < 9; i++) {\n            vbool4_t big_nums = vmgt_vx_i32m8_b4(v_temp, 9, vl);\n            v_temp = vdiv_vx_i32m8_m(big_nums, v_temp, v_temp, 10, vl);\n            v_first = vmerge_vvm_i32m8(big_nums, v_first, v_temp, vl);\n        }\n        \n        // Get last digit\n        vint32m8_t v_last = vrem_vx_i32m8(v_nums, 10, vl);\n        \n        // Make positive\n        v_last = vabs_v_i32m8(v_last, vl);\n        v_first = vabs_v_i32m8(v_first, vl);\n        \n        // Check if first digit is odd\n        vint32m8_t v_rem_first = vrem_vx_i32m8(v_first, 2, vl);\n        vbool4_t mask2 = vmseq_vx_i32m8_b4(v_rem_first, 1, vl);\n        \n        // Check if last digit is odd\n        vint32m8_t v_rem_last = vrem_vx_i32m8(v_last, 2, vl);\n        vbool4_t mask3 = vmseq_vx_i32m8_b4(v_rem_last, 1, vl);\n        \n        // Combine masks\n        vbool4_t final_mask = vmand_mm_b4(mask1, vmand_mm_b4(mask2, mask3, vl), vl);\n        \n        // Count matches\n        count += vcpop_m_b4(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t vlen = nums.size();\n    int count = 0;\n    size_t i;\n\n    vint32m1_t v_ten = vmv_v_x_i32m1(10, 1);\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        \n        vint32m1_t v_nums = vle32_v_i32m1(&nums[i], vl);\n        \n        // Check if greater than 10\n        vbool32_t mask = vmsgt_vx_i32m1_b32(v_nums, 10, vl);\n        \n        // Get first digit\n        vint32m1_t v_abs = vabs_v_i32m1(v_nums, vl);\n        vint32m1_t v_first = v_abs;\n        \n        // Keep dividing by 10 until we get first digit\n        for(int j = 0; j < 9; j++) {\n            vbool32_t big_nums = vmsgt_vx_i32m1_b32(v_first, 9, vl);\n            vint32m1_t v_div = vdiv_vx_i32m1(v_first, 10, vl);\n            v_first = vmerge_vvm_i32m1(big_nums, v_first, v_div, vl);\n        }\n        \n        // Get last digit\n        vint32m1_t v_last = vrem_vx_i32m1(v_abs, 10, vl);\n        \n        // Check if first and last digits are odd\n        vbool32_t first_odd = vmsne_vx_i32m1_b32(vrem_vx_i32m1(v_first, 2, vl), 0, vl);\n        vbool32_t last_odd = vmsne_vx_i32m1_b32(vrem_vx_i32m1(v_last, 2, vl), 0, vl);\n        \n        // Combine all conditions\n        mask = vmand_mm_b32(mask, first_odd, vl);\n        mask = vmand_mm_b32(mask, last_odd, vl);\n        \n        // Count true values in mask\n        count += vcpop_m_b32(mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t vlen = nums.size();\n    int count = 0;\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    \n    for(size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        vint32m8_t v_nums = vle32_v_i32m8(&nums[nums.size() - vlen], vl);\n        \n        // Check if > 10\n        vbool4_t mask = vmsgt_vx_i32m8_b4(v_nums, 10, vl);\n        \n        // Get first digit\n        vint32m8_t v_temp = v_nums;\n        while(1) {\n            vbool4_t big = vmsgt_vx_i32m8_b4(v_temp, 9, vl);\n            v_temp = vdiv_vx_i32m8_m(big, v_temp, v_temp, 10, vl);\n            if(vmfirst_m_b4(big, vl) < 0) break;\n        }\n        vint32m8_t first_digit = v_temp;\n        \n        // Get last digit\n        vint32m8_t last_digit = vrem_vx_i32m8(v_nums, 10, vl);\n        \n        // Check if first digit is odd\n        vbool4_t first_odd = vmsne_vx_i32m8_b4(vand_vx_i32m8(first_digit, 1, vl), 0, vl);\n        \n        // Check if last digit is odd  \n        vbool4_t last_odd = vmsne_vx_i32m8_b4(vand_vx_i32m8(last_digit, 1, vl), 0, vl);\n        \n        // Combine all conditions\n        mask = vmand_mm_b4(mask, first_odd, vl);\n        mask = vmand_mm_b4(mask, last_odd, vl);\n        \n        // Count matches\n        count += vcpop_m_b4(mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_RVV", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    size_t vlen = nums.size();\n    int count = 0;\n    \n    size_t vlmax = vsetvlmax_e32m8();\n    \n    for(size_t vl; vlen > 0; vlen -= vl) {\n        vl = vsetvl_e32m8(vlen);\n        \n        vint32m8_t v_nums = vle32_v_i32m8(&nums[nums.size() - vlen], vl);\n        \n        // Check if > 10\n        vbool4_t mask1 = vmgt_vx_i32m8_b4(v_nums, 10, vl);\n        \n        // Get first digit\n        vint32m8_t v_temp = v_nums;\n        vint32m8_t v_first = v_nums;\n        \n        // Keep dividing by 10 until single digit\n        for(int i = 0; i < 9; i++) {\n            v_first = vdiv_vx_i32m8(v_first, 10, vl);\n            vbool4_t continue_mask = vmgt_vx_i32m8_b4(v_first, 9, vl);\n            v_temp = v_first;\n            v_first = vmerge_vxm_i32m8(continue_mask, v_first, v_temp, vl);\n        }\n        \n        // Get last digit\n        vint32m8_t v_last = vrem_vx_i32m8(v_nums, 10, vl);\n        \n        // Check if first digit is odd\n        vint32m8_t v_first_rem = vrem_vx_i32m8(v_first, 2, vl);\n        vbool4_t mask2 = vmseq_vx_i32m8_b4(v_first_rem, 1, vl);\n        \n        // Check if last digit is odd\n        vint32m8_t v_last_rem = vrem_vx_i32m8(v_last, 2, vl);\n        vbool4_t mask3 = vmseq_vx_i32m8_b4(v_last_rem, 1, vl);\n        \n        // Combine all conditions\n        vbool4_t final_mask = vmand_mm_b4(mask1, vmand_mm_b4(mask2, mask3, vl), vl);\n        \n        // Count elements meeting all conditions\n        count += vcpop_m_b4(final_mask, vl);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate vector array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    size_t vl;\n    uint64_t count = 0;\n    \n    // Generate array values using vector operations\n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        \n        // Generate index vector\n        vint64m8_t vidx = vid_v_i64m8(vl);\n        vint64m8_t voffset = vadd_vx_i64m8(vidx, i + 1, vl);\n        \n        // Calculate a[i] = i * i - i + 1\n        vint64m8_t vsquare = vmul_vv_i64m8(voffset, voffset, vl);\n        vint64m8_t vtemp = vsub_vv_i64m8(vsquare, voffset, vl);\n        vint64m8_t vresult = vadd_vx_i64m8(vtemp, 1, vl);\n        \n        vse64_v_i64m8(a + i, vresult, vl);\n    }\n\n    // Check all possible triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            size_t remaining = n - j - 1;\n            uint64_t sum_ij = a[i] + a[j];\n            \n            for (size_t k = j+1; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                vint64m8_t vk = vle64_v_i64m8(a + k, vl);\n                \n                // Check if sum is divisible by 3\n                vint64m8_t vsum = vadd_vx_i64m8(vk, sum_ij, vl);\n                vbool8_t vmask = vmsne_vx_i64m8_b8(vrem_vx_i64m8(vsum, 3, vl), 0, vl);\n                \n                count += vcpop_m_b8(vmask, vl);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array values using vectors\n    size_t vlen = vsetvlmax_e64m8();\n    for (size_t i = 0; i < n; i += vlen) {\n        size_t avl = vsetvl_e64m8(n - i);\n        vuint64m8_t vid = vadd_vx_u64m8(vid_v_u64m8(avl), i, avl);\n        vuint64m8_t vsquare = vmul_vv_u64m8(vid, vid, avl);\n        vuint64m8_t vres = vsub_vv_u64m8(vsquare, vid, avl);\n        vres = vadd_vx_u64m8(vres, 1, avl);\n        vse64_v_u64m8(&a[i], vres, avl);\n    }\n\n    uint64_t count = 0;\n    \n    // Check all possible triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            size_t vlen = vsetvlmax_e64m8();\n            uint64_t sum_ij = a[i] + a[j];\n            \n            for (uint64_t k = j+1; k < n; k += vlen) {\n                size_t avl = vsetvl_e64m8(n - k);\n                if (avl > n-k) avl = n-k;\n                \n                vuint64m8_t vk = vle64_v_u64m8(&a[k], avl);\n                vuint64m8_t vsum = vadd_vx_u64m8(vk, sum_ij, avl);\n                vuint64m8_t vrem = vrem_vx_u64m8(vsum, 3, avl);\n                vbool8_t vmask = vmseq_vx_u64m8_b8(vrem, 0, avl);\n                count += vcpop_m_b8(vmask, avl);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array values using vectors\n    size_t vl;\n    vl = vsetvl_e64m8(n);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        vl = vsetvl_e64m8(n - i);\n        vuint64m8_t v_idx = vadd_vx_u64m8(vid_v_u64m8(vl), i + 1, vl);\n        vuint64m8_t v_square = vmul_vv_u64m8(v_idx, v_idx, vl);\n        vuint64m8_t v_sub = vsub_vv_u64m8(v_square, v_idx, vl);\n        vuint64m8_t v_result = vadd_vx_u64m8(v_sub, 1, vl);\n        vse64_v_u64m8(&a[i], v_result, vl);\n    }\n\n    // Count valid triples\n    uint64_t count = 0;\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            size_t remaining = n - j - 1;\n            vl = vsetvl_e64m8(remaining);\n            \n            for (uint64_t k = j+1; k < n; k += vl) {\n                vl = vsetvl_e64m8(n - k);\n                vuint64m8_t v_ak = vle64_v_u64m8(&a[k], vl);\n                \n                vuint64m8_t v_sum = vadd_vx_u64m8(v_ak, a[i] + a[j], vl);\n                vuint64m8_t v_rem = vrem_vx_u64m8(v_sum, 3, vl);\n                vbool8_t mask = vmseq_vx_u64m8_b8(v_rem, 0, vl);\n                \n                count += vcpop_m_b8(mask, vl);\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array values using vectors\n    size_t vl;\n    uint64_t count = 0;\n    uint64_t i = 0;\n    \n    while (i < n) {\n        vl = vsetvl_e64m8(n-i);\n        \n        // Generate index vector starting from i\n        vint64m8_t vidx = vadd_vx_i64m8(vid_v_i64m8(vl), i, vl);\n        \n        // Calculate i*i - i + 1 using vectors\n        vint64m8_t vsquare = vmul_vv_i64m8(vidx, vidx, vl);\n        vint64m8_t vres = vsub_vv_i64m8(vsquare, vidx, vl);\n        vint64m8_t vfinal = vadd_vx_i64m8(vres, 1, vl);\n        \n        // Store results\n        vse64_v_i64m8(a+i, vfinal, vl);\n        i += vl;\n    }\n\n    // Check all possible triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            size_t remaining = n-j-1;\n            uint64_t k = j+1;\n            \n            while (remaining > 0) {\n                vl = vsetvl_e64m8(remaining);\n                \n                // Load vector of values starting at k\n                vint64m8_t vk = vle64_v_i64m8(a+k, vl);\n                \n                // Calculate sum with a[i] and a[j]\n                vint64m8_t vsum = vadd_vx_i64m8(vk, a[i] + a[j], vl);\n                \n                // Check which sums are divisible by 3\n                vbool8_t vmask = vmsne_vx_i64m8_b8(vrem_vx_i64m8(vsum, 3, vl), 0, vl);\n                \n                // Count elements where mask is 0 (sum divisible by 3)\n                count += vl - vcpop_m_b8(vmask, vl);\n                \n                k += vl;\n                remaining -= vl;\n            }\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_RVV", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array values using vector operations\n    size_t vl;\n    uint64_t i = 0;\n    while (i < n) {\n        vl = vsetvl_e64m8(n-i);\n        \n        // Generate index vector\n        vint64m8_t vidx = vadd_vx_i64m8(vid_v_i64m8(vl), i+1, vl);\n        \n        // Calculate i*i - i + 1\n        vint64m8_t vsquare = vmul_vv_i64m8(vidx, vidx, vl);\n        vint64m8_t vtemp = vsub_vv_i64m8(vsquare, vidx, vl);\n        vint64m8_t vresult = vadd_vx_i64m8(vtemp, 1, vl);\n        \n        // Store results\n        vse64_v_i64m8(&a[i], vresult, vl);\n        i += vl;\n    }\n\n    // Count valid triples\n    uint64_t count = 0;\n    for(uint64_t i = 0; i < n-2; i++) {\n        for(uint64_t j = i+1; j < n-1; j++) {\n            size_t remaining = n-j-1;\n            uint64_t k = j+1;\n            \n            while(remaining > 0) {\n                vl = vsetvl_e64m8(remaining);\n                \n                // Load vector of k values\n                vint64m8_t vk = vle64_v_i64m8(&a[k], vl);\n                \n                // Calculate sum with a[i] and a[j]\n                vint64m8_t vsum = vadd_vx_i64m8(vk, a[i] + a[j], vl);\n                \n                // Check divisibility by 3\n                vbool8_t vmask = vmsne_vx_i64m8_b8(vrem_vx_i64m8(vsum, 3, vl), 0, vl);\n                \n                // Count elements where sum is divisible by 3\n                count += vl - vcpop_m_b8(vmask, vl);\n                \n                k += vl;\n                remaining -= vl;\n            }\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    size_t vl;\n    vl = vsetvl_e32m1(n/2);\n    \n    vint32m1_t vec_i = vid_v_i32m1(vl);\n    vint32m1_t vec_2 = vmv_v_x_i32m1(2, vl);\n    vec_i = vadd_vx_i32m1(vec_i, 2, vl);\n    \n    vbool32_t mask = vmseq_vx_i32m1_b32(vremu_vx_i32m1(vmv_v_x_i32m1(n, vl), vec_i, vl), 0, vl);\n    \n    if (vfirst_m_b32(mask, vl) != -1) {\n        return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    size_t vl;\n    int is_prime = 1;\n    \n    vint32m1_t v_i, v_rem;\n    vbool32_t v_mask;\n    \n    for (int i = 2; i * i <= n; i += vl) {\n        vl = vsetvl_e32m1((n - i) / 2);\n        v_i = vid_v_i32m1(vl);\n        v_i = vadd_vx_i32m1(v_i, i, vl);\n        \n        v_rem = vrem_vx_i32m1(vx_i32m1(n, vl), v_i, vl);\n        v_mask = vmseq_vx_i32m1_b32(v_rem, 0, vl);\n        \n        if (vcpop_m_b32(v_mask, vl) > 0) {\n            is_prime = 0;\n            break;\n        }\n    }\n    \n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_i = vid_v_i32m1(vlen);\n    vint32m1_t v_two = vmv_v_x_i32m1(2, vlen);\n    vint32m1_t v_n = vmv_v_x_i32m1(n, vlen);\n    \n    vbool32_t mask = vmsltu_vx_i32m1_b32(v_i, n/2 + 1, vlen);\n    v_i = vadd_vx_i32m1_m(mask, v_i, v_i, 2, vlen);\n    \n    vbool32_t is_divisible = vmsgtu_vx_i32m1_b32(v_i, 1, vlen);\n    is_divisible = vand_mm_b32(is_divisible, mask);\n    \n    while (vfirst_m_b32(is_divisible, vlen) != -1) {\n        vbool32_t rem_zero = vmsne_vx_i32m1_b32(vrem_vv_i32m1(v_n, v_i, vlen), 0, vlen);\n        is_divisible = vand_mm_b32(is_divisible, rem_zero);\n        \n        if (vfirst_m_b32(vmxor_mm_b32(is_divisible, rem_zero), vlen) != -1) {\n            return y;\n        }\n        \n        v_i = vadd_vx_i32m1_m(mask, v_i, v_i, 1, vlen);\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_i, v_rem;\n    vbool32_t v_mask;\n    int is_prime = 1;\n    \n    for (int i = 2; i * i <= n; i += vlen) {\n        vlen = vsetvl_e32m1(n - i + 1);\n        v_i = vid_v_i32m1(vlen);\n        v_i = vadd_vx_i32m1(v_i, i, vlen);\n        \n        v_rem = vrem_vx_i32m1(vreinterpret_v_i32m1(vmv_v_x_i32m1(n, vlen)), v_i, vlen);\n        v_mask = vmseq_vx_i32m1_b32(v_rem, 0, vlen);\n        \n        if (vfirst_m_b32(v_mask, vlen) != -1) {\n            is_prime = 0;\n            break;\n        }\n    }\n    \n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_RVV", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    size_t vlen = vsetvlmax_e32m1();\n    vint32m1_t v_i = vid_v_i32m1(vlen);\n    vint32m1_t v_two = vmv_v_x_i32m1(2, vlen);\n    vbool32_t mask = vmsltu_vx_i32m1_b32(v_i, n, vlen);\n    \n    vint32m1_t v_n = vmv_v_x_i32m1(n, vlen);\n    vint32m1_t v_rem = vrem_vv_i32m1_m(mask, v_n, v_i, vlen);\n    vbool32_t v_zero = vmseq_vx_i32m1_b32_m(mask, v_rem, 0, vlen);\n    \n    int is_prime = 1;\n    for (size_t i = 0; i < vlen && i + 2 < n; i++) {\n        if (v_zero[i]) {\n            is_prime = 0;\n            break;\n        }\n    }\n    \n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    uint64_t sum = 0;\n    size_t i;\n    \n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vlen);\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        \n        vfloat32m1_t v_input = vle32_v_f32m1(&lst[i], vl);\n        \n        // Check if numbers are non-negative\n        vbool32_t mask_pos = vmfge_vf_f32m1_b32(v_input, 0.0f, vl);\n        \n        // Check if numbers are integers\n        vfloat32m1_t v_floor = vfcvt_f_x_v_f32m1(vfcvt_x_f_v_i32m1(v_input, vl), vl);\n        vbool32_t mask_int = vmfeq_vv_f32m1_b32(v_input, v_floor, vl);\n        \n        // Get odd numbers\n        vint32m1_t v_int = vfcvt_x_f_v_i32m1(v_input, vl);\n        vbool32_t mask_odd = vmsne_vv_i32m1_b32(vand_vx_i32m1(v_int, 2, vl), \n                                                vreinterpret_v_f32m1_i32m1(v_zero), vl);\n        \n        // Combine masks\n        vbool32_t final_mask = vmand_mm_b32(vmand_mm_b32(mask_pos, mask_int), mask_odd);\n        \n        // Square the valid numbers\n        vfloat32m1_t v_square = vfmul_vv_f32m1_m(final_mask, v_zero, v_input, v_input, vl);\n        \n        // Reduce sum\n        sum += vfredsum_vs_f32m1_f32m1(v_square, v_square, v_zero, vl);\n    }\n    \n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    uint64_t sum = 0;\n    size_t i;\n    \n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vlen);\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        \n        vfloat32m1_t v_input = vle32_v_f32m1(&lst[i], vl);\n        \n        // Check if numbers are non-negative\n        vbool32_t mask = vmfge_vf_f32m1_b32(v_input, 0.0f, vl);\n        \n        // Check if numbers are integers\n        vfloat32m1_t v_floor = vfcvt_f_x_v_f32m1(vfcvt_x_f_v_i32m1(v_input, vl), vl);\n        vbool32_t int_mask = vmfeq_vv_f32m1_b32(v_input, v_floor, vl);\n        \n        // Combine masks\n        mask = vmand_mm_b32(mask, int_mask, vl);\n        \n        // Get odd numbers\n        vint32m1_t v_int = vfcvt_x_f_v_i32m1(v_input, vl);\n        vbool32_t odd_mask = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_int, 1, vl), 0, vl);\n        \n        // Final mask combining all conditions\n        mask = vmand_mm_b32(mask, odd_mask, vl);\n        \n        // Square the valid numbers\n        vfloat32m1_t v_square = vfmul_vv_f32m1_m(mask, v_zero, v_input, v_input, vl);\n        \n        // Reduce sum\n        sum += vfredsum_vs_f32m1_f32m1(v_square, v_zero, vl);\n    }\n    \n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    uint64_t sum = 0;\n    size_t i;\n    \n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vlen);\n    \n    for (i = 0; i < vlen; i += vsetvlmax_e32m1()) {\n        size_t vl = vsetvl_e32m1(vlen - i);\n        \n        vfloat32m1_t v_input = vle32_v_f32m1(&lst[i], vl);\n        \n        // Check if numbers are positive\n        vbool32_t mask_pos = vmfgt_vf_f32m1_b32(v_input, 0.0f, vl);\n        \n        // Check if numbers are integers\n        vfloat32m1_t v_floor = vfcvt_f_x_v_f32m1(vfcvt_x_f_v_i32m1(v_input, vl), vl);\n        vbool32_t mask_int = vmfeq_vv_f32m1_b32(v_input, v_floor, vl);\n        \n        // Check if numbers are odd\n        vint32m1_t v_int = vfcvt_x_f_v_i32m1(v_input, vl);\n        vbool32_t mask_odd = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_int, 1, vl), 0, vl);\n        \n        // Combine all masks\n        vbool32_t final_mask = vmand_mm_b32(vmand_mm_b32(mask_pos, mask_int), mask_odd);\n        \n        // Square the valid numbers\n        vfloat32m1_t v_square = vfmul_vv_f32m1_m(final_mask, v_zero, v_input, v_input, vl);\n        \n        // Reduce sum\n        sum += vfredsum_vs_f32m1_f32m1(v_square, v_square, v_zero, vl);\n    }\n    \n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    uint64_t sum = 0;\n    size_t i = 0;\n    \n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vlen);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        vfloat32m1_t v_input = vle32_v_f32m1(&lst[i], avl);\n        \n        // Create mask for non-negative numbers\n        vbool32_t non_neg_mask = vmfge_vf_f32m1_b32(v_input, 0.0f, avl);\n        \n        // Get fractional parts\n        vfloat32m1_t v_frac = vfsub_vv_f32m1(v_input, \n                                             vfcvt_f_x_v_f32m1(vfcvt_x_f_v_i32m1(v_input, avl), avl),\n                                             avl);\n        \n        // Mask for integers (fractional part == 0)\n        vbool32_t int_mask = vmfeq_vf_f32m1_b32(v_frac, 0.0f, avl);\n        \n        // Convert to integers\n        vint32m1_t v_ints = vfcvt_x_f_v_i32m1(v_input, avl);\n        \n        // Check for odd numbers\n        vbool32_t odd_mask = vmsne_vx_i32m1_b32(vand_vx_i32m1(v_ints, 1, avl), 0, avl);\n        \n        // Combine masks\n        vbool32_t final_mask = vmand_mm_b32(vmand_mm_b32(non_neg_mask, int_mask), odd_mask);\n        \n        // Square the valid numbers\n        vfloat32m1_t v_squared = vfmul_vv_f32m1_m(final_mask, v_zero, v_input, v_input, avl);\n        \n        // Reduce sum\n        sum += vfredsum_vs_f32m1_f32m1(v_squared, v_squared, v_zero, avl);\n        \n        i += avl;\n    }\n    \n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_134_RVV", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t vlen = lst.size();\n    size_t i = 0;\n    uint64_t sum = 0;\n    \n    vfloat32m1_t v_zero = vfmv_v_f_f32m1(0.0f, vlen);\n    \n    while (i < vlen) {\n        size_t avl = vlen - i;\n        vfloat32m1_t v_input = vle32_v_f32m1(&lst[i], avl);\n        \n        // Check if numbers are non-negative\n        vbool32_t mask_pos = vmfge_vf_f32m1_b32(v_input, 0.0f, avl);\n        \n        // Check if numbers are integers\n        vfloat32m1_t v_floor = vfcvt_f_x_v_f32m1(vfcvt_x_f_v_i32m1(v_input, avl), avl);\n        vbool32_t mask_int = vmfeq_vv_f32m1_b32(v_input, v_floor, avl);\n        \n        // Check if numbers are odd\n        vint32m1_t v_int = vfcvt_x_f_v_i32m1(v_input, avl);\n        vint32m1_t v_two = vmv_v_x_i32m1(2, avl);\n        vint32m1_t v_rem = vrem_vv_i32m1(v_int, v_two, avl);\n        vbool32_t mask_odd = vmseq_vx_i32m1_b32(v_rem, 1, avl);\n        \n        // Combine masks\n        vbool32_t mask_final = vmand_mm_b32(vmand_mm_b32(mask_pos, mask_int), mask_odd);\n        \n        // Square the valid numbers\n        vfloat32m1_t v_square = vfmul_vv_f32m1_m(mask_final, v_zero, v_input, v_input, avl);\n        \n        // Reduce sum\n        sum += vfredsum_vs_f32m1_f32m1(v_square, v_square, v_zero, avl);\n        \n        i += avl;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t i;\n    \n    for (i = 0; i < n - n % vlen; i += vlen) {\n        vint32m8_t v_game = __riscv_vle32_v_i32m8(&game[i], vlen);\n        vint32m8_t v_guess = __riscv_vle32_v_i32m8(&guess[i], vlen);\n        \n        // Calculate difference\n        vint32m8_t v_diff = __riscv_vsub_vv_i32m8(v_game, v_guess, vlen);\n        \n        // Get absolute values\n        vbool4_t mask = __riscv_vmslt_vx_i32m8_b4(v_diff, 0, vlen);\n        v_diff = __riscv_vrsub_vx_i32m8_m(mask, v_diff, 0, vlen);\n        \n        // Store results\n        __riscv_vse32_v_i32m8(&result[i], v_diff, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t i;\n    \n    for (i = 0; i < n - n % vlen; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v_game = __riscv_vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = __riscv_vle32_v_i32m8(&guess[i], vl);\n        \n        vint32m8_t v_diff = __riscv_vsub_vv_i32m8(v_game, v_guess, vl);\n        vint32m8_t v_abs = __riscv_vabs_v_i32m8(v_diff, vl);\n        \n        __riscv_vse32_v_i32m8(&result[i], v_abs, vl);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t i;\n    \n    for (i = 0; i < n - n % vlen; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v_game = __riscv_vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = __riscv_vle32_v_i32m8(&guess[i], vl);\n        \n        vint32m8_t v_diff = __riscv_vsub_vv_i32m8(v_game, v_guess, vl);\n        vint32m8_t v_abs = __riscv_vabs_v_i32m8(v_diff, vl);\n        \n        __riscv_vse32_v_i32m8(&result[i], v_abs, vl);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t i;\n    \n    for (i = 0; i < n - n % vlen; i += vlen) {\n        size_t vl = __riscv_vsetvl_e32m8(n - i);\n        \n        vint32m8_t v_game = __riscv_vle32_v_i32m8(&game[i], vl);\n        vint32m8_t v_guess = __riscv_vle32_v_i32m8(&guess[i], vl);\n        \n        // Calculate difference\n        vint32m8_t v_diff = __riscv_vsub_vv_i32m8(v_game, v_guess, vl);\n        \n        // Get absolute values\n        vint32m8_t v_abs = __riscv_vabs_v_i32m8(v_diff, vl);\n        \n        // Store results\n        __riscv_vse32_v_i32m8(&result[i], v_abs, vl);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_RVV", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    size_t vlen = __riscv_vsetvlmax_e32m8();\n    size_t i;\n    \n    for (i = 0; i + vlen <= n; i += vlen) {\n        vlen = __riscv_vsetvl_e32m8(n - i);\n        vint32m8_t v_game = __riscv_vle32_v_i32m8(&game[i], vlen);\n        vint32m8_t v_guess = __riscv_vle32_v_i32m8(&guess[i], vlen);\n        \n        // Calculate difference\n        vint32m8_t v_diff = __riscv_vsub_vv_i32m8(v_game, v_guess, vlen);\n        \n        // Get absolute values\n        vint32m8_t v_abs = __riscv_vabs_v_i32m8(v_diff, vlen);\n        \n        // Store results\n        __riscv_vse32_v_i32m8(&result[i], v_abs, vlen);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}

{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)(dst + i));\n        \n        __m128i mask_vec = _mm_set_epi64x(mask[i+1] ? -1LL : 0LL, \n                                         mask[i] ? -1LL : 0LL);\n                                         \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(mask_vec, src_vec),\n            _mm_andnot_si128(mask_vec, dst_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)(dst + i));\n        \n        __m128i mask_vec = _mm_set_epi64x(-(int64_t)mask[i+1], -(int64_t)mask[i]);\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(mask_vec, src_vec),\n            _mm_andnot_si128(mask_vec, dst_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)(dst + i));\n        \n        __m128i mask_vec = _mm_set_epi64x(-(int64_t)mask[i+1], -(int64_t)mask[i]);\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(mask_vec, src_vec),\n            _mm_andnot_si128(mask_vec, dst_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)(dst + i));\n        \n        __m128i mask_vec = _mm_set_epi64x(-(int64_t)mask[i+1], -(int64_t)mask[i]);\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(mask_vec, src_vec),\n            _mm_andnot_si128(mask_vec, dst_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_SSE", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i;\n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i dst_vec = _mm_loadu_si128((__m128i*)(dst + i));\n        \n        __m128i mask_vec = _mm_set_epi64x(mask[i+1] ? -1LL : 0LL, \n                                         mask[i] ? -1LL : 0LL);\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(mask_vec, src_vec),\n            _mm_andnot_si128(mask_vec, dst_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // element * scale\n        __m128i scaled = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // tmp1 = (element * scale) >> 3\n        __m128i tmp1 = _mm_srai_epi32(scaled, 3);\n        \n        // tmp2 = (element * scale) << 3\n        __m128i tmp2 = _mm_slli_epi32(scaled, 3);\n        \n        // tmp1 * tmp2\n        __m128i prod = _mm_mullo_epi32(tmp1, tmp2);\n        \n        // element * scale + tmp1 * tmp2\n        __m128i sum = _mm_add_epi32(scaled, prod);\n        \n        // divide by 7 using multiplication by magic number\n        __m128i magic = _mm_set1_epi32(0x24924925);\n        __m128i temp = _mm_srli_epi32(_mm_mul_epu32(sum, magic), 32);\n        __m128i temp2 = _mm_srli_epi32(_mm_mul_epu32(_mm_srli_si128(sum, 4), magic), 32);\n        __m128i result = _mm_unpacklo_epi32(temp, temp2);\n        result = _mm_srai_epi32(result, 2);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    \n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // element * scale\n        __m128i scaled = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        // tmp1 = (element * scale) >> 3\n        __m128i tmp1 = _mm_srai_epi32(scaled, 3);\n        \n        // tmp2 = (element * scale) << 3\n        __m128i tmp2 = _mm_slli_epi32(scaled, 3);\n        \n        // tmp1 * tmp2\n        __m128i prod = _mm_mullo_epi32(tmp1, tmp2);\n        \n        // element * scale + tmp1 * tmp2\n        __m128i sum = _mm_add_epi32(scaled, prod);\n        \n        // divide by 7 using multiplication by magic number\n        __m128i magic = _mm_set1_epi32(0x24924925);\n        __m128i temp = _mm_srli_epi32(_mm_mul_epu32(sum, magic), 32);\n        __m128i temp2 = _mm_srli_epi32(_mm_mul_epu32(_mm_srli_si128(sum, 4), magic), 32);\n        __m128i result = _mm_unpacklo_epi32(temp, temp2);\n        result = _mm_srai_epi32(result, 2);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i scaled = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        __m128i tmp1 = _mm_srai_epi32(scaled, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled, 3);\n        \n        __m128i tmp1_x_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i scaled_plus_prod = _mm_add_epi32(scaled, tmp1_x_tmp2);\n        \n        __m128i div7 = _mm_set1_epi32(0x24924925);\n        __m128i hi = _mm_mulhi_epi32(scaled_plus_prod, div7);\n        __m128i shift = _mm_srai_epi32(hi, 2);\n        __m128i sign = _mm_srai_epi32(scaled_plus_prod, 31);\n        __m128i result = _mm_sub_epi32(shift, sign);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((const __m128i*)(src + i));\n        __m128i scaled = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        __m128i tmp1 = _mm_srai_epi32(scaled, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled, 3);\n        \n        __m128i tmp1_x_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i scaled_plus_prod = _mm_add_epi32(scaled, tmp1_x_tmp2);\n        \n        __m128i div7_vec = _mm_set1_epi32(0x24924925);\n        __m128i hi = _mm_mulhi_epi32(scaled_plus_prod, div7_vec);\n        __m128i shift = _mm_srai_epi32(hi, 2);\n        __m128i sign = _mm_srai_epi32(scaled_plus_prod, 31);\n        __m128i result = _mm_sub_epi32(shift, sign);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SSE", "completion": "```cpp\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    __m128i scale_vec = _mm_set1_epi32(scale);\n    size_t i;\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i scaled = _mm_mullo_epi32(src_vec, scale_vec);\n        \n        __m128i tmp1 = _mm_srai_epi32(scaled, 3);\n        __m128i tmp2 = _mm_slli_epi32(scaled, 3);\n        \n        __m128i tmp1_x_tmp2 = _mm_mullo_epi32(tmp1, tmp2);\n        __m128i scaled_plus_prod = _mm_add_epi32(scaled, tmp1_x_tmp2);\n        \n        __m128i div7 = _mm_set1_epi32(0x24924925);\n        __m128i t1 = _mm_mul_epu32(scaled_plus_prod, div7);\n        __m128i t2 = _mm_srli_epi64(scaled_plus_prod, 32);\n        __m128i t3 = _mm_mul_epu32(t2, div7);\n        \n        t1 = _mm_srli_epi64(t1, 34);\n        t3 = _mm_srli_epi64(t3, 34);\n        __m128i result = _mm_blend_epi16(t1, _mm_slli_si128(t3, 4), 0xCC);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        int scaled = src[i] * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    size_t simd_width = 2;\n    size_t simd_rows = rows / simd_width;\n    size_t remaining = rows % simd_width;\n\n    for (i = 0; i < simd_rows; i++) {\n        __m128d v1 = _mm_set_pd(\n            src[(i*2 + 1)*cols + stride],\n            src[i*2*cols + stride]\n        );\n        _mm_storeu_pd(&dst[i*2], v1);\n    }\n\n    size_t offset = simd_rows * simd_width;\n    for (i = 0; i < remaining; i++) {\n        dst[offset + i] = src[(offset + i)*cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    for (i = 0; i + 2 <= rows; i += 2) {\n        __m128d v = _mm_set_pd(\n            src[(i+1)*cols + stride],\n            src[i*cols + stride]\n        );\n        _mm_storeu_pd(&dst[i], v);\n    }\n    \n    for (; i < rows; i++) {\n        dst[i] = src[i*cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    const size_t simd_width = 2;\n    size_t simd_rows = rows / simd_width;\n    size_t remainder = rows % simd_width;\n    \n    for (size_t r = 0; r < simd_rows; r++) {\n        __m128d v = _mm_set_pd(\n            src[(r*2 + 1)*cols + stride],\n            src[r*2*cols + stride]\n        );\n        _mm_storeu_pd(&dst[r*2], v);\n    }\n\n    size_t offset = simd_rows * simd_width;\n    for (size_t r = 0; r < remainder; r++) {\n        dst[offset + r] = src[(offset + r)*cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    const size_t simd_width = 2;\n    size_t aligned_rows = rows & ~(simd_width-1);\n    size_t r;\n\n    for (r = 0; r < aligned_rows; r += simd_width) {\n        __m128d v = _mm_set_pd(\n            src[(r+1)*cols + stride],\n            src[r*cols + stride]\n        );\n        _mm_storeu_pd(&dst[r], v);\n    }\n\n    for (; r < rows; r++) {\n        dst[r] = src[r*cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_SSE", "completion": "```cpp\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t i;\n    size_t simd_width = 2;\n    size_t simd_limit = (rows / simd_width) * simd_width;\n    \n    for (i = 0; i < simd_limit; i += simd_width) {\n        __m128d values = _mm_set_pd(\n            src[(i + 1) * cols + stride],\n            src[i * cols + stride]\n        );\n        _mm_storeu_pd(&dst[i], values);\n    }\n\n    for (; i < rows; i++) {\n        dst[i] = src[i * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Gather operation\n        __m128 gathered = _mm_set_ps(\n            src[indices[i+3]],\n            src[indices[i+2]], \n            src[indices[i+1]],\n            src[indices[i]]\n        );\n        _mm_storeu_ps(&dst[i], gathered);\n    }\n    \n    // Handle remaining elements for gather\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Reset counter for scatter operation\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load source values\n        __m128 values = _mm_loadu_ps(&src[i]);\n        \n        // Scatter operation - must be done individually since SSE2 doesn't have scatter\n        dst[indices[i]] = _mm_cvtss_f32(values);\n        dst[indices[i+1]] = _mm_cvtss_f32(_mm_shuffle_ps(values, values, _MM_SHUFFLE(1,1,1,1)));\n        dst[indices[i+2]] = _mm_cvtss_f32(_mm_shuffle_ps(values, values, _MM_SHUFFLE(2,2,2,2)));\n        dst[indices[i+3]] = _mm_cvtss_f32(_mm_shuffle_ps(values, values, _MM_SHUFFLE(3,3,3,3)));\n    }\n    \n    // Handle remaining elements for scatter\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time using SSE\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 indices\n        __m128i idx = _mm_loadu_si128((__m128i*)(indices + i));\n        \n        // Gather operation - load values from src using indices\n        float gathered[4];\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values to dst\n        __m128 gathered_vec = _mm_loadu_ps(gathered);\n        _mm_storeu_ps(dst + i, gathered_vec);\n    }\n    \n    // Handle remaining elements for gather\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Reset counter for scatter pass\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 values from src\n        __m128 src_vec = _mm_loadu_ps(src + i);\n        \n        // Scatter operation - store values to dst using indices\n        float temp[4];\n        _mm_storeu_ps(temp, src_vec);\n        \n        dst[indices[i]] = temp[0];\n        dst[indices[i+1]] = temp[1];\n        dst[indices[i+2]] = temp[2];\n        dst[indices[i+3]] = temp[3];\n    }\n    \n    // Handle remaining elements for scatter\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Gather operation\n        __m128 gather = _mm_set_ps(\n            src[indices[i+3]],\n            src[indices[i+2]], \n            src[indices[i+1]],\n            src[indices[i]]\n        );\n        _mm_storeu_ps(&dst[i], gather);\n    }\n    \n    // Handle remaining elements for gather\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Process 4 elements at a time for scatter\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 src_vec = _mm_loadu_ps(&src[i]);\n        \n        // Scatter operation - must be done sequentially\n        dst[indices[i]] = _mm_cvtss_f32(src_vec);\n        src_vec = _mm_shuffle_ps(src_vec, src_vec, _MM_SHUFFLE(3,2,1,0));\n        dst[indices[i+1]] = _mm_cvtss_f32(src_vec);\n        src_vec = _mm_shuffle_ps(src_vec, src_vec, _MM_SHUFFLE(3,2,1,0)); \n        dst[indices[i+2]] = _mm_cvtss_f32(src_vec);\n        src_vec = _mm_shuffle_ps(src_vec, src_vec, _MM_SHUFFLE(3,2,1,0));\n        dst[indices[i+3]] = _mm_cvtss_f32(src_vec);\n    }\n    \n    // Handle remaining elements for scatter\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Gather operation\n        __m128 gather = _mm_set_ps(\n            src[indices[i+3]],\n            src[indices[i+2]], \n            src[indices[i+1]],\n            src[indices[i]]\n        );\n        _mm_storeu_ps(&dst[i], gather);\n    }\n    \n    // Handle remaining elements for gather\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_SSE", "completion": "```cpp\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i;\n    \n    // Process 4 elements at a time using SSE\n    for (i = 0; i + 4 <= length; i += 4) {\n        // Load 4 indices\n        __m128i idx = _mm_loadu_si128((__m128i*)(indices + i));\n        \n        // Gather operation - load values from src using indices\n        float gathered[4];\n        gathered[0] = src[indices[i]];\n        gathered[1] = src[indices[i+1]]; \n        gathered[2] = src[indices[i+2]];\n        gathered[3] = src[indices[i+3]];\n        \n        // Store gathered values to dst\n        __m128 gathered_vec = _mm_loadu_ps(gathered);\n        _mm_storeu_ps(dst + i, gathered_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    // Scatter operation\n    for (i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        uint64_t remaining = end - start + 1;\n        \n        if (remaining >= 8) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&arr[start]);\n            __m128i v2 = _mm_loadu_si128((__m128i*)&arr[end-7]);\n            \n            v1 = _mm_shufflehi_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v1 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(0,1,2,3)); \n            v2 = _mm_shufflelo_epi16(v2, _MM_SHUFFLE(0,1,2,3));\n            \n            _mm_storeu_si128((__m128i*)&arr[start], v2);\n            _mm_storeu_si128((__m128i*)&arr[end-7], v1);\n            \n            start += 8;\n            end -= 8;\n        }\n        else {\n            int16_t temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        uint64_t elements = end - start + 1;\n        if (elements >= 8) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)(arr + start));\n            __m128i v2 = _mm_loadu_si128((__m128i*)(arr + end - 7));\n            \n            v1 = _mm_shufflehi_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v1 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(0,1,2,3)); \n            v2 = _mm_shufflelo_epi16(v2, _MM_SHUFFLE(0,1,2,3));\n            \n            _mm_storeu_si128((__m128i*)(arr + end - 7), v1);\n            _mm_storeu_si128((__m128i*)(arr + start), v2);\n            \n            start += 8;\n            end -= 8;\n        } else {\n            int16_t temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        uint64_t remaining = end - start + 1;\n        if (remaining >= 8) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&arr[start]);\n            __m128i v2 = _mm_loadu_si128((__m128i*)&arr[end-7]);\n            \n            // Reverse elements within each vector\n            v1 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v1 = _mm_shufflehi_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v1 = _mm_shuffle_epi32(v1, _MM_SHUFFLE(1,0,3,2));\n            \n            v2 = _mm_shufflelo_epi16(v2, _MM_SHUFFLE(0,1,2,3));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(0,1,2,3));\n            v2 = _mm_shuffle_epi32(v2, _MM_SHUFFLE(1,0,3,2));\n            \n            _mm_storeu_si128((__m128i*)&arr[start], v2);\n            _mm_storeu_si128((__m128i*)&arr[end-7], v1);\n            \n            start += 8;\n            end -= 8;\n        } else {\n            int16_t temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        uint64_t remaining = end - start + 1;\n        if (remaining >= 8) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&arr[start]);\n            __m128i v2 = _mm_loadu_si128((__m128i*)&arr[end-7]);\n            \n            // Reverse elements within each vector\n            v1 = _mm_shufflehi_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v1 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(0,1,2,3)); \n            v2 = _mm_shufflelo_epi16(v2, _MM_SHUFFLE(0,1,2,3));\n            \n            // Swap the vectors\n            _mm_storeu_si128((__m128i*)&arr[start], v2);\n            _mm_storeu_si128((__m128i*)&arr[end-7], v1);\n            \n            start += 8;\n            end -= 8;\n        } else {\n            int16_t temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_SSE", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        uint64_t remaining = end - start + 1;\n        if (remaining >= 8) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&arr[start]);\n            __m128i v2 = _mm_loadu_si128((__m128i*)&arr[end-7]);\n            \n            // Reverse elements within each vector\n            v1 = _mm_shufflehi_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v1 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(0,1,2,3));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(0,1,2,3)); \n            v2 = _mm_shufflelo_epi16(v2, _MM_SHUFFLE(0,1,2,3));\n            \n            // Swap the vectors\n            _mm_storeu_si128((__m128i*)&arr[start], v2);\n            _mm_storeu_si128((__m128i*)&arr[end-7], v1);\n            \n            start += 8;\n            end -= 8;\n        } else {\n            int16_t temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t stride = dim2 * dim3;\n    const size_t vec_size = 16;\n    \n    size_t i, j;\n    for (i = 0; i < dim1; i++) {\n        const uint8_t* src = tensor + i * stride + slice_idx;\n        uint8_t* dst = slice + i * dim2;\n        \n        // Process 16 elements at a time using SSE\n        for (j = 0; j + vec_size <= dim2; j += vec_size) {\n            __m128i v = _mm_set_epi8(\n                *(src + (j + 15) * dim3),\n                *(src + (j + 14) * dim3),\n                *(src + (j + 13) * dim3),\n                *(src + (j + 12) * dim3),\n                *(src + (j + 11) * dim3),\n                *(src + (j + 10) * dim3),\n                *(src + (j + 9) * dim3),\n                *(src + (j + 8) * dim3),\n                *(src + (j + 7) * dim3),\n                *(src + (j + 6) * dim3),\n                *(src + (j + 5) * dim3),\n                *(src + (j + 4) * dim3),\n                *(src + (j + 3) * dim3),\n                *(src + (j + 2) * dim3),\n                *(src + (j + 1) * dim3),\n                *(src + j * dim3)\n            );\n            _mm_storeu_si128((__m128i*)(dst + j), v);\n        }\n        \n        // Handle remaining elements\n        for (; j < dim2; j++) {\n            dst[j] = *(src + j * dim3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t stride = dim2 * dim3;\n    const size_t vec_size = 16;\n    \n    size_t i = 0;\n    for (; i + vec_size <= slice_size; i += vec_size) {\n        size_t base_idx = (i / dim2) * stride + (i % dim2) * dim3 + slice_idx;\n        __m128i vec = _mm_set_epi8(\n            tensor[base_idx + 15 * dim3],\n            tensor[base_idx + 14 * dim3],\n            tensor[base_idx + 13 * dim3],\n            tensor[base_idx + 12 * dim3],\n            tensor[base_idx + 11 * dim3],\n            tensor[base_idx + 10 * dim3],\n            tensor[base_idx + 9 * dim3],\n            tensor[base_idx + 8 * dim3],\n            tensor[base_idx + 7 * dim3],\n            tensor[base_idx + 6 * dim3],\n            tensor[base_idx + 5 * dim3],\n            tensor[base_idx + 4 * dim3],\n            tensor[base_idx + 3 * dim3],\n            tensor[base_idx + 2 * dim3],\n            tensor[base_idx + dim3],\n            tensor[base_idx]\n        );\n        _mm_storeu_si128((__m128i*)(slice + i), vec);\n    }\n\n    for (; i < slice_size; i++) {\n        size_t row = i / dim2;\n        size_t col = i % dim2;\n        slice[i] = tensor[row * stride + col * dim3 + slice_idx];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t stride = dim2 * dim3;\n    const size_t vec_size = 16;\n    \n    size_t i = 0;\n    for (; i + vec_size <= slice_size; i += vec_size) {\n        __m128i values = _mm_setzero_si128();\n        for (size_t row = 0; row < dim1; row++) {\n            size_t offset = row * stride + (i % dim2) * dim3 + slice_idx;\n            if (i % dim2 + vec_size <= dim2) {\n                values = _mm_loadu_si128((__m128i*)(tensor + offset));\n                _mm_storeu_si128((__m128i*)(slice + row * dim2 + i), values);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < slice_size; i++) {\n        size_t row = i / dim2;\n        size_t col = i % dim2;\n        slice[i] = tensor[row * stride + col * dim3 + slice_idx];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t stride = dim2 * dim3;\n    const size_t vec_size = 16;\n    \n    size_t i = 0;\n    for (; i + vec_size <= slice_size; i += vec_size) {\n        __m128i values = _mm_setzero_si128();\n        for (size_t j = 0; j < dim1; j++) {\n            size_t offset = j * stride + (i % dim2) * dim3 + slice_idx;\n            if (i % dim2 + vec_size <= dim2) {\n                values = _mm_loadu_si128((__m128i*)(tensor + offset));\n                _mm_storeu_si128((__m128i*)(slice + j * dim2 + i), values);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < slice_size; i++) {\n        size_t row = i / dim2;\n        size_t col = i % dim2;\n        slice[i] = tensor[row * stride + col * dim3 + slice_idx];\n    }\n}\n```"}
{"task_id": "SimdBench_5_SSE", "completion": "```cpp\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const size_t slice_size = dim1 * dim2;\n    const size_t stride = dim2 * dim3;\n    const size_t vec_size = 16;\n    \n    size_t i = 0;\n    for (; i + vec_size <= slice_size; i += vec_size) {\n        size_t row = i / dim2;\n        size_t col = i % dim2;\n        size_t tensor_idx = row * stride + col * dim3 + slice_idx;\n        \n        __m128i v = _mm_set_epi8(\n            tensor[tensor_idx + 15*dim3],\n            tensor[tensor_idx + 14*dim3],\n            tensor[tensor_idx + 13*dim3],\n            tensor[tensor_idx + 12*dim3],\n            tensor[tensor_idx + 11*dim3],\n            tensor[tensor_idx + 10*dim3],\n            tensor[tensor_idx + 9*dim3],\n            tensor[tensor_idx + 8*dim3],\n            tensor[tensor_idx + 7*dim3],\n            tensor[tensor_idx + 6*dim3],\n            tensor[tensor_idx + 5*dim3],\n            tensor[tensor_idx + 4*dim3],\n            tensor[tensor_idx + 3*dim3],\n            tensor[tensor_idx + 2*dim3],\n            tensor[tensor_idx + dim3],\n            tensor[tensor_idx]\n        );\n        \n        _mm_storeu_si128((__m128i*)(slice + i), v);\n    }\n    \n    for (; i < slice_size; i++) {\n        size_t row = i / dim2;\n        size_t col = i % dim2;\n        size_t tensor_idx = row * stride + col * dim3 + slice_idx;\n        slice[i] = tensor[tensor_idx];\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 8) {\n                for (size_t bj = j; bj < max_j; bj += 8) {\n                    if (bi + 8 <= max_i && bj + 8 <= max_j) {\n                        __m128i r0 = _mm_loadu_si128((__m128i*)&src[bi * cols + bj]);\n                        __m128i r1 = _mm_loadu_si128((__m128i*)&src[(bi + 1) * cols + bj]);\n                        __m128i r2 = _mm_loadu_si128((__m128i*)&src[(bi + 2) * cols + bj]);\n                        __m128i r3 = _mm_loadu_si128((__m128i*)&src[(bi + 3) * cols + bj]);\n                        __m128i r4 = _mm_loadu_si128((__m128i*)&src[(bi + 4) * cols + bj]);\n                        __m128i r5 = _mm_loadu_si128((__m128i*)&src[(bi + 5) * cols + bj]);\n                        __m128i r6 = _mm_loadu_si128((__m128i*)&src[(bi + 6) * cols + bj]);\n                        __m128i r7 = _mm_loadu_si128((__m128i*)&src[(bi + 7) * cols + bj]);\n\n                        __m128i t0 = _mm_unpacklo_epi16(r0, r1);\n                        __m128i t1 = _mm_unpackhi_epi16(r0, r1);\n                        __m128i t2 = _mm_unpacklo_epi16(r2, r3);\n                        __m128i t3 = _mm_unpackhi_epi16(r2, r3);\n                        __m128i t4 = _mm_unpacklo_epi16(r4, r5);\n                        __m128i t5 = _mm_unpackhi_epi16(r4, r5);\n                        __m128i t6 = _mm_unpacklo_epi16(r6, r7);\n                        __m128i t7 = _mm_unpackhi_epi16(r6, r7);\n\n                        r0 = _mm_unpacklo_epi32(t0, t2);\n                        r1 = _mm_unpackhi_epi32(t0, t2);\n                        r2 = _mm_unpacklo_epi32(t1, t3);\n                        r3 = _mm_unpackhi_epi32(t1, t3);\n                        r4 = _mm_unpacklo_epi32(t4, t6);\n                        r5 = _mm_unpackhi_epi32(t4, t6);\n                        r6 = _mm_unpacklo_epi32(t5, t7);\n                        r7 = _mm_unpackhi_epi32(t5, t7);\n\n                        t0 = _mm_unpacklo_epi64(r0, r4);\n                        t1 = _mm_unpackhi_epi64(r0, r4);\n                        t2 = _mm_unpacklo_epi64(r1, r5);\n                        t3 = _mm_unpackhi_epi64(r1, r5);\n                        t4 = _mm_unpacklo_epi64(r2, r6);\n                        t5 = _mm_unpackhi_epi64(r2, r6);\n                        t6 = _mm_unpacklo_epi64(r3, r7);\n                        t7 = _mm_unpackhi_epi64(r3, r7);\n\n                        _mm_storeu_si128((__m128i*)&dst[bj * rows + bi], t0);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 1) * rows + bi], t1);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 2) * rows + bi], t2);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 3) * rows + bi], t3);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 4) * rows + bi], t4);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 5) * rows + bi], t5);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 6) * rows + bi], t6);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 7) * rows + bi], t7);\n                    } else {\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 8) {\n                for (size_t bj = j; bj < max_j; bj += 8) {\n                    if (bi + 8 <= max_i && bj + 8 <= max_j) {\n                        __m128i r0 = _mm_loadu_si128((__m128i*)(src + bi * cols + bj));\n                        __m128i r1 = _mm_loadu_si128((__m128i*)(src + (bi + 1) * cols + bj));\n                        __m128i r2 = _mm_loadu_si128((__m128i*)(src + (bi + 2) * cols + bj));\n                        __m128i r3 = _mm_loadu_si128((__m128i*)(src + (bi + 3) * cols + bj));\n                        __m128i r4 = _mm_loadu_si128((__m128i*)(src + (bi + 4) * cols + bj));\n                        __m128i r5 = _mm_loadu_si128((__m128i*)(src + (bi + 5) * cols + bj));\n                        __m128i r6 = _mm_loadu_si128((__m128i*)(src + (bi + 6) * cols + bj));\n                        __m128i r7 = _mm_loadu_si128((__m128i*)(src + (bi + 7) * cols + bj));\n\n                        __m128i t0 = _mm_unpacklo_epi16(r0, r1);\n                        __m128i t1 = _mm_unpackhi_epi16(r0, r1);\n                        __m128i t2 = _mm_unpacklo_epi16(r2, r3);\n                        __m128i t3 = _mm_unpackhi_epi16(r2, r3);\n                        __m128i t4 = _mm_unpacklo_epi16(r4, r5);\n                        __m128i t5 = _mm_unpackhi_epi16(r4, r5);\n                        __m128i t6 = _mm_unpacklo_epi16(r6, r7);\n                        __m128i t7 = _mm_unpackhi_epi16(r6, r7);\n\n                        r0 = _mm_unpacklo_epi32(t0, t2);\n                        r1 = _mm_unpackhi_epi32(t0, t2);\n                        r2 = _mm_unpacklo_epi32(t1, t3);\n                        r3 = _mm_unpackhi_epi32(t1, t3);\n                        r4 = _mm_unpacklo_epi32(t4, t6);\n                        r5 = _mm_unpackhi_epi32(t4, t6);\n                        r6 = _mm_unpacklo_epi32(t5, t7);\n                        r7 = _mm_unpackhi_epi32(t5, t7);\n\n                        t0 = _mm_unpacklo_epi64(r0, r4);\n                        t1 = _mm_unpackhi_epi64(r0, r4);\n                        t2 = _mm_unpacklo_epi64(r1, r5);\n                        t3 = _mm_unpackhi_epi64(r1, r5);\n                        t4 = _mm_unpacklo_epi64(r2, r6);\n                        t5 = _mm_unpackhi_epi64(r2, r6);\n                        t6 = _mm_unpacklo_epi64(r3, r7);\n                        t7 = _mm_unpackhi_epi64(r3, r7);\n\n                        _mm_storeu_si128((__m128i*)(dst + bj * rows + bi), t0);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 1) * rows + bi), t1);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 2) * rows + bi), t2);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 3) * rows + bi), t3);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 4) * rows + bi), t4);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 5) * rows + bi), t5);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 6) * rows + bi), t6);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 7) * rows + bi), t7);\n                    } else {\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 8) {\n                for (size_t bj = j; bj < max_j; bj += 8) {\n                    if (bi + 8 <= max_i && bj + 8 <= max_j) {\n                        __m128i r0 = _mm_loadu_si128((__m128i*)&src[bi * cols + bj]);\n                        __m128i r1 = _mm_loadu_si128((__m128i*)&src[(bi + 1) * cols + bj]);\n                        __m128i r2 = _mm_loadu_si128((__m128i*)&src[(bi + 2) * cols + bj]);\n                        __m128i r3 = _mm_loadu_si128((__m128i*)&src[(bi + 3) * cols + bj]);\n                        __m128i r4 = _mm_loadu_si128((__m128i*)&src[(bi + 4) * cols + bj]);\n                        __m128i r5 = _mm_loadu_si128((__m128i*)&src[(bi + 5) * cols + bj]);\n                        __m128i r6 = _mm_loadu_si128((__m128i*)&src[(bi + 6) * cols + bj]);\n                        __m128i r7 = _mm_loadu_si128((__m128i*)&src[(bi + 7) * cols + bj]);\n\n                        __m128i t0 = _mm_unpacklo_epi16(r0, r1);\n                        __m128i t1 = _mm_unpacklo_epi16(r2, r3);\n                        __m128i t2 = _mm_unpacklo_epi16(r4, r5);\n                        __m128i t3 = _mm_unpacklo_epi16(r6, r7);\n                        __m128i t4 = _mm_unpackhi_epi16(r0, r1);\n                        __m128i t5 = _mm_unpackhi_epi16(r2, r3);\n                        __m128i t6 = _mm_unpackhi_epi16(r4, r5);\n                        __m128i t7 = _mm_unpackhi_epi16(r6, r7);\n\n                        r0 = _mm_unpacklo_epi32(t0, t1);\n                        r1 = _mm_unpackhi_epi32(t0, t1);\n                        r2 = _mm_unpacklo_epi32(t2, t3);\n                        r3 = _mm_unpackhi_epi32(t2, t3);\n                        r4 = _mm_unpacklo_epi32(t4, t5);\n                        r5 = _mm_unpackhi_epi32(t4, t5);\n                        r6 = _mm_unpacklo_epi32(t6, t7);\n                        r7 = _mm_unpackhi_epi32(t6, t7);\n\n                        t0 = _mm_unpacklo_epi64(r0, r2);\n                        t1 = _mm_unpackhi_epi64(r0, r2);\n                        t2 = _mm_unpacklo_epi64(r1, r3);\n                        t3 = _mm_unpackhi_epi64(r1, r3);\n                        t4 = _mm_unpacklo_epi64(r4, r6);\n                        t5 = _mm_unpackhi_epi64(r4, r6);\n                        t6 = _mm_unpacklo_epi64(r5, r7);\n                        t7 = _mm_unpackhi_epi64(r5, r7);\n\n                        _mm_storeu_si128((__m128i*)&dst[bj * rows + bi], t0);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 1) * rows + bi], t1);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 2) * rows + bi], t2);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 3) * rows + bi], t3);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 4) * rows + bi], t4);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 5) * rows + bi], t5);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 6) * rows + bi], t6);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 7) * rows + bi], t7);\n                    } else {\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 8) {\n                for (size_t bj = j; bj < max_j; bj += 8) {\n                    if (bi + 8 <= max_i && bj + 8 <= max_j) {\n                        __m128i r0 = _mm_loadu_si128((__m128i*)&src[bi * cols + bj]);\n                        __m128i r1 = _mm_loadu_si128((__m128i*)&src[(bi + 1) * cols + bj]);\n                        __m128i r2 = _mm_loadu_si128((__m128i*)&src[(bi + 2) * cols + bj]);\n                        __m128i r3 = _mm_loadu_si128((__m128i*)&src[(bi + 3) * cols + bj]);\n                        __m128i r4 = _mm_loadu_si128((__m128i*)&src[(bi + 4) * cols + bj]);\n                        __m128i r5 = _mm_loadu_si128((__m128i*)&src[(bi + 5) * cols + bj]);\n                        __m128i r6 = _mm_loadu_si128((__m128i*)&src[(bi + 6) * cols + bj]);\n                        __m128i r7 = _mm_loadu_si128((__m128i*)&src[(bi + 7) * cols + bj]);\n\n                        __m128i t0 = _mm_unpacklo_epi16(r0, r1);\n                        __m128i t1 = _mm_unpacklo_epi16(r2, r3);\n                        __m128i t2 = _mm_unpacklo_epi16(r4, r5);\n                        __m128i t3 = _mm_unpacklo_epi16(r6, r7);\n                        __m128i t4 = _mm_unpackhi_epi16(r0, r1);\n                        __m128i t5 = _mm_unpackhi_epi16(r2, r3);\n                        __m128i t6 = _mm_unpackhi_epi16(r4, r5);\n                        __m128i t7 = _mm_unpackhi_epi16(r6, r7);\n\n                        r0 = _mm_unpacklo_epi32(t0, t1);\n                        r1 = _mm_unpackhi_epi32(t0, t1);\n                        r2 = _mm_unpacklo_epi32(t2, t3);\n                        r3 = _mm_unpackhi_epi32(t2, t3);\n                        r4 = _mm_unpacklo_epi32(t4, t5);\n                        r5 = _mm_unpackhi_epi32(t4, t5);\n                        r6 = _mm_unpacklo_epi32(t6, t7);\n                        r7 = _mm_unpackhi_epi32(t6, t7);\n\n                        t0 = _mm_unpacklo_epi64(r0, r2);\n                        t1 = _mm_unpackhi_epi64(r0, r2);\n                        t2 = _mm_unpacklo_epi64(r1, r3);\n                        t3 = _mm_unpackhi_epi64(r1, r3);\n                        t4 = _mm_unpacklo_epi64(r4, r6);\n                        t5 = _mm_unpackhi_epi64(r4, r6);\n                        t6 = _mm_unpacklo_epi64(r5, r7);\n                        t7 = _mm_unpackhi_epi64(r5, r7);\n\n                        _mm_storeu_si128((__m128i*)&dst[bj * rows + bi], t0);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 1) * rows + bi], t1);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 2) * rows + bi], t2);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 3) * rows + bi], t3);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 4) * rows + bi], t4);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 5) * rows + bi], t5);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 6) * rows + bi], t6);\n                        _mm_storeu_si128((__m128i*)&dst[(bj + 7) * rows + bi], t7);\n                    } else {\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SSE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi += 8) {\n                for (size_t bj = j; bj < max_j; bj += 8) {\n                    if (bi + 8 <= max_i && bj + 8 <= max_j) {\n                        __m128i r0 = _mm_loadu_si128((__m128i*)(src + bi * cols + bj));\n                        __m128i r1 = _mm_loadu_si128((__m128i*)(src + (bi + 1) * cols + bj));\n                        __m128i r2 = _mm_loadu_si128((__m128i*)(src + (bi + 2) * cols + bj));\n                        __m128i r3 = _mm_loadu_si128((__m128i*)(src + (bi + 3) * cols + bj));\n                        __m128i r4 = _mm_loadu_si128((__m128i*)(src + (bi + 4) * cols + bj));\n                        __m128i r5 = _mm_loadu_si128((__m128i*)(src + (bi + 5) * cols + bj));\n                        __m128i r6 = _mm_loadu_si128((__m128i*)(src + (bi + 6) * cols + bj));\n                        __m128i r7 = _mm_loadu_si128((__m128i*)(src + (bi + 7) * cols + bj));\n\n                        __m128i t0 = _mm_unpacklo_epi16(r0, r1);\n                        __m128i t1 = _mm_unpacklo_epi16(r2, r3);\n                        __m128i t2 = _mm_unpacklo_epi16(r4, r5);\n                        __m128i t3 = _mm_unpacklo_epi16(r6, r7);\n                        __m128i t4 = _mm_unpackhi_epi16(r0, r1);\n                        __m128i t5 = _mm_unpackhi_epi16(r2, r3);\n                        __m128i t6 = _mm_unpackhi_epi16(r4, r5);\n                        __m128i t7 = _mm_unpackhi_epi16(r6, r7);\n\n                        r0 = _mm_unpacklo_epi32(t0, t1);\n                        r1 = _mm_unpackhi_epi32(t0, t1);\n                        r2 = _mm_unpacklo_epi32(t2, t3);\n                        r3 = _mm_unpackhi_epi32(t2, t3);\n                        r4 = _mm_unpacklo_epi32(t4, t5);\n                        r5 = _mm_unpackhi_epi32(t4, t5);\n                        r6 = _mm_unpacklo_epi32(t6, t7);\n                        r7 = _mm_unpackhi_epi32(t6, t7);\n\n                        t0 = _mm_unpacklo_epi64(r0, r2);\n                        t1 = _mm_unpackhi_epi64(r0, r2);\n                        t2 = _mm_unpacklo_epi64(r1, r3);\n                        t3 = _mm_unpackhi_epi64(r1, r3);\n                        t4 = _mm_unpacklo_epi64(r4, r6);\n                        t5 = _mm_unpackhi_epi64(r4, r6);\n                        t6 = _mm_unpacklo_epi64(r5, r7);\n                        t7 = _mm_unpackhi_epi64(r5, r7);\n\n                        _mm_storeu_si128((__m128i*)(dst + bj * rows + bi), t0);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 1) * rows + bi), t1);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 2) * rows + bi), t2);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 3) * rows + bi), t3);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 4) * rows + bi), t4);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 5) * rows + bi), t5);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 6) * rows + bi), t6);\n                        _mm_storeu_si128((__m128i*)(dst + (bj + 7) * rows + bi), t7);\n                    } else {\n                        for (size_t ii = bi; ii < max_i; ii++) {\n                            for (size_t jj = bj; jj < max_j; jj++) {\n                                dst[jj * rows + ii] = src[ii * cols + jj];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum = _mm_setzero_ps();\n    __m128 elements;\n    size_t i;\n    \n    // Process 4 diagonal elements at a time\n    for(i = 0; i + 3 < dim; i += 4) {\n        size_t idx0 = i * (dim * dim + dim + 1);\n        size_t idx1 = (i + 1) * (dim * dim + dim + 1); \n        size_t idx2 = (i + 2) * (dim * dim + dim + 1);\n        size_t idx3 = (i + 3) * (dim * dim + dim + 1);\n        \n        elements = _mm_set_ps(array[idx3], array[idx2], array[idx1], array[idx0]);\n        sum = _mm_add_ps(sum, elements);\n    }\n    \n    // Handle remaining elements\n    float result = 0.0f;\n    float temp[4];\n    _mm_store_ps(temp, sum);\n    result = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for(; i < dim; i++) {\n        result += array[i * (dim * dim + dim + 1)];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum = _mm_setzero_ps();\n    __m128 elements;\n    \n    size_t dim_sq = dim * dim;\n    size_t i = 0;\n    size_t remaining = dim;\n    \n    // Process 4 diagonal elements at a time\n    for (; remaining >= 4; remaining -= 4) {\n        elements = _mm_set_ps(array[i + 3 * dim_sq + 3 * dim + 3],\n                            array[i + 2 * dim_sq + 2 * dim + 2],\n                            array[i + dim_sq + dim + 1],\n                            array[i]);\n        sum = _mm_add_ps(sum, elements);\n        i += 4 * (dim_sq + dim + 1);\n    }\n    \n    // Horizontal sum of the 4 floats\n    sum = _mm_hadd_ps(sum, sum);\n    sum = _mm_hadd_ps(sum, sum);\n    float result = _mm_cvtss_f32(sum);\n    \n    // Handle remaining elements\n    for (; remaining > 0; remaining--) {\n        result += array[i];\n        i += dim_sq + dim + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum = _mm_setzero_ps();\n    __m128 elements;\n    size_t i;\n    size_t dim_squared = dim * dim;\n    size_t aligned_dim = (dim / 4) * 4;\n    float temp[4];\n    \n    for (i = 0; i < aligned_dim; i += 4) {\n        elements = _mm_set_ps(\n            array[i*dim_squared + i*dim + i],\n            array[(i+1)*dim_squared + (i+1)*dim + (i+1)],\n            array[(i+2)*dim_squared + (i+2)*dim + (i+2)],\n            array[(i+3)*dim_squared + (i+3)*dim + (i+3)]\n        );\n        sum = _mm_add_ps(sum, elements);\n    }\n    \n    _mm_store_ps(temp, sum);\n    float final_sum = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (; i < dim; i++) {\n        final_sum += array[i*dim_squared + i*dim + i];\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum = _mm_setzero_ps();\n    __m128 elements;\n    size_t i;\n    size_t dim_squared = dim * dim;\n    size_t num_vectors = dim / 4;\n    size_t remainder = dim % 4;\n    float result = 0.0f;\n\n    for (i = 0; i < num_vectors * 4; i += 4) {\n        size_t idx0 = i * dim_squared + i * dim + i;\n        size_t idx1 = (i + 1) * dim_squared + (i + 1) * dim + (i + 1);\n        size_t idx2 = (i + 2) * dim_squared + (i + 2) * dim + (i + 2);\n        size_t idx3 = (i + 3) * dim_squared + (i + 3) * dim + (i + 3);\n\n        elements = _mm_set_ps(array[idx3], array[idx2], array[idx1], array[idx0]);\n        sum = _mm_add_ps(sum, elements);\n    }\n\n    float temp[4] __attribute__((aligned(16)));\n    _mm_store_ps(temp, sum);\n    result = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (i = num_vectors * 4; i < dim; i++) {\n        size_t idx = i * dim_squared + i * dim + i;\n        result += array[idx];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_7_SSE", "completion": "```cpp\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    __m128 sum = _mm_setzero_ps();\n    size_t dim_sq = dim * dim;\n    size_t i = 0;\n    \n    // Process 4 diagonal elements at a time\n    for (; i + 3 < dim; i += 4) {\n        size_t idx0 = i * dim_sq + i * dim + i;\n        size_t idx1 = (i+1) * dim_sq + (i+1) * dim + (i+1);\n        size_t idx2 = (i+2) * dim_sq + (i+2) * dim + (i+2);\n        size_t idx3 = (i+3) * dim_sq + (i+3) * dim + (i+3);\n        \n        __m128 diag = _mm_set_ps(array[idx3], array[idx2], \n                                array[idx1], array[idx0]);\n        sum = _mm_add_ps(sum, diag);\n    }\n    \n    // Handle remaining elements\n    float result = 0.0f;\n    float temp[4];\n    _mm_store_ps(temp, sum);\n    result = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (; i < dim; i++) {\n        size_t idx = i * dim_sq + i * dim + i;\n        result += array[idx];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t aligned_size = total & ~1ULL; // Round down to multiple of 2\n    \n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result = _mm_or_pd(\n            _mm_and_pd(mask, scaled),\n            _mm_andnot_pd(mask, src_vec)\n        );\n        _mm_storeu_pd(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t aligned_size = total & ~1ULL; // Round down to multiple of 2\n    \n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    // Process 2 doubles at a time using SSE2\n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result = _mm_or_pd(\n            _mm_and_pd(mask, scaled),\n            _mm_andnot_pd(mask, src_vec)\n        );\n        _mm_storeu_pd(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total; i++) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    size_t simd_size = total / 2;\n    size_t remainder = total % 2;\n    \n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    for (size_t i = 0; i < simd_size; i++) {\n        __m128d src_vec = _mm_loadu_pd(&src[i*2]);\n        __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result = _mm_or_pd(\n            _mm_and_pd(mask, scaled),\n            _mm_andnot_pd(mask, src_vec)\n        );\n        _mm_storeu_pd(&dst[i*2], result);\n    }\n    \n    if (remainder) {\n        size_t i = simd_size * 2;\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    size_t total = rows * cols;\n    size_t aligned_size = total & ~1ULL;\n    \n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result = _mm_or_pd(_mm_and_pd(mask, scaled), \n                                  _mm_andnot_pd(mask, src_vec));\n        _mm_storeu_pd(&dst[i], result);\n    }\n    \n    for (size_t i = aligned_size; i < total; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_SSE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t size = rows * cols;\n    size_t aligned_size = size & ~1ULL;\n    \n    __m128d threshold_vec = _mm_set1_pd(threshold);\n    __m128d scale_vec = _mm_set1_pd(scale);\n    \n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d src_vec = _mm_loadu_pd(&src[i]);\n        __m128d mask = _mm_cmpgt_pd(src_vec, threshold_vec);\n        __m128d scaled = _mm_mul_pd(src_vec, scale_vec);\n        __m128d result = _mm_or_pd(_mm_and_pd(mask, scaled), \n                                  _mm_andnot_pd(mask, src_vec));\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    for (size_t i = aligned_size; i < size; i++) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t aligned_cols = (cols / 2) * 2;\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j;\n        for (j = 0; j < aligned_cols; j += 2) {\n            __m128d v = _mm_load_pd(&src[src_offset + j]);\n            _mm_store_pd(&dst[dst_offset + j], v);\n        }\n        \n        for (; j < cols; j++) {\n            dst[dst_offset + j] = src[src_offset + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    const size_t simd_width = 2;\n    const size_t simd_cols = cols / simd_width;\n    const size_t remainder = cols % simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const size_t src_row = indices[i];\n        const double* src_ptr = src + src_row * cols;\n        double* dst_ptr = dst + i * cols;\n\n        // Process 2 doubles at a time using SSE2\n        for (size_t j = 0; j < simd_cols; j++) {\n            __m128d v = _mm_load_pd(src_ptr + j * simd_width);\n            _mm_store_pd(dst_ptr + j * simd_width, v);\n        }\n\n        // Handle remaining elements\n        const size_t start_remainder = simd_cols * simd_width;\n        for (size_t j = 0; j < remainder; j++) {\n            dst_ptr[start_remainder + j] = src_ptr[start_remainder + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t cols_aligned = (cols / 2) * 2;\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j;\n        for (j = 0; j < cols_aligned; j += 2) {\n            __m128d v = _mm_load_pd(&src[src_offset + j]);\n            _mm_store_pd(&dst[dst_offset + j], v);\n        }\n        \n        for (; j < cols; j++) {\n            dst[dst_offset + j] = src[src_offset + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    const size_t simd_width = 2;\n    const size_t simd_cols = cols / simd_width;\n    const size_t remainder = cols % simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const size_t src_row = indices[i];\n        const double* src_ptr = src + src_row * cols;\n        double* dst_ptr = dst + i * cols;\n\n        // Process 2 doubles at a time using SSE2\n        for (size_t j = 0; j < simd_cols; j++) {\n            __m128d v = _mm_load_pd(src_ptr + j * simd_width);\n            _mm_store_pd(dst_ptr + j * simd_width, v);\n        }\n\n        // Handle remaining elements\n        for (size_t j = simd_cols * simd_width; j < cols; j++) {\n            dst_ptr[j] = src_ptr[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SSE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t simd_width = cols / 2;\n    size_t remainder = cols % 2;\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n\n        for (size_t j = 0; j < simd_width; j++) {\n            __m128d v = _mm_load_pd(&src[src_offset + j * 2]);\n            _mm_store_pd(&dst[dst_offset + j * 2], v);\n        }\n\n        if (remainder) {\n            dst[dst_offset + cols - 1] = src[src_offset + cols - 1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i sum = _mm_add_epi64(v1, v2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        \n        // Divide by 2 (shift right by 1)\n        __m128i sign = _mm_srai_epi32(_mm_shuffle_epi32(sum, 0xF5), 31);\n        __m128i high = _mm_srli_epi64(sum, 1);\n        __m128i low = _mm_slli_epi64(sum, 63);\n        __m128i result = _mm_or_si128(high, _mm_srli_si128(low, 8));\n        result = _mm_add_epi64(result, sign);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = (sum < 0) ? (sum - 1) / 2 : sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i;\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i sum = _mm_add_epi64(v1, v2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        \n        // Divide by 2 (shift right by 1)\n        __m128i sign = _mm_srai_epi32(_mm_shuffle_epi32(sum, 0xF5), 31);\n        sign = _mm_shuffle_epi32(sign, 0xF5);\n        sum = _mm_add_epi64(sum, sign);\n        sum = _mm_srai_epi32(sum, 1);\n        sum = _mm_shuffle_epi32(sum, 0xD8);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i sum = _mm_add_epi64(v1, v2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        \n        // Divide by 2 (shift right by 1)\n        __m128i sign = _mm_srai_epi32(_mm_shuffle_epi32(sum, 0xF5), 31);\n        __m128i high = _mm_srli_epi64(sum, 1);\n        __m128i low = _mm_slli_epi64(sum, 63);\n        __m128i result = _mm_or_si128(high, _mm_srli_si128(low, 8));\n        result = _mm_add_epi64(result, sign);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        dst[i] = (sum < 0) ? (sum + 1) / 2 : sum / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i sum = _mm_add_epi64(v1, v2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        \n        // Divide by 2 (shift right by 1)\n        __m128i sign = _mm_srai_epi32(_mm_shuffle_epi32(sum, 0xF5), 31);\n        sign = _mm_shuffle_epi32(sign, 0xF5);\n        sum = _mm_add_epi64(sum, sign);\n        sum = _mm_srai_epi32(sum, 1);\n        sum = _mm_shuffle_epi32(sum, 0xD8);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), sum);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SSE", "completion": "```cpp\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    __m128i scalar_vec = _mm_set1_epi64x(scalar);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)&src1[i]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&src2[i]);\n        \n        __m128i sum = _mm_add_epi64(v1, v2);\n        sum = _mm_add_epi64(sum, scalar_vec);\n        \n        // Shift right by 1 to divide by 2\n        __m128i result = _mm_srai_epi64(sum, 1);\n        \n        _mm_storeu_si128((__m128i*)&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 7 < length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src + i + 4));\n        \n        // Create mask for even indices\n        __m128i mask1 = _mm_set_epi32(0, -1, 0, -1);\n        __m128i mask2 = _mm_set_epi32(0, -1, 0, -1);\n        \n        // Mask out odd indices\n        v1 = _mm_and_si128(v1, mask1);\n        v2 = _mm_and_si128(v2, mask2);\n        \n        // Compare and get minimum\n        min_val = _mm_min_epi32(min_val, v1);\n        min_val = _mm_min_epi32(min_val, v2);\n    }\n    \n    // Handle remaining elements\n    int min = INT_MAX;\n    for (; i < length; i += 2) {\n        if (src[i] < min) {\n            min = src[i];\n        }\n    }\n    \n    // Extract minimum from SIMD vector\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_val);\n    \n    min = min_arr[0];\n    if (min_arr[2] < min) min = min_arr[2];\n    if (min > INT_MAX/2) min = INT_MAX;\n    \n    // Compare with scalar minimum\n    return (min < INT_MAX) ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(src + i));\n        // Create mask for even indices (1,0,1,0)\n        __m128i mask = _mm_set_epi32(0, -1, 0, -1);\n        // Zero out odd indices\n        curr = _mm_and_si128(curr, mask);\n        // Replace zeroed odd indices with INT_MAX\n        curr = _mm_or_si128(curr, _mm_andnot_si128(mask, _mm_set1_epi32(INT_MAX)));\n        min_val = _mm_min_epi32(min_val, curr);\n    }\n    \n    // Find minimum among the 4 elements\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_val);\n    int min = min_arr[0];\n    for (int j = 2; j < 4; j += 2) {\n        if (min_arr[j] < min) min = min_arr[j];\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] < min) min = src[i];\n    }\n    \n    return min;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(src + i));\n        // Mask to keep only even-indexed elements (1,0,1,0)\n        __m128i mask = _mm_set_epi32(0, -1, 0, -1);\n        curr = _mm_and_si128(curr, mask);\n        // Replace odd-indexed elements with INT_MAX\n        __m128i fill = _mm_andnot_si128(mask, _mm_set1_epi32(INT_MAX));\n        curr = _mm_or_si128(curr, fill);\n        min_val = _mm_min_epi32(min_val, curr);\n    }\n    \n    // Find minimum among the 4 elements\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_val);\n    int min = min_arr[0];\n    for (int j = 2; j < 4; j += 2) {\n        if (min_arr[j] < min) min = min_arr[j];\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i += 2) {\n        if (src[i] < min) min = src[i];\n    }\n    \n    return min;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 7 < length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src + i + 4));\n        \n        // Create mask for even indices\n        __m128i mask1 = _mm_set_epi32(0, -1, 0, -1);\n        __m128i mask2 = _mm_set_epi32(0, -1, 0, -1);\n        \n        // Mask out odd indices\n        v1 = _mm_and_si128(v1, mask1);\n        v2 = _mm_and_si128(v2, mask2);\n        \n        // Compare and update minimum\n        min_val = _mm_min_epi32(min_val, v1);\n        min_val = _mm_min_epi32(min_val, v2);\n    }\n    \n    // Handle remaining elements\n    int min = INT_MAX;\n    for (; i < length; i += 2) {\n        if (src[i] < min) {\n            min = src[i];\n        }\n    }\n    \n    // Extract minimum from SIMD vector\n    int min_array[4];\n    _mm_storeu_si128((__m128i*)min_array, min_val);\n    \n    int final_min = min;\n    for (i = 0; i < 4; i += 2) {\n        if (min_array[i] < final_min) {\n            final_min = min_array[i];\n        }\n    }\n    \n    return final_min;\n}\n```"}
{"task_id": "SimdBench_11_SSE", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    __m128i min_vec = _mm_set1_epi32(INT_MAX);\n    size_t i;\n    \n    // Process 4 elements at a time\n    for (i = 0; i + 7 < length; i += 8) {\n        // Load 8 elements\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src + i + 4));\n        \n        // Create mask for even indices\n        __m128i mask = _mm_set_epi32(0, -1, 0, -1);\n        \n        // Zero out odd indices\n        v1 = _mm_and_si128(v1, mask);\n        v2 = _mm_and_si128(v2, mask);\n        \n        // Find min between vectors\n        min_vec = _mm_min_epi32(min_vec, v1);\n        min_vec = _mm_min_epi32(min_vec, v2);\n    }\n    \n    // Handle remaining elements\n    int min_val = INT_MAX;\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    \n    // Extract minimum from vector\n    int min_arr[4];\n    _mm_storeu_si128((__m128i*)min_arr, min_vec);\n    \n    min_val = min(min_val, min_arr[0]);\n    min_val = min(min_val, min_arr[2]);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t aligned_length = length & ~3;\n    \n    for (i = 0; i < aligned_length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Arithmetic right shift\n        __m128i arith_shift = _mm_srai_epi32(input, shift);\n        \n        // Logical right shift\n        __m128i logical_shift = _mm_srli_epi32(input, shift);\n        \n        // Add results\n        __m128i result = _mm_add_epi32(arith_shift, logical_shift);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_result = src[i] >> shift;\n        int logical_result = (unsigned int)src[i] >> shift;\n        dst[i] = arith_result + logical_result;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t aligned_length = length & ~3;\n    \n    for (i = 0; i < aligned_length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Arithmetic right shift\n        __m128i arith_shift = _mm_srai_epi32(input, shift);\n        \n        // Logical right shift\n        __m128i logical_shift = _mm_srli_epi32(input, shift);\n        \n        // Add results\n        __m128i result = _mm_add_epi32(arith_shift, logical_shift);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (unsigned int)src[i] >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t aligned_length = length & ~3;\n    \n    for (i = 0; i < aligned_length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Arithmetic right shift\n        __m128i arith_shift = _mm_srai_epi32(input, shift);\n        \n        // Logical right shift\n        __m128i logical_shift = _mm_srli_epi32(input, shift);\n        \n        // Add results\n        __m128i result = _mm_add_epi32(arith_shift, logical_shift);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_result = src[i] >> shift;\n        int logical_result = (unsigned int)src[i] >> shift;\n        dst[i] = arith_result + logical_result;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t aligned_length = length & ~3;\n    \n    for (i = 0; i < aligned_length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Arithmetic right shift\n        __m128i arith_shift = _mm_srai_epi32(input, shift);\n        \n        // Logical right shift\n        __m128i logical_shift = _mm_srli_epi32(input, shift);\n        \n        // Add results\n        __m128i result = _mm_add_epi32(arith_shift, logical_shift);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_result = src[i] >> shift;\n        int logical_result = (unsigned int)src[i] >> shift;\n        dst[i] = arith_result + logical_result;\n    }\n}\n```"}
{"task_id": "SimdBench_12_SSE", "completion": "```cpp\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    size_t aligned_length = length & ~3;\n    \n    for (i = 0; i < aligned_length; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Arithmetic right shift\n        __m128i arith_shift = _mm_srai_epi32(input, shift);\n        \n        // Logical right shift\n        __m128i logical_shift = _mm_srli_epi32(input, shift);\n        \n        // Add results\n        __m128i result = _mm_add_epi32(arith_shift, logical_shift);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        int arith_result = src[i] >> shift;\n        int logical_result = (unsigned int)src[i] >> shift;\n        dst[i] = arith_result + logical_result;\n    }\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t aligned_size = total_elements - (total_elements % 4);\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)(matrix + i));\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n    \n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    int64_t total = (int64_t)temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (size_t i = aligned_size; i < total_elements; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t aligned_elements = total_elements & ~3;\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_elements; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)(matrix + i));\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n    \n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    int64_t total = (int64_t)temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (size_t i = aligned_elements; i < total_elements; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t aligned_size = total_elements - (total_elements % 4);\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)(matrix + i));\n        sum_vec = _mm_add_epi32(sum_vec, vec);\n    }\n    \n    int32_t temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum_vec);\n    int64_t total = (int64_t)temp[0] + temp[1] + temp[2] + temp[3];\n    \n    for (size_t i = aligned_size; i < total_elements; i++) {\n        total += matrix[i];\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    __m128i sum = _mm_setzero_si128();\n    size_t total = rows * cols;\n    size_t i = 0;\n    \n    // Process 4 elements at a time\n    for (; i + 3 < total; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)(matrix + i));\n        sum = _mm_add_epi32(sum, data);\n    }\n    \n    // Handle remaining elements\n    int64_t final_sum = 0;\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum);\n    final_sum = (int64_t)temp[0] + temp[1] + temp[2] + temp[3];\n    \n    // Add remaining elements\n    for (; i < total; i++) {\n        final_sum += matrix[i];\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_13_SSE", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t aligned_size = total_elements - (total_elements % 4);\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)(matrix + i));\n        sum_vec = _mm_add_epi32(sum_vec, data);\n    }\n    \n    int sum_array[4];\n    _mm_storeu_si128((__m128i*)sum_array, sum_vec);\n    \n    int64_t total_sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n    \n    for (size_t i = aligned_size; i < total_elements; i++) {\n        total_sum += matrix[i];\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(-128);\n    __m128i max_idx = _mm_setzero_si128();\n    __m128i curr_idx = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi8(16);\n    \n    size_t max_index = 0;\n    int8_t current_max = -128;\n\n    // Process 16 elements at a time\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i curr_val = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i mask = _mm_cmpgt_epi8(curr_val, max_val);\n        \n        max_val = _mm_or_si128(_mm_and_si128(mask, curr_val), \n                              _mm_andnot_si128(mask, max_val));\n        max_idx = _mm_or_si128(_mm_and_si128(mask, curr_idx),\n                              _mm_andnot_si128(mask, max_idx));\n        \n        curr_idx = _mm_add_epi8(curr_idx, increment);\n    }\n\n    // Find max among SIMD results\n    int8_t max_vals[16];\n    int8_t max_idxs[16];\n    _mm_storeu_si128((__m128i*)max_vals, max_val);\n    _mm_storeu_si128((__m128i*)max_idxs, max_idx);\n\n    for (int j = 0; j < 16; j++) {\n        if (max_vals[j] > current_max) {\n            current_max = max_vals[j];\n            max_index = max_idxs[j];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < length; i++) {\n        if (src[i] > current_max) {\n            current_max = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(-128);\n    __m128i max_idx = _mm_setzero_si128();\n    __m128i curr_idx = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi8(16);\n    \n    size_t max_index = 0;\n    int8_t max = src[0];\n    \n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i curr_val = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i mask = _mm_cmpgt_epi8(curr_val, max_val);\n        \n        max_val = _mm_or_si128(_mm_and_si128(mask, curr_val), \n                              _mm_andnot_si128(mask, max_val));\n        max_idx = _mm_or_si128(_mm_and_si128(mask, curr_idx),\n                              _mm_andnot_si128(mask, max_idx));\n                              \n        curr_idx = _mm_add_epi8(curr_idx, increment);\n    }\n    \n    alignas(16) int8_t values[16];\n    alignas(16) int8_t indices[16];\n    \n    _mm_store_si128((__m128i*)values, max_val);\n    _mm_store_si128((__m128i*)indices, max_idx);\n    \n    for (int j = 0; j < 16; j++) {\n        if (values[j] > max) {\n            max = values[j];\n            max_index = indices[j];\n        }\n    }\n    \n    for (; i < length; i++) {\n        if (src[i] > max) {\n            max = src[i];\n            max_index = i;\n        }\n    }\n    \n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(-128);\n    __m128i max_idx = _mm_setzero_si128();\n    __m128i curr_idx = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi8(16);\n    \n    size_t max_index = 0;\n    int8_t global_max = -128;\n\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i curr_val = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i mask = _mm_cmpgt_epi8(curr_val, max_val);\n        \n        max_val = _mm_max_epi8(max_val, curr_val);\n        max_idx = _mm_blendv_epi8(max_idx, curr_idx, mask);\n        curr_idx = _mm_add_epi8(curr_idx, increment);\n    }\n\n    alignas(16) int8_t max_vals[16];\n    alignas(16) int8_t idx_vals[16];\n    _mm_store_si128((__m128i*)max_vals, max_val);\n    _mm_store_si128((__m128i*)idx_vals, max_idx);\n\n    for (int j = 0; j < 16; j++) {\n        if (max_vals[j] > global_max) {\n            global_max = max_vals[j];\n            max_index = idx_vals[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > global_max) {\n            global_max = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    __m128i max_val = _mm_set1_epi8(-128);\n    __m128i max_idx = _mm_setzero_si128();\n    __m128i curr_idx = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi8(16);\n    \n    size_t max_index = 0;\n    int8_t global_max = -128;\n\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i curr_val = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i mask = _mm_cmpgt_epi8(curr_val, max_val);\n        \n        max_val = _mm_or_si128(_mm_and_si128(mask, curr_val), \n                              _mm_andnot_si128(mask, max_val));\n        max_idx = _mm_or_si128(_mm_and_si128(mask, curr_idx),\n                              _mm_andnot_si128(mask, max_idx));\n                              \n        curr_idx = _mm_add_epi8(curr_idx, increment);\n    }\n\n    alignas(16) int8_t max_vals[16];\n    alignas(16) int8_t idx_vals[16];\n    _mm_store_si128((__m128i*)max_vals, max_val);\n    _mm_store_si128((__m128i*)idx_vals, max_idx);\n\n    for (int j = 0; j < 16; j++) {\n        if (max_vals[j] > global_max) {\n            global_max = max_vals[j];\n            max_index = idx_vals[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > global_max) {\n            global_max = src[i];\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_SSE", "completion": "```cpp\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    \n    size_t max_idx = 0;\n    int8_t max_val = src[0];\n    \n    // Process 16 elements at a time using SSE2\n    size_t i;\n    for (i = 0; i + 16 <= length; i += 16) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Find max value in current chunk\n        __m128i max_vec = _mm_set1_epi8(max_val);\n        __m128i mask = _mm_cmpgt_epi8(curr, max_vec);\n        \n        // If any elements are greater than current max\n        if (_mm_movemask_epi8(mask)) {\n            // Find the maximum value and its index\n            for (size_t j = 0; j < 16; j++) {\n                if (src[i + j] > max_val) {\n                    max_val = src[i + j];\n                    max_idx = i + j;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    \n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t simd_width = 8; // Process 8 elements per iteration\n    const size_t simd_length = length & ~(simd_width - 1);\n    \n    for (i = 0; i < simd_length; i += simd_width) {\n        __m128i indices = _mm_set_epi16(i+7, i+6, i+5, i+4, i+3, i+2, i+1, i);\n        __m128i mask_vec = _mm_set1_epi32(mask);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask_cmp = _mm_cmpeq_epi16(and_result, zero);\n        \n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i result = _mm_blendv_epi8(src1_vec, src2_vec, mask_cmp);\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t simd_width = 8; // Process 8 uint16_t elements at a time\n    const size_t simd_length = length & ~(simd_width - 1);\n\n    for (i = 0; i < simd_length; i += simd_width) {\n        __m128i indices = _mm_set_epi16(i+7, i+6, i+5, i+4, i+3, i+2, i+1, i);\n        __m128i mask_vec = _mm_set1_epi32(mask);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask_cmp = _mm_cmpeq_epi16(and_result, zero);\n        \n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i result = _mm_or_si128(\n            _mm_andnot_si128(mask_cmp, src1_vec),\n            _mm_and_si128(mask_cmp, src2_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t simd_width = 8; // Process 8 uint16_t elements at a time\n    const size_t simd_length = length & ~(simd_width - 1);\n\n    for (i = 0; i < simd_length; i += simd_width) {\n        __m128i indices = _mm_set_epi16(i+7, i+6, i+5, i+4, i+3, i+2, i+1, i);\n        __m128i mask_vec = _mm_set1_epi32(mask);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask_cmp = _mm_cmpeq_epi16(and_result, zero);\n        \n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i result = _mm_or_si128(\n            _mm_andnot_si128(mask_cmp, src1_vec),\n            _mm_and_si128(mask_cmp, src2_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t simd_width = 8; // Process 8 elements at a time\n    const size_t simd_length = length & ~(simd_width - 1);\n\n    for (i = 0; i < simd_length; i += simd_width) {\n        __m128i indices = _mm_set_epi16(i+7, i+6, i+5, i+4, i+3, i+2, i+1, i);\n        __m128i mask_vec = _mm_set1_epi32(mask);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask_cmp = _mm_cmpeq_epi16(and_result, zero);\n        \n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(mask_cmp, src2_vec),\n            _mm_andnot_si128(mask_cmp, src1_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_SSE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i;\n    const size_t simd_width = 8; // Process 8 elements at a time\n    const size_t simd_length = length & ~(simd_width - 1);\n\n    for (i = 0; i < simd_length; i += simd_width) {\n        __m128i indices = _mm_set_epi16(i+7, i+6, i+5, i+4, i+3, i+2, i+1, i);\n        __m128i mask_vec = _mm_set1_epi32(mask);\n        __m128i and_result = _mm_and_si128(indices, mask_vec);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask_cmp = _mm_cmpeq_epi16(and_result, zero);\n        \n        __m128i src1_vec = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i src2_vec = _mm_loadu_si128((__m128i*)(src2 + i));\n        \n        __m128i result = _mm_or_si128(\n            _mm_andnot_si128(mask_cmp, src1_vec),\n            _mm_and_si128(mask_cmp, src2_vec)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    const __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    const __m128i mask = _mm_set1_epi8(0x0f);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i x = _mm_loadu_si128((__m128i*)(src + i));\n        \n        __m128i lo = _mm_and_si128(x, mask);\n        __m128i hi = _mm_and_si128(_mm_srli_epi8(x, 4), mask);\n        \n        __m128i popcnt1 = _mm_shuffle_epi8(lookup, lo);\n        __m128i popcnt2 = _mm_shuffle_epi8(lookup, hi);\n        \n        __m128i sum = _mm_add_epi8(popcnt1, popcnt2);\n        \n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 1));\n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 2));\n        \n        __m128i result = _mm_and_si128(sum, _mm_set1_epi32(0xFF));\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i x = _mm_loadu_si128((__m128i*)(src + i));\n        \n        __m128i mask1 = _mm_set1_epi8(0x0f);\n        __m128i low = _mm_and_si128(x, mask1);\n        __m128i high = _mm_and_si128(_mm_srli_epi8(x, 4), mask1);\n        \n        __m128i popcnt1 = _mm_shuffle_epi8(lookup, low);\n        __m128i popcnt2 = _mm_shuffle_epi8(lookup, high);\n        \n        __m128i sum = _mm_add_epi8(popcnt1, popcnt2);\n        \n        __m128i result = _mm_add_epi8(_mm_add_epi8(\n            _mm_add_epi8(sum, _mm_srli_si128(sum, 1)),\n            _mm_add_epi8(_mm_srli_si128(sum, 2), _mm_srli_si128(sum, 3))\n        ), _mm_setzero_si128());\n        \n        _mm_storeu_si128((__m128i*)(dst + i), _mm_and_si128(result, _mm_set1_epi32(0x3F)));\n    }\n    \n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    const __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    const __m128i mask = _mm_set1_epi8(0x0f);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i x = _mm_loadu_si128((__m128i*)(src + i));\n        \n        __m128i lo = _mm_and_si128(x, mask);\n        __m128i hi = _mm_and_si128(_mm_srli_epi8(x, 4), mask);\n        \n        __m128i popcnt1 = _mm_shuffle_epi8(lookup, lo);\n        __m128i popcnt2 = _mm_shuffle_epi8(lookup, hi);\n        \n        __m128i sum = _mm_add_epi8(popcnt1, popcnt2);\n        \n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 1));\n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 2));\n        \n        __m128i result = _mm_and_si128(sum, _mm_set1_epi32(0xFF));\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    const __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    const __m128i mask = _mm_set1_epi8(0x0f);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i x = _mm_loadu_si128((__m128i*)(src + i));\n        \n        __m128i lo = _mm_and_si128(x, mask);\n        __m128i hi = _mm_and_si128(_mm_srli_epi8(x, 4), mask);\n        \n        __m128i popcnt1 = _mm_shuffle_epi8(lookup, lo);\n        __m128i popcnt2 = _mm_shuffle_epi8(lookup, hi);\n        \n        __m128i sum = _mm_add_epi8(popcnt1, popcnt2);\n        \n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 1));\n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 2));\n        \n        __m128i result = _mm_and_si128(sum, _mm_set1_epi32(0xFF));\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SSE", "completion": "```cpp\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i;\n    const __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    const __m128i mask = _mm_set1_epi8(0x0f);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i x = _mm_loadu_si128((__m128i*)(src + i));\n        \n        __m128i lo = x & mask;\n        __m128i hi = _mm_and_si128(_mm_srli_epi8(x, 4), mask);\n        \n        __m128i popcnt1 = _mm_shuffle_epi8(lookup, lo);\n        __m128i popcnt2 = _mm_shuffle_epi8(lookup, hi);\n        \n        __m128i sum = _mm_add_epi8(popcnt1, popcnt2);\n        \n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 1));\n        sum = _mm_add_epi8(sum, _mm_srli_si128(sum, 2));\n        \n        __m128i result = _mm_and_si128(sum, _mm_set1_epi32(0xFF));\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 8);\n    \n    for (i = 0; i < simd_length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        __m128i result = _mm_adds_epu16(v1, v2);\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 8);\n    \n    for (i = 0; i < simd_length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        __m128i result = _mm_adds_epu16(v1, v2);\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 8);\n    \n    for (i = 0; i < simd_length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        __m128i result = _mm_adds_epu16(v1, v2);\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 8);\n    \n    for (i = 0; i < simd_length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        __m128i result = _mm_adds_epu16(v1, v2);\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_SSE", "completion": "```cpp\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 8);\n    \n    for (i = 0; i < simd_length; i += 8) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(src1 + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(src2 + i));\n        __m128i result = _mm_adds_epu16(v1, v2);\n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = (sum > UINT16_MAX) ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d vmin = _mm_set1_pd(-100.0);\n    __m128d vmax = _mm_set1_pd(100.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                __m128d a = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b = _mm_set_pd(B[(k + 1) * p + j], B[k * p + j]);\n                \n                __m128d mask_a = _mm_and_pd(_mm_cmpge_pd(a, vmin), _mm_cmple_pd(a, vmax));\n                __m128d mask_b = _mm_and_pd(_mm_cmpge_pd(b, vmin), _mm_cmple_pd(b, vmax));\n                __m128d mask = _mm_and_pd(mask_a, mask_b);\n                \n                __m128d prod = _mm_mul_pd(a, b);\n                prod = _mm_and_pd(prod, mask);\n                sum = _mm_add_pd(sum, prod);\n            }\n            \n            double temp[2];\n            _mm_storeu_pd(temp, sum);\n            C[i * p + j] = temp[0] + temp[1];\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = A[i * n + n - 1];\n                double b = B[(n - 1) * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    C[i * p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d vmin = _mm_set1_pd(-100.0);\n    __m128d vmax = _mm_set1_pd(100.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n-1; k+=2) {\n                __m128d a = _mm_loadu_pd(&A[i*n + k]);\n                __m128d b = _mm_set_pd(B[(k+1)*p + j], B[k*p + j]);\n                \n                __m128d mask_a_min = _mm_cmpge_pd(a, vmin);\n                __m128d mask_a_max = _mm_cmple_pd(a, vmax);\n                __m128d mask_b_min = _mm_cmpge_pd(b, vmin); \n                __m128d mask_b_max = _mm_cmple_pd(b, vmax);\n                \n                __m128d mask = _mm_and_pd(_mm_and_pd(mask_a_min, mask_a_max),\n                                        _mm_and_pd(mask_b_min, mask_b_max));\n                \n                __m128d prod = _mm_mul_pd(a, b);\n                prod = _mm_and_pd(prod, mask);\n                sum = _mm_add_pd(sum, prod);\n            }\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = A[i*n + n-1];\n                double b = B[(n-1)*p + j];\n                \n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum = _mm_add_pd(sum, _mm_set_pd(0.0, a*b));\n                }\n            }\n            \n            double result[2];\n            _mm_storeu_pd(result, sum);\n            C[i*p + j] = result[0] + result[1];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d min_val = _mm_set1_pd(-100.0);\n    __m128d max_val = _mm_set1_pd(100.0);\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                __m128d a = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b = _mm_set_pd(B[(k + 1) * p + j], B[k * p + j]);\n                \n                __m128d a_mask = _mm_and_pd(\n                    _mm_cmpge_pd(a, min_val),\n                    _mm_cmple_pd(a, max_val)\n                );\n                \n                __m128d b_mask = _mm_and_pd(\n                    _mm_cmpge_pd(b, min_val),\n                    _mm_cmple_pd(b, max_val)\n                );\n                \n                __m128d mask = _mm_and_pd(a_mask, b_mask);\n                __m128d prod = _mm_mul_pd(a, b);\n                prod = _mm_and_pd(prod, mask);\n                \n                sum = _mm_add_pd(sum, prod);\n            }\n\n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = A[i * n + n - 1];\n                double b = B[(n - 1) * p + j];\n                \n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum = _mm_add_pd(sum, _mm_set_pd(0.0, a * b));\n                }\n            }\n            \n            sum = _mm_hadd_pd(sum, zero);\n            _mm_store_sd(&C[i * p + j], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d min_val = _mm_set1_pd(-100.0);\n    __m128d max_val = _mm_set1_pd(100.0);\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                __m128d a = _mm_loadu_pd(&A[i * n + k]);\n                __m128d b = _mm_set_pd(B[(k + 1) * p + j], B[k * p + j]);\n                \n                __m128d a_mask = _mm_and_pd(\n                    _mm_cmpge_pd(a, min_val),\n                    _mm_cmple_pd(a, max_val)\n                );\n                \n                __m128d b_mask = _mm_and_pd(\n                    _mm_cmpge_pd(b, min_val),\n                    _mm_cmple_pd(b, max_val)\n                );\n                \n                __m128d mask = _mm_and_pd(a_mask, b_mask);\n                __m128d prod = _mm_mul_pd(a, b);\n                prod = _mm_and_pd(prod, mask);\n                \n                sum = _mm_add_pd(sum, prod);\n            }\n\n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = A[i * n + n - 1];\n                double b = B[(n - 1) * p + j];\n                \n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum = _mm_add_pd(sum, _mm_set_pd(0.0, a * b));\n                }\n            }\n            \n            sum = _mm_hadd_pd(sum, sum);\n            _mm_store_sd(&C[i * p + j], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SSE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    __m128d vmin = _mm_set1_pd(-100.0);\n    __m128d vmax = _mm_set1_pd(100.0);\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n-1; k+=2) {\n                __m128d a = _mm_loadu_pd(&A[i*n + k]);\n                __m128d b = _mm_set_pd(B[(k+1)*p + j], B[k*p + j]);\n                \n                __m128d mask_a = _mm_and_pd(_mm_cmpge_pd(a, vmin), _mm_cmple_pd(a, vmax));\n                __m128d mask_b = _mm_and_pd(_mm_cmpge_pd(b, vmin), _mm_cmple_pd(b, vmax));\n                __m128d mask = _mm_and_pd(mask_a, mask_b);\n                \n                __m128d prod = _mm_mul_pd(a, b);\n                prod = _mm_and_pd(prod, mask);\n                sum = _mm_add_pd(sum, prod);\n            }\n            \n            double temp[2];\n            _mm_storeu_pd(temp, sum);\n            C[i*p + j] = temp[0] + temp[1];\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = A[i*n + n-1];\n                double b = B[(n-1)*p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    C[i*p + j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t simd_limit = total_elements - (total_elements % 2);\n    \n    for (size_t i = 0; i < simd_limit; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], c);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t simd_size = total_size / 2;\n    size_t remainder = total_size % 2;\n    \n    __m128i* simd_a = (__m128i*)A;\n    __m128i* simd_b = (__m128i*)B; \n    __m128i* simd_c = (__m128i*)C;\n    \n    for (size_t i = 0; i < simd_size; i++) {\n        __m128i a = _mm_load_si128(&simd_a[i]);\n        __m128i b = _mm_load_si128(&simd_b[i]);\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_store_si128(&simd_c[i], sum);\n    }\n    \n    if (remainder) {\n        size_t last = total_size - 1;\n        C[last] = A[last] + B[last];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t simd_limit = total_elements - (total_elements % 2);\n    \n    for (size_t i = 0; i < simd_limit; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], c);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t simd_size = total_size / 2;\n    size_t remainder = total_size % 2;\n\n    __m128i* simd_a = (__m128i*)A;\n    __m128i* simd_b = (__m128i*)B; \n    __m128i* simd_c = (__m128i*)C;\n\n    for (size_t i = 0; i < simd_size; i++) {\n        __m128i a = _mm_load_si128(&simd_a[i]);\n        __m128i b = _mm_load_si128(&simd_b[i]);\n        __m128i sum = _mm_add_epi64(a, b);\n        _mm_store_si128(&simd_c[i], sum);\n    }\n\n    if (remainder) {\n        size_t offset = simd_size * 2;\n        C[offset] = A[offset] + B[offset];\n    }\n}\n```"}
{"task_id": "SimdBench_19_SSE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t simd_limit = total_elements - (total_elements % 2);\n    \n    for (size_t i = 0; i < simd_limit; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i c = _mm_add_epi64(a, b);\n        _mm_storeu_si128((__m128i*)&C[i], c);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t simdLen = length - (length % 4);\n    \n    for (i = 0; i < simdLen; i += 4) {\n        __m128 v1 = _mm_load_ps(src1 + i);\n        __m128 v2 = _mm_load_ps(src2 + i);\n        __m128 sum = _mm_add_ps(v1, v2);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_store_ps(dst + i, rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128 v1 = _mm_load_ps(src1 + i);\n        __m128 v2 = _mm_load_ps(src2 + i);\n        __m128 sum = _mm_add_ps(v1, v2);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_store_ps(dst + i, rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128 v1 = _mm_load_ps(&src1[i]);\n        __m128 v2 = _mm_load_ps(&src2[i]);\n        __m128 sum = _mm_add_ps(v1, v2);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_store_ps(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128 v1 = _mm_load_ps(&src1[i]);\n        __m128 v2 = _mm_load_ps(&src2[i]);\n        __m128 sum = _mm_add_ps(v1, v2);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_store_ps(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SSE", "completion": "```cpp\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128 v1 = _mm_load_ps(&src1[i]);\n        __m128 v2 = _mm_load_ps(&src2[i]);\n        __m128 sum = _mm_add_ps(v1, v2);\n        __m128 rounded = _mm_round_ps(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n        _mm_store_ps(&dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128 neg_one = _mm_set1_ps(-1.0f);\n    __m128 fifty = _mm_set1_ps(50.0f);\n    __m128 zero = _mm_setzero_ps();\n    __m128i two = _mm_set1_epi32(2);\n    __m128i indices = _mm_set_epi32(3,2,1,0);\n    \n    size_t i;\n    for(i = 0; i + 4 <= length; i += 4) {\n        __m128 v1 = _mm_load_ps(&src1[i]);\n        __m128 v2 = _mm_load_ps(&src2[i]);\n        \n        // Calculate absolute difference\n        __m128 diff = _mm_sub_ps(v1, v2);\n        __m128 abs_diff = _mm_max_ps(_mm_sub_ps(zero, diff), diff);\n        \n        // Check if difference is within 50\n        __m128 diff_mask = _mm_cmple_ps(abs_diff, fifty);\n        \n        // Check if index is multiple of 2\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i rem = _mm_and_si128(curr_indices, _mm_set1_epi32(1));\n        __m128 idx_mask = _mm_castsi128_ps(_mm_cmpeq_epi32(rem, _mm_setzero_si128()));\n        \n        // Combine conditions\n        __m128 mask = _mm_and_ps(diff_mask, idx_mask);\n        \n        // Multiply values where mask is true\n        __m128 prod = _mm_mul_ps(v1, v2);\n        \n        // Round up toward positive infinity\n        prod = _mm_ceil_ps(prod);\n        \n        // Select between product and -1 based on mask\n        __m128 result = _mm_or_ps(_mm_and_ps(mask, prod), \n                                 _mm_andnot_ps(mask, neg_one));\n        \n        _mm_store_ps(&dst[i], result);\n    }\n    \n    // Handle remaining elements\n    for(; i < length; i++) {\n        if(fabsf(src1[i] - src2[i]) <= 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    __m128 fifty = _mm_set1_ps(50.0f);\n    __m128 zero = _mm_setzero_ps();\n    __m128i two = _mm_set1_epi32(2);\n    __m128i zero_i = _mm_setzero_si128();\n    __m128i indices = _mm_set_epi32(3,2,1,0);\n\n    size_t i;\n    for(i = 0; i + 4 <= length; i += 4) {\n        __m128 v1 = _mm_load_ps(&src1[i]);\n        __m128 v2 = _mm_load_ps(&src2[i]);\n        \n        // Calculate absolute difference\n        __m128 diff = _mm_sub_ps(v1, v2);\n        __m128 abs_diff = _mm_max_ps(_mm_sub_ps(zero, diff), diff);\n        \n        // Check if difference is within 50\n        __m128 diff_mask = _mm_cmple_ps(abs_diff, fifty);\n        \n        // Check if index is multiple of 2\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i rem = _mm_and_si128(curr_indices, _mm_set1_epi32(1));\n        __m128i idx_mask = _mm_cmpeq_epi32(rem, zero_i);\n        __m128 idx_maskf = _mm_castsi128_ps(idx_mask);\n        \n        // Combine conditions\n        __m128 mask = _mm_and_ps(diff_mask, idx_maskf);\n        \n        // Multiply values where mask is true\n        __m128 mul = _mm_mul_ps(v1, v2);\n        \n        // Round up toward positive infinity\n        mul = _mm_ceil_ps(mul);\n        \n        // Select between multiplication result and -1 based on mask\n        __m128 result = _mm_or_ps(_mm_and_ps(mask, mul), \n                                 _mm_andnot_ps(mask, minus_one));\n        \n        _mm_store_ps(&dst[i], result);\n        \n        indices = _mm_add_epi32(indices, _mm_set1_epi32(4));\n    }\n\n    // Handle remaining elements\n    for(; i < length; i++) {\n        if(fabs(src1[i] - src2[i]) <= 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    __m128 fifty = _mm_set1_ps(50.0f);\n    __m128 zero = _mm_setzero_ps();\n    __m128i two = _mm_set1_epi32(2);\n    __m128i zero_i = _mm_setzero_si128();\n    __m128i indices = _mm_set_epi32(3,2,1,0);\n\n    size_t i;\n    for(i = 0; i + 4 <= length; i += 4) {\n        __m128 v1 = _mm_load_ps(src1 + i);\n        __m128 v2 = _mm_load_ps(src2 + i);\n        \n        // Calculate absolute difference\n        __m128 diff = _mm_sub_ps(v1, v2);\n        __m128 abs_diff = _mm_max_ps(_mm_sub_ps(zero, diff), diff);\n        \n        // Check if difference is within 50\n        __m128 diff_mask = _mm_cmple_ps(abs_diff, fifty);\n        \n        // Check if index is multiple of 2\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i rem = _mm_and_si128(curr_indices, _mm_set1_epi32(1));\n        __m128i idx_mask = _mm_cmpeq_epi32(rem, zero_i);\n        __m128 idx_mask_ps = _mm_castsi128_ps(idx_mask);\n        \n        // Combine conditions\n        __m128 mask = _mm_and_ps(diff_mask, idx_mask_ps);\n        \n        // Multiply values where mask is true\n        __m128 prod = _mm_mul_ps(v1, v2);\n        \n        // Round up toward positive infinity\n        prod = _mm_ceil_ps(prod);\n        \n        // Select between product and -1 based on mask\n        __m128 result = _mm_or_ps(\n            _mm_and_ps(mask, prod),\n            _mm_andnot_ps(mask, minus_one)\n        );\n        \n        _mm_store_ps(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for(; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if(diff <= 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    __m128 fifty = _mm_set1_ps(50.0f);\n    __m128 zero = _mm_setzero_ps();\n    __m128i two = _mm_set1_epi32(2);\n    __m128i indices = _mm_set_epi32(3,2,1,0);\n    \n    size_t i;\n    for(i = 0; i + 4 <= length; i += 4) {\n        __m128 v1 = _mm_load_ps(src1 + i);\n        __m128 v2 = _mm_load_ps(src2 + i);\n        \n        // Calculate absolute difference\n        __m128 diff = _mm_sub_ps(v1, v2);\n        __m128 abs_diff = _mm_max_ps(_mm_sub_ps(zero, diff), diff);\n        \n        // Check if difference is within 50\n        __m128 diff_mask = _mm_cmple_ps(abs_diff, fifty);\n        \n        // Check if index is multiple of 2\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i rem = _mm_and_si128(curr_indices, _mm_set1_epi32(1));\n        __m128i idx_mask = _mm_cmpeq_epi32(rem, _mm_setzero_si128());\n        __m128 idx_maskf = _mm_castsi128_ps(idx_mask);\n        \n        // Combine conditions\n        __m128 mask = _mm_and_ps(diff_mask, idx_maskf);\n        \n        // Multiply values where mask is true\n        __m128 prod = _mm_mul_ps(v1, v2);\n        \n        // Round up toward positive infinity\n        prod = _mm_ceil_ps(prod);\n        \n        // Select between product and -1 based on mask\n        __m128 result = _mm_or_ps(_mm_and_ps(mask, prod), \n                                 _mm_andnot_ps(mask, minus_one));\n        \n        _mm_store_ps(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for(; i < length; i++) {\n        if(fabsf(src1[i] - src2[i]) <= 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_SSE", "completion": "```cpp\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    __m128 minus_one = _mm_set1_ps(-1.0f);\n    __m128 fifty = _mm_set1_ps(50.0f);\n    __m128 zero = _mm_setzero_ps();\n    __m128i two = _mm_set1_epi32(2);\n    __m128i zero_i = _mm_setzero_si128();\n    __m128i indices = _mm_set_epi32(3,2,1,0);\n\n    size_t i;\n    for(i = 0; i + 4 <= length; i += 4) {\n        __m128 v1 = _mm_load_ps(src1 + i);\n        __m128 v2 = _mm_load_ps(src2 + i);\n        \n        // Calculate absolute difference\n        __m128 diff = _mm_sub_ps(v1, v2);\n        __m128 abs_diff = _mm_max_ps(_mm_sub_ps(zero, diff), diff);\n        __m128 within_fifty = _mm_cmple_ps(abs_diff, fifty);\n        \n        // Check if indices are multiples of 2\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i remainders = _mm_and_si128(_mm_set1_epi32(1), curr_indices);\n        __m128i is_multiple = _mm_cmpeq_epi32(remainders, zero_i);\n        __m128 is_multiple_f = _mm_castsi128_ps(is_multiple);\n        \n        // Combine conditions\n        __m128 conditions = _mm_and_ps(within_fifty, is_multiple_f);\n        \n        // Multiply and round up\n        __m128 product = _mm_mul_ps(v1, v2);\n        __m128 rounded = _mm_ceil_ps(product);\n        \n        // Select between rounded product and -1 based on conditions\n        __m128 result = _mm_or_ps(\n            _mm_and_ps(conditions, rounded),\n            _mm_andnot_ps(conditions, minus_one)\n        );\n        \n        _mm_store_ps(dst + i, result);\n    }\n    \n    // Handle remaining elements\n    for(; i < length; i++) {\n        float diff = fabsf(src1[i] - src2[i]);\n        if(diff <= 50.0f && (i % 2 == 0)) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total = m * n;\n    size_t i;\n    \n    for (i = 0; i < total - 1; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    for (; i < total; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t aligned_size = total - (total % 2);\n    \n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    for (size_t i = aligned_size; i < total; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    size_t total = m * n;\n    size_t i;\n    \n    for (i = 0; i < total - 1; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result);\n    }\n    \n    for (; i < total; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t aligned_size = total & ~1ULL;\n    \n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result);\n    }\n    \n    for (size_t i = aligned_size; i < total; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SSE", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t aligned_size = total - (total % 2);\n    \n    __m128d scalar_vec = _mm_set1_pd(scalar);\n    \n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d mat_vec = _mm_loadu_pd(&mat[i]);\n        __m128d result = _mm_mul_pd(mat_vec, scalar_vec);\n        _mm_storeu_pd(&dst[i], result);\n    }\n    \n    for (size_t i = aligned_size; i < total; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        // Calculate sum of squares using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            sum = _mm_add_ps(sum, _mm_mul_ps(v, v));\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        float norm = _mm_cvtss_f32(sums);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            norm += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        norm = 1.0f / sqrtf(norm);\n        __m128 norm_vec = _mm_set1_ps(norm);\n        \n        // Normalize row using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            _mm_storeu_ps(row + j, _mm_mul_ps(v, norm_vec));\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        // Calculate sum of squares using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            sum = _mm_add_ps(sum, _mm_mul_ps(v, v));\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        float norm = _mm_cvtss_f32(sums);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            norm += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        norm = 1.0f / sqrtf(norm);\n        __m128 norm_vec = _mm_set1_ps(norm);\n        \n        // Normalize row using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            _mm_storeu_ps(row + j, _mm_mul_ps(v, norm_vec));\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        // Calculate sum of squares using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            sum = _mm_add_ps(sum, _mm_mul_ps(v, v));\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        float norm = _mm_cvtss_f32(sums);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            norm += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        norm = 1.0f / sqrtf(norm);\n        __m128 norm_vec = _mm_set1_ps(norm);\n        \n        // Normalize row using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            _mm_storeu_ps(row + j, _mm_mul_ps(v, norm_vec));\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        // Calculate sum of squares using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            sum = _mm_add_ps(sum, _mm_mul_ps(v, v));\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        float norm = _mm_cvtss_f32(sums);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            norm += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        norm = 1.0f / sqrtf(norm);\n        __m128 norm_vec = _mm_set1_ps(norm);\n        \n        // Normalize row using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            _mm_storeu_ps(row + j, _mm_mul_ps(v, norm_vec));\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SSE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        // Calculate sum of squares using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            sum = _mm_add_ps(sum, _mm_mul_ps(v, v));\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        float norm = _mm_cvtss_f32(sums);\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            norm += row[j] * row[j];\n        }\n        \n        // Calculate reciprocal square root\n        norm = 1.0f / sqrtf(norm);\n        __m128 norm_vec = _mm_set1_ps(norm);\n        \n        // Normalize the row using SIMD\n        for (j = 0; j <= n-4; j += 4) {\n            __m128 v = _mm_loadu_ps(row + j);\n            _mm_storeu_ps(row + j, _mm_mul_ps(v, norm_vec));\n        }\n        \n        // Handle remaining elements\n        for (; j < n; j++) {\n            row[j] *= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            \n            double temp = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                temp += mat1[i * n + n - 1] * mat2[(n - 1) * p + j];\n            }\n            \n            dst[i * p + j] = round(temp);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = mat1[i * n + n - 1];\n                double b = mat2[(n - 1) * p + j];\n                sum = _mm_add_pd(sum, _mm_mul_pd(_mm_set1_pd(a), _mm_set1_pd(b)));\n            }\n            \n            // Horizontal add of sum vector\n            sum = _mm_add_pd(sum, _mm_unpackhi_pd(sum, sum));\n            \n            // Round to nearest integer\n            __m128d rounded = _mm_round_pd(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n            \n            // Store result\n            _mm_store_sd(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            size_t k;\n            \n            for (k = 0; k + 1 < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_set_pd(mat2[(k + 1) * p + j], mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            \n            double temp = _mm_cvtsd_f64(_mm_hadd_pd(sum, sum));\n            \n            if (k < n) {\n                temp += mat1[i * n + k] * mat2[k * p + j];\n            }\n            \n            dst[i * p + j] = round(temp);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < n - 1; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_loadu_pd(&mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            \n            // Handle remaining element if n is odd\n            if (n % 2) {\n                double a = mat1[i * n + n - 1];\n                double b = mat2[(n - 1) * p + j];\n                sum = _mm_add_pd(sum, _mm_mul_pd(_mm_set1_pd(a), _mm_set1_pd(b)));\n            }\n            \n            // Horizontal add of sum vector\n            sum = _mm_add_pd(sum, _mm_unpackhi_pd(sum, sum));\n            \n            // Round to nearest integer\n            __m128d rounded = _mm_round_pd(sum, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n            \n            // Store result\n            _mm_store_sd(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SSE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            __m128d sum = _mm_setzero_pd();\n            size_t k;\n            \n            for (k = 0; k + 1 < n; k += 2) {\n                __m128d a = _mm_loadu_pd(&mat1[i * n + k]);\n                __m128d b = _mm_set_pd(mat2[(k + 1) * p + j], mat2[k * p + j]);\n                sum = _mm_add_pd(sum, _mm_mul_pd(a, b));\n            }\n            \n            double temp = _mm_cvtsd_f64(_mm_hadd_pd(sum, sum));\n            \n            // Handle remaining element if n is odd\n            if (k < n) {\n                temp += mat1[i * n + k] * mat2[k * p + j];\n            }\n            \n            dst[i * p + j] = round(temp);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const __m128 quarter = _mm_set1_ps(0.25f);\n    const __m128 four = _mm_set1_ps(4.0f);\n    \n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row0 = _mm_loadu_ps(&src[(i + 0) * cols + j]);\n            __m128 row1 = _mm_loadu_ps(&src[(i + 1) * cols + j]); \n            __m128 row2 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            row0 = _mm_mul_ps(row0, four);\n            row1 = _mm_mul_ps(row1, four);\n            row2 = _mm_mul_ps(row2, four);\n            row3 = _mm_mul_ps(row3, four);\n\n            row0 = _mm_round_ps(row0, _MM_FROUND_TO_NEAREST_INT);\n            row1 = _mm_round_ps(row1, _MM_FROUND_TO_NEAREST_INT);\n            row2 = _mm_round_ps(row2, _MM_FROUND_TO_NEAREST_INT);\n            row3 = _mm_round_ps(row3, _MM_FROUND_TO_NEAREST_INT);\n\n            row0 = _mm_mul_ps(row0, quarter);\n            row1 = _mm_mul_ps(row1, quarter);\n            row2 = _mm_mul_ps(row2, quarter);\n            row3 = _mm_mul_ps(row3, quarter);\n\n            // Transpose 4x4 block\n            _MM_TRANSPOSE4_PS(row0, row1, row2, row3);\n\n            // Store transposed and rounded data\n            _mm_storeu_ps(&dst[j * rows + i], row0);\n            _mm_storeu_ps(&dst[j * rows + i + rows], row1);\n            _mm_storeu_ps(&dst[j * rows + i + rows * 2], row2);\n            _mm_storeu_ps(&dst[j * rows + i + rows * 3], row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    __m128 quarter = _mm_set1_ps(0.25f);\n    __m128 half = _mm_set1_ps(0.5f);\n    __m128 four = _mm_set1_ps(4.0f);\n    \n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            __m128 row0 = _mm_loadu_ps(&src[(i + 0) * cols + j]);\n            __m128 row1 = _mm_loadu_ps(&src[(i + 1) * cols + j]);\n            __m128 row2 = _mm_loadu_ps(&src[(i + 2) * cols + j]);\n            __m128 row3 = _mm_loadu_ps(&src[(i + 3) * cols + j]);\n\n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            row0 = _mm_mul_ps(row0, four);\n            row1 = _mm_mul_ps(row1, four);\n            row2 = _mm_mul_ps(row2, four);\n            row3 = _mm_mul_ps(row3, four);\n\n            row0 = _mm_add_ps(row0, half);\n            row1 = _mm_add_ps(row1, half);\n            row2 = _mm_add_ps(row2, half);\n            row3 = _mm_add_ps(row3, half);\n\n            row0 = _mm_cvtepi32_ps(_mm_cvtps_epi32(row0));\n            row1 = _mm_cvtepi32_ps(_mm_cvtps_epi32(row1));\n            row2 = _mm_cvtepi32_ps(_mm_cvtps_epi32(row2));\n            row3 = _mm_cvtepi32_ps(_mm_cvtps_epi32(row3));\n\n            row0 = _mm_mul_ps(row0, quarter);\n            row1 = _mm_mul_ps(row1, quarter);\n            row2 = _mm_mul_ps(row2, quarter);\n            row3 = _mm_mul_ps(row3, quarter);\n\n            // Transpose 4x4 matrix\n            _MM_TRANSPOSE4_PS(row0, row1, row2, row3);\n\n            // Store transposed and rounded results\n            _mm_storeu_ps(&dst[j * rows + i], row0);\n            _mm_storeu_ps(&dst[(j + 1) * rows + i], row1);\n            _mm_storeu_ps(&dst[(j + 2) * rows + i], row2);\n            _mm_storeu_ps(&dst[(j + 3) * rows + i], row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const __m128 quarter = _mm_set1_ps(0.25f);\n    const __m128 recip_quarter = _mm_set1_ps(4.0f);\n    \n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t src_idx = i * cols + j;\n            size_t dst_idx = j * rows + i;\n            \n            __m128 col;\n            if (i + 4 <= rows) {\n                col = _mm_set_ps(src[src_idx + 3*cols],\n                               src[src_idx + 2*cols],\n                               src[src_idx + cols],\n                               src[src_idx]);\n            } else {\n                float temp[4] = {0.0f, 0.0f, 0.0f, 0.0f};\n                for (size_t k = 0; k < rows-i; k++) {\n                    temp[k] = src[src_idx + k*cols];\n                }\n                col = _mm_loadu_ps(temp);\n            }\n            \n            // Round to nearest quarter\n            __m128 scaled = _mm_mul_ps(col, recip_quarter);\n            __m128 rounded = _mm_round_ps(scaled, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n            __m128 result = _mm_mul_ps(rounded, quarter);\n            \n            if (i + 4 <= rows) {\n                _mm_storeu_ps(&dst[dst_idx], result);\n            } else {\n                float temp[4];\n                _mm_storeu_ps(temp, result);\n                for (size_t k = 0; k < rows-i; k++) {\n                    dst[dst_idx + k] = temp[k];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const __m128 quarter = _mm_set1_ps(0.25f);\n    const __m128 reciprocal_quarter = _mm_set1_ps(4.0f);\n    \n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t src_idx = i * cols + j;\n            size_t dst_idx = j * rows + i;\n            \n            __m128 col;\n            if (i + 4 <= rows) {\n                col = _mm_set_ps(src[src_idx + 3*cols],\n                                src[src_idx + 2*cols],\n                                src[src_idx + cols],\n                                src[src_idx]);\n            } else {\n                float temp[4] = {0.0f, 0.0f, 0.0f, 0.0f};\n                for (size_t k = 0; k < rows-i; k++) {\n                    temp[k] = src[src_idx + k*cols];\n                }\n                col = _mm_loadu_ps(temp);\n            }\n            \n            // Round to nearest quarter\n            __m128 scaled = _mm_mul_ps(col, reciprocal_quarter);\n            __m128 rounded = _mm_round_ps(scaled, _MM_FROUND_TO_NEAREST_INT | _MM_FROUND_NO_EXC);\n            __m128 result = _mm_mul_ps(rounded, quarter);\n            \n            if (i + 4 <= rows) {\n                _mm_storeu_ps(&dst[dst_idx], result);\n            } else {\n                float temp[4];\n                _mm_storeu_ps(temp, result);\n                for (size_t k = 0; k < rows-i; k++) {\n                    dst[dst_idx + k] = temp[k];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SSE", "completion": "```cpp\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const __m128 quarter = _mm_set1_ps(0.25f);\n    const __m128 recip_quarter = _mm_set1_ps(4.0f);\n    \n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t src_idx = i * cols + j;\n            size_t dst_idx = j * rows + i;\n            \n            __m128 v = _mm_loadu_ps(&src[src_idx]);\n            \n            // Round to nearest quarter by multiplying by 4, rounding, then dividing by 4\n            v = _mm_mul_ps(v, recip_quarter);\n            v = _mm_round_ps(v, _MM_FROUND_TO_NEAREST_INT);\n            v = _mm_mul_ps(v, quarter);\n            \n            // Transpose by storing elements at transposed indices\n            _mm_store_ss(&dst[dst_idx], v);\n            _mm_store_ss(&dst[dst_idx + 1], _mm_shuffle_ps(v, v, _MM_SHUFFLE(1,1,1,1)));\n            _mm_store_ss(&dst[dst_idx + 2], _mm_shuffle_ps(v, v, _MM_SHUFFLE(2,2,2,2)));\n            _mm_store_ss(&dst[dst_idx + 3], _mm_shuffle_ps(v, v, _MM_SHUFFLE(3,3,3,3)));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3;\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 a = _mm_load_ps(tensor1 + i);\n        __m128 b = _mm_load_ps(tensor2 + i);\n        __m128 sub = _mm_sub_ps(a, b);\n        \n        // Round towards zero by:\n        // 1. Get the sign mask\n        __m128 sign = _mm_and_ps(sub, _mm_set1_ps(-0.0f));\n        \n        // 2. Add/subtract 0.5f based on sign\n        __m128 offset = _mm_or_ps(sign, _mm_set1_ps(0.5f));\n        __m128 added = _mm_add_ps(sub, offset);\n        \n        // 3. Truncate\n        __m128 rounded = _mm_cvtepi32_ps(_mm_cvttps_epi32(added));\n        \n        // Store result\n        _mm_store_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total_size; i++) {\n        float sub = tensor1[i] - tensor2[i];\n        dst[i] = (sub > 0) ? floorf(sub) : ceilf(sub);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3;\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 a = _mm_load_ps(tensor1 + i);\n        __m128 b = _mm_load_ps(tensor2 + i);\n        __m128 sub = _mm_sub_ps(a, b);\n        \n        // Round towards zero by:\n        // 1. Get the sign mask\n        __m128 sign = _mm_and_ps(sub, _mm_set1_ps(-0.0f));\n        \n        // 2. Add/subtract 0.5f based on sign\n        __m128 offset = _mm_or_ps(sign, _mm_set1_ps(0.5f));\n        __m128 temp = _mm_add_ps(sub, offset);\n        \n        // 3. Truncate\n        __m128 rounded = _mm_cvtepi32_ps(_mm_cvttps_epi32(temp));\n        \n        // 4. Compare with original for values exactly halfway between integers\n        __m128 mask = _mm_cmpeq_ps(temp, sub);\n        rounded = _mm_or_ps(_mm_and_ps(mask, sub), \n                           _mm_andnot_ps(mask, rounded));\n        \n        _mm_store_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        if (diff > 0) {\n            dst[i] = floorf(diff);\n        } else {\n            dst[i] = ceilf(diff);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3;\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 a = _mm_load_ps(tensor1 + i);\n        __m128 b = _mm_load_ps(tensor2 + i);\n        __m128 sub = _mm_sub_ps(a, b);\n        \n        // Round towards zero by:\n        // 1. Get the sign mask\n        __m128 sign = _mm_and_ps(sub, _mm_set1_ps(-0.0f));\n        \n        // 2. Add 0.5 for positive numbers, subtract 0.5 for negative\n        __m128 offset = _mm_or_ps(_mm_set1_ps(0.5f), sign);\n        __m128 added = _mm_add_ps(sub, offset);\n        \n        // 3. Truncate\n        __m128 rounded = _mm_cvtepi32_ps(_mm_cvttps_epi32(added));\n        \n        // Store result\n        _mm_store_ps(dst + i, rounded);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total_size; i++) {\n        float sub = tensor1[i] - tensor2[i];\n        dst[i] = (sub > 0) ? floorf(sub + 0.5f) : ceilf(sub - 0.5f);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3;\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 a = _mm_load_ps(tensor1 + i);\n        __m128 b = _mm_load_ps(tensor2 + i);\n        __m128 sub = _mm_sub_ps(a, b);\n        \n        // Round towards zero by:\n        // 1. Get the sign mask\n        __m128 sign = _mm_and_ps(sub, _mm_set1_ps(-0.0f));\n        // 2. Add sign to truncated value to round towards zero\n        __m128 result = _mm_add_ps(_mm_cvtepi32_ps(_mm_cvttps_epi32(sub)), sign);\n        \n        _mm_store_ps(dst + i, result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total_size; i++) {\n        float sub = tensor1[i] - tensor2[i];\n        dst[i] = (sub > 0) ? floorf(sub) : ceilf(sub);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SSE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 4;\n    size_t remainder = total_size % 4;\n\n    for (size_t i = 0; i < vec_size; i++) {\n        __m128 v1 = _mm_load_ps(tensor1 + 4*i);\n        __m128 v2 = _mm_load_ps(tensor2 + 4*i);\n        __m128 diff = _mm_sub_ps(v1, v2);\n        \n        // Round towards zero by:\n        // 1. Get the sign mask\n        __m128 sign = _mm_and_ps(diff, _mm_set1_ps(-0.0f));\n        // 2. Add/subtract 0.5f based on sign\n        __m128 offset = _mm_or_ps(sign, _mm_set1_ps(0.5f));\n        __m128 sum = _mm_add_ps(diff, offset);\n        // 3. Truncate\n        __m128 rounded = _mm_cvtepi32_ps(_mm_cvttps_epi32(sum));\n        // 4. Subtract the offset for negative numbers\n        rounded = _mm_sub_ps(rounded, offset);\n        \n        _mm_store_ps(dst + 4*i, rounded);\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 4; i < total_size; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff > 0) ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t simd_size = total / 2;\n    size_t remainder = total % 2;\n    \n    __m128d* simd_mat1 = (__m128d*)mat1;\n    __m128d* simd_mat2 = (__m128d*)mat2;\n    __m128d* simd_dst = (__m128d*)dst;\n    \n    for (size_t i = 0; i < simd_size; i++) {\n        __m128d v1 = _mm_load_pd((double*)&simd_mat1[i]);\n        __m128d v2 = _mm_load_pd((double*)&simd_mat2[i]);\n        __m128d result = _mm_mul_pd(v1, v2);\n        _mm_store_pd((double*)&simd_dst[i], result);\n    }\n    \n    if (remainder) {\n        size_t last = total - 1;\n        dst[last] = mat1[last] * mat2[last];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t simd_limit = total - (total % 2);\n    \n    for (size_t i = 0; i < simd_limit; i += 2) {\n        __m128d v1 = _mm_loadu_pd(&mat1[i]);\n        __m128d v2 = _mm_loadu_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(v1, v2);\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t simd_limit = total - (total % 2);\n    \n    for (size_t i = 0; i < simd_limit; i += 2) {\n        __m128d v1 = _mm_loadu_pd(&mat1[i]);\n        __m128d v2 = _mm_loadu_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(v1, v2);\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t simd_limit = total - (total % 2);\n    \n    for (size_t i = 0; i < simd_limit; i += 2) {\n        __m128d v1 = _mm_loadu_pd(&mat1[i]);\n        __m128d v2 = _mm_loadu_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(v1, v2);\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_SSE", "completion": "```cpp\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t simd_width = total / 2 * 2;\n    \n    for (size_t i = 0; i < simd_width; i += 2) {\n        __m128d v1 = _mm_loadu_pd(&mat1[i]);\n        __m128d v2 = _mm_loadu_pd(&mat2[i]);\n        __m128d result = _mm_mul_pd(v1, v2);\n        _mm_storeu_pd(&dst[i], result);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_width; i < total; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            __m128 mul = _mm_mul_ps(mat_vec, vec_vec);\n            sum = _mm_add_ps(sum, mul);\n        }\n        \n        float temp[4];\n        _mm_storeu_ps(temp, sum);\n        float result = temp[0] + temp[1] + temp[2] + temp[3];\n        \n        for (; j < n; j++) {\n            result += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_row = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vals = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_row, vec_vals));\n        }\n        \n        float temp[4];\n        _mm_storeu_ps(temp, sum);\n        float result = temp[0] + temp[1] + temp[2] + temp[3];\n        \n        for (; j < n; j++) {\n            result += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_row = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vals = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_row, vec_vals));\n        }\n        \n        float temp[4];\n        _mm_storeu_ps(temp, sum);\n        float result = temp[0] + temp[1] + temp[2] + temp[3];\n        \n        for (; j < n; j++) {\n            result += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_row = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vals = _mm_loadu_ps(&vec[j]);\n            __m128 mul = _mm_mul_ps(mat_row, vec_vals);\n            sum = _mm_add_ps(sum, mul);\n        }\n        \n        float temp[4];\n        _mm_storeu_ps(temp, sum);\n        float result = temp[0] + temp[1] + temp[2] + temp[3];\n        \n        for (; j < n; j++) {\n            result += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SSE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        __m128 sum = _mm_setzero_ps();\n        size_t j;\n        \n        for (j = 0; j + 4 <= n; j += 4) {\n            __m128 mat_vec = _mm_loadu_ps(&mat[i * n + j]);\n            __m128 vec_vec = _mm_loadu_ps(&vec[j]);\n            sum = _mm_add_ps(sum, _mm_mul_ps(mat_vec, vec_vec));\n        }\n        \n        float temp[4];\n        _mm_storeu_ps(temp, sum);\n        float result = temp[0] + temp[1] + temp[2] + temp[3];\n        \n        for (; j < n; j++) {\n            result += mat[i * n + j] * vec[j];\n        }\n        \n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t aligned_size = total - (total % 2);\n    \n    __m128d sum = _mm_setzero_pd();\n    \n    for(size_t i = 0; i < aligned_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    double total_sum = result[0] + result[1];\n    \n    for(size_t i = aligned_size; i < total; i++) {\n        total_sum += mat[i];\n    }\n    \n    return total_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t aligned_size = total - (total % 2);\n    \n    __m128d sum = _mm_setzero_pd();\n    \n    for(size_t i = 0; i < aligned_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double result[2];\n    _mm_storeu_pd(result, sum);\n    double total_sum = result[0] + result[1];\n    \n    for(size_t i = aligned_size; i < total; i++) {\n        total_sum += mat[i];\n    }\n    \n    return total_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    __m128d sum = _mm_setzero_pd();\n    size_t total = m * n;\n    size_t i;\n    \n    // Process 2 elements at a time\n    for(i = 0; i < total - (total % 2); i += 2) {\n        __m128d v = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, v);\n    }\n    \n    // Handle remaining element if total is odd\n    double final_sum = 0.0;\n    if(i < total) {\n        final_sum = mat[i];\n    }\n    \n    // Extract and sum the two doubles from the SSE register\n    double temp[2];\n    _mm_storeu_pd(temp, sum);\n    final_sum += temp[0] + temp[1];\n    \n    return final_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t aligned_size = total - (total % 2);\n    \n    __m128d sum = _mm_setzero_pd();\n    \n    for(size_t i = 0; i < aligned_size; i += 2) {\n        __m128d vec = _mm_load_pd(&mat[i]);\n        sum = _mm_add_pd(sum, vec);\n    }\n    \n    double result[2];\n    _mm_store_pd(result, sum);\n    double total_sum = result[0] + result[1];\n    \n    for(size_t i = aligned_size; i < total; i++) {\n        total_sum += mat[i];\n    }\n    \n    return total_sum / total;\n}\n```"}
{"task_id": "SimdBench_29_SSE", "completion": "```cpp\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    __m128d sum = _mm_setzero_pd();\n    size_t total = m * n;\n    size_t i;\n    \n    // Process 2 elements at a time\n    for(i = 0; i < total - (total % 2); i += 2) {\n        __m128d v = _mm_loadu_pd(&mat[i]);\n        sum = _mm_add_pd(sum, v);\n    }\n    \n    // Handle remaining element if total is odd\n    double remaining = 0.0;\n    if(i < total) {\n        remaining = mat[i];\n    }\n    \n    // Sum the 2 doubles in the SSE register\n    __m128d temp = _mm_hadd_pd(sum, sum);\n    double final_sum;\n    _mm_store_sd(&final_sum, temp);\n    \n    // Add remaining element and divide by total\n    return (final_sum + remaining) / total;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(curr_row + col));\n            __m128i next = _mm_loadu_si128((__m128i*)(curr_row + col + 1));\n            \n            __m128i cmp;\n            if (ascending) {\n                cmp = _mm_cmplt_epi32(curr, next);\n            } else {\n                cmp = _mm_cmpgt_epi32(curr, next);\n            }\n            \n            int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n            if (ascending && mask != 0xF) {\n                return false;\n            }\n            if (!ascending && mask != 0xF) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(curr_row + col));\n            __m128i next = _mm_loadu_si128((__m128i*)(curr_row + col + 1));\n            \n            __m128i cmp;\n            if (ascending) {\n                cmp = _mm_cmplt_epi32(curr, next);\n            } else {\n                cmp = _mm_cmpgt_epi32(curr, next);\n            }\n            \n            int mask = _mm_movemask_ps((__m128)cmp);\n            if (mask != 0xF) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(curr_row + col));\n            __m128i next = _mm_loadu_si128((__m128i*)(curr_row + col + 1));\n            \n            __m128i cmp;\n            if (ascending) {\n                cmp = _mm_cmplt_epi32(curr, next);\n            } else {\n                cmp = _mm_cmpgt_epi32(curr, next);\n            }\n            \n            int mask = _mm_movemask_ps((__m128)cmp);\n            if (mask != 0xF) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(curr_row + col));\n            __m128i next = _mm_loadu_si128((__m128i*)(curr_row + col + 1));\n            \n            __m128i cmp;\n            if (ascending) {\n                cmp = _mm_cmplt_epi32(curr, next);\n            } else {\n                cmp = _mm_cmpgt_epi32(curr, next);\n            }\n            \n            int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n            if (mask != 0xF) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SSE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        for (size_t col = 0; col < cols - 4; col += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(curr_row + col));\n            __m128i next = _mm_loadu_si128((__m128i*)(curr_row + col + 1));\n            \n            __m128i cmp;\n            if (ascending) {\n                cmp = _mm_cmplt_epi32(curr, next);\n            } else {\n                cmp = _mm_cmpgt_epi32(curr, next);\n            }\n            \n            int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n            if (ascending && mask != 0xF) {\n                return false;\n            }\n            if (!ascending && mask != 0xF) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t col = cols - (cols % 4); col < cols - 1; col++) {\n            if (ascending) {\n                if (curr_row[col] > curr_row[col + 1]) {\n                    return false;\n                }\n            } else {\n                if (curr_row[col] < curr_row[col + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    __m128i vbase = _mm_set1_epi16(base);\n    size_t i;\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i vsrc = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i vdiv = _mm_div_epi16(vsrc, vbase);\n        __m128i vmul = _mm_mullo_epi16(vdiv, vbase);\n        _mm_storeu_si128((__m128i*)(dst + i), vmul);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i;\n    __m128i vbase = _mm_set1_epi16(base);\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i vsrc = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i vdiv = _mm_div_epi16(vsrc, vbase);\n        __m128i vmul = _mm_mullo_epi16(vdiv, vbase);\n        _mm_storeu_si128((__m128i*)(dst + i), vmul);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i;\n    __m128i vbase = _mm_set1_epi16(base);\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i vsrc = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i vdiv = _mm_div_epi16(vsrc, vbase);\n        __m128i vmul = _mm_mullo_epi16(vdiv, vbase);\n        _mm_storeu_si128((__m128i*)(dst + i), vmul);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i;\n    __m128i vbase = _mm_set1_epi16(base);\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i vsrc = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i vdiv = _mm_div_epi16(vsrc, vbase);\n        __m128i vmul = _mm_mullo_epi16(vdiv, vbase);\n        _mm_storeu_si128((__m128i*)(dst + i), vmul);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31_SSE", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i;\n    __m128i vbase = _mm_set1_epi16(base);\n    \n    for (i = 0; i + 8 <= length; i += 8) {\n        __m128i vsrc = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i vdiv = _mm_div_epi16(vsrc, vbase);\n        __m128i vmul = _mm_mullo_epi16(vdiv, vbase);\n        _mm_storeu_si128((__m128i*)(dst + i), vmul);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (src[i] / base) * base;\n    }\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t simd_width = 2;\n    const size_t simd_cols = cols / simd_width;\n    const size_t remainder = cols % simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        for (size_t j = 0; j < simd_cols; j++) {\n            __m128d row_vec = _mm_loadu_pd(row + j * simd_width);\n            __m128d vec = _mm_loadu_pd(vector + j * simd_width);\n            __m128d cmp = _mm_cmpeq_pd(row_vec, vec);\n            \n            if (_mm_movemask_pd(cmp) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (!row_match) continue;\n\n        // Handle remaining elements\n        for (size_t j = simd_cols * simd_width; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t aligned_cols = cols - (cols % 2);\n    \n    for (size_t i = 0; i < rows; i++) {\n        bool row_match = true;\n        size_t j;\n        \n        for (j = 0; j < aligned_cols; j += 2) {\n            __m128d row_vec = _mm_loadu_pd(&matrix[i * cols + j]);\n            __m128d cmp_vec = _mm_loadu_pd(&vector[j]);\n            __m128d cmp_result = _mm_cmpeq_pd(row_vec, cmp_vec);\n            int mask = _mm_movemask_pd(cmp_result);\n            \n            if (mask != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (!row_match) continue;\n        \n        for (; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n        \n        if (row_match) return true;\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t simd_width = 2;\n    const size_t simd_cols = cols / simd_width;\n    const size_t remaining = cols % simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        for (size_t j = 0; j < simd_cols; j++) {\n            __m128d row_vec = _mm_loadu_pd(row + j * simd_width);\n            __m128d vec = _mm_loadu_pd(vector + j * simd_width);\n            __m128d cmp = _mm_cmpeq_pd(row_vec, vec);\n            \n            if (_mm_movemask_pd(cmp) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (!row_match) continue;\n\n        for (size_t j = simd_cols * simd_width; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t simd_width = 2;\n    const size_t simd_cols = cols / simd_width;\n    const size_t remaining = cols % simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        for (size_t j = 0; j < simd_cols; j++) {\n            __m128d row_vec = _mm_loadu_pd(row + j * simd_width);\n            __m128d vec = _mm_loadu_pd(vector + j * simd_width);\n            __m128d cmp = _mm_cmpeq_pd(row_vec, vec);\n            \n            if (_mm_movemask_pd(cmp) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (!row_match) continue;\n\n        for (size_t j = simd_cols * simd_width; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SSE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const size_t simd_width = 2;\n    const size_t simd_cols = cols / simd_width;\n    const size_t remaining = cols % simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool row_match = true;\n        \n        for (size_t j = 0; j < simd_cols; j++) {\n            __m128d row_vec = _mm_load_pd(row + j * simd_width);\n            __m128d vec = _mm_load_pd(vector + j * simd_width);\n            __m128d cmp = _mm_cmpeq_pd(row_vec, vec);\n            \n            if (_mm_movemask_pd(cmp) != 0x3) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (!row_match) continue;\n\n        for (size_t j = simd_cols * simd_width; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                row_match = false;\n                break;\n            }\n        }\n\n        if (row_match) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SSE2\n    size_t simd_size = total_size / 16 * 16;\n    for (; i < simd_size; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Compare for equality\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        \n        // Convert mask to integer\n        int mask = _mm_movemask_epi8(cmp);\n        \n        // Count set bits\n        count += __builtin_popcount(mask);\n    }\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    \n    // Process 16 elements at a time using SSE2\n    size_t vec_size = total_size / 16;\n    size_t remaining = total_size % 16;\n    \n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        // Load 16 bytes from each array\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i * 16));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i * 16));\n        \n        // Compare for equality\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        \n        // Count number of equal bytes using movemask\n        int mask = _mm_movemask_epi8(cmp);\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size * 16; i < total_size; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SSE2\n    __m128i zero = _mm_setzero_si128();\n    for (; i + 15 < total_size; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Compare for equality\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        \n        // Convert mask to integers\n        __m128i mask = _mm_and_si128(cmp, _mm_set1_epi8(1));\n        \n        // Sum up the matches using horizontal addition\n        __m128i sum = _mm_sad_epu8(mask, zero);\n        \n        count += _mm_extract_epi16(sum, 0) + _mm_extract_epi16(sum, 4);\n    }\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SSE2\n    __m128i count_vec = _mm_setzero_si128();\n    for (; i + 15 < total_size; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Compare for equality\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        \n        // Count set bits (each byte is either 0x00 or 0xFF)\n        count_vec = _mm_add_epi8(count_vec, _mm_and_si128(cmp, _mm_set1_epi8(1)));\n    }\n\n    // Horizontal sum of count_vec\n    __m128i sum = _mm_sad_epu8(count_vec, _mm_setzero_si128());\n    count += _mm_cvtsi128_si32(sum) + _mm_cvtsi128_si32(_mm_srli_si128(sum, 8));\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        count += (A[i] == B[i]);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SSE", "completion": "```cpp\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    // Process 16 elements at a time using SSE2\n    size_t simd_size = total_size / 16 * 16;\n    for (; i < simd_size; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Compare for equality\n        __m128i cmp = _mm_cmpeq_epi8(a, b);\n        \n        // Convert mask to integer\n        int mask = _mm_movemask_epi8(cmp);\n        \n        // Count set bits\n        count += _mm_popcnt_u32(mask);\n    }\n\n    // Handle remaining elements\n    for (; i < total_size; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i va = _mm_set1_epi64x(a);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vx = _mm_loadu_si128((__m128i*)(x + i));\n        __m128i vy = _mm_loadu_si128((__m128i*)(y + i));\n        \n        __m128i mul = _mm_mul_epi32(va, vx);\n        __m128i abs_y = _mm_abs_epi64(vy);\n        __m128i result = _mm_sub_epi64(mul, abs_y);\n        \n        _mm_storeu_si128((__m128i*)(y + i), result);\n    }\n    \n    for (; i < length; i++) {\n        y[i] = a * x[i] - llabs(y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i va = _mm_set1_epi64x(a);\n    \n    size_t i;\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vx = _mm_loadu_si128((__m128i*)(x + i));\n        __m128i vy = _mm_loadu_si128((__m128i*)(y + i));\n        \n        // Compute ax\n        __m128i vax = _mm_mul_epi32(va, vx);\n        \n        // Compute |y|\n        __m128i mask = _mm_cmpgt_epi64(_mm_setzero_si128(), vy);\n        vy = _mm_xor_si128(vy, mask);\n        vy = _mm_sub_epi64(vy, mask);\n        \n        // Compute ax - |y|\n        __m128i result = _mm_sub_epi64(vax, vy);\n        \n        _mm_storeu_si128((__m128i*)(y + i), result);\n    }\n    \n    // Handle remaining element\n    for (; i < length; i++) {\n        y[i] = a * x[i] - (y[i] < 0 ? -y[i] : y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i va = _mm_set1_epi64x(a);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vx = _mm_loadu_si128((__m128i*)(x + i));\n        __m128i vy = _mm_loadu_si128((__m128i*)(y + i));\n        \n        // Compute ax\n        __m128i vax = _mm_mul_epi32(va, vx);\n        \n        // Compute |y|\n        __m128i mask = _mm_srai_epi32(_mm_shuffle_epi32(vy, 0xF5), 31);\n        __m128i abs_y = _mm_sub_epi64(_mm_xor_si128(vy, mask), mask);\n        \n        // Compute ax - |y|\n        __m128i result = _mm_sub_epi64(vax, abs_y);\n        \n        _mm_storeu_si128((__m128i*)(y + i), result);\n    }\n    \n    // Handle remaining element\n    for (; i < length; i++) {\n        y[i] = a * x[i] - (y[i] >= 0 ? y[i] : -y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i va = _mm_set1_epi64x(a);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vx = _mm_loadu_si128((__m128i*)(x + i));\n        __m128i vy = _mm_loadu_si128((__m128i*)(y + i));\n        \n        // Compute ax\n        __m128i vax = _mm_mul_epi32(va, vx);\n        \n        // Compute |y|\n        __m128i mask = _mm_cmpgt_epi64(_mm_setzero_si128(), vy);\n        __m128i abs_y = _mm_sub_epi64(_mm_xor_si128(vy, mask), mask);\n        \n        // Compute ax - |y|\n        __m128i result = _mm_sub_epi64(vax, abs_y);\n        \n        _mm_storeu_si128((__m128i*)(y + i), result);\n    }\n    \n    // Handle remaining element\n    for (; i < length; i++) {\n        y[i] = a * x[i] - (y[i] < 0 ? -y[i] : y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SSE", "completion": "```cpp\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    __m128i va = _mm_set1_epi64x(a);\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i vx = _mm_loadu_si128((__m128i*)(x + i));\n        __m128i vy = _mm_loadu_si128((__m128i*)(y + i));\n        \n        // Compute ax\n        __m128i vax = _mm_mul_epi32(va, vx);\n        \n        // Compute |y|\n        __m128i mask = _mm_cmpgt_epi64(_mm_setzero_si128(), vy);\n        __m128i abs_y = _mm_sub_epi64(_mm_xor_si128(vy, mask), mask);\n        \n        // Compute ax - |y|\n        __m128i result = _mm_sub_epi64(vax, abs_y);\n        \n        _mm_storeu_si128((__m128i*)(y + i), result);\n    }\n    \n    // Handle remaining element\n    for (; i < length; i++) {\n        y[i] = a * x[i] - (y[i] < 0 ? -y[i] : y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    __m128i curr_min, curr_max;\n    curr_min = curr_max = _mm_set1_epi16(vec[0]);\n    \n    size_t i;\n    for(i = 0; i + 7 < length; i += 8) {\n        __m128i v = _mm_loadu_si128((__m128i*)(vec + i));\n        curr_min = _mm_min_epi16(curr_min, v);\n        curr_max = _mm_max_epi16(curr_max, v);\n    }\n\n    // Handle remaining elements\n    __m128i min_vals = curr_min;\n    __m128i max_vals = curr_max;\n    \n    // Horizontal min/max\n    min_vals = _mm_min_epi16(min_vals, _mm_srli_si128(min_vals, 8));\n    min_vals = _mm_min_epi16(min_vals, _mm_srli_si128(min_vals, 4));\n    min_vals = _mm_min_epi16(min_vals, _mm_srli_si128(min_vals, 2));\n    \n    max_vals = _mm_max_epi16(max_vals, _mm_srli_si128(max_vals, 8));\n    max_vals = _mm_max_epi16(max_vals, _mm_srli_si128(max_vals, 4));\n    max_vals = _mm_max_epi16(max_vals, _mm_srli_si128(max_vals, 2));\n\n    int16_t min_val = _mm_extract_epi16(min_vals, 0);\n    int16_t max_val = _mm_extract_epi16(max_vals, 0);\n\n    // Process remaining elements\n    for(; i < length; i++) {\n        min_val = min_val < vec[i] ? min_val : vec[i];\n        max_val = max_val > vec[i] ? max_val : vec[i];\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    __m128i curr_min, curr_max;\n    curr_min = curr_max = _mm_set1_epi16(vec[0]);\n    \n    size_t i;\n    for(i = 0; i + 7 < length; i += 8) {\n        __m128i v = _mm_loadu_si128((__m128i*)(vec + i));\n        curr_min = _mm_min_epi16(curr_min, v);\n        curr_max = _mm_max_epi16(curr_max, v);\n    }\n\n    // Horizontal min/max\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 8));\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 4));\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 2));\n    \n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 8));\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 4));\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 2));\n    \n    MinMaxPair result;\n    result.min_num = _mm_extract_epi16(curr_min, 0);\n    result.max_num = _mm_extract_epi16(curr_max, 0);\n    \n    // Handle remaining elements\n    for(; i < length; i++) {\n        if(vec[i] < result.min_num) result.min_num = vec[i];\n        if(vec[i] > result.max_num) result.max_num = vec[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    __m128i curr_min, curr_max, vec_reg;\n    \n    // Load first 8 elements and initialize min/max\n    vec_reg = _mm_loadu_si128((__m128i*)vec);\n    curr_min = vec_reg;\n    curr_max = vec_reg;\n    \n    // Process 8 elements at a time\n    for(size_t i = 8; i + 7 < length; i += 8) {\n        vec_reg = _mm_loadu_si128((__m128i*)(vec + i));\n        curr_min = _mm_min_epi16(curr_min, vec_reg);\n        curr_max = _mm_max_epi16(curr_max, vec_reg);\n    }\n    \n    // Find min/max across vector elements\n    __m128i min_shuffle = curr_min;\n    __m128i max_shuffle = curr_max;\n    \n    min_shuffle = _mm_min_epi16(min_shuffle, _mm_srli_si128(min_shuffle, 8));\n    min_shuffle = _mm_min_epi16(min_shuffle, _mm_srli_si128(min_shuffle, 4));\n    min_shuffle = _mm_min_epi16(min_shuffle, _mm_srli_si128(min_shuffle, 2));\n    \n    max_shuffle = _mm_max_epi16(max_shuffle, _mm_srli_si128(max_shuffle, 8));\n    max_shuffle = _mm_max_epi16(max_shuffle, _mm_srli_si128(max_shuffle, 4));\n    max_shuffle = _mm_max_epi16(max_shuffle, _mm_srli_si128(max_shuffle, 2));\n    \n    int16_t min_val = _mm_extract_epi16(min_shuffle, 0);\n    int16_t max_val = _mm_extract_epi16(max_shuffle, 0);\n    \n    // Handle remaining elements\n    for(size_t i = (length / 8) * 8; i < length; i++) {\n        min_val = std::min(min_val, vec[i]);\n        max_val = std::max(max_val, vec[i]);\n    }\n    \n    return {min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    __m128i curr_min, curr_max;\n    curr_min = curr_max = _mm_loadu_si128((__m128i*)vec);\n    \n    size_t i;\n    for(i = 8; i + 7 < length; i += 8) {\n        __m128i v = _mm_loadu_si128((__m128i*)(vec + i));\n        curr_min = _mm_min_epi16(curr_min, v);\n        curr_max = _mm_max_epi16(curr_max, v);\n    }\n\n    // Horizontal min/max\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 8));\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 4));\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 2));\n\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 8));\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 4));\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 2));\n\n    int16_t min_val = _mm_extract_epi16(curr_min, 0);\n    int16_t max_val = _mm_extract_epi16(curr_max, 0);\n\n    // Handle remaining elements\n    for(; i < length; i++) {\n        min_val = vec[i] < min_val ? vec[i] : min_val;\n        max_val = vec[i] > max_val ? vec[i] : max_val;\n    }\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SSE", "completion": "```cpp\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    __m128i curr_min, curr_max, vec_reg;\n    \n    // Initialize min/max with first vector\n    vec_reg = _mm_loadu_si128((__m128i*)vec);\n    curr_min = vec_reg;\n    curr_max = vec_reg;\n    \n    // Process 8 elements at a time\n    for(size_t i = 8; i < length - 7; i += 8) {\n        vec_reg = _mm_loadu_si128((__m128i*)(vec + i));\n        curr_min = _mm_min_epi16(curr_min, vec_reg);\n        curr_max = _mm_max_epi16(curr_max, vec_reg);\n    }\n\n    // Horizontal min/max\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 8));\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 4));\n    curr_min = _mm_min_epi16(curr_min, _mm_srli_si128(curr_min, 2));\n    \n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 8));\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 4));\n    curr_max = _mm_max_epi16(curr_max, _mm_srli_si128(curr_max, 2));\n\n    // Handle remaining elements\n    int16_t min_val = _mm_extract_epi16(curr_min, 0);\n    int16_t max_val = _mm_extract_epi16(curr_max, 0);\n    \n    for(size_t i = (length/8)*8; i < length; i++) {\n        min_val = min_val < vec[i] ? min_val : vec[i];\n        max_val = max_val > vec[i] ? max_val : vec[i];\n    }\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    const size_t simd_width = 4;\n    const size_t cols_simd = cols - 1;\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n\n        for (j = 0; j < cols_simd - simd_width + 1; j += simd_width) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + j + 1));\n            \n            __m128i cmp = _mm_cmplt_epi32(curr, next);\n            int mask = _mm_movemask_ps((__m128)cmp);\n            \n            if (mask != 0xF) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        \n        for (size_t j = 0; j < cols - 4; j += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + j + 1));\n            \n            __m128i cmp = _mm_cmplt_epi32(curr, next);\n            int mask = _mm_movemask_ps((__m128)cmp);\n            \n            if (mask != 0xF) {\n                return false;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t j = cols - (cols % 4); j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n\n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + j + 1));\n            \n            __m128i cmp = _mm_cmplt_epi32(curr, next);\n            int mask = _mm_movemask_ps((__m128)cmp);\n            \n            if (mask != 0xF) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    const size_t simd_width = 4;\n    const size_t cols_simd = (cols - 1) / simd_width * simd_width;\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        \n        for (size_t j = 0; j < cols_simd; j += simd_width) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + j + 1));\n            \n            __m128i cmp = _mm_cmplt_epi32(curr, next);\n            int mask = _mm_movemask_ps((__m128)cmp);\n            \n            if (mask != 0xF) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        for (size_t j = cols_simd; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SSE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j + 4 <= cols - 1; j += 4) {\n            __m128i curr = _mm_loadu_si128((__m128i*)(row + j));\n            __m128i next = _mm_loadu_si128((__m128i*)(row + j + 1));\n            \n            __m128i cmp = _mm_cmplt_epi32(curr, next);\n            int mask = _mm_movemask_ps((__m128)cmp);\n            \n            if (mask != 0xF) {\n                return false;\n            }\n        }\n\n        // Handle remaining elements\n        for (; j < cols - 1; j++) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t blocks_per_row = cols / block_size;\n    size_t blocks_per_col = rows / block_size;\n    \n    // Process 4 integers at a time using SSE2\n    size_t elements_per_simd = 4;\n    size_t aligned_block_size = (block_size * block_size / elements_per_simd) * elements_per_simd;\n    \n    // Get first block as reference\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) continue;\n            \n            const int* first_block = matrix;\n            const int* current_block = matrix + block_row * block_size * cols + block_col * block_size;\n            \n            // Process aligned elements using SIMD\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < aligned_block_size; j += elements_per_simd) {\n                    __m128i ref = _mm_loadu_si128((__m128i*)(first_block + i * cols + j));\n                    __m128i cur = _mm_loadu_si128((__m128i*)(current_block + i * cols + j));\n                    \n                    __m128i cmp = _mm_cmpeq_epi32(ref, cur);\n                    int mask = _mm_movemask_epi8(cmp);\n                    if (mask != 0xFFFF) {\n                        return false;\n                    }\n                }\n                \n                // Handle remaining elements\n                for (size_t j = aligned_block_size; j < block_size; j++) {\n                    if (first_block[i * cols + j] != current_block[i * cols + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Process 4 integers at a time using SSE\n    size_t sse_width = 4;\n    size_t sse_iters = block_size * block_size / sse_width;\n    size_t remainder = block_size * block_size % sse_width;\n\n    // First block will be reference\n    const int* ref_block = matrix;\n\n    // Compare each block with reference\n    for (size_t i = 0; i < num_blocks_row; i++) {\n        for (size_t j = 0; j < num_blocks_col; j++) {\n            // Skip first block\n            if (i == 0 && j == 0) continue;\n\n            const int* curr_block = matrix + i * block_size * cols + j * block_size;\n\n            // Compare blocks using SSE\n            for (size_t bi = 0; bi < block_size; bi++) {\n                const int* ref_row = ref_block + bi * cols;\n                const int* curr_row = curr_block + bi * cols;\n\n                for (size_t bj = 0; bj < block_size; bj += sse_width) {\n                    __m128i ref_vec = _mm_loadu_si128((__m128i*)(ref_row + bj));\n                    __m128i curr_vec = _mm_loadu_si128((__m128i*)(curr_row + bj));\n                    __m128i cmp = _mm_cmpeq_epi32(ref_vec, curr_vec);\n                    \n                    // Check if all elements are equal\n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements\n                for (size_t k = block_size - remainder; k < block_size; k++) {\n                    if (ref_row[k] != curr_row[k]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Process 4 integers at a time using SSE\n    size_t sse_width = 4;\n    size_t sse_iters = block_size * block_size / sse_width;\n    size_t remainder = block_size * block_size % sse_width;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            if (block_row == 0 && block_col == 0) continue;\n\n            const int* first_block = matrix;\n            const int* curr_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            // Compare blocks using SSE\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset = i * cols;\n                \n                for (size_t j = 0; j < sse_iters; j++) {\n                    __m128i first = _mm_loadu_si128((__m128i*)(first_block + row_offset + j * sse_width));\n                    __m128i curr = _mm_loadu_si128((__m128i*)(curr_block + row_offset + j * sse_width));\n                    \n                    __m128i cmp = _mm_cmpeq_epi32(first, curr);\n                    int mask = _mm_movemask_ps((__m128)cmp);\n                    \n                    if (mask != 0xF) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements\n                size_t start_idx = sse_iters * sse_width;\n                for (size_t k = 0; k < remainder; k++) {\n                    if (first_block[row_offset + start_idx + k] != \n                        curr_block[row_offset + start_idx + k]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const size_t blocks_per_row = cols / block_size;\n    const size_t blocks_per_col = rows / block_size;\n    const size_t elements_per_block = block_size * block_size;\n\n    for (size_t block_row = 0; block_row < blocks_per_col; block_row++) {\n        for (size_t block_col = 0; block_col < blocks_per_row; block_col++) {\n            if (block_row == 0 && block_col == 0) continue;\n\n            const int* first_block = matrix;\n            const int* current_block = matrix + (block_row * block_size * cols + block_col * block_size);\n\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset = i * cols;\n                size_t j = 0;\n\n                for (; j + 4 <= block_size; j += 4) {\n                    __m128i first = _mm_loadu_si128((__m128i*)(first_block + row_offset + j));\n                    __m128i curr = _mm_loadu_si128((__m128i*)(current_block + row_offset + j));\n                    __m128i cmp = _mm_cmpeq_epi32(first, curr);\n                    \n                    if (_mm_movemask_epi8(cmp) != 0xFFFF) {\n                        return false;\n                    }\n                }\n\n                for (; j < block_size; j++) {\n                    if (first_block[row_offset + j] != current_block[row_offset + j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SSE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    // Process 4 integers at a time using SSE2\n    const size_t simd_width = 4;\n    \n    for (size_t i = 0; i < block_size; i++) {\n        for (size_t j = 0; j < block_size; j++) {\n            // Get reference value from first block\n            int ref_val = matrix[i * cols + j];\n            __m128i ref = _mm_set1_epi32(ref_val);\n            \n            // Compare with corresponding position in other blocks\n            for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n                for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n                    // Skip first block\n                    if (block_row == 0 && block_col == 0) continue;\n                    \n                    size_t row = block_row * block_size + i;\n                    size_t col = block_col * block_size + j;\n                    \n                    if (ref_val != matrix[row * cols + col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || tolerance < 0 || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    size_t simd_width = 2;\n    size_t simd_blocks = block_size / simd_width;\n    size_t remainder = block_size % simd_width;\n\n    if (simd_blocks == 0) {\n        return false;\n    }\n\n    __m128d tol = _mm_set1_pd(tolerance);\n\n    for (size_t block = 1; block < num_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + block * block_size;\n\n        for (size_t i = 0; i < simd_blocks; i++) {\n            __m128d base = _mm_loadu_pd(base_ptr + i * simd_width);\n            __m128d curr = _mm_loadu_pd(curr_ptr + i * simd_width);\n            \n            __m128d diff = _mm_sub_pd(base, curr);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmpgt_pd(abs_diff, tol);\n            \n            if (_mm_movemask_pd(cmp)) {\n                return false;\n            }\n        }\n\n        for (size_t i = 0; i < remainder; i++) {\n            double diff = fabs(base_ptr[simd_blocks * simd_width + i] - \n                             curr_ptr[simd_blocks * simd_width + i]);\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    __m128d tol = _mm_set1_pd(tolerance);\n    \n    for (size_t block = 1; block < num_blocks; block++) {\n        for (size_t i = 0; i < block_size; i += 2) {\n            if (i + 1 >= block_size) {\n                double val1 = vec[i];\n                double val2 = vec[block * block_size + i];\n                if (fabs(val1 - val2) > tolerance) {\n                    return false;\n                }\n                continue;\n            }\n\n            __m128d v1 = _mm_loadu_pd(&vec[i]);\n            __m128d v2 = _mm_loadu_pd(&vec[block * block_size + i]);\n            __m128d diff = _mm_sub_pd(v1, v2);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmple_pd(abs_diff, tol);\n            \n            if (_mm_movemask_pd(cmp) != 0x3) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    __m128d tol = _mm_set1_pd(tolerance);\n    size_t simd_width = 2;\n    size_t simd_iters = block_size / simd_width;\n    size_t remainder = block_size % simd_width;\n\n    for (size_t block = 1; block < num_complete_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + block * block_size;\n\n        for (size_t i = 0; i < simd_iters; i++) {\n            __m128d base = _mm_loadu_pd(base_ptr + i * simd_width);\n            __m128d curr = _mm_loadu_pd(curr_ptr + i * simd_width);\n            \n            __m128d diff = _mm_sub_pd(base, curr);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmpgt_pd(abs_diff, tol);\n            \n            if (_mm_movemask_pd(cmp)) {\n                return false;\n            }\n        }\n\n        for (size_t i = simd_iters * simd_width; i < block_size; i++) {\n            if (fabs(base_ptr[i] - curr_ptr[i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    __m128d tol = _mm_set1_pd(tolerance);\n    size_t simd_width = 2;\n    size_t simd_blocks = block_size / simd_width;\n    size_t remainder = block_size % simd_width;\n\n    for (size_t block = 1; block < num_complete_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + block * block_size;\n\n        for (size_t i = 0; i < simd_blocks; i++) {\n            __m128d base = _mm_loadu_pd(base_ptr + i * simd_width);\n            __m128d curr = _mm_loadu_pd(curr_ptr + i * simd_width);\n            __m128d diff = _mm_sub_pd(base, curr);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmpgt_pd(abs_diff, tol);\n            \n            if (_mm_movemask_pd(cmp)) {\n                return false;\n            }\n        }\n\n        for (size_t i = simd_blocks * simd_width; i < block_size; i++) {\n            if (fabs(base_ptr[i] - curr_ptr[i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SSE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    __m128d tol = _mm_set1_pd(tolerance);\n    size_t simd_width = 2;\n    size_t simd_blocks = block_size / simd_width;\n    size_t remainder = block_size % simd_width;\n\n    for (size_t block = 1; block < num_complete_blocks; block++) {\n        const double* base_ptr = vec;\n        const double* curr_ptr = vec + block * block_size;\n\n        for (size_t i = 0; i < simd_blocks; i++) {\n            __m128d base = _mm_loadu_pd(base_ptr + i * simd_width);\n            __m128d curr = _mm_loadu_pd(curr_ptr + i * simd_width);\n            \n            __m128d diff = _mm_sub_pd(base, curr);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmpgt_pd(abs_diff, tol);\n            \n            if (_mm_movemask_pd(cmp)) {\n                return false;\n            }\n        }\n\n        for (size_t i = simd_blocks * simd_width; i < block_size; i++) {\n            if (fabs(base_ptr[i] - curr_ptr[i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum = _mm_setzero_pd();\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row = _mm_loadu_pd(&matrix[i * cols + j]);\n            sum = _mm_add_pd(sum, _mm_mul_pd(row, row));\n        }\n        \n        double norm = ((double*)&sum)[0] + ((double*)&sum)[1];\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        \n        result[i] = (sqrt(norm) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum = _mm_setzero_pd();\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row = _mm_loadu_pd(&matrix[i * cols + j]);\n            sum = _mm_add_pd(sum, _mm_mul_pd(row, row));\n        }\n        \n        double row_sum = _mm_cvtsd_f64(_mm_hadd_pd(sum, sum));\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            double last = matrix[i * cols + j];\n            row_sum += last * last;\n        }\n        \n        result[i] = (row_sum > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum = _mm_setzero_pd();\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row = _mm_loadu_pd(&matrix[i * cols + j]);\n            sum = _mm_add_pd(sum, _mm_mul_pd(row, row));\n        }\n        \n        double norm = ((double*)&sum)[0] + ((double*)&sum)[1];\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            double val = matrix[i * cols + j];\n            norm += val * val;\n        }\n        \n        result[i] = (sqrt(norm) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum = _mm_setzero_pd();\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row = _mm_loadu_pd(&matrix[i * cols + j]);\n            sum = _mm_add_pd(sum, _mm_mul_pd(row, row));\n        }\n        \n        double norm = _mm_cvtsd_f64(_mm_hadd_pd(sum, sum));\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            double last = matrix[i * cols + j];\n            norm += last * last;\n        }\n        \n        result[i] = (norm > thresholds[i] * thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SSE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        __m128d sum = _mm_setzero_pd();\n        \n        size_t j;\n        for (j = 0; j + 1 < cols; j += 2) {\n            __m128d row = _mm_loadu_pd(&matrix[i * cols + j]);\n            sum = _mm_add_pd(sum, _mm_mul_pd(row, row));\n        }\n        \n        double norm = ((double*)&sum)[0] + ((double*)&sum)[1];\n        \n        // Handle remaining column if cols is odd\n        if (j < cols) {\n            double last = matrix[i * cols + j];\n            norm += last * last;\n        }\n        \n        result[i] = (sqrt(norm) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_SSE", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 4);\n    \n    for (i = 0; i < simd_length; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i c = _mm_or_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), c);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    __m128i sum_squares = _mm_setzero_si128();\n    __m128i sum_products = _mm_setzero_si128();\n    \n    size_t i;\n    for(i = 0; i + 16 <= length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Convert 8-bit to 16-bit\n        __m128i a_lo = _mm_unpacklo_epi8(a, _mm_setzero_si128());\n        __m128i a_hi = _mm_unpackhi_epi8(a, _mm_setzero_si128());\n        __m128i b_lo = _mm_unpacklo_epi8(b, _mm_setzero_si128());\n        __m128i b_hi = _mm_unpackhi_epi8(b, _mm_setzero_si128());\n        \n        // Calculate squares\n        __m128i squares_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i squares_hi = _mm_mullo_epi16(a_hi, a_hi);\n        squares_lo = _mm_add_epi16(squares_lo, _mm_mullo_epi16(b_lo, b_lo));\n        squares_hi = _mm_add_epi16(squares_hi, _mm_mullo_epi16(b_hi, b_hi));\n        \n        // Calculate products\n        __m128i products_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i products_hi = _mm_mullo_epi16(a_hi, b_hi);\n        \n        // Accumulate sums\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpacklo_epi16(squares_lo, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpackhi_epi16(squares_lo, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpacklo_epi16(squares_hi, _mm_setzero_si128()));\n        sum_squares = _mm_add_epi32(sum_squares, _mm_unpackhi_epi16(squares_hi, _mm_setzero_si128()));\n        \n        sum_products = _mm_add_epi32(sum_products, _mm_unpacklo_epi16(products_lo, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpackhi_epi16(products_lo, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpacklo_epi16(products_hi, _mm_setzero_si128()));\n        sum_products = _mm_add_epi32(sum_products, _mm_unpackhi_epi16(products_hi, _mm_setzero_si128()));\n    }\n    \n    // Handle remaining elements\n    int64_t squares = 0, products = 0;\n    for(; i < length; i++) {\n        squares += A[i] * A[i] + B[i] * B[i];\n        products += A[i] * B[i];\n    }\n    \n    // Sum up the four 32-bit integers in the SIMD registers\n    int sum_sq = _mm_cvtsi128_si32(sum_squares) +\n                 _mm_cvtsi128_si32(_mm_srli_si128(sum_squares, 4)) +\n                 _mm_cvtsi128_si32(_mm_srli_si128(sum_squares, 8)) +\n                 _mm_cvtsi128_si32(_mm_srli_si128(sum_squares, 12));\n                 \n    int sum_prod = _mm_cvtsi128_si32(sum_products) +\n                   _mm_cvtsi128_si32(_mm_srli_si128(sum_products, 4)) +\n                   _mm_cvtsi128_si32(_mm_srli_si128(sum_products, 8)) +\n                   _mm_cvtsi128_si32(_mm_srli_si128(sum_products, 12));\n    \n    return (int64_t)sum_sq + squares - ((int64_t)sum_prod + products);\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t aligned_length = length & ~15;\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i sum_sq = _mm_setzero_si128();\n    __m128i sum_prod = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Process first 8 bytes\n        __m128i a_lo = _mm_unpacklo_epi8(a, zero);\n        __m128i b_lo = _mm_unpacklo_epi8(b, zero);\n        \n        __m128i sq_a_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i sq_b_lo = _mm_mullo_epi16(b_lo, b_lo);\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        \n        // Process next 8 bytes\n        __m128i a_hi = _mm_unpackhi_epi8(a, zero);\n        __m128i b_hi = _mm_unpackhi_epi8(b, zero);\n        \n        __m128i sq_a_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i sq_b_hi = _mm_mullo_epi16(b_hi, b_hi);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n        \n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpacklo_epi16(sq_a_lo, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpackhi_epi16(sq_a_lo, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpacklo_epi16(sq_b_lo, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpackhi_epi16(sq_b_lo, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpacklo_epi16(sq_a_hi, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpackhi_epi16(sq_a_hi, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpacklo_epi16(sq_b_hi, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpackhi_epi16(sq_b_hi, zero));\n        \n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpacklo_epi16(prod_lo, zero));\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpackhi_epi16(prod_lo, zero));\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpacklo_epi16(prod_hi, zero));\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpackhi_epi16(prod_hi, zero));\n    }\n    \n    int32_t sq_arr[4], prod_arr[4];\n    _mm_storeu_si128((__m128i*)sq_arr, sum_sq);\n    _mm_storeu_si128((__m128i*)prod_arr, sum_prod);\n    \n    for (int i = 0; i < 4; i++) {\n        sum_squares += sq_arr[i];\n        sum_products += prod_arr[i];\n    }\n    \n    for (size_t i = aligned_length; i < length; i++) {\n        sum_squares += A[i] * A[i] + B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t aligned_length = length & ~15;\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i sum_sq = _mm_setzero_si128();\n    __m128i sum_prod = _mm_setzero_si128();\n\n    for (size_t i = 0; i < aligned_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Process first 8 elements\n        __m128i a_lo = _mm_unpacklo_epi8(a, zero);\n        __m128i b_lo = _mm_unpacklo_epi8(b, zero);\n        \n        __m128i sq_a = _mm_madd_epi16(a_lo, a_lo);\n        __m128i sq_b = _mm_madd_epi16(b_lo, b_lo);\n        __m128i prod = _mm_madd_epi16(a_lo, b_lo);\n        \n        sum_sq = _mm_add_epi32(sum_sq, sq_a);\n        sum_sq = _mm_add_epi32(sum_sq, sq_b);\n        sum_prod = _mm_add_epi32(sum_prod, prod);\n        \n        // Process next 8 elements\n        __m128i a_hi = _mm_unpackhi_epi8(a, zero);\n        __m128i b_hi = _mm_unpackhi_epi8(b, zero);\n        \n        sq_a = _mm_madd_epi16(a_hi, a_hi);\n        sq_b = _mm_madd_epi16(b_hi, b_hi);\n        prod = _mm_madd_epi16(a_hi, b_hi);\n        \n        sum_sq = _mm_add_epi32(sum_sq, sq_a);\n        sum_sq = _mm_add_epi32(sum_sq, sq_b);\n        sum_prod = _mm_add_epi32(sum_prod, prod);\n    }\n    \n    // Horizontal sum\n    __m128i sum_sq_hi = _mm_srli_si128(sum_sq, 8);\n    __m128i sum_prod_hi = _mm_srli_si128(sum_prod, 8);\n    sum_sq = _mm_add_epi32(sum_sq, sum_sq_hi);\n    sum_prod = _mm_add_epi32(sum_prod, sum_prod_hi);\n    __m128i sum_sq_hi32 = _mm_srli_si128(sum_sq, 4);\n    __m128i sum_prod_hi32 = _mm_srli_si128(sum_prod, 4);\n    sum_sq = _mm_add_epi32(sum_sq, sum_sq_hi32);\n    sum_prod = _mm_add_epi32(sum_prod, sum_prod_hi32);\n    sum_squares = _mm_cvtsi128_si32(sum_sq);\n    sum_products = _mm_cvtsi128_si32(sum_prod);\n\n    // Handle remaining elements\n    for (size_t i = aligned_length; i < length; i++) {\n        sum_squares += A[i] * A[i] + B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - (2 * sum_products);\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t i = 0;\n    size_t simd_length = length - (length % 16);\n    \n    __m128i zero = _mm_setzero_si128();\n    \n    for(; i < simd_length; i += 16) {\n        // Load 16 bytes from A and B\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Unpack lower and upper bytes to 16-bit integers\n        __m128i a_lo = _mm_unpacklo_epi8(a, zero);\n        __m128i a_hi = _mm_unpackhi_epi8(a, zero);\n        __m128i b_lo = _mm_unpacklo_epi8(b, zero);\n        __m128i b_hi = _mm_unpackhi_epi8(b, zero);\n        \n        // Calculate squares\n        __m128i sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        __m128i sq_b_lo = _mm_mullo_epi16(b_lo, b_lo);\n        __m128i sq_b_hi = _mm_mullo_epi16(b_hi, b_hi);\n        \n        // Calculate products\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n        \n        // Sum up squares and products\n        __m128i sum_sq = _mm_add_epi16(sq_lo, sq_hi);\n        sum_sq = _mm_add_epi16(sum_sq, sq_b_lo);\n        sum_sq = _mm_add_epi16(sum_sq, sq_b_hi);\n        \n        __m128i sum_pr = _mm_add_epi16(prod_lo, prod_hi);\n        \n        // Extract and accumulate results\n        int16_t sq_arr[8], pr_arr[8];\n        _mm_storeu_si128((__m128i*)sq_arr, sum_sq);\n        _mm_storeu_si128((__m128i*)pr_arr, sum_pr);\n        \n        for(int j = 0; j < 8; j++) {\n            sum_squares += sq_arr[j];\n            sum_products += pr_arr[j];\n        }\n    }\n    \n    // Handle remaining elements\n    for(; i < length; i++) {\n        sum_squares += A[i] * A[i] + B[i] * B[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - 2 * sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SSE", "completion": "```cpp\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    size_t i;\n    size_t simd_length = length - (length % 16);\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i sum_sq = _mm_setzero_si128();\n    __m128i sum_prod = _mm_setzero_si128();\n    \n    for (i = 0; i < simd_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        // Unpack lower and upper bytes to 16-bit integers\n        __m128i a_lo = _mm_unpacklo_epi8(a, zero);\n        __m128i a_hi = _mm_unpackhi_epi8(a, zero);\n        __m128i b_lo = _mm_unpacklo_epi8(b, zero);\n        __m128i b_hi = _mm_unpackhi_epi8(b, zero);\n        \n        // Calculate squares\n        __m128i sq_lo = _mm_mullo_epi16(a_lo, a_lo);\n        __m128i sq_hi = _mm_mullo_epi16(a_hi, a_hi);\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpacklo_epi16(sq_lo, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpackhi_epi16(sq_lo, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpacklo_epi16(sq_hi, zero));\n        sum_sq = _mm_add_epi32(sum_sq, _mm_unpackhi_epi16(sq_hi, zero));\n        \n        // Calculate products\n        __m128i prod_lo = _mm_mullo_epi16(a_lo, b_lo);\n        __m128i prod_hi = _mm_mullo_epi16(a_hi, b_hi);\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpacklo_epi16(prod_lo, zero));\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpackhi_epi16(prod_lo, zero));\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpacklo_epi16(prod_hi, zero));\n        sum_prod = _mm_add_epi32(sum_prod, _mm_unpackhi_epi16(prod_hi, zero));\n    }\n    \n    // Extract and sum the 4 32-bit integers\n    int32_t sq_arr[4], prod_arr[4];\n    _mm_storeu_si128((__m128i*)sq_arr, sum_sq);\n    _mm_storeu_si128((__m128i*)prod_arr, sum_prod);\n    \n    for (i = 0; i < 4; i++) {\n        sum_squares += sq_arr[i];\n        sum_products += prod_arr[i];\n    }\n    \n    // Handle remaining elements\n    for (i = simd_length; i < length; i++) {\n        sum_squares += A[i] * A[i];\n        sum_products += A[i] * B[i];\n    }\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length / 2;\n    \n    for (i = 0; i < simd_length * 2; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi32(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length / 2;\n    \n    for (i = 0; i < simd_length * 2; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi32(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length / 2;\n    \n    for (i = 0; i < simd_length * 2; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i notb = _mm_xor_si128(b, _mm_set1_epi32(-1));\n        __m128i result = _mm_and_si128(a, notb);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length / 2;\n    \n    for (i = 0; i < simd_length * 2; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i notb = _mm_xor_si128(b, _mm_set1_epi32(-1));\n        __m128i result = _mm_and_si128(a, notb);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SSE", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length / 2;\n    \n    for (i = 0; i < simd_length * 2; i += 2) {\n        __m128i a = _mm_loadu_si128((__m128i*)&A[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&B[i]);\n        __m128i not_b = _mm_xor_si128(b, _mm_set1_epi32(-1));\n        __m128i result = _mm_and_si128(a, not_b);\n        _mm_storeu_si128((__m128i*)&C[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        C[i] = A[i] & (~B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 16);\n    \n    __m128i ones = _mm_set1_epi8(1);\n    __m128i neg_ones = _mm_set1_epi8(-1);\n    __m128i zeros = _mm_setzero_si128();\n\n    for (i = 0; i < simd_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        __m128i both_pos = _mm_and_si128(_mm_cmpgt_epi8(a, zeros), \n                                        _mm_cmpgt_epi8(b, zeros));\n        __m128i both_neg = _mm_and_si128(_mm_cmplt_epi8(a, zeros),\n                                        _mm_cmplt_epi8(b, zeros));\n        \n        __m128i result = _mm_or_si128(_mm_and_si128(both_pos, ones),\n                                     _mm_and_si128(both_neg, neg_ones));\n        \n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 16);\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i neg_ones = _mm_set1_epi8(-1);\n\n    for (i = 0; i < simd_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        __m128i a_pos = _mm_cmpgt_epi8(a, zero);\n        __m128i b_pos = _mm_cmpgt_epi8(b, zero);\n        __m128i a_neg = _mm_cmplt_epi8(a, zero);\n        __m128i b_neg = _mm_cmplt_epi8(b, zero);\n        \n        __m128i both_pos = _mm_and_si128(a_pos, b_pos);\n        __m128i both_neg = _mm_and_si128(a_neg, b_neg);\n        \n        __m128i result = _mm_and_si128(both_pos, ones);\n        __m128i neg_result = _mm_and_si128(both_neg, neg_ones);\n        result = _mm_or_si128(result, neg_result);\n        \n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    size_t simd_length = length - (length % 16);\n    \n    __m128i ones = _mm_set1_epi8(1);\n    __m128i neg_ones = _mm_set1_epi8(-1);\n    __m128i zeros = _mm_setzero_si128();\n\n    for (i = 0; i < simd_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        \n        __m128i a_pos = _mm_cmpgt_epi8(a, zeros);\n        __m128i b_pos = _mm_cmpgt_epi8(b, zeros);\n        __m128i a_neg = _mm_cmplt_epi8(a, zeros);\n        __m128i b_neg = _mm_cmplt_epi8(b, zeros);\n        \n        __m128i both_pos = _mm_and_si128(a_pos, b_pos);\n        __m128i both_neg = _mm_and_si128(a_neg, b_neg);\n        \n        __m128i result = _mm_and_si128(both_pos, ones);\n        __m128i neg_result = _mm_and_si128(both_neg, neg_ones);\n        result = _mm_or_si128(result, neg_result);\n        \n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t aligned_length = length & ~15;\n    size_t i;\n\n    __m128i zero = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i neg_ones = _mm_set1_epi8(-1);\n\n    for (i = 0; i < aligned_length; i += 16) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n\n        __m128i both_pos = _mm_and_si128(_mm_cmpgt_epi8(a, zero), _mm_cmpgt_epi8(b, zero));\n        __m128i both_neg = _mm_and_si128(_mm_cmplt_epi8(a, zero), _mm_cmplt_epi8(b, zero));\n\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(both_pos, ones),\n            _mm_and_si128(both_neg, neg_ones)\n        );\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_SSE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i;\n    const size_t simd_width = 16;\n    size_t simd_length = length & ~(simd_width - 1);\n\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i neg_ones = _mm_set1_epi8(-1);\n    __m128i zeros = _mm_setzero_si128();\n\n    for (i = 0; i < simd_length; i += simd_width) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n\n        __m128i both_pos = _mm_and_si128(_mm_cmpgt_epi8(a, zeros), \n                                        _mm_cmpgt_epi8(b, zeros));\n        __m128i both_neg = _mm_and_si128(_mm_cmplt_epi8(a, zeros),\n                                        _mm_cmplt_epi8(b, zeros));\n\n        __m128i result = _mm_or_si128(_mm_and_si128(both_pos, ones),\n                                     _mm_and_si128(both_neg, neg_ones));\n\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process 8 elements at a time before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process 8 elements at a time after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process 8 elements at a time before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process 8 elements at a time after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process 8 elements at a time before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process 8 elements at a time after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process 8 elements at a time using SSE2\n    for (; i + 8 <= midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process 8 elements at a time using SSE2 after midpoint\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_SSE", "completion": "```cpp\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    // Process 8 elements at a time before midpoint using XOR\n    for (; i + 8 <= midpoint; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_xor_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements before midpoint\n    for (; i < midpoint; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    i = midpoint + 1;\n    \n    // Process 8 elements at a time after midpoint using AND\n    for (; i + 8 <= length; i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i b = _mm_loadu_si128((__m128i*)(B + i));\n        __m128i result = _mm_and_si128(a, b);\n        _mm_storeu_si128((__m128i*)(C + i), result);\n    }\n    \n    // Handle remaining elements after midpoint\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t simd_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n        \n        __m128 mask1 = _mm_castsi128_ps(_mm_set_epi32(\n            cond1[i+3] ? -1 : 0,\n            cond1[i+2] ? -1 : 0,\n            cond1[i+1] ? -1 : 0,\n            cond1[i] ? -1 : 0\n        ));\n        \n        __m128 mask2 = _mm_castsi128_ps(_mm_set_epi32(\n            cond2[i+3] ? -1 : 0,\n            cond2[i+2] ? -1 : 0,\n            cond2[i+1] ? -1 : 0,\n            cond2[i] ? -1 : 0\n        ));\n\n        __m128 ab = _mm_or_ps(\n            _mm_and_ps(mask2, a),\n            _mm_andnot_ps(mask2, b)\n        );\n        \n        __m128 cd = _mm_or_ps(\n            _mm_and_ps(mask2, c),\n            _mm_andnot_ps(mask2, d)\n        );\n        \n        __m128 result = _mm_or_ps(\n            _mm_and_ps(mask1, ab),\n            _mm_andnot_ps(mask1, cd)\n        );\n        \n        _mm_storeu_ps(&out[i], result);\n    }\n    \n    for (size_t i = simd_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t simd_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n        \n        __m128 mask1 = _mm_castsi128_ps(_mm_set_epi32(\n            cond1[i+3] ? -1 : 0,\n            cond1[i+2] ? -1 : 0,\n            cond1[i+1] ? -1 : 0,\n            cond1[i] ? -1 : 0\n        ));\n        \n        __m128 mask2 = _mm_castsi128_ps(_mm_set_epi32(\n            cond2[i+3] ? -1 : 0,\n            cond2[i+2] ? -1 : 0,\n            cond2[i+1] ? -1 : 0,\n            cond2[i] ? -1 : 0\n        ));\n\n        // Select between A and B based on cond2 when cond1 is true\n        __m128 ab = _mm_or_ps(\n            _mm_and_ps(mask2, a),\n            _mm_andnot_ps(mask2, b)\n        );\n        \n        // Select between C and D based on cond2 when cond1 is false\n        __m128 cd = _mm_or_ps(\n            _mm_and_ps(mask2, c),\n            _mm_andnot_ps(mask2, d)\n        );\n        \n        // Final selection based on cond1\n        __m128 result = _mm_or_ps(\n            _mm_and_ps(mask1, ab),\n            _mm_andnot_ps(mask1, cd)\n        );\n        \n        _mm_storeu_ps(&out[i], result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t simd_size = total_size - (total_size % 4);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_loadu_ps(&A[i]);\n        __m128 b = _mm_loadu_ps(&B[i]);\n        __m128 c = _mm_loadu_ps(&C[i]);\n        __m128 d = _mm_loadu_ps(&D[i]);\n        \n        __m128 mask1 = _mm_castsi128_ps(_mm_set_epi32(\n            cond1[i+3] ? -1 : 0,\n            cond1[i+2] ? -1 : 0,\n            cond1[i+1] ? -1 : 0,\n            cond1[i] ? -1 : 0\n        ));\n        \n        __m128 mask2 = _mm_castsi128_ps(_mm_set_epi32(\n            cond2[i+3] ? -1 : 0,\n            cond2[i+2] ? -1 : 0,\n            cond2[i+1] ? -1 : 0,\n            cond2[i] ? -1 : 0\n        ));\n\n        __m128 ab = _mm_or_ps(\n            _mm_and_ps(mask2, a),\n            _mm_andnot_ps(mask2, b)\n        );\n        \n        __m128 cd = _mm_or_ps(\n            _mm_and_ps(mask2, c),\n            _mm_andnot_ps(mask2, d)\n        );\n        \n        __m128 result = _mm_or_ps(\n            _mm_and_ps(mask1, ab),\n            _mm_andnot_ps(mask1, cd)\n        );\n        \n        _mm_storeu_ps(&out[i], result);\n    }\n    \n    for (size_t i = simd_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3;\n\n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 a = _mm_load_ps(&A[i]);\n        __m128 b = _mm_load_ps(&B[i]);\n        __m128 c = _mm_load_ps(&C[i]);\n        __m128 d = _mm_load_ps(&D[i]);\n\n        __m128 mask1 = _mm_castsi128_ps(_mm_set_epi32(\n            cond1[i+3] ? -1 : 0,\n            cond1[i+2] ? -1 : 0,\n            cond1[i+1] ? -1 : 0,\n            cond1[i] ? -1 : 0\n        ));\n\n        __m128 mask2 = _mm_castsi128_ps(_mm_set_epi32(\n            cond2[i+3] ? -1 : 0,\n            cond2[i+2] ? -1 : 0,\n            cond2[i+1] ? -1 : 0,\n            cond2[i] ? -1 : 0\n        ));\n\n        __m128 ab = _mm_or_ps(\n            _mm_and_ps(mask2, a),\n            _mm_andnot_ps(mask2, b)\n        );\n\n        __m128 cd = _mm_or_ps(\n            _mm_and_ps(mask2, c),\n            _mm_andnot_ps(mask2, d)\n        );\n\n        __m128 result = _mm_or_ps(\n            _mm_and_ps(mask1, ab),\n            _mm_andnot_ps(mask1, cd)\n        );\n\n        _mm_store_ps(&out[i], result);\n    }\n\n    for (size_t i = aligned_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_SSE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3;\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 a = _mm_load_ps(&A[i]);\n        __m128 b = _mm_load_ps(&B[i]);\n        __m128 c = _mm_load_ps(&C[i]);\n        __m128 d = _mm_load_ps(&D[i]);\n        \n        __m128 mask1 = _mm_castsi128_ps(_mm_set_epi32(\n            cond1[i+3] ? -1 : 0,\n            cond1[i+2] ? -1 : 0,\n            cond1[i+1] ? -1 : 0,\n            cond1[i] ? -1 : 0\n        ));\n        \n        __m128 mask2 = _mm_castsi128_ps(_mm_set_epi32(\n            cond2[i+3] ? -1 : 0,\n            cond2[i+2] ? -1 : 0,\n            cond2[i+1] ? -1 : 0,\n            cond2[i] ? -1 : 0\n        ));\n\n        __m128 temp1 = _mm_and_ps(mask1, _mm_and_ps(mask2, a));\n        __m128 temp2 = _mm_and_ps(mask1, _mm_andnot_ps(mask2, b));\n        __m128 temp3 = _mm_and_ps(_mm_andnot_ps(mask1, mask2), c);\n        __m128 temp4 = _mm_and_ps(_mm_andnot_ps(mask1, _mm_andnot_ps(mask2, d)));\n        \n        __m128 result = _mm_or_ps(_mm_or_ps(temp1, temp2), _mm_or_ps(temp3, temp4));\n        _mm_store_ps(&out[i], result);\n    }\n\n    for (size_t i = aligned_size; i < total_size; i++) {\n        if (cond1[i]) {\n            out[i] = cond2[i] ? A[i] : B[i];\n        } else {\n            out[i] = cond2[i] ? C[i] : D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 4;\n    size_t remainder = total_size % 4;\n    \n    __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i * 4));\n        \n        __m128i mask1 = _mm_set1_epi8(0x0f);\n        __m128i mask2 = _mm_set1_epi32(0x0f0f0f0f);\n        \n        __m128i result = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; j++) {\n            __m128i shifted = _mm_srli_epi32(input, j * 8);\n            __m128i low_nibble = _mm_and_si128(shifted, mask1);\n            __m128i high_nibble = _mm_and_si128(_mm_srli_epi32(shifted, 4), mask1);\n            \n            __m128i count_low = _mm_shuffle_epi8(lookup, low_nibble);\n            __m128i count_high = _mm_shuffle_epi8(lookup, high_nibble);\n            \n            result = _mm_add_epi32(result, count_low);\n            result = _mm_add_epi32(result, count_high);\n        }\n        \n        __m128i packed = _mm_packs_epi32(result, result);\n        packed = _mm_packs_epi16(packed, packed);\n        \n        *((uint32_t*)(out + i * 4)) = _mm_cvtsi128_si32(packed);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_size * 4; i < total_size; i++) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = (total_size / 4) * 4;\n    \n    __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i));\n        \n        __m128i mask1 = _mm_set1_epi8(0x0f);\n        __m128i mask2 = _mm_set1_epi32(0x0f0f0f0f);\n        \n        // Split each 32-bit number into bytes\n        __m128i bytes = _mm_srli_epi32(input, 0);\n        \n        // Count bits in each nibble using lookup table\n        __m128i nibble1 = _mm_and_si128(bytes, mask2);\n        __m128i nibble2 = _mm_and_si128(_mm_srli_epi32(bytes, 4), mask2);\n        \n        __m128i count1 = _mm_shuffle_epi8(lookup, nibble1);\n        __m128i count2 = _mm_shuffle_epi8(lookup, nibble2);\n        \n        __m128i sum1 = _mm_add_epi8(count1, count2);\n        \n        // Process remaining bytes\n        __m128i sum2 = _mm_add_epi8(\n            _mm_shuffle_epi8(lookup, _mm_and_si128(_mm_srli_epi32(bytes, 16), mask2)),\n            _mm_shuffle_epi8(lookup, _mm_and_si128(_mm_srli_epi32(bytes, 20), mask2))\n        );\n        \n        __m128i sum3 = _mm_add_epi8(\n            _mm_shuffle_epi8(lookup, _mm_and_si128(_mm_srli_epi32(bytes, 8), mask2)),\n            _mm_shuffle_epi8(lookup, _mm_and_si128(_mm_srli_epi32(bytes, 12), mask2))\n        );\n        \n        __m128i sum4 = _mm_add_epi8(\n            _mm_shuffle_epi8(lookup, _mm_and_si128(_mm_srli_epi32(bytes, 24), mask2)),\n            _mm_shuffle_epi8(lookup, _mm_and_si128(_mm_srli_epi32(bytes, 28), mask2))\n        );\n        \n        // Sum all counts\n        __m128i total = _mm_add_epi8(_mm_add_epi8(sum1, sum2), _mm_add_epi8(sum3, sum4));\n        \n        // Extract results and store\n        uint32_t result[4];\n        _mm_storeu_si128((__m128i*)result, total);\n        \n        for (int j = 0; j < 4; j++) {\n            out[i + j] = (uint8_t)(result[j] & 0xFF);\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        out[i] = (uint8_t)(val & 0x3F);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t aligned_size = total_size & ~3ULL;\n    \n    __m128i lookup = _mm_set_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i));\n        \n        __m128i mask1 = _mm_set1_epi8(0x0f);\n        __m128i low_nibbles = _mm_and_si128(input, mask1);\n        __m128i high_nibbles = _mm_and_si128(_mm_srli_epi32(input, 4), mask1);\n        \n        __m128i low_count = _mm_shuffle_epi8(lookup, low_nibbles);\n        __m128i high_count = _mm_shuffle_epi8(lookup, high_nibbles);\n        \n        __m128i nibble_count = _mm_add_epi8(low_count, high_count);\n        \n        __m128i byte0 = _mm_add_epi8(nibble_count, _mm_srli_epi32(nibble_count, 8));\n        __m128i byte1 = _mm_add_epi8(byte0, _mm_srli_epi32(byte0, 16));\n        \n        __m128i result = _mm_and_si128(byte1, _mm_set1_epi32(0xFF));\n        \n        out[i] = _mm_extract_epi8(result, 0);\n        out[i+1] = _mm_extract_epi8(result, 4);\n        out[i+2] = _mm_extract_epi8(result, 8);\n        out[i+3] = _mm_extract_epi8(result, 12);\n    }\n    \n    for (size_t i = aligned_size; i < total_size; i++) {\n        uint32_t val = A[i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        out[i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 4;\n    size_t remainder = total_size % 4;\n\n    __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    __m128i mask1 = _mm_set1_epi32(0x0F0F0F0F);\n    __m128i mask2 = _mm_set1_epi32(0x0000FFFF);\n\n    for (size_t i = 0; i < vec_size; i++) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i * 4));\n        \n        __m128i tmp1 = input;\n        __m128i tmp2 = _mm_srli_epi32(input, 4);\n        tmp1 = _mm_and_si128(tmp1, mask1);\n        tmp2 = _mm_and_si128(tmp2, mask1);\n        tmp1 = _mm_shuffle_epi8(lookup, tmp1);\n        tmp2 = _mm_shuffle_epi8(lookup, tmp2);\n        tmp1 = _mm_add_epi32(tmp1, tmp2);\n\n        tmp2 = _mm_srli_epi32(input, 8);\n        input = _mm_srli_epi32(input, 12);\n        tmp2 = _mm_and_si128(tmp2, mask1);\n        input = _mm_and_si128(input, mask1);\n        tmp2 = _mm_shuffle_epi8(lookup, tmp2);\n        input = _mm_shuffle_epi8(lookup, input);\n        tmp1 = _mm_add_epi32(tmp1, tmp2);\n        tmp1 = _mm_add_epi32(tmp1, input);\n\n        tmp2 = _mm_srli_epi32(tmp1, 16);\n        tmp1 = _mm_add_epi32(tmp1, tmp2);\n        tmp1 = _mm_and_si128(tmp1, mask2);\n\n        __m128i result = _mm_packus_epi32(tmp1, tmp1);\n        result = _mm_packus_epi16(result, result);\n\n        *((uint32_t*)(out + i * 4)) = _mm_cvtsi128_si32(result);\n    }\n\n    // Handle remaining elements\n    size_t offset = vec_size * 4;\n    for (size_t i = 0; i < remainder; i++) {\n        uint32_t val = A[offset + i];\n        val = val - ((val >> 1) & 0x55555555);\n        val = (val & 0x33333333) + ((val >> 2) & 0x33333333);\n        val = (val + (val >> 4)) & 0x0F0F0F0F;\n        val = val + (val >> 8);\n        val = val + (val >> 16);\n        out[offset + i] = val & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_46_SSE", "completion": "```cpp\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t vec_size = total_size / 4;\n    size_t remainder = total_size % 4;\n\n    __m128i lookup = _mm_setr_epi8(0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4);\n    __m128i mask1 = _mm_set1_epi8(0x0f);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i * 4));\n        \n        __m128i result = _mm_setzero_si128();\n        \n        for (int j = 0; j < 4; j++) {\n            __m128i shifted = input;\n            if (j > 0) {\n                shifted = _mm_srli_epi32(input, j * 8);\n            }\n            \n            __m128i low = _mm_and_si128(shifted, mask1);\n            __m128i high = _mm_and_si128(_mm_srli_epi8(shifted, 4), mask1);\n            \n            __m128i count_low = _mm_shuffle_epi8(lookup, low);\n            __m128i count_high = _mm_shuffle_epi8(lookup, high);\n            \n            result = _mm_add_epi8(result, count_low);\n            result = _mm_add_epi8(result, count_high);\n        }\n        \n        uint8_t counts[16];\n        _mm_storeu_si128((__m128i*)counts, result);\n        \n        for (int j = 0; j < 4; j++) {\n            out[i * 4 + j] = counts[j * 4] + counts[j * 4 + 1] + \n                            counts[j * 4 + 2] + counts[j * 4 + 3];\n        }\n    }\n\n    // Handle remaining elements\n    for (size_t i = vec_size * 4; i < total_size; i++) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t aligned_size = total - (total % 4);\n    \n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        \n        // Calculate remainder when divided by 3\n        __m128i quotient = _mm_div_epi32(a, three);\n        __m128i product = _mm_mullo_epi32(quotient, three);\n        __m128i remainder = _mm_sub_epi32(a, product);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        // Get absolute values\n        __m128i neg = _mm_sub_epi32(zero, a);\n        __m128i abs = _mm_max_epi32(a, neg);\n        \n        // Select between original and absolute based on mask\n        __m128i result = _mm_blendv_epi8(a, abs, mask);\n        \n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] < 0) ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t aligned_size = total & ~3;\n    \n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        \n        // Calculate divisibility by 3\n        __m128i div3 = _mm_srli_epi32(_mm_mullo_epi32(a, _mm_set1_epi32(0x55555556)), 32);\n        div3 = _mm_sub_epi32(_mm_srai_epi32(a, 31), _mm_srai_epi32(_mm_sub_epi32(a, _mm_mullo_epi32(div3, three)), 31));\n        \n        // Get absolute value\n        __m128i sign = _mm_cmplt_epi32(a, zero);\n        __m128i abs_a = _mm_sub_epi32(_mm_xor_si128(a, sign), sign);\n        \n        // Select between original and absolute based on div3 mask\n        __m128i result = _mm_or_si128(_mm_and_si128(div3, abs_a), \n                                     _mm_andnot_si128(div3, a));\n        \n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = A[i] < 0 ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    const size_t total = rows * cols;\n    const size_t simd_width = 4;\n    const size_t simd_limit = total - (total % simd_width);\n    \n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < simd_limit; i += simd_width) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        \n        // Calculate remainder when divided by 3\n        __m128i quotient = _mm_div_epi32(a, three);\n        __m128i product = _mm_mullo_epi32(quotient, three);\n        __m128i remainder = _mm_sub_epi32(a, product);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        // Calculate absolute values\n        __m128i neg = _mm_sub_epi32(zero, a);\n        __m128i abs = _mm_max_epi32(a, neg);\n        \n        // Select between original and absolute based on mask\n        __m128i result = _mm_blendv_epi8(a, abs, mask);\n        \n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_limit; i < total; i++) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t aligned = total & ~0x3;\n    \n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        \n        // Calculate remainder when divided by 3\n        __m128i div = _mm_div_epi32(a, three);\n        __m128i mul = _mm_mullo_epi32(div, three);\n        __m128i rem = _mm_sub_epi32(a, mul);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        __m128i mask = _mm_cmpeq_epi32(rem, zero);\n        \n        // Get absolute values\n        __m128i neg = _mm_sub_epi32(zero, a);\n        __m128i abs = _mm_max_epi32(a, neg);\n        \n        // Select between original and absolute based on mask\n        __m128i result = _mm_blendv_epi8(a, abs, mask);\n        \n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned; i < total; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_SSE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t aligned_size = total - (total % 4);\n    \n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        \n        // Calculate remainder when divided by 3\n        __m128i div = _mm_div_epi32(a, three);\n        __m128i mul = _mm_mullo_epi32(div, three);\n        __m128i rem = _mm_sub_epi32(a, mul);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        __m128i mask = _mm_cmpeq_epi32(rem, zero);\n        \n        // Get absolute values\n        __m128i neg = _mm_sub_epi32(zero, a);\n        __m128i abs = _mm_max_epi32(a, neg);\n        \n        // Select between original and absolute based on mask\n        __m128i result = _mm_blendv_epi8(a, abs, mask);\n        \n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < total; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    __m128i mask = _mm_set1_epi32(0xF);\n    __m128i all_ones = _mm_set1_epi32(0xF);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Check if low 4 bits are all 1s\n        __m128i low_bits = _mm_and_si128(src_vec, mask);\n        __m128i cmp = _mm_cmpeq_epi32(low_bits, all_ones);\n        \n        // Perform rotation\n        __m128i rot_left = _mm_slli_epi32(src_vec, rotate_bits);\n        __m128i rot_right = _mm_srli_epi32(src_vec, 32 - rotate_bits);\n        __m128i rotated = _mm_or_si128(rot_left, rot_right);\n        \n        // Perform negation\n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Select between rotated and negated based on condition\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(cmp, rotated),\n            _mm_andnot_si128(cmp, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> (32 - rotate_bits)) | (src[i] << rotate_bits);\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    __m128i mask = _mm_set1_epi32(0xF);\n    __m128i all_ones = _mm_set1_epi32(0xF);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Check if low 4 bits are all 1\n        __m128i low_bits = _mm_and_si128(src_vec, mask);\n        __m128i cmp = _mm_cmpeq_epi32(low_bits, all_ones);\n        \n        // Prepare rotated values\n        __m128i rot_right = _mm_srli_epi32(src_vec, rotate_bits);\n        __m128i rot_left = _mm_slli_epi32(src_vec, 32 - rotate_bits);\n        __m128i rotated = _mm_or_si128(rot_right, rot_left);\n        \n        // Prepare negated values\n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(-1));\n        \n        // Select between rotated and negated based on condition\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(cmp, rotated),\n            _mm_andnot_si128(cmp, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    __m128i mask = _mm_set1_epi32(0xF);\n    __m128i all_ones = _mm_set1_epi32(0xF);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i low_bits = _mm_and_si128(src_vec, mask);\n        __m128i cmp = _mm_cmpeq_epi32(low_bits, all_ones);\n        \n        __m128i rotated = _mm_or_si128(\n            _mm_slli_epi32(src_vec, rotate_bits),\n            _mm_srli_epi32(src_vec, 32 - rotate_bits)\n        );\n        \n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        __m128i result = _mm_or_si128(\n            _mm_and_si128(cmp, rotated),\n            _mm_andnot_si128(cmp, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    __m128i mask = _mm_set1_epi32(0xF);\n    __m128i all_ones = _mm_set1_epi32(0xF);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        \n        // Check if low 4 bits are all 1\n        __m128i low_bits = _mm_and_si128(src_vec, mask);\n        __m128i cmp = _mm_cmpeq_epi32(low_bits, all_ones);\n        \n        // Perform rotation for matching elements\n        __m128i rot_right = _mm_srli_epi32(src_vec, rotate_bits);\n        __m128i rot_left = _mm_slli_epi32(src_vec, 32 - rotate_bits);\n        __m128i rotated = _mm_or_si128(rot_right, rot_left);\n        \n        // Perform bitwise NOT for non-matching elements\n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(-1));\n        \n        // Select between rotated and negated based on comparison\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(cmp, rotated),\n            _mm_andnot_si128(cmp, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_SSE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    __m128i mask = _mm_set1_epi32(0xF);\n    __m128i all_ones = _mm_set1_epi32(0xF);\n    __m128i rotate_amount = _mm_set1_epi32(rotate_bits);\n    \n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128i src_vec = _mm_loadu_si128((__m128i*)(src + i));\n        __m128i low_bits = _mm_and_si128(src_vec, mask);\n        __m128i condition = _mm_cmpeq_epi32(low_bits, all_ones);\n        \n        // Perform rotation\n        __m128i rotated = _mm_or_si128(\n            _mm_srl_epi32(src_vec, rotate_amount),\n            _mm_sll_epi32(src_vec, _mm_sub_epi32(_mm_set1_epi32(32), rotate_amount))\n        );\n        \n        // Perform negation\n        __m128i negated = _mm_xor_si128(src_vec, _mm_set1_epi32(0xFFFFFFFF));\n        \n        // Select based on condition\n        __m128i result = _mm_or_si128(\n            _mm_and_si128(condition, rotated),\n            _mm_andnot_si128(condition, negated)\n        );\n        \n        _mm_storeu_si128((__m128i*)(dst + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 eps = _mm_set1_ps(epsilon);\n    __m128 neg_eps = _mm_set1_ps(-epsilon);\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 neg_ones = _mm_set1_ps(-1.0f);\n    __m128 zeros = _mm_setzero_ps();\n\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(A + i);\n        __m128 b = _mm_loadu_ps(B + i);\n        __m128 diff = _mm_sub_ps(a, b);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff, eps);\n        __m128 lt_mask = _mm_cmplt_ps(diff, neg_eps);\n        \n        __m128 result = _mm_and_ps(gt_mask, ones);\n        result = _mm_or_ps(result, _mm_and_ps(lt_mask, neg_ones));\n        result = _mm_or_ps(result, _mm_and_ps(_mm_andnot_ps(_mm_or_ps(gt_mask, lt_mask), ones), zeros));\n        \n        __m128i int_result = _mm_cvtps_epi32(result);\n        __m128i packed = _mm_packs_epi32(int_result, int_result);\n        packed = _mm_packs_epi16(packed, packed);\n        \n        *((int32_t*)(out + i)) = _mm_cvtsi128_si32(packed);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) out[i] = 1;\n        else if (diff < -epsilon) out[i] = -1;\n        else out[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    const size_t simd_width = 4;\n    const size_t simd_length = length / simd_width;\n    const size_t remainder = length % simd_width;\n    \n    __m128 eps_vec = _mm_set1_ps(epsilon);\n    __m128 neg_eps_vec = _mm_set1_ps(-epsilon);\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 neg_ones = _mm_set1_ps(-1.0f);\n    __m128 zeros = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_length; i++) {\n        __m128 a = _mm_loadu_ps(A + i * simd_width);\n        __m128 b = _mm_loadu_ps(B + i * simd_width);\n        __m128 diff = _mm_sub_ps(a, b);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff, eps_vec);\n        __m128 lt_mask = _mm_cmplt_ps(diff, neg_eps_vec);\n        \n        __m128 result = _mm_and_ps(gt_mask, ones);\n        result = _mm_or_ps(result, _mm_and_ps(lt_mask, neg_ones));\n        result = _mm_or_ps(result, _mm_and_ps(_mm_nor_ps(gt_mask, lt_mask), zeros));\n        \n        __m128i int_result = _mm_cvtps_epi32(result);\n        __m128i packed = _mm_packs_epi32(int_result, int_result);\n        packed = _mm_packs_epi16(packed, packed);\n        \n        *((int32_t*)(out + i * simd_width)) = _mm_cvtsi128_si32(packed);\n    }\n\n    // Handle remaining elements\n    for (size_t i = simd_length * simd_width; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    const size_t simd_width = 4;\n    const size_t simd_length = length - (length % simd_width);\n    \n    __m128 eps = _mm_set1_ps(epsilon);\n    __m128 neg_eps = _mm_sub_ps(_mm_setzero_ps(), eps);\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 neg_ones = _mm_set1_ps(-1.0f);\n    __m128 zeros = _mm_setzero_ps();\n\n    for (size_t i = 0; i < simd_length; i += simd_width) {\n        __m128 a = _mm_loadu_ps(A + i);\n        __m128 b = _mm_loadu_ps(B + i);\n        __m128 diff = _mm_sub_ps(a, b);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff, eps);\n        __m128 lt_mask = _mm_cmplt_ps(diff, neg_eps);\n        \n        __m128 result = _mm_or_ps(\n            _mm_and_ps(gt_mask, ones),\n            _mm_and_ps(lt_mask, neg_ones)\n        );\n        \n        __m128i int_result = _mm_cvtps_epi32(result);\n        \n        out[i] = _mm_extract_epi32(int_result, 0);\n        out[i + 1] = _mm_extract_epi32(int_result, 1);\n        out[i + 2] = _mm_extract_epi32(int_result, 2);\n        out[i + 3] = _mm_extract_epi32(int_result, 3);\n    }\n\n    for (size_t i = simd_length; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 eps = _mm_set1_ps(epsilon);\n    __m128 neg_eps = _mm_set1_ps(-epsilon);\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 neg_ones = _mm_set1_ps(-1.0f);\n    __m128 zeros = _mm_setzero_ps();\n\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(A + i);\n        __m128 b = _mm_loadu_ps(B + i);\n        __m128 diff = _mm_sub_ps(a, b);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff, eps);\n        __m128 lt_mask = _mm_cmplt_ps(diff, neg_eps);\n        \n        __m128 result = _mm_and_ps(gt_mask, ones);\n        result = _mm_or_ps(result, _mm_and_ps(lt_mask, neg_ones));\n        result = _mm_or_ps(result, _mm_and_ps(_mm_andnot_ps(_mm_or_ps(gt_mask, lt_mask), ones), zeros));\n        \n        float temp[4];\n        _mm_storeu_ps(temp, result);\n        \n        for(int j = 0; j < 4; j++) {\n            out[i + j] = (int8_t)temp[j];\n        }\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon)\n            out[i] = 1;\n        else if (diff < -epsilon)\n            out[i] = -1;\n        else\n            out[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_49_SSE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    __m128 eps = _mm_set1_ps(epsilon);\n    __m128 neg_eps = _mm_sub_ps(_mm_setzero_ps(), eps);\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 neg_ones = _mm_set1_ps(-1.0f);\n    __m128 zeros = _mm_setzero_ps();\n\n    size_t i;\n    for (i = 0; i + 4 <= length; i += 4) {\n        __m128 a = _mm_loadu_ps(A + i);\n        __m128 b = _mm_loadu_ps(B + i);\n        __m128 diff = _mm_sub_ps(a, b);\n        \n        __m128 gt_mask = _mm_cmpgt_ps(diff, eps);\n        __m128 lt_mask = _mm_cmplt_ps(diff, neg_eps);\n        \n        __m128 result = _mm_and_ps(gt_mask, ones);\n        result = _mm_or_ps(result, _mm_and_ps(lt_mask, neg_ones));\n        \n        __m128i int_result = _mm_cvtps_epi32(result);\n        \n        out[i] = _mm_extract_epi32(int_result, 0);\n        out[i+1] = _mm_extract_epi32(int_result, 1);\n        out[i+2] = _mm_extract_epi32(int_result, 2);\n        out[i+3] = _mm_extract_epi32(int_result, 3);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) out[i] = 1;\n        else if (diff < -epsilon) out[i] = -1;\n        else out[i] = 0;\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    const __m128 max_val = _mm_set1_ps((float)INT32_MAX);\n    const __m128 min_val = _mm_set1_ps((float)INT32_MIN);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 input = _mm_loadu_ps(A + i);\n        \n        // Clamp values between INT32_MIN and INT32_MAX\n        input = _mm_min_ps(input, max_val);\n        input = _mm_max_ps(input, min_val);\n        \n        // Convert to integers with truncation\n        __m128i result = _mm_cvttps_epi32(input);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    const __m128 max_val = _mm_set1_ps((float)INT32_MAX);\n    const __m128 min_val = _mm_set1_ps((float)INT32_MIN);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 input = _mm_loadu_ps(A + i);\n        \n        // Clamp values between INT32_MIN and INT32_MAX\n        input = _mm_min_ps(input, max_val);\n        input = _mm_max_ps(input, min_val);\n        \n        // Convert to integers with truncation\n        __m128i result = _mm_cvttps_epi32(input);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    const __m128 max_val = _mm_set1_ps((float)INT32_MAX);\n    const __m128 min_val = _mm_set1_ps((float)INT32_MIN);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 input = _mm_loadu_ps(A + i);\n        \n        // Clamp values between INT32_MIN and INT32_MAX\n        input = _mm_min_ps(input, max_val);\n        input = _mm_max_ps(input, min_val);\n        \n        // Convert to integer\n        __m128i result = _mm_cvtps_epi32(input);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    const __m128 max_val = _mm_set1_ps((float)INT32_MAX);\n    const __m128 min_val = _mm_set1_ps((float)INT32_MIN);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 input = _mm_loadu_ps(A + i);\n        \n        // Clamp values between INT32_MIN and INT32_MAX\n        input = _mm_min_ps(input, max_val);\n        input = _mm_max_ps(input, min_val);\n        \n        // Convert to integers with truncation\n        __m128i result = _mm_cvttps_epi32(input);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_SSE", "completion": "```cpp\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i;\n    const __m128 max_float = _mm_set1_ps((float)INT32_MAX);\n    const __m128 min_float = _mm_set1_ps((float)INT32_MIN);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 input = _mm_loadu_ps(A + i);\n        \n        // Clamp values between INT32_MIN and INT32_MAX\n        input = _mm_min_ps(input, max_float);\n        input = _mm_max_ps(input, min_float);\n        \n        // Convert to integers with truncation\n        __m128i result = _mm_cvttps_epi32(input);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)(B + i), result);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        __m128 scaled = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, scaled);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        __m128 scaled = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, scaled);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        __m128 result = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        __m128 scaled = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, scaled);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SSE", "completion": "```cpp\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    size_t i;\n    __m128 scale_vec = _mm_set1_ps((float)scale);\n    \n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128i int_vec = _mm_loadu_si128((__m128i*)(A + i));\n        __m128 float_vec = _mm_cvtepi32_ps(int_vec);\n        __m128 result = _mm_mul_ps(float_vec, scale_vec);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_load_ps(A + i);\n        __m128 b = _mm_load_ps(B + i);\n        __m128 div = _mm_div_ps(a, b);\n        __m128i result = _mm_cvtps_epi32(div);\n        _mm_store_si128((__m128i*)(C + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_load_ps(A + i);\n        __m128 b = _mm_load_ps(B + i);\n        __m128 div = _mm_div_ps(a, b);\n        __m128i result = _mm_cvtps_epi32(div);\n        _mm_store_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3;\n\n    for (i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_load_ps(A + i);\n        __m128 b = _mm_load_ps(B + i);\n        __m128 div = _mm_div_ps(a, b);\n        __m128i result = _mm_cvtps_epi32(div);\n        _mm_store_si128((__m128i*)(C + i), result);\n    }\n\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_load_ps(A + i);\n        __m128 b = _mm_load_ps(B + i);\n        __m128 div = _mm_div_ps(a, b);\n        __m128i result = _mm_cvtps_epi32(div);\n        _mm_store_si128((__m128i*)(C + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SSE", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128 a = _mm_load_ps(A + i);\n        __m128 b = _mm_load_ps(B + i);\n        __m128 div = _mm_div_ps(a, b);\n        __m128i result = _mm_cvtps_epi32(div);\n        _mm_store_si128((__m128i*)(C + i), result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        C[i] = (int32_t)roundf(A[i] / B[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 flt_max = _mm_set1_ps(FLT_MAX);\n    const __m128 flt_min = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 1 < size; i += 2) {\n        __m128d doubles = _mm_loadu_pd(A + i);\n        __m128 floats = _mm_cvtpd_ps(doubles);\n        \n        floats = _mm_min_ps(floats, flt_max);\n        floats = _mm_max_ps(floats, flt_min);\n        \n        _mm_storel_pi((__m64*)(B + i), floats);\n    }\n\n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    __m128 fltmax = _mm_set1_ps(FLT_MAX);\n    __m128 fltmin = _mm_set1_ps(-FLT_MAX);\n    \n    for (i = 0; i + 1 < size; i += 2) {\n        __m128d dbl = _mm_loadu_pd(A + i);\n        __m128 flt = _mm_cvtpd_ps(dbl);\n        flt = _mm_min_ps(flt, fltmax);\n        flt = _mm_max_ps(flt, fltmin);\n        _mm_storel_pi((__m64*)(B + i), flt);\n    }\n\n    if (i < size) {\n        __m128d dbl = _mm_load_sd(A + i);\n        __m128 flt = _mm_cvtpd_ps(dbl);\n        flt = _mm_min_ps(flt, fltmax);\n        flt = _mm_max_ps(flt, fltmin);\n        _mm_store_ss(B + i, flt);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    const __m128 flt_max = _mm_set1_ps(FLT_MAX);\n    const __m128 flt_min = _mm_set1_ps(-FLT_MAX);\n    \n    for (i = 0; i + 1 < size; i += 2) {\n        __m128d doubles = _mm_loadu_pd(A + i);\n        __m128 floats = _mm_cvtpd_ps(doubles);\n        floats = _mm_min_ps(floats, flt_max);\n        floats = _mm_max_ps(floats, flt_min);\n        _mm_storel_pi((__m64*)(B + i), floats);\n    }\n\n    for (; i < size; i++) {\n        __m128d d = _mm_load_sd(A + i);\n        __m128 f = _mm_cvtpd_ps(d);\n        f = _mm_min_ps(f, flt_max);\n        f = _mm_max_ps(f, flt_min);\n        _mm_store_ss(B + i, f);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i;\n    __m128 fltmax = _mm_set1_ps(FLT_MAX);\n    __m128 fltmin = _mm_set1_ps(-FLT_MAX);\n    \n    for (i = 0; i + 1 < size; i += 2) {\n        __m128d dbl = _mm_loadu_pd(A + i);\n        __m128 flt = _mm_cvtpd_ps(dbl);\n        flt = _mm_min_ps(flt, fltmax);\n        flt = _mm_max_ps(flt, fltmin);\n        _mm_storel_pi((__m64*)(B + i), flt);\n    }\n\n    if (i < size) {\n        __m128d dbl = _mm_load_sd(A + i);\n        __m128 flt = _mm_cvtpd_ps(dbl);\n        flt = _mm_min_ps(flt, fltmax);\n        flt = _mm_max_ps(flt, fltmin);\n        _mm_store_ss(B + i, flt);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SSE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const __m128 max_float = _mm_set1_ps(FLT_MAX);\n    const __m128 min_float = _mm_set1_ps(-FLT_MAX);\n    \n    size_t i;\n    for (i = 0; i + 1 < size; i += 2) {\n        __m128d doubles = _mm_loadu_pd(A + i);\n        __m128 floats = _mm_cvtpd_ps(doubles);\n        \n        floats = _mm_min_ps(floats, max_float);\n        floats = _mm_max_ps(floats, min_float);\n        \n        _mm_storel_pi((__m64*)(B + i), floats);\n    }\n    \n    for (; i < size; i++) {\n        double val = A[i];\n        if (val > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m64 tmp = _mm_load_si64((const __m64*)(A + i));\n        __m128i vec = _mm_cvtepi16_epi32(_mm_loadl_epi64((__m128i*)&tmp));\n        _mm_store_si128((__m128i*)(B + i), vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m64 mmx_val = _mm_loadl_pi(_mm_setzero_ps(), (__m64*)&A[i]);\n        __m128i xmm_val = _mm_cvtpi16_pi32(mmx_val);\n        _mm_store_si128((__m128i*)&B[i], xmm_val);\n    }\n    \n    _mm_empty();\n    \n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 8);\n    \n    for (i = 0; i < simd_size; i += 8) {\n        __m128i in = _mm_loadu_si128((__m128i*)(A + i));\n        \n        __m128i low = _mm_unpacklo_epi16(in, _mm_srai_epi16(in, 15));\n        __m128i high = _mm_unpackhi_epi16(in, _mm_srai_epi16(in, 15));\n        \n        _mm_storeu_si128((__m128i*)(B + i), low);\n        _mm_storeu_si128((__m128i*)(B + i + 4), high);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m64 lower = _mm_loadl_pi(_mm_setzero_si64(), (__m64*)&A[i]);\n        __m128i values = _mm_cvtpi16_epi32(_mm_loadl_pi(_mm_setzero_si64(), (__m64*)&A[i]));\n        _mm_storeu_si128((__m128i*)&B[i], values);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n    \n    _mm_empty();\n}\n```"}
{"task_id": "SimdBench_54_SSE", "completion": "```cpp\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m64 mmx_val = _mm_loadl_pi(_mm_setzero_ps(), (__m64*)&A[i]);\n        __m128i xmm_val = _mm_cvtpi16_pi32(mmx_val);\n        _mm_storeu_si128((__m128i*)&B[i], xmm_val);\n    }\n    \n    _mm_empty();\n    \n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 vmin = _mm_set1_ps(min_val);\n    __m128 vmax = _mm_set1_ps(max_val);\n    __m128 vrange = _mm_sub_ps(vmax, vmin);\n    __m128 vzero = _mm_setzero_ps();\n    __m128 vone = _mm_set1_ps(1.0f);\n    \n    size_t i;\n    for(i = 0; i + 4 <= size; i += 4) {\n        __m128 va = _mm_loadu_ps(&A[i]);\n        __m128i vcontrol = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 vmask = _mm_castsi128_ps(_mm_cmpgt_epi32(vcontrol, _mm_setzero_si128()));\n        \n        // Normalize values\n        __m128 vnorm = _mm_sub_ps(va, vmin);\n        vnorm = _mm_div_ps(vnorm, vrange);\n        \n        // Clamp between 0 and 1\n        vnorm = _mm_max_ps(vnorm, vzero);\n        vnorm = _mm_min_ps(vnorm, vone);\n        \n        // Select between normalized and original based on control\n        __m128 vresult = _mm_or_ps(\n            _mm_and_ps(vmask, vnorm),\n            _mm_andnot_ps(vmask, va)\n        );\n        \n        _mm_storeu_ps(&B[i], vresult);\n    }\n    \n    // Handle remaining elements\n    for(; i < size; i++) {\n        if(control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 vmin = _mm_set1_ps(min_val);\n    __m128 vmax = _mm_set1_ps(max_val);\n    __m128 vrange = _mm_sub_ps(vmax, vmin);\n    __m128 vzero = _mm_setzero_ps();\n    __m128 vone = _mm_set1_ps(1.0f);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 va = _mm_loadu_ps(&A[i]);\n        __m128i vcontrol = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 vcontrol_f = _mm_cvtepi32_ps(vcontrol);\n        __m128 vmask = _mm_cmpgt_ps(vcontrol_f, vzero);\n        \n        // Normalize values\n        __m128 vnorm = _mm_sub_ps(va, vmin);\n        vnorm = _mm_div_ps(vnorm, vrange);\n        vnorm = _mm_max_ps(vnorm, vzero);\n        vnorm = _mm_min_ps(vnorm, vone);\n        \n        // Select between normalized and original values based on control\n        __m128 vresult = _mm_or_ps(\n            _mm_and_ps(vmask, vnorm),\n            _mm_andnot_ps(vmask, va)\n        );\n        \n        _mm_storeu_ps(&B[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 vmin = _mm_set1_ps(min_val);\n    __m128 vmax = _mm_set1_ps(max_val);\n    __m128 vrange = _mm_sub_ps(vmax, vmin);\n    __m128 vzero = _mm_setzero_ps();\n    __m128 vone = _mm_set1_ps(1.0f);\n    \n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 va = _mm_loadu_ps(&A[i]);\n        __m128i vcontrol = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 vcmp = _mm_cvtepi32_ps(vcontrol);\n        __m128 vmask = _mm_cmpgt_ps(vcmp, vzero);\n        \n        // Normalize values\n        __m128 vnorm = _mm_sub_ps(va, vmin);\n        vnorm = _mm_div_ps(vnorm, vrange);\n        \n        // Clamp between 0 and 1\n        vnorm = _mm_max_ps(vnorm, vzero);\n        vnorm = _mm_min_ps(vnorm, vone);\n        \n        // Select between normalized and original based on control\n        __m128 vresult = _mm_or_ps(\n            _mm_and_ps(vmask, vnorm),\n            _mm_andnot_ps(vmask, va)\n        );\n        \n        _mm_storeu_ps(&B[i], vresult);\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 vmin = _mm_set1_ps(min_val);\n    __m128 vmax = _mm_set1_ps(max_val);\n    __m128 vrange = _mm_sub_ps(vmax, vmin);\n    __m128 vzero = _mm_setzero_ps();\n    __m128 vone = _mm_set1_ps(1.0f);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 va = _mm_loadu_ps(&A[i]);\n        __m128i vctrl = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 vmask = _mm_castsi128_ps(_mm_cmpgt_epi32(vctrl, _mm_setzero_si128()));\n        \n        // Normalize values\n        __m128 vnorm = _mm_sub_ps(va, vmin);\n        vnorm = _mm_div_ps(vnorm, vrange);\n        vnorm = _mm_max_ps(vnorm, vzero);\n        vnorm = _mm_min_ps(vnorm, vone);\n        \n        // Select between normalized and original based on control\n        __m128 vresult = _mm_or_ps(\n            _mm_and_ps(vmask, vnorm),\n            _mm_andnot_ps(vmask, va)\n        );\n        \n        _mm_storeu_ps(&B[i], vresult);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / (max_val - min_val);\n            B[i] = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_SSE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    __m128 vmin = _mm_set1_ps(min_val);\n    __m128 vmax = _mm_set1_ps(max_val);\n    __m128 vrange = _mm_sub_ps(vmax, vmin);\n    __m128 vzero = _mm_setzero_ps();\n    __m128 vone = _mm_set1_ps(1.0f);\n\n    size_t i;\n    for (i = 0; i + 4 <= size; i += 4) {\n        __m128 va = _mm_loadu_ps(&A[i]);\n        __m128i vcontrol = _mm_loadu_si128((__m128i*)&control[i]);\n        __m128 vcontrol_f = _mm_cvtepi32_ps(vcontrol);\n        __m128 mask = _mm_cmpgt_ps(vcontrol_f, vzero);\n\n        __m128 normalized = _mm_sub_ps(va, vmin);\n        normalized = _mm_div_ps(normalized, vrange);\n        normalized = _mm_max_ps(normalized, vzero);\n        normalized = _mm_min_ps(normalized, vone);\n\n        __m128 result = _mm_or_ps(\n            _mm_and_ps(mask, normalized),\n            _mm_andnot_ps(mask, va)\n        );\n\n        _mm_storeu_ps(&B[i], result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float normalized = (A[i] - min_val) / (max_val - min_val);\n            B[i] = normalized < 0.0f ? 0.0f : (normalized > 1.0f ? 1.0f : normalized);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i shifted = _mm_srli_epi32(input, 16);\n        __m128 converted = _mm_cvtepi32_ps(shifted);\n        __m128 result = _mm_sqrt_ps(converted);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i input = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i shifted = _mm_srli_epi32(input, 16);\n        __m128 converted = _mm_cvtepi32_ps(shifted);\n        __m128 result = _mm_sqrt_ps(converted);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i shifted = _mm_srli_epi32(a, 16);\n        __m128 converted = _mm_cvtepi32_ps(shifted);\n        __m128 result = _mm_sqrt_ps(converted);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i shifted = _mm_srli_epi32(a, 16);\n        __m128 converted = _mm_cvtepi32_ps(shifted);\n        __m128 result = _mm_sqrt_ps(converted);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SSE", "completion": "```cpp\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    const size_t simd_size = size - (size % 4);\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i a = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i shifted = _mm_srli_epi32(a, 16);\n        __m128 converted = _mm_cvtepi32_ps(shifted);\n        __m128 result = _mm_sqrt_ps(converted);\n        _mm_storeu_ps(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i int_vals = _mm_loadu_si128((__m128i*)(A + i));\n        _mm_storeu_ps(B + i, _mm_castsi128_ps(int_vals));\n    }\n    \n    for (; i < size; i++) {\n        _mm_store_ss(B + i, _mm_castsi128_ps(_mm_set1_epi32(A[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i int_val = _mm_loadu_si128((__m128i*)(A + i));\n        _mm_storeu_ps(B + i, _mm_castsi128_ps(int_val));\n    }\n    \n    for (; i < size; i++) {\n        _mm_store_ss(B + i, _mm_castsi128_ps(_mm_set1_epi32(A[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i int_vals = _mm_loadu_si128((__m128i*)(A + i));\n        _mm_storeu_ps(B + i, _mm_castsi128_ps(int_vals));\n    }\n    \n    for (; i < size; i++) {\n        _mm_store_ss(B + i, _mm_castsi128_ps(_mm_set1_epi32(A[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i int_val = _mm_loadu_si128((__m128i*)(A + i));\n        _mm_storeu_ps(B + i, _mm_castsi128_ps(int_val));\n    }\n    \n    for (; i < size; i++) {\n        _mm_store_ss(B + i, _mm_castsi128_ps(_mm_set1_epi32(A[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_57_SSE", "completion": "```cpp\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i;\n    size_t simd_size = size & ~3UL;\n    \n    for (i = 0; i < simd_size; i += 4) {\n        __m128i int_vals = _mm_loadu_si128((__m128i*)(A + i));\n        _mm_storeu_ps(B + i, _mm_castsi128_ps(int_vals));\n    }\n    \n    for (; i < size; i++) {\n        _mm_store_ss(B + i, _mm_castsi128_ps(_mm_set1_epi32(A[i])));\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const size_t simd_size = 4;\n    size_t i;\n\n    for (i = 1; i + simd_size <= size; i += simd_size) {\n        // Load current and previous values\n        __m128i curr = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev = _mm_loadu_si128((__m128i*)(A + i - 1));\n        \n        // Load condition flags\n        __m128i cond_mask = _mm_set_epi32(\n            cond[i+3] ? -1 : 0,\n            cond[i+2] ? -1 : 0,\n            cond[i+1] ? -1 : 0,\n            cond[i+0] ? -1 : 0\n        );\n        \n        // Calculate differences\n        __m128i diff_i = _mm_sub_epi32(curr, prev);\n        \n        // Convert to float\n        __m128 diff_f = _mm_cvtepi32_ps(diff_i);\n        \n        // Apply condition mask\n        __m128 masked = _mm_and_ps(_mm_castsi128_ps(cond_mask), diff_f);\n        \n        // Store result\n        _mm_storeu_ps(diff + i, masked);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const int simd_width = 4;\n    size_t i;\n\n    for (i = 1; i + simd_width <= size; i += simd_width) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev = _mm_loadu_si128((__m128i*)(A + i - 1));\n        __m128i diff_i = _mm_sub_epi32(curr, prev);\n        \n        __m128 diff_f = _mm_cvtepi32_ps(diff_i);\n        \n        __m128i cond_mask = _mm_loadu_si128((__m128i*)(cond + i));\n        cond_mask = _mm_and_si128(cond_mask, _mm_set1_epi32(0x1));\n        __m128 mask_f = _mm_castsi128_ps(_mm_cmpeq_epi32(cond_mask, _mm_set1_epi32(1)));\n        \n        __m128 result = _mm_and_ps(diff_f, mask_f);\n        \n        _mm_storeu_ps(diff + i, result);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const size_t simd_size = (size-1) / 4 * 4;\n    size_t i = 1;\n\n    for (; i <= simd_size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev = _mm_loadu_si128((__m128i*)(A + i - 1));\n        __m128i diff_i = _mm_sub_epi32(curr, prev);\n        \n        __m128 diff_f = _mm_cvtepi32_ps(diff_i);\n        \n        __m128i cond_mask = _mm_loadu_si128((__m128i*)(cond + i));\n        cond_mask = _mm_and_si128(cond_mask, _mm_set1_epi32(0x1));\n        __m128 mask_f = _mm_castsi128_ps(_mm_cmpeq_epi32(cond_mask, _mm_set1_epi32(1)));\n        \n        __m128 result = _mm_and_ps(diff_f, mask_f);\n        \n        _mm_storeu_ps(diff + i, result);\n    }\n\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    if (size <= 1) return;\n\n    const size_t simd_size = 4;\n    size_t i;\n\n    for (i = 1; i + simd_size <= size; i += simd_size) {\n        // Load current and previous integers\n        __m128i curr = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev = _mm_loadu_si128((__m128i*)(A + i - 1));\n        \n        // Compute differences\n        __m128i diff_i = _mm_sub_epi32(curr, prev);\n        \n        // Convert to float\n        __m128 diff_f = _mm_cvtepi32_ps(diff_i);\n        \n        // Load conditions\n        __m128i cond_mask = _mm_loadu_si128((__m128i*)(cond + i));\n        cond_mask = _mm_and_si128(cond_mask, _mm_set1_epi32(1));\n        __m128 mask_f = _mm_cvtepi32_ps(cond_mask);\n        \n        // Apply conditions\n        __m128 result = _mm_mul_ps(diff_f, mask_f);\n        \n        // Store result\n        _mm_storeu_ps(diff + i, result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SSE", "completion": "```cpp\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    size_t i;\n    for (i = 1; i + 4 <= size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(A + i));\n        __m128i prev = _mm_loadu_si128((__m128i*)(A + i - 1));\n        __m128i diff_i = _mm_sub_epi32(curr, prev);\n        \n        __m128i cond_mask = _mm_set_epi32(\n            cond[i+3] ? -1 : 0,\n            cond[i+2] ? -1 : 0,\n            cond[i+1] ? -1 : 0,\n            cond[i] ? -1 : 0\n        );\n        \n        diff_i = _mm_and_si128(diff_i, cond_mask);\n        __m128 diff_f = _mm_cvtepi32_ps(diff_i);\n        \n        _mm_storeu_ps(diff + i, diff_f);\n    }\n    \n    for (; i < size; i++) {\n        diff[i] = cond[i] ? (float)(A[i] - A[i-1]) : 0.0f;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i ones = _mm_set1_epi32(-1);\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i input = _mm_loadl_epi64((__m128i*)(src + i));\n        __m128i extended = _mm_unpacklo_epi32(input, ones);\n        _mm_store_si128((__m128i*)(dst + i), extended);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | (0xFFFFFFFFULL << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const __m128i ones = _mm_set1_epi32(-1);\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i input = _mm_loadl_epi64((__m128i*)(src + i));\n        __m128i extended = _mm_unpacklo_epi32(input, ones);\n        _mm_store_si128((__m128i*)(dst + i), extended);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[i] | (0xFFFFFFFFULL << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    __m128i ones = _mm_set1_epi32(-1);\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i input = _mm_loadl_epi64((__m128i*)(src + i));\n        __m128i extended = _mm_unpacklo_epi32(input, ones);\n        _mm_storeu_si128((__m128i*)(dst + i), extended);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | (0xFFFFFFFFULL << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const __m128i ones = _mm_set1_epi32(-1);\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i input = _mm_loadl_epi64((__m128i*)(src + i));\n        __m128i extended = _mm_unpacklo_epi32(input, ones);\n        _mm_store_si128((__m128i*)(dst + i), extended);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        dst[i] = src[i] | (0xFFFFFFFFULL << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SSE", "completion": "```cpp\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i;\n    const __m128i ones = _mm_set1_epi32(-1);\n    \n    for (i = 0; i + 2 <= length; i += 2) {\n        __m128i input = _mm_loadl_epi64((__m128i*)(src + i));\n        __m128i extended = _mm_unpacklo_epi32(input, ones);\n        _mm_storeu_si128((__m128i*)(dst + i), extended);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = src[i] | (0xFFFFFFFFULL << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)(index + i));\n        idx = _mm_unpacklo_epi16(idx, _mm_setzero_si128());\n        \n        __m128d val1 = _mm_load_sd(vec + index[i]);\n        __m128d val2 = _mm_load_sd(vec + index[i+1]);\n        __m128d vals = _mm_unpacklo_pd(val1, val2);\n        \n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double result = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n    \n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)(index + i));\n        idx = _mm_unpacklo_epi16(idx, _mm_setzero_si128());\n        \n        __m128d val1 = _mm_load_sd(vec + index[i]);\n        __m128d val2 = _mm_load_sd(vec + index[i+1]);\n        __m128d vals = _mm_unpacklo_pd(val1, val2);\n        \n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double result = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n    \n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)(index + i));\n        idx = _mm_unpacklo_epi16(idx, _mm_setzero_si128());\n        \n        __m128d val1 = _mm_load_sd(vec + index[i]);\n        __m128d val2 = _mm_load_sd(vec + index[i+1]);\n        __m128d vals = _mm_unpacklo_pd(val1, val2);\n        \n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double result = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n    \n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    size_t i;\n    \n    // Process 2 elements at a time\n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)(index + i));\n        idx = _mm_unpacklo_epi16(idx, _mm_setzero_si128()); // Convert to 32-bit\n        \n        // Load indexed values\n        double val1 = vec[_mm_extract_epi32(idx, 0)];\n        double val2 = vec[_mm_extract_epi32(idx, 1)];\n        \n        __m128d values = _mm_setr_pd(val1, val2);\n        sum = _mm_add_pd(sum, values);\n    }\n    \n    // Handle remaining element if length is odd\n    if (i < length) {\n        sum = _mm_add_pd(sum, _mm_set_pd(0.0, vec[index[i]]));\n    }\n    \n    // Horizontal sum\n    __m128d temp = _mm_hadd_pd(sum, sum);\n    return _mm_cvtsd_f64(temp);\n}\n```"}
{"task_id": "SimdBench_60_SSE", "completion": "```cpp\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    __m128d sum = _mm_setzero_pd();\n    size_t i;\n    \n    for (i = 0; i + 1 < length; i += 2) {\n        __m128i idx = _mm_loadu_si128((__m128i*)(index + i));\n        idx = _mm_unpacklo_epi16(idx, _mm_setzero_si128());\n        \n        __m128d val1 = _mm_load_sd(vec + _mm_extract_epi32(idx, 0));\n        __m128d val2 = _mm_load_sd(vec + _mm_extract_epi32(idx, 1));\n        \n        __m128d pair = _mm_unpacklo_pd(val1, val2);\n        sum = _mm_add_pd(sum, pair);\n    }\n    \n    double result = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n    \n    for (; i < length; i++) {\n        result += vec[index[i]];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += 2) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + j + kj;\n                    __m128d in = _mm_loadu_pd(&input[input_idx]);\n                    __m128d ker = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    sum = _mm_add_pd(sum, _mm_mul_pd(in, ker));\n                }\n            }\n            \n            // ReLU activation\n            sum = _mm_max_pd(sum, zero);\n            \n            if (j + 1 < output_size) {\n                _mm_storeu_pd(&output[i * output_size + j], sum);\n            } else {\n                // Handle edge case when output_size is odd\n                _mm_store_sd(&output[i * output_size + j], sum);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += 2) {\n            __m128d sum = _mm_setzero_pd();\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + j + kj;\n                    __m128d input_val;\n                    \n                    if (j + 1 < output_size) {\n                        input_val = _mm_setr_pd(\n                            input[input_idx],\n                            input[input_idx + 1]\n                        );\n                    } else {\n                        input_val = _mm_setr_pd(\n                            input[input_idx],\n                            0.0\n                        );\n                    }\n\n                    __m128d kernel_val = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    __m128d mul = _mm_mul_pd(input_val, kernel_val);\n                    sum = _mm_add_pd(sum, mul);\n                }\n            }\n\n            // ReLU activation\n            sum = _mm_max_pd(sum, zero);\n\n            // Store result\n            if (j + 1 < output_size) {\n                _mm_storeu_pd(&output[i * output_size + j], sum);\n            } else {\n                _mm_store_sd(&output[i * output_size + j], sum);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += 2) {\n            __m128d sum = _mm_setzero_pd();\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + j + kj;\n                    __m128d in = _mm_loadu_pd(&input[input_idx]);\n                    __m128d kern = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    sum = _mm_add_pd(sum, _mm_mul_pd(in, kern));\n                }\n            }\n\n            // ReLU activation\n            sum = _mm_max_pd(sum, zero);\n\n            if (j + 1 < output_size) {\n                _mm_storeu_pd(&output[i * output_size + j], sum);\n            } else {\n                // Handle edge case when output_size is odd\n                _mm_store_sd(&output[i * output_size + j], sum);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            __m128d sum = _mm_setzero_pd();\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                size_t input_row = i + k;\n                \n                for (size_t l = 0; l < kernel_size - 1; l += 2) {\n                    size_t input_idx = input_row * input_size + j + l;\n                    size_t kernel_idx = k * kernel_size + l;\n                    \n                    __m128d input_vec = _mm_loadu_pd(&input[input_idx]);\n                    __m128d kernel_vec = _mm_loadu_pd(&kernel[kernel_idx]);\n                    __m128d mul = _mm_mul_pd(input_vec, kernel_vec);\n                    sum = _mm_add_pd(sum, mul);\n                }\n                \n                // Handle remaining element if kernel_size is odd\n                if (kernel_size % 2) {\n                    size_t input_idx = input_row * input_size + j + kernel_size - 1;\n                    size_t kernel_idx = k * kernel_size + kernel_size - 1;\n                    \n                    __m128d input_val = _mm_load_sd(&input[input_idx]);\n                    __m128d kernel_val = _mm_load_sd(&kernel[kernel_idx]);\n                    __m128d mul = _mm_mul_sd(input_val, kernel_val);\n                    sum = _mm_add_sd(sum, mul);\n                }\n            }\n            \n            // Horizontal add of sum vector\n            __m128d temp = _mm_unpackhi_pd(sum, sum);\n            sum = _mm_add_sd(sum, temp);\n            \n            // Apply ReLU\n            sum = _mm_max_sd(sum, zero);\n            \n            // Store result\n            _mm_store_sd(&output[i * output_size + j], sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SSE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    __m128d zero = _mm_setzero_pd();\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += 2) {\n            __m128d sum = _mm_setzero_pd();\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_idx = (i + ki) * input_size + j + kj;\n                    __m128d input_val;\n                    \n                    if (j + 1 < output_size) {\n                        input_val = _mm_set_pd(\n                            input[input_idx + 1],\n                            input[input_idx]\n                        );\n                    } else {\n                        input_val = _mm_set_pd(\n                            0.0,\n                            input[input_idx]\n                        );\n                    }\n\n                    __m128d kernel_val = _mm_set1_pd(kernel[ki * kernel_size + kj]);\n                    __m128d mul = _mm_mul_pd(input_val, kernel_val);\n                    sum = _mm_add_pd(sum, mul);\n                }\n            }\n\n            // ReLU activation\n            sum = _mm_max_pd(sum, zero);\n\n            // Store result\n            if (j + 1 < output_size) {\n                _mm_storeu_pd(&output[i * output_size + j], sum);\n            } else {\n                _mm_store_sd(&output[i * output_size + j], sum);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    const int size = numbers.size();\n    const __m128d thresh = _mm_set1_pd(threshold);\n\n    for (int i = 0; i < size - 1; i++) {\n        __m128d v1 = _mm_set1_pd(numbers[i]);\n        \n        for (int j = i + 1; j < size - 1; j += 2) {\n            __m128d v2 = _mm_loadu_pd(&numbers[j]);\n            __m128d diff = _mm_sub_pd(v1, v2);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmplt_pd(abs_diff, thresh);\n            \n            if (_mm_movemask_pd(cmp)) {\n                return true;\n            }\n        }\n\n        // Handle last element if size is odd\n        if (size % 2 == 0 && i < size - 2) {\n            double diff = std::abs(numbers[i] - numbers[size-1]);\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n\n    // Check last pair if not already checked\n    if (size % 2 == 0) {\n        double diff = std::abs(numbers[size-2] - numbers[size-1]);\n        if (diff < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    const size_t n = numbers.size();\n    const __m128d thresh = _mm_set1_pd(threshold);\n    \n    for (size_t i = 0; i < n-1; i++) {\n        __m128d v1 = _mm_set1_pd(numbers[i]);\n        \n        for (size_t j = i+1; j < n; j += 2) {\n            __m128d v2;\n            if (j + 1 < n) {\n                v2 = _mm_loadu_pd(&numbers[j]);\n            } else {\n                v2 = _mm_set_pd(numbers[j], numbers[j]);\n            }\n            \n            __m128d diff = _mm_sub_pd(v1, v2);\n            diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            \n            __m128d cmp = _mm_cmplt_pd(diff, thresh);\n            int mask = _mm_movemask_pd(cmp);\n            \n            if (mask != 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    const int n = numbers.size();\n    const __m128d thresh = _mm_set1_pd(threshold);\n    \n    for (int i = 0; i < n-1; i++) {\n        const __m128d v1 = _mm_set1_pd(numbers[i]);\n        \n        for (int j = i+1; j < n-1; j+=2) {\n            __m128d v2 = _mm_loadu_pd(&numbers[j]);\n            __m128d diff = _mm_sub_pd(v1, v2);\n            diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmplt_pd(diff, thresh);\n            \n            if (_mm_movemask_pd(cmp) != 0) {\n                return true;\n            }\n        }\n        \n        if ((n-1-i) % 2 != 0) {\n            double diff = std::abs(numbers[i] - numbers[n-1]);\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    const int n = numbers.size();\n    __m128d thresh = _mm_set1_pd(threshold);\n\n    for (int i = 0; i < n-1; i++) {\n        __m128d v1 = _mm_set1_pd(numbers[i]);\n        \n        for (int j = i+1; j < n-1; j+=2) {\n            __m128d v2 = _mm_loadu_pd(&numbers[j]);\n            __m128d diff = _mm_sub_pd(v1, v2);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmplt_pd(abs_diff, thresh);\n            \n            if (_mm_movemask_pd(cmp) != 0) {\n                return true;\n            }\n        }\n\n        // Handle last element if odd number of elements\n        if ((n-i) % 2 == 0) {\n            double diff = std::abs(numbers[i] - numbers[n-1]);\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SSE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    const int n = numbers.size();\n    const __m128d thresh = _mm_set1_pd(threshold);\n\n    for (int i = 0; i < n-1; i++) {\n        __m128d v1 = _mm_set1_pd(numbers[i]);\n        \n        for (int j = i+1; j < n-1; j+=2) {\n            __m128d v2 = _mm_loadu_pd(&numbers[j]);\n            __m128d diff = _mm_sub_pd(v1, v2);\n            __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n            __m128d cmp = _mm_cmplt_pd(abs_diff, thresh);\n            \n            if (_mm_movemask_pd(cmp)) {\n                return true;\n            }\n        }\n\n        // Handle last element if odd number of elements\n        if ((n-i) % 2 == 0) {\n            double diff = std::abs(numbers[i] - numbers[n-1]);\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    size_t size = operations.size();\n    size_t vectorSize = (size + 3) / 4 * 4;\n    \n    std::vector<int> padded(vectorSize, 0);\n    std::copy(operations.begin(), operations.end(), padded.begin());\n\n    __m128i sum = _mm_setzero_si128();\n    __m128i zero = _mm_setzero_si128();\n\n    for (size_t i = 0; i < vectorSize; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&padded[i]);\n        sum = _mm_add_epi32(sum, curr);\n        \n        __m128i cmp = _mm_cmplt_epi32(sum, zero);\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask != 0) {\n            return true;\n        }\n\n        __m128i shuffle1 = _mm_shuffle_epi32(sum, _MM_SHUFFLE(2, 1, 0, 3));\n        __m128i shuffle2 = _mm_shuffle_epi32(sum, _MM_SHUFFLE(1, 0, 3, 2)); \n        __m128i shuffle3 = _mm_shuffle_epi32(sum, _MM_SHUFFLE(0, 3, 2, 1));\n        \n        sum = _mm_add_epi32(sum, shuffle1);\n        sum = _mm_add_epi32(sum, shuffle2);\n        sum = _mm_add_epi32(sum, shuffle3);\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    size_t size = operations.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i zero = _mm_setzero_si128();\n    int running_sum = 0;\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        sum = _mm_add_epi32(sum, ops);\n        \n        __m128i prefix_sums = _mm_add_epi32(\n            _mm_shuffle_epi32(sum, _MM_SHUFFLE(0,0,0,0)),\n            _mm_set_epi32(running_sum, running_sum, running_sum, running_sum)\n        );\n        \n        if (_mm_movemask_ps(_mm_castsi128_ps(_mm_cmplt_epi32(prefix_sums, zero)))) {\n            return true;\n        }\n        \n        running_sum = _mm_cvtsi128_si32(_mm_shuffle_epi32(sum, _MM_SHUFFLE(3,3,3,3)));\n    }\n    \n    for (size_t i = simd_size; i < size; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    size_t size = operations.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i zero = _mm_setzero_si128();\n    int running_sum = 0;\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        sum = _mm_add_epi32(sum, ops);\n        \n        __m128i prefix_sums = sum;\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_slli_si128(prefix_sums, 4));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_slli_si128(prefix_sums, 8));\n        \n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_set1_epi32(running_sum));\n        \n        __m128i cmp = _mm_cmplt_epi32(prefix_sums, zero);\n        \n        if (_mm_movemask_epi8(cmp)) {\n            return true;\n        }\n        \n        running_sum += operations[i] + operations[i+1] + operations[i+2] + operations[i+3];\n    }\n\n    for (size_t i = simd_size; i < size; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    size_t size = operations.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i zero = _mm_setzero_si128();\n    int running_sum = 0;\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        sum = _mm_add_epi32(sum, ops);\n        \n        __m128i prefix_sums = _mm_setzero_si128();\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(0,0,0,0)));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(1,1,1,1)));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(2,2,2,2)));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(3,3,3,3)));\n        \n        __m128i cmp = _mm_cmplt_epi32(prefix_sums, zero);\n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0) {\n            return true;\n        }\n        \n        running_sum = _mm_cvtsi128_si32(_mm_shuffle_epi32(sum, _MM_SHUFFLE(3,3,3,3)));\n    }\n    \n    for (size_t i = simd_size; i < size; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SSE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) {\n        return false;\n    }\n\n    size_t size = operations.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i zero = _mm_setzero_si128();\n    int running_sum = 0;\n\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i ops = _mm_loadu_si128((__m128i*)&operations[i]);\n        sum = _mm_add_epi32(sum, ops);\n        \n        __m128i prefix_sums = _mm_setzero_si128();\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(0,0,0,0)));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(1,1,1,1)));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(2,2,2,2)));\n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_shuffle_epi32(sum, _MM_SHUFFLE(3,3,3,3)));\n        \n        prefix_sums = _mm_add_epi32(prefix_sums, _mm_set1_epi32(running_sum));\n        \n        if (_mm_movemask_ps(_mm_castsi128_ps(_mm_cmplt_epi32(prefix_sums, zero))) != 0) {\n            return true;\n        }\n        \n        running_sum += _mm_cvtsi128_si32(_mm_shuffle_epi32(sum, _MM_SHUFFLE(3,3,3,3)));\n    }\n\n    for (size_t i = simd_size; i < size; i++) {\n        running_sum += operations[i];\n        if (running_sum < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    size_t simd_size = n - (n % 2);\n    \n    // Calculate mean\n    __m128d sum = _mm_setzero_pd();\n    for (size_t i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double mean = (_mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum)));\n    for (size_t i = simd_size; i < n; i++) {\n        mean += numbers[i];\n    }\n    mean /= n;\n    \n    // Calculate absolute deviations\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d abs_sum = _mm_setzero_pd();\n    for (size_t i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        __m128d diff = _mm_sub_pd(vals, mean_vec);\n        __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n        abs_sum = _mm_add_pd(abs_sum, abs_diff);\n    }\n    \n    double mad = (_mm_cvtsd_f64(abs_sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(abs_sum, abs_sum)));\n    for (size_t i = simd_size; i < n; i++) {\n        mad += std::fabs(numbers[i] - mean);\n    }\n    \n    return mad / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    size_t aligned_size = n - (n % 2);\n    \n    // Calculate mean\n    __m128d sum = _mm_setzero_pd();\n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    // Handle remaining elements\n    double total = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n    for (size_t i = aligned_size; i < n; i++) {\n        total += numbers[i];\n    }\n    \n    double mean = total / n;\n    \n    // Calculate absolute deviations\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d abs_sum = _mm_setzero_pd();\n    for (size_t i = 0; i < aligned_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        __m128d diff = _mm_sub_pd(vals, mean_vec);\n        // Absolute value using bitwise operations\n        __m128d abs_mask = _mm_set1_pd(-0.0);\n        __m128d abs_diff = _mm_andnot_pd(abs_mask, diff);\n        abs_sum = _mm_add_pd(abs_sum, abs_diff);\n    }\n    \n    // Sum up absolute deviations\n    double abs_total = _mm_cvtsd_f64(abs_sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(abs_sum, abs_sum));\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < n; i++) {\n        abs_total += std::fabs(numbers[i] - mean);\n    }\n    \n    return abs_total / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    size_t simd_size = n - (n % 2);\n    \n    // Calculate mean\n    __m128d sum = _mm_setzero_pd();\n    for (size_t i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    // Handle remaining elements\n    double total = _mm_cvtsd_f64(_mm_hadd_pd(sum, sum));\n    for (size_t i = simd_size; i < n; i++) {\n        total += numbers[i];\n    }\n    double mean = total / n;\n    \n    // Calculate absolute deviations\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d abs_sum = _mm_setzero_pd();\n    for (size_t i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        __m128d diff = _mm_sub_pd(vals, mean_vec);\n        __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n        abs_sum = _mm_add_pd(abs_sum, abs_diff);\n    }\n    \n    // Sum up absolute deviations\n    double abs_total = _mm_cvtsd_f64(_mm_hadd_pd(abs_sum, abs_sum));\n    for (size_t i = simd_size; i < n; i++) {\n        abs_total += std::fabs(numbers[i] - mean);\n    }\n    \n    return abs_total / n;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t size = numbers.size();\n    size_t simd_size = size - (size % 2);\n    \n    // Calculate mean\n    __m128d sum = _mm_setzero_pd();\n    size_t i;\n    \n    for (i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    double mean = (_mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum)));\n    for (; i < size; i++) {\n        mean += numbers[i];\n    }\n    mean /= size;\n    \n    // Calculate absolute deviations\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d abs_sum = _mm_setzero_pd();\n    \n    for (i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        __m128d diff = _mm_sub_pd(vals, mean_vec);\n        __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n        abs_sum = _mm_add_pd(abs_sum, abs_diff);\n    }\n    \n    double mad = (_mm_cvtsd_f64(abs_sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(abs_sum, abs_sum)));\n    \n    for (; i < size; i++) {\n        mad += std::fabs(numbers[i] - mean);\n    }\n    \n    return mad / size;\n}\n```"}
{"task_id": "SimdBench_64_SSE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    size_t simd_size = n - (n % 2);\n    \n    // Calculate mean\n    __m128d sum = _mm_setzero_pd();\n    for (size_t i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        sum = _mm_add_pd(sum, vals);\n    }\n    \n    // Handle remaining elements\n    double total = _mm_cvtsd_f64(sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(sum, sum));\n    for (size_t i = simd_size; i < n; i++) {\n        total += numbers[i];\n    }\n    double mean = total / n;\n    \n    // Calculate absolute deviations\n    __m128d mean_vec = _mm_set1_pd(mean);\n    __m128d abs_sum = _mm_setzero_pd();\n    for (size_t i = 0; i < simd_size; i += 2) {\n        __m128d vals = _mm_loadu_pd(&numbers[i]);\n        __m128d diff = _mm_sub_pd(vals, mean_vec);\n        __m128d abs_diff = _mm_andnot_pd(_mm_set1_pd(-0.0), diff);\n        abs_sum = _mm_add_pd(abs_sum, abs_diff);\n    }\n    \n    // Sum up absolute deviations\n    double abs_total = _mm_cvtsd_f64(abs_sum) + _mm_cvtsd_f64(_mm_unpackhi_pd(abs_sum, abs_sum));\n    for (size_t i = simd_size; i < n; i++) {\n        abs_total += std::fabs(numbers[i] - mean);\n    }\n    \n    return abs_total / n;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n    \n    size_t i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        result.push_back(_mm_extract_epi32(nums, 0));\n        result.push_back(delimeter);\n        result.push_back(_mm_extract_epi32(nums, 1)); \n        result.push_back(delimeter);\n        result.push_back(_mm_extract_epi32(nums, 2));\n        result.push_back(delimeter);\n        result.push_back(_mm_extract_epi32(nums, 3));\n        \n        if (i + 4 < numbers.size()) {\n            result.push_back(delimeter);\n        }\n    }\n\n    for (; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(2 * numbers.size() - 1);\n    \n    __m128i delimiter_vec = _mm_set1_epi32(delimeter);\n    \n    size_t i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        result.push_back(_mm_cvtsi128_si32(nums));\n        result.push_back(delimeter);\n        \n        nums = _mm_srli_si128(nums, 4);\n        result.push_back(_mm_cvtsi128_si32(nums));\n        result.push_back(delimeter);\n        \n        nums = _mm_srli_si128(nums, 4);\n        result.push_back(_mm_cvtsi128_si32(nums));\n        result.push_back(delimeter);\n        \n        nums = _mm_srli_si128(nums, 4);\n        result.push_back(_mm_cvtsi128_si32(nums));\n        if (i + 4 < numbers.size()) {\n            result.push_back(delimeter);\n        }\n    }\n\n    for (; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(2 * numbers.size() - 1);\n    \n    __m128i delim = _mm_set1_epi32(delimeter);\n    \n    size_t i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        result.push_back(_mm_extract_epi32(nums, 0));\n        result.push_back(delimeter);\n        result.push_back(_mm_extract_epi32(nums, 1)); \n        result.push_back(delimeter);\n        result.push_back(_mm_extract_epi32(nums, 2));\n        result.push_back(delimeter);\n        result.push_back(_mm_extract_epi32(nums, 3));\n        \n        if (i + 4 < numbers.size()) {\n            result.push_back(delimeter);\n        }\n    }\n\n    for (; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(2 * numbers.size() - 1);\n    \n    __m128i delim = _mm_set1_epi32(delimeter);\n    \n    size_t i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Store first number\n        result.push_back(_mm_cvtsi128_si32(nums));\n        \n        // Store delimiter\n        result.push_back(delimeter);\n        \n        // Store second number\n        result.push_back(_mm_extract_epi32(nums, 1));\n        \n        // Store delimiter\n        result.push_back(delimeter);\n        \n        // Store third number\n        result.push_back(_mm_extract_epi32(nums, 2));\n        \n        // Store delimiter\n        result.push_back(delimeter);\n        \n        // Store fourth number\n        result.push_back(_mm_extract_epi32(nums, 3));\n        \n        if (i + 4 < numbers.size()) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SSE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(2 * numbers.size() - 1);\n    \n    __m128i delim = _mm_set1_epi32(delimeter);\n    \n    size_t i;\n    for (i = 0; i + 4 <= numbers.size(); i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n        \n        // Unpack and interleave with delimiter\n        __m128i lo = _mm_unpacklo_epi32(nums, delim);\n        __m128i hi = _mm_unpackhi_epi32(nums, delim);\n        \n        // Store interleaved results\n        int temp[8];\n        _mm_storeu_si128((__m128i*)&temp[0], lo);\n        _mm_storeu_si128((__m128i*)&temp[4], hi);\n        \n        // Add to result vector\n        result.push_back(temp[0]); // number\n        result.push_back(temp[1]); // delimiter\n        result.push_back(temp[2]); // number\n        result.push_back(temp[3]); // delimiter\n        result.push_back(temp[4]); // number\n        result.push_back(temp[5]); // delimiter\n        result.push_back(temp[6]); // number\n        if (i + 4 < numbers.size()) {\n            result.push_back(temp[7]); // delimiter\n        }\n    }\n\n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    __m128i sum = _mm_setzero_si128();\n    __m128i prod = _mm_set1_epi16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&numbers[i + 4]);\n        \n        sum = _mm_add_epi16(sum, a);\n        sum = _mm_add_epi16(sum, b);\n        \n        prod = _mm_mullo_epi16(prod, a);\n        prod = _mm_mullo_epi16(prod, b);\n    }\n\n    int16_t sums[8];\n    int16_t products[8];\n    _mm_storeu_si128((__m128i*)sums, sum);\n    _mm_storeu_si128((__m128i*)products, prod);\n    \n    int64_t final_sum = sums[0] + sums[1] + sums[2] + sums[3] + \n                        sums[4] + sums[5] + sums[6] + sums[7];\n    int64_t final_product = products[0] * products[1] * products[2] * products[3] *\n                           products[4] * products[5] * products[6] * products[7];\n\n    for (; i < numbers.size(); i++) {\n        final_sum += numbers[i];\n        final_product *= numbers[i];\n    }\n\n    return {final_sum, final_product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    __m128i sum = _mm_setzero_si128();\n    __m128i prod = _mm_set1_epi16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&numbers[i + 4]);\n        \n        sum = _mm_add_epi16(sum, a);\n        sum = _mm_add_epi16(sum, b);\n        \n        prod = _mm_mullo_epi16(prod, a);\n        prod = _mm_mullo_epi16(prod, b);\n    }\n\n    int16_t sum_arr[8];\n    int16_t prod_arr[8];\n    _mm_storeu_si128((__m128i*)sum_arr, sum);\n    _mm_storeu_si128((__m128i*)prod_arr, prod);\n\n    int64_t final_sum = 0;\n    int64_t final_prod = 1;\n\n    for (int j = 0; j < 8; j++) {\n        final_sum += sum_arr[j];\n        final_prod *= prod_arr[j];\n    }\n\n    for (; i < numbers.size(); i++) {\n        final_sum += numbers[i];\n        final_prod *= numbers[i];\n    }\n\n    return {final_sum, final_prod};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    __m128i sum = _mm_setzero_si128();\n    __m128i prod = _mm_set1_epi16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&numbers[i + 4]);\n        \n        sum = _mm_add_epi16(sum, a);\n        sum = _mm_add_epi16(sum, b);\n        \n        prod = _mm_mullo_epi16(prod, a);\n        prod = _mm_mullo_epi16(prod, b);\n    }\n\n    int16_t sums[8];\n    int16_t products[8];\n    _mm_storeu_si128((__m128i*)sums, sum);\n    _mm_storeu_si128((__m128i*)products, prod);\n    \n    int64_t final_sum = sums[0] + sums[1] + sums[2] + sums[3] + \n                        sums[4] + sums[5] + sums[6] + sums[7];\n    int64_t final_product = products[0] * products[1] * products[2] * products[3] *\n                           products[4] * products[5] * products[6] * products[7];\n\n    for (; i < numbers.size(); i++) {\n        final_sum += numbers[i];\n        final_product *= numbers[i];\n    }\n\n    return {final_sum, final_product};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    __m128i sum = _mm_setzero_si128();\n    __m128i prod = _mm_set1_epi16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&numbers[i + 4]);\n        \n        sum = _mm_add_epi16(sum, a);\n        sum = _mm_add_epi16(sum, b);\n        \n        prod = _mm_mullo_epi16(prod, a);\n        prod = _mm_mullo_epi16(prod, b);\n    }\n\n    int16_t sums[8];\n    int16_t products[8];\n    _mm_storeu_si128((__m128i*)sums, sum);\n    _mm_storeu_si128((__m128i*)products, prod);\n    \n    int64_t final_sum = sums[0] + sums[1] + sums[2] + sums[3] + \n                        sums[4] + sums[5] + sums[6] + sums[7];\n    int64_t final_prod = products[0] * products[1] * products[2] * products[3] *\n                         products[4] * products[5] * products[6] * products[7];\n\n    for (; i < numbers.size(); i++) {\n        final_sum += numbers[i];\n        final_prod *= numbers[i];\n    }\n\n    return {final_sum, final_prod};\n}\n```"}
{"task_id": "SimdBench_66_SSE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    __m128i sum = _mm_setzero_si128();\n    __m128i prod = _mm_set1_epi16(1);\n    \n    size_t i;\n    for (i = 0; i + 8 <= numbers.size(); i += 8) {\n        __m128i a = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i b = _mm_loadu_si128((__m128i*)&numbers[i + 4]);\n        \n        sum = _mm_add_epi16(sum, a);\n        sum = _mm_add_epi16(sum, b);\n        \n        prod = _mm_mullo_epi16(prod, a);\n        prod = _mm_mullo_epi16(prod, b);\n    }\n\n    int16_t sums[8];\n    int16_t products[8];\n    _mm_storeu_si128((__m128i*)sums, sum);\n    _mm_storeu_si128((__m128i*)products, prod);\n    \n    int64_t final_sum = sums[0] + sums[1] + sums[2] + sums[3] + \n                        sums[4] + sums[5] + sums[6] + sums[7];\n    int64_t final_product = products[0] * products[1] * products[2] * products[3] *\n                           products[4] * products[5] * products[6] * products[7];\n\n    for (; i < numbers.size(); i++) {\n        final_sum += numbers[i];\n        final_product *= numbers[i];\n    }\n\n    return {final_sum, final_product};\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    result[0] = numbers[0];\n    \n    int i = 1;\n    // Process 4 elements at a time using SSE\n    for (; i + 4 <= numbers.size(); i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i prev = _mm_set1_epi32(result[i-1]);\n        \n        // Compare each element with previous max\n        __m128i max1 = _mm_max_epi32(curr, prev);\n        \n        // Compare adjacent pairs\n        __m128i shift1 = _mm_slli_si128(max1, 4);\n        __m128i max2 = _mm_max_epi32(max1, shift1);\n        \n        // Compare adjacent quads\n        __m128i shift2 = _mm_slli_si128(max2, 8);\n        __m128i max3 = _mm_max_epi32(max2, shift2);\n        \n        _mm_storeu_si128((__m128i*)&result[i], max3);\n    }\n    \n    // Handle remaining elements\n    for (; i < numbers.size(); i++) {\n        result[i] = std::max(numbers[i], result[i-1]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    const size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    // Process 4 elements at a time using SSE\n    const size_t simd_size = 4;\n    size_t i = 1;\n    \n    if (n >= simd_size) {\n        __m128i current_max = _mm_set1_epi32(numbers[0]);\n        \n        for (; i + simd_size <= n; i += simd_size) {\n            // Load next 4 integers\n            __m128i data = _mm_loadu_si128((__m128i*)&numbers[i]);\n            \n            // Compare with current max and update\n            current_max = _mm_max_epi32(current_max, data);\n            \n            // Store result\n            _mm_storeu_si128((__m128i*)&result[i], current_max);\n        }\n    }\n    \n    // Handle remaining elements\n    int current_max = result[i-1];\n    for (; i < n; i++) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) return numbers;\n    \n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n    \n    // Process 4 elements at a time using SSE\n    size_t i = 1;\n    if (n >= 4) {\n        __m128i curr_max = _mm_set1_epi32(numbers[0]);\n        \n        for (; i <= n-4; i += 4) {\n            __m128i curr_nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n            curr_max = _mm_max_epi32(curr_max, curr_nums);\n            _mm_storeu_si128((__m128i*)&result[i], curr_max);\n        }\n    }\n    \n    // Handle remaining elements\n    int running_max = result[i-1];\n    for (; i < n; i++) {\n        running_max = std::max(running_max, numbers[i]);\n        result[i] = running_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    const size_t n = numbers.size();\n    std::vector<int> result(n);\n    result[0] = numbers[0];\n\n    // Process 4 elements at a time using SSE\n    const size_t simd_size = 4;\n    size_t i = 1;\n\n    if (n >= simd_size) {\n        __m128i current_max = _mm_set1_epi32(numbers[0]);\n\n        for (; i + simd_size <= n; i += simd_size) {\n            __m128i nums = _mm_loadu_si128((__m128i*)&numbers[i]);\n            current_max = _mm_max_epi32(current_max, nums);\n            _mm_storeu_si128((__m128i*)&result[i], current_max);\n        }\n    }\n\n    // Handle remaining elements\n    int current_max = result[i-1];\n    for (; i < n; ++i) {\n        current_max = std::max(current_max, numbers[i]);\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SSE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    result[0] = numbers[0];\n    \n    int i = 1;\n    for (; i + 3 < numbers.size(); i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&numbers[i]);\n        __m128i prev = _mm_loadu_si128((__m128i*)&result[i-1]);\n        \n        // Shift right to align with previous max\n        __m128i shifted = _mm_shuffle_epi32(prev, _MM_SHUFFLE(3,3,3,3));\n        \n        // Compare and get max between current and previous shifted\n        __m128i max1 = _mm_max_epi32(curr, shifted);\n        \n        // Get running max by comparing with shifted versions\n        shifted = _mm_shuffle_epi32(max1, _MM_SHUFFLE(2,2,1,0));\n        __m128i max2 = _mm_max_epi32(max1, shifted);\n        \n        shifted = _mm_shuffle_epi32(max2, _MM_SHUFFLE(1,1,1,0)); \n        __m128i max3 = _mm_max_epi32(max2, shifted);\n        \n        _mm_storeu_si128((__m128i*)&result[i], max3);\n    }\n    \n    // Handle remaining elements\n    int curr_max = result[i-1];\n    for (; i < numbers.size(); i++) {\n        curr_max = std::max(curr_max, numbers[i]);\n        result[i] = curr_max;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)(a.data() + i));\n        __m128i vb = _mm_loadu_si128((__m128i*)(b.data() + i));\n        \n        __m128i vxor = _mm_xor_si128(va, vb);\n        _mm_storeu_si128((__m128i*)(result.data() + i), vxor);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)(a.data() + i));\n        __m128i vb = _mm_loadu_si128((__m128i*)(b.data() + i));\n        __m128i vxor = _mm_xor_si128(va, vb);\n        _mm_storeu_si128((__m128i*)(result.data() + i), vxor);\n    }\n    \n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)(a.data() + i));\n        __m128i vb = _mm_loadu_si128((__m128i*)(b.data() + i));\n        __m128i vxor = _mm_xor_si128(va, vb);\n        _mm_storeu_si128((__m128i*)(result.data() + i), vxor);\n    }\n    \n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)&a[i]);\n        __m128i vb = _mm_loadu_si128((__m128i*)&b[i]);\n        __m128i vxor = _mm_xor_si128(va, vb);\n        _mm_storeu_si128((__m128i*)&result[i], vxor);\n    }\n    \n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SSE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        __m128i va = _mm_loadu_si128((__m128i*)(a.data() + i));\n        __m128i vb = _mm_loadu_si128((__m128i*)(b.data() + i));\n        __m128i vxor = _mm_xor_si128(va, vb);\n        _mm_storeu_si128((__m128i*)(result.data() + i), vxor);\n    }\n    \n    for (; i < len; i++) {\n        result[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time\n    size_t vec_size = strings.size();\n    size_t i;\n    for (i = 0; i + 4 <= vec_size; i += 4) {\n        __m128i lengths = _mm_setr_epi32(\n            strings[i].length(),\n            strings[i+1].length(), \n            strings[i+2].length(),\n            strings[i+3].length()\n        );\n        \n        // Find max of 4 lengths\n        __m128i max_vec = lengths;\n        __m128i shuffle = _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(2,3,0,1));\n        max_vec = _mm_max_epi32(max_vec, shuffle);\n        shuffle = _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(1,0,3,2)); \n        max_vec = _mm_max_epi32(max_vec, shuffle);\n        \n        int curr_max = _mm_cvtsi128_si32(max_vec);\n        \n        if (curr_max > max_len) {\n            // Find index of max length\n            for (size_t j = 0; j < 4; j++) {\n                if (strings[i+j].length() == curr_max) {\n                    max_len = curr_max;\n                    max_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < vec_size; i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 lengths at a time using SSE\n    const size_t vec_size = strings.size();\n    const size_t vec_step = 4;\n    const size_t vec_end = vec_size - (vec_size % vec_step);\n    \n    for (size_t i = 0; i < vec_end; i += vec_step) {\n        __m128i lengths = _mm_setr_epi32(\n            strings[i].length(),\n            strings[i+1].length(), \n            strings[i+2].length(),\n            strings[i+3].length()\n        );\n        \n        // Find max of 4 lengths\n        __m128i max_vec = lengths;\n        __m128i shuffle = _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(2,3,0,1));\n        max_vec = _mm_max_epi32(max_vec, shuffle);\n        shuffle = _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(1,0,3,2)); \n        max_vec = _mm_max_epi32(max_vec, shuffle);\n        \n        int curr_max = _mm_cvtsi128_si32(max_vec);\n        \n        if (curr_max > max_len) {\n            // Find index of max length\n            for (size_t j = 0; j < vec_step; j++) {\n                if (strings[i+j].length() == curr_max) {\n                    max_len = curr_max;\n                    max_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = vec_end; i < vec_size; i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time using SSE\n    for (size_t i = 0; i < strings.size() - 4; i += 4) {\n        __m128i lengths = _mm_setr_epi32(\n            strings[i].length(),\n            strings[i+1].length(), \n            strings[i+2].length(),\n            strings[i+3].length()\n        );\n        \n        // Find max of 4 lengths\n        __m128i max = lengths;\n        __m128i shuffle = _mm_shuffle_epi32(max, _MM_SHUFFLE(2,3,0,1));\n        max = _mm_max_epi32(max, shuffle);\n        shuffle = _mm_shuffle_epi32(max, _MM_SHUFFLE(1,0,3,2)); \n        max = _mm_max_epi32(max, shuffle);\n        \n        int curr_max = _mm_cvtsi128_si32(max);\n        \n        if (curr_max > max_len) {\n            // Find index of max length\n            for (size_t j = 0; j < 4; j++) {\n                if (strings[i+j].length() == curr_max) {\n                    max_len = curr_max;\n                    max_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (strings.size()/4)*4; i < strings.size(); i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 8 lengths at a time using SSE\n    const size_t vec_size = strings.size();\n    const size_t vec_step = 8;\n    size_t i;\n    \n    for (i = 0; i + vec_step <= vec_size; i += vec_step) {\n        __m128i len1 = _mm_set_epi16(strings[i+7].length(), \n                                    strings[i+6].length(),\n                                    strings[i+5].length(),\n                                    strings[i+4].length(),\n                                    strings[i+3].length(),\n                                    strings[i+2].length(), \n                                    strings[i+1].length(),\n                                    strings[i].length());\n                                    \n        // Find max of 8 lengths\n        __m128i max1 = len1;\n        __m128i shuffle1 = _mm_shuffle_epi32(max1, _MM_SHUFFLE(3,2,3,2));\n        max1 = _mm_max_epi16(max1, shuffle1);\n        shuffle1 = _mm_shufflelo_epi16(max1, _MM_SHUFFLE(3,2,3,2));\n        max1 = _mm_max_epi16(max1, shuffle1);\n        shuffle1 = _mm_shufflelo_epi16(max1, _MM_SHUFFLE(1,1,1,1)); \n        max1 = _mm_max_epi16(max1, shuffle1);\n        \n        int curr_max = _mm_extract_epi16(max1, 0);\n        \n        if (curr_max > max_len) {\n            // Find index of max length\n            for(size_t j = 0; j < vec_step; j++) {\n                if (strings[i+j].length() == curr_max) {\n                    max_len = curr_max;\n                    max_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < vec_size; i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SSE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    \n    // Process 4 strings at a time using SSE\n    size_t vec_size = strings.size();\n    size_t i;\n    for (i = 0; i + 4 <= vec_size; i += 4) {\n        __m128i lengths = _mm_setr_epi32(\n            strings[i].length(),\n            strings[i+1].length(), \n            strings[i+2].length(),\n            strings[i+3].length()\n        );\n        \n        // Find max of 4 lengths\n        __m128i max_vec = lengths;\n        __m128i shuffle = _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(2,3,0,1));\n        max_vec = _mm_max_epi32(max_vec, shuffle);\n        shuffle = _mm_shuffle_epi32(max_vec, _MM_SHUFFLE(1,0,3,2)); \n        max_vec = _mm_max_epi32(max_vec, shuffle);\n        \n        int curr_max = _mm_cvtsi128_si32(max_vec);\n        \n        if (curr_max > max_len) {\n            // Find index of max length\n            for (size_t j = 0; j < 4; j++) {\n                if (strings[i+j].length() == curr_max) {\n                    max_len = curr_max;\n                    max_idx = i+j;\n                    break;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < vec_size; i++) {\n        if (strings[i].length() > max_len) {\n            max_len = strings[i].length();\n            max_idx = i;\n        }\n    }\n    \n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set_epi64x(0, a);\n    __m128i vb = _mm_set_epi64x(0, b);\n    \n    while (1) {\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(vb, zero);\n        \n        if (_mm_movemask_epi8(mask) & 0x00FF)\n            return _mm_cvtsi128_si64(va);\n            \n        __m128i temp = va;\n        va = vb;\n        __m128i vdiv = _mm_div_epu64(temp, vb);\n        __m128i vmul = _mm_mul_epu32(vdiv, vb);\n        vb = _mm_sub_epi64(temp, vmul);\n    }\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set_epi64x(0, a);\n    __m128i vb = _mm_set_epi64x(0, b);\n    \n    while (1) {\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(vb, zero);\n        \n        if (_mm_extract_epi64(mask, 0))\n            return _mm_extract_epi64(va, 0);\n            \n        __m128i temp = va;\n        va = vb;\n        \n        __m128i quotient = _mm_div_epi64(temp, vb);\n        __m128i product = _mm_mul_epi32(quotient, vb);\n        vb = _mm_sub_epi64(temp, product);\n    }\n    \n    return _mm_extract_epi64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set_epi64x(0, a);\n    __m128i vb = _mm_set_epi64x(0, b);\n    \n    while (1) {\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(vb, zero);\n        \n        if (_mm_extract_epi64(mask, 0))\n            return _mm_extract_epi64(va, 0);\n            \n        __m128i temp = va;\n        va = vb;\n        __m128i vmod = _mm_div_epi64(temp, vb);\n        vmod = _mm_mul_epi32(vb, vmod);\n        vb = _mm_sub_epi64(temp, vmod);\n    }\n    \n    return _mm_extract_epi64(va, 0);\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set_epi64x(0, a);\n    __m128i vb = _mm_set_epi64x(0, b);\n    \n    while (1) {\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(vb, zero);\n        \n        if (_mm_extract_epi64(mask, 0))\n            return _mm_extract_epi64(va, 0);\n            \n        __m128i temp = va;\n        va = vb;\n        \n        __m128i quotient = _mm_div_epi64(temp, vb);\n        __m128i product = _mm_mul_epi32(quotient, vb);\n        vb = _mm_sub_epi64(temp, product);\n    }\n}\n```"}
{"task_id": "SimdBench_70_SSE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    __m128i va = _mm_set_epi64x(0, a);\n    __m128i vb = _mm_set_epi64x(0, b);\n    \n    while (1) {\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi64(vb, zero);\n        \n        if (_mm_extract_epi64(mask, 0))\n            return _mm_extract_epi64(va, 0);\n            \n        __m128i temp = va;\n        va = vb;\n        \n        __m128i quotient = _mm_div_epi64(temp, vb);\n        __m128i product = _mm_mul_epi32(quotient, vb);\n        vb = _mm_sub_epi64(temp, product);\n    }\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    const size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    // Pad vector size to multiple of 4 for SSE\n    while (numbers.size() % 4 != 0) {\n        numbers.push_back(std::numeric_limits<float>::max());\n    }\n\n    for (size_t i = 0; i < n; i++) {\n        __m128 v1 = _mm_set1_ps(numbers[i]);\n        \n        for (size_t j = 0; j < numbers.size(); j += 4) {\n            if (i != j) {\n                __m128 v2 = _mm_load_ps(&numbers[j]);\n                __m128 diff = _mm_sub_ps(v1, v2);\n                __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n                \n                float diffs[4];\n                _mm_store_ps(diffs, abs_diff);\n                \n                for (int k = 0; k < 4; k++) {\n                    if (j + k < n && i != j + k && diffs[k] < min_diff) {\n                        min_diff = diffs[k];\n                        if (numbers[i] <= numbers[j + k]) {\n                            num1 = numbers[i];\n                            num2 = numbers[j + k];\n                        } else {\n                            num1 = numbers[j + k];\n                            num2 = numbers[i];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    for (size_t i = 0; i < n - 4; i += 4) {\n        __m128 v1 = _mm_loadu_ps(&numbers[i]);\n        \n        for (size_t j = i + 1; j < n - 3; j += 4) {\n            __m128 v2 = _mm_loadu_ps(&numbers[j]);\n            \n            // Calculate absolute differences between vectors\n            __m128 diff = _mm_sub_ps(v1, v2);\n            diff = _mm_abs_ps(diff);\n            \n            // Find minimum difference in the vector\n            float diffs[4];\n            _mm_storeu_ps(diffs, diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (diffs[k] < min_diff) {\n                    min_diff = diffs[k];\n                    num1 = std::min(numbers[i+k], numbers[j+k]);\n                    num2 = std::max(numbers[i+k], numbers[j+k]);\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = 0; i < n; i++) {\n        for (size_t j = i + 1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                num1 = std::min(numbers[i], numbers[j]);\n                num2 = std::max(numbers[i], numbers[j]);\n            }\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < n-3; i += 4) {\n        __m128 v1 = _mm_loadu_ps(&numbers[i]);\n        \n        for (size_t j = i+1; j < n; j++) {\n            __m128 v2 = _mm_set1_ps(numbers[j]);\n            __m128 diff = _mm_sub_ps(v1, v2);\n            diff = _mm_abs_ps(diff);\n            \n            float diffs[4];\n            _mm_storeu_ps(diffs, diff);\n            \n            for(int k = 0; k < 4; k++) {\n                if (diffs[k] < min_diff && i+k != j) {\n                    min_diff = diffs[k];\n                    if (numbers[i+k] <= numbers[j]) {\n                        num1 = numbers[i+k];\n                        num2 = numbers[j];\n                    } else {\n                        num1 = numbers[j];\n                        num2 = numbers[i+k];\n                    }\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (n/4)*4; i < n; i++) {\n        for (size_t j = i+1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                if (numbers[i] <= numbers[j]) {\n                    num1 = numbers[i];\n                    num2 = numbers[j];\n                } else {\n                    num1 = numbers[j];\n                    num2 = numbers[i];\n                }\n            }\n        }\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    // Process 4 elements at a time\n    for (size_t i = 0; i < n-3; i += 4) {\n        __m128 v1 = _mm_loadu_ps(&numbers[i]);\n        \n        for (size_t j = i+1; j < n; j++) {\n            __m128 v2 = _mm_set1_ps(numbers[j]);\n            __m128 diff = _mm_sub_ps(v1, v2);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n            \n            float diffs[4];\n            _mm_storeu_ps(diffs, abs_diff);\n            \n            for (int k = 0; k < 4; k++) {\n                if (i+k != j && diffs[k] < min_diff) {\n                    min_diff = diffs[k];\n                    if (numbers[i+k] <= numbers[j]) {\n                        num1 = numbers[i+k];\n                        num2 = numbers[j];\n                    } else {\n                        num1 = numbers[j];\n                        num2 = numbers[i+k];\n                    }\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (n/4)*4; i < n; i++) {\n        for (size_t j = i+1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                if (numbers[i] <= numbers[j]) {\n                    num1 = numbers[i];\n                    num2 = numbers[j];\n                } else {\n                    num1 = numbers[j];\n                    num2 = numbers[i];\n                }\n            }\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SSE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n\n    // Process 4 elements at a time using SSE\n    for (size_t i = 0; i < n-3; i += 4) {\n        __m128 v1 = _mm_loadu_ps(&numbers[i]);\n        \n        for (size_t j = i+1; j < n; j++) {\n            __m128 v2 = _mm_set1_ps(numbers[j]);\n            __m128 diff = _mm_sub_ps(v1, v2);\n            __m128 abs_diff = _mm_and_ps(diff, _mm_castsi128_ps(_mm_set1_epi32(0x7FFFFFFF)));\n            \n            float diffs[4];\n            _mm_storeu_ps(diffs, abs_diff);\n            \n            for(int k = 0; k < 4; k++) {\n                if (diffs[k] < min_diff && i+k != j) {\n                    min_diff = diffs[k];\n                    if (numbers[i+k] <= numbers[j]) {\n                        num1 = numbers[i+k];\n                        num2 = numbers[j];\n                    } else {\n                        num1 = numbers[j];\n                        num2 = numbers[i+k];\n                    }\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = (n/4)*4; i < n; i++) {\n        for (size_t j = i+1; j < n; j++) {\n            float diff = std::abs(numbers[i] - numbers[j]);\n            if (diff < min_diff) {\n                min_diff = diff;\n                if (numbers[i] <= numbers[j]) {\n                    num1 = numbers[i];\n                    num2 = numbers[j];\n                } else {\n                    num1 = numbers[j];\n                    num2 = numbers[i];\n                }\n            }\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using SIMD\n    __m128 vmin = _mm_set1_ps(numbers[0]);\n    __m128 vmax = _mm_set1_ps(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        vmin = _mm_min_ps(vmin, v);\n        vmax = _mm_max_ps(vmax, v);\n    }\n\n    // Horizontal min/max\n    float min_vals[4], max_vals[4];\n    _mm_storeu_ps(min_vals, vmin);\n    _mm_storeu_ps(max_vals, vmax);\n    \n    float min_val = min_vals[0];\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; j++) {\n        min_val = std::min(min_val, min_vals[j]);\n        max_val = std::max(max_val, max_vals[j]);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n\n    // Scale vector using SIMD\n    __m128 vrange = _mm_set1_ps(range);\n    __m128 vmin_val = _mm_set1_ps(min_val);\n    \n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        v = _mm_sub_ps(v, vmin_val);\n        v = _mm_div_ps(v, vrange);\n        _mm_storeu_ps(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using SIMD\n    __m128 vmin = _mm_set1_ps(numbers[0]);\n    __m128 vmax = _mm_set1_ps(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        vmin = _mm_min_ps(vmin, v);\n        vmax = _mm_max_ps(vmax, v);\n    }\n\n    // Horizontal min/max\n    float min_vals[4], max_vals[4];\n    _mm_storeu_ps(min_vals, vmin);\n    _mm_storeu_ps(max_vals, vmax);\n    \n    float min_val = min_vals[0];\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; j++) {\n        min_val = std::min(min_val, min_vals[j]);\n        max_val = std::max(max_val, max_vals[j]);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n\n    // Scale values using SIMD\n    __m128 vrange = _mm_set1_ps(range);\n    __m128 vmin_val = _mm_set1_ps(min_val);\n    \n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        v = _mm_sub_ps(v, vmin_val);\n        v = _mm_div_ps(v, vrange);\n        _mm_storeu_ps(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n    \n    size_t n = numbers.size();\n    size_t simd_size = n - (n % 4);\n    \n    // Find min/max using SIMD\n    __m128 vmin = _mm_set1_ps(numbers[0]);\n    __m128 vmax = _mm_set1_ps(numbers[0]);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        vmin = _mm_min_ps(vmin, v);\n        vmax = _mm_max_ps(vmax, v);\n    }\n    \n    // Horizontal min/max\n    float min_vals[4], max_vals[4];\n    _mm_storeu_ps(min_vals, vmin);\n    _mm_storeu_ps(max_vals, vmax);\n    \n    float min_val = min_vals[0];\n    float max_val = max_vals[0];\n    \n    for (int i = 1; i < 4; i++) {\n        min_val = std::min(min_val, min_vals[i]);\n        max_val = std::max(max_val, max_vals[i]);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_size; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n    \n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n    \n    // Scale factor\n    __m128 vrange = _mm_set1_ps(range);\n    __m128 vmin_val = _mm_set1_ps(min_val);\n    \n    // Transform values using SIMD\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        v = _mm_sub_ps(v, vmin_val);\n        v = _mm_div_ps(v, vrange);\n        _mm_storeu_ps(&numbers[i], v);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_size; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using SIMD\n    __m128 vmin = _mm_set1_ps(numbers[0]);\n    __m128 vmax = _mm_set1_ps(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        vmin = _mm_min_ps(vmin, v);\n        vmax = _mm_max_ps(vmax, v);\n    }\n\n    // Horizontal min/max\n    float min_vals[4], max_vals[4];\n    _mm_storeu_ps(min_vals, vmin);\n    _mm_storeu_ps(max_vals, vmax);\n    \n    float min_val = min_vals[0];\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; j++) {\n        min_val = std::min(min_val, min_vals[j]);\n        max_val = std::max(max_val, max_vals[j]);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n\n    // Scale vector using SIMD\n    __m128 vrange = _mm_set1_ps(range);\n    __m128 vmin_val = _mm_set1_ps(min_val);\n    \n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        v = _mm_sub_ps(v, vmin_val);\n        v = _mm_div_ps(v, vrange);\n        _mm_storeu_ps(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SSE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) return numbers;\n\n    // Find min/max using SIMD\n    __m128 vmin = _mm_set1_ps(numbers[0]);\n    __m128 vmax = _mm_set1_ps(numbers[0]);\n    \n    size_t i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        vmin = _mm_min_ps(vmin, v);\n        vmax = _mm_max_ps(vmax, v);\n    }\n\n    // Horizontal min/max\n    float min_vals[4], max_vals[4];\n    _mm_storeu_ps(min_vals, vmin);\n    _mm_storeu_ps(max_vals, vmax);\n    \n    float min_val = min_vals[0];\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; j++) {\n        min_val = std::min(min_val, min_vals[j]);\n        max_val = std::max(max_val, max_vals[j]);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        min_val = std::min(min_val, numbers[i]);\n        max_val = std::max(max_val, numbers[i]);\n    }\n\n    float range = max_val - min_val;\n    if (range == 0) return std::vector<float>(n, 0);\n\n    // Scale vector using SIMD\n    __m128 vrange = _mm_set1_ps(range);\n    __m128 vmin_val = _mm_set1_ps(min_val);\n    \n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128 v = _mm_loadu_ps(&numbers[i]);\n        v = _mm_sub_ps(v, vmin_val);\n        v = _mm_div_ps(v, vrange);\n        _mm_storeu_ps(&numbers[i], v);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        numbers[i] = (numbers[i] - min_val) / range;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i result = _mm_setzero_si128();\n    \n    uint32_t limit = sqrt(n);\n    \n    for (uint32_t i = 1; i <= limit; i += 4) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i mask = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n        \n        if (_mm_movemask_epi8(mask)) {\n            for (int j = 3; j >= 0; j--) {\n                uint32_t div = ((uint32_t*)&divisors)[j];\n                if (div <= limit && n % div == 0) {\n                    uint64_t quotient = n / div;\n                    if (quotient > div) {\n                        return quotient;\n                    }\n                    return div;\n                }\n            }\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i result = _mm_set1_epi32(1);\n    \n    uint32_t limit = sqrt(n);\n    \n    for (uint32_t i = 1; i <= limit/4 + 1; i++) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i mask = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n        \n        if (_mm_movemask_epi8(mask)) {\n            int32_t values[4];\n            _mm_store_si128((__m128i*)values, divisors);\n            \n            for (int j = 3; j >= 0; j--) {\n                if (n % values[j] == 0 && values[j] <= limit) {\n                    return n / values[j];\n                }\n            }\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    for (uint64_t i = limit; i >= 1; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(1,2,3,4);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i max_divisor = _mm_set1_epi32(1);\n    __m128i zero = _mm_setzero_si128();\n    \n    uint32_t sqrt_n = sqrt(n);\n    \n    while (_mm_cvtsi128_si32(divisors) <= sqrt_n) {\n        __m128i quotient = _mm_div_epi32(num, divisors);\n        __m128i remainder = _mm_sub_epi32(num, _mm_mul_epi32(quotient, divisors));\n        \n        __m128i is_divisor = _mm_cmpeq_epi32(remainder, zero);\n        \n        if (_mm_movemask_epi8(is_divisor)) {\n            max_divisor = _mm_max_epi32(max_divisor, \n                                      _mm_and_si128(divisors, is_divisor));\n            max_divisor = _mm_max_epi32(max_divisor,\n                                      _mm_and_si128(quotient, is_divisor));\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    int max_val = 1;\n    int* vals = (int*)&max_divisor;\n    for(int i = 0; i < 4; i++) {\n        if(vals[i] > max_val && vals[i] < n) {\n            max_val = vals[i];\n        }\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i num = _mm_set1_epi32(n);\n    __m128i result = _mm_setzero_si128();\n    \n    uint32_t limit = sqrt(n);\n    \n    for (uint32_t i = 1; i <= limit; i += 4) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i mask = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n        \n        if (_mm_movemask_epi8(mask)) {\n            for (int j = 3; j >= 0; j--) {\n                uint32_t div = ((uint32_t*)&divisors)[j];\n                if (div <= limit && n % div == 0) {\n                    uint64_t quotient = n / div;\n                    return quotient;\n                }\n            }\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SSE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(1, 2, 3, 4);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i result = _mm_setzero_si128();\n    \n    uint32_t sqrt_n = sqrt(n);\n    \n    for (uint32_t i = 4; i <= sqrt_n; i += 4) {\n        __m128i quotient = _mm_div_epi32(num, divisors);\n        __m128i product = _mm_mul_epi32(quotient, divisors);\n        __m128i mask = _mm_cmpeq_epi32(product, num);\n        \n        if (_mm_movemask_epi8(mask)) {\n            result = _mm_or_si128(result, _mm_and_si128(divisors, mask));\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    alignas(16) uint32_t values[4];\n    _mm_store_si128((__m128i*)values, result);\n    \n    uint64_t largest = 1;\n    for (int i = 0; i < 4; i++) {\n        if (values[i] > largest && n % values[i] == 0) {\n            largest = values[i];\n        }\n    }\n    \n    for (uint64_t i = sqrt_n + 1; i > 0; i--) {\n        if (n % i == 0) {\n            uint64_t div = n / i;\n            if (div < n) {\n                return div;\n            }\n            return i;\n        }\n    }\n    \n    return largest;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Load number into all elements of vector\n    __m128i num = _mm_set1_epi32(n);\n    \n    // Vector of 2,3,4,5 for trial division\n    __m128i divs = _mm_set_epi32(5,4,3,2);\n    \n    // Vector of 1s for comparison\n    __m128i ones = _mm_set1_epi32(1);\n    \n    while (n > 1) {\n        // Try dividing by 2,3,4,5 in parallel\n        __m128i quotients = _mm_div_epi32(num, divs);\n        __m128i remainders = _mm_sub_epi32(num, _mm_mul_epi32(quotients, divs));\n        \n        // Check which numbers divide evenly\n        __m128i mask = _mm_cmpeq_epi32(remainders, _mm_setzero_si128());\n        \n        // Get first divisor that works\n        int m = _mm_movemask_epi8(mask);\n        if (m) {\n            int div_index = __builtin_ctz(m) / 4;\n            int divisor = ((int*)&divs)[div_index];\n            \n            factors.push_back(divisor);\n            n /= divisor;\n            num = _mm_set1_epi32(n);\n        }\n        else {\n            // No small divisors found, increment by 4\n            divs = _mm_add_epi32(divs, _mm_set1_epi32(4));\n            \n            // Break if we've exceeded square root\n            __m128i sqrt = _mm_set1_epi32((int)sqrt(n));\n            __m128i cmp = _mm_cmpgt_epi32(divs, sqrt);\n            if (_mm_movemask_epi8(cmp) == 0xFFFF) {\n                if (n > 1) {\n                    factors.push_back(n);\n                }\n                break;\n            }\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Load value into all elements of vector\n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisor = _mm_set_epi32(7, 5, 3, 2);\n    __m128i one = _mm_set1_epi32(1);\n    __m128i increment = _mm_set1_epi32(4);\n\n    while (n > 1) {\n        // Try dividing by 2,3,5,7 in parallel\n        __m128i quotient = _mm_div_epi32(num, divisor);\n        __m128i remainder = _mm_sub_epi32(num, _mm_mul_epi32(quotient, divisor));\n        \n        // Check which divisions had no remainder\n        __m128i mask = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n        int m = _mm_movemask_ps(_mm_castsi128_ps(mask));\n\n        if (m) {\n            // Found a factor\n            int idx = __builtin_ctz(m);\n            int factor = divisor.m128i_i32[idx];\n            factors.push_back(factor);\n            n /= factor;\n            num = _mm_set1_epi32(n);\n        } else {\n            // Try next set of potential factors\n            divisor = _mm_add_epi32(divisor, increment);\n        }\n\n        // Early exit for prime numbers\n        if (divisor.m128i_i32[0] * divisor.m128i_i32[0] > n) {\n            if (n > 1) factors.push_back(n);\n            break;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    // Load value into all 4 elements of XMM register\n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisor = _mm_set_epi32(7, 5, 3, 2);\n    __m128i increment = _mm_set1_epi32(1);\n    __m128i zero = _mm_setzero_si128();\n\n    while (n > 1) {\n        // Try dividing by 2,3,5,7 in parallel\n        __m128i quotient = _mm_div_epi32(num, divisor);\n        __m128i remainder = _mm_sub_epi32(num, _mm_mul_epi32(quotient, divisor));\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        int m = _mm_movemask_ps(_mm_castsi128_ps(mask));\n\n        if (m) {\n            // Found a factor\n            int factor = 0;\n            if (m & 1) factor = 2;\n            else if (m & 2) factor = 3;\n            else if (m & 4) factor = 5; \n            else if (m & 8) factor = 7;\n\n            factors.push_back(factor);\n            n /= factor;\n            num = _mm_set1_epi32(n);\n        } else {\n            // Try next set of potential factors\n            divisor = _mm_add_epi32(divisor, _mm_slli_epi32(increment, 2));\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    if (n <= 1) return factors;\n\n    // Load number into all elements of vector\n    __m128i num = _mm_set1_epi32(n);\n    \n    // Vector of 2,3,4,5 for trial division\n    __m128i divs = _mm_set_epi32(5,4,3,2);\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i fours = _mm_set1_epi32(4);\n    \n    while (n > 1) {\n        // Try dividing by 2,3,4,5 in parallel\n        __m128i quotients = _mm_div_epi32(num, divs);\n        __m128i remainders = _mm_sub_epi32(num, _mm_mul_epi32(quotients, divs));\n        \n        // Create mask of which divisions had no remainder\n        __m128i mask = _mm_cmpeq_epi32(remainders, _mm_setzero_si128());\n        \n        // Get first divisor that worked\n        int m = _mm_movemask_ps(_mm_castsi128_ps(mask));\n        \n        if (m) {\n            // Found a factor\n            int idx = __builtin_ctz(m);\n            int factor = 2 + idx;\n            factors.push_back(factor);\n            n /= factor;\n            num = _mm_set1_epi32(n);\n        } else {\n            // Try next batch of numbers\n            divs = _mm_add_epi32(divs, fours);\n        }\n        \n        // Early exit for prime numbers\n        if (_mm_cvtsi128_si32(divs) * _mm_cvtsi128_si32(divs) > n) {\n            if (n > 1) factors.push_back(n);\n            break;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SSE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle 2 as a special case\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    // Check odd numbers up to sqrt(n)\n    int limit = static_cast<int>(sqrt(n));\n    \n    __m128i divisor = _mm_set_epi32(11, 7, 5, 3);\n    __m128i increment = _mm_set1_epi32(12);\n    \n    while (n > 1 && divisor.m128i_i32[0] <= limit) {\n        __m128i num = _mm_set1_epi32(n);\n        __m128i remainder = _mm_rem_epi32(num, divisor);\n        __m128i mask = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n        \n        int m = _mm_movemask_ps(_mm_castsi128_ps(mask));\n        \n        if (m) {\n            int d = divisor.m128i_i32[__builtin_ctz(m)];\n            factors.push_back(d);\n            n /= d;\n            limit = static_cast<int>(sqrt(n));\n        } else {\n            divisor = _mm_add_epi32(divisor, increment);\n        }\n    }\n    \n    if (n > 1) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    if (l.empty()) return result;\n    \n    size_t size = l.size();\n    size_t vectorSize = size - (size % 4);\n    \n    __m128 zero = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < vectorSize; i += 4) {\n        __m128 values = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(values, zero);\n        \n        float temp[4];\n        _mm_storeu_ps(temp, values);\n        \n        int maskBits = _mm_movemask_ps(mask);\n        \n        if (maskBits & 1) result.push_back(temp[0]);\n        if (maskBits & 2) result.push_back(temp[1]);\n        if (maskBits & 4) result.push_back(temp[2]);\n        if (maskBits & 8) result.push_back(temp[3]);\n    }\n    \n    for (size_t i = vectorSize; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    const int simd_width = 4;\n    int size = l.size();\n    int aligned_size = size & ~(simd_width - 1);\n\n    __m128 zero = _mm_setzero_ps();\n    \n    // Process 4 elements at a time\n    for (int i = 0; i < aligned_size; i += simd_width) {\n        __m128 v = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(v, zero);\n        \n        // Extract positive values using mask\n        float temp[4];\n        _mm_storeu_ps(temp, _mm_and_ps(v, mask));\n        \n        for (int j = 0; j < simd_width; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = aligned_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    size_t size = l.size();\n    size_t aligned_size = size & ~3;\n    \n    __m128 zero = _mm_setzero_ps();\n    \n    // Process 4 floats at a time\n    for (size_t i = 0; i < aligned_size; i += 4) {\n        __m128 values = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(values, zero);\n        \n        // Extract individual elements if they are positive\n        float temp[4];\n        _mm_storeu_ps(temp, values);\n        \n        for (int j = 0; j < 4; j++) {\n            if (_mm_movemask_ps(mask) & (1 << j)) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128 zero = _mm_setzero_ps();\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128 values = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(values, zero);\n        \n        float temp[4];\n        _mm_storeu_ps(temp, values);\n        \n        for (int j = 0; j < 4; j++) {\n            if (_mm_movemask_ps(mask) & (1 << j)) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SSE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    if (l.empty()) return result;\n\n    const int simd_size = 4;\n    int size = l.size();\n    int aligned_size = size & ~(simd_size - 1);\n\n    __m128 zero = _mm_setzero_ps();\n\n    // Process 4 elements at a time\n    for (int i = 0; i < aligned_size; i += simd_size) {\n        __m128 v = _mm_loadu_ps(&l[i]);\n        __m128 mask = _mm_cmpgt_ps(v, zero);\n        \n        // Extract positive values using mask\n        float temp[4];\n        _mm_storeu_ps(temp, _mm_and_ps(v, mask));\n        \n        for (int j = 0; j < simd_size; j++) {\n            if (temp[j] > 0) {\n                result.push_back(temp[j]);\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = aligned_size; i < size; i++) {\n        if (l[i] > 0) {\n            result.push_back(l[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n & 1) == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    \n    __m128i increment = _mm_set_epi32(24, 18, 12, 6);\n    __m128i divisors = _mm_set_epi32(29, 23, 17, 11);\n    __m128i num = _mm_set1_epi32(n);\n    \n    for (int64_t i = 5; i <= sqrt_n; i += 30) {\n        __m128i remainders = _mm_set_epi32(\n            n % (i + 24),\n            n % (i + 18),\n            n % (i + 12),\n            n % (i + 6)\n        );\n        \n        __m128i cmp = _mm_cmpeq_epi32(remainders, _mm_setzero_si128());\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask != 0) return false;\n        \n        remainders = _mm_set_epi32(\n            n % (i + 30),\n            n % (i + 28), \n            n % (i + 22),\n            n % (i + 16)\n        );\n        \n        cmp = _mm_cmpeq_epi32(remainders, _mm_setzero_si128());\n        mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask != 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    __m128i increment = _mm_set_epi32(0, 0, 24, 24);\n    __m128i divisors = _mm_set_epi32(0, 0, 5, 7);\n    \n    for (int64_t i = 5; i <= sqrt_n; i += 24) {\n        __m128i n_vec = _mm_set1_epi32(n);\n        __m128i rem = _mm_rem_epi32(n_vec, divisors);\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp = _mm_cmpeq_epi32(rem, zero);\n        \n        int mask = _mm_movemask_epi8(cmp);\n        if (mask & 0xFF) return false;\n        \n        divisors = _mm_add_epi32(divisors, increment);\n        \n        if (i + 7 <= sqrt_n && n % (i + 11) == 0) return false;\n        if (i + 11 <= sqrt_n && n % (i + 13) == 0) return false;\n        if (i + 13 <= sqrt_n && n % (i + 17) == 0) return false;\n        if (i + 17 <= sqrt_n && n % (i + 19) == 0) return false;\n        if (i + 19 <= sqrt_n && n % (i + 23) == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    int64_t i;\n\n    __m128i vec_n = _mm_set1_epi32(n);\n    __m128i increment = _mm_set_epi32(24, 18, 12, 6);\n    __m128i base = _mm_set_epi32(5, 5, 5, 5);\n\n    for (i = 5; i <= sqrt_n; i += 24) {\n        __m128i divisors = _mm_add_epi32(base, increment);\n        __m128i remainders = _mm_set_epi32(\n            n % (i + 24),\n            n % (i + 18), \n            n % (i + 12),\n            n % (i + 6)\n        );\n        \n        int mask = _mm_movemask_epi8(_mm_cmpeq_epi32(remainders, _mm_setzero_si128()));\n        if (mask != 0) return false;\n\n        base = _mm_add_epi32(base, _mm_set1_epi32(24));\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n & 1) == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    \n    __m128i increment = _mm_set_epi32(24, 18, 12, 6);\n    __m128i divisors = _mm_set_epi32(29, 23, 17, 11);\n    __m128i num = _mm_set1_epi32(n);\n    \n    for (int64_t i = 5; i <= sqrt_n; i += 30) {\n        __m128i remainders = _mm_set_epi32(\n            n % (i + 24),\n            n % (i + 18),\n            n % (i + 12),\n            n % (i + 6)\n        );\n        \n        __m128i cmp = _mm_cmpeq_epi32(remainders, _mm_setzero_si128());\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask != 0) return false;\n        \n        remainders = _mm_set_epi32(\n            n % (i + 30),\n            n % (i + 20), \n            n % (i + 10),\n            n % i\n        );\n        \n        cmp = _mm_cmpeq_epi32(remainders, _mm_setzero_si128());\n        mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask != 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SSE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if ((n & 1) == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    \n    __m128i increment = _mm_set_epi32(24, 18, 12, 6);\n    __m128i divisors = _mm_set_epi32(29, 23, 17, 11);\n    __m128i num = _mm_set1_epi32((int)n);\n    \n    for (int64_t i = 5; i <= sqrt_n; i += 30) {\n        __m128i rem = _mm_set_epi32(\n            (int)(n % (i + 24)),\n            (int)(n % (i + 18)),\n            (int)(n % (i + 12)), \n            (int)(n % (i + 6))\n        );\n        \n        __m128i cmp = _mm_cmpeq_epi32(rem, _mm_setzero_si128());\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask != 0) return false;\n        \n        if (n % i == 0 || n % (i + 30) == 0) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n    \n    // Process 16 bytes at a time\n    for (int i = 0; i + 16 <= len; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check for letters\n        __m128i lower_mask = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('a'-1)), \n                                         _mm_cmplt_epi8(data, _mm_set1_epi8('z'+1)));\n        __m128i upper_mask = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('A'-1)),\n                                         _mm_cmplt_epi8(data, _mm_set1_epi8('Z'+1)));\n        \n        // Convert case if letter\n        __m128i is_letter = _mm_or_si128(lower_mask, upper_mask);\n        if (_mm_movemask_epi8(is_letter)) {\n            has_letters = true;\n            __m128i toggle = _mm_and_si128(is_letter, _mm_set1_epi8(32));\n            data = _mm_xor_si128(data, toggle);\n        }\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), data);\n    }\n    \n    // Handle remaining bytes\n    for (int i = len - (len % 16); i < len; i++) {\n        if (isalpha(result[i])) {\n            has_letters = true;\n            result[i] ^= 32;\n        }\n    }\n    \n    // If no letters found, reverse the whole string\n    if (!has_letters) {\n        int left = 0, right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n    \n    // Process 16 bytes at a time\n    for (int i = 0; i + 16 <= len; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check for letters\n        __m128i lower_mask = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('a'-1)), \n                                         _mm_cmplt_epi8(data, _mm_set1_epi8('z'+1)));\n        __m128i upper_mask = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('A'-1)),\n                                         _mm_cmplt_epi8(data, _mm_set1_epi8('Z'+1)));\n        \n        // Convert case if letter\n        __m128i is_letter = _mm_or_si128(lower_mask, upper_mask);\n        if (_mm_movemask_epi8(is_letter)) {\n            has_letters = true;\n            __m128i toggle = _mm_and_si128(is_letter, _mm_set1_epi8(32));\n            data = _mm_xor_si128(data, toggle);\n        }\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), data);\n    }\n    \n    // Handle remaining bytes\n    for (int i = len - (len % 16); i < len; i++) {\n        if (isalpha(result[i])) {\n            has_letters = true;\n            result[i] ^= 32;\n        }\n    }\n    \n    // If no letters found, reverse the string\n    if (!has_letters) {\n        int left = 0;\n        int right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n    \n    // Process 16 characters at a time\n    for (int i = 0; i + 15 < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check for letters\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_set1_epi8('A'-1)), \n                                        _mm_cmplt_epi8(chars, _mm_set1_epi8('Z'+1)));\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_set1_epi8('a'-1)),\n                                        _mm_cmplt_epi8(chars, _mm_set1_epi8('z'+1)));\n        __m128i is_letter = _mm_or_si128(is_upper, is_lower);\n        \n        if (_mm_movemask_epi8(is_letter)) {\n            has_letters = true;\n            \n            // Toggle case by XORing with 0x20\n            __m128i mask = _mm_and_si128(is_letter, _mm_set1_epi8(0x20));\n            chars = _mm_xor_si128(chars, mask);\n            \n            _mm_storeu_si128((__m128i*)(result.data() + i), chars);\n        }\n    }\n    \n    // Handle remaining characters\n    for (int i = (len/16)*16; i < len; i++) {\n        if (isalpha(result[i])) {\n            has_letters = true;\n            result[i] ^= 0x20;\n        }\n    }\n    \n    // If no letters found, reverse the entire string\n    if (!has_letters) {\n        int left = 0, right = len-1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool hasLetters = false;\n    \n    // Process 16 bytes at a time\n    for (int i = 0; i + 15 < len; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check for letters\n        __m128i upperMask = _mm_cmpgt_epi8(data, _mm_set1_epi8('A' - 1));\n        __m128i upperCheck = _mm_cmplt_epi8(data, _mm_set1_epi8('Z' + 1));\n        __m128i lowerMask = _mm_cmpgt_epi8(data, _mm_set1_epi8('a' - 1));\n        __m128i lowerCheck = _mm_cmplt_epi8(data, _mm_set1_epi8('z' + 1));\n        \n        __m128i isUpper = _mm_and_si128(upperMask, upperCheck);\n        __m128i isLower = _mm_and_si128(lowerMask, lowerCheck);\n        __m128i isLetter = _mm_or_si128(isUpper, isLower);\n        \n        if (_mm_movemask_epi8(isLetter)) {\n            hasLetters = true;\n            \n            // Convert case\n            __m128i toggle = _mm_set1_epi8(0x20);\n            __m128i converted = _mm_xor_si128(data, _mm_and_si128(isLetter, toggle));\n            _mm_storeu_si128((__m128i*)(result.data() + i), converted);\n        }\n    }\n    \n    // Handle remaining bytes\n    for (int i = (len/16)*16; i < len; i++) {\n        if (isalpha(result[i])) {\n            hasLetters = true;\n            result[i] ^= 0x20;\n        }\n    }\n    \n    // If no letters found, reverse the whole string\n    if (!hasLetters) {\n        int left = 0, right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SSE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int len = s.length();\n    bool has_letters = false;\n    \n    // Process 16 bytes at a time\n    for (int i = 0; i + 16 <= len; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check for letters\n        __m128i lower_mask = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('a'-1)), \n                                         _mm_cmplt_epi8(data, _mm_set1_epi8('z'+1)));\n        __m128i upper_mask = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('A'-1)),\n                                         _mm_cmplt_epi8(data, _mm_set1_epi8('Z'+1)));\n        \n        // Convert case for letters\n        __m128i is_letter = _mm_or_si128(lower_mask, upper_mask);\n        if (_mm_movemask_epi8(is_letter)) {\n            has_letters = true;\n            __m128i toggle = _mm_set1_epi8(0x20);\n            data = _mm_xor_si128(data, _mm_and_si128(is_letter, toggle));\n        }\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), data);\n    }\n    \n    // Handle remaining bytes\n    for (int i = (len/16)*16; i < len; i++) {\n        if (isalpha(result[i])) {\n            has_letters = true;\n            result[i] ^= 0x20;\n        }\n    }\n    \n    // If no letters found, reverse the whole string\n    if (!has_letters) {\n        int left = 0, right = len - 1;\n        while (left < right) {\n            std::swap(result[left], result[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> thirds;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n    \n    // Sort the thirds using SSE\n    size_t thirds_size = thirds.size();\n    size_t simd_size = (thirds_size / 4) * 4;\n    \n    for (size_t i = 0; i < thirds_size - 1; i++) {\n        for (size_t j = 0; j < simd_size; j += 4) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&thirds[j]);\n            __m128i v2 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(2,3,0,1));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(2,3,0,1));\n            __m128i min = _mm_min_epi32(v1, v2);\n            __m128i max = _mm_max_epi32(v1, v2);\n            _mm_storeu_si128((__m128i*)&thirds[j], min);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < thirds_size - 1; j++) {\n            if (thirds[j] > thirds[j + 1]) {\n                std::swap(thirds[j], thirds[j + 1]);\n            }\n        }\n    }\n    \n    // Put sorted values back in original array\n    size_t thirds_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = thirds[thirds_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> thirds;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]); \n    }\n    \n    // Sort the thirds using SSE\n    size_t n = thirds.size();\n    size_t simd_size = (n / 4) * 4;\n    \n    for (size_t i = 0; i < n-1; i++) {\n        for (size_t j = 0; j < simd_size; j += 4) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&thirds[j]);\n            __m128i v2 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(2,3,0,1));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(2,3,0,1));\n            \n            __m128i min = _mm_min_epi32(v1, v2);\n            __m128i max = _mm_max_epi32(v1, v2);\n            \n            _mm_storeu_si128((__m128i*)&thirds[j], min);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < n-1; j++) {\n            if (thirds[j] > thirds[j+1]) {\n                std::swap(thirds[j], thirds[j+1]);\n            }\n        }\n    }\n    \n    // Put sorted values back in original array\n    size_t j = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = thirds[j++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> thirds;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n    \n    // Sort the thirds using SSE\n    size_t thirds_size = thirds.size();\n    size_t simd_size = (thirds_size / 4) * 4;\n    \n    for (size_t i = 0; i < thirds_size - 1; i++) {\n        for (size_t j = 0; j < simd_size; j += 4) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&thirds[j]);\n            __m128i v2 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(2,3,1,0));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(2,3,1,0));\n            \n            __m128i min = _mm_min_epi32(v1, v2);\n            __m128i max = _mm_max_epi32(v1, v2);\n            \n            _mm_storeu_si128((__m128i*)&thirds[j], min);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < thirds_size - 1; j++) {\n            if (thirds[j] > thirds[j + 1]) {\n                std::swap(thirds[j], thirds[j + 1]);\n            }\n        }\n    }\n    \n    // Put sorted values back in original array\n    size_t thirds_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = thirds[thirds_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> thirds;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        thirds.push_back(l[i]);\n    }\n    \n    // Sort the thirds using SSE\n    size_t n = thirds.size();\n    size_t simd_size = (n / 4) * 4;\n    \n    for (size_t i = 0; i < n-1; i++) {\n        for (size_t j = 0; j < simd_size; j += 4) {\n            __m128i v1 = _mm_loadu_si128((__m128i*)&thirds[j]);\n            __m128i v2 = _mm_shufflelo_epi16(v1, _MM_SHUFFLE(2,3,0,1));\n            v2 = _mm_shufflehi_epi16(v2, _MM_SHUFFLE(2,3,0,1));\n            __m128i mask = _mm_cmpgt_epi32(v1, v2);\n            __m128i min = _mm_and_si128(mask, v2);\n            __m128i max = _mm_andnot_si128(mask, v1);\n            __m128i result = _mm_or_si128(min, max);\n            _mm_storeu_si128((__m128i*)&thirds[j], result);\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < n-1; j++) {\n            if (thirds[j] > thirds[j+1]) {\n                std::swap(thirds[j], thirds[j+1]);\n            }\n        }\n    }\n    \n    // Put sorted values back in original array\n    size_t thirds_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        l[i] = thirds[thirds_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SSE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.size() < 3) return l;\n    \n    std::vector<int> third_elements;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        third_elements.push_back(l[i]);\n    }\n    \n    // Sort the third elements\n    std::sort(third_elements.begin(), third_elements.end());\n    \n    // Create result vector\n    std::vector<int> result = l;\n    size_t third_idx = 0;\n    \n    int remainder = l.size() % 4;\n    size_t simd_size = l.size() - remainder;\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i mask = _mm_set_epi32(0, 0, 0, -1);\n        __m128i vec = _mm_loadu_si128((__m128i*)&result[i]);\n        __m128i third_val = _mm_set1_epi32(third_elements[third_idx++]);\n        vec = _mm_blendv_epi8(vec, third_val, mask);\n        _mm_storeu_si128((__m128i*)&result[i], vec);\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_size; i < l.size(); i += 3) {\n        if (third_idx < third_elements.size()) {\n            result[i] = third_elements[third_idx++];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t size = l.size();\n    size_t simd_size = size / 4;\n    size_t remainder = size % 4;\n    \n    __m128 max_val = _mm_set1_ps(-INFINITY);\n    \n    for(size_t i = 0; i < simd_size; i++) {\n        __m128 curr = _mm_loadu_ps(&l[4*i]);\n        max_val = _mm_max_ps(max_val, curr);\n    }\n    \n    float max_arr[4];\n    _mm_storeu_ps(max_arr, max_val);\n    float max_result = max_arr[0];\n    for(int i = 1; i < 4; i++) {\n        max_result = std::max(max_result, max_arr[i]);\n    }\n    \n    for(size_t i = 4*simd_size; i < size; i++) {\n        max_result = std::max(max_result, l[i]);\n    }\n    \n    return max_result;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t aligned_size = n - (n % 4);\n    \n    __m128 max_vec = _mm_set1_ps(-INFINITY);\n    \n    for(size_t i = 0; i < aligned_size; i += 4) {\n        __m128 curr = _mm_loadu_ps(&l[i]);\n        max_vec = _mm_max_ps(max_vec, curr);\n    }\n    \n    float max_val = -INFINITY;\n    float temp[4];\n    _mm_storeu_ps(temp, max_vec);\n    \n    for(int i = 0; i < 4; i++) {\n        max_val = std::max(max_val, temp[i]);\n    }\n    \n    for(size_t i = aligned_size; i < n; i++) {\n        max_val = std::max(max_val, l[i]);\n    }\n    \n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t size = l.size();\n    size_t simd_size = size / 4;\n    size_t remainder = size % 4;\n    \n    __m128 max_val = _mm_set1_ps(-INFINITY);\n    \n    for(size_t i = 0; i < simd_size; i++) {\n        __m128 curr = _mm_loadu_ps(&l[4*i]);\n        max_val = _mm_max_ps(max_val, curr);\n    }\n    \n    float max_arr[4];\n    _mm_storeu_ps(max_arr, max_val);\n    \n    float max = max_arr[0];\n    for(int i = 1; i < 4; i++) {\n        if(max_arr[i] > max) max = max_arr[i];\n    }\n    \n    for(size_t i = 4*simd_size; i < size; i++) {\n        if(l[i] > max) max = l[i];\n    }\n    \n    return max;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t simd_size = n / 4;\n    size_t remainder = n % 4;\n    \n    __m128 max_val = _mm_set1_ps(-INFINITY);\n    \n    for(size_t i = 0; i < simd_size; i++) {\n        __m128 curr = _mm_loadu_ps(&l[4*i]);\n        max_val = _mm_max_ps(max_val, curr);\n    }\n    \n    float result[4];\n    _mm_storeu_ps(result, max_val);\n    float max = result[0];\n    for(int i = 1; i < 4; i++) {\n        if(result[i] > max) max = result[i];\n    }\n    \n    for(size_t i = 4*simd_size; i < n; i++) {\n        if(l[i] > max) max = l[i];\n    }\n    \n    return max;\n}\n```"}
{"task_id": "SimdBench_79_SSE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t simd_size = n / 4;\n    size_t remainder = n % 4;\n    \n    __m128 max_val = _mm_set1_ps(-INFINITY);\n    \n    for(size_t i = 0; i < simd_size; i++) {\n        __m128 curr = _mm_loadu_ps(&l[4*i]);\n        max_val = _mm_max_ps(max_val, curr);\n    }\n    \n    float result[4];\n    _mm_storeu_ps(result, max_val);\n    float max = result[0];\n    for(int i = 1; i < 4; i++) {\n        if(result[i] > max) max = result[i];\n    }\n    \n    for(size_t i = 4*simd_size; i < n; i++) {\n        if(l[i] > max) max = l[i];\n    }\n    \n    return max;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i sevens = _mm_set1_epi32(7);\n    __m128i tens = _mm_set1_epi32(10);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for(int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_setr_epi32(i, i+1, i+2, i+3);\n        __m128i mod11 = _mm_setr_epi32(i%11, (i+1)%11, (i+2)%11, (i+3)%11);\n        __m128i mod13 = _mm_setr_epi32(i%13, (i+1)%13, (i+2)%13, (i+3)%13);\n        \n        __m128i div_mask = _mm_or_si128(\n            _mm_cmpeq_epi32(mod11, zeros),\n            _mm_cmpeq_epi32(mod13, zeros)\n        );\n        \n        for(int j = 0; j < 4; j++) {\n            if(i+j >= n) break;\n            \n            if(_mm_extract_epi32(div_mask, j)) {\n                int num = i + j;\n                while(num > 0) {\n                    if(num % 10 == 7) count++;\n                    num /= 10;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i seven = _mm_set1_epi32(7);\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div11 = _mm_set_epi32((i+3)%11==0, (i+2)%11==0, (i+1)%11==0, i%11==0);\n        __m128i div13 = _mm_set_epi32((i+3)%13==0, (i+2)%13==0, (i+1)%13==0, i%13==0);\n        __m128i divisible = _mm_or_si128(div11, div13);\n        \n        __m128i curr = nums;\n        while (_mm_movemask_epi8(_mm_cmpeq_epi32(curr, zero)) != 0xFFFF) {\n            __m128i digit = _mm_and_si128(_mm_cmpeq_epi32(_mm_rem_epi32(curr, ten), seven), divisible);\n            count += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(digit)));\n            curr = _mm_div_epi32(curr, ten);\n        }\n    }\n    \n    // Handle remaining numbers\n    for (int i = (n/4)*4; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) count++;\n                num /= 10;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i sevens = _mm_set1_epi32(7);\n    __m128i tens = _mm_set1_epi32(10);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for(int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div11 = _mm_set_epi32((i+3)%11==0, (i+2)%11==0, (i+1)%11==0, i%11==0);\n        __m128i div13 = _mm_set_epi32((i+3)%13==0, (i+2)%13==0, (i+1)%13==0, i%13==0);\n        __m128i mask = _mm_or_si128(div11, div13);\n        \n        __m128i curr = nums;\n        while(_mm_movemask_epi8(_mm_cmpeq_epi32(curr, zeros)) != 0xFFFF) {\n            __m128i digit = _mm_and_si128(_mm_cmpeq_epi32(_mm_rem_epi32(curr, tens), sevens), mask);\n            count += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(digit)));\n            curr = _mm_div_epi32(curr, tens);\n        }\n    }\n    \n    // Handle remaining numbers\n    for(int i = (n/4)*4; i < n; i++) {\n        if(i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while(num > 0) {\n                if(num % 10 == 7) count++;\n                num /= 10;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i sevens = _mm_set1_epi32(7);\n    __m128i tens = _mm_set1_epi32(10);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for(int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div11 = _mm_set_epi32((i+3)%11==0, (i+2)%11==0, (i+1)%11==0, i%11==0);\n        __m128i div13 = _mm_set_epi32((i+3)%13==0, (i+2)%13==0, (i+1)%13==0, i%13==0);\n        __m128i mask = _mm_or_si128(div11, div13);\n        \n        __m128i curr = nums;\n        \n        while(_mm_movemask_epi8(_mm_cmpeq_epi32(curr, zeros)) != 0xFFFF) {\n            __m128i digit = _mm_and_si128(_mm_cmpeq_epi32(_mm_rem_epi32(curr, tens), sevens), mask);\n            count += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(digit)));\n            curr = _mm_div_epi32(curr, tens);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SSE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    __m128i sevens = _mm_set1_epi32(7);\n    __m128i tens = _mm_set1_epi32(10);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for(int i = 0; i < n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i div11 = _mm_set_epi32((i+3)%11==0, (i+2)%11==0, (i+1)%11==0, i%11==0);\n        __m128i div13 = _mm_set_epi32((i+3)%13==0, (i+2)%13==0, (i+1)%13==0, i%13==0);\n        __m128i divisible = _mm_or_si128(div11, div13);\n        \n        __m128i curr = nums;\n        \n        while(_mm_movemask_epi8(_mm_cmpeq_epi32(curr, zeros)) != 0xFFFF) {\n            __m128i digit = _mm_and_si128(_mm_set1_epi32(0xF), curr);\n            __m128i matches = _mm_and_si128(_mm_cmpeq_epi32(digit, sevens), divisible);\n            count += _mm_popcnt_u32(_mm_movemask_ps(_mm_castsi128_ps(matches)));\n            curr = _mm_srli_epi32(_mm_div_epi32(curr, tens), 0);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    // Pad vector to multiple of 4 if needed\n    size_t orig_size = l.size();\n    while (l.size() % 4 != 0) {\n        l.push_back(std::numeric_limits<float>::max());\n    }\n    \n    // Extract even elements\n    std::vector<float> even;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    \n    // Sort even elements using SSE\n    for (size_t i = 0; i < even.size(); i += 4) {\n        __m128 v = _mm_load_ps(&even[i]);\n        \n        // Sort within each 4-element chunk\n        for (int j = 0; j < 4; j++) {\n            for (int k = 0; k < 3; k++) {\n                __m128 v1 = v;\n                __m128 v2 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(k+1,k,k+1,k));\n                __m128 cmp = _mm_cmplt_ps(v1, v2);\n                v = _mm_blendv_ps(v2, v1, cmp);\n            }\n        }\n        \n        _mm_store_ps(&even[i], v);\n    }\n    \n    // Put sorted even elements back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        l[i] = even[even_idx++];\n    }\n    \n    // Restore original size\n    l.resize(orig_size);\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    // Pad vector to multiple of 4\n    size_t orig_size = l.size();\n    size_t padded_size = ((l.size() + 3) / 4) * 4;\n    l.resize(padded_size, std::numeric_limits<float>::max());\n    \n    // Create mask for even indices\n    __m128 even_mask = _mm_set_ps(0.0f, 1.0f, 0.0f, 1.0f);\n    \n    for (size_t i = 0; i < padded_size; i += 4) {\n        // Load 4 elements\n        __m128 v = _mm_loadu_ps(&l[i]);\n        \n        // Extract even elements\n        __m128 even = _mm_and_ps(v, even_mask);\n        \n        // Compare and swap elements\n        __m128 shuffled = _mm_shuffle_ps(even, even, _MM_SHUFFLE(2,3,0,1));\n        __m128 cmp = _mm_cmplt_ps(shuffled, even);\n        __m128 min = _mm_min_ps(even, shuffled);\n        __m128 max = _mm_max_ps(even, shuffled);\n        even = _mm_or_ps(_mm_and_ps(cmp, min), _mm_andnot_ps(cmp, max));\n        \n        // Merge sorted even elements with original odd elements\n        __m128 result = _mm_or_ps(even, _mm_andnot_ps(even_mask, v));\n        \n        // Store result\n        _mm_storeu_ps(&l[i], result);\n    }\n    \n    // Restore original size\n    l.resize(orig_size);\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_values;\n    even_values.reserve(even_count);\n    \n    // Extract even-indexed values\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n    \n    // Sort even values using SSE\n    size_t sse_count = even_count / 4;\n    size_t remainder = even_count % 4;\n    \n    for (size_t i = 0; i < sse_count; i++) {\n        __m128 v = _mm_loadu_ps(&even_values[i * 4]);\n        \n        // Sort within each vector using min/max operations\n        __m128 min1 = _mm_min_ps(v, _mm_shuffle_ps(v, v, _MM_SHUFFLE(2, 3, 0, 1)));\n        __m128 max1 = _mm_max_ps(v, _mm_shuffle_ps(v, v, _MM_SHUFFLE(2, 3, 0, 1)));\n        \n        v = _mm_shuffle_ps(min1, max1, _MM_SHUFFLE(3, 2, 1, 0));\n        \n        min1 = _mm_min_ps(v, _mm_shuffle_ps(v, v, _MM_SHUFFLE(1, 0, 3, 2)));\n        max1 = _mm_max_ps(v, _mm_shuffle_ps(v, v, _MM_SHUFFLE(1, 0, 3, 2)));\n        \n        v = _mm_shuffle_ps(min1, max1, _MM_SHUFFLE(3, 2, 1, 0));\n        \n        _mm_storeu_ps(&even_values[i * 4], v);\n    }\n    \n    // Sort remaining elements\n    std::sort(even_values.begin() + sse_count * 4, even_values.end());\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_nums;\n    even_nums.reserve(even_count);\n    \n    // Extract even indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_nums.push_back(l[i]);\n    }\n    \n    // Sort even indexed elements using SSE\n    for (size_t i = 0; i < even_count; i += 4) {\n        size_t remaining = std::min(4UL, even_count - i);\n        if (remaining < 2) break;\n        \n        __m128 v = _mm_loadu_ps(&even_nums[i]);\n        \n        for (size_t j = 0; j < remaining - 1; j++) {\n            for (size_t k = 0; k < remaining - j - 1; k++) {\n                __m128 v1 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(k+1,k+1,k,k));\n                __m128 cmp = _mm_cmplt_ps(v1, _mm_shuffle_ps(v1,v1,_MM_SHUFFLE(2,3,0,1)));\n                __m128 min = _mm_min_ps(v1, _mm_shuffle_ps(v1,v1,_MM_SHUFFLE(2,3,0,1)));\n                __m128 max = _mm_max_ps(v1, _mm_shuffle_ps(v1,v1,_MM_SHUFFLE(2,3,0,1)));\n                v = _mm_blend_ps(v, _mm_shuffle_ps(max,min,_MM_SHUFFLE(0,1,2,3)), \n                               (1 << k) | (1 << (k+1)));\n            }\n        }\n        \n        _mm_storeu_ps(&even_nums[i], v);\n    }\n    \n    // Put sorted even elements back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_nums[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SSE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.size() <= 1) return l;\n    \n    size_t n = l.size();\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_nums;\n    \n    // Extract even indexed elements\n    for (size_t i = 0; i < n; i += 2) {\n        even_nums.push_back(l[i]);\n    }\n    \n    // Sort even indexed elements using SSE\n    for (size_t i = 0; i < even_count; i += 4) {\n        size_t remaining = std::min(4UL, even_count - i);\n        if (remaining < 2) break;\n        \n        __m128 v = _mm_loadu_ps(&even_nums[i]);\n        \n        if (remaining >= 2) {\n            __m128 v1 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(1,0,3,2));\n            __m128 min = _mm_min_ps(v, v1);\n            __m128 max = _mm_max_ps(v, v1);\n            v = _mm_shuffle_ps(min, max, _MM_SHUFFLE(1,0,1,0));\n        }\n        \n        if (remaining >= 4) {\n            __m128 v2 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(2,3,0,1));\n            __m128 min = _mm_min_ps(v, v2);\n            __m128 max = _mm_max_ps(v, v2);\n            v = _mm_shuffle_ps(min, max, _MM_SHUFFLE(3,2,1,0));\n            \n            v2 = _mm_shuffle_ps(v, v, _MM_SHUFFLE(0,3,2,1));\n            min = _mm_min_ps(v, v2);\n            max = _mm_max_ps(v, v2);\n            v = _mm_shuffle_ps(min, max, _MM_SHUFFLE(3,2,1,0));\n        }\n        \n        _mm_storeu_ps(&even_nums[i], v);\n    }\n    \n    // Put sorted even elements back\n    for (size_t i = 0, j = 0; i < n; i += 2) {\n        l[i] = even_nums[j++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int aligned_size = (n + 3) & ~3;\n    std::vector<int> aligned_vec(aligned_size, 0);\n    std::copy(l.begin(), l.end(), aligned_vec.begin());\n\n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int sum2 = l[i] + l[j];\n            \n            __m128i v_sum2 = _mm_set1_epi32(-sum2);\n            \n            for (int k = j+1; k < aligned_size; k += 4) {\n                __m128i v_nums = _mm_load_si128((__m128i*)&aligned_vec[k]);\n                __m128i v_cmp = _mm_cmpeq_epi32(v_nums, v_sum2);\n                int mask = _mm_movemask_epi8(v_cmp);\n                \n                if (mask != 0 && k < n) {\n                    for (int m = 0; m < 4 && k+m < n; m++) {\n                        if (aligned_vec[k+m] == -sum2) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int aligned_size = (n + 3) & ~3;\n    std::vector<int> aligned_data(aligned_size, 0);\n    std::copy(l.begin(), l.end(), aligned_data.begin());\n\n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int sum_ij = l[i] + l[j];\n            \n            int remaining = n - (j+1);\n            int simd_iters = remaining / 4;\n            \n            __m128i v_sum = _mm_set1_epi32(-sum_ij);\n            \n            for (int k = 0; k < simd_iters; k++) {\n                int offset = j + 1 + k*4;\n                __m128i v_data = _mm_loadu_si128((__m128i*)&aligned_data[offset]);\n                __m128i v_cmp = _mm_cmpeq_epi32(v_data, v_sum);\n                int mask = _mm_movemask_epi8(v_cmp);\n                if (mask != 0) return true;\n            }\n            \n            // Handle remaining elements\n            for (int k = j + 1 + simd_iters*4; k < n; k++) {\n                if (l[k] == -sum_ij) return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int aligned_size = (n + 3) & ~3;\n    std::vector<int> aligned_vec(aligned_size, 0);\n    std::copy(l.begin(), l.end(), aligned_vec.begin());\n\n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int target = -(l[i] + l[j]);\n            \n            int k = j + 1;\n            int remaining = n - k;\n            int simd_iters = remaining / 4;\n            \n            __m128i v1 = _mm_set1_epi32(target);\n            \n            for (int s = 0; s < simd_iters; s++) {\n                __m128i v2 = _mm_load_si128((__m128i*)&aligned_vec[k + s*4]);\n                __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n                int mask = _mm_movemask_epi8(cmp);\n                if (mask != 0) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (int r = k + simd_iters*4; r < n; r++) {\n                if (l[r] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int aligned_size = (n + 3) & ~3;\n    std::vector<int> aligned_vec(aligned_size, 0);\n    std::copy(l.begin(), l.end(), aligned_vec.begin());\n\n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int target = -(l[i] + l[j]);\n            \n            int k = j + 1;\n            int remaining = n - k;\n            int simd_iters = remaining / 4;\n            \n            __m128i v1 = _mm_set1_epi32(target);\n            \n            for (int s = 0; s < simd_iters; s++) {\n                __m128i v2 = _mm_load_si128((__m128i*)&aligned_vec[k + s*4]);\n                __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n                int mask = _mm_movemask_epi8(cmp);\n                if (mask != 0) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (int r = k + simd_iters*4; r < n; r++) {\n                if (l[r] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SSE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    int n = l.size();\n    int aligned_size = (n + 3) & ~3;\n    std::vector<int> aligned_vec(aligned_size, 0);\n    std::copy(l.begin(), l.end(), aligned_vec.begin());\n\n    for (int i = 0; i < n-2; i++) {\n        for (int j = i+1; j < n-1; j++) {\n            int target = -(l[i] + l[j]);\n            \n            int k = j + 1;\n            int remaining = n - k;\n            int simd_iters = remaining / 4;\n            \n            __m128i v1 = _mm_set1_epi32(target);\n            \n            for (int s = 0; s < simd_iters; s++) {\n                __m128i v2 = _mm_load_si128((__m128i*)&aligned_vec[k + s*4]);\n                __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n                int mask = _mm_movemask_ps((__m128)cmp);\n                \n                if (mask != 0) {\n                    return true;\n                }\n            }\n            \n            // Handle remaining elements\n            for (int r = k + simd_iters*4; r < n; r++) {\n                if (l[r] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(size_t i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        vec = _mm_add_epi32(vec, ones);\n        _mm_storeu_si128((__m128i*)&l[i], vec);\n    }\n    \n    for(size_t i = simd_size; i < size; i++) {\n        l[i]++;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(size_t i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        vec = _mm_add_epi32(vec, ones);\n        _mm_storeu_si128((__m128i*)&l[i], vec);\n    }\n    \n    for(size_t i = simd_size; i < size; i++) {\n        l[i]++;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(size_t i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        vec = _mm_add_epi32(vec, ones);\n        _mm_storeu_si128((__m128i*)&l[i], vec);\n    }\n    \n    for(size_t i = simd_size; i < size; i++) {\n        l[i]++;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(size_t i = 0; i < simd_size; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&l[i]);\n        vec = _mm_add_epi32(vec, ones);\n        _mm_storeu_si128((__m128i*)&l[i], vec);\n    }\n    \n    for(size_t i = simd_size; i < size; i++) {\n        l[i]++;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_83_SSE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t size = l.size();\n    size_t aligned_size = size - (size % 4);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    \n    // Process 4 elements at a time\n    for(size_t i = 0; i < aligned_size; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&l[i]);\n        v = _mm_add_epi32(v, ones);\n        _mm_storeu_si128((__m128i*)&l[i], v);\n    }\n    \n    // Handle remaining elements\n    for(size_t i = aligned_size; i < size; i++) {\n        l[i]++;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    for (size_t i = 0; i < size; i++) {\n        __m128i v1 = _mm_set1_epi32(l[i]);\n        \n        for (size_t j = 0; j < simd_size; j += 4) {\n            if (i != j && i < j+4) continue;\n            \n            __m128i v2 = _mm_loadu_si128((__m128i*)&l[j]);\n            __m128i sum = _mm_add_epi32(v1, v2);\n            __m128i cmp = _mm_cmpeq_epi32(sum, _mm_setzero_si128());\n            int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n            \n            if (mask != 0) return true;\n        }\n        \n        for (size_t j = simd_size; j < size; j++) {\n            if (i != j && l[i] + l[j] == 0) return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    for (size_t i = 0; i < size; i++) {\n        __m128i v1 = _mm_set1_epi32(l[i]);\n        \n        for (size_t j = i + 1; j < simd_size; j += 4) {\n            __m128i v2 = _mm_loadu_si128((__m128i*)&l[j]);\n            __m128i sum = _mm_add_epi32(v1, v2);\n            __m128i cmp = _mm_cmpeq_epi32(sum, _mm_setzero_si128());\n            int mask = _mm_movemask_ps((__m128)cmp);\n            \n            if (mask != 0) {\n                return true;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < size; j++) {\n            if (i != j && l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    for (size_t i = 0; i < size; i++) {\n        __m128i v1 = _mm_set1_epi32(l[i]);\n        \n        for (size_t j = 0; j < simd_size; j += 4) {\n            if (i != j && i != j+1 && i != j+2 && i != j+3) {\n                __m128i v2 = _mm_loadu_si128((__m128i*)&l[j]);\n                __m128i sum = _mm_add_epi32(v1, v2);\n                __m128i cmp = _mm_cmpeq_epi32(sum, _mm_setzero_si128());\n                int mask = _mm_movemask_ps((__m128)cmp);\n                if (mask != 0) return true;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < size; j++) {\n            if (i != j && l[i] + l[j] == 0) return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    for (size_t i = 0; i < size; i++) {\n        __m128i v1 = _mm_set1_epi32(l[i]);\n        \n        for (size_t j = 0; j < simd_size; j += 4) {\n            if (i != j && i != j+1 && i != j+2 && i != j+3) {\n                __m128i v2 = _mm_loadu_si128((__m128i*)&l[j]);\n                __m128i sum = _mm_add_epi32(v1, v2);\n                __m128i cmp = _mm_cmpeq_epi32(sum, _mm_setzero_si128());\n                int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n                if (mask) return true;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < size; j++) {\n            if (i != j && l[i] + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SSE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    size_t vec_size = l.size();\n    size_t simd_size = vec_size - (vec_size % 4);\n    \n    for (size_t i = 0; i < vec_size; i++) {\n        __m128i v1 = _mm_set1_epi32(l[i]);\n        \n        for (size_t j = 0; j < simd_size; j += 4) {\n            if (i != j && i != j+1 && i != j+2 && i != j+3) {\n                __m128i v2 = _mm_loadu_si128((__m128i*)&l[j]);\n                __m128i sum = _mm_add_epi32(v1, v2);\n                __m128i cmp = _mm_cmpeq_epi32(sum, _mm_setzero_si128());\n                int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n                if (mask != 0) return true;\n            }\n        }\n        \n        // Handle remaining elements\n        for (size_t j = simd_size; j < vec_size; j++) {\n            if (i != j && l[i] + l[j] == 0) return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char result[65];\n    int pos = 64;\n    result[pos] = '\\0';\n    \n    __m128i num = _mm_set1_epi32(x);\n    __m128i base_vec = _mm_set1_epi32(base);\n    __m128i zero = _mm_setzero_si128();\n    \n    while (_mm_movemask_epi8(_mm_cmpeq_epi32(num, zero)) != 0xFFFF) {\n        __m128i quotient = _mm_div_epi32(num, base_vec);\n        __m128i remainder = _mm_sub_epi32(num, _mm_mul_epi32(quotient, base_vec));\n        \n        int rem = _mm_cvtsi128_si32(remainder);\n        result[--pos] = rem + '0';\n        \n        num = quotient;\n    }\n    \n    return std::string(result + pos);\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    // Load x into all elements of vector\n    __m128i vec_x = _mm_set1_epi32(x);\n    __m128i vec_base = _mm_set1_epi32(base);\n    __m128i vec_zero = _mm_setzero_si128();\n    \n    char digits[64];\n    int idx = 0;\n\n    while (x > 0) {\n        // Divide x by base using SIMD\n        __m128i quotient = _mm_div_epi32(vec_x, vec_base);\n        __m128i remainder = _mm_sub_epi32(vec_x, _mm_mul_epi32(quotient, vec_base));\n        \n        // Extract remainder and convert to digit\n        int rem = _mm_cvtsi128_si32(remainder);\n        digits[idx++] = rem + '0';\n        \n        // Update x for next iteration\n        x /= base;\n        vec_x = _mm_set1_epi32(x);\n    }\n\n    // Build result string\n    if (negative) result += '-';\n    for (int i = idx - 1; i >= 0; i--) {\n        result += digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    // Load x into all elements of vector\n    __m128i vec_x = _mm_set1_epi32(x);\n    __m128i vec_base = _mm_set1_epi32(base);\n    __m128i vec_zero = _mm_setzero_si128();\n    \n    char digits[64];\n    int idx = 0;\n\n    while (x > 0) {\n        // Divide x by base using SIMD\n        __m128i quotient = _mm_div_epi32(vec_x, vec_base);\n        __m128i remainder = _mm_sub_epi32(vec_x, _mm_mul_epi32(quotient, vec_base));\n        \n        // Extract remainder and convert to digit\n        int rem = _mm_cvtsi128_si32(remainder);\n        digits[idx++] = rem + '0';\n        \n        // Update x for next iteration\n        x /= base;\n        vec_x = _mm_set1_epi32(x);\n    }\n\n    // Build result string\n    if (negative) result += '-';\n    for (int i = idx - 1; i >= 0; i--) {\n        result += digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    // Load constants into SIMD registers\n    __m128i vbase = _mm_set1_epi32(base);\n    __m128i vx = _mm_set1_epi32(x);\n    __m128i vzero = _mm_setzero_si128();\n    \n    char digits[64];\n    int idx = 0;\n\n    while (x > 0) {\n        // Process 4 divisions in parallel\n        __m128i vquot = _mm_set_epi32(x/base/base/base, x/base/base, x/base, x);\n        __m128i vrem = _mm_sub_epi32(vquot, _mm_mul_epi32(_mm_div_epi32(vquot, vbase), vbase));\n        \n        // Extract remainders and convert to ASCII\n        int32_t rem[4];\n        _mm_storeu_si128((__m128i*)rem, vrem);\n        \n        for(int i = 0; i < 4 && x > 0; i++) {\n            digits[idx++] = '0' + (rem[i] % base);\n            x /= base;\n        }\n    }\n\n    // Reverse the digits\n    result.reserve(idx + negative);\n    if (negative) result += '-';\n    for(int i = idx-1; i >= 0; i--) {\n        result += digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SSE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    // Load constants into SIMD registers\n    __m128i divisor = _mm_set1_epi32(base);\n    __m128i num = _mm_set1_epi32(x);\n    __m128i zero = _mm_setzero_si128();\n    \n    char digits[64];\n    int idx = 0;\n\n    while (_mm_movemask_epi8(_mm_cmpeq_epi32(num, zero)) != 0xFFFF) {\n        // Divide by base and get remainder\n        __m128i quotient = _mm_div_epi32(num, divisor);\n        __m128i remainder = _mm_sub_epi32(num, _mm_mul_epi32(quotient, divisor));\n        \n        // Extract remainder and convert to digit\n        int rem = _mm_cvtsi128_si32(remainder);\n        digits[idx++] = '0' + rem;\n        \n        num = quotient;\n    }\n\n    // Build result string\n    if (negative) result += '-';\n    for (int i = idx - 1; i >= 0; i--) {\n        result += digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i + 16 <= j) {\n        __m128i forward = _mm_loadu_si128((__m128i*)(str + i));\n        __m128i reverse = _mm_loadu_si128((__m128i*)(str + j - 15));\n        \n        reverse = _mm_shuffle_epi8(reverse, _mm_setr_epi8(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0));\n        \n        __m128i cmp = _mm_cmpeq_epi8(forward, reverse);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        if (mask != 0xFFFF) {\n            return false;\n        }\n        \n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (str[i] != str[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    int i = 0;\n    int j = len - 16;\n\n    while (i < j) {\n        if (j >= 0) {\n            __m128i forward = _mm_loadu_si128((__m128i*)(str + i));\n            __m128i reverse = _mm_loadu_si128((__m128i*)(str + j));\n\n            char rev_chars[16];\n            _mm_storeu_si128((__m128i*)rev_chars, reverse);\n\n            __m128i reversed = _mm_setr_epi8(\n                rev_chars[15], rev_chars[14], rev_chars[13], rev_chars[12],\n                rev_chars[11], rev_chars[10], rev_chars[9], rev_chars[8],\n                rev_chars[7], rev_chars[6], rev_chars[5], rev_chars[4],\n                rev_chars[3], rev_chars[2], rev_chars[1], rev_chars[0]\n            );\n\n            __m128i cmp = _mm_cmpeq_epi8(forward, reversed);\n            int mask = _mm_movemask_epi8(cmp);\n\n            if (mask != 0xFFFF)\n                return false;\n\n            i += 16;\n            j -= 16;\n        } else {\n            while (i < len/2) {\n                if (str[i] != str[len-1-i])\n                    return false;\n                i++;\n            }\n            break;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    const char* start = text.c_str();\n    const char* end = start + text.length() - 16;\n    \n    while (start < end) {\n        __m128i forward = _mm_loadu_si128((__m128i*)start);\n        \n        char reversed[16];\n        for (int i = 0; i < 16; i++) {\n            reversed[15-i] = *(end + i);\n        }\n        __m128i backward = _mm_loadu_si128((__m128i*)reversed);\n        \n        __m128i cmp = _mm_cmpeq_epi8(forward, backward);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        if (mask != 0xFFFF) {\n            return false;\n        }\n        \n        start += 16;\n        end -= 16;\n    }\n    \n    // Handle remaining characters\n    int remaining = (text.length() % 32) / 2;\n    for (int i = 0; i < remaining; i++) {\n        if (*(start + i) != *(end + 16 + remaining - 1 - i)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.c_str();\n    const char* end = start + len - 16;\n    \n    while (start < end) {\n        __m128i forward = _mm_loadu_si128((__m128i*)start);\n        \n        char reversed[16];\n        for (int i = 0; i < 16; i++) {\n            reversed[15-i] = *(end + i);\n        }\n        __m128i backward = _mm_loadu_si128((__m128i*)reversed);\n\n        __m128i cmp = _mm_cmpeq_epi8(forward, backward);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        if (mask != 0xFFFF) {\n            return false;\n        }\n        \n        start += 16;\n        end -= 16;\n    }\n\n    // Handle remaining characters\n    start = text.c_str() + (len/2) - (len%16);\n    end = text.c_str() + len - 1 - (len/2) + (len%16);\n    \n    while (start < end) {\n        if (*start != *end) return false;\n        start++;\n        end--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SSE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* start = text.data();\n    const char* end = start + len - 16;\n    \n    while (start < end) {\n        __m128i forward = _mm_loadu_si128((__m128i*)start);\n        \n        char reversed[16];\n        for (int i = 0; i < 16; i++) {\n            reversed[i] = *(end + 15 - i);\n        }\n        __m128i backward = _mm_loadu_si128((__m128i*)reversed);\n\n        __m128i cmp = _mm_cmpeq_epi8(forward, backward);\n        int mask = _mm_movemask_epi8(cmp);\n        \n        if (mask != 0xFFFF) {\n            return false;\n        }\n        \n        start += 16;\n        end -= 16;\n    }\n\n    // Handle remaining characters\n    start = text.data() + (len / 32) * 16;\n    end = text.data() + len - (len / 32) * 16 - 1;\n    \n    while (start < end) {\n        if (*start != *end) return false;\n        start++;\n        end--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i twenty_six = _mm_set1_epi8(26);\n\n    for (i = 0; i <= s.length()-16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Shift back by 5\n        __m128i shifted = _mm_add_epi8(chars, shift);\n        \n        // Handle wraparound\n        __m128i below_a = _mm_cmplt_epi8(shifted, a);\n        __m128i fix = _mm_and_si128(below_a, twenty_six);\n        shifted = _mm_add_epi8(shifted, fix);\n        \n        _mm_storeu_si128((__m128i*)(out.data() + i), shifted);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i twenty_six = _mm_set1_epi8(26);\n\n    for (i = 0; i <= s.length()-16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Shift back by 5\n        __m128i shifted = _mm_add_epi8(chars, shift);\n        \n        // Handle wraparound\n        __m128i less_than_a = _mm_cmplt_epi8(shifted, a);\n        __m128i wrap = _mm_and_si128(less_than_a, twenty_six);\n        shifted = _mm_add_epi8(shifted, wrap);\n        \n        _mm_storeu_si128((__m128i*)(out.data() + i), shifted);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i twenty_six = _mm_set1_epi8(26);\n\n    for (i = 0; i <= s.length()-16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Shift back by 5\n        __m128i shifted = _mm_add_epi8(chars, shift);\n        \n        // Handle wrap around\n        __m128i less_than_a = _mm_cmplt_epi8(shifted, a);\n        __m128i wrap = _mm_and_si128(less_than_a, twenty_six);\n        shifted = _mm_add_epi8(shifted, wrap);\n        \n        _mm_storeu_si128((__m128i*)(out.data() + i), shifted);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    __m128i shift = _mm_set1_epi8(-5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i twenty_six = _mm_set1_epi8(26);\n\n    for (i = 0; i <= s.length()-16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Subtract 'a' to get 0-25 range\n        chars = _mm_sub_epi8(chars, a);\n        \n        // Add shift (-5)\n        chars = _mm_add_epi8(chars, shift);\n        \n        // Handle negative values by adding 26\n        __m128i mask = _mm_cmplt_epi8(chars, _mm_setzero_si128());\n        __m128i add = _mm_and_si128(twenty_six, mask);\n        chars = _mm_add_epi8(chars, add);\n        \n        // Add 'a' back\n        chars = _mm_add_epi8(chars, a);\n        \n        _mm_storeu_si128((__m128i*)(out.data() + i), chars);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SSE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    int i;\n    \n    __m128i shift = _mm_set1_epi8(5);\n    __m128i a = _mm_set1_epi8('a');\n    __m128i z = _mm_set1_epi8('z');\n    __m128i size = _mm_set1_epi8(26);\n\n    for (i = 0; i <= s.length()-16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Subtract shift amount\n        chars = _mm_sub_epi8(chars, shift);\n        \n        // Handle wraparound by adding 26 if char < 'a'\n        __m128i mask = _mm_cmplt_epi8(chars, a);\n        __m128i wrap = _mm_and_si128(mask, size);\n        chars = _mm_add_epi8(chars, wrap);\n        \n        _mm_storeu_si128((__m128i*)(out.data() + i), chars);\n    }\n\n    // Handle remaining characters\n    for (; i < s.length(); i++) {\n        int w = ((int)s[i] - 5 - (int)'a');\n        if (w < 0) w += 26;\n        w = w + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) return true;\n    \n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i threshold = _mm_set1_epi32(t);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i values = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(values, threshold);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        if (mask != 0xF) return false;\n    }\n    \n    for (size_t i = simd_size; i < size; i++) {\n        if (l[i] >= t) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i threshold = _mm_set1_epi32(t);\n    \n    for(size_t i = 0; i < simd_size; i += 4) {\n        __m128i values = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(values, threshold);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        if(mask != 0xF) return false;\n    }\n    \n    for(size_t i = simd_size; i < size; i++) {\n        if(l[i] >= t) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) return true;\n    \n    size_t size = l.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128i threshold = _mm_set1_epi32(t);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i values = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i cmp = _mm_cmplt_epi32(values, threshold);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        if (mask != 0xF) return false;\n    }\n    \n    for (size_t i = simd_size; i < size; i++) {\n        if (l[i] >= t) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) {\n        return true;\n    }\n\n    size_t vectorSize = l.size();\n    size_t simdSize = vectorSize - (vectorSize % 4);\n    \n    __m128i threshold = _mm_set1_epi32(t);\n    \n    for (size_t i = 0; i < simdSize; i += 4) {\n        __m128i values = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i comp = _mm_cmplt_epi32(values, threshold);\n        \n        if (_mm_movemask_epi8(comp) != 0xFFFF) {\n            return false;\n        }\n    }\n\n    for (size_t i = simdSize; i < vectorSize; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SSE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) {\n        return true;\n    }\n\n    size_t vectorSize = l.size();\n    size_t simdSize = vectorSize - (vectorSize % 4);\n    \n    __m128i threshold = _mm_set1_epi32(t);\n    \n    for (size_t i = 0; i < simdSize; i += 4) {\n        __m128i values = _mm_loadu_si128((__m128i*)&l[i]);\n        __m128i comp = _mm_cmplt_epi32(values, threshold);\n        \n        if (_mm_movemask_epi8(comp) != 0xFFFF) {\n            return false;\n        }\n    }\n    \n    for (size_t i = simdSize; i < vectorSize; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    int count = 0;\n    \n    // Process 16 characters at a time using SSE\n    while (len >= 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)brackets.c_str());\n        \n        // Create masks for '<' and '>'\n        __m128i open_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        __m128i close_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        // Count openings and closings\n        int opens = _mm_movemask_epi8(open_mask);\n        int closes = _mm_movemask_epi8(close_mask);\n        \n        // Update running count\n        count += _mm_popcnt_u32(opens) - _mm_popcnt_u32(closes);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        brackets = brackets.substr(16);\n        len -= 16;\n    }\n    \n    // Handle remaining characters\n    for (int i = 0; i < len; i++) {\n        if (brackets[i] == '<') count++;\n        else if (brackets[i] == '>') count--;\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    int i;\n    \n    // Process 16 characters at a time using SSE\n    for (i = 0; i <= len-16; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(brackets.data() + i));\n        \n        // Create masks for < and > characters\n        __m128i open_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        __m128i close_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        // Count < and > characters\n        int open_count = _mm_movemask_epi8(open_mask);\n        int close_count = _mm_movemask_epi8(close_mask);\n        \n        // Update running count\n        count += _mm_popcnt_u32(open_count);\n        count -= _mm_popcnt_u32(close_count);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        if (brackets[i] == '<') count++;\n        else count--;\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int count = 0;\n    int len = brackets.length();\n    \n    // Handle strings shorter than 16 characters without SIMD\n    if (len < 16) {\n        for (char c : brackets) {\n            if (c == '<') count++;\n            else count--;\n            if (count < 0) return false;\n        }\n        return count == 0;\n    }\n\n    // Process 16 characters at a time using SSE2\n    __m128i zeros = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i running_sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < len - 15; i += 16) {\n        // Load 16 characters\n        __m128i data = _mm_loadu_si128((__m128i*)(brackets.data() + i));\n        \n        // Create masks for '<' and '>'\n        __m128i open_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('<'));\n        __m128i close_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('>'));\n        \n        // Add 1 for '<' and subtract 1 for '>'\n        __m128i adds = _mm_and_si128(open_mask, ones);\n        __m128i subs = _mm_and_si128(close_mask, ones);\n        \n        // Update running sum\n        running_sum = _mm_add_epi8(running_sum, adds);\n        running_sum = _mm_sub_epi8(running_sum, subs);\n        \n        // Check if any position became negative\n        __m128i cmp = _mm_cmplt_epi8(running_sum, zeros);\n        if (_mm_movemask_epi8(cmp)) {\n            return false;\n        }\n    }\n    \n    // Sum up the final counts\n    alignas(16) char counts[16];\n    _mm_store_si128((__m128i*)counts, running_sum);\n    \n    for (int i = 0; i < 16; i++) {\n        count += counts[i];\n    }\n    \n    // Process remaining characters\n    for (int i = (len / 16) * 16; i < len; i++) {\n        if (brackets[i] == '<') count++;\n        else count--;\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 16 != 0) {\n        int padding = 16 - (len % 16);\n        brackets.append(padding, '>');\n        len += padding;\n    }\n\n    __m128i count = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int i = 0; i < len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(brackets.c_str() + i));\n        __m128i open_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('<'));\n        __m128i close_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('>'));\n        \n        __m128i open_inc = _mm_and_si128(open_mask, ones);\n        __m128i close_dec = _mm_and_si128(close_mask, ones);\n        \n        count = _mm_add_epi8(count, open_inc);\n        count = _mm_sub_epi8(count, close_dec);\n        \n        __m128i neg_check = _mm_cmplt_epi8(count, zeros);\n        if (_mm_movemask_epi8(neg_check)) {\n            return false;\n        }\n    }\n    \n    alignas(16) char counts[16];\n    _mm_store_si128((__m128i*)counts, count);\n    \n    int final_count = 0;\n    for (int i = 0; i < 16; i++) {\n        final_count += counts[i];\n    }\n    \n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    int count = 0;\n    \n    // Process 16 characters at a time using SSE\n    while (len >= 16) {\n        __m128i chunk = _mm_loadu_si128((__m128i*)brackets.c_str());\n        \n        // Create masks for '<' and '>'\n        __m128i open_mask = _mm_cmpeq_epi8(chunk, _mm_set1_epi8('<'));\n        __m128i close_mask = _mm_cmpeq_epi8(chunk, _mm_set1_epi8('>'));\n        \n        // Count number of open and close brackets\n        int open_count = _mm_movemask_epi8(open_mask);\n        int close_count = _mm_movemask_epi8(close_mask);\n        \n        // Update running count\n        count += _mm_popcnt_u32(open_count);\n        count -= _mm_popcnt_u32(close_count);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        brackets = brackets.substr(16);\n        len -= 16;\n    }\n    \n    // Handle remaining characters\n    for (int i = 0; i < len; i++) {\n        if (brackets[i] == '<') count++;\n        else count--;\n        if (count < 0) return false;\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const int len = brackets.length();\n    const int simd_width = 16;\n    const int simd_iters = len / simd_width;\n    \n    __m128i count = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int i = 0; i < simd_iters; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)(brackets.data() + i * simd_width));\n        __m128i open_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8(')'));\n        \n        __m128i open_count = _mm_and_si128(open_mask, ones);\n        __m128i close_count = _mm_and_si128(close_mask, ones);\n        \n        count = _mm_add_epi8(count, open_count);\n        count = _mm_sub_epi8(count, close_count);\n        \n        __m128i neg_check = _mm_cmplt_epi8(count, zeros);\n        if (_mm_movemask_epi8(neg_check)) {\n            return false;\n        }\n    }\n    \n    int final_count = 0;\n    char counts[16];\n    _mm_storeu_si128((__m128i*)counts, count);\n    \n    for (int i = 0; i < 16; i++) {\n        final_count += counts[i];\n    }\n    \n    for (int i = simd_iters * simd_width; i < len; i++) {\n        if (brackets[i] == '(') final_count++;\n        else final_count--;\n        if (final_count < 0) return false;\n    }\n    \n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const size_t len = brackets.length();\n    const size_t simd_width = 16;\n    const size_t vec_size = (len + simd_width - 1) / simd_width * simd_width;\n    \n    alignas(16) char padded[vec_size];\n    memset(padded, 0, vec_size);\n    memcpy(padded, brackets.c_str(), len);\n\n    __m128i count = _mm_setzero_si128();\n    __m128i one = _mm_set1_epi8(1);\n    __m128i negone = _mm_set1_epi8(-1);\n    \n    for (size_t i = 0; i < vec_size; i += simd_width) {\n        __m128i chars = _mm_load_si128((__m128i*)(padded + i));\n        __m128i open_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(chars, _mm_set1_epi8(')'));\n        \n        __m128i open_inc = _mm_and_si128(open_mask, one);\n        __m128i close_inc = _mm_and_si128(close_mask, negone);\n        \n        count = _mm_add_epi8(count, open_inc);\n        count = _mm_add_epi8(count, close_inc);\n        \n        alignas(16) char counts[16];\n        _mm_store_si128((__m128i*)counts, count);\n        \n        for (int j = 0; j < 16; j++) {\n            if (counts[j] < 0) return false;\n        }\n    }\n    \n    alignas(16) char final_counts[16];\n    _mm_store_si128((__m128i*)final_counts, count);\n    \n    int total = 0;\n    for (int i = 0; i < 16; i++) {\n        total += final_counts[i];\n    }\n    \n    return total == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const int len = brackets.length();\n    const int simd_width = 16;\n    const int simd_iters = len / simd_width;\n    \n    __m128i count = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int i = 0; i < simd_iters; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)(brackets.data() + i * simd_width));\n        __m128i open_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8(')'));\n        \n        __m128i open_count = _mm_and_si128(open_mask, ones);\n        __m128i close_count = _mm_and_si128(close_mask, ones);\n        \n        count = _mm_add_epi8(count, open_count);\n        count = _mm_sub_epi8(count, close_count);\n        \n        __m128i neg_check = _mm_cmplt_epi8(count, zeros);\n        if (_mm_movemask_epi8(neg_check)) {\n            return false;\n        }\n    }\n    \n    int final_count = 0;\n    char counts[16];\n    _mm_storeu_si128((__m128i*)counts, count);\n    \n    for (int i = 0; i < 16; i++) {\n        final_count += counts[i];\n    }\n    \n    for (int i = simd_iters * simd_width; i < len; i++) {\n        if (brackets[i] == '(') final_count++;\n        else final_count--;\n        if (final_count < 0) return false;\n    }\n    \n    return final_count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const int len = brackets.length();\n    const int simd_width = 16;\n    const int simd_iters = len / simd_width;\n    \n    __m128i count = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i neg_ones = _mm_set1_epi8(-1);\n    \n    for (int i = 0; i < simd_iters; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)(brackets.data() + i * simd_width));\n        __m128i open_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8(')'));\n        \n        __m128i open_count = _mm_and_si128(open_mask, ones);\n        __m128i close_count = _mm_and_si128(close_mask, neg_ones);\n        \n        count = _mm_add_epi8(count, open_count);\n        count = _mm_add_epi8(count, close_count);\n        \n        __m128i neg_check = _mm_cmplt_epi8(count, _mm_setzero_si128());\n        if (_mm_movemask_epi8(neg_check)) {\n            return false;\n        }\n    }\n    \n    int running_sum = 0;\n    char counts[16];\n    _mm_storeu_si128((__m128i*)counts, count);\n    \n    for (int i = 0; i < 16; i++) {\n        running_sum += counts[i];\n    }\n    \n    for (int i = simd_iters * simd_width; i < len; i++) {\n        if (brackets[i] == '(') running_sum++;\n        else running_sum--;\n        if (running_sum < 0) return false;\n    }\n    \n    return running_sum == 0;\n}\n```"}
{"task_id": "SimdBench_90_SSE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    if (brackets.empty()) return true;\n    if (brackets.length() % 2) return false;\n\n    const int len = brackets.length();\n    const int simd_width = 16;\n    const int simd_iters = len / simd_width;\n    \n    __m128i count = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi8(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int i = 0; i < simd_iters; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)(brackets.data() + i * simd_width));\n        __m128i open_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8('('));\n        __m128i close_mask = _mm_cmpeq_epi8(data, _mm_set1_epi8(')'));\n        \n        __m128i open_count = _mm_and_si128(open_mask, ones);\n        __m128i close_count = _mm_and_si128(close_mask, ones);\n        \n        count = _mm_add_epi8(count, open_count);\n        count = _mm_sub_epi8(count, close_count);\n        \n        __m128i neg_check = _mm_cmplt_epi8(count, zeros);\n        if (_mm_movemask_epi8(neg_check)) {\n            return false;\n        }\n    }\n    \n    int running_sum = 0;\n    char counts[16];\n    _mm_storeu_si128((__m128i*)counts, count);\n    \n    for (int i = 0; i < 16; i++) {\n        running_sum += counts[i];\n    }\n    \n    for (int i = simd_iters * simd_width; i < len; i++) {\n        if (brackets[i] == '(') running_sum++;\n        else running_sum--;\n        if (running_sum < 0) return false;\n    }\n    \n    return running_sum == 0;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n    \n    size_t i = 0;\n    for (; i + 3 < n; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 indices = _mm_set_ps(i + 4, i + 3, i + 2, i + 1);\n        __m128 derivatives = _mm_mul_ps(coeffs, indices);\n        _mm_storeu_ps(&result[i], derivatives);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= xs.size() - 1; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 indices = _mm_set_ps(i + 4, i + 3, i + 2, i + 1);\n        __m128 products = _mm_mul_ps(coeffs, indices);\n        _mm_storeu_ps(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= xs.size() - 1; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 indices = _mm_set_ps(i + 4, i + 3, i + 2, i + 1);\n        __m128 products = _mm_mul_ps(coeffs, indices);\n        _mm_storeu_ps(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n    \n    size_t i = 0;\n    for (; i + 3 < n; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 multipliers = _mm_set_ps(i + 4, i + 3, i + 2, i + 1);\n        __m128 products = _mm_mul_ps(coeffs, multipliers);\n        _mm_storeu_ps(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SSE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    int i = 0;\n    for (; i + 4 <= xs.size() - 1; i += 4) {\n        __m128 coeffs = _mm_loadu_ps(&xs[i + 1]);\n        __m128 indices = _mm_set_ps(i + 4, i + 3, i + 2, i + 1);\n        __m128 products = _mm_mul_ps(coeffs, indices);\n        _mm_storeu_ps(&result[i], products);\n    }\n\n    // Handle remaining elements\n    for (; i < xs.size() - 1; i++) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n    \n    // Convert string to lowercase\n    for(int i = 0; i < len; i++) {\n        s[i] = tolower(s[i]);\n    }\n    \n    // Process 16 chars at a time using SSE\n    __m128i vowels_a = _mm_set1_epi8('a');\n    __m128i vowels_e = _mm_set1_epi8('e'); \n    __m128i vowels_i = _mm_set1_epi8('i');\n    __m128i vowels_o = _mm_set1_epi8('o');\n    __m128i vowels_u = _mm_set1_epi8('u');\n    \n    int i;\n    for(i = 0; i + 16 <= len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n        \n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        unsigned mask = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining characters\n    for(; i < len; i++) {\n        if(s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || \n           s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n    \n    // Check if last char is 'y'\n    if(len > 0 && s[len-1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n    \n    // Handle empty string\n    if (len == 0) return 0;\n\n    // Convert string to lowercase\n    for(int i = 0; i < len; i++) {\n        s[i] = tolower(s[i]);\n    }\n\n    // Set up vowel masks\n    __m128i vowels_a = _mm_set1_epi8('a');\n    __m128i vowels_e = _mm_set1_epi8('e'); \n    __m128i vowels_i = _mm_set1_epi8('i');\n    __m128i vowels_o = _mm_set1_epi8('o');\n    __m128i vowels_u = _mm_set1_epi8('u');\n    \n    int i;\n    for(i = 0; i <= len-16; i += 16) {\n        // Load 16 bytes\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        // Compare with each vowel\n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n        \n        // Combine results\n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        // Count matches\n        int mask = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining characters\n    for(; i < len; i++) {\n        char c = s[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Handle 'y' at end of word\n    if(len > 0 && s[len-1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    if (len == 0) return 0;\n    \n    int count = 0;\n    int i = 0;\n    \n    // Create vowel masks\n    __m128i vowel_a = _mm_set1_epi8('a');\n    __m128i vowel_e = _mm_set1_epi8('e'); \n    __m128i vowel_i = _mm_set1_epi8('i');\n    __m128i vowel_o = _mm_set1_epi8('o');\n    __m128i vowel_u = _mm_set1_epi8('u');\n    __m128i vowel_A = _mm_set1_epi8('A');\n    __m128i vowel_E = _mm_set1_epi8('E');\n    __m128i vowel_I = _mm_set1_epi8('I');\n    __m128i vowel_O = _mm_set1_epi8('O');\n    __m128i vowel_U = _mm_set1_epi8('U');\n\n    // Process 16 bytes at a time\n    for (; i + 16 <= len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        __m128i mask_a = _mm_cmpeq_epi8(str, vowel_a);\n        __m128i mask_e = _mm_cmpeq_epi8(str, vowel_e);\n        __m128i mask_i = _mm_cmpeq_epi8(str, vowel_i);\n        __m128i mask_o = _mm_cmpeq_epi8(str, vowel_o);\n        __m128i mask_u = _mm_cmpeq_epi8(str, vowel_u);\n        __m128i mask_A = _mm_cmpeq_epi8(str, vowel_A);\n        __m128i mask_E = _mm_cmpeq_epi8(str, vowel_E);\n        __m128i mask_I = _mm_cmpeq_epi8(str, vowel_I);\n        __m128i mask_O = _mm_cmpeq_epi8(str, vowel_O);\n        __m128i mask_U = _mm_cmpeq_epi8(str, vowel_U);\n\n        __m128i result = _mm_or_si128(mask_a, mask_e);\n        result = _mm_or_si128(result, mask_i);\n        result = _mm_or_si128(result, mask_o);\n        result = _mm_or_si128(result, mask_u);\n        result = _mm_or_si128(result, mask_A);\n        result = _mm_or_si128(result, mask_E);\n        result = _mm_or_si128(result, mask_I);\n        result = _mm_or_si128(result, mask_O);\n        result = _mm_or_si128(result, mask_U);\n\n        int mask = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask);\n    }\n\n    // Handle remaining bytes and check for 'y'/'Y' at end\n    for (; i < len; i++) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check if word ends with 'y' or 'Y'\n    if (len > 0 && (s[len-1] == 'y' || s[len-1] == 'Y')) {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n    \n    // Convert string to lowercase\n    for(int i = 0; i < len; i++) {\n        s[i] = tolower(s[i]);\n    }\n    \n    // Handle empty string\n    if(len == 0) return 0;\n    \n    // Check if y is at end\n    if(s[len-1] == 'y') count++;\n    \n    // Pad string length to multiple of 16\n    int padded_len = ((len + 15) / 16) * 16;\n    char* padded_str = (char*)_mm_malloc(padded_len, 16);\n    memset(padded_str, 0, padded_len);\n    memcpy(padded_str, s.c_str(), len);\n    \n    // Create vowel masks\n    __m128i vowel_a = _mm_set1_epi8('a');\n    __m128i vowel_e = _mm_set1_epi8('e'); \n    __m128i vowel_i = _mm_set1_epi8('i');\n    __m128i vowel_o = _mm_set1_epi8('o');\n    __m128i vowel_u = _mm_set1_epi8('u');\n    \n    for(int i = 0; i < padded_len; i += 16) {\n        __m128i str = _mm_load_si128((__m128i*)(padded_str + i));\n        \n        __m128i mask_a = _mm_cmpeq_epi8(str, vowel_a);\n        __m128i mask_e = _mm_cmpeq_epi8(str, vowel_e);\n        __m128i mask_i = _mm_cmpeq_epi8(str, vowel_i);\n        __m128i mask_o = _mm_cmpeq_epi8(str, vowel_o);\n        __m128i mask_u = _mm_cmpeq_epi8(str, vowel_u);\n        \n        __m128i mask = _mm_or_si128(mask_a, mask_e);\n        mask = _mm_or_si128(mask, mask_i);\n        mask = _mm_or_si128(mask, mask_o);\n        mask = _mm_or_si128(mask, mask_u);\n        \n        int mask_bits = _mm_movemask_epi8(mask);\n        count += _mm_popcnt_u32(mask_bits);\n    }\n    \n    _mm_free(padded_str);\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SSE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int len = s.length();\n    int count = 0;\n    \n    // Handle empty string\n    if (len == 0) return 0;\n    \n    // Convert to lowercase\n    for(int i = 0; i < len; i++) {\n        s[i] = tolower(s[i]);\n    }\n\n    // Process 16 chars at a time\n    __m128i vowels_a = _mm_set1_epi8('a');\n    __m128i vowels_e = _mm_set1_epi8('e'); \n    __m128i vowels_i = _mm_set1_epi8('i');\n    __m128i vowels_o = _mm_set1_epi8('o');\n    __m128i vowels_u = _mm_set1_epi8('u');\n    \n    int i;\n    for(i = 0; i <= len-16; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n        \n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        int mask = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining characters\n    for(; i < len; i++) {\n        char c = s[i];\n        if(c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    // Handle 'y' at the end\n    if(len > 0 && s[len-1] == 'y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time\n    const int SIMD_WIDTH = 16;\n    int vectorized_len = len - (len % SIMD_WIDTH);\n    \n    for (int i = 0; i < vectorized_len; i += SIMD_WIDTH) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Create masks for uppercase letters (ASCII 65-90)\n        __m128i upper_bound = _mm_set1_epi8(90);\n        __m128i lower_bound = _mm_set1_epi8(65);\n        \n        // Check if characters are uppercase\n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(upper_bound, chars),\n            _mm_cmpgt_epi8(chars, lower_bound)\n        );\n        \n        // Zero out non-uppercase characters\n        chars = _mm_and_si128(chars, is_upper);\n        \n        // Sum the ASCII values\n        __m128i sum8 = _mm_sad_epu8(chars, _mm_setzero_si128());\n        sum += _mm_cvtsi128_si32(sum8) + _mm_cvtsi128_si32(_mm_srli_si128(sum8, 8));\n    }\n    \n    // Handle remaining characters\n    for (int i = vectorized_len; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    \n    // Process 16 characters at a time\n    const int SIMD_WIDTH = 16;\n    int vectorized_len = len & ~(SIMD_WIDTH-1);\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i upper_mask = _mm_set1_epi8(0x40); // ASCII 'A'-1\n    __m128i lower_mask = _mm_set1_epi8(0x5B); // ASCII 'Z'+1\n    \n    for(int i = 0; i < vectorized_len; i += SIMD_WIDTH) {\n        // Load 16 chars\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Check if chars are uppercase (between 'A' and 'Z')\n        __m128i greater = _mm_cmpgt_epi8(chars, upper_mask);\n        __m128i lesser = _mm_cmplt_epi8(chars, lower_mask);\n        __m128i is_upper = _mm_and_si128(greater, lesser);\n        \n        // Zero out non-uppercase chars\n        chars = _mm_and_si128(chars, is_upper);\n        \n        // Sum the bytes\n        __m128i sum16 = _mm_sad_epu8(chars, zero);\n        \n        // Extract and add the sums\n        sum += _mm_extract_epi16(sum16, 0) + _mm_extract_epi16(sum16, 4);\n    }\n    \n    // Handle remaining characters\n    for(int i = vectorized_len; i < len; i++) {\n        if(s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n    \n    int len = s.length();\n    int sum = 0;\n    \n    // Process 16 characters at a time\n    int vectorSize = 16;\n    int vectorCount = len / vectorSize;\n    \n    __m128i upperMask = _mm_set1_epi8(0x40);  // ASCII 'A'-1\n    __m128i lowerMask = _mm_set1_epi8(0x5B);  // ASCII 'Z'+1\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < vectorCount; i++) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i * vectorSize]);\n        \n        // Check if characters are uppercase (between 'A' and 'Z')\n        __m128i isGreater = _mm_cmpgt_epi8(chars, upperMask);\n        __m128i isLess = _mm_cmplt_epi8(chars, lowerMask);\n        __m128i isUpper = _mm_and_si128(isGreater, isLess);\n        \n        // Zero out non-uppercase characters\n        chars = _mm_and_si128(chars, isUpper);\n        \n        // Sum up the bytes\n        __m128i sum16 = _mm_sad_epu8(chars, zero);\n        sum += _mm_extract_epi16(sum16, 0) + _mm_extract_epi16(sum16, 4);\n    }\n    \n    // Handle remaining characters\n    for (int i = vectorCount * vectorSize; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    int len = s.length();\n    \n    if (len == 0) return 0;\n\n    // Process 16 characters at a time\n    const int SIMD_WIDTH = 16;\n    int aligned_len = len & ~(SIMD_WIDTH-1);\n    \n    __m128i upper_mask = _mm_set1_epi8(0x40); // '@' ASCII 64\n    __m128i lower_mask = _mm_set1_epi8(0x5B); // '[' ASCII 91\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < aligned_len; i += SIMD_WIDTH) {\n        // Load 16 chars\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Check if chars are uppercase (between '@' and '[')\n        __m128i gt_upper = _mm_cmpgt_epi8(chars, upper_mask);\n        __m128i lt_lower = _mm_cmplt_epi8(chars, lower_mask);\n        __m128i is_upper = _mm_and_si128(gt_upper, lt_lower);\n        \n        // Zero out non-uppercase chars\n        __m128i masked = _mm_and_si128(chars, is_upper);\n        \n        // Convert to 16-bit ints to avoid overflow in sum\n        __m128i sum_lo = _mm_unpacklo_epi8(masked, zero);\n        __m128i sum_hi = _mm_unpackhi_epi8(masked, zero);\n        \n        // Horizontal sum\n        sum_lo = _mm_add_epi16(sum_lo, sum_hi);\n        sum_lo = _mm_hadd_epi16(sum_lo, sum_lo);\n        sum_lo = _mm_hadd_epi16(sum_lo, sum_lo);\n        sum_lo = _mm_hadd_epi16(sum_lo, sum_lo);\n        \n        sum += _mm_extract_epi16(sum_lo, 0);\n    }\n    \n    // Handle remaining characters\n    for (int i = aligned_len; i < len; i++) {\n        if (s[i] > '@' && s[i] < '[') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SSE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n    \n    int sum = 0;\n    int len = s.length();\n    int vectorLen = len - (len % 16);\n    \n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i upper_mask = _mm_set1_epi8(0x40);\n    __m128i lower_mask = _mm_set1_epi8(0x5B);\n    \n    for (int i = 0; i < vectorLen; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        __m128i is_upper = _mm_and_si128(\n            _mm_cmpgt_epi8(chars, upper_mask),\n            _mm_cmplt_epi8(chars, lower_mask)\n        );\n        \n        chars = _mm_and_si128(chars, is_upper);\n        sum_vec = _mm_add_epi8(sum_vec, chars);\n    }\n    \n    alignas(16) char sums[16];\n    _mm_store_si128((__m128i*)sums, sum_vec);\n    \n    for (int i = 0; i < 16; i++) {\n        sum += (unsigned char)sums[i];\n    }\n    \n    for (int i = vectorLen; i < len; i++) {\n        if (s[i] >= 'A' && s[i] <= 'Z') {\n            sum += s[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int n = arr.size();\n    const int simd_size = 4;\n    const int aligned_size = (n + simd_size - 1) & ~(simd_size - 1);\n    \n    std::vector<int> padded(aligned_size, INT_MAX);\n    std::copy(arr.begin(), arr.end(), padded.begin());\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    __m128i min_idx = _mm_set1_epi32(INT_MAX);\n    __m128i curr_idx = _mm_set_epi32(3,2,1,0);\n    __m128i idx_inc = _mm_set1_epi32(4);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        __m128i vals = _mm_loadu_si128((__m128i*)&padded[i]);\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(vals, _mm_set1_epi32(1)), _mm_setzero_si128());\n        \n        __m128i masked_vals = _mm_or_si128(\n            _mm_and_si128(is_even, vals),\n            _mm_andnot_si128(is_even, _mm_set1_epi32(INT_MAX))\n        );\n        \n        __m128i lt_mask = _mm_cmplt_epi32(masked_vals, min_val);\n        \n        min_val = _mm_or_si128(\n            _mm_and_si128(lt_mask, masked_vals),\n            _mm_andnot_si128(lt_mask, min_val)\n        );\n        \n        min_idx = _mm_or_si128(\n            _mm_and_si128(lt_mask, curr_idx),\n            _mm_andnot_si128(lt_mask, min_idx)\n        );\n        \n        curr_idx = _mm_add_epi32(curr_idx, idx_inc);\n    }\n    \n    alignas(16) int min_vals[4];\n    alignas(16) int min_indices[4];\n    \n    _mm_store_si128((__m128i*)min_vals, min_val);\n    _mm_store_si128((__m128i*)min_indices, min_idx);\n    \n    int smallest_val = INT_MAX;\n    int smallest_idx = INT_MAX;\n    \n    for(int i = 0; i < 4; i++) {\n        if(min_vals[i] < smallest_val) {\n            smallest_val = min_vals[i];\n            smallest_idx = min_indices[i];\n        }\n    }\n    \n    if(smallest_val == INT_MAX) return {};\n    return {smallest_val, smallest_idx};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n\n    const int n = arr.size();\n    const int simd_size = 4;\n    const int aligned_size = (n + simd_size - 1) & ~(simd_size - 1);\n    \n    std::vector<int> padded(aligned_size, INT_MAX);\n    std::copy(arr.begin(), arr.end(), padded.begin());\n\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    __m128i min_idx = _mm_set1_epi32(INT_MAX);\n    __m128i curr_idx = _mm_set_epi32(3,2,1,0);\n    __m128i idx_inc = _mm_set1_epi32(4);\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i vals = _mm_loadu_si128((__m128i*)&padded[i]);\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(vals, _mm_set1_epi32(1)), _mm_setzero_si128());\n        \n        // Set odd numbers to INT_MAX\n        vals = _mm_or_si128(_mm_and_si128(is_even, vals), \n                           _mm_andnot_si128(is_even, _mm_set1_epi32(INT_MAX)));\n\n        __m128i mask = _mm_cmplt_epi32(vals, min_val);\n        min_val = _mm_or_si128(_mm_and_si128(mask, vals),\n                              _mm_andnot_si128(mask, min_val));\n        min_idx = _mm_or_si128(_mm_and_si128(mask, curr_idx),\n                              _mm_andnot_si128(mask, min_idx));\n        curr_idx = _mm_add_epi32(curr_idx, idx_inc);\n    }\n\n    int min_vals[4], min_idxs[4];\n    _mm_storeu_si128((__m128i*)min_vals, min_val);\n    _mm_storeu_si128((__m128i*)min_idxs, min_idx);\n\n    int smallest_val = INT_MAX;\n    int smallest_idx = INT_MAX;\n\n    for (int i = 0; i < 4; i++) {\n        if (min_vals[i] < smallest_val) {\n            smallest_val = min_vals[i];\n            smallest_idx = min_idxs[i];\n        }\n    }\n\n    if (smallest_val == INT_MAX) return {};\n    return {smallest_val, smallest_idx};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int n = arr.size();\n    const int simd_size = 4;\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    __m128i min_idx = _mm_set1_epi32(INT_MAX);\n    __m128i increment = _mm_set_epi32(3,2,1,0);\n    __m128i four = _mm_set1_epi32(4);\n    \n    for (int i = 0; i < n; i += simd_size) {\n        __m128i curr_idx = _mm_add_epi32(_mm_set1_epi32(i), increment);\n        \n        // Load 4 elements or pad with INT_MAX\n        __m128i curr_val;\n        if (i + simd_size <= n) {\n            curr_val = _mm_loadu_si128((__m128i*)&arr[i]);\n        } else {\n            alignas(16) int pad[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n            for (int j = 0; j < n-i; j++) {\n                pad[j] = arr[i+j];\n            }\n            curr_val = _mm_load_si128((__m128i*)pad);\n        }\n        \n        // Check if values are even\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(curr_val, _mm_set1_epi32(1)), _mm_setzero_si128());\n        \n        // Update min value and index if current value is even and smaller\n        __m128i mask = _mm_and_si128(is_even, _mm_cmplt_epi32(curr_val, min_val));\n        min_val = _mm_or_si128(_mm_and_si128(mask, curr_val), _mm_andnot_si128(mask, min_val));\n        min_idx = _mm_or_si128(_mm_and_si128(mask, curr_idx), _mm_andnot_si128(mask, min_idx));\n    }\n    \n    // Find minimum across SIMD lanes\n    alignas(16) int vals[4], idxs[4];\n    _mm_store_si128((__m128i*)vals, min_val);\n    _mm_store_si128((__m128i*)idxs, min_idx);\n    \n    int min_value = INT_MAX;\n    int min_index = INT_MAX;\n    \n    for (int i = 0; i < 4; i++) {\n        if (vals[i] < min_value) {\n            min_value = vals[i];\n            min_index = idxs[i];\n        }\n    }\n    \n    if (min_value == INT_MAX) {\n        return {};\n    }\n    \n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int n = arr.size();\n    const int simd_size = 4;\n    const int aligned_size = (n + simd_size - 1) & ~(simd_size - 1);\n    \n    std::vector<int> padded(aligned_size, INT_MAX);\n    std::copy(arr.begin(), arr.end(), padded.begin());\n    \n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    __m128i min_idx = _mm_set1_epi32(INT_MAX);\n    __m128i curr_idx = _mm_set_epi32(3,2,1,0);\n    const __m128i idx_inc = _mm_set1_epi32(4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i vals = _mm_loadu_si128((__m128i*)&padded[i]);\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(vals, _mm_set1_epi32(1)), _mm_setzero_si128());\n        \n        // Set odd numbers to INT_MAX\n        vals = _mm_or_si128(_mm_and_si128(is_even, vals), \n                           _mm_andnot_si128(is_even, _mm_set1_epi32(INT_MAX)));\n        \n        __m128i lt_mask = _mm_cmplt_epi32(vals, min_val);\n        min_val = _mm_or_si128(_mm_and_si128(lt_mask, vals),\n                              _mm_andnot_si128(lt_mask, min_val));\n        min_idx = _mm_or_si128(_mm_and_si128(lt_mask, curr_idx),\n                              _mm_andnot_si128(lt_mask, min_idx));\n        \n        curr_idx = _mm_add_epi32(curr_idx, idx_inc);\n    }\n    \n    // Find minimum across SIMD lanes\n    int min_values[4], min_indices[4];\n    _mm_storeu_si128((__m128i*)min_values, min_val);\n    _mm_storeu_si128((__m128i*)min_indices, min_idx);\n    \n    int smallest_val = INT_MAX;\n    int smallest_idx = INT_MAX;\n    \n    for (int i = 0; i < 4; i++) {\n        if (min_values[i] < smallest_val) {\n            smallest_val = min_values[i];\n            smallest_idx = min_indices[i];\n        }\n    }\n    \n    if (smallest_val == INT_MAX) return {};\n    return {smallest_val, smallest_idx};\n}\n```"}
{"task_id": "SimdBench_94_SSE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) return {};\n    \n    const int n = arr.size();\n    const int simd_size = 4;\n    const int aligned_size = (n + simd_size - 1) & ~(simd_size - 1);\n    \n    std::vector<int> padded(aligned_size, INT_MAX);\n    std::copy(arr.begin(), arr.end(), padded.begin());\n    \n    __m128i min_even = _mm_set1_epi32(INT_MAX);\n    __m128i min_idx = _mm_set1_epi32(INT_MAX);\n    __m128i curr_idx = _mm_set_epi32(3,2,1,0);\n    __m128i four = _mm_set1_epi32(4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i vals = _mm_loadu_si128((__m128i*)&padded[i]);\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(vals, _mm_set1_epi32(1)), _mm_setzero_si128());\n        \n        __m128i masked_vals = _mm_or_si128(_mm_and_si128(is_even, vals), \n                                         _mm_andnot_si128(is_even, _mm_set1_epi32(INT_MAX)));\n                                         \n        __m128i lt_mask = _mm_cmplt_epi32(masked_vals, min_even);\n        min_even = _mm_or_si128(_mm_and_si128(lt_mask, masked_vals),\n                               _mm_andnot_si128(lt_mask, min_even));\n        min_idx = _mm_or_si128(_mm_and_si128(lt_mask, curr_idx),\n                              _mm_andnot_si128(lt_mask, min_idx));\n                              \n        curr_idx = _mm_add_epi32(curr_idx, four);\n    }\n    \n    alignas(16) int min_vals[4];\n    alignas(16) int idx_vals[4];\n    _mm_store_si128((__m128i*)min_vals, min_even);\n    _mm_store_si128((__m128i*)idx_vals, min_idx);\n    \n    int min_val = INT_MAX;\n    int min_index = INT_MAX;\n    \n    for (int i = 0; i < 4; i++) {\n        if (min_vals[i] < min_val) {\n            min_val = min_vals[i];\n            min_index = idx_vals[i];\n        }\n    }\n    \n    if (min_val == INT_MAX) return {};\n    return {min_val, min_index};\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Get max element to determine frequency array size\n    int max_element = *std::max_element(lst.begin(), lst.end());\n    \n    // Create frequency array initialized to 0\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Count frequencies\n    for (int i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\n    // Process 4 elements at a time using SSE\n    int result = -1;\n    int n = freq.size();\n    int simd_size = n - (n % 4); // Round down to multiple of 4\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        // Load 4 indices and frequencies\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i freqs = _mm_loadu_si128((__m128i*)&freq[i]);\n        \n        // Compare if frequency >= index\n        __m128i cmp = _mm_cmpgt_epi32(freqs, indices);\n        __m128i equal = _mm_cmpeq_epi32(freqs, indices);\n        cmp = _mm_or_si128(cmp, equal);\n        \n        // Get mask of valid elements\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask) {\n            // Find rightmost 1 in mask to get largest valid index\n            int pos = 31 - __builtin_clz(mask);\n            result = std::max(result, i + pos);\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_size; i < n; i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_element = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Count frequencies\n    for (int num : lst) {\n        freq[num]++;\n    }\n\n    // Process 4 elements at a time using SSE\n    int result = -1;\n    int size = freq.size();\n    int simd_size = size - (size % 4);\n    \n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        // Load 4 indices\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        // Load 4 frequencies\n        __m128i freqs = _mm_loadu_si128((__m128i*)&freq[i]);\n        \n        // Compare if frequency >= index\n        __m128i cmp = _mm_cmpgt_epi32(freqs, indices);\n        __m128i equal = _mm_cmpeq_epi32(freqs, indices);\n        cmp = _mm_or_si128(cmp, equal);\n        \n        // If any comparison is true\n        if (_mm_movemask_epi8(cmp)) {\n            // Find which elements passed the comparison\n            int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n            \n            // Update result with largest valid index\n            for (int j = 0; j < 4; j++) {\n                if (mask & (1 << j)) {\n                    result = std::max(result, i + j);\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_size; i < size; i++) {\n        if (freq[i] >= i) {\n            result = std::max(result, i);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_elem = lst[0];\n    for (int i = 1; i < n; i++) {\n        max_elem = std::max(max_elem, lst[i]);\n    }\n\n    // Initialize frequency array\n    std::vector<int> freq(max_elem + 1, 0);\n    for (int x : lst) {\n        freq[x]++;\n    }\n\n    // Process 4 elements at a time using SSE\n    int result = -1;\n    int i;\n    __m128i zero = _mm_setzero_si128();\n    \n    for (i = max_elem; i >= 4; i -= 4) {\n        // Load 4 frequencies\n        __m128i freqs = _mm_loadu_si128((__m128i*)&freq[i-3]);\n        \n        // Load 4 consecutive numbers\n        __m128i nums = _mm_set_epi32(i, i-1, i-2, i-3);\n        \n        // Compare if frequency >= number\n        __m128i cmp = _mm_cmpgt_epi32(freqs, zero);\n        __m128i cmp2 = _mm_cmpge_epi32(freqs, nums);\n        __m128i mask = _mm_and_si128(cmp, cmp2);\n        \n        // Check if any element satisfies condition\n        if (_mm_movemask_epi8(mask)) {\n            // Find the largest satisfying number\n            int m = _mm_movemask_epi8(mask);\n            for (int j = 3; j >= 0; j--) {\n                if (m & (0xF << (j*4))) {\n                    return i - (3-j);\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i > 0; i--) {\n        if (freq[i] >= i && freq[i] > 0) {\n            return i;\n        }\n    }\n    \n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_element = *std::max_element(lst.begin(), lst.end());\n    \n    // Create frequency array initialized to 0\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Count frequencies\n    for (int i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n    \n    // Process 4 elements at a time using SSE\n    int result = -1;\n    int size = freq.size();\n    int simd_size = size - (size % 4);\n    \n    __m128i indices = _mm_set_epi32(3, 2, 1, 0);\n    __m128i increment = _mm_set1_epi32(4);\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        // Load 4 frequencies\n        __m128i freqs = _mm_loadu_si128((__m128i*)&freq[i]);\n        \n        // Load corresponding indices\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        \n        // Compare if frequency >= index\n        __m128i cmp = _mm_cmpgt_epi32(freqs, curr_indices);\n        __m128i equal = _mm_cmpeq_epi32(freqs, curr_indices);\n        cmp = _mm_or_si128(cmp, equal);\n        \n        // Extract comparison results\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask) {\n            for (int j = 0; j < 4; j++) {\n                if (mask & (1 << j)) {\n                    if (freq[i + j] >= i + j && i + j > result) {\n                        result = i + j;\n                    }\n                }\n            }\n        }\n        \n        indices = _mm_add_epi32(indices, increment);\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_size; i < size; i++) {\n        if (freq[i] >= i && i > result) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SSE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) return -1;\n    \n    // Get max element to determine frequency array size\n    int max_element = *std::max_element(lst.begin(), lst.end());\n    \n    // Create frequency array initialized to 0\n    std::vector<int> freq(max_element + 1, 0);\n    \n    // Count frequencies\n    for (int i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\n    // Process 4 elements at a time using SSE\n    int result = -1;\n    int n = freq.size();\n    int simd_size = n - (n % 4); // Round down to multiple of 4\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        // Load 4 indices and frequencies\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i freqs = _mm_loadu_si128((__m128i*)&freq[i]);\n        \n        // Compare if frequency >= index\n        __m128i cmp = _mm_cmpgt_epi32(freqs, indices);\n        __m128i equal = _mm_cmpeq_epi32(freqs, indices);\n        cmp = _mm_or_si128(cmp, equal);\n        \n        // Get mask of valid elements\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask) {\n            // Find highest valid index\n            for (int j = 3; j >= 0; j--) {\n                if (mask & (1 << j)) {\n                    int idx = i + j;\n                    if (idx > result) {\n                        result = idx;\n                    }\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_size; i < n; i++) {\n        if (freq[i] >= i && i > result) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check sum <= w using SIMD\n    __m128i sum = _mm_setzero_si128();\n    for(int i = 0; i < n-3; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&q[i]);\n        sum = _mm_add_epi32(sum, v);\n    }\n    \n    // Handle remaining elements\n    int total = 0;\n    int remainder = n % 4;\n    int aligned = n - remainder;\n    \n    // Sum the SIMD results\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum);\n    total = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    // Add remaining elements\n    for(int i = aligned; i < n; i++) {\n        total += q[i];\n    }\n    \n    if(total > w) return false;\n    \n    // Check palindrome using SIMD\n    int half = n/2;\n    for(int i = 0; i < half-3; i += 4) {\n        __m128i front = _mm_loadu_si128((__m128i*)&q[i]);\n        __m128i back = _mm_setr_epi32(q[n-i-1], q[n-i-2], q[n-i-3], q[n-i-4]);\n        __m128i cmp = _mm_cmpeq_epi32(front, back);\n        if(_mm_movemask_epi8(cmp) != 0xFFFF) {\n            return false;\n        }\n    }\n    \n    // Check remaining elements for palindrome\n    for(int i = (half/4)*4; i < half; i++) {\n        if(q[i] != q[n-i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Check sum <= w\n    __m128i sum = _mm_setzero_si128();\n    for (int i = 0; i < n - 3; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&q[i]);\n        sum = _mm_add_epi32(sum, v);\n    }\n    \n    int total = 0;\n    int remainder = n % 4;\n    int aligned = n - remainder;\n    \n    // Horizontal sum of vector\n    sum = _mm_hadd_epi32(sum, sum);\n    sum = _mm_hadd_epi32(sum, sum);\n    total += _mm_cvtsi128_si32(sum);\n    \n    // Add remaining elements\n    for (int i = aligned; i < n; i++) {\n        total += q[i];\n    }\n    \n    if (total > w) return false;\n    \n    // Check palindrome\n    int i = 0, j = n-1;\n    while (i < j) {\n        __m128i v1 = _mm_set1_epi32(q[i]);\n        __m128i v2 = _mm_set1_epi32(q[j]); \n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        if (_mm_extract_epi32(cmp, 0) == 0) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n    \n    // Check if balanced using SSE\n    int iterations = n/4;\n    int remainder = n%4;\n    bool balanced = true;\n    \n    for (int i = 0; i < iterations; i++) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)&q[i*4]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&q[n-4-i*4]);\n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        if (_mm_movemask_ps(_mm_castsi128_ps(cmp)) != 0xF) {\n            balanced = false;\n            break;\n        }\n    }\n    \n    // Check remaining elements\n    for (int i = iterations*4; i < iterations*4 + remainder; i++) {\n        if (q[i] != q[n-1-(i-iterations*4)]) {\n            balanced = false;\n            break;\n        }\n    }\n    \n    // Calculate sum using SSE\n    __m128i sum_vec = _mm_setzero_si128();\n    for (int i = 0; i < iterations; i++) {\n        __m128i v = _mm_loadu_si128((__m128i*)&q[i*4]);\n        sum_vec = _mm_add_epi32(sum_vec, v);\n    }\n    \n    // Horizontal sum of vector\n    int sum = 0;\n    int* temp = (int*)&sum_vec;\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n    \n    // Add remaining elements\n    for (int i = iterations*4; i < n; i++) {\n        sum += q[i];\n    }\n    \n    return balanced && sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    if (n == 0) return false;\n    \n    // Check sum <= w\n    __m128i sum = _mm_setzero_si128();\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&q[i]);\n        sum = _mm_add_epi32(sum, v);\n    }\n    \n    int total = 0;\n    int* s = (int*)&sum;\n    total = s[0] + s[1] + s[2] + s[3];\n    \n    // Add remaining elements\n    for (; i < n; i++) {\n        total += q[i];\n    }\n    \n    if (total > w) return false;\n    \n    // Check palindrome\n    int left = 0;\n    int right = n-1;\n    \n    while (left < right) {\n        __m128i v1 = _mm_set1_epi32(q[left]);\n        __m128i v2 = _mm_set1_epi32(q[right]);\n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        if (_mm_extract_epi32(cmp, 0) == 0) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SSE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int size = q.size();\n    \n    // Handle single element case\n    if (size == 1) {\n        return q[0] <= w;\n    }\n\n    // Check if balanced using SSE\n    int iterations = size / 4;\n    int remainder = size % 4;\n    \n    __m128i sum = _mm_setzero_si128();\n    \n    // Calculate sum using SSE\n    for (int i = 0; i < iterations * 4; i += 4) {\n        __m128i v = _mm_loadu_si128((__m128i*)&q[i]);\n        sum = _mm_add_epi32(sum, v);\n    }\n    \n    // Horizontal sum\n    sum = _mm_hadd_epi32(sum, sum);\n    sum = _mm_hadd_epi32(sum, sum);\n    int total = _mm_cvtsi128_si32(sum);\n    \n    // Add remaining elements\n    for (int i = iterations * 4; i < size; i++) {\n        total += q[i];\n    }\n    \n    // Check if sum exceeds weight\n    if (total > w) {\n        return false;\n    }\n    \n    // Check if palindrome using SSE\n    int half = size / 2;\n    for (int i = 0; i < half; i += 4) {\n        int remaining = half - i;\n        int chunk = remaining >= 4 ? 4 : remaining;\n        \n        __m128i v1 = _mm_loadu_si128((__m128i*)&q[i]);\n        \n        // Load reversed elements\n        int reversed[4];\n        for (int j = 0; j < chunk; j++) {\n            reversed[j] = q[size - 1 - i - j];\n        }\n        __m128i v2 = _mm_loadu_si128((__m128i*)reversed);\n        \n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        // Check if all elements in chunk match\n        if ((mask & ((1 << chunk) - 1)) != ((1 << chunk) - 1)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Handle vectors smaller than 4 elements without SIMD\n    if (n < 4) {\n        for (int i = 0; i < n/2; i++) {\n            if (arr[i] != arr[n-1-i]) {\n                changes++;\n            }\n        }\n        return changes;\n    }\n\n    // Number of iterations needed for SIMD processing\n    int simd_iters = n/8;\n    \n    // Process 8 elements at a time using 2 SSE registers\n    for (int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        __m128i v1 = _mm_loadu_si128((__m128i*)&arr[i*4]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&arr[n-4-(i*4)]);\n        \n        // Reverse elements in v2\n        v2 = _mm_shuffle_epi32(v2, _MM_SHUFFLE(0,1,2,3));\n        \n        // Compare vectors\n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        \n        // Get mask of comparison\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        // Count number of unequal elements\n        changes += 4 - _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    int remaining_start = simd_iters * 4;\n    int remaining_end = n - remaining_start;\n    \n    for (int i = remaining_start; i < remaining_start + remaining_end/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Handle vectors smaller than 4 elements without SIMD\n    if (n < 4) {\n        for (int i = 0; i < n/2; i++) {\n            if (arr[i] != arr[n-1-i]) {\n                changes++;\n            }\n        }\n        return changes;\n    }\n\n    // Number of iterations needed for SIMD processing\n    int simd_iters = n/8;\n    \n    // Process 8 elements at a time using two __m128i registers\n    for (int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        __m128i front = _mm_loadu_si128((__m128i*)&arr[i*4]);\n        __m128i back = _mm_loadu_si128((__m128i*)&arr[n-4-(i*4)]);\n        \n        // Reverse elements in back register\n        back = _mm_shuffle_epi32(back, _MM_SHUFFLE(0,1,2,3));\n        \n        // Compare elements\n        __m128i cmp = _mm_cmpeq_epi32(front, back);\n        \n        // Get mask of comparison\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        // Count number of unequal elements\n        changes += 4 - _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    int rem_start = simd_iters * 4;\n    int rem_end = n - rem_start;\n    \n    for (int i = rem_start; i < rem_start + rem_end/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Handle vectors smaller than 4 elements without SIMD\n    if (n < 4) {\n        for (int i = 0; i < n/2; i++) {\n            if (arr[i] != arr[n-1-i]) {\n                changes++;\n            }\n        }\n        return changes;\n    }\n\n    // Number of iterations needed for SIMD processing\n    int simd_iters = n/8;\n    \n    // Process 8 elements at a time using two __m128i registers\n    for (int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        __m128i front = _mm_loadu_si128((__m128i*)&arr[i*4]);\n        __m128i back = _mm_loadu_si128((__m128i*)&arr[n-4-(i*4)]);\n        \n        // Reverse elements in back register\n        back = _mm_shuffle_epi32(back, _MM_SHUFFLE(0,1,2,3));\n        \n        // Compare elements\n        __m128i cmp = _mm_cmpeq_epi32(front, back);\n        \n        // Get mask of comparison\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        // Count number of unequal elements\n        changes += 4 - _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    int rem_start = simd_iters * 4;\n    int rem_end = n - rem_start;\n    \n    for (int i = rem_start; i < rem_start + rem_end/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Handle vectors smaller than 4 elements without SIMD\n    if (n < 4) {\n        for (int i = 0; i < n/2; i++) {\n            if (arr[i] != arr[n-1-i]) {\n                changes++;\n            }\n        }\n        return changes;\n    }\n\n    // Number of iterations needed for SIMD processing\n    int simd_iters = n/8;\n    \n    // Process 4 pairs at a time using SSE\n    for (int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        __m128i v1 = _mm_loadu_si128((__m128i*)&arr[i*4]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&arr[n-4-(i*4)]);\n        \n        // Reverse elements from end\n        v2 = _mm_shuffle_epi32(v2, _MM_SHUFFLE(0,1,2,3));\n        \n        // Compare elements\n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        \n        // Get mask of comparison results\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        // Count number of unequal elements\n        changes += 4 - _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_iters*4; i < n/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SSE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Handle vectors smaller than 4 elements without SIMD\n    if (n < 4) {\n        for (int i = 0; i < n/2; i++) {\n            if (arr[i] != arr[n-1-i]) {\n                changes++;\n            }\n        }\n        return changes;\n    }\n\n    // Number of iterations needed for SIMD processing\n    int simd_iters = n/8;\n    \n    // Process 4 pairs at a time using SSE\n    for (int i = 0; i < simd_iters; i++) {\n        // Load 4 elements from start and end\n        __m128i v1 = _mm_loadu_si128((__m128i*)&arr[i*4]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&arr[n-4-(i*4)]);\n        \n        // Reverse elements from end\n        v2 = _mm_shuffle_epi32(v2, _MM_SHUFFLE(0,1,2,3));\n        \n        // Compare elements\n        __m128i cmp = _mm_cmpeq_epi32(v1, v2);\n        \n        // Get mask of comparisons\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        // Count number of unequal elements\n        changes += 4 - _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (int i = simd_iters*4; i < n/2; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    // Process 16 characters at a time using SSE\n    const size_t simd_size = 16;\n    \n    // Calculate total chars in lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        size_t simd_iterations = len / simd_size;\n        __m128i sum = _mm_setzero_si128();\n        \n        for (size_t i = 0; i < simd_iterations; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i * simd_size));\n            sum = _mm_add_epi8(sum, chars);\n        }\n        \n        // Handle remaining characters\n        for (size_t i = simd_iterations * simd_size; i < len; i++) {\n            total1 += ptr[i];\n        }\n        \n        // Add SIMD sum to total\n        alignas(16) char temp[16];\n        _mm_store_si128((__m128i*)temp, sum);\n        for (int i = 0; i < 16; i++) {\n            total1 += (unsigned char)temp[i];\n        }\n    }\n    \n    // Calculate total chars in lst2\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        size_t simd_iterations = len / simd_size;\n        __m128i sum = _mm_setzero_si128();\n        \n        for (size_t i = 0; i < simd_iterations; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i * simd_size));\n            sum = _mm_add_epi8(sum, chars);\n        }\n        \n        // Handle remaining characters\n        for (size_t i = simd_iterations * simd_size; i < len; i++) {\n            total2 += ptr[i];\n        }\n        \n        // Add SIMD sum to total\n        alignas(16) char temp[16];\n        _mm_store_si128((__m128i*)temp, sum);\n        for (int i = 0; i < 16; i++) {\n            total2 += (unsigned char)temp[i];\n        }\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    // Process 16 characters at a time using SSE\n    const int SIMD_WIDTH = 16;\n    \n    // Calculate total chars in lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        size_t simd_iters = len / SIMD_WIDTH;\n        __m128i sum = _mm_setzero_si128();\n        \n        for (size_t i = 0; i < simd_iters; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i * SIMD_WIDTH));\n            sum = _mm_add_epi8(sum, chars);\n        }\n        \n        // Handle remaining characters\n        for (size_t i = simd_iters * SIMD_WIDTH; i < len; i++) {\n            total1 += ptr[i];\n        }\n        \n        // Horizontal sum of SIMD registers\n        __m128i sum_hi = _mm_unpackhi_epi8(sum, _mm_setzero_si128());\n        __m128i sum_lo = _mm_unpacklo_epi8(sum, _mm_setzero_si128());\n        sum = _mm_add_epi16(sum_hi, sum_lo);\n        \n        sum_hi = _mm_unpackhi_epi16(sum, _mm_setzero_si128());\n        sum_lo = _mm_unpacklo_epi16(sum, _mm_setzero_si128());\n        sum = _mm_add_epi32(sum_hi, sum_lo);\n        \n        int32_t tmp[4];\n        _mm_storeu_si128((__m128i*)tmp, sum);\n        total1 += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n    \n    // Calculate total chars in lst2\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        size_t simd_iters = len / SIMD_WIDTH;\n        __m128i sum = _mm_setzero_si128();\n        \n        for (size_t i = 0; i < simd_iters; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i * SIMD_WIDTH));\n            sum = _mm_add_epi8(sum, chars);\n        }\n        \n        // Handle remaining characters\n        for (size_t i = simd_iters * SIMD_WIDTH; i < len; i++) {\n            total2 += ptr[i];\n        }\n        \n        // Horizontal sum of SIMD registers\n        __m128i sum_hi = _mm_unpackhi_epi8(sum, _mm_setzero_si128());\n        __m128i sum_lo = _mm_unpacklo_epi8(sum, _mm_setzero_si128());\n        sum = _mm_add_epi16(sum_hi, sum_lo);\n        \n        sum_hi = _mm_unpackhi_epi16(sum, _mm_setzero_si128());\n        sum_lo = _mm_unpacklo_epi16(sum, _mm_setzero_si128());\n        sum = _mm_add_epi32(sum_hi, sum_lo);\n        \n        int32_t tmp[4];\n        _mm_storeu_si128((__m128i*)tmp, sum);\n        total2 += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    // Process 16 characters at a time using SSE\n    const size_t simd_size = 16;\n    __m128i sum1 = _mm_setzero_si128();\n    __m128i sum2 = _mm_setzero_si128();\n\n    // Process first vector\n    for (const auto& str : lst1) {\n        const char* ptr = str.c_str();\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 chars at a time\n        for (; i + simd_size <= len; i += simd_size) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr + i));\n            sum1 = _mm_add_epi8(sum1, chars);\n        }\n\n        // Handle remaining chars\n        for (; i < len; i++) {\n            total1 += static_cast<size_t>(ptr[i]);\n        }\n    }\n\n    // Process second vector\n    for (const auto& str : lst2) {\n        const char* ptr = str.c_str();\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 chars at a time\n        for (; i + simd_size <= len; i += simd_size) {\n            __m128i chars = _mm_loadu_si128(reinterpret_cast<const __m128i*>(ptr + i));\n            sum2 = _mm_add_epi8(sum2, chars);\n        }\n\n        // Handle remaining chars\n        for (; i < len; i++) {\n            total2 += static_cast<size_t>(ptr[i]);\n        }\n    }\n\n    // Sum up the SIMD results\n    alignas(16) char sum1_array[16];\n    alignas(16) char sum2_array[16];\n    _mm_store_si128(reinterpret_cast<__m128i*>(sum1_array), sum1);\n    _mm_store_si128(reinterpret_cast<__m128i*>(sum2_array), sum2);\n\n    for (int i = 0; i < 16; i++) {\n        total1 += static_cast<size_t>(sum1_array[i]);\n        total2 += static_cast<size_t>(sum2_array[i]);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    // Process 16 characters at a time using SSE\n    const size_t simd_size = 16;\n    \n    // Calculate total chars in lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        // Process 16 chars at a time\n        while (len >= simd_size) {\n            __m128i chars = _mm_loadu_si128((__m128i*)ptr);\n            __m128i count = _mm_set1_epi8(1);\n            __m128i sum = _mm_sad_epu8(chars, _mm_setzero_si128());\n            total1 += _mm_cvtsi128_si32(sum) + _mm_cvtsi128_si32(_mm_srli_si128(sum, 8));\n            ptr += simd_size;\n            len -= simd_size;\n        }\n        \n        // Handle remaining chars\n        while (len > 0) {\n            total1++;\n            ptr++;\n            len--;\n        }\n    }\n\n    // Calculate total chars in lst2 \n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        while (len >= simd_size) {\n            __m128i chars = _mm_loadu_si128((__m128i*)ptr);\n            __m128i count = _mm_set1_epi8(1);\n            __m128i sum = _mm_sad_epu8(chars, _mm_setzero_si128());\n            total2 += _mm_cvtsi128_si32(sum) + _mm_cvtsi128_si32(_mm_srli_si128(sum, 8));\n            ptr += simd_size;\n            len -= simd_size;\n        }\n        \n        while (len > 0) {\n            total2++;\n            ptr++;\n            len--;\n        }\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SSE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n    \n    // Process 16 characters at a time using SSE\n    const int SIMD_WIDTH = 16;\n    \n    // Calculate total chars in lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        size_t simd_iters = len / SIMD_WIDTH;\n        size_t remainder = len % SIMD_WIDTH;\n        \n        __m128i sum = _mm_setzero_si128();\n        \n        for (size_t i = 0; i < simd_iters; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i * SIMD_WIDTH));\n            sum = _mm_add_epi8(sum, chars);\n        }\n        \n        // Sum the bytes in the SSE register\n        __m128i high = _mm_unpackhi_epi8(sum, _mm_setzero_si128());\n        __m128i low = _mm_unpacklo_epi8(sum, _mm_setzero_si128());\n        __m128i added = _mm_add_epi16(high, low);\n        \n        int32_t temp[4];\n        _mm_storeu_si128((__m128i*)temp, added);\n        total1 += temp[0] + temp[1] + temp[2] + temp[3];\n        \n        // Handle remaining characters\n        for (size_t i = len - remainder; i < len; i++) {\n            total1 += ptr[i];\n        }\n    }\n    \n    // Calculate total chars in lst2\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        const char* ptr = str.c_str();\n        \n        size_t simd_iters = len / SIMD_WIDTH;\n        size_t remainder = len % SIMD_WIDTH;\n        \n        __m128i sum = _mm_setzero_si128();\n        \n        for (size_t i = 0; i < simd_iters; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i * SIMD_WIDTH));\n            sum = _mm_add_epi8(sum, chars);\n        }\n        \n        __m128i high = _mm_unpackhi_epi8(sum, _mm_setzero_si128());\n        __m128i low = _mm_unpacklo_epi8(sum, _mm_setzero_si128());\n        __m128i added = _mm_add_epi16(high, low);\n        \n        int32_t temp[4];\n        _mm_storeu_si128((__m128i*)temp, added);\n        total2 += temp[0] + temp[1] + temp[2] + temp[3];\n        \n        for (size_t i = len - remainder; i < len; i++) {\n            total2 += ptr[i];\n        }\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    __m128d vec_x = _mm_set1_pd(x);\n    __m128d vec_n = _mm_set1_pd(n);\n    __m128d result = _mm_set1_pd(1.0);\n    \n    while (result.m128d_f64[0] <= x) {\n        result = _mm_mul_pd(result, vec_n);\n        if (result.m128d_f64[0] == x) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    __m128d vec_x = _mm_set1_pd(x);\n    __m128d vec_n = _mm_set1_pd(n);\n    __m128d result = _mm_set1_pd(1.0);\n    \n    while (result[0] < x) {\n        result = _mm_mul_pd(result, vec_n);\n    }\n    \n    return result[0] == x;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    __m128d vec_x = _mm_set1_pd(x);\n    __m128d vec_n = _mm_set1_pd(n);\n    __m128d result = _mm_set1_pd(1.0);\n    \n    while (result[0] < x) {\n        result = _mm_mul_pd(result, vec_n);\n    }\n    \n    return result[0] == x;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    __m128d vec_x = _mm_set1_pd(x);\n    __m128d vec_n = _mm_set1_pd(n);\n    __m128d result = _mm_set1_pd(1.0);\n    \n    while (result.m128d_f64[0] <= x) {\n        result = _mm_mul_pd(result, vec_n);\n        if (result.m128d_f64[0] == x) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SSE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    __m128d vec_x = _mm_set1_pd(x);\n    __m128d vec_n = _mm_set1_pd(n);\n    __m128d vec_result = _mm_set1_pd(1.0);\n    \n    while (vec_result.m128d_f64[0] <= x) {\n        vec_result = _mm_mul_pd(vec_result, vec_n);\n        if (vec_result.m128d_f64[0] == x) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int count = 0;\n    int len = num.length();\n    \n    // Create masks for prime hex digits (2,3,5,7,B,D)\n    __m128i prime_2 = _mm_set1_epi8('2');\n    __m128i prime_3 = _mm_set1_epi8('3'); \n    __m128i prime_5 = _mm_set1_epi8('5');\n    __m128i prime_7 = _mm_set1_epi8('7');\n    __m128i prime_B = _mm_set1_epi8('B');\n    __m128i prime_D = _mm_set1_epi8('D');\n\n    // Process 16 chars at a time\n    for (int i = 0; i < len - 15; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(num.c_str() + i));\n        \n        __m128i cmp2 = _mm_cmpeq_epi8(data, prime_2);\n        __m128i cmp3 = _mm_cmpeq_epi8(data, prime_3);\n        __m128i cmp5 = _mm_cmpeq_epi8(data, prime_5);\n        __m128i cmp7 = _mm_cmpeq_epi8(data, prime_7);\n        __m128i cmpB = _mm_cmpeq_epi8(data, prime_B);\n        __m128i cmpD = _mm_cmpeq_epi8(data, prime_D);\n        \n        __m128i result = _mm_or_si128(cmp2, cmp3);\n        result = _mm_or_si128(result, cmp5);\n        result = _mm_or_si128(result, cmp7);\n        result = _mm_or_si128(result, cmpB);\n        result = _mm_or_si128(result, cmpD);\n        \n        unsigned mask = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; i++) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if(num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Create mask for prime hex digits (2,3,5,7,B,D)\n    __m128i primes = _mm_setr_epi8('2','3','5','7','B','D',0,0,0,0,0,0,0,0,0,0);\n    __m128i num_chars;\n    \n    for(int i = 0; i < len; i += 16) {\n        // Load 16 bytes from input string\n        if(i + 16 <= len) {\n            num_chars = _mm_loadu_si128((__m128i*)(num.c_str() + i));\n        } else {\n            char temp[16] = {0};\n            memcpy(temp, num.c_str() + i, len - i);\n            num_chars = _mm_loadu_si128((__m128i*)temp);\n        }\n        \n        // Compare each byte with each prime digit\n        for(int j = 0; j < 6; j++) {\n            __m128i prime = _mm_set1_epi8(((char*)&primes)[j]);\n            __m128i cmp = _mm_cmpeq_epi8(num_chars, prime);\n            int mask = _mm_movemask_epi8(cmp);\n            \n            // Count matches\n            while(mask) {\n                count += mask & 1;\n                mask >>= 1;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if(num.empty()) return 0;\n    \n    const int len = num.length();\n    int count = 0;\n    \n    // Create masks for prime hex digits\n    __m128i prime_2357 = _mm_set1_epi8(0);\n    __m128i prime_bd = _mm_set1_epi8(0);\n    \n    prime_2357 = _mm_setr_epi8('2','3','5','7',0,0,0,0,0,0,0,0,0,0,0,0);\n    prime_bd = _mm_setr_epi8('B','D',0,0,0,0,0,0,0,0,0,0,0,0,0,0);\n    \n    for(int i = 0; i < len; i += 16) {\n        __m128i chunk;\n        if(i + 16 <= len) {\n            chunk = _mm_loadu_si128((__m128i*)(num.c_str() + i));\n        } else {\n            char padded[16] = {0};\n            memcpy(padded, num.c_str() + i, len - i);\n            chunk = _mm_loadu_si128((__m128i*)padded);\n        }\n        \n        // Compare with prime digits\n        __m128i match1 = _mm_cmpeq_epi8(chunk, prime_2357);\n        __m128i match2 = _mm_cmpeq_epi8(chunk, _mm_shuffle_epi32(prime_2357, _MM_SHUFFLE(1,0,3,2)));\n        __m128i match3 = _mm_cmpeq_epi8(chunk, prime_bd);\n        __m128i match4 = _mm_cmpeq_epi8(chunk, _mm_shuffle_epi32(prime_bd, _MM_SHUFFLE(1,0,3,2)));\n        \n        // Combine matches\n        __m128i result = _mm_or_si128(match1, match2);\n        result = _mm_or_si128(result, match3);\n        result = _mm_or_si128(result, match4);\n        \n        // Get mask of matches\n        int mask = _mm_movemask_epi8(result);\n        \n        // Count set bits in mask\n        if(i + 16 <= len) {\n            count += _mm_popcnt_u32(mask);\n        } else {\n            count += _mm_popcnt_u32(mask & ((1 << (len - i)) - 1));\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Create masks for prime hex digits (2,3,5,7,B,D)\n    __m128i prime_2 = _mm_set1_epi8('2');\n    __m128i prime_3 = _mm_set1_epi8('3'); \n    __m128i prime_5 = _mm_set1_epi8('5');\n    __m128i prime_7 = _mm_set1_epi8('7');\n    __m128i prime_B = _mm_set1_epi8('B');\n    __m128i prime_D = _mm_set1_epi8('D');\n\n    for (int i = 0; i < len; i += 16) {\n        __m128i chunk;\n        if (i + 16 <= len) {\n            chunk = _mm_loadu_si128((__m128i*)(num.c_str() + i));\n        } else {\n            char padded[16] = {0};\n            memcpy(padded, num.c_str() + i, len - i);\n            chunk = _mm_loadu_si128((__m128i*)padded);\n        }\n\n        __m128i match_2 = _mm_cmpeq_epi8(chunk, prime_2);\n        __m128i match_3 = _mm_cmpeq_epi8(chunk, prime_3);\n        __m128i match_5 = _mm_cmpeq_epi8(chunk, prime_5);\n        __m128i match_7 = _mm_cmpeq_epi8(chunk, prime_7);\n        __m128i match_B = _mm_cmpeq_epi8(chunk, prime_B);\n        __m128i match_D = _mm_cmpeq_epi8(chunk, prime_D);\n\n        __m128i result = _mm_or_si128(match_2, match_3);\n        result = _mm_or_si128(result, match_5);\n        result = _mm_or_si128(result, match_7);\n        result = _mm_or_si128(result, match_B);\n        result = _mm_or_si128(result, match_D);\n\n        int mask = _mm_movemask_epi8(result);\n        \n        if (i + 16 > len) {\n            mask &= (1 << (len - i)) - 1;\n        }\n        \n        count += _mm_popcnt_u32(mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SSE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Create masks for prime hex digits (2,3,5,7,B,D)\n    __m128i prime_2 = _mm_set1_epi8('2');\n    __m128i prime_3 = _mm_set1_epi8('3'); \n    __m128i prime_5 = _mm_set1_epi8('5');\n    __m128i prime_7 = _mm_set1_epi8('7');\n    __m128i prime_B = _mm_set1_epi8('B');\n    __m128i prime_D = _mm_set1_epi8('D');\n\n    for (int i = 0; i < len; i += 16) {\n        // Load 16 bytes from string\n        __m128i data;\n        if (i + 16 <= len) {\n            data = _mm_loadu_si128((__m128i*)(num.c_str() + i));\n        } else {\n            char temp[16] = {0};\n            memcpy(temp, num.c_str() + i, len - i);\n            data = _mm_loadu_si128((__m128i*)temp);\n        }\n\n        // Compare with each prime hex digit\n        __m128i cmp2 = _mm_cmpeq_epi8(data, prime_2);\n        __m128i cmp3 = _mm_cmpeq_epi8(data, prime_3);\n        __m128i cmp5 = _mm_cmpeq_epi8(data, prime_5);\n        __m128i cmp7 = _mm_cmpeq_epi8(data, prime_7);\n        __m128i cmpB = _mm_cmpeq_epi8(data, prime_B);\n        __m128i cmpD = _mm_cmpeq_epi8(data, prime_D);\n\n        // Combine results\n        __m128i result = _mm_or_si128(cmp2, cmp3);\n        result = _mm_or_si128(result, cmp5);\n        result = _mm_or_si128(result, cmp7);\n        result = _mm_or_si128(result, cmpB);\n        result = _mm_or_si128(result, cmpD);\n\n        // Get mask of matches\n        int mask = _mm_movemask_epi8(result);\n\n        // Count set bits for remaining length\n        if (i + 16 <= len) {\n            count += _mm_popcnt_u32(mask);\n        } else {\n            count += _mm_popcnt_u32(mask & ((1 << (len - i)) - 1));\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length();\n    const int simdWidth = 16;\n    const int numFullChunks = (len - 2) / simdWidth;\n    \n    for (int i = 0; i < numFullChunks; i++) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(s.data() + i));\n        __m128i next1 = _mm_loadu_si128((__m128i*)(s.data() + i + 1)); \n        __m128i next2 = _mm_loadu_si128((__m128i*)(s.data() + i + 2));\n\n        __m128i eq1 = _mm_cmpeq_epi8(curr, next1);\n        __m128i eq2 = _mm_cmpeq_epi8(curr, next2);\n        __m128i eq3 = _mm_cmpeq_epi8(next1, next2);\n\n        __m128i result = _mm_or_si128(eq1, _mm_or_si128(eq2, eq3));\n        \n        if (_mm_movemask_epi8(result)) {\n            return false;\n        }\n    }\n\n    // Handle remaining elements\n    for (int i = numFullChunks * simdWidth; i < len - 2; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length() - 2;\n    const char* ptr = s.c_str();\n\n    // Process 16 characters at a time\n    for (int i = 0; i < len - 13; i += 16) {\n        __m128i str1 = _mm_loadu_si128((__m128i*)(ptr + i));\n        __m128i str2 = _mm_loadu_si128((__m128i*)(ptr + i + 1)); \n        __m128i str3 = _mm_loadu_si128((__m128i*)(ptr + i + 2));\n\n        // Check if consecutive chars are equal\n        __m128i cmp1 = _mm_cmpeq_epi8(str1, str2);\n        __m128i cmp2 = _mm_cmpeq_epi8(str2, str3);\n        __m128i cmp3 = _mm_cmpeq_epi8(str1, str3);\n\n        // Combine results\n        __m128i result = _mm_or_si128(cmp1, _mm_or_si128(cmp2, cmp3));\n\n        // Check if any consecutive triplets had equal chars\n        if (_mm_movemask_epi8(result)) {\n            return false;\n        }\n    }\n\n    // Handle remaining characters\n    for (int i = len - (len % 16); i < len; i++) {\n        if (ptr[i] == ptr[i+1] || ptr[i+1] == ptr[i+2] || ptr[i] == ptr[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char* str = s.c_str();\n    int len = s.length();\n    \n    for (int i = 0; i <= len - 3; i += 4) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(str + i));\n        \n        // Compare each character with next 2 characters\n        __m128i shift1 = _mm_srli_si128(chars, 1);\n        __m128i shift2 = _mm_srli_si128(chars, 2);\n        \n        // Check if any consecutive 3 chars are equal\n        __m128i cmp1 = _mm_cmpeq_epi8(chars, shift1);\n        __m128i cmp2 = _mm_cmpeq_epi8(chars, shift2);\n        __m128i cmp3 = _mm_cmpeq_epi8(shift1, shift2);\n        \n        __m128i result = _mm_or_si128(cmp1, _mm_or_si128(cmp2, cmp3));\n        \n        // Get mask of valid comparisons\n        int mask = _mm_movemask_epi8(result);\n        \n        // Check only relevant bits based on remaining length\n        int check_bits = (i + 4 <= len - 2) ? 0x0F : (1 << (len - i - 2)) - 1;\n        \n        if (mask & check_bits) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    \n    int len = s.length();\n    const char* str = s.c_str();\n    \n    // Process 16 characters at a time\n    for (int i = 0; i <= len-3; i++) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)(str + i));\n        __m128i v2 = _mm_loadu_si128((__m128i*)(str + i + 1)); \n        __m128i v3 = _mm_loadu_si128((__m128i*)(str + i + 2));\n        \n        // Compare adjacent characters\n        __m128i eq1 = _mm_cmpeq_epi8(v1, v2);\n        __m128i eq2 = _mm_cmpeq_epi8(v2, v3);\n        __m128i eq3 = _mm_cmpeq_epi8(v1, v3);\n        \n        // Combine results\n        __m128i res = _mm_or_si128(eq1, _mm_or_si128(eq2, eq3));\n        \n        // Check if any 3 consecutive chars are equal\n        int mask = _mm_movemask_epi8(res);\n        if (mask & (1 << i)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SSE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length();\n    const int simdWidth = 16;\n    const int simdLen = len - 2;\n    \n    for (int i = 0; i < simdLen; i += simdWidth) {\n        int remainingChars = std::min(simdWidth, simdLen - i);\n        \n        __m128i curr = _mm_loadu_si128((__m128i*)(s.data() + i));\n        __m128i next = _mm_loadu_si128((__m128i*)(s.data() + i + 1)); \n        __m128i next2 = _mm_loadu_si128((__m128i*)(s.data() + i + 2));\n\n        __m128i eq1 = _mm_cmpeq_epi8(curr, next);\n        __m128i eq2 = _mm_cmpeq_epi8(curr, next2);\n        __m128i eq3 = _mm_cmpeq_epi8(next, next2);\n\n        __m128i result = _mm_or_si128(eq1, _mm_or_si128(eq2, eq3));\n        \n        int mask = _mm_movemask_epi8(result);\n        mask &= (1 << remainingChars) - 1;\n        \n        if (mask != 0) {\n            return false;\n        }\n    }\n\n    // Check remaining characters\n    for (int i = simdLen - (simdLen % simdWidth); i < len - 2; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    int sqrt_len = sqrt(len);\n    int nums_to_check = (sqrt_len + 3) / 4 * 4;\n    \n    alignas(16) int divisors[4] = {3,5,7,9};\n    __m128i increment = _mm_set1_epi32(8);\n    __m128i len_vec = _mm_set1_epi32(len);\n    __m128i divisors_vec = _mm_load_si128((__m128i*)divisors);\n    \n    for(int i = 0; i < nums_to_check; i += 4) {\n        __m128i remainder = _mm_rem_epi32(len_vec, divisors_vec);\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(_mm_cmpeq_epi32(remainder, _mm_setzero_si128())));\n        \n        if(mask != 0) {\n            return false;\n        }\n        \n        divisors_vec = _mm_add_epi32(divisors_vec, increment);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n\n    int sqrt_len = static_cast<int>(sqrt(len));\n    int nums_per_vec = 4;\n    int vec_iters = (sqrt_len + nums_per_vec - 1) / nums_per_vec;\n\n    __m128i vec_len = _mm_set1_epi32(len);\n    __m128i increment = _mm_set1_epi32(nums_per_vec);\n    __m128i start = _mm_set_epi32(3, 5, 7, 9);\n\n    for (int i = 0; i < vec_iters; i++) {\n        __m128i divs = _mm_div_epi32(vec_len, start);\n        __m128i muls = _mm_mul_epi32(divs, start);\n        __m128i cmp = _mm_cmpeq_epi32(muls, vec_len);\n        \n        int mask = _mm_movemask_epi8(cmp);\n        if (mask != 0) {\n            return false;\n        }\n        \n        start = _mm_add_epi32(start, increment);\n        start = _mm_add_epi32(start, increment);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n\n    int sqrt_len = sqrt(len);\n    int nums_to_check = (sqrt_len + 3) / 4 * 4;\n    \n    alignas(16) int divisors[4] = {3,5,7,9};\n    __m128i increment = _mm_set1_epi32(8);\n    __m128i len_vec = _mm_set1_epi32(len);\n    __m128i divisors_vec = _mm_load_si128((__m128i*)divisors);\n    \n    for(int i = 0; i < nums_to_check; i += 4) {\n        __m128i quotient = _mm_div_epi32(len_vec, divisors_vec);\n        __m128i product = _mm_mullo_epi32(quotient, divisors_vec);\n        __m128i remainder = _mm_sub_epi32(len_vec, product);\n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp = _mm_cmpeq_epi32(remainder, zero);\n        \n        int mask = _mm_movemask_epi8(cmp);\n        if(mask != 0) return false;\n        \n        divisors_vec = _mm_add_epi32(divisors_vec, increment);\n        \n        int max_divisor = divisors[3];\n        if(max_divisor > sqrt_len) break;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n    \n    __m128i nums = _mm_setr_epi32(3, 5, 7, 9);\n    __m128i lens = _mm_set1_epi32(len);\n    __m128i zeros = _mm_setzero_si128();\n    \n    size_t sqrt_len = sqrt(len);\n    \n    for (int i = 3; i <= sqrt_len; i += 4) {\n        __m128i divs = _mm_div_epi32(lens, nums);\n        __m128i muls = _mm_mullo_epi32(divs, nums);\n        __m128i cmps = _mm_cmpeq_epi32(muls, lens);\n        \n        if (_mm_movemask_epi8(cmps)) {\n            return false;\n        }\n        \n        nums = _mm_add_epi32(nums, _mm_set1_epi32(8));\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SSE", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    int len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n\n    int sqrt_len = sqrt(len);\n    int nums_to_check = (sqrt_len + 3) / 4 * 4;\n\n    __m128i curr = _mm_set1_epi32(len);\n    __m128i divisors = _mm_set_epi32(3, 5, 7, 9);\n    __m128i increment = _mm_set1_epi32(8);\n    \n    for (int i = 0; i < nums_to_check; i += 4) {\n        __m128i quotient = _mm_div_epi32(curr, divisors);\n        __m128i product = _mm_mullo_epi32(quotient, divisors);\n        __m128i remainder = _mm_sub_epi32(curr, product);\n        __m128i is_zero = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n        \n        int mask = _mm_movemask_ps(_mm_castsi128_ps(is_zero));\n        if (mask != 0) return false;\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i digit;\n    \n    while (N > 0) {\n        // Extract 4 digits at a time\n        digit = _mm_set_epi32(N % 10, \n                             (N/10) % 10,\n                             (N/100) % 10, \n                             (N/1000) % 10);\n        \n        // Add digits to running sum\n        sum = _mm_add_epi32(sum, digit);\n        \n        N /= 10000;\n    }\n\n    // Horizontal sum of 4 32-bit integers\n    sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 8));\n    sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 4));\n    \n    int total = _mm_cvtsi128_si32(sum);\n    \n    if(total == 0) return \"0\";\n    \n    std::string result;\n    while(total > 0) {\n        result = (total & 1 ? \"1\" : \"0\") + result;\n        total >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i num = _mm_set1_epi32(N);\n    \n    while (N > 0) {\n        __m128i digits = _mm_setzero_si128();\n        for (int i = 0; i < 4 && N > 0; i++) {\n            digits = _mm_insert_epi32(digits, N % 10, i);\n            N /= 10;\n        }\n        sum = _mm_add_epi32(sum, digits);\n    }\n    \n    int total = 0;\n    alignas(16) int temp[4];\n    _mm_store_si128((__m128i*)temp, sum);\n    \n    for (int i = 0; i < 4; i++) {\n        total += temp[i];\n    }\n\n    if (total == 0) return \"0\";\n    \n    std::string result;\n    while (total > 0) {\n        result = (total & 1 ? '1' : '0') + result;\n        total >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i digit;\n    \n    while (N > 0) {\n        // Extract 4 digits at a time\n        int digits[4] = {0};\n        for (int i = 0; i < 4 && N > 0; i++) {\n            digits[i] = N % 10;\n            N /= 10;\n        }\n        \n        // Load digits into SIMD register\n        digit = _mm_loadu_si128((__m128i*)digits);\n        \n        // Add to running sum\n        sum = _mm_add_epi32(sum, digit);\n    }\n    \n    // Horizontal sum of 4 32-bit integers\n    sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 8));\n    sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 4));\n    int total = _mm_cvtsi128_si32(sum);\n    \n    // Convert to binary string\n    if (total == 0) return \"0\";\n    \n    std::string result;\n    while (total > 0) {\n        result = (total & 1 ? '1' : '0') + result;\n        total >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i num = _mm_set1_epi32(N);\n    \n    while (N > 0) {\n        // Process 4 digits at a time\n        __m128i digits = _mm_setzero_si128();\n        for (int i = 0; i < 4 && N > 0; i++) {\n            int digit = N % 10;\n            N /= 10;\n            digits = _mm_insert_epi32(digits, digit, i);\n        }\n        \n        // Add digits to running sum\n        sum = _mm_add_epi32(sum, digits);\n    }\n    \n    // Horizontal sum of 4 32-bit integers\n    sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 8));\n    sum = _mm_add_epi32(sum, _mm_srli_si128(sum, 4));\n    int total = _mm_cvtsi128_si32(sum);\n    \n    // Convert to binary string\n    if (total == 0) return \"0\";\n    \n    std::string result;\n    while (total > 0) {\n        result = (total & 1 ? '1' : '0') + result;\n        total >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SSE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    __m128i sum = _mm_setzero_si128();\n    __m128i ten = _mm_set1_epi32(10);\n    __m128i num = _mm_set1_epi32(N);\n    \n    while (N > 0) {\n        // Process 4 digits at a time\n        __m128i digits = _mm_setzero_si128();\n        for (int i = 0; i < 4 && N > 0; i++) {\n            int digit = N % 10;\n            N /= 10;\n            digits = _mm_insert_epi32(digits, digit, i);\n        }\n        \n        // Add digits to running sum\n        sum = _mm_add_epi32(sum, digits);\n    }\n    \n    // Horizontal sum of 4 32-bit integers\n    sum = _mm_hadd_epi32(sum, sum);\n    sum = _mm_hadd_epi32(sum, sum);\n    int final_sum = _mm_cvtsi128_si32(sum);\n\n    // Convert to binary string\n    if (final_sum == 0) return \"0\";\n    \n    std::string result;\n    while (final_sum > 0) {\n        result = (final_sum & 1 ? '1' : '0') + result;\n        final_sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i two = _mm_set1_epi32(2);\n    \n    for(int i = 1; i < size - 3; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i mask = _mm_cmpeq_epi32(_mm_and_si128(nums, two), zero);\n        mask = _mm_xor_si128(mask, _mm_set1_epi32(-1));\n        nums = _mm_and_si128(nums, mask);\n        \n        __m128i sum4 = _mm_add_epi32(nums, _mm_srli_si128(nums, 8));\n        sum4 = _mm_add_epi32(sum4, _mm_srli_si128(sum4, 4));\n        sum += _mm_cvtsi128_si32(sum4);\n    }\n    \n    for(int i = (size/4)*4 + 1; i < size; i += 2) {\n        if(lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Pad vector size to multiple of 4\n    while (lst.size() % 4 != 0) {\n        lst.push_back(0);\n    }\n    \n    __m128i indices = _mm_set_epi32(3, 2, 1, 0);\n    __m128i odd_mask = _mm_set1_epi32(1);\n    __m128i even_mask = _mm_set1_epi32(2);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        // Load 4 integers\n        __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for odd indices\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i is_odd = _mm_and_si128(curr_indices, odd_mask);\n        __m128i odd_indices = _mm_cmpeq_epi32(is_odd, odd_mask);\n        \n        // Create mask for even values\n        __m128i is_even = _mm_and_si128(data, even_mask);\n        __m128i even_values = _mm_cmpeq_epi32(is_even, zero);\n        \n        // Combine masks and get final values\n        __m128i mask = _mm_and_si128(odd_indices, even_values);\n        __m128i masked_data = _mm_and_si128(data, mask);\n        \n        // Horizontal sum\n        __m128i sum2 = _mm_add_epi32(masked_data, _mm_srli_si128(masked_data, 8));\n        __m128i sum4 = _mm_add_epi32(sum2, _mm_srli_si128(sum2, 4));\n        sum += _mm_cvtsi128_si32(sum4);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Pad vector size to multiple of 4 for SSE\n    while (lst.size() % 4 != 0) {\n        lst.push_back(0);\n    }\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i mask_odd = _mm_set_epi32(0, 0xFFFFFFFF, 0, 0xFFFFFFFF);\n    __m128i mask_even = _mm_set_epi32(2, 2, 2, 2);\n    __m128i result = _mm_setzero_si128();\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Mask for odd indices\n        __m128i odd_elements = _mm_and_si128(data, mask_odd);\n        \n        // Check if even numbers\n        __m128i mod = _mm_srai_epi32(_mm_slli_epi32(odd_elements, 31), 31);\n        __m128i even_check = _mm_and_si128(mod, mask_even);\n        __m128i is_even = _mm_cmpeq_epi32(even_check, zero);\n        \n        // Keep only even numbers at odd indices\n        __m128i valid_nums = _mm_and_si128(odd_elements, is_even);\n        \n        result = _mm_add_epi32(result, valid_nums);\n    }\n    \n    // Horizontal sum\n    __m128i hi64 = _mm_unpackhi_epi64(result, result);\n    __m128i sum128 = _mm_add_epi32(result, hi64);\n    __m128i hi32 = _mm_shufflelo_epi16(sum128, _MM_SHUFFLE(1,0,3,2));\n    __m128i sum32 = _mm_add_epi32(sum128, hi32);\n    sum = _mm_cvtsi128_si32(sum32);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Pad vector size to multiple of 4\n    while (lst.size() % 4 != 0) {\n        lst.push_back(0);\n    }\n    \n    __m128i indices = _mm_set_epi32(3, 2, 1, 0);\n    __m128i odd_mask = _mm_set1_epi32(1);\n    __m128i even_mask = _mm_set1_epi32(2);\n    __m128i zero = _mm_setzero_si128();\n    __m128i result = _mm_setzero_si128();\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        // Load 4 integers\n        __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for odd indices\n        __m128i curr_indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i is_odd = _mm_and_si128(curr_indices, odd_mask);\n        __m128i odd_indices = _mm_cmpeq_epi32(is_odd, odd_mask);\n        \n        // Create mask for even values\n        __m128i remainder = _mm_and_si128(_mm_srli_epi32(data, 1), odd_mask);\n        __m128i is_even = _mm_cmpeq_epi32(remainder, zero);\n        \n        // Combine masks and add matching elements\n        __m128i mask = _mm_and_si128(odd_indices, is_even);\n        __m128i masked_data = _mm_and_si128(data, mask);\n        result = _mm_add_epi32(result, masked_data);\n    }\n    \n    // Horizontal sum\n    __m128i sum1 = _mm_hadd_epi32(result, result);\n    __m128i sum2 = _mm_hadd_epi32(sum1, sum1);\n    sum = _mm_cvtsi128_si32(sum2);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SSE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int size = lst.size();\n    int sum = 0;\n    \n    // Pad vector size to multiple of 4 for SSE\n    while (lst.size() % 4 != 0) {\n        lst.push_back(0);\n    }\n    \n    __m128i zero = _mm_setzero_si128();\n    __m128i odd_mask = _mm_set_epi32(3, 2, 1, 0);\n    __m128i even_mask = _mm_set1_epi32(2);\n    __m128i result = _mm_setzero_si128();\n    \n    for (int i = 0; i < lst.size(); i += 4) {\n        // Load 4 integers\n        __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for odd indices\n        __m128i indices = _mm_add_epi32(odd_mask, _mm_set1_epi32(i));\n        __m128i odd_indices = _mm_and_si128(indices, _mm_set1_epi32(1));\n        odd_indices = _mm_cmpeq_epi32(odd_indices, _mm_set1_epi32(1));\n        \n        // Create mask for even values\n        __m128i even_values = _mm_and_si128(data, _mm_set1_epi32(1));\n        even_values = _mm_cmpeq_epi32(even_values, zero);\n        \n        // Combine masks and add matching values\n        __m128i mask = _mm_and_si128(odd_indices, even_values);\n        __m128i masked_data = _mm_and_si128(data, mask);\n        result = _mm_add_epi32(result, masked_data);\n    }\n    \n    // Horizontal sum\n    __m128i sum_hi = _mm_srli_si128(result, 8);\n    result = _mm_add_epi32(result, sum_hi);\n    __m128i sum_lo = _mm_srli_si128(result, 4); \n    result = _mm_add_epi32(result, sum_lo);\n    sum = _mm_cvtsi128_si32(result);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    size_t len = s.length();\n    size_t simd_width = 16;\n    size_t simd_blocks = len / simd_width;\n    \n    __m128i shift = _mm_set1_epi8(4); // Shift by 4 (2*2)\n    \n    for(size_t i = 0; i < simd_blocks; i++) {\n        __m128i data = _mm_loadu_si128((__m128i*)&s[i * simd_width]);\n        __m128i encrypted = _mm_add_epi8(data, shift);\n        _mm_storeu_si128((__m128i*)&result[i * simd_width], encrypted);\n    }\n    \n    // Handle remaining characters\n    for(size_t i = simd_blocks * simd_width; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    std::string result(s);\n    size_t len = s.length();\n    size_t simd_len = len & ~0xF;  // Round down to multiple of 16\n\n    if (len >= 16) {\n        __m128i shift = _mm_set1_epi8(4);  // Shift by 4 (2*2)\n        \n        for (size_t i = 0; i < simd_len; i += 16) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n            __m128i encrypted = _mm_add_epi8(chars, shift);\n            _mm_storeu_si128((__m128i*)(result.data() + i), encrypted);\n        }\n    }\n\n    // Handle remaining characters\n    for (size_t i = simd_len; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    size_t len = s.length();\n    std::string result(s);\n    \n    // Process 16 characters at a time using SSE\n    size_t vectorSize = len - (len % 16);\n    \n    for (size_t i = 0; i < vectorSize; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Multiply by 2 and shift by 2\n        __m128i shift = _mm_set1_epi8(4);\n        chars = _mm_add_epi8(chars, shift);\n        \n        // Store result\n        _mm_storeu_si128((__m128i*)&result[i], chars);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = vectorSize; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    size_t len = s.length();\n    std::string result(s);\n    \n    // Process 16 characters at a time using SSE\n    size_t vectorSize = len - (len % 16);\n    \n    for (size_t i = 0; i < vectorSize; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)&s[i]);\n        \n        // Multiply by 2 and shift by 2\n        __m128i shift = _mm_set1_epi8(4);\n        chars = _mm_add_epi8(chars, shift);\n        \n        _mm_storeu_si128((__m128i*)&result[i], chars);\n    }\n    \n    // Handle remaining characters\n    for (size_t i = vectorSize; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SSE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    size_t len = s.length();\n    std::string result(len, 0);\n    \n    size_t i = 0;\n    \n    // Process 16 characters at a time using SSE\n    for (; i + 16 <= len; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n        \n        // Multiply by 2 and shift by 2\n        __m128i shift = _mm_set1_epi8(4);\n        __m128i encrypted = _mm_add_epi8(chars, shift);\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), encrypted);\n    }\n    \n    // Handle remaining characters\n    for (; i < len; i++) {\n        result[i] = s[i] + 4;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    int len = message.length();\n    int simd_len = len - (len % 16);\n    \n    __m128i vowels = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    __m128i vowel_shifts = _mm_setr_epi8('c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W', 0, 0, 0, 0, 0, 0);\n    __m128i upper_mask = _mm_set1_epi8(0x20);\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound_cap = _mm_set1_epi8('Z');\n    __m128i lower_bound_cap = _mm_set1_epi8('A');\n\n    for (int i = 0; i < simd_len; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(message.data() + i));\n        \n        // Check for vowels\n        __m128i is_vowel = _mm_setzero_si128();\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_shuffle_epi8(vowels, _mm_set1_epi8(j));\n            is_vowel = _mm_or_si128(is_vowel, _mm_cmpeq_epi8(data, vowel));\n        }\n        \n        // Get vowel replacements\n        __m128i vowel_replace = data;\n        for (int j = 0; j < 10; j++) {\n            __m128i v = _mm_shuffle_epi8(vowels, _mm_set1_epi8(j));\n            __m128i r = _mm_shuffle_epi8(vowel_shifts, _mm_set1_epi8(j));\n            __m128i mask = _mm_cmpeq_epi8(data, v);\n            vowel_replace = _mm_blendv_epi8(vowel_replace, r, mask);\n        }\n        \n        // Case swap for non-vowels\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(data, lower_bound), \n                                        _mm_cmplt_epi8(data, upper_bound));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(data, lower_bound_cap),\n                                        _mm_cmplt_epi8(data, upper_bound_cap));\n                                        \n        __m128i case_swapped = _mm_xor_si128(data, _mm_and_si128(_mm_or_si128(is_lower, is_upper), upper_mask));\n        \n        // Combine vowel replacements and case swaps\n        __m128i final = _mm_blendv_epi8(case_swapped, vowel_replace, is_vowel);\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), final);\n    }\n    \n    // Handle remaining characters\n    for (int i = simd_len; i < len; i++) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                result[i] = c + 2;\n            } else {\n                result[i] = c - 32;\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                result[i] = c + 2;\n            } else {\n                result[i] = c + 32;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    int len = message.length();\n    int simd_len = len - (len % 16);\n    \n    __m128i vowels = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    __m128i vowel_shifts = _mm_setr_epi8('c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W', 0, 0, 0, 0, 0, 0);\n    __m128i upper_mask = _mm_set1_epi8(0x20);\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i upper_lower = _mm_set1_epi8('A');\n    __m128i upper_upper = _mm_set1_epi8('Z');\n\n    for (int i = 0; i < simd_len; i += 16) {\n        __m128i data = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check if character is a letter\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('a'-1)), \n                                        _mm_cmplt_epi8(data, _mm_set1_epi8('z'+1)));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(data, _mm_set1_epi8('A'-1)),\n                                        _mm_cmplt_epi8(data, _mm_set1_epi8('Z'+1)));\n        \n        // Swap case for letters\n        __m128i case_swapped = _mm_xor_si128(data, _mm_and_si128(_mm_or_si128(is_lower, is_upper), upper_mask));\n        \n        // Check for vowels and replace\n        __m128i is_vowel = _mm_setzero_si128();\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_set1_epi8(((char*)&vowels)[j]);\n            is_vowel = _mm_or_si128(is_vowel, _mm_cmpeq_epi8(data, vowel));\n        }\n        \n        // Replace vowels with shifted characters\n        __m128i vowel_replaced = case_swapped;\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_set1_epi8(((char*)&vowels)[j]);\n            __m128i shift = _mm_set1_epi8(((char*)&vowel_shifts)[j]);\n            __m128i mask = _mm_cmpeq_epi8(data, vowel);\n            vowel_replaced = _mm_or_si128(_mm_and_si128(mask, shift),\n                                        _mm_andnot_si128(mask, vowel_replaced));\n        }\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), vowel_replaced);\n    }\n\n    // Handle remaining characters\n    for (int i = simd_len; i < len; i++) {\n        char c = message[i];\n        if (isalpha(c)) {\n            // Swap case\n            c ^= 0x20;\n            \n            // Replace vowels\n            switch(tolower(c)) {\n                case 'a': c = (c >= 'a' && c <= 'z') ? 'c' : 'C'; break;\n                case 'e': c = (c >= 'a' && c <= 'z') ? 'g' : 'G'; break;\n                case 'i': c = (c >= 'a' && c <= 'z') ? 'k' : 'K'; break;\n                case 'o': c = (c >= 'a' && c <= 'z') ? 'q' : 'Q'; break;\n                case 'u': c = (c >= 'a' && c <= 'z') ? 'w' : 'W'; break;\n            }\n        }\n        result[i] = c;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    int len = message.length();\n    int simd_len = len - (len % 16);\n    \n    __m128i vowels = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    __m128i vowel_shifts = _mm_setr_epi8('c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W', 0, 0, 0, 0, 0, 0);\n    __m128i upper_mask = _mm_set1_epi8(0x20);\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound_caps = _mm_set1_epi8('Z');\n    __m128i lower_bound_caps = _mm_set1_epi8('A');\n\n    for (int i = 0; i < simd_len; i += 16) {\n        __m128i curr = _mm_loadu_si128((__m128i*)(message.data() + i));\n        \n        // Check for vowels\n        __m128i is_vowel = _mm_setzero_si128();\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_shuffle_epi8(vowels, _mm_set1_epi8(j));\n            is_vowel = _mm_or_si128(is_vowel, _mm_cmpeq_epi8(curr, vowel));\n        }\n        \n        // Get replacement vowels\n        __m128i vowel_replace = curr;\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_shuffle_epi8(vowels, _mm_set1_epi8(j));\n            __m128i shift = _mm_shuffle_epi8(vowel_shifts, _mm_set1_epi8(j));\n            __m128i mask = _mm_cmpeq_epi8(curr, vowel);\n            vowel_replace = _mm_blendv_epi8(vowel_replace, shift, mask);\n        }\n        \n        // Swap case for non-vowels\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(curr, lower_bound - 1),\n                                        _mm_cmpgt_epi8(upper_bound + 1, curr));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(curr, lower_bound_caps - 1),\n                                        _mm_cmpgt_epi8(upper_bound_caps + 1, curr));\n                                        \n        __m128i case_swapped = _mm_xor_si128(curr, _mm_and_si128(_mm_or_si128(is_lower, is_upper), upper_mask));\n        \n        // Combine vowel replacements and case swaps\n        __m128i final = _mm_blendv_epi8(case_swapped, vowel_replace, is_vowel);\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), final);\n    }\n\n    // Handle remaining characters\n    for (int i = simd_len; i < len; i++) {\n        char c = message[i];\n        bool is_vowel = (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n                        c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n                        \n        if (is_vowel) {\n            switch(c) {\n                case 'a': result[i] = 'c'; break;\n                case 'e': result[i] = 'g'; break;\n                case 'i': result[i] = 'k'; break;\n                case 'o': result[i] = 'q'; break;\n                case 'u': result[i] = 'w'; break;\n                case 'A': result[i] = 'C'; break;\n                case 'E': result[i] = 'G'; break;\n                case 'I': result[i] = 'K'; break;\n                case 'O': result[i] = 'Q'; break;\n                case 'U': result[i] = 'W'; break;\n            }\n        } else {\n            if (c >= 'a' && c <= 'z') {\n                result[i] = c - 32;\n            } else if (c >= 'A' && c <= 'Z') {\n                result[i] = c + 32;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t simd_size = len - (len % 16);\n\n    __m128i vowels = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    __m128i vowel_shifts = _mm_setr_epi8('c', 'g', 'k', 'q', 'w', 'C', 'G', 'K', 'Q', 'W', 0, 0, 0, 0, 0, 0);\n    __m128i upper_mask = _mm_set1_epi8(0x20);\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound_caps = _mm_set1_epi8('Z');\n    __m128i lower_bound_caps = _mm_set1_epi8('A');\n\n    for (size_t i = 0; i < simd_size; i += 16) {\n        __m128i chars = _mm_loadu_si128((__m128i*)(result.data() + i));\n        \n        // Check for vowels\n        __m128i is_vowel = _mm_setzero_si128();\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_shuffle_epi8(vowels, _mm_set1_epi8(j));\n            is_vowel = _mm_or_si128(is_vowel, _mm_cmpeq_epi8(chars, vowel));\n        }\n        \n        // Replace vowels\n        __m128i vowel_replaced = chars;\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_shuffle_epi8(vowels, _mm_set1_epi8(j));\n            __m128i shift = _mm_shuffle_epi8(vowel_shifts, _mm_set1_epi8(j));\n            __m128i mask = _mm_cmpeq_epi8(chars, vowel);\n            vowel_replaced = _mm_blendv_epi8(vowel_replaced, shift, mask);\n        }\n        \n        // Swap case for non-vowels\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_set1_epi8('`')),\n                                        _mm_cmpgt_epi8(_mm_set1_epi8('{'}, chars));\n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(chars, _mm_set1_epi8('@')),\n                                        _mm_cmpgt_epi8(_mm_set1_epi8('['}, chars));\n                                        \n        __m128i case_swapped = _mm_xor_si128(chars, _mm_and_si128(_mm_or_si128(is_lower, is_upper), upper_mask));\n        \n        // Combine vowel replacements and case swaps\n        __m128i final = _mm_blendv_epi8(case_swapped, vowel_replaced, is_vowel);\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), final);\n    }\n\n    // Handle remaining characters\n    for (size_t i = simd_size; i < len; i++) {\n        char c = result[i];\n        bool is_vowel = (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n                        c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U');\n        \n        if (is_vowel) {\n            switch(c) {\n                case 'a': c = 'c'; break;\n                case 'e': c = 'g'; break;\n                case 'i': c = 'k'; break;\n                case 'o': c = 'q'; break;\n                case 'u': c = 'w'; break;\n                case 'A': c = 'C'; break;\n                case 'E': c = 'G'; break;\n                case 'I': c = 'K'; break;\n                case 'O': c = 'Q'; break;\n                case 'U': c = 'W'; break;\n            }\n        } else if (c >= 'a' && c <= 'z') {\n            c -= 32;\n        } else if (c >= 'A' && c <= 'Z') {\n            c += 32;\n        }\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SSE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    int len = message.length();\n    int simd_width = 16;\n    \n    __m128i vowels_mask = _mm_setr_epi8('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U', 0, 0, 0, 0, 0, 0);\n    __m128i vowel_shifts = _mm_setr_epi8(2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0);\n    __m128i upper_mask = _mm_set1_epi8(0x20);\n    __m128i lower_bound = _mm_set1_epi8('a');\n    __m128i upper_bound = _mm_set1_epi8('z');\n    __m128i upper_lower = _mm_set1_epi8('A');\n    __m128i upper_upper = _mm_set1_epi8('Z');\n\n    for (int i = 0; i < len; i += simd_width) {\n        __m128i chunk = _mm_loadu_si128((__m128i*)(message.data() + i));\n        \n        // Check for vowels\n        __m128i is_vowel = _mm_setzero_si128();\n        for (int j = 0; j < 10; j++) {\n            __m128i vowel = _mm_set1_epi8(((char*)&vowels_mask)[j]);\n            is_vowel = _mm_or_si128(is_vowel, _mm_cmpeq_epi8(chunk, vowel));\n        }\n        \n        // Replace vowels with char 2 ahead\n        __m128i vowel_replaced = _mm_add_epi8(chunk, _mm_and_si128(is_vowel, vowel_shifts));\n        \n        // Swap case for all letters\n        __m128i is_lower = _mm_and_si128(_mm_cmpgt_epi8(chunk, _mm_sub_epi8(lower_bound, _mm_set1_epi8(1))),\n                                        _mm_cmpgt_epi8(_mm_add_epi8(upper_bound, _mm_set1_epi8(1)), chunk));\n        \n        __m128i is_upper = _mm_and_si128(_mm_cmpgt_epi8(chunk, _mm_sub_epi8(upper_lower, _mm_set1_epi8(1))),\n                                        _mm_cmpgt_epi8(_mm_add_epi8(upper_upper, _mm_set1_epi8(1)), chunk));\n        \n        __m128i case_swapped = _mm_xor_si128(vowel_replaced, \n                                            _mm_and_si128(_mm_or_si128(is_lower, is_upper), upper_mask));\n        \n        _mm_storeu_si128((__m128i*)(result.data() + i), case_swapped);\n    }\n    \n    // Handle remaining characters\n    for (int i = (len / simd_width) * simd_width; i < len; i++) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n                result[i] = (char)(((c - 'a' + 2) % 26) + 'A');\n            } else {\n                result[i] = c - 32;\n            }\n        } else if (c >= 'A' && c <= 'Z') {\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                result[i] = (char)(((c - 'A' + 2) % 26) + 'a');\n            } else {\n                result[i] = c + 32;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLower = false;\n    bool hasUpper = false;\n    \n    __m128i lower_mask = _mm_set1_epi8('a' - 1);\n    __m128i upper_mask = _mm_set1_epi8('z' + 1);\n    __m128i zero = _mm_setzero_si128();\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        for (size_t i = 0; i < key.length(); i += 16) {\n            size_t remaining = std::min(size_t(16), key.length() - i);\n            char buffer[16] = {0};\n            memcpy(buffer, key.c_str() + i, remaining);\n            \n            __m128i chars = _mm_loadu_si128((__m128i*)buffer);\n            \n            __m128i gt_lower = _mm_cmpgt_epi8(chars, lower_mask);\n            __m128i lt_upper = _mm_cmplt_epi8(chars, upper_mask);\n            __m128i is_letter = _mm_and_si128(gt_lower, lt_upper);\n            \n            if (_mm_movemask_epi8(is_letter) == 0) {\n                return false;\n            }\n            \n            __m128i is_upper = _mm_cmpgt_epi8(chars, _mm_set1_epi8('Z'));\n            int upper_mask = _mm_movemask_epi8(is_upper);\n            \n            if (upper_mask == 0) {\n                hasUpper = true;\n            } else if (upper_mask == 0xFFFF) {\n                hasLower = true;\n            } else {\n                return false;\n            }\n            \n            if (hasUpper && hasLower) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasUpper = false;\n    bool hasLower = false;\n    \n    __m128i upper_mask = _mm_set1_epi8(0x40); // '@'\n    __m128i lower_mask = _mm_set1_epi8(0x60); // '`'\n    __m128i letter_mask = _mm_set1_epi8(0x1F); // For checking A-Z range\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        for (size_t i = 0; i < key.length(); i += 16) {\n            size_t remaining = std::min(size_t(16), key.length() - i);\n            char aligned_buf[16] = {0};\n            memcpy(aligned_buf, key.c_str() + i, remaining);\n            \n            __m128i chars = _mm_loadu_si128((__m128i*)aligned_buf);\n            \n            // Check for uppercase letters (A-Z)\n            __m128i upper_check = _mm_cmpgt_epi8(chars, upper_mask);\n            __m128i upper_check2 = _mm_cmplt_epi8(chars, _mm_set1_epi8('Z' + 1));\n            __m128i is_upper = _mm_and_si128(upper_check, upper_check2);\n            \n            // Check for lowercase letters (a-z)\n            __m128i lower_check = _mm_cmpgt_epi8(chars, lower_mask);\n            __m128i lower_check2 = _mm_cmplt_epi8(chars, _mm_set1_epi8('z' + 1));\n            __m128i is_lower = _mm_and_si128(lower_check, lower_check2);\n            \n            int upper_mask = _mm_movemask_epi8(is_upper);\n            int lower_mask = _mm_movemask_epi8(is_lower);\n            \n            // Check if any character is not a letter\n            if ((upper_mask | lower_mask) != 0) {\n                if (upper_mask != 0) hasUpper = true;\n                if (lower_mask != 0) hasLower = true;\n                \n                if (hasUpper && hasLower) return false;\n            } else {\n                // If character is not a letter, return false\n                if (remaining > 0) return false;\n            }\n        }\n    }\n\n    return (hasUpper || hasLower);\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasUpper = false;\n    bool hasLower = false;\n    \n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (key.empty()) continue;\n\n        size_t len = key.length();\n        size_t simdLen = len - (len % 16);\n        \n        for (size_t i = 0; i < simdLen; i += 16) {\n            __m128i chars = _mm_loadu_si128((__m128i*)&key[i]);\n            \n            __m128i upperMask = _mm_cmpgt_epi8(chars, _mm_set1_epi8('Z'));\n            __m128i lowerMask = _mm_cmplt_epi8(chars, _mm_set1_epi8('a'));\n            __m128i nonAlphaMask = _mm_or_si128(\n                _mm_cmplt_epi8(chars, _mm_set1_epi8('A')),\n                _mm_cmpgt_epi8(chars, _mm_set1_epi8('z'))\n            );\n            \n            int upperBits = _mm_movemask_epi8(upperMask);\n            int lowerBits = _mm_movemask_epi8(lowerMask);\n            int nonAlphaBits = _mm_movemask_epi8(nonAlphaMask);\n            \n            if (nonAlphaBits) return false;\n            \n            if (upperBits) hasLower = true;\n            if (lowerBits) hasUpper = true;\n            \n            if (hasUpper && hasLower) return false;\n        }\n        \n        for (size_t i = simdLen; i < len; i++) {\n            char c = key[i];\n            if (!isalpha(c)) return false;\n            if (islower(c)) hasLower = true;\n            if (isupper(c)) hasUpper = true;\n            if (hasUpper && hasLower) return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool first_upper = isupper(dict.begin()->first[0]);\n    \n    const int SIMD_WIDTH = 16;\n    char buffer[SIMD_WIDTH];\n    __m128i all_upper = _mm_set1_epi8('Z');\n    __m128i all_lower = _mm_set1_epi8('z'); \n    __m128i upper_bound = _mm_set1_epi8('A');\n    __m128i lower_bound = _mm_set1_epi8('a');\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        if (key.empty()) {\n            return false;\n        }\n\n        size_t len = key.length();\n        size_t i;\n        \n        for (i = 0; i + SIMD_WIDTH <= len; i += SIMD_WIDTH) {\n            memcpy(buffer, key.c_str() + i, SIMD_WIDTH);\n            __m128i chars = _mm_loadu_si128((__m128i*)buffer);\n\n            if (first_upper) {\n                __m128i upper_check = _mm_and_si128(\n                    _mm_cmpgt_epi8(chars, _mm_set1_epi8('@')),\n                    _mm_cmplt_epi8(chars, _mm_set1_epi8('['))\n                );\n                \n                if (!_mm_test_all_ones(upper_check)) {\n                    return false;\n                }\n            } else {\n                __m128i lower_check = _mm_and_si128(\n                    _mm_cmpgt_epi8(chars, _mm_set1_epi8('`')),\n                    _mm_cmplt_epi8(chars, _mm_set1_epi8('{'))\n                );\n                \n                if (!_mm_test_all_ones(lower_check)) {\n                    return false;\n                }\n            }\n        }\n\n        for (; i < len; i++) {\n            char c = key[i];\n            if (first_upper) {\n                if (c < 'A' || c > 'Z') {\n                    return false;\n                }\n            } else {\n                if (c < 'a' || c > 'z') {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SSE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasUpper = false;\n    bool hasLower = false;\n    \n    __m128i upper_mask = _mm_set1_epi8(0x40);\n    __m128i lower_mask = _mm_set1_epi8(0x60); \n    __m128i compare_mask = _mm_set1_epi8(0x1F);\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        \n        for (size_t i = 0; i < key.length(); i += 16) {\n            size_t remaining = std::min(size_t(16), key.length() - i);\n            char buffer[16] = {0};\n            memcpy(buffer, key.c_str() + i, remaining);\n            \n            __m128i chars = _mm_loadu_si128((__m128i*)buffer);\n            \n            __m128i is_upper = _mm_and_si128(\n                _mm_cmpgt_epi8(chars, upper_mask),\n                _mm_cmplt_epi8(chars, lower_mask)\n            );\n            \n            __m128i is_lower = _mm_cmpgt_epi8(chars, lower_mask);\n            \n            int upper_mask_bits = _mm_movemask_epi8(is_upper);\n            int lower_mask_bits = _mm_movemask_epi8(is_lower);\n            \n            if (upper_mask_bits) hasUpper = true;\n            if (lower_mask_bits) hasLower = true;\n            \n            if (hasUpper && hasLower) return false;\n            \n            // Check if non-alphabetic\n            __m128i alpha_check = _mm_or_si128(is_upper, is_lower);\n            int alpha_mask = _mm_movemask_epi8(alpha_check);\n            \n            for (size_t j = 0; j < remaining; j++) {\n                if (!(alpha_mask & (1 << j))) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int num = 5; num < n; num += 2) {\n        int sqrtNum = sqrt(num);\n        bool isPrime = true;\n        \n        int alignedLimit = (sqrtNum / 4) * 4;\n        int i;\n        \n        for (i = 0; i < alignedLimit && i < primes.size(); i += 4) {\n            __m128i prime_vec = _mm_loadu_si128((__m128i*)&primes[i]);\n            __m128i num_vec = _mm_set1_epi32(num);\n            __m128i div = _mm_div_epi32(num_vec, prime_vec);\n            __m128i mul = _mm_mullo_epi32(div, prime_vec);\n            __m128i cmp = _mm_cmpeq_epi32(mul, num_vec);\n            \n            if (_mm_movemask_epi8(cmp)) {\n                isPrime = false;\n                break;\n            }\n        }\n        \n        if (isPrime) {\n            for (; i < primes.size() && primes[i] <= sqrtNum; i++) {\n                if (num % primes[i] == 0) {\n                    isPrime = false;\n                    break;\n                }\n            }\n            \n            if (isPrime) {\n                primes.push_back(num);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    // Create aligned arrays for SIMD processing\n    int size = ((n + 3) / 4) * 4; // Round up to multiple of 4\n    int* numbers = (int*)_mm_malloc(size * sizeof(int), 16);\n    bool* is_prime = (bool*)_mm_malloc(size * sizeof(bool), 16);\n    \n    // Initialize arrays\n    for (int i = 0; i < size; i++) {\n        numbers[i] = i >= n ? 0 : i;\n        is_prime[i] = true;\n    }\n    is_prime[0] = is_prime[1] = false;\n    \n    // Sieve of Eratosthenes with SIMD\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            __m128i vi = _mm_set1_epi32(i);\n            \n            for (int j = i * i; j < size; j += 4) {\n                __m128i vj = _mm_load_si128((__m128i*)&numbers[j]);\n                __m128i vmod = _mm_rem_epi32(vj, vi);\n                __m128i vcmp = _mm_cmpeq_epi32(vmod, _mm_setzero_si128());\n                \n                int mask = _mm_movemask_ps(_mm_castsi128_ps(vcmp));\n                \n                if (mask) {\n                    for (int k = 0; k < 4; k++) {\n                        if (mask & (1 << k)) {\n                            is_prime[j + k] = false;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    // Collect prime numbers\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    \n    _mm_free(numbers);\n    _mm_free(is_prime);\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    if (n <= 3) return primes;\n    primes.push_back(3);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int num = 5; num < n; num += 2) {\n        int sqrtNum = sqrt(num);\n        bool isPrime = true;\n        \n        int alignedLimit = (sqrtNum / 4) * 4;\n        \n        for (int i = 0; i < primes.size() && primes[i] <= sqrtNum; i += 4) {\n            if (i + 4 <= alignedLimit) {\n                __m128i prime_vec = _mm_loadu_si128((__m128i*)&primes[i]);\n                __m128i div = _mm_set1_epi32(num);\n                __m128i rem = _mm_rem_epi32(div, prime_vec);\n                __m128i cmp = _mm_cmpeq_epi32(rem, zeros);\n                int mask = _mm_movemask_epi8(cmp);\n                \n                if (mask != 0) {\n                    isPrime = false;\n                    break;\n                }\n            } else {\n                for (; i < primes.size() && primes[i] <= sqrtNum; i++) {\n                    if (num % primes[i] == 0) {\n                        isPrime = false;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        if (isPrime) {\n            primes.push_back(num);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int num = 3; num < n; num += 2) {\n        int sqrtNum = sqrt(num);\n        bool isPrime = true;\n        \n        int alignedLimit = (sqrtNum / 4) * 4;\n        \n        for (int i = 0; i < alignedLimit && isPrime; i += 4) {\n            __m128i divs = _mm_setr_epi32(i, i+1, i+2, i+3);\n            __m128i numVec = _mm_set1_epi32(num);\n            __m128i remainders = _mm_sub_epi32(numVec, _mm_mul_epi32(divs, _mm_div_epi32(numVec, divs)));\n            __m128i mask = _mm_cmpeq_epi32(remainders, zeros);\n            \n            if (_mm_movemask_epi8(mask) != 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        \n        for (int i = alignedLimit; i <= sqrtNum && isPrime; i++) {\n            if (i > 1 && num % i == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        \n        if (isPrime) {\n            primes.push_back(num);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SSE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    __m128i ones = _mm_set1_epi32(1);\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int num = 3; num < n; num += 2) {\n        int sqrtNum = sqrt(num);\n        bool isPrime = true;\n        \n        int aligned = (sqrtNum / 4) * 4;\n        \n        for (int i = 3; i <= aligned; i += 4) {\n            __m128i divs = _mm_set_epi32(i+3, i+2, i+1, i);\n            __m128i nums = _mm_set1_epi32(num);\n            __m128i rem = _mm_sub_epi32(nums, _mm_mul_epi32(_mm_div_epi32(nums, divs), divs));\n            __m128i mask = _mm_cmpeq_epi32(rem, zeros);\n            \n            if (_mm_movemask_epi8(mask)) {\n                isPrime = false;\n                break;\n            }\n        }\n        \n        for (int i = aligned + 1; i <= sqrtNum && isPrime; i++) {\n            if (num % i == 0) {\n                isPrime = false;\n                break;\n            }\n        }\n        \n        if (isPrime) {\n            primes.push_back(num);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    __m128i vowels_a = _mm_set1_epi8('A');\n    __m128i vowels_e = _mm_set1_epi8('E'); \n    __m128i vowels_i = _mm_set1_epi8('I');\n    __m128i vowels_o = _mm_set1_epi8('O');\n    __m128i vowels_u = _mm_set1_epi8('U');\n    __m128i mask = _mm_set1_epi8(0xAA);\n\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n\n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        result = _mm_and_si128(result, mask);\n        \n        int mask_result = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask_result);\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if ((c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    __m128i vowels_a = _mm_set1_epi8('A');\n    __m128i vowels_e = _mm_set1_epi8('E'); \n    __m128i vowels_i = _mm_set1_epi8('I');\n    __m128i vowels_o = _mm_set1_epi8('O');\n    __m128i vowels_u = _mm_set1_epi8('U');\n    __m128i mask = _mm_set1_epi8(0xAA);\n\n    int i;\n    for (i = 0; i + 16 <= len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n\n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        result = _mm_and_si128(result, mask);\n        \n        count += _mm_popcnt_u32(_mm_movemask_epi8(result));\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if ((c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n                count++;\n        }\n        return count;\n    }\n\n    __m128i vowels_a = _mm_set1_epi8('A');\n    __m128i vowels_e = _mm_set1_epi8('E');\n    __m128i vowels_i = _mm_set1_epi8('I');\n    __m128i vowels_o = _mm_set1_epi8('O');\n    __m128i vowels_u = _mm_set1_epi8('U');\n    __m128i mask = _mm_set1_epi8(0xAA);\n\n    int i;\n    for (i = 0; i + 15 < len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n\n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n\n        result = _mm_and_si128(result, mask);\n        \n        int mask_result = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask_result);\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U')\n            count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    __m128i vowels_a = _mm_set1_epi8('A');\n    __m128i vowels_e = _mm_set1_epi8('E'); \n    __m128i vowels_i = _mm_set1_epi8('I');\n    __m128i vowels_o = _mm_set1_epi8('O');\n    __m128i vowels_u = _mm_set1_epi8('U');\n    __m128i mask = _mm_set1_epi8(0xAA);\n\n    int i;\n    for (i = 0; i + 16 <= len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n\n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        result = _mm_and_si128(result, mask);\n        \n        int mask_result = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask_result);\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SSE", "completion": "```cpp\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    \n    if (len < 16) {\n        for (int i = 0; i < len; i += 2) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n        return count;\n    }\n\n    __m128i vowels_a = _mm_set1_epi8('A');\n    __m128i vowels_e = _mm_set1_epi8('E'); \n    __m128i vowels_i = _mm_set1_epi8('I');\n    __m128i vowels_o = _mm_set1_epi8('O');\n    __m128i vowels_u = _mm_set1_epi8('U');\n    __m128i mask = _mm_set1_epi8(0xAA);\n\n    int i;\n    for (i = 0; i + 16 <= len; i += 16) {\n        __m128i str = _mm_loadu_si128((__m128i*)(s.c_str() + i));\n        \n        __m128i cmp_a = _mm_cmpeq_epi8(str, vowels_a);\n        __m128i cmp_e = _mm_cmpeq_epi8(str, vowels_e);\n        __m128i cmp_i = _mm_cmpeq_epi8(str, vowels_i);\n        __m128i cmp_o = _mm_cmpeq_epi8(str, vowels_o);\n        __m128i cmp_u = _mm_cmpeq_epi8(str, vowels_u);\n\n        __m128i result = _mm_or_si128(cmp_a, cmp_e);\n        result = _mm_or_si128(result, cmp_i);\n        result = _mm_or_si128(result, cmp_o);\n        result = _mm_or_si128(result, cmp_u);\n        \n        result = _mm_and_si128(result, mask);\n        \n        int mask_result = _mm_movemask_epi8(result);\n        count += _mm_popcnt_u32(mask_result);\n    }\n\n    for (; i < len; i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    if (n <= 1) {\n        return result;\n    }\n\n    // Initialize vector with starting value n and increment by 2\n    __m128i curr = _mm_set1_epi32(n);\n    __m128i increment = _mm_set1_epi32(2);\n    \n    // Process 4 elements at a time\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        _mm_storeu_si128((__m128i*)&result[i], curr);\n        curr = _mm_add_epi32(curr, increment);\n        curr = _mm_add_epi32(curr, increment);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = n + 2 * i;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    if (n <= 1) {\n        return result;\n    }\n\n    // Initialize vector with starting value n and increment by 2\n    __m128i curr = _mm_set1_epi32(n);\n    __m128i increment = _mm_set1_epi32(2);\n    \n    // Process 4 elements at a time\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        _mm_storeu_si128((__m128i*)&result[i], curr);\n        curr = _mm_add_epi32(curr, increment);\n        curr = _mm_add_epi32(curr, increment);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = n + 2 * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    if (n <= 1) {\n        return result;\n    }\n\n    // Handle first value separately\n    int start = n;\n    bool is_odd = (start % 2 == 1);\n    \n    // Calculate how many 4-element chunks we need\n    int simd_iters = (n-1) / 4;\n    int remainder = (n-1) % 4;\n\n    // Set up increment vectors\n    __m128i inc_even = _mm_set1_epi32(2);\n    __m128i inc_odd = _mm_set1_epi32(2);\n    \n    // Process 4 elements at a time\n    for(int i = 0; i < simd_iters; i++) {\n        int idx = i*4 + 1;\n        \n        // Load current values\n        __m128i curr;\n        if (i == 0) {\n            curr = _mm_set1_epi32(start + (is_odd ? 2 : 2));\n        } else {\n            curr = _mm_loadu_si128((__m128i*)&result[idx-1]);\n        }\n        \n        // Add increments\n        __m128i next = _mm_add_epi32(curr, is_odd ? inc_odd : inc_even);\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[idx], next);\n    }\n\n    // Handle remaining elements\n    int last = result[simd_iters*4];\n    for(int i = 0; i < remainder; i++) {\n        result[simd_iters*4 + 1 + i] = last + (is_odd ? 2 : 2) * (i+1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    if (n <= 1) {\n        return result;\n    }\n\n    __m128i increment;\n    if (n % 2 == 0) {\n        increment = _mm_set1_epi32(2); // Even increment\n    } else {\n        increment = _mm_set1_epi32(2); // Odd increment\n    }\n\n    int i;\n    for (i = 0; i + 4 <= n; i += 4) {\n        __m128i indices = _mm_set_epi32(3, 2, 1, 0);\n        indices = _mm_add_epi32(indices, _mm_set1_epi32(i));\n        __m128i multiplier = _mm_mullo_epi32(indices, increment);\n        __m128i values = _mm_add_epi32(_mm_set1_epi32(n), multiplier);\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        result[i] = result[i-1] + (n % 2 == 0 ? 2 : 2);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SSE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    result[0] = n;\n    \n    if (n <= 1) return result;\n    \n    int iterations = (n-1) / 4;\n    int remainder = (n-1) % 4;\n    \n    __m128i curr = _mm_set1_epi32(n);\n    __m128i increment = _mm_set1_epi32(2);\n    __m128i four = _mm_set1_epi32(4);\n    \n    // Process 4 elements at a time\n    for(int i = 0; i < iterations; i++) {\n        curr = _mm_add_epi32(curr, increment);\n        _mm_storeu_si128((__m128i*)&result[i*4 + 1], curr);\n        increment = _mm_add_epi32(increment, four);\n    }\n    \n    // Handle remaining elements\n    curr = _mm_add_epi32(curr, increment);\n    int last_val = result[iterations*4];\n    \n    for(int i = 0; i < remainder; i++) {\n        result[iterations*4 + 1 + i] = last_val + (i+1)*2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i count = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i nums = _mm_set_epi32(3, 2, 1, 0);\n    \n    int64_t range = m - n + 1;\n    int64_t i;\n    \n    for (i = n; i <= m-3; i += 4) {\n        __m128i curr = _mm_add_epi32(_mm_set1_epi32(i), nums);\n        sum = _mm_add_epi32(sum, curr);\n        count = _mm_add_epi32(count, increment);\n    }\n    \n    int64_t total = 0;\n    int32_t *sum_arr = (int32_t*)&sum;\n    for (int j = 0; j < 4; j++) {\n        total += sum_arr[j];\n    }\n    \n    for (; i <= m; i++) {\n        total += i;\n    }\n    \n    int64_t final_count = range;\n    int64_t avg = total / final_count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    // Calculate number of elements\n    int64_t count = m - n + 1;\n    \n    // Initialize SIMD registers\n    __m128i sum = _mm_setzero_si128();\n    __m128i nums = _mm_set1_epi32(0);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i start = _mm_set_epi32(n+3, n+2, n+1, n);\n    \n    // Process 4 numbers at a time\n    int64_t i;\n    for(i = n; i <= m-3; i += 4) {\n        nums = start;\n        sum = _mm_add_epi32(sum, nums);\n        start = _mm_add_epi32(start, increment);\n    }\n    \n    // Extract results\n    int32_t result[4];\n    _mm_storeu_si128((__m128i*)result, sum);\n    \n    // Add remaining elements and sum up\n    int64_t total = result[0] + result[1] + result[2] + result[3];\n    for(; i <= m; i++) {\n        total += i;\n    }\n    \n    // Calculate average and round down\n    int64_t avg = total / count;\n    \n    // Convert to binary string\n    if(avg == 0) return \"0\";\n    \n    std::string binary;\n    while(avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i count = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi64x(4);\n    __m128i nums = _mm_set_epi64x(n+1, n);\n    \n    int64_t remaining = m - n + 1;\n    \n    while (remaining >= 2) {\n        sum = _mm_add_epi64(sum, nums);\n        count = _mm_add_epi64(count, _mm_set1_epi64x(1));\n        nums = _mm_add_epi64(nums, increment);\n        remaining -= 2;\n    }\n    \n    int64_t total = 0;\n    int64_t temp[2];\n    _mm_store_si128((__m128i*)temp, sum);\n    total = temp[0] + temp[1];\n    \n    if (remaining > 0) {\n        total += m;\n        remaining++;\n    }\n    \n    _mm_store_si128((__m128i*)temp, count);\n    int64_t cnt = temp[0] + temp[1] + remaining;\n    \n    int64_t avg = total / cnt;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i count = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i nums = _mm_set_epi32(3, 2, 1, 0);\n    \n    int64_t range = m - n + 1;\n    int64_t i;\n    \n    for (i = 0; i + 4 <= range; i += 4) {\n        __m128i curr = _mm_add_epi32(_mm_set1_epi32(n + i), nums);\n        sum = _mm_add_epi32(sum, curr);\n        count = _mm_add_epi32(count, increment);\n    }\n    \n    int32_t total = 0;\n    int32_t temp[4];\n    _mm_store_si128((__m128i*)temp, sum);\n    \n    for (int j = 0; j < 4; j++) {\n        total += temp[j];\n    }\n    \n    for (; i < range; i++) {\n        total += (n + i);\n    }\n    \n    int64_t final_count = (i >= 4 ? 4 : 0);\n    for (int j = 0; j < (range % 4); j++) {\n        final_count++;\n    }\n    \n    int64_t avg = total / final_count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SSE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i count = _mm_setzero_si128();\n    __m128i increment = _mm_set1_epi64x(4);\n    __m128i nums = _mm_set_epi64x(n+1, n);\n    \n    int64_t remaining = m - n + 1;\n    \n    while (remaining >= 2) {\n        sum = _mm_add_epi64(sum, nums);\n        count = _mm_add_epi64(count, _mm_set1_epi64x(2));\n        nums = _mm_add_epi64(nums, increment);\n        remaining -= 2;\n    }\n    \n    int64_t total = 0;\n    int64_t* sum_arr = (int64_t*)&sum;\n    total = sum_arr[0] + sum_arr[1];\n    \n    if (remaining == 1) {\n        total += m;\n        count = _mm_add_epi64(count, _mm_set1_epi64x(1));\n    }\n    \n    int64_t* count_arr = (int64_t*)&count;\n    int64_t final_count = count_arr[0];\n    \n    int64_t avg = total / final_count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg % 2 ? '1' : '0') + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i mod = _mm_set1_epi32(10000);\n    \n    // Process 4 elements at a time\n    for (int i = 1; i < n-3; i += 4) {\n        __m128i indices = _mm_set_epi32(i+4, i+3, i+2, i+1);\n        __m128i is_even = _mm_and_si128(indices, ones);\n        is_even = _mm_cmpeq_epi32(is_even, _mm_setzero_si128());\n        \n        // Calculate factorials\n        __m128i fact = _mm_set1_epi32(1);\n        for (int j = 1; j <= i+4; j++) {\n            __m128i mult = _mm_set1_epi32(j);\n            fact = _mm_mullo_epi32(fact, mult);\n            fact = _mm_rem_epi32(fact, mod);\n        }\n        \n        // Calculate sums\n        __m128i sums = _mm_set_epi32(\n            (i+4)*((i+4)+1)/2,\n            (i+3)*((i+3)+1)/2,\n            (i+2)*((i+2)+1)/2,\n            (i+1)*((i+1)+1)/2\n        );\n        \n        // Select between factorial and sum based on even/odd\n        __m128i res = _mm_blendv_epi8(sums, fact, is_even);\n        \n        _mm_storeu_si128((__m128i*)&result[i], res);\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if ((i+1) % 2 == 0) {\n            int fact = 1;\n            for (int j = 1; j <= i+1; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            result[i] = ((i+1) * ((i+1)+1)) / 2;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) result[0] = 1;\n    \n    // Process 4 elements at a time using SSE\n    const int simd_width = 4;\n    int i;\n    \n    for (i = 1; i + simd_width <= n; i += simd_width) {\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i ones = _mm_set1_epi32(1);\n        __m128i sums = _mm_setzero_si128();\n        __m128i facts = _mm_set1_epi32(1);\n        __m128i mod = _mm_set1_epi32(10000);\n        \n        // Calculate both factorial and sum for all 4 indices\n        for (int j = 1; j <= i + 3; j++) {\n            __m128i j_vec = _mm_set1_epi32(j);\n            __m128i mask = _mm_cmpgt_epi32(indices, _mm_sub_epi32(j_vec, ones));\n            \n            // Update running sums\n            sums = _mm_add_epi32(sums, _mm_and_si128(j_vec, mask));\n            \n            // Update factorials\n            facts = _mm_mullo_epi32(facts, _mm_and_si128(j_vec, mask));\n            facts = _mm_rem_epi32(facts, mod);\n        }\n        \n        // Select factorial for even indices, sum for odd indices\n        __m128i even_mask = _mm_cmpeq_epi32(_mm_and_si128(indices, ones), _mm_setzero_si128());\n        __m128i result_vec = _mm_or_si128(\n            _mm_and_si128(facts, even_mask),\n            _mm_andnot_si128(even_mask, sums)\n        );\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], result_vec);\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if ((i + 1) % 2 == 0) {\n            // Calculate factorial for even indices\n            int fact = 1;\n            for (int j = 1; j <= i + 1; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        } else {\n            // Calculate sum for odd indices\n            int sum = 0;\n            for (int j = 1; j <= i + 1; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n    \n    // Pre-calculate factorials mod 10000\n    int fact = 1;\n    std::vector<int> factorials(n+1);\n    factorials[0] = 1;\n    factorials[1] = 1;\n    for(int i = 2; i <= n; i++) {\n        fact = (fact * i) % 10000;\n        factorials[i] = fact;\n    }\n\n    // Process 4 elements at a time using SSE\n    __m128i mod10k = _mm_set1_epi32(10000);\n    \n    for(int i = 1; i < n-3; i+=4) {\n        // Create vector of indices\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        // Create vector of sums from 1 to i\n        __m128i sums = _mm_setzero_si128();\n        for(int j = 1; j <= i+3; j++) {\n            sums = _mm_add_epi32(sums, _mm_set1_epi32(1));\n        }\n        \n        // Load factorials for even indices\n        __m128i facts = _mm_set_epi32(\n            factorials[i+3],\n            factorials[i+2], \n            factorials[i+1],\n            factorials[i]\n        );\n        \n        // Create mask for even/odd indices\n        __m128i two = _mm_set1_epi32(2);\n        __m128i mask = _mm_cmpeq_epi32(_mm_and_si128(indices, two), _mm_setzero_si128());\n        \n        // Select between factorial and sum based on mask\n        __m128i res = _mm_or_si128(\n            _mm_and_si128(mask, facts),\n            _mm_andnot_si128(mask, sums)\n        );\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], res);\n    }\n    \n    // Handle remaining elements\n    for(int i = (n/4)*4 + 1; i < n; i++) {\n        if(i % 2 == 0) {\n            result[i] = factorials[i];\n        } else {\n            int sum = 0;\n            for(int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) result[0] = 1;\n    \n    // Process 4 elements at a time using SSE\n    int i;\n    for (i = 1; i + 3 < n; i += 4) {\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i ones = _mm_set1_epi32(1);\n        __m128i sums = _mm_setzero_si128();\n        __m128i facts = _mm_set1_epi32(1);\n        __m128i mod = _mm_set1_epi32(10000);\n        \n        // Calculate both factorial and sum for all indices\n        for (int j = 1; j <= i+3; j++) {\n            __m128i j_vec = _mm_set1_epi32(j);\n            \n            // Update factorials\n            facts = _mm_mullo_epi32(facts, j_vec);\n            facts = _mm_rem_epi32(facts, mod);\n            \n            // Update running sums for indices >= j\n            __m128i mask = _mm_cmpgt_epi32(indices, _mm_sub_epi32(j_vec, ones));\n            __m128i add = _mm_and_si128(mask, j_vec);\n            sums = _mm_add_epi32(sums, add);\n        }\n        \n        // Select factorial for even indices, sum for odd indices\n        __m128i even_mask = _mm_set1_epi32(1);\n        even_mask = _mm_and_si128(indices, even_mask);\n        even_mask = _mm_cmpeq_epi32(even_mask, _mm_setzero_si128());\n        \n        __m128i result_vec = _mm_or_si128(\n            _mm_and_si128(even_mask, facts),\n            _mm_andnot_si128(even_mask, sums)\n        );\n        \n        // Store results\n        alignas(16) int temp[4];\n        _mm_store_si128((__m128i*)temp, result_vec);\n        for (int j = 0; j < 4 && i+j < n; j++) {\n            result[i+j] = temp[j];\n        }\n    }\n    \n    // Handle remaining elements\n    for (; i < n; i++) {\n        if (i % 2 == 1) {\n            int sum = 0;\n            for (int j = 1; j <= i+1; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        } else {\n            int fact = 1;\n            for (int j = 1; j <= i+1; j++) {\n                fact = (fact * j) % 10000;\n            }\n            result[i] = fact;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SSE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Handle first element separately since i starts from 1\n    if (n > 0) {\n        result[0] = 1;\n    }\n    \n    // Pre-calculate factorials mod 10000\n    int factorials[16] = {1, 1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800, 3628800, 3628800, 3628800, 3628800, 3628800};\n    for (int i = 5; i < 16; i++) {\n        factorials[i] %= 10000;\n    }\n\n    // Process 4 elements at a time using SSE\n    for (int i = 1; i < n - 3; i += 4) {\n        __m128i indices = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i ones = _mm_set1_epi32(1);\n        \n        // Calculate sums for odd indices\n        __m128i sums = _mm_setzero_si128();\n        __m128i counter = ones;\n        \n        for (int j = 1; j <= i+3; j++) {\n            sums = _mm_add_epi32(sums, counter);\n            counter = _mm_add_epi32(counter, ones);\n        }\n        \n        // Get factorials for even indices\n        __m128i facts = _mm_set_epi32(\n            factorials[(i+3) % 16],\n            factorials[(i+2) % 16], \n            factorials[(i+1) % 16],\n            factorials[i % 16]\n        );\n        \n        // Create mask for even/odd indices\n        __m128i two = _mm_set1_epi32(2);\n        __m128i is_even = _mm_and_si128(indices, two);\n        is_even = _mm_cmpeq_epi32(is_even, _mm_setzero_si128());\n        \n        // Select between sums and factorials based on even/odd\n        __m128i values = _mm_or_si128(\n            _mm_and_si128(is_even, sums),\n            _mm_andnot_si128(is_even, facts)\n        );\n        \n        // Store results\n        _mm_storeu_si128((__m128i*)&result[i], values);\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4 + 1; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = factorials[i % 16] % 10000;\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; j++) {\n                sum += j;\n            }\n            result[i] = sum;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i counts = _mm_setzero_si128(); // Initialize counts to 0\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i nums = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    \n    while (_mm_cvtsi128_si32(nums) <= n) {\n        // Check if each number is palindrome\n        __m128i temp = nums;\n        __m128i rev = _mm_setzero_si128();\n        \n        while (_mm_movemask_epi8(_mm_cmpeq_epi32(temp, _mm_setzero_si128())) != 0xFFFF) {\n            rev = _mm_add_epi32(_mm_mullo_epi32(rev, _mm_set1_epi32(10)), \n                               _mm_and_si128(temp, _mm_set1_epi32(0xF)));\n            temp = _mm_srli_epi32(temp, 4);\n        }\n        \n        // Compare original numbers with reversed\n        __m128i is_palindrome = _mm_cmpeq_epi32(nums, rev);\n        \n        // Check if numbers are even/odd\n        __m128i is_even = _mm_cmpeq_epi32(_mm_and_si128(nums, _mm_set1_epi32(1)), \n                                         _mm_setzero_si128());\n        \n        // Update counts based on palindrome and even/odd status\n        __m128i even_mask = _mm_and_si128(is_palindrome, is_even);\n        __m128i odd_mask = _mm_and_si128(is_palindrome, \n                                        _mm_xor_si128(is_even, _mm_set1_epi32(-1)));\n        \n        counts = _mm_add_epi32(counts,\n                              _mm_add_epi32(_mm_and_si128(even_mask, ones),\n                                          _mm_and_si128(odd_mask, ones)));\n        \n        nums = _mm_add_epi32(nums, increment);\n    }\n    \n    // Horizontal sum of counts\n    __m128i sum = _mm_hadd_epi32(counts, counts);\n    sum = _mm_hadd_epi32(sum, sum);\n    \n    int even_count = _mm_cvtsi128_si32(sum) & 0xFFFF;\n    int odd_count = _mm_cvtsi128_si32(sum) >> 16;\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i counts = _mm_setzero_si128(); // Initialize counts to 0\n    __m128i ones = _mm_set1_epi32(1);\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i mask = _mm_cmplt_epi32(nums, _mm_set1_epi32(n+1));\n        \n        // Check palindrome for each number\n        __m128i palindrome_mask = _mm_setzero_si128();\n        for (int j = 0; j < 4; j++) {\n            int num = ((int*)&nums)[j];\n            if (num > n) continue;\n            \n            // Convert to string to check palindrome\n            char str[16];\n            int len = sprintf(str, \"%d\", num);\n            bool is_palindrome = true;\n            \n            for (int k = 0; k < len/2; k++) {\n                if (str[k] != str[len-1-k]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n            \n            if (is_palindrome) {\n                // Set bit if palindrome\n                palindrome_mask = _mm_insert_epi32(palindrome_mask, 1, j);\n                \n                // Update even/odd counts\n                if (num % 2 == 0) {\n                    counts = _mm_add_epi32(counts, _mm_and_si128(_mm_srli_si128(ones, 12), mask));\n                } else {\n                    counts = _mm_add_epi32(counts, _mm_and_si128(_mm_srli_si128(ones, 8), mask)); \n                }\n            }\n        }\n    }\n    \n    // Extract results\n    int even_count = _mm_extract_epi32(counts, 3);\n    int odd_count = _mm_extract_epi32(counts, 2);\n    \n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i counts = _mm_setzero_si128(); // Initialize counts to 0\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i nums = _mm_set_epi32(4, 3, 2, 1); // Load first 4 numbers\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        __m128i palindrome_mask = _mm_setzero_si128();\n        __m128i even_mask = _mm_setzero_si128();\n        \n        // Check which numbers are palindromes\n        for (int j = 0; j < 4; j++) {\n            if (i + j <= n) {\n                int num = i + j;\n                int rev = 0;\n                int temp = num;\n                \n                while (temp > 0) {\n                    rev = rev * 10 + temp % 10;\n                    temp /= 10;\n                }\n                \n                if (num == rev) {\n                    palindrome_mask = _mm_or_si128(palindrome_mask, \n                        _mm_slli_si128(ones, j * 4));\n                    \n                    if (num % 2 == 0) {\n                        even_mask = _mm_or_si128(even_mask,\n                            _mm_slli_si128(ones, j * 4));\n                    }\n                }\n            }\n        }\n        \n        // Count even palindromes\n        __m128i even_count = _mm_and_si128(palindrome_mask, even_mask);\n        counts = _mm_add_epi32(counts, even_count);\n        \n        // Count odd palindromes \n        __m128i odd_count = _mm_and_si128(palindrome_mask,\n            _mm_xor_si128(even_mask, palindrome_mask));\n        counts = _mm_add_epi32(counts, _mm_slli_si128(odd_count, 4));\n        \n        nums = _mm_add_epi32(nums, _mm_set1_epi32(4));\n    }\n    \n    // Extract results\n    alignas(16) int result[4];\n    _mm_store_si128((__m128i*)result, counts);\n    \n    return {result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i counts = _mm_setzero_si128(); // Initialize counts to 0\n    __m128i ones = _mm_set1_epi32(1);\n    \n    // Process 4 numbers at a time\n    for (int i = 1; i <= n; i += 4) {\n        __m128i nums = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i mask = _mm_cmplt_epi32(nums, _mm_set1_epi32(n+1));\n        \n        // Check palindrome for each number\n        __m128i palindrome_mask = _mm_setzero_si128();\n        for (int j = 0; j < 4; j++) {\n            int num = ((int*)&nums)[j];\n            if (num > n) continue;\n            \n            // Convert to string to check palindrome\n            char str[16];\n            int len = sprintf(str, \"%d\", num);\n            bool is_palindrome = true;\n            \n            for (int k = 0; k < len/2; k++) {\n                if (str[k] != str[len-1-k]) {\n                    is_palindrome = false;\n                    break;\n                }\n            }\n            \n            if (is_palindrome) {\n                // Set bit if palindrome\n                palindrome_mask = _mm_or_si128(palindrome_mask, \n                    _mm_slli_epi32(ones, j*32));\n                \n                // Increment even/odd count\n                if (num % 2 == 0) {\n                    counts = _mm_add_epi32(counts, \n                        _mm_and_si128(_mm_slli_epi32(ones, 0), mask));\n                } else {\n                    counts = _mm_add_epi32(counts, \n                        _mm_and_si128(_mm_slli_epi32(ones, 32), mask));\n                }\n            }\n        }\n    }\n    \n    // Extract results\n    int result[4];\n    _mm_store_si128((__m128i*)result, counts);\n    \n    return {result[0], result[1]};\n}\n```"}
{"task_id": "SimdBench_113_SSE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    __m128i counts = _mm_setzero_si128(); // Initialize counts to 0\n    __m128i ones = _mm_set1_epi32(1);\n    __m128i nums = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    \n    while (_mm_cvtsi128_si32(nums) <= n) {\n        // Check if numbers are palindromes\n        __m128i palindrome_mask = _mm_setzero_si128();\n        __m128i temp_nums = nums;\n        \n        // Convert numbers to palindrome check\n        for (int i = 0; i < 4; i++) {\n            int num = _mm_cvtsi128_si32(_mm_srli_si128(temp_nums, i * 4));\n            if (num <= n) {\n                int rev = 0;\n                int orig = num;\n                while (orig > 0) {\n                    rev = rev * 10 + orig % 10;\n                    orig /= 10;\n                }\n                if (num == rev) {\n                    palindrome_mask = _mm_or_si128(palindrome_mask, \n                        _mm_slli_si128(_mm_set1_epi32(1), i * 4));\n                }\n            }\n        }\n        \n        // Check even/odd and update counts\n        __m128i even_mask = _mm_and_si128(nums, _mm_set1_epi32(1));\n        even_mask = _mm_cmpeq_epi32(even_mask, _mm_setzero_si128());\n        \n        __m128i even_palindromes = _mm_and_si128(palindrome_mask, even_mask);\n        __m128i odd_palindromes = _mm_andnot_si128(even_mask, palindrome_mask);\n        \n        counts = _mm_add_epi32(counts, \n            _mm_unpacklo_epi64(\n                _mm_sad_epu8(even_palindromes, _mm_setzero_si128()),\n                _mm_sad_epu8(odd_palindromes, _mm_setzero_si128())\n            )\n        );\n        \n        nums = _mm_add_epi32(nums, increment);\n    }\n    \n    std::vector<int> result(2);\n    result[0] = _mm_cvtsi128_si32(counts);\n    result[1] = _mm_cvtsi128_si32(_mm_srli_si128(counts, 8));\n    \n    // Handle remaining numbers sequentially\n    int start = ((n - 1) / 4) * 4 + 1;\n    for (int i = start; i <= n; i++) {\n        int num = i;\n        int rev = 0;\n        int orig = num;\n        while (orig > 0) {\n            rev = rev * 10 + orig % 10;\n            orig /= 10;\n        }\n        if (num == rev) {\n            result[num % 2]++;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int size = n.size();\n    int aligned_size = size - (size % 4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i result = zeros;\n        \n        for (int j = 0; j < 10; j++) {\n            __m128i digit_sums = zeros;\n            __m128i nums_copy = nums;\n            \n            // Handle negative numbers\n            __m128i signs = _mm_srai_epi32(nums_copy, 31);\n            __m128i abs_nums = _mm_xor_si128(nums_copy, signs);\n            abs_nums = _mm_sub_epi32(abs_nums, signs);\n            \n            // Extract digits and sum\n            while (_mm_movemask_epi8(_mm_cmpeq_epi32(abs_nums, zeros)) != 0xFFFF) {\n                __m128i digits = _mm_and_si128(abs_nums, _mm_set1_epi32(0x0F));\n                digit_sums = _mm_add_epi32(digit_sums, digits);\n                abs_nums = _mm_srai_epi32(abs_nums, 4);\n            }\n            \n            // Apply sign to first digit\n            digit_sums = _mm_xor_si128(digit_sums, _mm_and_si128(signs, digit_sums));\n            digit_sums = _mm_sub_epi32(digit_sums, _mm_and_si128(signs, digit_sums));\n            \n            // Check if sum > 0\n            __m128i mask = _mm_cmpgt_epi32(digit_sums, zeros);\n            result = _mm_or_si128(result, mask);\n        }\n        \n        // Extract results\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(result));\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for (int i = aligned_size; i < size; i++) {\n        int num = n[i];\n        int sum = 0;\n        bool first = true;\n        \n        if (num < 0) {\n            num = -num;\n            first = false;\n        }\n        \n        while (num) {\n            int digit = num % 10;\n            if (!first) {\n                sum += digit;\n            } else {\n                sum += (num < 0) ? -digit : digit;\n                first = false;\n            }\n            num /= 10;\n        }\n        \n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int size = n.size();\n    int aligned_size = size & ~3;\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i signs = _mm_cmplt_epi32(nums, zeros);\n        __m128i abs_nums = _mm_sub_epi32(_mm_xor_si128(nums, signs), signs);\n        \n        int sums[4] = {0};\n        for (int j = 0; j < 4; j++) {\n            int num = _mm_extract_epi32(abs_nums, j);\n            int sign = _mm_extract_epi32(signs, j) & 1;\n            int sum = 0;\n            \n            if (num == 0) {\n                sum = 0;\n            } else {\n                bool first = true;\n                while (num) {\n                    int digit = num % 10;\n                    if (first && sign) {\n                        sum -= digit;\n                    } else {\n                        sum += digit;\n                    }\n                    first = false;\n                    num /= 10;\n                }\n            }\n            \n            if (sum > 0) count++;\n        }\n    }\n    \n    for (int i = aligned_size; i < size; i++) {\n        int num = std::abs(n[i]);\n        int sum = 0;\n        bool first = true;\n        \n        if (num == 0) {\n            sum = 0;\n        } else {\n            while (num) {\n                int digit = num % 10;\n                if (first && n[i] < 0) {\n                    sum -= digit;\n                } else {\n                    sum += digit;\n                }\n                first = false;\n                num /= 10;\n            }\n        }\n        \n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int size = n.size();\n    int aligned_size = size - (size % 4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i sums = _mm_setzero_si128();\n        \n        for (int j = 0; j < 10; j++) {\n            __m128i q = _mm_div_epi32(nums, _mm_set1_epi32(10));\n            __m128i r = _mm_sub_epi32(nums, _mm_mullo_epi32(q, _mm_set1_epi32(10)));\n            sums = _mm_add_epi32(sums, r);\n            nums = q;\n        }\n        \n        __m128i mask = _mm_cmpgt_epi32(sums, zeros);\n        int m = _mm_movemask_ps((__m128)mask);\n        count += _mm_popcnt_u32(m);\n    }\n    \n    for (int i = aligned_size; i < size; i++) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int size = n.size();\n    int aligned_size = size - (size % 4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i sums = _mm_setzero_si128();\n        \n        for (int j = 0; j < 10; j++) {\n            __m128i tens = _mm_set1_epi32(10);\n            __m128i abs_nums = _mm_abs_epi32(nums);\n            __m128i digits = _mm_rem_epi32(abs_nums, tens);\n            \n            __m128i signs = _mm_srai_epi32(nums, 31);\n            digits = _mm_xor_si128(digits, signs);\n            digits = _mm_sub_epi32(digits, signs);\n            \n            sums = _mm_add_epi32(sums, digits);\n            nums = _mm_div_epi32(nums, tens);\n            \n            __m128i all_zeros = _mm_cmpeq_epi32(nums, zeros);\n            if (_mm_movemask_epi8(all_zeros) == 0xFFFF) break;\n        }\n        \n        __m128i nonzero = _mm_cmpgt_epi32(sums, zeros);\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(nonzero));\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    for (int i = aligned_size; i < size; i++) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += (num > 0) ? digit : -digit;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SSE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int size = n.size();\n    int aligned_size = size - (size % 4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&n[i]);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i sums = _mm_setzero_si128();\n        \n        for (int j = 0; j < 10; j++) {\n            __m128i tens = _mm_set1_epi32(10);\n            __m128i abs_nums = _mm_abs_epi32(nums);\n            __m128i digits = _mm_rem_epi32(abs_nums, tens);\n            \n            __m128i signs = _mm_srai_epi32(nums, 31);\n            digits = _mm_xor_si128(digits, signs);\n            digits = _mm_sub_epi32(digits, signs);\n            \n            sums = _mm_add_epi32(sums, digits);\n            nums = _mm_div_epi32(nums, tens);\n            \n            __m128i all_zeros = _mm_cmpeq_epi32(nums, zeros);\n            if (_mm_movemask_epi8(all_zeros) == 0xFFFF) break;\n        }\n        \n        __m128i mask = _mm_cmpgt_epi32(sums, zeros);\n        int result = _mm_movemask_ps(_mm_castsi128_ps(mask));\n        count += _mm_popcnt_u32(result);\n    }\n    \n    for (int i = aligned_size; i < size; i++) {\n        int num = n[i];\n        int sum = 0;\n        while (num != 0) {\n            int digit = abs(num % 10);\n            sum += (num > 0) ? digit : -digit;\n            num /= 10;\n        }\n        if (sum > 0) count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n == 1) return true;\n\n    // Find minimum element and its index\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i curr;\n        if (i + 4 <= n) {\n            curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        } else {\n            // Handle remaining elements\n            alignas(16) int temp[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n            for(int j = i; j < n; j++) {\n                temp[j-i] = arr[j];\n            }\n            curr = _mm_load_si128((__m128i*)temp);\n        }\n        \n        __m128i cmp = _mm_cmplt_epi32(curr, min_val);\n        min_val = _mm_min_epi32(curr, min_val);\n        \n        alignas(16) int min_arr[4];\n        _mm_store_si128((__m128i*)min_arr, cmp);\n        \n        for(int j = 0; j < 4 && i+j < n; j++) {\n            if(min_arr[j]) {\n                min_idx = i + j;\n            }\n        }\n    }\n    \n    // Check if array can be sorted by rotation\n    bool increasing = true;\n    int prev = arr[min_idx];\n    \n    for(int i = 1; i < n; i++) {\n        int curr_idx = (min_idx + i) % n;\n        if(arr[curr_idx] < prev) {\n            increasing = false;\n            break;\n        }\n        prev = arr[curr_idx];\n    }\n    \n    return increasing;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n == 1) return true;\n\n    // Find minimum element and its index\n    __m128i min_val = _mm_set1_epi32(INT_MAX);\n    int min_idx = 0;\n    \n    for (int i = 0; i < n-3; i+=4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i cmp = _mm_cmplt_epi32(curr, min_val);\n        min_val = _mm_min_epi32(curr, min_val);\n        \n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        if (mask) {\n            for (int j = 0; j < 4; j++) {\n                if (mask & (1 << j)) {\n                    min_idx = i + j;\n                }\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < _mm_cvtsi128_si32(min_val)) {\n            min_val = _mm_set1_epi32(arr[i]);\n            min_idx = i;\n        }\n    }\n    \n    // Check if array is sorted after rotation\n    int prev = arr[min_idx];\n    for (int i = 1; i < n; i++) {\n        int curr_idx = (min_idx + i) % n;\n        if (arr[curr_idx] < prev) {\n            return false;\n        }\n        prev = arr[curr_idx];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty() || arr.size() == 1) return true;\n    \n    int n = arr.size();\n    int count = 0;\n    \n    // Find number of rotations needed by finding min element position\n    int minIdx = 0;\n    __m128i vmin = _mm_set1_epi32(arr[0]);\n    \n    for (int i = 0; i < n-3; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmplt_epi32(curr, vmin);\n        \n        if (_mm_movemask_epi8(mask)) {\n            for (int j = 0; j < 4; j++) {\n                if (arr[i+j] < arr[minIdx]) {\n                    minIdx = i+j;\n                }\n            }\n            vmin = _mm_set1_epi32(arr[minIdx]);\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = ((n-1)/4)*4; i < n; i++) {\n        if (arr[i] < arr[minIdx]) {\n            minIdx = i;\n        }\n    }\n    \n    // Rotate array by minIdx positions\n    std::rotate(arr.begin(), arr.begin() + minIdx, arr.end());\n    \n    // Check if sorted after rotation\n    __m128i prev = _mm_set1_epi32(arr[0]);\n    \n    for (int i = 1; i < n-3; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmplt_epi32(curr, prev);\n        \n        if (_mm_movemask_epi8(mask)) {\n            return false;\n        }\n        prev = curr;\n    }\n    \n    // Check remaining elements\n    for (int i = ((n-1)/4)*4; i < n-1; i++) {\n        if (arr[i] > arr[i+1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty() || arr.size() == 1) return true;\n    \n    int n = arr.size();\n    int count = 0;\n    \n    // Find number of rotations needed by finding min element position\n    int min_idx = 0;\n    __m128i min_val = _mm_set1_epi32(arr[0]);\n    \n    for (int i = 0; i <= n-4; i+=4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmplt_epi32(curr, min_val);\n        \n        if (_mm_movemask_epi8(mask)) {\n            for (int j = 0; j < 4; j++) {\n                if (i+j < n && arr[i+j] < arr[min_idx]) {\n                    min_idx = i+j;\n                }\n            }\n            min_val = _mm_set1_epi32(arr[min_idx]);\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < arr[min_idx]) {\n            min_idx = i;\n        }\n    }\n    \n    // Rotate array to put min element at start\n    std::rotate(arr.begin(), arr.begin() + min_idx, arr.end());\n    \n    // Check if array is sorted after rotation\n    __m128i prev = _mm_set1_epi32(arr[0]);\n    \n    for (int i = 1; i <= n-4; i+=4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmplt_epi32(curr, prev);\n        \n        if (_mm_movemask_epi8(mask)) {\n            return false;\n        }\n        prev = curr;\n    }\n    \n    // Check remaining elements\n    int last = arr[(n/4)*4 - 1];\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < last) {\n            return false;\n        }\n        last = arr[i];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SSE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty() || arr.size() == 1) return true;\n    \n    int n = arr.size();\n    int count = 0;\n    \n    // Find number of rotations needed by finding min element position\n    int minPos = 0;\n    __m128i vmin = _mm_set1_epi32(arr[0]);\n    \n    for (int i = 0; i < n-3; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmplt_epi32(curr, vmin);\n        \n        if (_mm_movemask_epi8(mask)) {\n            for (int j = 0; j < 4; j++) {\n                if (arr[i+j] < arr[minPos]) {\n                    minPos = i+j;\n                }\n            }\n            vmin = _mm_set1_epi32(arr[minPos]);\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < arr[minPos]) {\n            minPos = i;\n        }\n    }\n    \n    // Rotate array to put min element at start\n    std::rotate(arr.begin(), arr.begin() + minPos, arr.end());\n    \n    // Check if sorted after rotation\n    __m128i prev = _mm_set1_epi32(arr[0]);\n    \n    for (int i = 1; i < n-3; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i mask = _mm_cmplt_epi32(curr, prev);\n        \n        if (_mm_movemask_epi8(mask)) {\n            return false;\n        }\n        prev = curr;\n    }\n    \n    // Check remaining elements\n    int last = arr[(n/4)*4-1];\n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] < last) {\n            return false;\n        }\n        last = arr[i];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using SSE2\n    int aligned_size = n - (n % 4);\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        // Load 4 elements from lst1\n        __m128i v1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        \n        // Check odd/even by ANDing with 1\n        __m128i mask1 = _mm_and_si128(v1, ones);\n        \n        // Count odd numbers in lst1\n        int odd_mask1 = _mm_movemask_ps(_mm_castsi128_ps(mask1));\n        odd_count1 += _mm_popcnt_u32(odd_mask1);\n        \n        // Load 4 elements from lst2\n        __m128i v2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Check odd/even\n        __m128i mask2 = _mm_and_si128(v2, ones);\n        \n        // Count even numbers in lst2\n        int odd_mask2 = _mm_movemask_ps(_mm_castsi128_ps(mask2));\n        even_count2 += 4 - _mm_popcnt_u32(odd_mask2);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < n; i++) {\n        if(lst1[i] & 1) odd_count1++;\n        if(!(lst2[i] & 1)) even_count2++;\n    }\n    \n    // Check if we have enough even numbers to exchange\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using SSE2\n    int aligned_size = n - (n % 4);\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        // Load 4 elements from lst1\n        __m128i v1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        \n        // Count odd numbers in lst1\n        __m128i and1 = _mm_and_si128(v1, ones);\n        __m128i cmp1 = _mm_cmpeq_epi32(and1, ones);\n        int mask1 = _mm_movemask_ps(_mm_castsi128_ps(cmp1));\n        odd_count1 += _mm_popcnt_u32(mask1);\n        \n        // Load 4 elements from lst2\n        __m128i v2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Count even numbers in lst2\n        __m128i and2 = _mm_and_si128(v2, ones);\n        __m128i cmp2 = _mm_cmpeq_epi32(and2, _mm_setzero_si128());\n        int mask2 = _mm_movemask_ps(_mm_castsi128_ps(cmp2));\n        even_count2 += _mm_popcnt_u32(mask2);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < n; i++) {\n        if(lst1[i] & 1) odd_count1++;\n        if(!(lst2[i] & 1)) even_count2++;\n    }\n    \n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using SSE2\n    int i;\n    for(i = 0; i + 4 <= n; i += 4) {\n        __m128i v1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        __m128i v2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Create mask for odd numbers (LSB = 1)\n        __m128i one = _mm_set1_epi32(1);\n        __m128i mask1 = _mm_and_si128(v1, one);\n        __m128i mask2 = _mm_and_si128(v2, one);\n        \n        // Count odd numbers in lst1\n        int m1 = _mm_movemask_ps(_mm_castsi128_ps(mask1));\n        odd_count1 += _mm_popcnt_u32(m1);\n        \n        // Count even numbers in lst2  \n        int m2 = _mm_movemask_ps(_mm_castsi128_ps(mask2));\n        even_count2 += 4 - _mm_popcnt_u32(m2);\n    }\n    \n    // Handle remaining elements\n    for(; i < n; i++) {\n        odd_count1 += (lst1[i] & 1);\n        even_count2 += !(lst2[i] & 1);\n    }\n\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using SSE2\n    int aligned_size = n - (n % 4);\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        // Load 4 elements from lst1\n        __m128i v1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        \n        // Check odd numbers in lst1\n        __m128i mask1 = _mm_and_si128(v1, ones);\n        int odd_mask1 = _mm_movemask_ps(_mm_castsi128_ps(mask1));\n        odd_count1 += _mm_popcnt_u32(odd_mask1);\n        \n        // Load 4 elements from lst2\n        __m128i v2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Check even numbers in lst2\n        __m128i mask2 = _mm_and_si128(v2, ones);\n        int odd_mask2 = _mm_movemask_ps(_mm_castsi128_ps(mask2));\n        even_count2 += 4 - _mm_popcnt_u32(odd_mask2);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < n; i++) {\n        if(lst1[i] & 1) odd_count1++;\n        if(!(lst2[i] & 1)) even_count2++;\n    }\n    \n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SSE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Process 4 elements at a time using SSE2\n    int aligned_size = n - (n % 4);\n    __m128i ones = _mm_set1_epi32(1);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        // Load 4 elements from lst1\n        __m128i v1 = _mm_loadu_si128((__m128i*)&lst1[i]);\n        \n        // Count odd numbers in lst1\n        __m128i and1 = _mm_and_si128(v1, ones);\n        __m128i cmp1 = _mm_cmpeq_epi32(and1, ones);\n        int mask1 = _mm_movemask_ps(_mm_castsi128_ps(cmp1));\n        odd_count1 += _mm_popcnt_u32(mask1);\n        \n        // Load 4 elements from lst2\n        __m128i v2 = _mm_loadu_si128((__m128i*)&lst2[i]);\n        \n        // Count even numbers in lst2\n        __m128i and2 = _mm_and_si128(v2, ones);\n        __m128i cmp2 = _mm_cmpeq_epi32(and2, _mm_setzero_si128());\n        int mask2 = _mm_movemask_ps(_mm_castsi128_ps(cmp2));\n        even_count2 += _mm_popcnt_u32(mask2);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < n; i++) {\n        if(lst1[i] & 1) odd_count1++;\n        if(!(lst2[i] & 1)) even_count2++;\n    }\n    \n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const int len = str.length();\n        const int simd_len = len / 16;\n        \n        __m128i ones = _mm_set1_epi8(1);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i odd_mask = _mm_set1_epi8(1);\n        __m128i total = _mm_setzero_si128();\n        \n        for (int i = 0; i < simd_len; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(str.c_str() + i * 16));\n            __m128i nums = _mm_sub_epi8(chars, _mm_set1_epi8('0'));\n            __m128i odd = _mm_and_si128(nums, odd_mask);\n            __m128i is_odd = _mm_cmpeq_epi8(odd, ones);\n            total = _mm_add_epi8(total, _mm_and_si128(is_odd, ones));\n        }\n\n        char counts[16];\n        _mm_storeu_si128((__m128i*)counts, total);\n        \n        for (int i = 0; i < 16; i++) {\n            odd_count += counts[i];\n        }\n\n        for (int i = simd_len * 16; i < len; i++) {\n            if ((str[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n\n        std::string output(template_str);\n        size_t pos = output.find('%');\n        while (pos != std::string::npos) {\n            output.replace(pos, 1, std::to_string(odd_count));\n            pos = output.find('%', pos + 1);\n        }\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for(const auto& s : lst) {\n        int odd_count = 0;\n        const int len = s.length();\n        const int simd_len = len / 16;\n        const int remainder = len % 16;\n        \n        __m128i ones = _mm_set1_epi8(1);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i odd_mask = _mm_set1_epi8(1);\n        __m128i total = _mm_setzero_si128();\n        \n        for(int i = 0; i < simd_len; i++) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i * 16));\n            __m128i nums = _mm_sub_epi8(chars, _mm_set1_epi8('0'));\n            __m128i odd = _mm_and_si128(nums, odd_mask);\n            __m128i is_odd = _mm_cmpeq_epi8(odd, ones);\n            total = _mm_add_epi8(total, _mm_and_si128(is_odd, ones));\n        }\n        \n        alignas(16) char counts[16];\n        _mm_store_si128((__m128i*)counts, total);\n        \n        for(int i = 0; i < 16; i++) {\n            odd_count += counts[i];\n        }\n        \n        for(int i = simd_len * 16; i < len; i++) {\n            if((s[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n        \n        std::string output(template_str);\n        size_t pos = output.find('%');\n        while(pos != std::string::npos) {\n            output.replace(pos, 1, std::to_string(odd_count));\n            pos = output.find('%', pos + 1);\n        }\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const int len = str.length();\n        \n        // Process 16 chars at a time using SSE\n        __m128i ones = _mm_set1_epi8(1);\n        __m128i zeros = _mm_setzero_si128();\n        __m128i odd_mask = _mm_set1_epi8(1);\n        \n        for (int i = 0; i < len - 15; i += 16) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(str.c_str() + i));\n            __m128i nums = _mm_sub_epi8(chars, _mm_set1_epi8('0'));\n            __m128i odd = _mm_and_si128(nums, odd_mask);\n            __m128i is_odd = _mm_cmpeq_epi8(odd, ones);\n            \n            int mask = _mm_movemask_epi8(is_odd);\n            odd_count += _mm_popcnt_u32(mask);\n        }\n        \n        // Handle remaining characters\n        for (int i = (len/16)*16; i < len; i++) {\n            if ((str[i] - '0') & 1) {\n                odd_count++;\n            }\n        }\n\n        std::string output(template_str);\n        std::string count_str = std::to_string(odd_count);\n        \n        size_t pos = output.find('%');\n        while (pos != std::string::npos) {\n            output.replace(pos, 1, count_str);\n            pos = output.find('%', pos + 1);\n        }\n        \n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for (const auto& s : lst) {\n        int odd_count = 0;\n        const int len = s.length();\n        \n        // Process 16 characters at a time using SSE\n        __m128i zeros = _mm_setzero_si128();\n        __m128i ones = _mm_set1_epi8(1);\n        __m128i twos = _mm_set1_epi8(2);\n        \n        for (int i = 0; i < len - 15; i += 16) {\n            // Load 16 characters\n            __m128i chars = _mm_loadu_si128((__m128i*)(s.data() + i));\n            \n            // Convert chars to numbers by subtracting '0'\n            chars = _mm_sub_epi8(chars, _mm_set1_epi8('0'));\n            \n            // Get remainder when divided by 2\n            __m128i remainders = _mm_sub_epi8(chars, \n                _mm_mullo_epi16(_mm_srli_epi16(\n                    _mm_mullo_epi16(chars, twos), 1), twos));\n            \n            // Compare with 1 to find odd numbers\n            __m128i odd_mask = _mm_cmpeq_epi8(remainders, ones);\n            \n            // Count number of 1s\n            odd_count += _mm_popcnt_u32(_mm_movemask_epi8(odd_mask));\n        }\n        \n        // Handle remaining characters\n        for (int i = len - (len % 16); i < len; i++) {\n            if ((s[i] - '0') % 2 == 1) {\n                odd_count++;\n            }\n        }\n        \n        // Create result string\n        std::string res;\n        res.reserve(64);\n        \n        const char* ptr = template_str;\n        while (*ptr) {\n            if (*ptr == '%') {\n                res += std::to_string(odd_count);\n            } else {\n                res += *ptr;\n            }\n            ptr++;\n        }\n        \n        result.push_back(res);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SSE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const char* template_str = \"the number of odd elements %n the str%ng % of the %nput.\";\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        \n        // Process 16 characters at a time using SSE\n        const int len = str.length();\n        const char* ptr = str.c_str();\n        int i = 0;\n        \n        for (; i + 15 < len; i += 16) {\n            __m128i chars = _mm_loadu_si128((__m128i*)(ptr + i));\n            \n            // Convert chars to integers by subtracting '0'\n            __m128i nums = _mm_sub_epi8(chars, _mm_set1_epi8('0'));\n            \n            // Create mask for odd numbers\n            __m128i odd_mask = _mm_and_si128(nums, _mm_set1_epi8(1));\n            \n            // Count odd numbers using popcount\n            int mask = _mm_movemask_epi8(_mm_cmpeq_epi8(odd_mask, _mm_set1_epi8(1)));\n            odd_count += _mm_popcnt_u32(mask);\n        }\n        \n        // Handle remaining characters\n        for (; i < len; i++) {\n            int digit = str[i] - '0';\n            odd_count += digit & 1;\n        }\n        \n        // Create result string\n        char result_str[100];\n        snprintf(result_str, sizeof(result_str), template_str, \n                odd_count, odd_count, odd_count, odd_count);\n        \n        result.emplace_back(result_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    if (nums.size() == 1) return nums[0];\n\n    size_t n = nums.size();\n    size_t aligned_size = (n + 1) & ~1ULL;\n    std::vector<int64_t> curr_sum(aligned_size, 0);\n    \n    __m128i min_sum = _mm_set1_epi64x(INT64_MAX);\n    __m128i zero = _mm_setzero_si128();\n    __m128i curr = zero;\n    \n    for (size_t i = 0; i < n; i += 2) {\n        __m128i nums_vec;\n        if (i + 1 < n) {\n            nums_vec = _mm_set_epi64x(nums[i+1], nums[i]);\n        } else {\n            nums_vec = _mm_set_epi64x(0, nums[i]);\n        }\n        \n        curr = _mm_add_epi64(curr, nums_vec);\n        min_sum = _mm_min_epi64(min_sum, curr);\n        \n        __m128i cmp = _mm_cmpgt_epi64(zero, curr);\n        curr = _mm_andnot_si128(cmp, curr);\n    }\n    \n    int64_t min_val = INT64_MAX;\n    int64_t tmp[2];\n    _mm_storeu_si128((__m128i*)tmp, min_sum);\n    min_val = std::min(min_val, tmp[0]);\n    if (n > 1) {\n        min_val = std::min(min_val, tmp[1]);\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    size_t n = nums.size();\n    if (n == 1) return nums[0];\n\n    // Pad input to multiple of 2 elements\n    size_t padded_size = ((n + 1) / 2) * 2;\n    std::vector<int64_t> padded(padded_size, 0);\n    std::copy(nums.begin(), nums.end(), padded.begin());\n\n    __m128i curr_sum = _mm_setzero_si128();\n    __m128i min_sum = _mm_set1_epi64x(INT64_MAX);\n    \n    for (size_t i = 0; i < padded_size; i += 2) {\n        // Load 2 elements\n        __m128i nums_vec = _mm_loadu_si128((__m128i*)&padded[i]);\n        \n        // Add to current sum\n        curr_sum = _mm_add_epi64(curr_sum, nums_vec);\n        \n        // Update min sum\n        min_sum = _mm_min_epi64(min_sum, curr_sum);\n        \n        // Reset current sum if it becomes positive\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpgt_epi64(curr_sum, zero);\n        curr_sum = _mm_andnot_si128(mask, curr_sum);\n    }\n\n    // Extract minimum from min_sum vector\n    int64_t min_vals[2];\n    _mm_storeu_si128((__m128i*)min_vals, min_sum);\n    \n    int64_t result = std::min(min_vals[0], min_vals[1]);\n    \n    // Handle single elements\n    int64_t curr = 0;\n    for (size_t i = 0; i < n; i++) {\n        curr += nums[i];\n        result = std::min(result, curr);\n        if (curr > 0) curr = 0;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    if (nums.size() == 1) return nums[0];\n\n    size_t n = nums.size();\n    size_t aligned_size = (n + 1) & ~1ULL;\n    \n    std::vector<int64_t> curr_sum(aligned_size, 0);\n    std::vector<int64_t> min_sum(aligned_size, 0);\n    \n    curr_sum[0] = nums[0];\n    min_sum[0] = nums[0];\n    \n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 1; i < n; i += 2) {\n        __m128i nums_vec;\n        if (i + 1 < n) {\n            nums_vec = _mm_set_epi64x(nums[i+1], nums[i]);\n        } else {\n            nums_vec = _mm_set_epi64x(0, nums[i]);\n        }\n        \n        __m128i curr_sum_prev = _mm_loadu_si128((__m128i*)&curr_sum[i-1]);\n        __m128i sum = _mm_add_epi64(nums_vec, _mm_alignr_epi8(curr_sum_prev, zero, 8));\n        \n        __m128i compare = _mm_cmpgt_epi64(sum, nums_vec);\n        __m128i result = _mm_blendv_epi8(sum, nums_vec, compare);\n        \n        _mm_storeu_si128((__m128i*)&curr_sum[i], result);\n        \n        __m128i min_sum_prev = _mm_loadu_si128((__m128i*)&min_sum[i-1]);\n        __m128i min_vals = _mm_min_epi64(result, min_sum_prev);\n        _mm_storeu_si128((__m128i*)&min_sum[i], min_vals);\n    }\n    \n    int64_t min_val = min_sum[0];\n    for (size_t i = 1; i < n; i++) {\n        min_val = std::min(min_val, min_sum[i]);\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    const size_t n = nums.size();\n    const size_t simd_size = 2;\n    const size_t aligned_size = (n / simd_size) * simd_size;\n    \n    __m128i curr_sum = _mm_setzero_si128();\n    __m128i min_sum = _mm_setzero_si128();\n    int64_t global_min = nums[0];\n    \n    for (size_t i = 0; i < aligned_size; i += simd_size) {\n        __m128i nums_vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        curr_sum = _mm_add_epi64(curr_sum, nums_vec);\n        \n        __m128i zero = _mm_setzero_si128();\n        __m128i cmp = _mm_cmpgt_epi64(zero, curr_sum);\n        curr_sum = _mm_andnot_si128(cmp, curr_sum);\n        \n        min_sum = _mm_min_epi64(min_sum, curr_sum);\n        \n        int64_t sum_arr[2];\n        _mm_storeu_si128((__m128i*)sum_arr, curr_sum);\n        global_min = std::min(global_min, std::min(sum_arr[0], sum_arr[1]));\n    }\n    \n    int64_t curr = 0;\n    for (size_t i = aligned_size; i < n; i++) {\n        curr += nums[i];\n        if (curr < 0) curr = 0;\n        global_min = std::min(global_min, curr);\n    }\n    \n    int64_t min_arr[2];\n    _mm_storeu_si128((__m128i*)min_arr, min_sum);\n    global_min = std::min(global_min, std::min(min_arr[0], min_arr[1]));\n    \n    if (global_min == 0) {\n        global_min = nums[0];\n        for (size_t i = 0; i < n; i++) {\n            global_min = std::min(global_min, nums[i]);\n        }\n    }\n    \n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SSE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    \n    size_t n = nums.size();\n    size_t aligned_size = (n + 1) & ~1ULL;\n    \n    std::vector<int64_t> curr_sum(aligned_size, 0);\n    std::vector<int64_t> min_sum(aligned_size, 0);\n    \n    __m128i min_val = _mm_set1_epi64x(INT64_MAX);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < n; i += 2) {\n        __m128i num;\n        if (i + 1 < n) {\n            num = _mm_set_epi64x(nums[i+1], nums[i]);\n        } else {\n            num = _mm_set_epi64x(0, nums[i]);\n        }\n        \n        __m128i prev_sum = _mm_loadu_si128((__m128i*)&curr_sum[i]);\n        __m128i sum = _mm_add_epi64(num, prev_sum);\n        \n        // Update current sum\n        _mm_storeu_si128((__m128i*)&curr_sum[i], sum);\n        \n        // Get minimum between current sum and 0\n        __m128i curr_min = _mm_min_epi8(_mm_setzero_si128(), sum);\n        \n        // Update global minimum\n        min_val = _mm_min_epi8(min_val, curr_min);\n        \n        // Store minimum sum\n        _mm_storeu_si128((__m128i*)&min_sum[i], curr_min);\n    }\n    \n    int64_t min_result = INT64_MAX;\n    for (size_t i = 0; i < n; i++) {\n        min_result = std::min(min_result, min_sum[i]);\n    }\n    \n    return min_result;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total = 0;\n    \n    // Process 4 elements at a time using SSE\n    for (int i = 0; i < rows; i++) {\n        int j = 0;\n        int water_count = 0;\n        \n        // Align to 16-byte boundary\n        while (j < cols && ((size_t)&grid[i][j] & 15)) {\n            water_count += grid[i][j];\n            j++;\n        }\n        \n        // Process 4 elements at a time\n        __m128i sum = _mm_setzero_si128();\n        for (; j + 3 < cols; j += 4) {\n            __m128i row = _mm_loadu_si128((__m128i*)&grid[i][j]);\n            sum = _mm_add_epi32(sum, row);\n        }\n        \n        // Horizontal sum of 4 integers\n        sum = _mm_hadd_epi32(sum, sum);\n        sum = _mm_hadd_epi32(sum, sum);\n        water_count += _mm_cvtsi128_si32(sum);\n        \n        // Process remaining elements\n        for (; j < cols; j++) {\n            water_count += grid[i][j];\n        }\n        \n        // Calculate number of bucket operations needed\n        total += (water_count + capacity - 1) / capacity;\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total = 0;\n    \n    // Process 4 columns at a time using SSE\n    for (int j = 0; j < cols; j += 4) {\n        __m128i sum = _mm_setzero_si128();\n        \n        // For each row\n        for (int i = 0; i < rows; i++) {\n            // Load 4 elements or remaining elements if less than 4\n            __m128i row;\n            if (j + 4 <= cols) {\n                row = _mm_setr_epi32(grid[i][j], grid[i][j+1], \n                                   grid[i][j+2], grid[i][j+3]);\n            } else {\n                int remaining = cols - j;\n                int vals[4] = {0};\n                for (int k = 0; k < remaining; k++) {\n                    vals[k] = grid[i][j+k];\n                }\n                row = _mm_setr_epi32(vals[0], vals[1], vals[2], vals[3]);\n            }\n            \n            // Add to running sum\n            sum = _mm_add_epi32(sum, row);\n        }\n        \n        // Extract results\n        int result[4];\n        _mm_storeu_si128((__m128i*)result, sum);\n        \n        // Add up water units and divide by capacity\n        for (int k = 0; k < 4 && j + k < cols; k++) {\n            total += (result[k] + capacity - 1) / capacity;\n        }\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int result = 0;\n    \n    // Process 4 columns at a time using SSE\n    for (int j = 0; j < cols; j += 4) {\n        __m128i sum = _mm_setzero_si128();\n        \n        // Sum water units in each column\n        for (int i = 0; i < rows; i++) {\n            __m128i row;\n            if (j + 4 <= cols) {\n                // Load 4 elements\n                row = _mm_set_epi32(grid[i][j+3], grid[i][j+2], \n                                  grid[i][j+1], grid[i][j]);\n            } else {\n                // Handle remaining elements\n                int v[4] = {0,0,0,0};\n                for(int k = 0; k < cols-j; k++) {\n                    v[k] = grid[i][j+k];\n                }\n                row = _mm_set_epi32(v[3], v[2], v[1], v[0]);\n            }\n            sum = _mm_add_epi32(sum, row);\n        }\n        \n        // Extract sums and add to result\n        int col_sums[4];\n        _mm_store_si128((__m128i*)col_sums, sum);\n        \n        for(int k = 0; k < 4 && j+k < cols; k++) {\n            result += (col_sums[k] + capacity - 1) / capacity;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int result = 0;\n    \n    // Pad input to multiple of 4\n    int padded_cols = ((cols + 3) / 4) * 4;\n    std::vector<std::vector<int>> padded_grid(rows, std::vector<int>(padded_cols, 0));\n    \n    // Copy input data to padded grid\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            padded_grid[i][j] = grid[i][j];\n        }\n    }\n\n    // Process 4 elements at a time using SSE\n    while (true) {\n        bool has_water = false;\n        __m128i zero = _mm_setzero_si128();\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < padded_cols; j += 4) {\n                __m128i* row_ptr = (__m128i*)&padded_grid[i][j];\n                __m128i curr = _mm_load_si128(row_ptr);\n                \n                // Check if any water remains\n                if (_mm_movemask_epi8(_mm_cmpeq_epi32(curr, zero)) != 0xFFFF) {\n                    has_water = true;\n                    \n                    // Extract up to 'capacity' units of water\n                    __m128i count = _mm_set1_epi32(capacity);\n                    __m128i mask = _mm_cmpgt_epi32(curr, zero);\n                    __m128i extract = _mm_min_epi32(curr, count);\n                    curr = _mm_sub_epi32(curr, _mm_and_si128(extract, mask));\n                    \n                    _mm_store_si128(row_ptr, curr);\n                }\n            }\n        }\n        \n        if (!has_water) break;\n        result++;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_119_SSE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int result = 0;\n    \n    // Pad input to multiple of 4\n    int padded_cols = ((cols + 3) / 4) * 4;\n    std::vector<std::vector<int>> padded_grid(rows, std::vector<int>(padded_cols, 0));\n    \n    // Copy input to padded grid\n    for (int i = 0; i < rows; i++) {\n        for (int j = 0; j < cols; j++) {\n            padded_grid[i][j] = grid[i][j];\n        }\n    }\n    \n    // Process 4 elements at a time using SSE\n    while (true) {\n        bool has_water = false;\n        __m128i zero = _mm_setzero_si128();\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < padded_cols; j += 4) {\n                // Load 4 elements\n                __m128i row = _mm_loadu_si128((__m128i*)&padded_grid[i][j]);\n                \n                // Check if any elements are non-zero\n                __m128i cmp = _mm_cmpeq_epi32(row, zero);\n                int mask = _mm_movemask_ps((__m128)cmp);\n                \n                if (mask != 0xF) {\n                    has_water = true;\n                    \n                    // Subtract min(value, capacity) from each element\n                    __m128i cap = _mm_set1_epi32(capacity);\n                    __m128i min_val = _mm_min_epi32(row, cap);\n                    row = _mm_sub_epi32(row, min_val);\n                    \n                    // Store result back\n                    _mm_storeu_si128((__m128i*)&padded_grid[i][j], row);\n                }\n            }\n        }\n        \n        if (!has_water) break;\n        result++;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] & 1) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    __m128i* ptr = (__m128i*)lst.data();\n    __m128i vsum = _mm_setzero_si128();\n    __m128i one = _mm_set1_epi16(1);\n    __m128i mask = _mm_set_epi16(0, 1, 0, 1, 0, 1, 0, 1);\n    \n    int vectorized_size = size - (size % 8);\n    \n    for (int i = 0; i < vectorized_size; i += 8) {\n        __m128i data = _mm_loadu_si128(ptr);\n        __m128i is_odd = _mm_and_si128(data, one);\n        is_odd = _mm_cmpeq_epi16(is_odd, one);\n        __m128i masked = _mm_and_si128(is_odd, data);\n        masked = _mm_and_si128(masked, mask);\n        vsum = _mm_add_epi16(vsum, masked);\n        ptr++;\n    }\n    \n    int16_t temp[8];\n    _mm_storeu_si128((__m128i*)temp, vsum);\n    \n    for (int i = 0; i < 8; i++) {\n        sum += temp[i];\n    }\n    \n    for (int i = vectorized_size; i < size; i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] & 1) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    __m128i* ptr = (__m128i*)lst.data();\n    __m128i vsum = _mm_setzero_si128();\n    __m128i one = _mm_set1_epi16(1);\n    __m128i mask = _mm_set_epi16(0, 1, 0, 1, 0, 1, 0, 1);\n    \n    int vectorized_size = (size / 8) * 8;\n    \n    for (int i = 0; i < vectorized_size; i += 8) {\n        __m128i v = _mm_loadu_si128(ptr);\n        __m128i is_odd = _mm_and_si128(v, one);\n        is_odd = _mm_cmpeq_epi16(is_odd, one);\n        is_odd = _mm_and_si128(is_odd, mask);\n        \n        __m128i masked_values = _mm_and_si128(v, is_odd);\n        vsum = _mm_add_epi16(vsum, masked_values);\n        \n        ptr++;\n    }\n    \n    int16_t temp[8];\n    _mm_storeu_si128((__m128i*)temp, vsum);\n    \n    for (int i = 0; i < 8; i++) {\n        sum += temp[i];\n    }\n    \n    for (int i = vectorized_size; i < size; i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] & 1) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    __m128i vsum = _mm_setzero_si128();\n    __m128i mask = _mm_set1_epi16(1);\n    \n    int i = 0;\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 16-bit integers\n        __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for even positions (1,0,1,0,1,0,1,0)\n        __m128i evenMask = _mm_set_epi16(0, 1, 0, 1, 0, 1, 0, 1);\n        \n        // Keep only elements at even positions\n        data = _mm_and_si128(data, evenMask);\n        \n        // Check which numbers are odd\n        __m128i isOdd = _mm_and_si128(data, mask);\n        \n        // Keep only odd numbers\n        data = _mm_and_si128(data, _mm_cmpeq_epi16(isOdd, mask));\n        \n        // Add to running sum\n        vsum = _mm_add_epi16(vsum, data);\n    }\n    \n    // Extract and sum the results\n    int16_t temp[8];\n    _mm_storeu_si128((__m128i*)temp, vsum);\n    \n    for (int j = 0; j < 8; j++) {\n        sum += temp[j];\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t size = lst.size();\n    size_t aligned_size = size & ~7; // Round down to multiple of 8\n    \n    if (size >= 8) {\n        __m128i sum_vec = _mm_setzero_si128();\n        __m128i one = _mm_set1_epi16(1);\n        __m128i even_mask = _mm_set_epi16(0, -1, 0, -1, 0, -1, 0, -1);\n        \n        for (size_t i = 0; i < aligned_size; i += 8) {\n            // Load 8 16-bit integers\n            __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n            \n            // Check for odd numbers (bitwise AND with 1)\n            __m128i odd_mask = _mm_and_si128(data, one);\n            odd_mask = _mm_cmpeq_epi16(odd_mask, one);\n            \n            // Mask for even positions\n            __m128i masked = _mm_and_si128(odd_mask, even_mask);\n            \n            // Get values where mask is set\n            __m128i values = _mm_and_si128(data, masked);\n            \n            // Add to running sum\n            sum_vec = _mm_add_epi16(sum_vec, values);\n        }\n        \n        // Horizontal sum\n        __m128i sum_hi = _mm_unpackhi_epi16(sum_vec, _mm_setzero_si128());\n        __m128i sum_lo = _mm_unpacklo_epi16(sum_vec, _mm_setzero_si128());\n        __m128i sum32 = _mm_add_epi32(sum_hi, sum_lo);\n        \n        int32_t temp[4];\n        _mm_storeu_si128((__m128i*)temp, sum32);\n        sum = temp[0] + temp[1] + temp[2] + temp[3];\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SSE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    \n    if (size < 8) {\n        for (int i = 0; i < size; i += 2) {\n            if (lst[i] & 1) {\n                sum += lst[i];\n            }\n        }\n        return sum;\n    }\n\n    __m128i vsum = _mm_setzero_si128();\n    __m128i ones = _mm_set1_epi16(1);\n    \n    int i = 0;\n    for (; i + 8 <= size; i += 8) {\n        // Load 8 elements\n        __m128i data = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        // Create mask for even positions (1,0,1,0,1,0,1,0)\n        __m128i pos_mask = _mm_set_epi16(0, 1, 0, 1, 0, 1, 0, 1);\n        \n        // Check for odd numbers\n        __m128i odd_mask = _mm_and_si128(data, ones);\n        \n        // Combine masks\n        __m128i final_mask = _mm_and_si128(odd_mask, pos_mask);\n        \n        // Zero out non-odd numbers and non-even positions\n        __m128i masked_data = _mm_and_si128(data, _mm_cmpeq_epi16(final_mask, ones));\n        \n        // Add to running sum\n        vsum = _mm_add_epi16(vsum, masked_data);\n    }\n    \n    // Horizontal sum\n    int16_t temp[8];\n    _mm_storeu_si128((__m128i*)temp, vsum);\n    \n    for (int j = 0; j < 8; j++) {\n        sum += temp[j];\n    }\n    \n    // Handle remaining elements\n    for (; i < size; i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE2\n    for (; i + 4 <= k; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create masks for numbers >= 100 and >= 1000\n        __m128i mask100 = _mm_set1_epi32(100);\n        __m128i mask1000 = _mm_set1_epi32(1000);\n        \n        // Compare numbers with masks\n        __m128i cmp100 = _mm_cmplt_epi32(nums, mask100);\n        __m128i cmp1000 = _mm_cmplt_epi32(nums, mask1000);\n        \n        // Combine masks to get numbers with 1 or 2 digits\n        __m128i valid = _mm_or_si128(cmp100, cmp1000);\n        \n        // Zero out invalid numbers\n        nums = _mm_and_si128(nums, valid);\n        \n        // Horizontal sum\n        nums = _mm_hadd_epi32(nums, nums);\n        nums = _mm_hadd_epi32(nums, nums);\n        \n        sum += _mm_cvtsi128_si32(nums);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] < 100 || (arr[i] >= 100 && arr[i] < 1000)) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE2\n    for (; i + 4 <= k; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create masks for numbers >= 100 and >= 1000\n        __m128i mask100 = _mm_set1_epi32(100);\n        __m128i mask1000 = _mm_set1_epi32(1000);\n        \n        // Compare numbers with masks\n        __m128i cmp100 = _mm_cmplt_epi32(nums, mask100);\n        __m128i cmp1000 = _mm_cmplt_epi32(nums, mask1000);\n        \n        // Combine masks to get numbers with at most 2 digits\n        __m128i valid = _mm_and_si128(cmp1000, _mm_or_si128(cmp100, cmp1000));\n        \n        // Zero out invalid numbers\n        nums = _mm_and_si128(nums, valid);\n        \n        // Extract elements and add to sum\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, nums);\n        sum += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n        else if (arr[i] >= 100 && arr[i] < 1000) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE2\n    for (; i + 4 <= k; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create masks for numbers >= 100 and >= 1000\n        __m128i mask100 = _mm_set1_epi32(100);\n        __m128i mask1000 = _mm_set1_epi32(1000);\n        \n        // Compare numbers with masks\n        __m128i cmp100 = _mm_cmplt_epi32(nums, mask100);\n        __m128i cmp1000 = _mm_cmplt_epi32(nums, mask1000);\n        \n        // Combine masks to get numbers with 1 or 2 digits\n        __m128i valid = _mm_and_si128(cmp1000, _mm_or_si128(cmp100, cmp1000));\n        \n        // Zero out invalid numbers\n        nums = _mm_and_si128(nums, valid);\n        \n        // Extract elements and add to sum\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, nums);\n        sum += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        } else if (arr[i] >= 100 && arr[i] < 1000) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE2\n    for (; i + 4 <= k; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Create masks for numbers >= 100 and >= 1000\n        __m128i mask100 = _mm_set1_epi32(100);\n        __m128i mask1000 = _mm_set1_epi32(1000);\n        \n        // Compare numbers with masks\n        __m128i cmp100 = _mm_cmplt_epi32(nums, mask100);\n        __m128i cmp1000 = _mm_cmplt_epi32(nums, mask1000);\n        \n        // Combine masks to get numbers with 1 or 2 digits\n        __m128i valid = _mm_or_si128(cmp100, cmp1000);\n        \n        // Zero out invalid numbers\n        nums = _mm_and_si128(nums, valid);\n        \n        // Horizontal sum of valid numbers\n        int temp[4];\n        _mm_storeu_si128((__m128i*)temp, nums);\n        sum += temp[0] + temp[1] + temp[2] + temp[3];\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] < 100 || (arr[i] >= 100 && arr[i] < 1000)) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SSE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n    \n    // Process 4 elements at a time using SSE2\n    for (; i + 4 <= k; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Check if numbers are less than 100 (two digits)\n        __m128i cmp = _mm_cmplt_epi32(nums, _mm_set1_epi32(100));\n        __m128i cmp2 = _mm_cmpgt_epi32(nums, _mm_set1_epi32(-1));\n        __m128i mask = _mm_and_si128(cmp, cmp2);\n        \n        // Zero out numbers with more than 2 digits\n        nums = _mm_and_si128(nums, mask);\n        \n        // Horizontal sum\n        __m128i sum2 = _mm_add_epi32(nums, _mm_srli_si128(nums, 8));\n        __m128i sum4 = _mm_add_epi32(sum2, _mm_srli_si128(sum2, 4));\n        sum += _mm_cvtsi128_si32(sum4);\n    }\n    \n    // Handle remaining elements\n    for (; i < k; i++) {\n        if (arr[i] >= 0 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t i;\n    const size_t simd_size = lst.size() - 4;\n    \n    // Check for duplicates using SIMD\n    for (i = 0; i + 4 <= lst.size(); i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i shifted = _mm_shuffle_epi32(curr, _MM_SHUFFLE(2,1,0,3));\n        __m128i equal = _mm_cmpeq_epi32(curr, shifted);\n        int mask = _mm_movemask_ps((__m128)equal);\n        \n        // Count duplicates in the mask\n        int count = __builtin_popcount(mask);\n        if (count > 1) return false;\n    }\n    \n    // Check remaining elements for duplicates\n    for (; i < lst.size() - 1; i++) {\n        if (lst[i] == lst[i+1]) {\n            int count = 0;\n            for (size_t j = i; j < lst.size() && lst[j] == lst[i]; j++) {\n                count++;\n            }\n            if (count > 2) return false;\n        }\n    }\n\n    // Check if sorted using SIMD\n    for (i = 0; i + 4 <= simd_size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i+1]);\n        \n        __m128i cmp = _mm_cmplt_epi32(curr, next);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask != 15) return false;\n    }\n    \n    // Check remaining elements\n    for (; i < lst.size() - 1; i++) {\n        if (lst[i] >= lst[i+1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t i;\n    const size_t simdSize = 4;\n    const size_t alignedSize = lst.size() & ~(simdSize - 1);\n    \n    // Check sorted order using SIMD\n    for (i = 0; i + simdSize <= alignedSize; i += simdSize) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i+1]);\n        \n        // Compare if current >= next\n        __m128i cmp = _mm_cmpgt_epi32(curr, next);\n        \n        // If any element is greater than next, not sorted\n        if (_mm_movemask_ps(_mm_castsi128_ps(cmp))) {\n            return false;\n        }\n        \n        // Check for more than 2 duplicates in current chunk\n        __m128i eq1 = _mm_cmpeq_epi32(curr, _mm_shuffle_epi32(curr, _MM_SHUFFLE(0,3,2,1)));\n        __m128i eq2 = _mm_cmpeq_epi32(curr, _mm_shuffle_epi32(curr, _MM_SHUFFLE(1,0,3,2)));\n        __m128i eq3 = _mm_cmpeq_epi32(curr, _mm_shuffle_epi32(curr, _MM_SHUFFLE(2,1,0,3)));\n        \n        __m128i dupmask = _mm_or_si128(_mm_or_si128(eq1, eq2), eq3);\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(dupmask));\n        if (_mm_popcnt_u32(mask) > 2) {\n            return false;\n        }\n    }\n    \n    // Check remaining elements\n    for (; i < lst.size() - 1; i++) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n        \n        // Check for more than 2 duplicates\n        int count = 1;\n        for (size_t j = i+1; j < lst.size() && lst[j] == lst[i]; j++) {\n            count++;\n            if (count > 2) return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t size = lst.size();\n    size_t simd_size = size - (size % 4);\n    \n    // Check if sorted in ascending order using SIMD\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        if (i > 0) {\n            __m128i prev = _mm_set1_epi32(lst[i-1]);\n            __m128i cmp = _mm_cmplt_epi32(prev, curr);\n            if (_mm_movemask_ps((__m128)cmp) != 0xF)\n                return false;\n        }\n        \n        // Check current 4 elements are ascending\n        __m128i shifted = _mm_shuffle_epi32(curr, _MM_SHUFFLE(2,1,0,3));\n        __m128i cmp = _mm_cmplt_epi32(shifted, curr);\n        if (_mm_movemask_ps((__m128)cmp) & 0x7)\n            return false;\n    }\n    \n    // Check remaining elements\n    for (size_t i = simd_size; i < size; i++) {\n        if (i > 0 && lst[i] <= lst[i-1])\n            return false;\n    }\n    \n    // Check for more than 1 duplicate\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i shifted = _mm_shuffle_epi32(curr, _MM_SHUFFLE(2,1,0,3)); \n        __m128i equal = _mm_cmpeq_epi32(curr, shifted);\n        int mask = _mm_movemask_ps((__m128)equal);\n        \n        if (i > 0 && _mm_cvtsi128_si32(curr) == lst[i-1]) {\n            if (mask & 0x1) return false;\n        }\n        \n        if (mask & 0x6) return false;\n    }\n    \n    // Check remaining elements for duplicates\n    for (size_t i = simd_size; i < size; i++) {\n        int count = 0;\n        for (size_t j = 0; j < size; j++) {\n            if (lst[i] == lst[j]) count++;\n            if (count > 1) return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t size = lst.size();\n    size_t simd_size = size - (size % 4);\n    \n    // Check if sorted in ascending order using SIMD\n    for (size_t i = 0; i < simd_size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        \n        if (i > 0) {\n            __m128i prev = _mm_loadu_si128((__m128i*)&lst[i-4]);\n            __m128i shifted = _mm_shuffle_epi32(prev, _MM_SHUFFLE(3,3,3,3));\n            __m128i compare = _mm_cmplt_epi32(shifted, curr);\n            if (_mm_movemask_epi8(compare) != 0xFFFF) {\n                return false;\n            }\n        }\n        \n        // Check elements within current vector are ascending\n        __m128i shifted = _mm_shuffle_epi32(curr, _MM_SHUFFLE(2,1,0,3));\n        __m128i compare = _mm_cmplt_epi32(shifted, curr);\n        if (_mm_movemask_epi8(compare) != 0xFFF0) {\n            return false;\n        }\n        \n        // Check for duplicates\n        __m128i dup_check = _mm_cmpeq_epi32(curr, shifted);\n        if (_mm_movemask_epi8(dup_check) & 0xFFF0) {\n            // Found potential duplicate, check count\n            for (size_t j = i; j < i + 4 && j < size; j++) {\n                int count = 0;\n                for (size_t k = 0; k < size; k++) {\n                    if (lst[j] == lst[k]) count++;\n                    if (count > 2) return false;\n                }\n            }\n        }\n    }\n    \n    // Check remaining elements\n    for (size_t i = simd_size; i < size; i++) {\n        if (i > 0 && lst[i] <= lst[i-1]) return false;\n        \n        // Check duplicates\n        int count = 0;\n        for (size_t j = 0; j < size; j++) {\n            if (lst[i] == lst[j]) count++;\n            if (count > 2) return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SSE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n    \n    size_t i;\n    const size_t simdSize = lst.size() - 4;\n    \n    // Check duplicates with SIMD\n    for (i = 0; i + 4 <= lst.size(); i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i shifted = _mm_shuffle_epi32(curr, _MM_SHUFFLE(2,1,0,3));\n        __m128i equal = _mm_cmpeq_epi32(curr, shifted);\n        int mask = _mm_movemask_ps((__m128)equal);\n        \n        // Count duplicates in window\n        int count = 0;\n        for (int j = i; j < i + 4 && j + 1 < lst.size(); j++) {\n            if (lst[j] == lst[j+1]) count++;\n            if (count > 1) return false;\n        }\n    }\n    \n    // Check remaining elements for duplicates\n    for (; i + 1 < lst.size(); i++) {\n        if (lst[i] == lst[i+1]) {\n            int count = 0;\n            for (size_t j = i; j + 1 < lst.size() && lst[j] == lst[j+1]; j++) {\n                count++;\n                if (count > 1) return false;\n            }\n        }\n    }\n\n    // Check if sorted with SIMD\n    for (i = 0; i + 4 <= simdSize; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&lst[i+1]);\n        __m128i cmp = _mm_cmplt_epi32(curr, next);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        if (mask != 15) return false;\n    }\n    \n    // Check remaining elements\n    for (; i + 1 < lst.size(); i++) {\n        if (lst[i] >= lst[i+1]) return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int n = arr.size();\n    int aligned_size = (n + 3) & ~3;\n    \n    alignas(16) int signs[4] = {1,1,1,1};\n    alignas(16) int magnitudes[4] = {0,0,0,0};\n    \n    __m128i sign_prod = _mm_set1_epi32(1);\n    __m128i mag_sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < n; i += 4) {\n        __m128i chunk;\n        if (i + 4 <= n) {\n            chunk = _mm_loadu_si128((__m128i*)&arr[i]);\n        } else {\n            // Handle remaining elements\n            int remaining = n - i;\n            alignas(16) int temp[4] = {0,0,0,0};\n            for(int j = 0; j < remaining; j++) {\n                temp[j] = arr[i+j];\n            }\n            chunk = _mm_load_si128((__m128i*)temp);\n        }\n        \n        // Get signs\n        __m128i zero = _mm_setzero_si128();\n        __m128i is_neg = _mm_cmplt_epi32(chunk, zero);\n        __m128i is_pos = _mm_cmpgt_epi32(chunk, zero);\n        __m128i signs = _mm_or_si128(\n            _mm_and_si128(is_pos, _mm_set1_epi32(1)),\n            _mm_and_si128(is_neg, _mm_set1_epi32(-1))\n        );\n        \n        // Get magnitudes using abs\n        __m128i magnitudes = _mm_abs_epi32(chunk);\n        \n        // Accumulate signs and magnitudes\n        sign_prod = _mm_mullo_epi32(sign_prod, signs);\n        mag_sum = _mm_add_epi32(mag_sum, magnitudes);\n    }\n    \n    _mm_store_si128((__m128i*)signs, sign_prod);\n    _mm_store_si128((__m128i*)magnitudes, mag_sum);\n    \n    // Reduce sign product\n    int final_sign = signs[0] * signs[1] * signs[2] * signs[3];\n    \n    // Reduce magnitude sum\n    int final_sum = magnitudes[0] + magnitudes[1] + magnitudes[2] + magnitudes[3];\n    \n    return final_sign * final_sum;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int n = arr.size();\n    int sign_prod = 1;\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int i = 0; i < n-3; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Get signs\n        __m128i is_neg = _mm_cmplt_epi32(curr, zeros);\n        __m128i is_pos = _mm_cmpgt_epi32(curr, zeros);\n        __m128i signs = _mm_or_si128(\n            _mm_and_si128(is_pos, _mm_set1_epi32(1)),\n            _mm_and_si128(is_neg, _mm_set1_epi32(-1))\n        );\n        \n        // Multiply signs\n        int sign_arr[4];\n        _mm_storeu_si128((__m128i*)sign_arr, signs);\n        for (int j = 0; j < 4; j++) {\n            sign_prod *= sign_arr[j];\n        }\n        \n        // Add magnitudes\n        __m128i abs_vals = _mm_or_si128(\n            _mm_and_si128(is_pos, curr),\n            _mm_and_si128(is_neg, _mm_sub_epi32(zeros, curr))\n        );\n        sum = _mm_add_epi32(sum, abs_vals);\n    }\n    \n    // Handle remaining elements\n    int total = 0;\n    int sum_arr[4];\n    _mm_storeu_si128((__m128i*)sum_arr, sum);\n    for (int i = 0; i < 4; i++) {\n        total += sum_arr[i];\n    }\n    \n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] > 0) {\n            total += arr[i];\n            sign_prod *= 1;\n        }\n        else if (arr[i] < 0) {\n            total += -arr[i];\n            sign_prod *= -1;\n        }\n        else {\n            sign_prod *= 0;\n        }\n    }\n    \n    return total * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int n = arr.size();\n    int sign_prod = 1;\n    \n    __m128i sum = _mm_setzero_si128();\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (int i = 0; i < n-3; i += 4) {\n        __m128i vec = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Get signs\n        __m128i signs = _mm_srai_epi32(vec, 31);\n        signs = _mm_or_si128(signs, _mm_cmpeq_epi32(vec, zeros));\n        \n        // Get absolute values\n        __m128i abs_vec = _mm_abs_epi32(vec);\n        \n        // Add to sum\n        sum = _mm_add_epi32(sum, abs_vec);\n        \n        // Extract signs and multiply\n        int sign_arr[4];\n        _mm_storeu_si128((__m128i*)sign_arr, signs);\n        for (int j = 0; j < 4; j++) {\n            if (sign_arr[j] == 0) {\n                sign_prod = 0;\n            } else if (sign_arr[j] == -1) {\n                sign_prod *= -1;\n            }\n        }\n    }\n    \n    // Handle remaining elements\n    int total = 0;\n    int tmp[4];\n    _mm_storeu_si128((__m128i*)tmp, sum);\n    total = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    \n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] == 0) sign_prod = 0;\n        else if (arr[i] < 0) sign_prod *= -1;\n        total += abs(arr[i]);\n    }\n    \n    return total * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int n = arr.size();\n    int sign_prod = 1;\n    __m128i sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < n-3; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Get signs\n        __m128i zeros = _mm_setzero_si128();\n        __m128i pos = _mm_cmpgt_epi32(nums, zeros);\n        __m128i neg = _mm_cmplt_epi32(nums, zeros);\n        \n        // Convert comparison results to 1/-1\n        __m128i ones = _mm_set1_epi32(1);\n        pos = _mm_and_si128(pos, ones);\n        neg = _mm_and_si128(neg, ones);\n        neg = _mm_sub_epi32(zeros, neg);\n        __m128i signs = _mm_or_si128(pos, neg);\n        \n        // Multiply signs\n        int sign_arr[4];\n        _mm_storeu_si128((__m128i*)sign_arr, signs);\n        sign_prod *= sign_arr[0] * sign_arr[1] * sign_arr[2] * sign_arr[3];\n        \n        // Get absolute values\n        __m128i abs_nums = _mm_abs_epi32(nums);\n        \n        // Add to sum\n        sum = _mm_add_epi32(sum, abs_nums);\n    }\n    \n    // Handle remaining elements\n    int total = 0;\n    int sum_arr[4];\n    _mm_storeu_si128((__m128i*)sum_arr, sum);\n    total = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n    \n    for (int i = (n/4)*4; i < n; i++) {\n        if (arr[i] > 0) sign_prod *= 1;\n        else if (arr[i] < 0) sign_prod *= -1;\n        else sign_prod *= 0;\n        total += abs(arr[i]);\n    }\n    \n    return total * sign_prod;\n}\n```"}
{"task_id": "SimdBench_123_SSE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) return -32768;\n    \n    int n = arr.size();\n    int sign_prod = 1;\n    \n    // Process 4 elements at a time\n    __m128i sum_vec = _mm_setzero_si128();\n    __m128i zero_vec = _mm_setzero_si128();\n    \n    for (int i = 0; i < n-3; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        \n        // Get signs\n        __m128i is_zero = _mm_cmpeq_epi32(curr, zero_vec);\n        __m128i is_neg = _mm_cmplt_epi32(curr, zero_vec);\n        \n        // Compute sign product\n        int zero_mask = _mm_movemask_epi8(is_zero);\n        if (zero_mask) {\n            sign_prod = 0;\n            break;\n        }\n        \n        int neg_mask = _mm_movemask_epi8(is_neg);\n        int neg_count = __builtin_popcount(neg_mask) / 4;\n        sign_prod *= (neg_count % 2 == 0) ? 1 : -1;\n        \n        // Get absolute values\n        __m128i abs_val = _mm_abs_epi32(curr);\n        sum_vec = _mm_add_epi32(sum_vec, abs_val);\n    }\n    \n    // Handle remaining elements\n    int sum = 0;\n    if (sign_prod != 0) {\n        int tmp[4];\n        _mm_storeu_si128((__m128i*)tmp, sum_vec);\n        sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n        \n        for (int i = (n/4)*4; i < n; i++) {\n            if (arr[i] == 0) {\n                sign_prod = 0;\n                break;\n            }\n            sign_prod *= (arr[i] > 0) ? 1 : -1;\n            sum += abs(arr[i]);\n        }\n    }\n    \n    return sum * sign_prod;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result;\n    if (k == 0) return result;\n    \n    // Store minimum path found so far\n    std::vector<int> min_path(k, INT_MAX);\n    \n    // Directions for neighbor cells\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, 1, 0, -1};\n    \n    // Try each starting cell\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::vector<int> curr_path;\n            curr_path.push_back(grid[i][j]);\n            \n            std::function<void(int,int,int)> dfs = [&](int x, int y, int len) {\n                if (len == k) {\n                    // Compare paths using SSE\n                    __m128i* curr_path_ptr = (__m128i*)curr_path.data();\n                    __m128i* min_path_ptr = (__m128i*)min_path.data();\n                    \n                    for (int pos = 0; pos < k; pos += 4) {\n                        __m128i curr_vals = _mm_loadu_si128(curr_path_ptr + pos/4);\n                        __m128i min_vals = _mm_loadu_si128(min_path_ptr + pos/4);\n                        \n                        __m128i cmp = _mm_cmplt_epi32(curr_vals, min_vals);\n                        int mask = _mm_movemask_ps((__m128)cmp);\n                        \n                        if (mask != 0) {\n                            // Found smaller path\n                            min_path = curr_path;\n                            return;\n                        }\n                        \n                        cmp = _mm_cmpgt_epi32(curr_vals, min_vals); \n                        mask = _mm_movemask_ps((__m128)cmp);\n                        if (mask != 0) {\n                            return;\n                        }\n                    }\n                    return;\n                }\n                \n                // Try all neighbor cells\n                for (int d = 0; d < 4; d++) {\n                    int nx = x + dx[d];\n                    int ny = y + dy[d];\n                    \n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                        curr_path.push_back(grid[nx][ny]);\n                        dfs(nx, ny, len + 1);\n                        curr_path.pop_back();\n                    }\n                }\n            };\n            \n            dfs(i, j, 1);\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result;\n    if (k == 0) return result;\n    \n    // Store min path found so far\n    std::vector<int> min_path(k, INT_MAX);\n    \n    // Directions for neighbor cells\n    const int dx[4] = {-1, 0, 1, 0};\n    const int dy[4] = {0, 1, 0, -1};\n    \n    // Try each starting cell\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::vector<int> curr_path;\n            curr_path.push_back(grid[i][j]);\n            \n            std::function<void(int,int,int)> dfs = [&](int x, int y, int len) {\n                if (len == k) {\n                    // Compare paths using SSE\n                    __m128i* curr_path_ptr = (__m128i*)curr_path.data();\n                    __m128i* min_path_ptr = (__m128i*)min_path.data();\n                    \n                    for (int pos = 0; pos < k; pos += 4) {\n                        __m128i curr_vals = _mm_loadu_si128(curr_path_ptr + pos/4);\n                        __m128i min_vals = _mm_loadu_si128(min_path_ptr + pos/4);\n                        \n                        __m128i cmp = _mm_cmplt_epi32(curr_vals, min_vals);\n                        int mask = _mm_movemask_ps((__m128)cmp);\n                        \n                        if (mask != 0) {\n                            // Found smaller path\n                            min_path = curr_path;\n                            return;\n                        }\n                        \n                        cmp = _mm_cmpgt_epi32(curr_vals, min_vals); \n                        mask = _mm_movemask_ps((__m128)cmp);\n                        if (mask != 0) {\n                            return;\n                        }\n                    }\n                    return;\n                }\n                \n                // Try all neighbor cells\n                for (int d = 0; d < 4; d++) {\n                    int nx = x + dx[d];\n                    int ny = y + dy[d];\n                    \n                    if (nx >= 0 && nx < n && ny >= 0 && ny < n) {\n                        curr_path.push_back(grid[nx][ny]);\n                        dfs(nx, ny, len + 1);\n                        curr_path.pop_back();\n                    }\n                }\n            };\n            \n            dfs(i, j, 1);\n        }\n    }\n    \n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = grid[0][0];\n        int minRow = 0, minCol = 0;\n        \n        for (int i = 0; i < n; i += 4) {\n            for (int j = 0; j < n; j++) {\n                __m128i row = _mm_setr_epi32(\n                    i < n ? grid[i][j] : INT_MAX,\n                    i+1 < n ? grid[i+1][j] : INT_MAX,\n                    i+2 < n ? grid[i+2][j] : INT_MAX,\n                    i+3 < n ? grid[i+3][j] : INT_MAX\n                );\n                \n                __m128i cmp = _mm_set1_epi32(minVal);\n                __m128i mask = _mm_cmplt_epi32(row, cmp);\n                \n                if (_mm_movemask_ps(_mm_castsi128_ps(mask))) {\n                    for (int k = 0; k < 4 && i+k < n; k++) {\n                        if (grid[i+k][j] < minVal) {\n                            minVal = grid[i+k][j];\n                            minRow = i+k;\n                            minCol = j;\n                        }\n                    }\n                }\n            }\n        }\n        result[0] = grid[minRow][minCol];\n        return result;\n    }\n    \n    int minVal = INT_MAX;\n    int startRow = 0, startCol = 0;\n    \n    for (int i = 0; i < n; i += 4) {\n        for (int j = 0; j < n; j++) {\n            __m128i vals = _mm_setr_epi32(\n                i < n ? grid[i][j] : INT_MAX,\n                i+1 < n ? grid[i+1][j] : INT_MAX, \n                i+2 < n ? grid[i+2][j] : INT_MAX,\n                i+3 < n ? grid[i+3][j] : INT_MAX\n            );\n            \n            __m128i minv = _mm_set1_epi32(minVal);\n            __m128i mask = _mm_cmplt_epi32(vals, minv);\n            \n            if (_mm_movemask_ps(_mm_castsi128_ps(mask))) {\n                for (int k = 0; k < 4 && i+k < n; k++) {\n                    if (grid[i+k][j] < minVal) {\n                        minVal = grid[i+k][j];\n                        startRow = i+k;\n                        startCol = j;\n                    }\n                }\n            }\n        }\n    }\n    \n    result[0] = grid[startRow][startCol];\n    \n    const int dx[] = {-1, 0, 1, 0};\n    const int dy[] = {0, 1, 0, -1};\n    \n    int curRow = startRow;\n    int curCol = startCol;\n    \n    for (int step = 1; step < k; step++) {\n        int nextVal = INT_MAX;\n        int nextRow = curRow;\n        int nextCol = curCol;\n        \n        __m128i minVec = _mm_set1_epi32(nextVal);\n        \n        for (int dir = 0; dir < 4; dir++) {\n            int newRow = curRow + dx[dir];\n            int newCol = curCol + dy[dir];\n            \n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                int val = grid[newRow][newCol];\n                if (val < nextVal) {\n                    nextVal = val;\n                    nextRow = newRow;\n                    nextCol = newCol;\n                }\n            }\n        }\n        \n        result[step] = grid[nextRow][nextCol];\n        curRow = nextRow;\n        curCol = nextCol;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = INT_MAX;\n        int minRow = 0, minCol = 0;\n        \n        for (int i = 0; i < n; i++) {\n            __m128i row = _mm_loadu_si128((__m128i*)&grid[i][0]);\n            __m128i minVec = _mm_set1_epi32(minVal);\n            __m128i cmpMask = _mm_cmplt_epi32(row, minVec);\n            \n            for (int j = 0; j < n; j++) {\n                if (_mm_movemask_epi8(cmpMask) & (1 << (j*4))) {\n                    minVal = grid[i][j];\n                    minRow = i;\n                    minCol = j;\n                }\n            }\n        }\n        result[0] = minVal;\n        return result;\n    }\n    \n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    int minRow = 0, minCol = 0;\n    int minFirst = INT_MAX;\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < minFirst) {\n                minFirst = grid[i][j];\n                minRow = i;\n                minCol = j;\n            }\n        }\n    }\n    \n    result[0] = minFirst;\n    \n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n    \n    for (int step = 1; step < k; step++) {\n        int nextVal = INT_MAX;\n        int nextRow = minRow, nextCol = minCol;\n        \n        __m128i minVec = _mm_set1_epi32(nextVal);\n        \n        for (int d = 0; d < 4; d++) {\n            int newRow = minRow + dx[d];\n            int newCol = minCol + dy[d];\n            \n            if (newRow >= 0 && newRow < n && newCol >= 0 && newCol < n) {\n                if (grid[newRow][newCol] < nextVal) {\n                    nextVal = grid[newRow][newCol];\n                    nextRow = newRow;\n                    nextCol = newCol;\n                }\n            }\n        }\n        \n        result[step] = nextVal;\n        minRow = nextRow;\n        minCol = nextCol;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SSE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = INT_MAX;\n        int minRow = 0, minCol = 0;\n        \n        for (int i = 0; i < n; i++) {\n            __m128i row = _mm_loadu_si128((__m128i*)&grid[i][0]);\n            __m128i minVec = _mm_set1_epi32(minVal);\n            __m128i cmpMask = _mm_cmplt_epi32(row, minVec);\n            \n            int mask = _mm_movemask_ps(_mm_castsi128_ps(cmpMask));\n            \n            while (mask) {\n                int pos = __builtin_ctz(mask);\n                if (grid[i][pos] < minVal) {\n                    minVal = grid[i][pos];\n                    minRow = i;\n                    minCol = pos;\n                }\n                mask &= (mask - 1);\n            }\n        }\n        result[0] = grid[minRow][minCol];\n        return result;\n    }\n    \n    std::vector<std::vector<int>> dp(n, std::vector<int>(n, INT_MAX));\n    std::vector<std::vector<std::pair<int,int>>> parent(k, std::vector<std::pair<int,int>>(n*n));\n    \n    int minRow = 0, minCol = 0;\n    int minValue = INT_MAX;\n    \n    for (int len = 0; len < k; len++) {\n        std::vector<std::vector<int>> newDp(n, std::vector<int>(n, INT_MAX));\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (len == 0) {\n                    newDp[i][j] = grid[i][j];\n                    if (grid[i][j] < minValue) {\n                        minValue = grid[i][j];\n                        minRow = i;\n                        minCol = j;\n                    }\n                    continue;\n                }\n                \n                const int dx[] = {-1, 1, 0, 0};\n                const int dy[] = {0, 0, -1, 1};\n                \n                __m128i currMin = _mm_set1_epi32(INT_MAX);\n                \n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    \n                    if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                        __m128i prev = _mm_set1_epi32(dp[ni][nj]);\n                        __m128i curr = _mm_set1_epi32(grid[i][j]);\n                        currMin = _mm_min_epi32(currMin, _mm_add_epi32(prev, curr));\n                        \n                        if (dp[ni][nj] != INT_MAX && dp[ni][nj] + grid[i][j] < newDp[i][j]) {\n                            newDp[i][j] = dp[ni][nj] + grid[i][j];\n                            parent[len][i*n + j] = {ni, nj};\n                            \n                            if (len == k-1 && newDp[i][j] < minValue) {\n                                minValue = newDp[i][j];\n                                minRow = i;\n                                minCol = j;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        dp = newDp;\n    }\n    \n    int currRow = minRow;\n    int currCol = minCol;\n    \n    for (int i = k-1; i >= 0; i--) {\n        result[i] = grid[currRow][currCol];\n        if (i > 0) {\n            auto [nextRow, nextCol] = parent[i][currRow*n + currCol];\n            currRow = nextRow;\n            currCol = nextCol;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad with zeros to multiple of 16\n    while (len % 16 != 0) {\n        digits[len++] = '0';\n    }\n    \n    // Load masks for checking odd digits\n    __m128i zero = _mm_setzero_si128();\n    __m128i ascii_zero = _mm_set1_epi8('0');\n    __m128i one = _mm_set1_epi8(1);\n    \n    __m128i prod = _mm_set1_epi8(1);\n    __m128i has_odd = _mm_setzero_si128();\n    \n    // Process 16 digits at a time\n    for (int i = 0; i < len; i += 16) {\n        // Load 16 digits\n        __m128i digits_vec = _mm_loadu_si128((__m128i*)(digits + i));\n        \n        // Convert ASCII to numeric\n        __m128i nums = _mm_sub_epi8(digits_vec, ascii_zero);\n        \n        // Check which digits are odd\n        __m128i odd = _mm_and_si128(nums, one);\n        odd = _mm_cmpeq_epi8(odd, one);\n        \n        // Update has_odd flag\n        has_odd = _mm_or_si128(has_odd, odd);\n        \n        // Multiply odd digits (set even digits to 1)\n        __m128i masked = _mm_or_si128(_mm_and_si128(odd, nums), \n                                    _mm_andnot_si128(odd, one));\n        prod = _mm_mullo_epi16(_mm_unpacklo_epi8(prod, zero),\n                              _mm_unpacklo_epi8(masked, zero));\n        prod = _mm_mullo_epi16(_mm_unpackhi_epi8(prod, zero),\n                              _mm_unpackhi_epi8(masked, zero));\n    }\n    \n    // Horizontal multiply of prod\n    __m128i tmp = prod;\n    tmp = _mm_mullo_epi16(tmp, _mm_srli_si128(tmp, 8));\n    tmp = _mm_mullo_epi16(tmp, _mm_srli_si128(tmp, 4));\n    tmp = _mm_mullo_epi16(tmp, _mm_srli_si128(tmp, 2));\n    \n    // Check if any odd digits found\n    int mask = _mm_movemask_epi8(has_odd);\n    \n    if (mask == 0) return 0;\n    return _mm_extract_epi16(tmp, 0) & 0xFF;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad with zeros to multiple of 16\n    int padded_len = (len + 15) & ~15;\n    char padded[32] = {0};\n    memcpy(padded, digits, len);\n    \n    // Load digit chars into SIMD registers\n    __m128i v_digits = _mm_loadu_si128((__m128i*)padded);\n    \n    // Convert chars to integers by subtracting '0'\n    __m128i v_zero = _mm_set1_epi8('0');\n    v_digits = _mm_sub_epi8(v_digits, v_zero);\n    \n    // Create mask for odd digits\n    __m128i v_one = _mm_set1_epi8(1);\n    __m128i v_odd = _mm_and_si128(v_digits, v_one);\n    \n    // Zero out even digits\n    __m128i v_zeros = _mm_setzero_si128();\n    v_digits = _mm_andnot_si128(_mm_cmpeq_epi8(v_odd, v_zeros), v_digits);\n    \n    // Initialize product\n    uint64_t product = 1;\n    uint8_t* p = (uint8_t*)&v_digits;\n    \n    // Multiply non-zero digits\n    bool has_odd = false;\n    for (int i = 0; i < len; i++) {\n        if (p[i] > 0) {\n            product *= p[i];\n            has_odd = true;\n        }\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad with zeros to multiple of 16\n    int padded_len = ((len + 15) / 16) * 16;\n    for (int i = len; i < padded_len; i++) {\n        digits[i] = '0';\n    }\n\n    __m128i result = _mm_set1_epi8(1);\n    __m128i zero = _mm_set1_epi8('0');\n    __m128i one = _mm_set1_epi8(1);\n    __m128i two = _mm_set1_epi8(2);\n    \n    for (int i = 0; i < padded_len; i += 16) {\n        // Load 16 digits\n        __m128i nums = _mm_loadu_si128((__m128i*)(digits + i));\n        \n        // Convert chars to actual numbers\n        nums = _mm_sub_epi8(nums, zero);\n        \n        // Check if odd\n        __m128i remainder = _mm_and_si128(nums, one);\n        __m128i is_odd = _mm_cmpeq_epi8(remainder, one);\n        \n        // Mask even digits to 1 so they don't affect product\n        nums = _mm_or_si128(_mm_and_si128(is_odd, nums), \n                           _mm_andnot_si128(is_odd, one));\n                           \n        // Multiply into result\n        result = _mm_mullo_epi16(_mm_unpacklo_epi8(result, zero),\n                                _mm_unpacklo_epi8(nums, zero));\n        result = _mm_mullo_epi16(_mm_unpackhi_epi8(result, zero),\n                                _mm_unpackhi_epi8(nums, zero));\n    }\n\n    // Horizontal multiply\n    __m128i prod = _mm_mullo_epi16(\n        result,\n        _mm_shuffle_epi32(result, _MM_SHUFFLE(2,3,0,1))\n    );\n    prod = _mm_mullo_epi16(\n        prod, \n        _mm_shuffle_epi32(prod, _MM_SHUFFLE(1,0,3,2))\n    );\n    \n    uint64_t final = 1;\n    uint16_t* vals = (uint16_t*)&prod;\n    for (int i = 0; i < 8; i++) {\n        final *= vals[i];\n    }\n\n    // Check if any odd digits exist\n    bool has_odd = false;\n    for (int i = 0; i < len; i++) {\n        if ((digits[i] - '0') % 2 == 1) {\n            has_odd = true;\n            break;\n        }\n    }\n\n    return has_odd ? final : 0;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad with zeros to multiple of 16\n    int padded_len = (len + 15) & ~15;\n    char padded[32] = {0};\n    memcpy(padded, digits, len);\n    \n    // Load digits into SSE registers\n    __m128i zero = _mm_setzero_si128();\n    __m128i ascii_0 = _mm_set1_epi8('0');\n    __m128i one = _mm_set1_epi8(1);\n    __m128i product = _mm_set1_epi8(1);\n    \n    for (int i = 0; i < padded_len; i += 16) {\n        // Load 16 bytes\n        __m128i data = _mm_loadu_si128((__m128i*)(padded + i));\n        \n        // Convert ASCII to numeric\n        __m128i nums = _mm_sub_epi8(data, ascii_0);\n        \n        // Check if odd (LSB == 1)\n        __m128i odd = _mm_and_si128(nums, one);\n        __m128i is_odd = _mm_cmpeq_epi8(odd, one);\n        \n        // Mask out even digits\n        __m128i masked = _mm_and_si128(nums, is_odd);\n        \n        // Multiply odd digits\n        __m128i tmp = _mm_or_si128(masked, _mm_andnot_si128(is_odd, one));\n        product = _mm_mullo_epi16(_mm_unpacklo_epi8(product, zero),\n                                 _mm_unpacklo_epi8(tmp, zero));\n        product = _mm_mullo_epi16(_mm_unpackhi_epi8(product, zero), \n                                 _mm_unpackhi_epi8(tmp, zero));\n    }\n    \n    // Horizontal multiply to get final result\n    uint8_t result[16];\n    _mm_storeu_si128((__m128i*)result, product);\n    \n    uint64_t final = 1;\n    bool has_odd = false;\n    \n    for (int i = 0; i < 16; i++) {\n        if (result[i] > 1) {\n            final *= result[i];\n            has_odd = true;\n        }\n    }\n    \n    return has_odd ? final : 0;\n}\n```"}
{"task_id": "SimdBench_125_SSE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to string of digits\n    char digits[20];\n    int len = sprintf(digits, \"%lu\", n);\n    \n    // Pad with zeros to multiple of 16\n    int padded_len = ((len + 15) / 16) * 16;\n    for(int i = len; i < padded_len; i++) {\n        digits[i] = '0';\n    }\n\n    __m128i prod = _mm_set1_epi8(1);\n    __m128i zero = _mm_setzero_si128();\n    __m128i ascii_zero = _mm_set1_epi8('0');\n    __m128i two = _mm_set1_epi8(2);\n    \n    for(int i = 0; i < padded_len; i += 16) {\n        // Load 16 digits\n        __m128i nums = _mm_loadu_si128((__m128i*)(digits + i));\n        \n        // Convert ASCII to integers\n        nums = _mm_sub_epi8(nums, ascii_zero);\n        \n        // Check if odd (num % 2 == 1)\n        __m128i odd = _mm_and_si128(nums, _mm_set1_epi8(1));\n        __m128i is_odd = _mm_cmpeq_epi8(odd, _mm_set1_epi8(1));\n        \n        // Zero out even numbers\n        nums = _mm_and_si128(nums, is_odd);\n        \n        // Add 1 to zeros to avoid multiplying by 0\n        nums = _mm_add_epi8(nums, _mm_and_si128(_mm_cmpeq_epi8(nums, zero), _mm_set1_epi8(1)));\n        \n        // Multiply with running product\n        prod = _mm_mullo_epi8(prod, nums);\n    }\n    \n    // Extract result\n    uint64_t result = 1;\n    uint8_t *p = (uint8_t*)&prod;\n    for(int i = 0; i < 16; i++) {\n        if(p[i] > 1) result *= p[i];\n    }\n    \n    // Check if any odd digits were found\n    bool has_odd = false;\n    for(int i = 0; i < len; i++) {\n        if((digits[i] - '0') % 2 == 1) {\n            has_odd = true;\n            break;\n        }\n    }\n    \n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t aligned_size = size & ~3;\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        __m128 sum_vec = _mm_setzero_ps();\n        \n        for (size_t i = 0; i < aligned_size; i += 4) {\n            // Load 4 floats\n            __m128 vec = _mm_loadu_ps(&lst[i]);\n            \n            // Ceiling operation\n            vec = _mm_ceil_ps(vec);\n            \n            // Square the values\n            vec = _mm_mul_ps(vec, vec);\n            \n            // Accumulate sum\n            sum_vec = _mm_add_ps(sum_vec, vec);\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum_vec, sum_vec, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum_vec, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        sum = static_cast<uint64_t>(_mm_cvtss_f32(sums));\n    }\n\n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        float val = ceilf(lst[i]);\n        sum += static_cast<uint64_t>(val * val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t aligned_size = size & ~3;\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        __m128 sum_vec = _mm_setzero_ps();\n        \n        for (size_t i = 0; i < aligned_size; i += 4) {\n            // Load 4 floats\n            __m128 vec = _mm_loadu_ps(&lst[i]);\n            \n            // Ceiling operation\n            vec = _mm_ceil_ps(vec);\n            \n            // Square the values\n            vec = _mm_mul_ps(vec, vec);\n            \n            // Accumulate sum\n            sum_vec = _mm_add_ps(sum_vec, vec);\n        }\n        \n        // Horizontal sum\n        __m128 shuf = _mm_shuffle_ps(sum_vec, sum_vec, _MM_SHUFFLE(2, 3, 0, 1));\n        __m128 sums = _mm_add_ps(sum_vec, shuf);\n        shuf = _mm_movehl_ps(shuf, sums);\n        sums = _mm_add_ss(sums, shuf);\n        sum = static_cast<uint64_t>(_mm_cvtss_f32(sums));\n    }\n\n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        float val = ceilf(lst[i]);\n        sum += static_cast<uint64_t>(val * val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t aligned_size = size & ~3;\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        __m128 sum_vec = _mm_setzero_ps();\n        \n        for (size_t i = 0; i < aligned_size; i += 4) {\n            __m128 vec = _mm_loadu_ps(&lst[i]);\n            __m128 ceil_vec = _mm_ceil_ps(vec);\n            __m128 square = _mm_mul_ps(ceil_vec, ceil_vec);\n            sum_vec = _mm_add_ps(sum_vec, square);\n        }\n\n        float temp[4];\n        _mm_storeu_ps(temp, sum_vec);\n        sum = static_cast<uint64_t>(temp[0] + temp[1] + temp[2] + temp[3]);\n    }\n\n    for (size_t i = aligned_size; i < size; i++) {\n        float ceil_val = std::ceil(lst[i]);\n        sum += static_cast<uint64_t>(ceil_val * ceil_val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t aligned_size = size & ~3;\n    uint64_t sum = 0;\n\n    if (size >= 4) {\n        __m128 sum_vec = _mm_setzero_ps();\n        \n        for (size_t i = 0; i < aligned_size; i += 4) {\n            __m128 vec = _mm_loadu_ps(&lst[i]);\n            __m128 ceil_vec = _mm_ceil_ps(vec);\n            __m128 square = _mm_mul_ps(ceil_vec, ceil_vec);\n            sum_vec = _mm_add_ps(sum_vec, square);\n        }\n\n        float temp[4];\n        _mm_storeu_ps(temp, sum_vec);\n        sum = (uint64_t)(temp[0] + temp[1] + temp[2] + temp[3]);\n    }\n\n    for (size_t i = aligned_size; i < size; i++) {\n        float ceil_val = ceilf(lst[i]);\n        sum += (uint64_t)(ceil_val * ceil_val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SSE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t size = lst.size();\n    size_t aligned_size = size - (size % 4);\n    uint64_t sum = 0;\n\n    __m128 sum_vec = _mm_setzero_ps();\n    \n    for(size_t i = 0; i < aligned_size; i += 4) {\n        // Load 4 floats\n        __m128 vec = _mm_loadu_ps(&lst[i]);\n        \n        // Ceiling operation\n        vec = _mm_ceil_ps(vec);\n        \n        // Square the numbers\n        vec = _mm_mul_ps(vec, vec);\n        \n        // Add to running sum\n        sum_vec = _mm_add_ps(sum_vec, vec);\n    }\n\n    // Extract sum from vector\n    float temp[4];\n    _mm_storeu_ps(temp, sum_vec);\n    sum = (uint64_t)(temp[0] + temp[1] + temp[2] + temp[3]);\n\n    // Handle remaining elements\n    for(size_t i = aligned_size; i < size; i++) {\n        float val = ceilf(lst[i]);\n        sum += (uint64_t)(val * val);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int n = arr.size();\n    int aligned_size = ((n-1) / 4) * 4;\n    int result = -1;\n\n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        __m128i cmp = _mm_cmplt_epi32(next, curr);\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask) {\n            result = i + _tzcnt_u32(mask);\n        }\n    }\n\n    for (int i = aligned_size; i < n-1; i++) {\n        if (arr[i+1] < arr[i]) {\n            result = i+1;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int result = -1;\n    \n    // Process 4 elements at a time\n    for (int i = 0; i <= n-4; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        // Compare if current elements are greater than next elements\n        __m128i cmp = _mm_cmpgt_epi32(curr, next);\n        \n        // Get mask of comparison results\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask) {\n            // Find first set bit\n            result = i + _tzcnt_u32(mask);\n            break;\n        }\n    }\n    \n    // Handle remaining elements\n    if (result == -1) {\n        for (int i = ((n-1)/4)*4; i < n-1; i++) {\n            if (arr[i] > arr[i+1]) {\n                result = i+1;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int n = arr.size();\n    int result = -1;\n    \n    // Process 4 elements at a time\n    for (int i = 0; i < n-4; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        // Compare if current elements are greater than next elements\n        __m128i cmp = _mm_cmpgt_epi32(curr, next);\n        \n        // Get mask of comparison results\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask) {\n            // Find first set bit\n            result = i + _tzcnt_u32(mask);\n            break;\n        }\n    }\n\n    // Handle remaining elements\n    if (result == -1) {\n        for (int i = ((n-1)/4)*4; i < n-1; i++) {\n            if (arr[i] > arr[i+1]) {\n                result = i+1;\n                break;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int result = -1;\n    \n    // Process 4 elements at a time\n    for (int i = 0; i <= n-4; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]); \n        \n        // Compare if next < curr\n        __m128i cmp = _mm_cmplt_epi32(next, curr);\n        \n        // Get mask of comparisons\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(cmp));\n        \n        if (mask) {\n            // Find first set bit\n            result = i + _tzcnt_u32(mask);\n            break;\n        }\n    }\n    \n    // Handle remaining elements\n    if (result == -1) {\n        for (int i = ((n-1)/4)*4; i < n-1; i++) {\n            if (arr[i+1] < arr[i]) {\n                result = i+1;\n                break;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SSE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n    \n    int n = arr.size();\n    int result = -1;\n    \n    // Process 4 elements at a time\n    for (int i = 0; i <= n-4; i += 4) {\n        __m128i curr = _mm_loadu_si128((__m128i*)&arr[i]);\n        __m128i next = _mm_loadu_si128((__m128i*)&arr[i+1]);\n        \n        // Compare if next elements are less than current\n        __m128i cmp = _mm_cmplt_epi32(next, curr);\n        int mask = _mm_movemask_ps((__m128)cmp);\n        \n        if (mask) {\n            // Find first set bit\n            int pos = _tzcnt_u32(mask);\n            result = i + pos + 1;\n        }\n    }\n    \n    // Handle remaining elements\n    for (int i = (n/4)*4; i < n-1; i++) {\n        if (arr[i+1] < arr[i]) {\n            result = i+1;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    __m128i max_neg = _mm_set1_epi32(0x80000000);  // Minimum possible integer\n    __m128i min_pos = _mm_set1_epi32(0x7FFFFFFF);  // Maximum possible integer\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        __m128i curr;\n        if (i + 4 <= lst.size()) {\n            curr = _mm_loadu_si128((__m128i*)(lst.data() + i));\n        } else {\n            alignas(16) int temp[4] = {0};\n            for (size_t j = i; j < lst.size(); j++) {\n                temp[j - i] = lst[j];\n            }\n            curr = _mm_load_si128((__m128i*)temp);\n        }\n\n        __m128i is_neg = _mm_cmplt_epi32(curr, zeros);\n        __m128i is_pos = _mm_cmpgt_epi32(curr, zeros);\n        \n        __m128i neg_vals = _mm_and_si128(curr, is_neg);\n        __m128i pos_vals = _mm_and_si128(curr, is_pos);\n        \n        max_neg = _mm_max_epi32(max_neg, neg_vals);\n        min_pos = _mm_min_epi32(_mm_or_si128(min_pos, _mm_andnot_si128(is_pos, _mm_set1_epi32(0x7FFFFFFF))), pos_vals);\n    }\n\n    alignas(16) int result_neg[4];\n    alignas(16) int result_pos[4];\n    _mm_store_si128((__m128i*)result_neg, max_neg);\n    _mm_store_si128((__m128i*)result_pos, min_pos);\n\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    \n    for (int i = 0; i < 4; i++) {\n        if (result_neg[i] < 0) {\n            largest_neg = std::max(largest_neg, result_neg[i]);\n        }\n        if (result_pos[i] > 0) {\n            if (smallest_pos == 0) {\n                smallest_pos = result_pos[i];\n            } else {\n                smallest_pos = std::min(smallest_pos, result_pos[i]);\n            }\n        }\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    __m128i max_neg = _mm_set1_epi32(0x80000000);  // Minimum possible int\n    __m128i min_pos = _mm_set1_epi32(0x7FFFFFFF);  // Maximum possible int\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        __m128i curr;\n        if (i + 4 <= lst.size()) {\n            curr = _mm_loadu_si128((__m128i*)(lst.data() + i));\n        } else {\n            // Handle remaining elements\n            alignas(16) int temp[4] = {0};\n            for(size_t j = 0; j < lst.size() - i; j++) {\n                temp[j] = lst[i + j];\n            }\n            curr = _mm_load_si128((__m128i*)temp);\n        }\n\n        __m128i is_neg = _mm_cmplt_epi32(curr, zeros);\n        __m128i is_pos = _mm_cmpgt_epi32(curr, zeros);\n        \n        __m128i neg_vals = _mm_and_si128(curr, is_neg);\n        __m128i pos_vals = _mm_and_si128(curr, is_pos);\n        \n        max_neg = _mm_max_epi32(max_neg, neg_vals);\n        min_pos = _mm_min_epi32(_mm_or_si128(min_pos, _mm_andnot_si128(is_pos, _mm_set1_epi32(0x7FFFFFFF))), pos_vals);\n    }\n\n    alignas(16) int neg_results[4];\n    alignas(16) int pos_results[4];\n    _mm_store_si128((__m128i*)neg_results, max_neg);\n    _mm_store_si128((__m128i*)pos_results, min_pos);\n\n    int max_negative = 0;\n    int min_positive = 0;\n    \n    for(int i = 0; i < 4; i++) {\n        if(neg_results[i] < 0) {\n            max_negative = std::max(max_negative, neg_results[i]);\n        }\n        if(pos_results[i] > 0) {\n            if(min_positive == 0) min_positive = pos_results[i];\n            else min_positive = std::min(min_positive, pos_results[i]);\n        }\n    }\n\n    return {max_negative, min_positive};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    __m128i max_neg = _mm_set1_epi32(0x80000000);  // Minimum possible int\n    __m128i min_pos = _mm_set1_epi32(0x7FFFFFFF);  // Maximum possible int\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        __m128i curr;\n        if (i + 4 <= lst.size()) {\n            curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        } else {\n            // Handle remaining elements\n            alignas(16) int temp[4] = {0};\n            for (size_t j = 0; j < lst.size() - i; j++) {\n                temp[j] = lst[i + j];\n            }\n            curr = _mm_load_si128((__m128i*)temp);\n        }\n\n        __m128i is_neg = _mm_cmplt_epi32(curr, zeros);\n        __m128i is_pos = _mm_cmpgt_epi32(curr, zeros);\n\n        // Update max negative\n        __m128i neg_vals = _mm_and_si128(curr, is_neg);\n        max_neg = _mm_max_epi32(max_neg, neg_vals);\n\n        // Update min positive\n        __m128i pos_vals = _mm_or_si128(\n            _mm_and_si128(curr, is_pos),\n            _mm_andnot_si128(is_pos, min_pos)\n        );\n        min_pos = _mm_min_epi32(min_pos, pos_vals);\n    }\n\n    alignas(16) int max_neg_arr[4];\n    alignas(16) int min_pos_arr[4];\n    _mm_store_si128((__m128i*)max_neg_arr, max_neg);\n    _mm_store_si128((__m128i*)min_pos_arr, min_pos);\n\n    int largest_neg = 0;\n    int smallest_pos = 0;\n\n    // Find max negative across lanes\n    for (int i = 0; i < 4; i++) {\n        if (max_neg_arr[i] < 0 && max_neg_arr[i] > largest_neg) {\n            largest_neg = max_neg_arr[i];\n        }\n    }\n\n    // Find min positive across lanes\n    smallest_pos = 0x7FFFFFFF;\n    for (int i = 0; i < 4; i++) {\n        if (min_pos_arr[i] > 0 && min_pos_arr[i] < smallest_pos) {\n            smallest_pos = min_pos_arr[i];\n        }\n    }\n\n    if (smallest_pos == 0x7FFFFFFF) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    __m128i max_neg = _mm_set1_epi32(0x80000000);  // Minimum possible int\n    __m128i min_pos = _mm_set1_epi32(0x7FFFFFFF);  // Maximum possible int\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        __m128i curr;\n        if (i + 4 <= lst.size()) {\n            curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        } else {\n            alignas(16) int temp[4] = {0};\n            for (size_t j = i; j < lst.size(); j++) {\n                temp[j-i] = lst[j];\n            }\n            curr = _mm_load_si128((__m128i*)temp);\n        }\n\n        __m128i is_neg = _mm_cmplt_epi32(curr, zeros);\n        __m128i is_pos = _mm_cmpgt_epi32(curr, zeros);\n        \n        __m128i neg_vals = _mm_and_si128(curr, is_neg);\n        __m128i pos_vals = _mm_and_si128(curr, is_pos);\n        \n        max_neg = _mm_max_epi32(max_neg, neg_vals);\n        min_pos = _mm_min_epi32(_mm_or_si128(min_pos, _mm_andnot_si128(is_pos, _mm_set1_epi32(0x7FFFFFFF))), pos_vals);\n    }\n\n    alignas(16) int max_neg_arr[4];\n    alignas(16) int min_pos_arr[4];\n    _mm_store_si128((__m128i*)max_neg_arr, max_neg);\n    _mm_store_si128((__m128i*)min_pos_arr, min_pos);\n\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    \n    for (int i = 0; i < 4; i++) {\n        if (max_neg_arr[i] < 0) {\n            largest_neg = std::max(largest_neg, max_neg_arr[i]);\n        }\n        if (min_pos_arr[i] > 0) {\n            if (smallest_pos == 0) smallest_pos = min_pos_arr[i];\n            else smallest_pos = std::min(smallest_pos, min_pos_arr[i]);\n        }\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128_SSE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    __m128i max_neg = _mm_set1_epi32(0x80000000);  // Minimum possible integer\n    __m128i min_pos = _mm_set1_epi32(0x7FFFFFFF);  // Maximum possible integer\n    __m128i zeros = _mm_setzero_si128();\n    \n    for (size_t i = 0; i < lst.size(); i += 4) {\n        __m128i curr;\n        if (i + 4 <= lst.size()) {\n            curr = _mm_loadu_si128((__m128i*)&lst[i]);\n        } else {\n            // Handle remaining elements\n            alignas(16) int temp[4] = {0, 0, 0, 0};\n            for (size_t j = 0; j < lst.size() - i; j++) {\n                temp[j] = lst[i + j];\n            }\n            curr = _mm_load_si128((__m128i*)temp);\n        }\n\n        __m128i is_neg = _mm_cmplt_epi32(curr, zeros);\n        __m128i is_pos = _mm_cmpgt_epi32(curr, zeros);\n\n        // Update max negative\n        __m128i neg_vals = _mm_and_si128(curr, is_neg);\n        max_neg = _mm_max_epi32(max_neg, neg_vals);\n\n        // Update min positive\n        __m128i pos_vals = _mm_or_si128(\n            _mm_and_si128(curr, is_pos),\n            _mm_andnot_si128(is_pos, min_pos)\n        );\n        min_pos = _mm_min_epi32(min_pos, pos_vals);\n    }\n\n    alignas(16) int max_neg_arr[4];\n    alignas(16) int min_pos_arr[4];\n    _mm_store_si128((__m128i*)max_neg_arr, max_neg);\n    _mm_store_si128((__m128i*)min_pos_arr, min_pos);\n\n    int largest_neg = 0;\n    int smallest_pos = 0;\n\n    // Find largest negative\n    for (int i = 0; i < 4; i++) {\n        if (max_neg_arr[i] < 0 && max_neg_arr[i] > largest_neg) {\n            largest_neg = max_neg_arr[i];\n        }\n    }\n\n    // Find smallest positive\n    smallest_pos = 0x7FFFFFFF;\n    for (int i = 0; i < 4; i++) {\n        if (min_pos_arr[i] > 0 && min_pos_arr[i] < smallest_pos) {\n            smallest_pos = min_pos_arr[i];\n        }\n    }\n\n    if (smallest_pos == 0x7FFFFFFF) {\n        smallest_pos = 0;\n    }\n\n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i result = _mm_set1_epi64x(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        __m128i factors = _mm_set1_epi64x(1);\n        \n        for (uint64_t j = 2; j <= i; j++) {\n            factorial *= j;\n        }\n        \n        for (uint64_t k = i; k <= n; k++) {\n            factors = _mm_mul_epu32(factors, _mm_set1_epi64x(factorial));\n        }\n        \n        result = _mm_mul_epu32(result, factors);\n    }\n    \n    uint64_t final[2];\n    _mm_store_si128((__m128i*)final, result);\n    \n    return final[0];\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0 || n == 1) return 1;\n    \n    __m128i result = _mm_set1_epi64x(1);\n    __m128i one = _mm_set1_epi64x(1);\n    \n    for (uint64_t i = n; i >= 1; i--) {\n        __m128i factorial = _mm_set1_epi64x(1);\n        __m128i counter = _mm_set1_epi64x(i);\n        \n        while (_mm_cvtsi128_si64(counter) > 1) {\n            factorial = _mm_mul_epu32(factorial, counter);\n            counter = _mm_sub_epi64(counter, one);\n        }\n        \n        result = _mm_mul_epu32(result, factorial);\n    }\n    \n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i result = _mm_set1_epi64x(1);\n    __m128i one = _mm_set1_epi64x(1);\n    \n    for (uint64_t i = n; i >= 1; i--) {\n        __m128i factorial = _mm_set1_epi64x(1);\n        __m128i counter = _mm_set1_epi64x(i);\n        \n        while (_mm_cvtsi128_si64(counter) > 1) {\n            factorial = _mm_mul_epu32(factorial, counter);\n            counter = _mm_sub_epi64(counter, one);\n        }\n        \n        result = _mm_mul_epu32(result, factorial);\n    }\n    \n    return _mm_cvtsi128_si64(result);\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i result = _mm_set1_epi64x(1);\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        __m128i factors = _mm_set1_epi64x(1);\n        \n        for (uint64_t j = 2; j <= i; j++) {\n            factorial *= j;\n        }\n        \n        factors = _mm_set1_epi64x(factorial);\n        result = _mm_mul_epu32(result, factors);\n    }\n    \n    uint64_t final_result;\n    _mm_storel_epi64((__m128i*)&final_result, result);\n    \n    return final_result;\n}\n```"}
{"task_id": "SimdBench_129_SSE", "completion": "```cpp\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    __m128i result = _mm_set1_epi64x(1);\n    __m128i one = _mm_set1_epi64x(1);\n    \n    for (uint64_t i = n; i >= 1; i--) {\n        uint64_t factorial = 1;\n        __m128i current = _mm_set1_epi64x(1);\n        \n        for (uint64_t j = i; j > 0; j--) {\n            current = _mm_mul_epu32(current, _mm_set1_epi64x(j));\n        }\n        \n        result = _mm_mul_epu32(result, current);\n    }\n    \n    uint64_t final[2];\n    _mm_storeu_si128((__m128i*)final, result);\n    \n    return final[0];\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    int size = lst.size();\n    int result = 0;\n    \n    // Pad vector size to multiple of 4\n    int padded_size = (size + 3) & ~3;\n    std::vector<int> padded(padded_size, 0);\n    std::copy(lst.begin(), lst.end(), padded.begin());\n\n    __m128i sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < padded_size; i += 4) {\n        // Load 4 integers\n        __m128i nums = _mm_loadu_si128((__m128i*)&padded[i]);\n        \n        // Create masks for multiples of 3 and 4\n        __m128i idx = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i mod3 = _mm_set1_epi32(3);\n        __m128i mod4 = _mm_set1_epi32(4);\n        __m128i is_mult3 = _mm_cmpeq_epi32(_mm_and_si128(idx, mod3), _mm_setzero_si128());\n        __m128i is_mult4 = _mm_cmpeq_epi32(_mm_and_si128(idx, mod4), _mm_setzero_si128());\n        \n        // Square numbers at indices divisible by 3\n        __m128i squared = _mm_mullo_epi32(nums, nums);\n        nums = _mm_or_si128(_mm_and_si128(is_mult3, squared), \n                           _mm_andnot_si128(is_mult3, nums));\n        \n        // Cube numbers at indices divisible by 4 but not by 3\n        __m128i cubed = _mm_mullo_epi32(squared, nums);\n        __m128i is_mult4_not3 = _mm_andnot_si128(is_mult3, is_mult4);\n        nums = _mm_or_si128(_mm_and_si128(is_mult4_not3, cubed),\n                           _mm_andnot_si128(is_mult4_not3, nums));\n        \n        sum = _mm_add_epi32(sum, nums);\n    }\n    \n    // Extract and sum the four 32-bit integers\n    int temp[4];\n    _mm_storeu_si128((__m128i*)temp, sum);\n    \n    for (int i = 0; i < 4; i++) {\n        if (i < size) result += temp[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n    \n    int size = lst.size();\n    int remainder = size % 4;\n    int aligned_size = size - remainder;\n    \n    __m128i sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)(lst.data() + i));\n        __m128i idx = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        __m128i mod3 = _mm_set1_epi32(3);\n        __m128i mod4 = _mm_set1_epi32(4);\n        \n        __m128i is_mult3 = _mm_cmpeq_epi32(_mm_rem_epi32(idx, mod3), _mm_setzero_si128());\n        __m128i is_mult4 = _mm_cmpeq_epi32(_mm_rem_epi32(idx, mod4), _mm_setzero_si128());\n        \n        __m128i square = _mm_mullo_epi32(nums, nums);\n        __m128i cube = _mm_mullo_epi32(square, nums);\n        \n        __m128i result = nums;\n        result = _mm_blendv_epi8(result, square, is_mult3);\n        result = _mm_blendv_epi8(result, cube, _mm_andnot_si128(is_mult3, is_mult4));\n        \n        sum = _mm_add_epi32(sum, result);\n    }\n    \n    int final_sum = _mm_extract_epi32(sum, 0) + \n                    _mm_extract_epi32(sum, 1) + \n                    _mm_extract_epi32(sum, 2) + \n                    _mm_extract_epi32(sum, 3);\n                    \n    for (int i = aligned_size; i < size; i++) {\n        if (i % 3 == 0) {\n            final_sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            final_sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            final_sum += lst[i];\n        }\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    int size = lst.size();\n    int result = 0;\n    \n    // Pad input to multiple of 4\n    int padded_size = (size + 3) & ~3;\n    std::vector<int> padded(padded_size, 0);\n    std::copy(lst.begin(), lst.end(), padded.begin());\n    \n    __m128i sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < padded_size; i += 4) {\n        // Load 4 integers\n        __m128i nums = _mm_loadu_si128((__m128i*)&padded[i]);\n        \n        // Create masks for multiples of 3 and 4\n        __m128i idx = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i mod3 = _mm_set1_epi32(3);\n        __m128i mod4 = _mm_set1_epi32(4);\n        __m128i is_mult3 = _mm_cmpeq_epi32(_mm_and_si128(idx, mod3), _mm_setzero_si128());\n        __m128i is_mult4 = _mm_cmpeq_epi32(_mm_and_si128(idx, mod4), _mm_setzero_si128());\n        \n        // Square numbers at multiples of 3\n        __m128i squared = _mm_mullo_epi32(nums, nums);\n        nums = _mm_or_si128(_mm_and_si128(is_mult3, squared), \n                           _mm_andnot_si128(is_mult3, nums));\n        \n        // Cube numbers at multiples of 4 (not multiples of 3)\n        __m128i cubed = _mm_mullo_epi32(squared, nums);\n        __m128i cube_mask = _mm_andnot_si128(is_mult3, is_mult4);\n        nums = _mm_or_si128(_mm_and_si128(cube_mask, cubed),\n                           _mm_andnot_si128(cube_mask, nums));\n                           \n        sum = _mm_add_epi32(sum, nums);\n    }\n    \n    // Horizontal sum\n    __m128i hi = _mm_srli_si128(sum, 8);\n    sum = _mm_add_epi32(sum, hi);\n    __m128i lo = _mm_srli_si128(sum, 4);\n    sum = _mm_add_epi32(sum, lo);\n    result = _mm_cvtsi128_si32(sum);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n    \n    int size = lst.size();\n    int result = 0;\n    \n    // Pad vector size to multiple of 4\n    int padded_size = (size + 3) & ~3;\n    std::vector<int> padded(padded_size, 0);\n    std::copy(lst.begin(), lst.end(), padded.begin());\n    \n    __m128i sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < padded_size; i += 4) {\n        // Load 4 integers\n        __m128i nums = _mm_loadu_si128((__m128i*)&padded[i]);\n        \n        // Create masks for multiples of 3 and 4\n        __m128i idx = _mm_set_epi32(i+3, i+2, i+1, i);\n        __m128i mod3 = _mm_set1_epi32(3);\n        __m128i mod4 = _mm_set1_epi32(4);\n        __m128i is_mult3 = _mm_cmpeq_epi32(_mm_and_si128(idx, mod3), _mm_setzero_si128());\n        __m128i is_mult4 = _mm_cmpeq_epi32(_mm_and_si128(idx, mod4), _mm_setzero_si128());\n        \n        // Square numbers at multiples of 3\n        __m128i squared = _mm_mullo_epi32(nums, nums);\n        nums = _mm_or_si128(_mm_and_si128(is_mult3, squared), \n                           _mm_andnot_si128(is_mult3, nums));\n        \n        // Cube numbers at multiples of 4 (not multiples of 3)\n        __m128i cubed = _mm_mullo_epi32(squared, nums);\n        __m128i cube_mask = _mm_andnot_si128(is_mult3, is_mult4);\n        nums = _mm_or_si128(_mm_and_si128(cube_mask, cubed),\n                           _mm_andnot_si128(cube_mask, nums));\n                           \n        sum = _mm_add_epi32(sum, nums);\n    }\n    \n    // Horizontal sum\n    __m128i hi = _mm_srli_si128(sum, 8);\n    sum = _mm_add_epi32(sum, hi);\n    __m128i lo = _mm_srli_si128(sum, 4);\n    sum = _mm_add_epi32(sum, lo);\n    result = _mm_cvtsi128_si32(sum);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SSE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int> & lst) {\n    if (lst.empty()) return 0;\n    \n    int size = lst.size();\n    int remainder = size % 4;\n    int simd_size = size - remainder;\n    \n    __m128i sum = _mm_setzero_si128();\n    \n    for (int i = 0; i < simd_size; i += 4) {\n        __m128i nums = _mm_loadu_si128((__m128i*)(lst.data() + i));\n        __m128i idx = _mm_set_epi32(i+3, i+2, i+1, i);\n        \n        __m128i mod3 = _mm_set1_epi32(3);\n        __m128i mod4 = _mm_set1_epi32(4);\n        \n        __m128i is_mult3 = _mm_cmpeq_epi32(_mm_rem_epi32(idx, mod3), _mm_setzero_si128());\n        __m128i is_mult4 = _mm_cmpeq_epi32(_mm_rem_epi32(idx, mod4), _mm_setzero_si128());\n        \n        __m128i squared = _mm_mullo_epi32(nums, nums);\n        __m128i cubed = _mm_mullo_epi32(squared, nums);\n        \n        __m128i result = nums;\n        result = _mm_blendv_epi8(result, squared, is_mult3);\n        result = _mm_blendv_epi8(result, cubed, _mm_andnot_si128(is_mult3, is_mult4));\n        \n        sum = _mm_add_epi32(sum, result);\n    }\n    \n    int final_sum = 0;\n    int* sum_arr = (int*)&sum;\n    for (int i = 0; i < 4; i++) {\n        final_sum += sum_arr[i];\n    }\n    \n    for (int i = simd_size; i < size; i++) {\n        if (i % 3 == 0) {\n            final_sum += lst[i] * lst[i];\n        }\n        else if (i % 4 == 0) {\n            final_sum += lst[i] * lst[i] * lst[i];\n        }\n        else {\n            final_sum += lst[i];\n        }\n    }\n    \n    return final_sum;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int aligned_size = size - (size % 4);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        __m128i nums_vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        __m128i ten = _mm_set1_epi32(10);\n        __m128i gt_mask = _mm_cmpgt_epi32(nums_vec, ten);\n        \n        // Get first digit by repeated division by 10\n        __m128i temp = nums_vec;\n        __m128i ten_vec = _mm_set1_epi32(10);\n        while(_mm_movemask_epi8(_mm_cmpgt_epi32(temp, ten_vec)) != 0) {\n            temp = _mm_div_epi32(temp, ten_vec);\n        }\n        __m128i first_digit = temp;\n        \n        // Get last digit using modulo\n        __m128i last_digit = _mm_rem_epi32(nums_vec, ten_vec);\n        \n        // Check if first and last digits are odd\n        __m128i two = _mm_set1_epi32(2);\n        __m128i first_odd = _mm_rem_epi32(first_digit, two);\n        __m128i last_odd = _mm_rem_epi32(last_digit, two);\n        \n        // Combine conditions\n        __m128i odd_mask = _mm_and_si128(first_odd, last_odd);\n        __m128i final_mask = _mm_and_si128(gt_mask, odd_mask);\n        \n        int mask = _mm_movemask_ps(_mm_castsi128_ps(final_mask));\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < size; i++) {\n        int num = nums[i];\n        if(num <= 10) continue;\n        \n        int first = num;\n        while(first >= 10) {\n            first /= 10;\n        }\n        int last = num % 10;\n        \n        if(first % 2 == 1 && last % 2 == 1) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int size = nums.size();\n    int aligned_size = size - (size % 4);\n    \n    __m128i ten = _mm_set1_epi32(10);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compare greater than 10\n        __m128i mask_gt = _mm_cmpgt_epi32(data, ten);\n        \n        // Get first digit\n        __m128i abs_data = _mm_abs_epi32(data);\n        __m128i first_digits = abs_data;\n        __m128i ten_div = _mm_set1_epi32(10);\n        \n        while(_mm_movemask_epi8(_mm_cmpgt_epi32(first_digits, ten_div)) != 0) {\n            first_digits = _mm_div_epi32(first_digits, ten_div);\n        }\n        \n        // Get last digit\n        __m128i last_digits = _mm_rem_epi32(abs_data, ten_div);\n        \n        // Check if first and last digits are odd\n        __m128i two = _mm_set1_epi32(2);\n        __m128i first_odd = _mm_rem_epi32(first_digits, two);\n        __m128i last_odd = _mm_rem_epi32(last_digits, two);\n        \n        __m128i both_odd = _mm_and_si128(first_odd, last_odd);\n        \n        // Combine all conditions\n        __m128i final_mask = _mm_and_si128(mask_gt, both_odd);\n        \n        int mask = _mm_movemask_ps(_mm_castsi128_ps(final_mask));\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < size; i++) {\n        if(nums[i] <= 10) continue;\n        \n        int num = abs(nums[i]);\n        int first = num;\n        while(first >= 10) {\n            first /= 10;\n        }\n        int last = num % 10;\n        \n        if((first % 2 == 1) && (last % 2 == 1)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int size = nums.size();\n    \n    if (size < 4) {\n        for (int num : nums) {\n            if (num > 10) {\n                int first = abs(num);\n                while (first >= 10) first /= 10;\n                int last = abs(num) % 10;\n                if ((first % 2 == 1) && (last % 2 == 1)) count++;\n            }\n        }\n        return count;\n    }\n\n    int aligned_size = size - (size % 4);\n    __m128i ten = _mm_set1_epi32(10);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums_vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        __m128i gt_mask = _mm_cmpgt_epi32(nums_vec, ten);\n        \n        int mask = _mm_movemask_ps((__m128)gt_mask);\n        \n        for (int j = 0; j < 4; j++) {\n            if (mask & (1 << j)) {\n                int num = abs(nums[i + j]);\n                int first = num;\n                while (first >= 10) first /= 10;\n                int last = num % 10;\n                if ((first % 2 == 1) && (last % 2 == 1)) count++;\n            }\n        }\n    }\n    \n    for (int i = aligned_size; i < size; i++) {\n        if (nums[i] > 10) {\n            int first = abs(nums[i]);\n            while (first >= 10) first /= 10;\n            int last = abs(nums[i]) % 10;\n            if ((first % 2 == 1) && (last % 2 == 1)) count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int size = nums.size();\n    int aligned_size = size - (size % 4);\n    \n    for (int i = 0; i < aligned_size; i += 4) {\n        __m128i nums_vec = _mm_loadu_si128((__m128i*)&nums[i]);\n        __m128i ten = _mm_set1_epi32(10);\n        __m128i gt_mask = _mm_cmpgt_epi32(nums_vec, ten);\n        \n        int mask = _mm_movemask_ps((__m128)gt_mask);\n        \n        for (int j = 0; j < 4; j++) {\n            if (mask & (1 << j)) {\n                int num = nums[i + j];\n                if (num < 0) num = -num;\n                \n                int lastDigit = num % 10;\n                while (num >= 10) {\n                    num /= 10;\n                }\n                int firstDigit = num;\n                \n                if ((firstDigit % 2 == 1) && (lastDigit % 2 == 1)) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    for (int i = aligned_size; i < size; i++) {\n        int num = nums[i];\n        if (num > 10) {\n            if (num < 0) num = -num;\n            \n            int lastDigit = num % 10;\n            while (num >= 10) {\n                num /= 10;\n            }\n            int firstDigit = num;\n            \n            if ((firstDigit % 2 == 1) && (lastDigit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SSE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int>& nums) {\n    int count = 0;\n    int size = nums.size();\n    int aligned_size = size - (size % 4);\n    \n    __m128i ten = _mm_set1_epi32(10);\n    \n    for(int i = 0; i < aligned_size; i += 4) {\n        __m128i data = _mm_loadu_si128((__m128i*)&nums[i]);\n        \n        // Compare greater than 10\n        __m128i mask1 = _mm_cmpgt_epi32(data, ten);\n        \n        // Get first digits\n        __m128i abs_nums = _mm_abs_epi32(data);\n        __m128i first_digits = abs_nums;\n        __m128i div = _mm_set1_epi32(10);\n        while(_mm_movemask_epi8(_mm_cmpgt_epi32(first_digits, _mm_set1_epi32(9)))) {\n            first_digits = _mm_div_epi32(first_digits, div);\n        }\n        \n        // Get last digits\n        __m128i last_digits = _mm_rem_epi32(abs_nums, _mm_set1_epi32(10));\n        \n        // Check if first and last digits are odd\n        __m128i odd_mask = _mm_set1_epi32(1);\n        __m128i first_odd = _mm_and_si128(first_digits, odd_mask);\n        __m128i last_odd = _mm_and_si128(last_digits, odd_mask);\n        __m128i both_odd = _mm_and_si128(first_odd, last_odd);\n        \n        // Combine conditions\n        __m128i final_mask = _mm_and_si128(mask1, both_odd);\n        \n        // Count matches\n        int mask = _mm_movemask_ps(_mm_castsi128_ps(final_mask));\n        count += _mm_popcnt_u32(mask);\n    }\n    \n    // Handle remaining elements\n    for(int i = aligned_size; i < size; i++) {\n        int num = abs(nums[i]);\n        if(nums[i] <= 10) continue;\n        \n        int first = num;\n        while(first > 9) {\n            first /= 10;\n        }\n        int last = num % 10;\n        \n        if((first & 1) && (last & 1)) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Generate array values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    \n    __m128i three = _mm_set1_epi32(3);\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            __m128i sum_ij = _mm_set1_epi32(a[i] + a[j]);\n            \n            uint64_t k = j+1;\n            uint64_t k_aligned = ((k + 3) & ~3);\n            \n            // Handle unaligned elements\n            for (; k < k_aligned && k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n            \n            // Process 4 elements at a time using SSE\n            for (; k + 3 < n; k += 4) {\n                __m128i ak = _mm_load_si128((__m128i*)&a[k]);\n                __m128i sum = _mm_add_epi32(sum_ij, ak);\n                __m128i remainder = _mm_rem_epi32(sum, three);\n                __m128i mask = _mm_cmpeq_epi32(remainder, _mm_setzero_si128());\n                int m = _mm_movemask_epi8(mask);\n                count += _mm_popcnt_u32(m) / 4;\n            }\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    _mm_free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Generate array values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    \n    __m128i three = _mm_set1_epi32(3);\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            uint64_t sum_ij = a[i] + a[j];\n            \n            // Process 4 k values at a time\n            uint64_t k;\n            for (k = j+1; k+3 < n; k += 4) {\n                __m128i ak = _mm_loadu_si128((__m128i*)&a[k]);\n                __m128i sum = _mm_add_epi32(_mm_set1_epi32(sum_ij), ak);\n                __m128i rem = _mm_rem_epi32(sum, three);\n                int mask = _mm_movemask_epi8(_mm_cmpeq_epi32(rem, _mm_setzero_si128()));\n                \n                // Count number of valid triples\n                count += _mm_popcnt_u32(mask) >> 2;\n            }\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                if ((sum_ij + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    _mm_free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Fill array with i*i - i + 1 values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    // Process 2 elements at a time for k\n    __m128i three = _mm_set1_epi64x(3);\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            __m128i sum_ij = _mm_set1_epi64x(a[i] + a[j]);\n            \n            for (uint64_t k = j+1; k+1 < n; k+=2) {\n                __m128i ak = _mm_set_epi64x(a[k+1], a[k]);\n                __m128i sum = _mm_add_epi64(sum_ij, ak);\n                \n                // Check divisibility by 3\n                __m128i div = _mm_div_epi64(sum, three);\n                __m128i mul = _mm_mul_epi32(div, three);\n                __m128i cmp = _mm_cmpeq_epi64(sum, mul);\n                \n                uint64_t mask = _mm_movemask_pd((__m128d)cmp);\n                \n                if (mask & 1) count++;\n                if ((mask & 2) && (k+1 < n)) count++;\n            }\n            \n            // Handle remaining k if n is odd\n            if ((n-1) % 2 == 0) {\n                uint64_t k = n-1;\n                if (((a[i] + a[j] + a[k]) % 3) == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    _mm_free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Generate array values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n    \n    __m128i three = _mm_set1_epi32(3);\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            __m128i sum_ij = _mm_set1_epi32(a[i] + a[j]);\n            \n            uint64_t k = j+1;\n            uint64_t rem = (n-k) % 4;\n            \n            // Process 4 elements at a time\n            for (; k+3 < n; k += 4) {\n                __m128i ak = _mm_loadu_si128((__m128i*)&a[k]);\n                __m128i sum = _mm_add_epi32(sum_ij, ak);\n                __m128i mod = _mm_rem_epi32(sum, three);\n                int mask = _mm_movemask_epi8(_mm_cmpeq_epi32(mod, _mm_setzero_si128()));\n                count += _mm_popcnt_u32(mask) / 4;\n            }\n            \n            // Handle remaining elements\n            for (uint64_t m = 0; m < rem; m++) {\n                if ((a[i] + a[j] + a[k+m]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    _mm_free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SSE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)_mm_malloc(n * sizeof(uint64_t), 16);\n    \n    // Generate array values\n    for (uint64_t i = 0; i < n; i++) {\n        a[i] = i * i - i + 1;\n    }\n\n    __m128i three = _mm_set1_epi32(3);\n    __m128i zero = _mm_setzero_si128();\n    \n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            __m128i sum_ij = _mm_set1_epi32(a[i] + a[j]);\n            \n            uint64_t k = j+1;\n            uint64_t remaining = n - k;\n            uint64_t simd_iters = remaining/4;\n            \n            for (uint64_t l = 0; l < simd_iters; l++, k += 4) {\n                __m128i ak = _mm_loadu_si128((__m128i*)&a[k]);\n                __m128i sum = _mm_add_epi32(sum_ij, ak);\n                __m128i rem = _mm_rem_epi32(sum, three);\n                __m128i mask = _mm_cmpeq_epi32(rem, zero);\n                int m = _mm_movemask_epi8(mask);\n                count += _mm_popcnt_u32(m) / 4;\n            }\n            \n            // Handle remaining elements\n            for (; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    _mm_free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i is_prime = _mm_set1_epi32(1);\n    \n    int limit = (int)sqrt(n);\n    \n    while (_mm_extract_epi32(divisors, 0) <= limit) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        if (_mm_movemask_epi8(mask) & 0xFFFF) {\n            if (n > 3) {\n                return y;\n            }\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(7, 5, 3, 2);\n    __m128i result = _mm_set1_epi32(0);\n    \n    // Check if n is divisible by 2,3,5,7\n    __m128i remainders = _mm_rem_epi32(num, divisors);\n    __m128i zeros = _mm_setzero_si128();\n    __m128i mask = _mm_cmpeq_epi32(remainders, zeros);\n    \n    // If any remainder is 0 and divisor < n, then n is not prime\n    int m = _mm_movemask_ps((__m128)mask);\n    \n    if (n % 2 == 0 || n % 3 == 0 || n % 5 == 0 || n % 7 == 0) {\n        return y;\n    }\n    \n    // Check remaining numbers up to sqrt(n)\n    for (int i = 11; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return y;\n        }\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i is_prime = _mm_set1_epi32(1);\n    \n    int limit = (int)sqrt(n);\n    \n    while (_mm_extract_epi32(divisors, 0) <= limit) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        if (_mm_movemask_epi8(mask)) {\n            if (n > 2) return y;\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n <= 3) return x;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    \n    int limit = n/2;\n    \n    while (_mm_cvtsi128_si32(divisors) <= limit) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        if (_mm_movemask_epi8(mask)) {\n            return y;\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SSE", "completion": "```cpp\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    \n    __m128i num = _mm_set1_epi32(n);\n    __m128i divisors = _mm_set_epi32(4, 3, 2, 1);\n    __m128i increment = _mm_set1_epi32(4);\n    __m128i is_prime = _mm_set1_epi32(1);\n    \n    int limit = (int)sqrt(n);\n    \n    while (_mm_cvtsi128_si32(divisors) <= limit) {\n        __m128i remainder = _mm_rem_epi32(num, divisors);\n        __m128i zero = _mm_setzero_si128();\n        __m128i mask = _mm_cmpeq_epi32(remainder, zero);\n        \n        if (_mm_movemask_epi8(mask)) {\n            if (n % _mm_cvtsi128_si32(divisors) == 0) {\n                return y;\n            }\n        }\n        \n        divisors = _mm_add_epi32(divisors, increment);\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) return 0;\n    \n    size_t size = lst.size();\n    size_t aligned_size = size - (size % 4);\n    uint64_t sum = 0;\n\n    __m128 zeros = _mm_setzero_ps();\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 twos = _mm_set1_ps(2.0f);\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        // Load 4 floats\n        __m128 nums = _mm_loadu_ps(&lst[i]);\n        \n        // Check if numbers are negative\n        __m128 neg_mask = _mm_cmpge_ps(nums, zeros);\n        \n        // Check if numbers are integers\n        __m128 rounded = _mm_round_ps(nums, _MM_FROUND_TO_NEAREST_INT);\n        __m128 int_mask = _mm_cmpeq_ps(nums, rounded);\n        \n        // Check if numbers are odd\n        __m128 divided = _mm_div_ps(rounded, twos);\n        __m128 mult = _mm_mul_ps(divided, twos);\n        __m128 odd_mask = _mm_cmpneq_ps(rounded, mult);\n        \n        // Combine masks\n        __m128 final_mask = _mm_and_ps(_mm_and_ps(neg_mask, int_mask), odd_mask);\n        \n        // Zero out invalid numbers\n        nums = _mm_and_ps(nums, final_mask);\n        \n        // Square the numbers\n        __m128 squares = _mm_mul_ps(nums, nums);\n        \n        // Store squares in array to sum\n        float temp[4];\n        _mm_storeu_ps(temp, squares);\n        \n        // Add up squares\n        for(int j = 0; j < 4; j++) {\n            sum += (uint64_t)temp[j];\n        }\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        float num = lst[i];\n        if (num >= 0 && num == (int)num && (int)num % 2 == 1) {\n            sum += (uint64_t)(num * num);\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t size = lst.size();\n    size_t aligned_size = size - (size % 4);\n    \n    __m128 sum = _mm_setzero_ps();\n    __m128 zeros = _mm_setzero_ps();\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 twos = _mm_set1_ps(2.0f);\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        // Load 4 floats\n        __m128 nums = _mm_loadu_ps(&lst[i]);\n        \n        // Check if numbers are negative\n        __m128 neg_mask = _mm_cmplt_ps(nums, zeros);\n        \n        // Check if numbers are integers\n        __m128 rounded = _mm_round_ps(nums, _MM_FROUND_TO_NEAREST_INT);\n        __m128 int_mask = _mm_cmpeq_ps(nums, rounded);\n        \n        // Check if numbers are odd\n        __m128 divided = _mm_div_ps(rounded, twos);\n        __m128 mult = _mm_mul_ps(divided, twos);\n        __m128 odd_mask = _mm_cmpneq_ps(rounded, mult);\n        \n        // Combine masks\n        __m128 valid_mask = _mm_andnot_ps(neg_mask, int_mask);\n        valid_mask = _mm_and_ps(valid_mask, odd_mask);\n        \n        // Zero out invalid numbers\n        nums = _mm_and_ps(nums, valid_mask);\n        \n        // Square and add\n        nums = _mm_mul_ps(nums, nums);\n        sum = _mm_add_ps(sum, nums);\n    }\n    \n    // Horizontal sum\n    float temp[4];\n    _mm_storeu_ps(temp, sum);\n    uint64_t result = 0;\n    \n    for (int i = 0; i < 4; i++) {\n        result += (uint64_t)temp[i];\n    }\n    \n    // Process remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        float num = lst[i];\n        if (num >= 0 && num == (int)num && (int)num % 2 == 1) {\n            result += (uint64_t)(num * num);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t size = lst.size();\n    size_t aligned_size = size - (size % 4);\n    \n    __m128 sum = _mm_setzero_ps();\n    __m128 zeros = _mm_setzero_ps();\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 twos = _mm_set1_ps(2.0f);\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        // Load 4 floats\n        __m128 nums = _mm_loadu_ps(&lst[i]);\n        \n        // Check if numbers are negative\n        __m128 pos_mask = _mm_cmpge_ps(nums, zeros);\n        \n        // Check if numbers are integers\n        __m128 rounded = _mm_round_ps(nums, _MM_FROUND_TO_NEAREST_INT);\n        __m128 int_mask = _mm_cmpeq_ps(nums, rounded);\n        \n        // Check if numbers are odd\n        __m128 divided = _mm_div_ps(rounded, twos);\n        __m128 mult = _mm_mul_ps(divided, twos);\n        __m128 odd_mask = _mm_cmpneq_ps(rounded, mult);\n        \n        // Combine masks\n        __m128 final_mask = _mm_and_ps(_mm_and_ps(pos_mask, int_mask), odd_mask);\n        \n        // Zero out invalid numbers\n        nums = _mm_and_ps(nums, final_mask);\n        \n        // Square the numbers\n        nums = _mm_mul_ps(nums, nums);\n        \n        // Add to running sum\n        sum = _mm_add_ps(sum, nums);\n    }\n    \n    // Horizontal sum\n    float temp[4];\n    _mm_storeu_ps(temp, sum);\n    uint64_t result = 0;\n    \n    for (int i = 0; i < 4; i++) {\n        result += (uint64_t)temp[i];\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        float num = lst[i];\n        if (num >= 0 && num == (int)num && (int)num % 2 == 1) {\n            result += (uint64_t)(num * num);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t size = lst.size();\n    size_t simd_size = size - (size % 4);\n    \n    __m128 sum = _mm_setzero_ps();\n    __m128 zeros = _mm_setzero_ps();\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 twos = _mm_set1_ps(2.0f);\n    \n    for (size_t i = 0; i < simd_size; i += 4) {\n        // Load 4 floats\n        __m128 nums = _mm_loadu_ps(&lst[i]);\n        \n        // Check if numbers are negative\n        __m128 pos_mask = _mm_cmpge_ps(nums, zeros);\n        \n        // Check if numbers are integers\n        __m128 rounded = _mm_round_ps(nums, _MM_FROUND_TO_NEAREST_INT);\n        __m128 int_mask = _mm_cmpeq_ps(nums, rounded);\n        \n        // Check if numbers are odd\n        __m128 divided = _mm_div_ps(nums, twos);\n        __m128 rounded_div = _mm_round_ps(divided, _MM_FROUND_TO_NEAREST_INT);\n        __m128 mult = _mm_mul_ps(rounded_div, twos);\n        __m128 odd_mask = _mm_cmpneq_ps(nums, mult);\n        \n        // Combine masks\n        __m128 final_mask = _mm_and_ps(_mm_and_ps(pos_mask, int_mask), odd_mask);\n        \n        // Zero out invalid numbers\n        __m128 valid_nums = _mm_and_ps(nums, final_mask);\n        \n        // Square the numbers\n        __m128 squares = _mm_mul_ps(valid_nums, valid_nums);\n        \n        // Add to running sum\n        sum = _mm_add_ps(sum, squares);\n    }\n    \n    // Horizontal sum\n    float result[4];\n    _mm_storeu_ps(result, sum);\n    uint64_t total = 0;\n    \n    for (int i = 0; i < 4; i++) {\n        total += (uint64_t)result[i];\n    }\n    \n    // Handle remaining elements\n    for (size_t i = simd_size; i < size; i++) {\n        float num = lst[i];\n        if (num >= 0 && num == (int)num && (int)num % 2 == 1) {\n            total += (uint64_t)(num * num);\n        }\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_134_SSE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    size_t size = lst.size();\n    size_t aligned_size = size - (size % 4);\n    \n    __m128 sum = _mm_setzero_ps();\n    __m128 zeros = _mm_setzero_ps();\n    __m128 ones = _mm_set1_ps(1.0f);\n    __m128 twos = _mm_set1_ps(2.0f);\n    \n    for (size_t i = 0; i < aligned_size; i += 4) {\n        // Load 4 floats\n        __m128 nums = _mm_loadu_ps(&lst[i]);\n        \n        // Check if numbers are negative\n        __m128 neg_mask = _mm_cmplt_ps(nums, zeros);\n        \n        // Check if numbers are integers\n        __m128 rounded = _mm_round_ps(nums, _MM_FROUND_TO_NEAREST_INT);\n        __m128 int_mask = _mm_cmpeq_ps(nums, rounded);\n        \n        // Check if numbers are odd\n        __m128 divided = _mm_div_ps(nums, twos);\n        __m128 rounded_div = _mm_round_ps(divided, _MM_FROUND_TO_NEAREST_INT);\n        __m128 mult = _mm_mul_ps(rounded_div, twos);\n        __m128 odd_mask = _mm_cmpneq_ps(nums, mult);\n        \n        // Combine masks\n        __m128 valid_mask = _mm_andnot_ps(neg_mask, _mm_and_ps(int_mask, odd_mask));\n        \n        // Zero out invalid numbers\n        nums = _mm_and_ps(nums, valid_mask);\n        \n        // Square the numbers\n        nums = _mm_mul_ps(nums, nums);\n        \n        // Add to running sum\n        sum = _mm_add_ps(sum, nums);\n    }\n    \n    // Horizontal sum\n    float temp[4];\n    _mm_storeu_ps(temp, sum);\n    uint64_t result = 0;\n    \n    for (int i = 0; i < 4; i++) {\n        result += (uint64_t)temp[i];\n    }\n    \n    // Handle remaining elements\n    for (size_t i = aligned_size; i < size; i++) {\n        float num = lst[i];\n        if (num >= 0 && num == (int)num && (int)num % 2 == 1) {\n            result += (uint64_t)(num * num);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    \n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i neg_diff = _mm_sub_epi32(_mm_setzero_si128(), diff);\n        __m128i abs_diff = _mm_max_epi32(diff, neg_diff);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    \n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i neg_diff = _mm_sub_epi32(_mm_setzero_si128(), diff);\n        __m128i abs_diff = _mm_max_epi32(diff, neg_diff);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    \n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i neg_diff = _mm_sub_epi32(_mm_setzero_si128(), diff);\n        __m128i abs_diff = _mm_max_epi32(diff, neg_diff);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    \n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i neg_diff = _mm_sub_epi32(_mm_setzero_si128(), diff);\n        __m128i abs_diff = _mm_max_epi32(diff, neg_diff);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SSE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    int i = 0;\n    \n    for (; i + 4 <= game.size(); i += 4) {\n        __m128i game_vec = _mm_loadu_si128((__m128i*)&game[i]);\n        __m128i guess_vec = _mm_loadu_si128((__m128i*)&guess[i]);\n        \n        __m128i diff = _mm_sub_epi32(game_vec, guess_vec);\n        __m128i neg_diff = _mm_sub_epi32(_mm_setzero_si128(), diff);\n        __m128i abs_diff = _mm_max_epi32(diff, neg_diff);\n        \n        _mm_storeu_si128((__m128i*)&result[i], abs_diff);\n    }\n    \n    // Handle remaining elements\n    for (; i < game.size(); i++) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n    \n    return result;\n}\n```"}

{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svbool_t pred = svand_z(pg, svld1_b64(pg, mask + i));\n        svst1_s64(pred, dst + i, svld1_s64(pred, src + i));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svbool_t pred = svand_z(pg, svld1_b64(pg, mask + i));\n        svst1_s64(pred, dst + i, svld1_s64(pred, src + i));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svbool_t pred = svand_z(pg, svld1_b8(pg, mask + i));\n        svst1_s64(pred, dst + i, svld1_s64(pred, src + i));\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    while (svptest_first(pg, pg)) {\n        svbool_t pred = svld1_b64(pg, mask);\n        svint64_t vec_src = svld1_s64(pg, src);\n        svst1_s64(pred, dst, vec_src);\n        \n        size_t vl = svcntd();\n        src += vl;\n        dst += vl; \n        mask += vl;\n        pg = svwhilelt_b64(vl, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svbool_t pred = svand_z(pg, svld1_b64(pg, (svbool_t*)&mask[i]));\n        svint64_t vec = svld1_s64(pg, &src[i]);\n        svst1_s64(pred, &dst[i], vec);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    do {\n        svint32_t vec_src = svld1_s32(pg, src);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        svint32_t vec_tmp1 = svmul_n_s32_x(pg, vec_src, scale);\n        vec_tmp1 = svasr_n_s32_x(pg, vec_tmp1, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        svint32_t vec_tmp2 = svmul_n_s32_x(pg, vec_src, scale);\n        vec_tmp2 = svasl_n_s32_x(pg, vec_tmp2, 3);\n        \n        // Calculate element * scale\n        svint32_t vec_scaled = svmul_n_s32_x(pg, vec_src, scale);\n        \n        // Calculate tmp1 * tmp2\n        svint32_t vec_prod = svmul_s32_x(pg, vec_tmp1, vec_tmp2);\n        \n        // Add element * scale + tmp1 * tmp2\n        svint32_t vec_sum = svadd_s32_x(pg, vec_scaled, vec_prod);\n        \n        // Divide by 7\n        svint32_t vec_result = svdiv_n_s32_x(pg, vec_sum, 7);\n        \n        // Store result\n        svst1_s32(pg, dst, vec_result);\n        \n        src += svcntw();\n        dst += svcntw();\n        length -= svcntw();\n        pg = svwhilelt_b32(0, length);\n        \n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    do {\n        svint32_t vec_src = svld1_s32(pg, src);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        svint32_t vec_tmp1 = svmul_n_s32_x(pg, vec_src, scale);\n        vec_tmp1 = svasr_n_s32_x(pg, vec_tmp1, 3);\n        \n        // Calculate tmp2 = (element * scale) << 3\n        svint32_t vec_tmp2 = svmul_n_s32_x(pg, vec_src, scale);\n        vec_tmp2 = svasl_n_s32_x(pg, vec_tmp2, 3);\n        \n        // Calculate element * scale\n        svint32_t vec_scaled = svmul_n_s32_x(pg, vec_src, scale);\n        \n        // Calculate tmp1 * tmp2\n        svint32_t vec_prod = svmul_s32_x(pg, vec_tmp1, vec_tmp2);\n        \n        // Add vec_scaled + (tmp1 * tmp2)\n        svint32_t vec_sum = svadd_s32_x(pg, vec_scaled, vec_prod);\n        \n        // Divide by 7\n        svint32_t vec_result = svdiv_n_s32_x(pg, vec_sum, 7);\n        \n        // Store result\n        svst1_s32(pg, dst, vec_result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n        \n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    do {\n        svint32_t vec_src = svld1_s32(pg, src);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        svint32_t vec_tmp1 = svasr_n_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), 3);\n        \n        // Calculate tmp2 = (element * scale) << 3  \n        svint32_t vec_tmp2 = svlsl_n_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), 3);\n        \n        // Calculate element * scale\n        svint32_t vec_scaled = svmul_n_s32_x(pg, vec_src, scale);\n        \n        // Calculate tmp1 * tmp2\n        svint32_t vec_prod = svmul_s32_x(pg, vec_tmp1, vec_tmp2);\n        \n        // Add element * scale\n        svint32_t vec_sum = svadd_s32_x(pg, vec_scaled, vec_prod);\n        \n        // Divide by 7\n        svint32_t vec_result = svdiv_n_s32_x(pg, vec_sum, 7);\n        \n        svst1_s32(pg, dst, vec_result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n        \n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    do {\n        svint32_t vec_src = svld1_s32(pg, src);\n        \n        // Calculate tmp1 = (element * scale) >> 3\n        svint32_t vec_tmp1 = svasr_n_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), 3);\n        \n        // Calculate tmp2 = (element * scale) << 3  \n        svint32_t vec_tmp2 = svasl_n_s32_x(pg, svmul_n_s32_x(pg, vec_src, scale), 3);\n        \n        // Calculate element * scale\n        svint32_t vec_scaled = svmul_n_s32_x(pg, vec_src, scale);\n        \n        // Calculate tmp1 * tmp2\n        svint32_t vec_prod = svmul_s32_x(pg, vec_tmp1, vec_tmp2);\n        \n        // Add element * scale\n        svint32_t vec_sum = svadd_s32_x(pg, vec_scaled, vec_prod);\n        \n        // Divide by 7\n        svint32_t vec_result = svdiv_n_s32_x(pg, vec_sum, 7);\n        \n        svst1_s32(pg, dst, vec_result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n        \n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    do {\n        svint32_t vec_src = svld1_s32(pg, src);\n        \n        // element * scale\n        svint32_t scaled = svmul_n_s32_x(pg, vec_src, scale);\n        \n        // tmp1 = (element * scale) >> 3\n        svint32_t tmp1 = svasr_n_s32_x(pg, scaled, 3);\n        \n        // tmp2 = (element * scale) << 3  \n        svint32_t tmp2 = svasl_n_s32_x(pg, scaled, 3);\n        \n        // tmp1 * tmp2\n        svint32_t prod = svmul_s32_x(pg, tmp1, tmp2);\n        \n        // element * scale + tmp1 * tmp2\n        svint32_t sum = svadd_s32_x(pg, scaled, prod);\n        \n        // final division by 7\n        svint32_t result = svdiv_n_s32_x(pg, sum, 7);\n        \n        svst1_s32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n        \n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    svuint64_t indices = svindex_u64(0, cols);\n    svuint64_t stride_vec = svdup_u64(stride);\n    svuint64_t gather_indices = svadd_u64_z(pg, svmul_u64_z(pg, indices, svdup_u64(cols)), stride_vec);\n    \n    svfloat64_t gathered = svld1_gather_u64index_f64(pg, src, gather_indices);\n    svst1_f64(pg, dst, gathered);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    \n    svuint64_t indices = svindex_u64(0, cols);\n    svuint64_t stride_vec = svdup_u64(stride);\n    indices = svadd_u64_z(pg, indices, stride_vec);\n    \n    svfloat64_t data = svld1_gather_u64index_f64(pg, src, indices);\n    svst1_f64(pg, dst, data);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    svuint64_t indices = svindex_u64(0, cols);\n    svuint64_t stride_vec = svdup_u64(stride);\n    svuint64_t gather_indices = svadd_u64_z(pg, svmul_u64_z(pg, indices, svdup_u64(cols)), stride_vec);\n    \n    svfloat64_t gathered = svld1_gather_u64index_f64(pg, src, gather_indices);\n    svst1_f64(pg, dst, gathered);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    \n    svuint64_t indices = svindex_u64(0, cols);\n    svuint64_t stride_vec = svdup_u64(stride);\n    svuint64_t gather_indices = svadd_u64_z(pg, svmul_u64_z(pg, indices, svdup_u64(cols)), stride_vec);\n    \n    svfloat64_t gathered = svld1_gather_u64index_f64(pg, src, gather_indices);\n    svst1_f64(pg, dst, gathered);\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    svbool_t pg = svwhilelt_b64(0, rows);\n    \n    svuint64_t indices = svindex_u64(0, cols);\n    svuint64_t stride_vec = svdup_u64(stride);\n    svuint64_t offset = svadd_u64_z(pg, indices, stride_vec);\n    \n    svfloat64_t data = svld1_gather_u64offset_f64(pg, src, offset);\n    svst1_f64(pg, dst, data);\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        // Gather operation\n        svfloat32_t gather = svld1_gather_s32index_f32(pg, src, svld1_s32(pg, indices));\n        svst1_f32(pg, dst, gather);\n        \n        // Scatter operation\n        svfloat32_t values = svld1_f32(pg, src);\n        svst1_scatter_s32index_f32(pg, dst, svld1_s32(pg, indices), values);\n        \n        src += svcntw();\n        indices += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        // Gather operation\n        svfloat32_t gather = svld1_gather_s32index_f32(pg, src, svld1_s32(pg, indices));\n        svst1_f32(pg, dst, gather);\n        \n        // Scatter operation\n        svfloat32_t data = svld1_f32(pg, src);\n        svst1_scatter_s32index_f32(pg, dst, svld1_s32(pg, indices), data);\n        \n        src += svcntw();\n        indices += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    size_t offset = 0;\n\n    while (svptest_first(svptrue_b32(), pg)) {\n        // Gather operation\n        svfloat32_t gather = svld1_gather_s32index_f32(pg, src, svld1_s32(pg, indices + offset));\n        svst1_f32(pg, dst + offset, gather);\n\n        // Scatter operation\n        svfloat32_t values = svld1_f32(pg, src + offset);\n        svst1_scatter_s32index_f32(pg, dst, svld1_s32(pg, indices + offset), values);\n\n        offset += svcntw();\n        pg = svwhilelt_b32(offset, length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        // Gather operation\n        svfloat32_t gather = svld1_gather_s32index_f32(pg, src, svld1_s32(pg, indices));\n        svst1_f32(pg, dst, gather);\n        \n        // Scatter operation\n        svfloat32_t data = svld1_f32(pg, src);\n        svst1_scatter_s32index_f32(pg, dst, svld1_s32(pg, indices), data);\n        \n        src += svcntw();\n        indices += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        // Gather operation\n        svfloat32_t gather = svld1_gather_s32index_f32(pg, src, svld1_s32(pg, indices));\n        svst1_f32(pg, dst, gather);\n        \n        // Scatter operation \n        svfloat32_t values = svld1_f32(pg, src);\n        svst1_scatter_s32index_f32(pg, dst, svld1_s32(pg, indices), values);\n        \n        src += svcntw();\n        indices += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n    \n    while (left < right) {\n        uint64_t remaining = right - left + 1;\n        svbool_t pg = svwhilelt_b16(0, remaining/2);\n        \n        svint16_t v_left = svld1_s16(pg, &arr[left]);\n        svint16_t v_right = svld1_s16(pg, &arr[right - svcntw() + 1]);\n        \n        v_right = svrev_s16(v_right);\n        \n        svst1_s16(pg, &arr[left], v_right);\n        svst1_s16(pg, &arr[right - svcntw() + 1], v_left);\n        \n        uint64_t vl = svcntw();\n        left += vl;\n        right -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n    \n    while (left < right) {\n        svbool_t pg = svwhilelt_b16(left, right + 1);\n        svbool_t pg_rev = svwhilelt_b16(left, right - left + 1);\n        \n        svint16_t v_left = svld1_s16(pg, &arr[left]);\n        svint16_t v_right = svld1_s16(pg_rev, &arr[right - svcntw() + 1]);\n        \n        v_right = svrev_s16(v_right);\n        \n        svst1_s16(pg, &arr[left], v_right);\n        svst1_s16(pg_rev, &arr[right - svcntw() + 1], v_left);\n        \n        uint64_t vl = svcntw();\n        left += vl;\n        right -= vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    while (i < j) {\n        uint64_t remaining = j - i + 1;\n        svbool_t pg = svwhilelt_b16(0, remaining/2);\n        \n        svint16_t v1 = svld1_s16(pg, &arr[i]);\n        svint16_t v2 = svld1_s16(pg, &arr[j - svcntw() + 1]);\n        \n        v2 = svrev_s16(v2);\n        \n        svst1_s16(pg, &arr[i], v2);\n        svst1_s16(pg, &arr[j - svcntw() + 1], v1);\n        \n        i += svcntw();\n        j -= svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    svbool_t pg;\n    svint16_t v1, v2, temp;\n    uint64_t vl = svcntw();\n    \n    while (i < j) {\n        uint64_t elements = (j - i + 1) / 2;\n        if (elements < vl) {\n            pg = svwhilelt_b16(0, elements);\n        } else {\n            pg = svptrue_b16();\n        }\n        \n        v1 = svld1_s16(pg, &arr[i]);\n        v2 = svld1_s16(pg, &arr[j - svcntw() + 1]);\n        \n        v2 = svrev_s16(v2);\n        \n        temp = v1;\n        v1 = v2;\n        v2 = temp;\n        \n        v2 = svrev_s16(v2);\n        \n        svst1_s16(pg, &arr[i], v1);\n        svst1_s16(pg, &arr[j - svcntw() + 1], v2);\n        \n        i += svcntw();\n        j -= svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n    \n    svbool_t pg;\n    svint16_t v1, v2, temp;\n    \n    while (i < j) {\n        uint64_t remaining = j - i + 1;\n        uint64_t vl = svcntw();\n        \n        if (remaining < 2 * vl) {\n            // Handle remaining elements one at a time\n            int16_t temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        } else {\n            // Create predicate for vector length\n            pg = svwhilelt_b16(0, vl);\n            \n            // Load vectors from both ends\n            v1 = svld1_s16(pg, &arr[i]);\n            v2 = svld1_s16(pg, &arr[j - vl + 1]);\n            \n            // Reverse elements within vectors\n            v1 = svrev_s16(v1);\n            v2 = svrev_s16(v2);\n            \n            // Store reversed vectors to opposite ends\n            svst1_s16(pg, &arr[j - vl + 1], v1);\n            svst1_s16(pg, &arr[i], v2);\n            \n            i += vl;\n            j -= vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    svbool_t pg = svwhilelt_b8(0, slice_size);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, tensor + offset);\n        svst1_u8(pg, slice, vec);\n        \n        offset += svcntb();\n        slice += svcntb();\n        pg = svwhilelt_b8(offset, slice_size);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    svbool_t pg = svwhilelt_b8(0, slice_size);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, tensor + offset);\n        svst1_u8(pg, slice, vec);\n        \n        offset += svcntb();\n        slice += svcntb();\n        pg = svwhilelt_b8(offset, slice_size);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    svbool_t pg = svwhilelt_b8(0, slice_size);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, tensor + offset);\n        svst1_u8(pg, slice, vec);\n        \n        offset += svcntb();\n        slice += svcntb();\n        pg = svwhilelt_b8(offset, slice_size);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    svbool_t pg = svwhilelt_b8(0, slice_size);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        size_t vl = svcntb();\n        svuint8_t vec = svld1_u8(pg, tensor + offset);\n        svst1_u8(pg, slice, vec);\n        \n        offset += vl;\n        slice += vl;\n        pg = svwhilelt_b8(offset, slice_size);\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    \n    svbool_t pg = svwhilelt_b8(0, slice_size);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t vec = svld1_u8(pg, tensor + offset);\n        svst1_u8(pg, slice, vec);\n        \n        offset += svcntb();\n        slice += svcntb();\n        pg = svwhilelt_b8(offset, slice_size);\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi++) {\n                size_t vl = svcntw();\n                size_t k;\n                \n                for (k = j; k + vl <= max_j; k += vl) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t vec = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    // Store elements one by one in transposed positions\n                    for (size_t idx = 0; idx < vl && (k + idx) < max_j; idx++) {\n                        int16_t val = svextw_s16_x(pg, vec, idx);\n                        dst[(k + idx) * rows + bi] = val;\n                    }\n                }\n                \n                // Handle remaining elements\n                for (; k < max_j; k++) {\n                    dst[k * rows + bi] = src[bi * cols + k];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi++) {\n                size_t vl = svcntw();\n                size_t k;\n                \n                for (k = j; k + vl <= max_j; k += vl) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t vec = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    for (size_t idx = 0; idx < vl && (k + idx) < max_j; idx++) {\n                        dst[(k + idx) * rows + bi] = svextw_s16_x(pg, vec, idx);\n                    }\n                }\n                \n                if (k < max_j) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t vec = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    for (size_t idx = 0; idx < (max_j - k); idx++) {\n                        dst[(k + idx) * rows + bi] = svextw_s16_x(pg, vec, idx);\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi++) {\n                size_t vl = svcntw();\n                size_t k;\n                \n                for (k = j; k + vl <= max_j; k += vl) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t v = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    // Store elements one by one in transposed positions\n                    for (size_t idx = 0; idx < vl && (k + idx) < max_j; idx++) {\n                        dst[(k + idx) * rows + bi] = svextw_s16_x(pg, v, idx);\n                    }\n                }\n                \n                // Handle remaining elements\n                if (k < max_j) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t v = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    for (size_t idx = 0; idx < (max_j - k); idx++) {\n                        dst[(k + idx) * rows + bi] = svextw_s16_x(pg, v, idx);\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi++) {\n                size_t src_offset = bi * cols + j;\n                size_t dst_offset = j * rows + bi;\n                \n                svbool_t pg = svwhilelt_b16(0, max_j - j);\n                \n                svint16_t v_src = svld1_s16(pg, src + src_offset);\n                \n                for (size_t bj = j; bj < max_j; bj++) {\n                    dst[dst_offset] = svextw_s16_x(pg, v_src, bj - j);\n                    dst_offset += rows;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t max_i = (i + block_size < rows) ? i + block_size : rows;\n            size_t max_j = (j + block_size < cols) ? j + block_size : cols;\n\n            for (size_t bi = i; bi < max_i; bi++) {\n                size_t vl = svcntw();\n                size_t k;\n                \n                for (k = j; k + vl <= max_j; k += vl) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t vec = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    for (size_t idx = 0; idx < vl && (k + idx) < max_j; idx++) {\n                        dst[(k + idx) * rows + bi] = svextw_s16_x(pg, vec, idx);\n                    }\n                }\n                \n                if (k < max_j) {\n                    svbool_t pg = svwhilelt_b16(0, max_j - k);\n                    svint16_t vec = svld1_s16(pg, &src[bi * cols + k]);\n                    \n                    for (size_t idx = 0; idx < (max_j - k); idx++) {\n                        dst[(k + idx) * rows + bi] = svextw_s16_x(pg, vec, idx);\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t dim_squared = dim * dim;\n    \n    svbool_t pg = svwhilelt_b32(0, dim);\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n    \n    for (size_t i = 0; i < dim; i++) {\n        size_t diagonal_idx = i * dim_squared + i * dim + i;\n        vec_sum = svadd_f32_z(pg, vec_sum, svdup_f32(array[diagonal_idx]));\n    }\n    \n    sum = svaddv_f32(pg, vec_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n    \n    size_t dim_squared = dim * dim;\n    size_t vec_length = svcntw();\n    \n    for (size_t i = 0; i < dim; i += vec_length) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        \n        size_t diagonal_idx = i * (dim_squared + dim + 1);\n        svfloat32_t vec = svld1_gather_index_f32(pg, array, \n            svindex_s32(diagonal_idx, dim_squared + dim + 1));\n            \n        vec_sum = svadd_f32_m(pg, vec_sum, vec);\n    }\n    \n    sum = svaddv_f32(svptrue_b32(), vec_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t diag_elements = dim;\n    size_t diag_stride = dim * dim + dim + 1;\n    \n    svbool_t pg = svwhilelt_b32(0, diag_elements);\n    svfloat32_t acc = svdup_f32(0.0f);\n    \n    for (size_t i = 0; i < diag_elements; i += svcntw()) {\n        svfloat32_t elements = svld1_gather_u32offset_f32(pg, \n            array, \n            svindex_u32(0, diag_stride));\n        acc = svadd_f32_m(pg, acc, elements);\n        pg = svwhilelt_b32(i + svcntw(), diag_elements);\n    }\n    \n    sum = svaddv_f32(svptrue_b32(), acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t diag_stride = dim * dim + dim + 1;\n    size_t total_elements = dim;\n    \n    svbool_t pg = svwhilelt_b32(0, total_elements);\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n    \n    size_t i = 0;\n    while (svptest_first(pg)) {\n        svfloat32_t vec = svld1_gather_index_f32(pg, array + i*diag_stride, svindex_s32(0, diag_stride));\n        sum_vec = svadd_f32_z(pg, sum_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n    \n    sum = svaddv_f32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float sum = 0.0f;\n    svfloat32_t vec_sum = svdup_f32(0.0f);\n    svbool_t pg = svptrue_b32();\n    \n    size_t dim_sq = dim * dim;\n    size_t total_elements = dim;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        size_t vl = svcntp_b32(pg, pg);\n        size_t remaining = total_elements - i;\n        vl = (vl > remaining) ? remaining : vl;\n        \n        svbool_t p = svwhilelt_b32(i, total_elements);\n        \n        size_t indices[MAX_SVE_LENGTH];\n        for (size_t j = 0; j < vl; j++) {\n            indices[j] = (i + j) * (dim_sq + dim + 1);\n        }\n        \n        svuint32_t vec_indices = svld1_u32(p, indices);\n        svfloat32_t vec_elements = svld1_gather_u32index_f32(p, array, vec_indices);\n        \n        vec_sum = svadd_f32_m(p, vec_sum, vec_elements);\n        \n        i += vl;\n    }\n    \n    sum = svaddv_f32(pg, vec_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t vthreshold = svdup_f64(threshold);\n    svfloat64_t vscale = svdup_f64(scale);\n\n    while (i < total_elements) {\n        svbool_t active = svwhilelt_b64(i, total_elements);\n        svfloat64_t vdata = svld1_f64(active, &src[i]);\n        \n        svbool_t mask = svcmpgt_f64(active, vdata, vthreshold);\n        svfloat64_t scaled = svmul_f64_m(active, vdata, vscale);\n        svfloat64_t result = svsel_f64(mask, scaled, vdata);\n        \n        svst1_f64(active, &dst[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t vthreshold = svdup_n_f64(threshold);\n    svfloat64_t vscale = svdup_n_f64(scale);\n\n    for (; i < total_elements; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, total_elements);\n        svfloat64_t vdata = svld1(p, &src[i]);\n        \n        svbool_t vcmp = svcmpgt(p, vdata, vthreshold);\n        svfloat64_t vresult = svmul_m(p, vdata, vdata, vscale);\n        \n        svst1(p, &dst[i], svsel(vcmp, vresult, vdata));\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        size_t this_vl = (i + vl <= total_elements) ? vl : total_elements - i;\n        \n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        \n        svfloat64_t vec_src = svld1_f64(pg, &src[i]);\n        svfloat64_t vec_threshold = svdup_n_f64(threshold);\n        svfloat64_t vec_scale = svdup_n_f64(scale);\n        \n        svbool_t mask = svcmpgt_f64(pg, vec_src, vec_threshold);\n        svfloat64_t vec_scaled = svmul_f64_m(pg, vec_src, vec_scale);\n        svfloat64_t vec_result = svsel_f64(mask, vec_scaled, vec_src);\n        \n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = svcntd();\n    \n    svbool_t pg = svptrue_b64();\n    svfloat64_t vec_threshold = svdup_n_f64(threshold);\n    svfloat64_t vec_scale = svdup_n_f64(scale);\n\n    for (size_t i = 0; i < total_elements; i += vl) {\n        if (i + vl > total_elements) {\n            pg = svwhilelt_b64(i, total_elements);\n        }\n\n        svfloat64_t vec_src = svld1_f64(pg, &src[i]);\n        svbool_t mask = svcmpgt_f64(pg, vec_src, vec_threshold);\n        svfloat64_t vec_scaled = svmul_f64_m(pg, vec_src, vec_scale);\n        svfloat64_t vec_result = svsel_f64(mask, vec_scaled, vec_src);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t vthreshold = svdup_f64(threshold);\n    svfloat64_t vscale = svdup_f64(scale);\n\n    while (i < total_elements) {\n        svbool_t active = svwhilelt_b64(i, total_elements);\n        \n        svfloat64_t vdata = svld1_f64(active, &src[i]);\n        \n        svbool_t mask = svcmpgt_f64(active, vdata, vthreshold);\n        svfloat64_t scaled = svmul_f64_m(active, vdata, vscale);\n        svfloat64_t result = svsel_f64(mask, scaled, vdata);\n        \n        svst1_f64(active, &dst[i], result);\n        \n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        \n        do {\n            svfloat64_t v = svld1_f64(pg, &src[src_offset + j]);\n            svst1_f64(pg, &dst[dst_offset + j], v);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        \n        do {\n            svfloat64_t vec = svld1_f64(pg, &src[src_offset + j]);\n            svst1_f64(pg, &dst[dst_offset + j], vec);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        for (size_t j = 0; j < cols; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t v = svld1_f64(pg, &src[src_offset + j]);\n            svst1_f64(pg, &dst[dst_offset + j], v);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        for (size_t j = 0; j < cols; j += vl) {\n            size_t curr_vl = (j + vl <= cols) ? vl : cols - j;\n            svbool_t pg = svwhilelt_b64(j, cols);\n            \n            svfloat64_t vec = svld1_f64(pg, &src[src_offset + j]);\n            svst1_f64(pg, &dst[dst_offset + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_offset = indices[i] * cols;\n        size_t dst_offset = i * cols;\n        \n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        \n        do {\n            svfloat64_t vec = svld1_f64(pg, &src[src_offset + j]);\n            svst1_f64(pg, &dst[dst_offset + j], vec);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svint64_t vec1 = svld1_s64(pg, src1);\n        svint64_t vec2 = svld1_s64(pg, src2);\n        \n        // Add vectors\n        svint64_t sum = svadd_s64_z(pg, vec1, vec2);\n        \n        // Add scalar\n        svint64_t with_scalar = svadd_n_s64_z(pg, sum, scalar);\n        \n        // Divide by 2 (arithmetic right shift by 1)\n        svint64_t result = svdiv_n_s64_z(pg, with_scalar, 2);\n        \n        // Store result\n        svst1_s64(pg, dst, result);\n        \n        src1 += svcntd();\n        src2 += svcntd();\n        dst += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    do {\n        svint64_t v1 = svld1_s64(pg, src1);\n        svint64_t v2 = svld1_s64(pg, src2);\n        \n        // Add vectors\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        \n        // Add scalar\n        sum = svadd_n_s64_z(pg, sum, scalar);\n        \n        // Divide by 2 (arithmetic right shift by 1)\n        svint64_t result = svdiv_n_s64_z(pg, sum, 2);\n        \n        // Store result\n        svst1_s64(pg, dst, result);\n        \n        src1 += svcntd();\n        src2 += svcntd();\n        dst += svcntd();\n        \n        pg = svwhilelt_b64(svcntd(), length);\n        \n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svint64_t v1 = svld1_s64(pg, src1);\n        svint64_t v2 = svld1_s64(pg, src2);\n        \n        // Add vectors\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        \n        // Add scalar\n        sum = svadd_n_s64_z(pg, sum, scalar);\n        \n        // Divide by 2\n        sum = svdiv_n_s64_z(pg, sum, 2);\n        \n        // Store result\n        svst1_s64(pg, dst, sum);\n        \n        src1 += svcntd();\n        src2 += svcntd();\n        dst += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svint64_t v1 = svld1_s64(pg, src1);\n        svint64_t v2 = svld1_s64(pg, src2);\n        \n        // Add vectors\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        \n        // Add scalar\n        sum = svadd_n_s64_z(pg, sum, scalar);\n        \n        // Divide by 2 (arithmetic right shift by 1)\n        svint64_t result = svdiv_n_s64_z(pg, sum, 2);\n        \n        // Store result\n        svst1_s64(pg, dst, result);\n        \n        src1 += svcntd();\n        src2 += svcntd();\n        dst += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    while(svptest_first(svptrue_b64(), pg)) {\n        svint64_t v1 = svld1_s64(pg, src1);\n        svint64_t v2 = svld1_s64(pg, src2);\n        \n        // Add vectors\n        svint64_t sum = svadd_s64_z(pg, v1, v2);\n        \n        // Add scalar\n        sum = svadd_n_s64_z(pg, sum, scalar);\n        \n        // Divide by 2 (arithmetic right shift by 1)\n        svint64_t result = svdiv_n_s64_z(pg, sum, 2);\n        \n        // Store result\n        svst1_s64(pg, dst, result);\n        \n        src1 += svcntd();\n        src2 += svcntd();\n        dst += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(p, &src[i]);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_z(p, svdup_b32(1), \n                                   svcmpeq_n_s32(svindex_s32(i, 1), 0));\n        \n        // Update minimum only for even indices\n        min_vec = svmin_s32_z(even_mask, min_vec, vec);\n    }\n    \n    // Horizontal minimum across vector\n    int min_val = svminv_s32(pg, min_vec);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(p, src + i);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_b_z(p, p, svdup_b32(1));\n        even_mask = svnot_b_z(p, even_mask);\n        \n        // Update minimum only for even indices\n        min_vec = svmin_s32_z(even_mask, min_vec, vec);\n    }\n    \n    // Horizontal minimum across vector\n    int min_val = svminv_s32(pg, min_vec);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(p, &src[i]);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_b_z(p, p, svnot_b_z(p, svdup_b32(false)));\n        \n        // Update minimum only for even indices\n        min_vec = svmin_s32_z(even_mask, min_vec, vec);\n    }\n    \n    // Horizontal minimum across vector\n    int min_val = svminv_s32(svptrue_b32(), min_vec);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n    \n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(p, &src[i]);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_b_z(p, p, svdup_b32(1));\n        even_mask = svnot_b_z(p, even_mask);\n        \n        // Update minimum only for even indices\n        min_vec = svmin_s32_z(even_mask, min_vec, vec);\n    }\n    \n    // Horizontal minimum reduction\n    int min_val = svminv_s32(pg, min_vec);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) return -1;\n\n    svbool_t pg = svwhilelt_b32(0, length);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(p, &src[i]);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_b_z(p, p, svdup_b32(true));\n        even_mask = svbic_b_z(p, even_mask, svdup_b32(1));\n        \n        // Update minimum only for even indices\n        min_vec = svmin_s32_z(even_mask, min_vec, vec);\n    }\n    \n    // Horizontal minimum across vector\n    int min_val = svminv_s32(svptrue_b32(), min_vec);\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, vec, shift);\n        \n        // Logical right shift - convert to uint first\n        svuint32_t uvec = svreinterpret_u32_s32(vec);\n        svuint32_t logic_shift = svlsr_n_u32_z(pg, uvec, shift);\n        svint32_t logic_shift_s = svreinterpret_s32_u32(logic_shift);\n        \n        // Add results and store\n        svint32_t result = svadd_s32_z(pg, arith_shift, logic_shift_s);\n        svst1_s32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, vec, shift);\n        \n        // Logical right shift (convert to uint, shift, convert back)\n        svuint32_t uvec = svreinterpret_u32_s32(vec);\n        svuint32_t logical_shift = svlsr_n_u32_z(pg, uvec, shift);\n        svint32_t logical_shift_s = svreinterpret_s32_u32(logical_shift);\n        \n        // Add results and store\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_s);\n        svst1_s32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, vec, shift);\n        \n        // Logical right shift - convert to uint, shift, convert back to int\n        svuint32_t uvec = svreinterpret_u32_s32(vec);\n        svuint32_t logical_shift = svlsr_n_u32_z(pg, uvec, shift);\n        svint32_t logical_shift_s = svreinterpret_s32_u32(logical_shift);\n        \n        // Add results and store\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_s);\n        svst1_s32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, vec, shift);\n        \n        // Logical right shift - first convert to uint\n        svuint32_t uvec = svreinterpret_u32_s32(vec);\n        svuint32_t logic_shift = svlsr_n_u32_z(pg, uvec, shift);\n        svint32_t logic_shift_s = svreinterpret_s32_u32(logic_shift);\n        \n        // Add results and store\n        svint32_t result = svadd_s32_z(pg, arith_shift, logic_shift_s);\n        svst1_s32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src);\n        \n        // Arithmetic right shift\n        svint32_t arith_shift = svasr_n_s32_z(pg, vec, shift);\n        \n        // Logical right shift - convert to uint first\n        svuint32_t uvec = svreinterpret_u32_s32(vec);\n        svuint32_t logical_shift = svlsr_n_u32_z(pg, uvec, shift);\n        svint32_t logical_shift_s = svreinterpret_s32_u32(logical_shift);\n        \n        // Add results together\n        svint32_t result = svadd_s32_z(pg, arith_shift, logical_shift_s);\n        \n        // Store result\n        svst1_s32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(0, total_elements);\n    svint32_t sum = svdup_n_s32(0);\n\n    while (svptest_first(pg, pg)) {\n        svint32_t elements = svld1_s32(pg, &matrix[i]);\n        sum = svadd_s32_z(pg, sum, elements);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n\n    return (int64_t)svaddv_s32(svptrue_b32(), sum);\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, total_elements);\n    svint32_t sum = svdup_n_s32(0);\n    \n    while (svptest_first(pg)) {\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        sum = svadd_s32_z(pg, sum, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n    \n    total = (int64_t)svaddv_s32(svptrue_b32(), sum);\n    return total;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svint32_t sum = svdup_n_s32(0);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        sum = svadd_s32_z(pg, sum, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n    \n    return (int64_t)svaddv_s32(svptrue_b32(), sum);\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(0, total_elements);\n    svint32_t sum = svdup_n_s32(0);\n\n    while (svptest_first(pg)) {\n        svint32_t elements = svld1_s32(pg, &matrix[i]);\n        sum = svadd_s32_z(pg, sum, elements);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n\n    total = (int64_t)svaddv_s32(svptrue_b32(), sum);\n    return total;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    svint32_t sum = svdup_n_s32(0);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &matrix[i]);\n        sum = svadd_s32_z(pg, sum, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n    \n    total = (int64_t)svaddv_s32(svptrue_b32(), sum);\n    return total;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_val = svdup_s8(INT8_MIN);\n    size_t max_idx = 0;\n    size_t i = 0;\n\n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        \n        if (svptest_any(pg, cmp)) {\n            svint8_t new_max = svmax_s8_z(pg, max_val, vec);\n            svbool_t is_max = svcmpeq_s8(pg, vec, new_max);\n            \n            size_t first_max = i + svfirst_b8(is_max);\n            \n            if (svmaxv_s8(pg, new_max) > svmaxv_s8(pg, max_val)) {\n                max_idx = first_max;\n                max_val = new_max;\n            }\n        }\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_val = svdup_s8(INT8_MIN);\n    size_t max_idx = 0;\n    size_t i = 0;\n\n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        \n        if (svptest_any(pg, cmp)) {\n            svint8_t new_max = svmax_s8_z(pg, max_val, vec);\n            svbool_t is_max = svcmpeq_s8(pg, vec, new_max);\n            \n            size_t first_max = i + svfirst_b8(is_max);\n            \n            if (svmaxv_s8(pg, new_max) > svmaxv_s8(pg, max_val)) {\n                max_idx = first_max;\n                max_val = new_max;\n            }\n        }\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_val = svdup_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_u64(0);\n    svuint64_t vec_idx = svindex_u64(0, 1);\n    size_t i = 0;\n\n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        \n        max_val = svsel_s8(cmp, vec, max_val);\n        max_idx = svsel_u64(cmp, svdup_u64(i) + vec_idx, max_idx);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    int8_t max = svmaxv_s8(svptrue_b8(), max_val);\n    size_t final_idx = 0;\n    \n    pg = svwhilelt_b8(0, length);\n    i = 0;\n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpeq_n_s8(pg, vec, max);\n        if (svptest_any(pg, cmp)) {\n            final_idx = i + svfindfi_s8(pg, cmp);\n            break;\n        }\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return final_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_val = svdup_s8(INT8_MIN);\n    svuint64_t max_idx = svdup_u64(0);\n    svuint64_t vec_idx = svindex_u64(0, 1);\n    size_t i = 0;\n\n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        \n        max_val = svsel_s8(cmp, vec, max_val);\n        max_idx = svsel_u64(cmp, svdup_u64(i) + vec_idx, max_idx);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    int8_t scalar_max = svmaxv_s8(svptrue_b8(), max_val);\n    svbool_t max_mask = svcmpeq_n_s8(svptrue_b8(), max_val, scalar_max);\n    uint64_t result = svminv_u64(max_mask, max_idx);\n\n    return (size_t)result;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n\n    svbool_t pg = svwhilelt_b8(0, length);\n    svint8_t max_val = svdup_s8(INT8_MIN);\n    size_t max_idx = 0;\n    size_t i = 0;\n\n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, &src[i]);\n        svbool_t cmp = svcmpgt_s8(pg, vec, max_val);\n        \n        if (svptest_any(pg, cmp)) {\n            svint8_t new_max = svmax_s8_z(pg, max_val, vec);\n            svbool_t is_max = svcmpeq_s8(pg, vec, new_max);\n            \n            size_t first_max = i + svfirst_b8(is_max);\n            \n            if (svmaxv_s8(pg, new_max) > svmaxv_s8(pg, max_val)) {\n                max_idx = first_max;\n                max_val = new_max;\n            }\n        }\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```cpp\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (svptest_first(pg)) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t mask_vec = svdup_n_u16(mask);\n        svuint16_t and_result = svand_u16_x(pg, indices, mask_vec);\n        svbool_t mask_pred = svcmpne_n_u16(pg, and_result, 0);\n\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsel_u16(mask_pred, vec1, vec2);\n        \n        svst1_u16(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (svptest_first(pg)) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t mask_vec = svdup_n_u16(mask);\n        svuint16_t and_result = svand_u16_x(pg, indices, mask_vec);\n        svbool_t mask_cond = svcmpne_n_u16(pg, and_result, 0);\n        \n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsel_u16(mask_cond, vec1, vec2);\n        \n        svst1_u16(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (svptest_first(pg)) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t mask_vec = svdup_n_u16(mask);\n        svuint16_t and_result = svand_u16_z(pg, indices, mask_vec);\n        svbool_t mask_pred = svcmpne_n_u16(pg, and_result, 0);\n\n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsel_u16(mask_pred, vec1, vec2);\n\n        svst1_u16(pg, &dst[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (svptest_first(pg)) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t mask_vec = svdup_n_u16(mask);\n        \n        svuint16_t and_result = svand_u16_x(pg, indices, mask_vec);\n        svbool_t mask_cond = svcmpne_n_u16(pg, and_result, 0);\n        \n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        \n        svuint16_t result = svsel_u16(mask_cond, vec1, vec2);\n        svst1_u16(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    size_t i = 0;\n\n    while (svptest_first(pg, pg)) {\n        svuint16_t indices = svindex_u16(i, 1);\n        svuint16_t mask_vec = svdup_n_u16(mask);\n        svuint16_t and_result = svand_u16_x(pg, indices, mask_vec);\n        svbool_t mask_pred = svcmpne_n_u16(pg, and_result, 0);\n        \n        svuint16_t vec1 = svld1_u16(pg, &src1[i]);\n        svuint16_t vec2 = svld1_u16(pg, &src2[i]);\n        svuint16_t result = svsel_u16(mask_pred, vec1, vec2);\n        \n        svst1_u16(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg;\n    svuint32_t vec_src;\n    svuint32_t vec_result;\n    size_t processed = 0;\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        vec_src = svld1_u32(pg, &src[processed]);\n        vec_result = svcnt_u32_x(pg, vec_src);\n        svst1_u32(pg, &dst[processed], vec_result);\n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        svuint32_t vec = svld1_u32(pg, &src[processed]);\n        svuint32_t cnt = svcnt_u32_x(pg, vec);\n        svst1_u32(pg, &dst[processed], cnt);\n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        svuint32_t input = svld1_u32(pg, &src[processed]);\n        svuint32_t result = svcnt_u32_x(pg, input);\n        svst1_u32(pg, &dst[processed], result);\n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        svuint32_t vec = svld1_u32(pg, &src[processed]);\n        svuint32_t popcnt = svcnt_u32_x(pg, vec);\n        svst1_u32(pg, &dst[processed], popcnt);\n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        svuint32_t vec = svld1_u32(pg, &src[processed]);\n        svuint32_t cnt = svcnt_u32_x(pg, vec);\n        svst1_u32(pg, &dst[processed], cnt);\n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1_u16(pg, src1);\n        svuint16_t vec2 = svld1_u16(pg, src2);\n        svuint16_t result = svqadd_u16_x(pg, vec1, vec2);\n        svst1_u16(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1_u16(pg, src1);\n        svuint16_t vec2 = svld1_u16(pg, src2);\n        svuint16_t result = svqadd_u16_x(pg, vec1, vec2);\n        svst1_u16(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1_u16(pg, src1);\n        svuint16_t vec2 = svld1_u16(pg, src2);\n        svuint16_t result = svqadd_u16_x(pg, vec1, vec2);\n        svst1_u16(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1_u16(pg, src1);\n        svuint16_t vec2 = svld1_u16(pg, src2);\n        svuint16_t result = svqadd_u16_x(pg, vec1, vec2);\n        svst1_u16(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svuint16_t vec1 = svld1_u16(pg, src1);\n        svuint16_t vec2 = svld1_u16(pg, src2);\n        svuint16_t result = svqadd_u16_x(pg, vec1, vec2);\n        svst1_u16(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b16(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            svbool_t pg = svwhilelt_b64(k, n);\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t a = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &B[j + k * p]);\n                \n                // Create masks for range check\n                svbool_t mask_a = svand_b_z(pg, \n                    svaclt_f64(pg, a, svdup_f64(100.0)),\n                    svacgt_f64(pg, a, svdup_f64(-100.0))\n                );\n                \n                svbool_t mask_b = svand_b_z(pg,\n                    svaclt_f64(pg, b, svdup_f64(100.0)), \n                    svacgt_f64(pg, b, svdup_f64(-100.0))\n                );\n                \n                svbool_t valid_mask = svand_b_z(pg, mask_a, mask_b);\n                \n                // Multiply and accumulate only valid elements\n                sum = svmad_f64_z(valid_mask, a, b, sum);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n            \n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            svbool_t pg = svwhilelt_b64(k, n);\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t va = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t vb = svld1_f64(pg, &B[j + k * p]);\n                \n                // Create masks for range check\n                svbool_t mask_a = svand_b_z(pg, \n                    svaclt_f64(pg, va, svdup_f64(100.0)),\n                    svacgt_f64(pg, va, svdup_f64(-100.0))\n                );\n                \n                svbool_t mask_b = svand_b_z(pg,\n                    svaclt_f64(pg, vb, svdup_f64(100.0)), \n                    svacgt_f64(pg, vb, svdup_f64(-100.0))\n                );\n                \n                svbool_t valid_mask = svand_b_z(pg, mask_a, mask_b);\n                \n                // Multiply and accumulate only valid elements\n                svfloat64_t prod = svmul_f64_z(valid_mask, va, vb);\n                sum = svadd_f64_m(valid_mask, sum, prod);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n            \n            // Horizontal sum\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            svbool_t pg = svwhilelt_b64(k, n);\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t a = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t b = svld1_f64(pg, &B[j + k * p]);\n                \n                // Create masks for range check\n                svbool_t mask_a = svand_b_z(pg, \n                    svaclt_f64(pg, a, svdup_f64(100.0)),\n                    svacgt_f64(pg, a, svdup_f64(-100.0))\n                );\n                \n                svbool_t mask_b = svand_b_z(pg,\n                    svaclt_f64(pg, b, svdup_f64(100.0)), \n                    svacgt_f64(pg, b, svdup_f64(-100.0))\n                );\n                \n                svbool_t valid_mask = svand_b_z(pg, mask_a, mask_b);\n                \n                // Multiply and accumulate only valid elements\n                sum = svmla_f64_z(valid_mask, sum, a, b);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n            \n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            svbool_t pg = svwhilelt_b64(k, n);\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t va = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t vb = svld1_f64(pg, &B[j + k * p]);\n                \n                // Create masks for range check\n                svbool_t mask_a = svand_b_z(pg, \n                    svaclt_f64(pg, va, svdup_f64(100.0)),\n                    svacgt_f64(pg, va, svdup_f64(-100.0))\n                );\n                \n                svbool_t mask_b = svand_b_z(pg,\n                    svaclt_f64(pg, vb, svdup_f64(100.0)), \n                    svacgt_f64(pg, vb, svdup_f64(-100.0))\n                );\n                \n                // Combine masks\n                svbool_t valid_mask = svand_b_z(pg, mask_a, mask_b);\n                \n                // Multiply and accumulate only valid elements\n                svfloat64_t prod = svmul_f64_z(valid_mask, va, vb);\n                sum = svadd_f64_m(valid_mask, sum, prod);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n            \n            // Reduce sum vector\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            size_t k = 0;\n            \n            svbool_t pg = svwhilelt_b64(k, n);\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t va = svld1_f64(pg, &A[i * n + k]);\n                svfloat64_t vb = svld1_f64(pg, &B[j + k * p]);\n                \n                // Create masks for range check\n                svbool_t range_mask_a = svand_b_z(pg, \n                    svaclt_f64(pg, va, svdup_f64(100.0)),\n                    svacgt_f64(pg, va, svdup_f64(-100.0))\n                );\n                \n                svbool_t range_mask_b = svand_b_z(pg,\n                    svaclt_f64(pg, vb, svdup_f64(100.0)), \n                    svacgt_f64(pg, vb, svdup_f64(-100.0))\n                );\n                \n                svbool_t valid_mask = svand_b_z(pg, range_mask_a, range_mask_b);\n                \n                // Multiply and accumulate only valid elements\n                svfloat64_t prod = svmul_f64_z(valid_mask, va, vb);\n                sum = svadd_f64_m(valid_mask, sum, prod);\n                \n                k += svcntd();\n                pg = svwhilelt_b64(k, n);\n            }\n            \n            // Horizontal sum\n            C[i * p + j] = svaddv_f64(svptrue_b64(), sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_size);\n    while (svptest_first(svptrue_b64(), pg)) {\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_size);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n\n    for (; i + svcntd() <= total_elements; i += svcntd()) {\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n    }\n\n    // Handle remaining elements\n    if (i < total_elements) {\n        svbool_t pg_tail = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg_tail, &A[i]);\n        svint64_t vb = svld1_s64(pg_tail, &B[i]);\n        svint64_t vc = svadd_s64_z(pg_tail, va, vb);\n        svst1_s64(pg_tail, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_size);\n    while (svptest_first(svptrue_b64(), pg)) {\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_size);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1_s64(pg, &A[i]);\n        svint64_t vb = svld1_s64(pg, &B[i]);\n        svint64_t vc = svadd_s64_z(pg, va, vb);\n        svst1_s64(pg, &C[i], vc);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_m(pg, sum);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, src1);\n        svfloat32_t vec2 = svld1_f32(pg, src2);\n        \n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        \n        svst1_f32(pg, dst, rounded);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, src1);\n        svfloat32_t vec2 = svld1_f32(pg, src2);\n        \n        svfloat32_t sum = svadd_f32_z(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        \n        svst1_f32(pg, dst, rounded);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        svfloat32_t sum = svadd_f32_m(pg, vec1, vec2);\n        svfloat32_t rounded = svrintn_f32_m(pg, sum);\n        svst1_f32(pg, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    size_t i = 0;\n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &src1[i]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[i]);\n        \n        // Create index vector\n        svuint32_t indices = svindex_u32(i, 1);\n        \n        // Check if index is multiple of 2\n        svbool_t is_multiple_2 = svcmpeq_n_u32(pg, svand_n_u32_z(pg, indices, 1), 0);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_z(pg, svsub_f32_z(pg, vec1, vec2));\n        svbool_t within_50 = svcmplt_n_f32(pg, diff, 50.0f);\n        \n        // Combine conditions\n        svbool_t valid_elements = svand_b_z(pg, within_50, is_multiple_2);\n        \n        // Multiply valid elements and round up\n        svfloat32_t mul = svmul_f32_z(valid_elements, vec1, vec2);\n        svfloat32_t rounded = svceil_f32_z(valid_elements, mul);\n        \n        // Set -1 for invalid elements\n        svfloat32_t result = svsel_f32(valid_elements, rounded, svdup_n_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, &dst[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, length);\n        \n        // Load vectors\n        svfloat32_t v1 = svld1_f32(p, &src1[i]);\n        svfloat32_t v2 = svld1_f32(p, &src2[i]);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svsub_f32_z(p, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_z(p, diff);\n        \n        // Check if difference is within 50\n        svbool_t diff_mask = svcmplt_f32(p, abs_diff, 50.0f);\n        \n        // Create mask for indices divisible by 2\n        svbool_t idx_mask = svand_z(p, p, svdup_b32(0x55555555));\n        \n        // Combine conditions\n        svbool_t final_mask = svand_b_z(p, diff_mask, idx_mask);\n        \n        // Multiply elements that meet conditions\n        svfloat32_t mul = svmul_f32_z(final_mask, v1, v2);\n        \n        // Round up toward positive infinity\n        svfloat32_t rounded = svceil_f32_z(final_mask, mul);\n        \n        // Set -1 for elements that don't meet conditions\n        svfloat32_t result = svsel_f32(final_mask, rounded, svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(p, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, src1);\n        svfloat32_t vec2 = svld1_f32(pg, src2);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n        \n        // Check if difference is within 50\n        svbool_t diff_mask = svcmplt_f32(pg, diff, 50.0f);\n        \n        // Create mask for indices divisible by 2\n        svbool_t idx_mask = svand_z(pg, pg, svdup_b32(0x55555555));\n        \n        // Combine conditions\n        svbool_t final_mask = svand_b_z(pg, diff_mask, idx_mask);\n        \n        // Multiply elements that meet conditions and round up\n        svfloat32_t mul = svmul_f32_x(final_mask, vec1, vec2);\n        svfloat32_t rounded = svceil_f32_x(final_mask, mul);\n        \n        // Set -1 for elements that don't meet conditions\n        svfloat32_t result = svsel_f32(final_mask, rounded, svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, src1);\n        svfloat32_t vec2 = svld1_f32(pg, src2);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n        \n        // Check if diff <= 50\n        svbool_t diff_mask = svcmple_f32(pg, diff, 50.0f);\n        \n        // Create index mask for multiples of 2\n        svbool_t idx_mask = svand_z(pg, pg, svdup_b32(0x55555555));\n        \n        // Combine conditions\n        svbool_t final_mask = svand_b_z(pg, diff_mask, idx_mask);\n        \n        // Multiply elements that meet conditions\n        svfloat32_t mul = svmul_f32_x(final_mask, vec1, vec2);\n        \n        // Round up toward positive infinity\n        mul = svrintp_f32_x(final_mask, mul);\n        \n        // Set -1 for elements that don't meet conditions\n        svfloat32_t result = svsel_f32(final_mask, mul, svdup_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, dst, result);\n        \n        src1 += svcntw();\n        src2 += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    size_t offset = 0;\n    while (svptest_first(svptrue_b32(), pg)) {\n        // Load vectors\n        svfloat32_t vec1 = svld1_f32(pg, &src1[offset]);\n        svfloat32_t vec2 = svld1_f32(pg, &src2[offset]);\n        \n        // Calculate absolute difference\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n        \n        // Check if difference is within 50\n        svbool_t diff_mask = svcmplt_f32(pg, diff, 50.0f);\n        \n        // Create index mask for multiples of 2\n        svbool_t idx_mask = svcmpeq_n_u32(pg, svindex_u32(offset, 1), 0);\n        idx_mask = svand_b_z(pg, idx_mask, diff_mask);\n        \n        // Multiply elements that meet conditions\n        svfloat32_t mul = svmul_f32_z(idx_mask, vec1, vec2);\n        \n        // Round up toward positive infinity\n        mul = svceil_f32_z(idx_mask, mul);\n        \n        // Set -1 for elements that don't meet conditions\n        svfloat32_t result = svsel_f32(idx_mask, mul, svdup_n_f32(-1.0f));\n        \n        // Store result\n        svst1_f32(pg, &dst[offset], result);\n        \n        offset += svcntw();\n        pg = svwhilelt_b32(offset, length);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    \n    do {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_n_f64_x(pg, vec, scalar);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    svfloat64_t scalar_vec = svdup_n_f64(scalar);\n\n    while (svptest_first(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg, vec, scalar_vec);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b64();\n    svfloat64_t scalar_vec = svdup_n_f64(scalar);\n\n    for (; i + svcntd() <= total_elements; i += svcntd()) {\n        svfloat64_t mat_vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1_f64(pg, &dst[i], result);\n    }\n\n    // Handle remaining elements\n    if (i < total_elements) {\n        svbool_t pg_tail = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pg_tail, &mat[i]);\n        svfloat64_t result = svmul_f64_z(pg_tail, mat_vec, scalar_vec);\n        svst1_f64(pg_tail, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    do {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        svfloat64_t result = svmul_n_f64_x(pg, vec, scalar);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat64_t vec_scalar = svdup_n_f64(scalar);\n\n    for(; i < total_elements; i += svcntd()) {\n        pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec_mat = svld1_f64(pg, &mat[i]);\n        svfloat64_t vec_result = svmul_f64_z(pg, vec_mat, vec_scalar);\n        svst1_f64(pg, &dst[i], vec_result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate row norm\n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t sum = svdup_f32(0.0f);\n        \n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1_f32(pg, &row[j]);\n            svfloat32_t squared = svmul_f32_z(pg, vec, vec);\n            sum = svadd_f32_m(pg, sum, squared);\n            pg = svwhilelt_b32(j + svcntw(), n);\n        }\n        \n        float norm = sqrtf(svaddv_f32(svptrue_b32(), sum));\n\n        // Normalize row\n        pg = svwhilelt_b32(0, n);\n        svfloat32_t norm_vec = svdup_f32(norm);\n        \n        for (size_t j = 0; j < n; j += svcntw()) {\n            svfloat32_t vec = svld1_f32(pg, &row[j]);\n            svfloat32_t normalized = svdiv_f32_z(pg, vec, norm_vec);\n            svst1_f32(pg, &row[j], normalized);\n            pg = svwhilelt_b32(j + svcntw(), n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate L2 norm of row\n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t sum = svdup_f32(0.0f);\n        \n        size_t j = 0;\n        while (svptest_any(pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            sum = svadd_f32_z(pg, sum, svmul_f32_z(pg, vec, vec));\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n        \n        float l2_norm = sqrtf(svaddv_f32(svptrue_b32(), sum));\n        \n        // Normalize row by dividing by L2 norm\n        pg = svwhilelt_b32(0, n);\n        j = 0;\n        while (svptest_any(pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t normalized = svdiv_f32_z(pg, vec, svdup_f32(l2_norm));\n            svst1_f32(pg, row + j, normalized);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t sum = svdup_f32(0.0f);\n        \n        size_t j = 0;\n        while (svptest_any(pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t squared = svmul_f32_z(pg, vec, vec);\n            sum = svadd_f32_m(pg, sum, squared);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n        \n        float l2_norm = sqrtf(svaddv_f32(svptrue_b32(), sum));\n        \n        pg = svwhilelt_b32(0, n);\n        j = 0;\n        while (svptest_any(pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t normalized = svdiv_f32_z(pg, vec, svdup_f32(l2_norm));\n            svst1_f32(pg, row + j, normalized);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate L2 norm of row\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n        \n        svbool_t pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t vec = svld1_f32(pg, &row[j]);\n            svfloat32_t squared = svmul_f32_z(pg, vec, vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, squared);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        \n        float l2_norm = sqrtf(svaddv_f32(svptrue_b32(), sum_vec));\n\n        // Normalize row by dividing by L2 norm\n        svfloat32_t norm_vec = svdup_f32(l2_norm);\n        j = 0;\n        \n        pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t vec = svld1_f32(pg, &row[j]);\n            svfloat32_t normalized = svdiv_f32_z(pg, vec, norm_vec);\n            svst1_f32(pg, &row[j], normalized);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        \n        // Calculate L2 norm\n        svfloat32_t sum_vec = svdupq_n_f32(0.0f);\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        \n        do {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            sum_vec = svmad_f32_x(pg, vec, vec, sum_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        \n        float l2_norm = sqrtf(svaddv_f32(svptrue_b32(), sum_vec));\n        \n        // Normalize row\n        j = 0;\n        pg = svwhilelt_b32(j, n);\n        svfloat32_t norm_vec = svdup_n_f32(l2_norm);\n        \n        do {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t normalized = svdiv_f32_x(pg, vec, norm_vec);\n            svst1_f32(pg, row + j, normalized);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t v1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t v2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmla_f64_z(pg, sum, v1, v2);\n            }\n            \n            double total = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(total);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                size_t vl = svcntd();\n                if (k + vl > n) {\n                    vl = n - k;\n                }\n                \n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t v1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t v2 = svld1_f64(pg, &mat2[j + k * p]);\n                \n                sum = svmla_f64_x(pg, sum, v1, v2);\n            }\n            \n            double total = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(total);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t v1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t v2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmad_f64_x(pg, v1, v2, sum);\n            }\n            \n            double total = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(total);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                size_t vl = svcntd();\n                if (k + vl > n) {\n                    vl = n - k;\n                }\n                \n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t v1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t v2 = svld1_f64(pg, &mat2[j + k * p]);\n                \n                sum = svmad_f64_x(pg, v1, v2, sum);\n            }\n            \n            double total = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(total);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < n; k += svcntd()) {\n                svbool_t pg = svwhilelt_b64(k, n);\n                \n                svfloat64_t v1 = svld1_f64(pg, &mat1[i * n + k]);\n                svfloat64_t v2 = svld1_f64(pg, &mat2[k * p + j]);\n                \n                sum = svmad_f64_x(pg, v1, v2, sum);\n            }\n            \n            double total = svaddv_f64(svptrue_b64(), sum);\n            dst[i * p + j] = round(total);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_f32(quarter);\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            \n            // Load elements from source matrix\n            svfloat32_t elements = svld1_f32(pg, &src[i * cols + j]);\n            \n            // Round to nearest quarter by dividing by 0.25, rounding to int, and multiplying by 0.25\n            svfloat32_t divided = svdiv_f32_z(pg, elements, quarter_vec);\n            svfloat32_t rounded = svrintn_f32_z(pg, divided);\n            svfloat32_t result = svmul_f32_z(pg, rounded, quarter_vec);\n            \n            // Store transposed result\n            for (size_t k = 0; k < svcntw() && (j + k) < cols; k++) {\n                if (svptest_first(pg, svptrue_b32())) {\n                    dst[(j + k) * rows + i] = svextw_f32(result, k);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_n_f32(quarter);\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pred = svwhilelt_b32(j, cols);\n            \n            // Load elements from source matrix\n            svfloat32_t vec = svld1_f32(pred, &src[i * cols + j]);\n            \n            // Round to nearest quarter by dividing by 0.25, rounding to nearest int, then multiplying by 0.25\n            svfloat32_t divided = svdiv_f32_z(pred, vec, quarter_vec);\n            svfloat32_t rounded = svrintn_f32_z(pred, divided);\n            svfloat32_t result = svmul_f32_z(pred, rounded, quarter_vec);\n            \n            // Store transposed result\n            for (size_t k = 0; k < svcntw() && (j + k) < cols; k++) {\n                if (svptest_first(pred, svptrue_pat_b32(SV_VL1)))\n                    dst[(j + k) * rows + i] = svextw_f32(result, k);\n                pred = svpnext_b32(pred, svptrue_b32());\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_n_f32(quarter);\n    svbool_t pg = svptrue_b32();\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pred = svwhilelt_b32(j, cols);\n            \n            // Load elements from source matrix\n            svfloat32_t vec = svld1_f32(pred, &src[i * cols + j]);\n            \n            // Round to nearest quarter by dividing by 0.25, rounding to nearest int, then multiplying by 0.25\n            svfloat32_t divided = svdiv_f32_z(pred, vec, quarter_vec);\n            svfloat32_t rounded = svrintn_f32_z(pred, divided);\n            svfloat32_t result = svmul_f32_z(pred, rounded, quarter_vec);\n            \n            // Store transposed and rounded elements in destination matrix\n            for (size_t k = 0; k < svcntw() && (j + k) < cols; k++) {\n                if (svptest_first(pred, svptrue_pat_b32(SV_VL1))) {\n                    dst[(j + k) * rows + i] = svextw_f32(result, k);\n                }\n                pred = svpnext_b32(pred, pred);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_n_f32(quarter);\n    svbool_t pg;\n\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            pg = svwhilelt_b32(j, cols);\n            \n            // Load elements from source matrix\n            svfloat32_t src_vec = svld1_f32(pg, &src[i * cols + j]);\n            \n            // Round to nearest quarter by dividing by 0.25, rounding to int, and multiplying by 0.25\n            svfloat32_t div_vec = svdiv_f32_z(pg, src_vec, quarter_vec);\n            svfloat32_t round_vec = svrintn_f32_z(pg, div_vec);\n            svfloat32_t result = svmul_f32_z(pg, round_vec, quarter_vec);\n            \n            // Store transposed and rounded result\n            for (size_t k = 0; k < svcntw() && (j + k) < cols; k++) {\n                if (svptest_first(pg, svptrue_b32())) {\n                    dst[(j + k) * rows + i] = svextw_f32(result, k);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    svfloat32_t quarter_vec = svdup_f32(quarter);\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j += svcntw()) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            \n            // Load elements from source matrix\n            svfloat32_t vec = svld1_f32(pg, &src[i * cols + j]);\n            \n            // Round to nearest quarter by dividing by 0.25, rounding to int, and multiplying by 0.25\n            svfloat32_t divided = svdiv_f32_z(pg, vec, quarter_vec);\n            svfloat32_t rounded = svrintn_f32_z(pg, divided);\n            svfloat32_t result = svmul_f32_z(pg, rounded, quarter_vec);\n            \n            // Store transposed result\n            for (size_t k = 0; k < svcntw() && (j + k) < cols; k++) {\n                if (svptest_first(pg, svptrue_b32())) {\n                    dst[(j + k) * rows + i] = svextw_f32(result, k);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg;\n    svfloat32_t v1, v2, result;\n\n    while (i < total_elements) {\n        pg = svwhilelt_b32(i, total_elements);\n        v1 = svld1_f32(pg, &tensor1[i]);\n        v2 = svld1_f32(pg, &tensor2[i]);\n        \n        // Perform subtraction\n        result = svsub_f32_z(pg, v1, v2);\n        \n        // Round towards zero using truncation\n        result = svrintz_f32_z(pg, result);\n        \n        // Store result\n        svst1_f32(pg, &dst[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n\n    for (; i + svcntw() <= total_elements; i += svcntw()) {\n        svfloat32_t v1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &tensor2[i]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintz_f32_z(pg, diff);\n        \n        svst1_f32(pg, &dst[i], rounded);\n    }\n\n    // Handle remaining elements\n    if (i < total_elements) {\n        svbool_t pg_tail = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t v1 = svld1_f32(pg_tail, &tensor1[i]);\n        svfloat32_t v2 = svld1_f32(pg_tail, &tensor2[i]);\n        \n        svfloat32_t diff = svsub_f32_z(pg_tail, v1, v2);\n        svfloat32_t rounded = svrintz_f32_z(pg_tail, diff);\n        \n        svst1_f32(pg_tail, &dst[i], rounded);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_size) {\n        svbool_t pg = svwhilelt_b32(i, total_size);\n        \n        svfloat32_t v1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &tensor2[i]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintz_f32_z(pg, diff);\n        \n        svst1_f32(pg, &dst[i], rounded);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_size) {\n        svbool_t pg = svwhilelt_b32(i, total_size);\n        \n        svfloat32_t v1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &tensor2[i]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintz_f32_z(pg, diff);\n        \n        svst1_f32(pg, &dst[i], rounded);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svfloat32_t v1 = svld1_f32(pg, &tensor1[i]);\n        svfloat32_t v2 = svld1_f32(pg, &tensor2[i]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintz_f32_z(pg, diff);\n        \n        svst1_f32(pg, &dst[i], rounded);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t result = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], result);\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        size_t j = 0;\n        \n        svbool_t pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t v_mat = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t v_vec = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_x(pg, sum, v_mat, v_vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        \n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t sum = svdup_f32(0.0f);\n        size_t j;\n        \n        svbool_t pg = svwhilelt_b32(0, n);\n        for (j = 0; j < n; j += svcntw()) {\n            svfloat32_t v1 = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t v2 = svld1_f32(pg, &vec[j]);\n            sum = svmla_f32_x(pg, sum, v1, v2);\n            pg = svwhilelt_b32(j + svcntw(), n);\n        }\n        \n        dst[i] = svaddv_f32(svptrue_b32(), sum);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        svfloat32_t acc = svdup_f32(0.0f);\n        \n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        \n        do {\n            svfloat32_t v1 = svld1_f32(pg, &mat[i*n + j]);\n            svfloat32_t v2 = svld1_f32(pg, &vec[j]);\n            acc = svmla_f32_x(pg, acc, v1, v2);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        \n        sum = svaddv_f32(svptrue_b32(), acc);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        svfloat32_t acc = svdup_f32(0.0f);\n        \n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        \n        do {\n            svfloat32_t v1 = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t v2 = svld1_f32(pg, &vec[j]);\n            acc = svmla_f32_m(pg, acc, v1, v2);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        \n        sum = svaddv_f32(svptrue_b32(), acc);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        svfloat32_t acc = svdup_f32(0.0f);\n        \n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        \n        do {\n            svfloat32_t v1 = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t v2 = svld1_f32(pg, &vec[j]);\n            acc = svmla_f32_m(pg, acc, v1, v2);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        \n        sum = svaddv_f32(svptrue_b32(), acc);\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    \n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svptrue_b64();\n    \n    while(i < total_elements) {\n        svbool_t pred = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pred, &mat[i]);\n        sum_vec = svadd_f64_m(pred, sum_vec, vec);\n        i += svcntd();\n    }\n    \n    double sum = svaddv_f64(pg, sum_vec);\n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    \n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(0, total_elements);\n    \n    while(svptest_first(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n    \n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    \n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svptrue_b64();\n    \n    while (i + svcntd() <= total_elements) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n        i += svcntd();\n    }\n    \n    double sum = svaddv_f64(pg, sum_vec);\n    \n    if (i < total_elements) {\n        svbool_t pg_tail = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec_tail = svld1_f64(pg_tail, &mat[i]);\n        sum += svaddv_f64(pg_tail, vec_tail);\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    svbool_t pg = svwhilelt_b64(0, total_elements);\n    svfloat64_t acc = svdup_f64(0.0);\n    \n    size_t i = 0;\n    while (svptest_first(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        acc = svadd_f64_m(pg, acc, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n    \n    sum = svaddv_f64(svptrue_b64(), acc);\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double sum = 0.0;\n    \n    svbool_t pg = svwhilelt_b64(0, total_elements);\n    svfloat64_t acc = svdup_f64(0.0);\n    \n    size_t i = 0;\n    while (svptest_first(pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[i]);\n        acc = svadd_f64_m(pg, acc, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n    \n    sum = svaddv_f64(svptrue_b64(), acc);\n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svwhilelt_b32(0, cols-1);\n        \n        while (svptest_first(pg, pg)) {\n            svint32_t v_curr = svld1_s32(pg, curr_row);\n            svint32_t v_next = svld1_s32(pg, curr_row + 1);\n            \n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmpgt_s32(pg, v_curr, v_next);\n            } else {\n                cmp = svcmplt_s32(pg, v_curr, v_next);\n            }\n            \n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n            \n            curr_row += svcntw();\n            pg = svwhilelt_b32(curr_row - matrix, cols-1);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        svbool_t pg = svwhilelt_b32(0, cols-1);\n        \n        while (svptest_first(pg, pg)) {\n            svint32_t v1 = svld1_s32(pg, row);\n            svint32_t v2 = svld1_s32(pg, row + 1);\n            \n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmpgt_s32(pg, v1, v2);\n            } else {\n                cmp = svcmplt_s32(pg, v1, v2);\n            }\n            \n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n            \n            row += svcntw();\n            pg = svwhilelt_b32(row - matrix, cols-1);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svwhilelt_b32(0, cols-1);\n        \n        while (svptest_first(pg, pg)) {\n            svint32_t v_curr = svld1_s32(pg, curr_row);\n            svint32_t v_next = svld1_s32(pg, curr_row + 1);\n            \n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmpgt_s32(pg, v_curr, v_next);\n            } else {\n                cmp = svcmplt_s32(pg, v_curr, v_next);\n            }\n            \n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n            \n            curr_row += svcntw();\n            pg = svwhilelt_b32(curr_row - matrix, cols-1);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t row = 0; row < rows; row++) {\n        const int* curr_row = matrix + row * cols;\n        bool ascending = directions[row];\n        \n        svbool_t pg = svwhilelt_b32(0, cols-1);\n        \n        while (svptest_first(pg, pg)) {\n            svint32_t v1 = svld1_s32(pg, curr_row);\n            svint32_t v2 = svld1_s32(pg, curr_row + 1);\n            \n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmpgt_s32(pg, v1, v2);\n            } else {\n                cmp = svcmplt_s32(pg, v1, v2);\n            }\n            \n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n            \n            curr_row += svcntw();\n            pg = svwhilelt_b32(curr_row - matrix, cols);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```c\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n        \n        svbool_t pg = svwhilelt_b32(0, cols-1);\n        \n        while (svptest_first(pg, pg)) {\n            svint32_t v1 = svld1_s32(pg, row);\n            svint32_t v2 = svld1_s32(pg, row + 1);\n            \n            svbool_t cmp;\n            if (ascending) {\n                cmp = svcmpgt_s32(pg, v1, v2);\n            } else {\n                cmp = svcmplt_s32(pg, v1, v2);\n            }\n            \n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n            \n            row += svcntw();\n            pg = svwhilelt_b32(row - matrix, cols-1);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vec_src, vec_div, vec_mul;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        // Load vector from src\n        vec_src = svld1_s16(pg, src + i);\n        \n        // Divide by base (integer division)\n        vec_div = svdiv_s16_z(pg, vec_src, svdup_n_s16(base));\n        \n        // Multiply back by base to get nearest multiple\n        vec_mul = svmul_s16_z(pg, vec_div, svdup_n_s16(base));\n        \n        // Store result\n        svst1_s16(pg, dst + i, vec_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vec_src, vec_div, vec_mul;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        // Load vector from src\n        vec_src = svld1_s16(pg, src + i);\n        \n        // Divide by base\n        vec_div = svdiv_n_s16_z(pg, vec_src, base);\n        \n        // Multiply back by base to get nearest multiple\n        vec_mul = svmul_n_s16_z(pg, vec_div, base);\n        \n        // Store result\n        svst1_s16(pg, dst + i, vec_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vec_src, vec_div, vec_mul;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        // Load vector from src\n        vec_src = svld1_s16(pg, src + i);\n        \n        // Divide by base\n        vec_div = svdiv_n_s16_z(pg, vec_src, base);\n        \n        // Multiply back by base to get nearest multiple\n        vec_mul = svmul_n_s16_z(pg, vec_div, base);\n        \n        // Store result\n        svst1_s16(pg, dst + i, vec_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vec_src, vec_div, vec_mul;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        // Load vector from source\n        vec_src = svld1_s16(pg, src + i);\n        \n        // Divide by base\n        vec_div = svdiv_s16_z(pg, vec_src, svdup_n_s16(base));\n        \n        // Multiply back by base to get nearest multiple\n        vec_mul = svmul_s16_z(pg, vec_div, svdup_n_s16(base));\n        \n        // Store result\n        svst1_s16(pg, dst + i, vec_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    svbool_t pg;\n    svint16_t vec_src, vec_div, vec_mul;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        \n        // Load vector from source\n        vec_src = svld1_s16(pg, src + i);\n        \n        // Divide by base and convert to integer\n        vec_div = svdiv_n_s16_z(pg, vec_src, base);\n        \n        // Multiply back by base to get nearest multiple\n        vec_mul = svmul_n_s16_z(pg, vec_div, base);\n        \n        // Store result\n        svst1_s16(pg, dst + i, vec_mul);\n    }\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        svbool_t match = svpfalltrue_b(pg, svtrue_b64());\n        \n        while (svptest_any(pg, svptrue_b64())) {\n            svfloat64_t v1 = svld1_f64(pg, row + j);\n            svfloat64_t v2 = svld1_f64(pg, vector + j);\n            svbool_t cmp = svcmpeq_f64(pg, v1, v2);\n            match = svand_b_z(pg, match, cmp);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n        \n        if (svptest_any(match, svptrue_b64())) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        svbool_t match = svptrue_b64();\n        \n        do {\n            svfloat64_t v1 = svld1_f64(pg, row + j);\n            svfloat64_t v2 = svld1_f64(pg, vector + j);\n            match = svand_z(pg, match, svcmpeq(pg, v1, v2));\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n\n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        svbool_t match = svptrue_b64();\n        \n        do {\n            svfloat64_t vec1 = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t vec2 = svld1_f64(pg, &vector[j]);\n            \n            svbool_t cmp = svcmpeq_f64(pg, vec1, vec2);\n            match = svand_b_z(pg, match, cmp);\n            \n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n        \n        if (svptest_all(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        \n        svbool_t pg = svwhilelt_b64(0, cols);\n        svbool_t match = svdup_b64(1);\n        \n        while (svptest_first(pg, match)) {\n            svfloat64_t v1 = svld1_f64(pg, row + j);\n            svfloat64_t v2 = svld1_f64(pg, vector + j);\n            \n            match = svand_b_z(pg, match, svcmpeq_f64(pg, v1, v2));\n            \n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n        \n        if (svptest_last(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        svbool_t match = svdup_b64(1);\n\n        do {\n            svfloat64_t v_row = svld1_f64(pg, row + j);\n            svfloat64_t v_vec = svld1_f64(pg, vector + j);\n            \n            svbool_t cmp = svcmpeq_f64(pg, v_row, v_vec);\n            match = svand_b_z(pg, match, cmp);\n            \n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n\n        if (svptest_all(svptrue_b64(), match)) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t va, vb;\n    svbool_t vcmp;\n    \n    while (i + svcntb() <= total_size) {\n        va = svld1_u8(pg, &A[i]);\n        vb = svld1_u8(pg, &B[i]);\n        vcmp = svcmpeq_u8(pg, va, vb);\n        count += svcntp_b8(pg, vcmp);\n        i += svcntb();\n    }\n\n    if (i < total_size) {\n        svbool_t pg_tail = svwhilelt_b8(i, total_size);\n        va = svld1_u8(pg_tail, &A[i]);\n        vb = svld1_u8(pg_tail, &B[i]);\n        vcmp = svcmpeq_u8(pg_tail, va, vb);\n        count += svcntp_b8(pg_tail, vcmp);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t va, vb;\n    svbool_t vcmp;\n    \n    while (i + svcntb() <= total_size) {\n        va = svld1_u8(pg, &A[i]);\n        vb = svld1_u8(pg, &B[i]);\n        \n        vcmp = svcmpeq_u8(pg, va, vb);\n        count += svcntp_b8(pg, vcmp);\n        \n        i += svcntb();\n    }\n\n    if (i < total_size) {\n        svbool_t pg_last = svwhilelt_b8(i, total_size);\n        va = svld1_u8(pg_last, &A[i]);\n        vb = svld1_u8(pg_last, &B[i]);\n        \n        vcmp = svcmpeq_u8(pg_last, va, vb);\n        count += svcntp_b8(pg_last, vcmp);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t a, b;\n    svbool_t eq_mask;\n    \n    while (i + svcntb() <= total_size) {\n        a = svld1_u8(pg, &A[i]);\n        b = svld1_u8(pg, &B[i]);\n        \n        eq_mask = svcmpeq_u8(pg, a, b);\n        count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n    }\n\n    // Handle remaining elements\n    if (i < total_size) {\n        svbool_t pg_tail = svwhilelt_b8(i, total_size);\n        a = svld1_u8(pg_tail, &A[i]);\n        b = svld1_u8(pg_tail, &B[i]);\n        \n        eq_mask = svcmpeq_u8(pg_tail, a, b);\n        count += svcntp_b8(pg_tail, eq_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b8();\n    svuint8_t a, b;\n    svbool_t eq_mask;\n    \n    while (i < total_size) {\n        pg = svwhilelt_b8(i, total_size);\n        a = svld1_u8(pg, &A[i]);\n        b = svld1_u8(pg, &B[i]);\n        \n        eq_mask = svcmpeq_u8(pg, a, b);\n        count += svcntp_b8(pg, eq_mask);\n        \n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_size = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b8();\n    svuint64_t acc = svdup_u64(0);\n\n    while (i + svcntb() <= total_size) {\n        svuint8_t va = svld1_u8(pg, &A[i]);\n        svuint8_t vb = svld1_u8(pg, &B[i]);\n        svbool_t eq = svcmpeq_u8(pg, va, vb);\n        acc = svadd_u64_z(pg, acc, svcntp_b8(pg, eq));\n        i += svcntb();\n    }\n\n    count = svaddv_u64(pg, acc);\n\n    // Handle remaining elements\n    svbool_t pg_tail = svwhilelt_b8(i, total_size);\n    if (!svptest_any(svptrue_b8(), pg_tail)) {\n        return count;\n    }\n\n    svuint8_t va_tail = svld1_u8(pg_tail, &A[i]);\n    svuint8_t vb_tail = svld1_u8(pg_tail, &B[i]);\n    svbool_t eq_tail = svcmpeq_u8(pg_tail, va_tail, vb_tail);\n    count += svcntp_b8(pg_tail, eq_tail);\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    do {\n        svint64_t vx = svld1_s64(pg, x);\n        svint64_t vy = svld1_s64(pg, y);\n        \n        svint64_t mul = svmul_n_s64_x(pg, vx, a);\n        svint64_t abs_y = svabs_s64_x(pg, vy);\n        svint64_t result = svsub_s64_x(pg, mul, abs_y);\n        \n        svst1_s64(pg, y, result);\n        \n        x += svcntd();\n        y += svcntd();\n        length -= svcntd();\n        pg = svwhilelt_b64(0, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    do {\n        svint64_t vx = svld1_s64(pg, x);\n        svint64_t vy = svld1_s64(pg, y);\n        \n        svint64_t mul = svmul_n_s64_x(pg, vx, a);\n        svint64_t abs_y = svabs_s64_x(pg, vy);\n        svint64_t result = svsub_s64_x(pg, mul, abs_y);\n        \n        svst1_s64(pg, y, result);\n        \n        x += svcntd();\n        y += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n        \n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    do {\n        svint64_t vx = svld1_s64(pg, x);\n        svint64_t vy = svld1_s64(pg, y);\n        \n        svint64_t mul = svmul_n_s64_x(pg, vx, a);\n        svint64_t abs_y = svabs_s64_x(pg, vy);\n        svint64_t result = svsub_s64_x(pg, mul, abs_y);\n        \n        svst1_s64(pg, y, result);\n        \n        x += svcntd();\n        y += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n        \n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    do {\n        svint64_t vx = svld1_s64(pg, x);\n        svint64_t vy = svld1_s64(pg, y);\n        \n        svint64_t mul = svmul_n_s64_x(pg, vx, a);\n        svint64_t abs_y = svabs_s64_x(pg, vy);\n        svint64_t result = svsub_s64_x(pg, mul, abs_y);\n        \n        svst1_s64(pg, y, result);\n        \n        x += svcntd();\n        y += svcntd();\n        length -= svcntd();\n        pg = svwhilelt_b64(0, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    \n    do {\n        svint64_t vx = svld1_s64(pg, x);\n        svint64_t vy = svld1_s64(pg, y);\n        \n        svint64_t mul = svmul_n_s64_x(pg, vx, a);\n        svint64_t abs_y = svabs_s64_x(pg, vy);\n        svint64_t result = svsub_s64_x(pg, mul, abs_y);\n        \n        svst1_s64(pg, y, result);\n        \n        x += svcntd();\n        y += svcntd();\n        pg = svwhilelt_b64(svcntd(), length);\n        \n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    svint16_t vec_max = svdup_s16(INT16_MIN);\n    svint16_t vec_min = svdup_s16(INT16_MAX);\n    \n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    do {\n        svint16_t data = svld1_s16(pg, vec);\n        vec_max = svmax_s16_z(pg, vec_max, data);\n        vec_min = svmin_s16_z(pg, vec_min, data);\n        vec += svcntw();\n        pg = svwhilelt_b16(vec - vec, length);\n    } while (svptest_any(svptrue_b16(), pg));\n    \n    result.max_num = svmaxv_s16(svptrue_b16(), vec_max);\n    result.min_num = svminv_s16(svptrue_b16(), vec_min);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_val = svld1_s16(pg, vec);\n    svint16_t min_val = vec_val;\n    svint16_t max_val = vec_val;\n    \n    size_t i = svlen_s16();\n    while(svptest_any(pg)) {\n        pg = svwhilelt_b16(i, length);\n        vec_val = svld1_s16(pg, vec + i);\n        min_val = svmin_s16_z(pg, min_val, vec_val);\n        max_val = svmax_s16_z(pg, max_val, vec_val);\n        i += svlen_s16();\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), min_val);\n    result.max_num = svmaxv_s16(svptrue_b16(), max_val);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    svint16_t vec_max = svdup_s16(INT16_MIN);\n    svint16_t vec_min = svdup_s16(INT16_MAX);\n    \n    svbool_t pg = svwhilelt_b16(0, length);\n    \n    do {\n        svint16_t input = svld1_s16(pg, vec);\n        vec_max = svmax_s16_z(pg, vec_max, input);\n        vec_min = svmin_s16_z(pg, vec_min, input);\n        vec += svcntw();\n        pg = svwhilelt_b16(vec - vec, length);\n    } while (svptest_any(svptrue_b16(), pg));\n\n    result.max_num = svmaxv_s16(svptrue_b16(), vec_max);\n    result.min_num = svminv_s16(svptrue_b16(), vec_min);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_val = svld1_s16(pg, vec);\n    svint16_t max_val = vec_val;\n    svint16_t min_val = vec_val;\n    \n    size_t i = svlen_s16(vec_val);\n    while (i < length) {\n        pg = svwhilelt_b16(i, length);\n        vec_val = svld1_s16(pg, vec + i);\n        max_val = svmax_s16_z(pg, max_val, vec_val);\n        min_val = svmin_s16_z(pg, min_val, vec_val);\n        i += svlen_s16(vec_val);\n    }\n    \n    result.max_num = (int16_t)svmaxv_s16(svptrue_b16(), max_val);\n    result.min_num = (int16_t)svminv_s16(svptrue_b16(), min_val);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    \n    svbool_t pg = svwhilelt_b16(0, length);\n    svint16_t vec_val = svld1_s16(pg, vec);\n    svint16_t min_val = vec_val;\n    svint16_t max_val = vec_val;\n    \n    size_t i = svlen_s16(vec_val);\n    while (i < length) {\n        pg = svwhilelt_b16(i, length);\n        vec_val = svld1_s16(pg, vec + i);\n        min_val = svmin_s16_z(pg, min_val, vec_val);\n        max_val = svmax_s16_z(pg, max_val, vec_val);\n        i += svlen_s16(vec_val);\n    }\n    \n    result.min_num = svminv_s16(svptrue_b16(), min_val);\n    result.max_num = svmaxv_s16(svptrue_b16(), max_val);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, cols-1);\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j < cols-1; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, cols-1);\n            \n            svint32_t v1 = svld1_s32(p, row + j);\n            svint32_t v2 = svld1_s32(p, row + j + 1);\n            \n            svbool_t cmp = svcmplt_s32(p, v1, v2);\n            \n            if (!svptest_all(p, cmp)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, cols-1);\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j < cols-1; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, cols-1);\n            \n            svint32_t v1 = svld1_s32(p, row + j);\n            svint32_t v2 = svld1_s32(p, row + j + 1);\n            \n            svbool_t cmp = svcmplt_s32(p, v1, v2);\n            \n            if (!svptest_all(p, cmp)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, cols-1);\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j < cols-1; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, cols-1);\n            \n            svint32_t v1 = svld1_s32(p, row + j);\n            svint32_t v2 = svld1_s32(p, row + j + 1);\n            \n            svbool_t cmp = svcmplt_s32(p, v1, v2);\n            \n            if (!svptest_first(p, cmp)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svptrue_b32();\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j < cols - 1; j += svcntw()) {\n            size_t vl = svcntw();\n            if (j + vl > cols - 1) {\n                vl = cols - 1 - j;\n                pg = svwhilelt_b32(0, vl);\n            }\n            \n            svint32_t v1 = svld1_s32(pg, row + j);\n            svint32_t v2 = svld1_s32(pg, row + j + 1);\n            \n            svbool_t comp = svcmplt_s32(pg, v1, v2);\n            \n            if (!svptest_any(pg, comp)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, cols-1);\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t j;\n        \n        for (j = 0; j < cols-1; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, cols-1);\n            \n            svint32_t v1 = svld1_s32(p, row + j);\n            svint32_t v2 = svld1_s32(p, row + j + 1);\n            \n            svbool_t cmp = svcmplt_s32(p, v1, v2);\n            \n            if (!svptest_first(p, cmp)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Get SVE vector length\n    size_t vl = svcntw();\n\n    // For each row in first block\n    for (size_t i = 0; i < block_size; i++) {\n        // For each col in first block\n        for (size_t j = 0; j < block_size; j++) {\n            int ref_val = matrix[i * cols + j];\n            \n            // Compare with corresponding position in other blocks\n            for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n                for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n                    // Skip first block\n                    if (block_row == 0 && block_col == 0) continue;\n                    \n                    size_t row = block_row * block_size + i;\n                    size_t col = block_col * block_size + j;\n                    \n                    if (matrix[row * cols + col] != ref_val) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    // Get first block as reference\n    int* first_block = (int*)malloc(block_size * block_size * sizeof(int));\n    for (size_t i = 0; i < block_size; i++) {\n        for (size_t j = 0; j < block_size; j++) {\n            first_block[i * block_size + j] = matrix[i * cols + j];\n        }\n    }\n\n    // Compare each block with first block\n    for (size_t block_i = 0; block_i < num_blocks_row; block_i++) {\n        for (size_t block_j = 0; block_j < num_blocks_col; block_j++) {\n            if (block_i == 0 && block_j == 0) continue;\n\n            for (size_t i = 0; i < block_size; i++) {\n                size_t row_offset = block_i * block_size + i;\n                size_t col_offset = block_j * block_size;\n                \n                svbool_t pg = svwhilelt_b32(0, block_size);\n                do {\n                    svint32_t v1 = svld1_s32(pg, &matrix[row_offset * cols + col_offset]);\n                    svint32_t v2 = svld1_s32(pg, &first_block[i * block_size]);\n                    \n                    svbool_t cmp = svcmpne_s32(pg, v1, v2);\n                    if (svptest_any(svptrue_b32(), cmp)) {\n                        free(first_block);\n                        return false;\n                    }\n                    \n                    col_offset += svcntw();\n                    pg = svwhilelt_b32(col_offset, block_size);\n                } while (svptest_any(svptrue_b32(), pg));\n            }\n        }\n    }\n\n    free(first_block);\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    if (num_blocks_row == 1 && num_blocks_col == 1) {\n        return true;\n    }\n\n    // Get vector length\n    size_t vl = svcntw();\n\n    // Compare each block with first block\n    for (size_t block_r = 0; block_r < num_blocks_row; block_r++) {\n        for (size_t block_c = 0; block_c < num_blocks_col; block_c++) {\n            // Skip first block\n            if (block_r == 0 && block_c == 0) continue;\n\n            // Compare current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                size_t first_block_row = i;\n                size_t curr_block_row = block_r * block_size + i;\n                \n                size_t j = 0;\n                svbool_t pg = svwhilelt_b32(j, block_size);\n                \n                do {\n                    // Load elements from first block and current block\n                    svint32_t v1 = svld1_s32(pg, matrix + first_block_row * cols + j);\n                    svint32_t v2 = svld1_s32(pg, matrix + curr_block_row * cols + block_c * block_size + j);\n                    \n                    // Compare vectors\n                    svbool_t cmp = svcmpeq_s32(pg, v1, v2);\n                    \n                    // Check if any elements are not equal\n                    if (!svptest_all(pg, cmp)) {\n                        return false;\n                    }\n                    \n                    j += vl;\n                    pg = svwhilelt_b32(j, block_size);\n                    \n                } while (svptest_any(svptrue_b32(), pg));\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    if (num_blocks_row == 1 && num_blocks_col == 1) {\n        return true;\n    }\n\n    // Get vector length\n    size_t vl = svcntw();\n\n    // Compare each block with first block\n    for (size_t block_row = 0; block_row < num_blocks_row; block_row++) {\n        for (size_t block_col = 0; block_col < num_blocks_col; block_col++) {\n            // Skip first block\n            if (block_row == 0 && block_col == 0) {\n                continue;\n            }\n\n            // Compare current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                size_t first_block_row = i;\n                size_t curr_block_row = block_row * block_size + i;\n                \n                size_t j = 0;\n                for (; j + vl <= block_size; j += vl) {\n                    size_t first_idx = first_block_row * cols + j;\n                    size_t curr_idx = curr_block_row * cols + block_col * block_size + j;\n\n                    svbool_t pg = svwhilelt_b32(j, block_size);\n                    svint32_t v1 = svld1_s32(pg, &matrix[first_idx]);\n                    svint32_t v2 = svld1_s32(pg, &matrix[curr_idx]);\n                    \n                    svbool_t cmp = svcmpeq_s32(pg, v1, v2);\n                    if (!svptest_all(pg, cmp)) {\n                        return false;\n                    }\n                }\n\n                // Handle remaining elements\n                for (; j < block_size; j++) {\n                    size_t first_idx = first_block_row * cols + j;\n                    size_t curr_idx = curr_block_row * cols + block_col * block_size + j;\n                    if (matrix[first_idx] != matrix[curr_idx]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n    \n    if (num_blocks_row == 1 && num_blocks_col == 1) {\n        return true;\n    }\n\n    // Get vector length\n    size_t vl = svcntw();\n\n    // Compare each block with first block\n    for (size_t block_r = 0; block_r < num_blocks_row; block_r++) {\n        for (size_t block_c = 0; block_c < num_blocks_col; block_c++) {\n            if (block_r == 0 && block_c == 0) continue;\n\n            // Compare current block with first block\n            for (size_t i = 0; i < block_size; i++) {\n                size_t first_block_row = i;\n                size_t curr_block_row = block_r * block_size + i;\n                \n                size_t j = 0;\n                svbool_t pg = svwhilelt_b32(j, block_size);\n                \n                do {\n                    size_t first_idx = first_block_row * cols + j;\n                    size_t curr_idx = curr_block_row * cols + block_c * block_size + j;\n                    \n                    svint32_t v1 = svld1_s32(pg, matrix + first_idx);\n                    svint32_t v2 = svld1_s32(pg, matrix + curr_idx);\n                    \n                    svbool_t cmp = svcmpeq_s32(pg, v1, v2);\n                    if (!svptest_any(pg, cmp)) {\n                        return false;\n                    }\n                    \n                    j += vl;\n                    pg = svwhilelt_b32(j, block_size);\n                    \n                } while (svptest_any(svptrue_b32(), pg));\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1_f64(pg, vec);\n\n    for (size_t i = 1; i < num_complete_blocks; i++) {\n        svfloat64_t curr_block = svld1_f64(pg, vec + i * block_size);\n        \n        svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, first_block, curr_block));\n        svbool_t cmp = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n        \n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_complete_blocks = length / block_size;\n    if (num_complete_blocks <= 1) {\n        return false;\n    }\n\n    const size_t vl = svcntd();\n    svbool_t pg = svptrue_b64();\n\n    for (size_t block = 1; block < num_complete_blocks; block++) {\n        size_t block_offset = block * block_size;\n        size_t elements_checked = 0;\n\n        while (elements_checked < block_size) {\n            size_t current_vl = (block_size - elements_checked) < vl ? \n                              (block_size - elements_checked) : vl;\n            \n            pg = svwhilelt_b64(elements_checked, block_size);\n\n            svfloat64_t v1 = svld1_f64(pg, vec + elements_checked);\n            svfloat64_t v2 = svld1_f64(pg, vec + block_offset + elements_checked);\n            \n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, v1, v2));\n            svbool_t cmp = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n            \n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n\n            elements_checked += current_vl;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1_f64(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t curr_block = svld1_f64(pg, vec + i * block_size);\n        \n        svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, first_block, curr_block));\n        svbool_t cmp = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n        \n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1_f64(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        const double* curr_block = vec + i * block_size;\n        svfloat64_t curr_vec = svld1_f64(pg, curr_block);\n        \n        svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, first_block, curr_vec));\n        svbool_t cmp = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n        \n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (!vec || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return false;\n    }\n\n    svbool_t pg = svwhilelt_b64(0, block_size);\n    svfloat64_t first_block = svld1_f64(pg, vec);\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        svfloat64_t curr_block = svld1_f64(pg, vec + i * block_size);\n        \n        svfloat64_t diff = svabs_f64_z(pg, svsub_f64_z(pg, first_block, curr_block));\n        svbool_t cmp = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n        \n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        double sum = 0.0;\n        \n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t acc = svdup_f64(0.0);\n        \n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1_f64(pg, row + j);\n            svfloat64_t squared = svmul_f64_z(pg, vec, vec);\n            acc = svadd_f64_m(pg, acc, squared);\n            pg = svwhilelt_b64(j + svcntd(), cols);\n        }\n        \n        sum = svaddv_f64(svptrue_b64(), acc);\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        const double* row = matrix + i * cols;\n        \n        size_t j;\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        \n        for (j = 0; j + vl <= cols; j += vl) {\n            svfloat64_t vec = svld1_f64(pg, &row[j]);\n            svfloat64_t squared = svmul_f64_x(pg, vec, vec);\n            sum_vec = svadd_f64_x(pg, sum_vec, squared);\n        }\n        \n        // Reduce vector sum\n        row_sum = svaddv_f64(pg, sum_vec);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            row_sum += row[j] * row[j];\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        const double* row = matrix + i * cols;\n        \n        size_t j;\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        \n        for (j = 0; j + vl <= cols; j += vl) {\n            svfloat64_t vec = svld1_f64(pg, &row[j]);\n            svfloat64_t squared = svmul_f64_x(pg, vec, vec);\n            sum_vec = svadd_f64_x(pg, sum_vec, squared);\n        }\n        \n        // Reduce vector sum\n        row_sum = svaddv_f64(pg, sum_vec);\n        \n        // Handle remaining elements\n        for (; j < cols; j++) {\n            row_sum += row[j] * row[j];\n        }\n        \n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        double sum = 0.0;\n        \n        svbool_t pg = svwhilelt_b64(0, cols);\n        svfloat64_t acc = svdup_f64(0.0);\n        \n        for (size_t j = 0; j < cols; j += svcntd()) {\n            svfloat64_t vec = svld1_f64(pg, row + j);\n            svfloat64_t squared = svmul_f64_z(pg, vec, vec);\n            acc = svadd_f64_m(pg, acc, squared);\n            pg = svwhilelt_b64(j + svcntd(), cols);\n        }\n        \n        sum = svaddv_f64(svptrue_b64(), acc);\n        result[i] = (sqrt(sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    svbool_t pg = svptrue_b64();\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        double row_sum = 0.0;\n        size_t j;\n        \n        for (j = 0; j + vl <= cols; j += vl) {\n            svfloat64_t v_row = svld1_f64(pg, &matrix[i * cols + j]);\n            svfloat64_t v_squared = svmul_f64_z(pg, v_row, v_row);\n            row_sum += svaddv_f64(pg, v_squared);\n        }\n\n        // Handle remaining elements\n        for (; j < cols; j++) {\n            double val = matrix[i * cols + j];\n            row_sum += val * val;\n        }\n\n        result[i] = (sqrt(row_sum) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    svbool_t pg;\n    svuint32_t va, vb, vc;\n    size_t processed = 0;\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        va = svld1_u32(pg, &A[processed]);\n        vb = svld1_u32(pg, &B[processed]);\n        vc = svorr_u32_z(pg, va, vb);\n        svst1_u32(pg, &C[processed], vc);\n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    svuint32_t va, vb, vc;\n\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        va = svld1_u32(pg, &A[i]);\n        vb = svld1_u32(pg, &B[i]);\n        vc = svorr_u32_x(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    svbool_t pg;\n    svuint32_t va, vb, vc;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        va = svld1_u32(pg, &A[i]);\n        vb = svld1_u32(pg, &B[i]);\n        vc = svorr_u32_x(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    svbool_t pg;\n    svuint32_t va, vb, vc;\n    \n    for (size_t i = 0; i < length; i += svcntw()) {\n        pg = svwhilelt_b32(i, length);\n        va = svld1_u32(pg, &A[i]);\n        vb = svld1_u32(pg, &B[i]);\n        vc = svorr_u32_z(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    svbool_t pg;\n    svuint32_t va, vb, vc;\n    size_t i = 0;\n\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        va = svld1_u32(pg, &A[i]);\n        vb = svld1_u32(pg, &B[i]);\n        vc = svorr_u32_z(pg, va, vb);\n        svst1_u32(pg, &C[i], vc);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    do {\n        svint8_t va = svld1_s8(pg, A);\n        svint8_t vb = svld1_s8(pg, B);\n        \n        // Calculate squares\n        svint16_t va_16 = svextb_s16(va);\n        svint16_t vb_16 = svextb_s16(vb);\n        \n        svint32_t va_sq = svmul_s32(svextb_s32(va_16), svextb_s32(va_16));\n        svint32_t vb_sq = svmul_s32(svextb_s32(vb_16), svextb_s32(vb_16));\n        \n        // Calculate products\n        svint32_t vprod = svmul_s32(svextb_s32(va_16), svextb_s32(vb_16));\n        \n        // Accumulate sums\n        sum_squares += svaddv_s32(pg, va_sq);\n        sum_squares += svaddv_s32(pg, vb_sq);\n        sum_products += svaddv_s32(pg, vprod);\n        sum_products += svaddv_s32(pg, vprod);\n        \n        A += svcntb();\n        B += svcntb();\n        pg = svwhilelt_b8(A - (const int8_t*)A, length);\n        \n    } while (svptest_any(svptrue_b8(), pg));\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    do {\n        svint8_t va = svld1_s8(pg, A);\n        svint8_t vb = svld1_s8(pg, B);\n        \n        // Calculate squares\n        svint16_t va_16 = svextb_s16(va);\n        svint16_t vb_16 = svextb_s16(vb);\n        \n        svint32_t va_32 = svextb_s32(va);\n        svint32_t vb_32 = svextb_s32(vb);\n        \n        svint32_t vsqr_a = svmul_s32_z(pg, va_32, va_32);\n        svint32_t vsqr_b = svmul_s32_z(pg, vb_32, vb_32);\n        \n        // Calculate products\n        svint32_t vprod = svmul_s32_z(pg, va_32, vb_32);\n        \n        // Accumulate sums\n        sum_squares += svaddv_s32(pg, vsqr_a);\n        sum_squares += svaddv_s32(pg, vsqr_b);\n        sum_products += svaddv_s32(pg, vprod);\n        sum_products += svaddv_s32(pg, vprod);\n        \n        A += svcntb();\n        B += svcntb();\n        pg = svwhilelt_b8(A - (const int8_t*)A, length);\n        \n    } while (svptest_any(svptrue_b8(), pg));\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    do {\n        svint8_t va = svld1_s8(pg, A);\n        svint8_t vb = svld1_s8(pg, B);\n        \n        // Calculate squares\n        svint16_t va_16 = svextb_s16(va);\n        svint16_t vb_16 = svextb_s16(vb);\n        \n        svint32_t va_32 = svextb_s32(va);\n        svint32_t vb_32 = svextb_s32(vb);\n        \n        svint32_t vsqr_a = svmul_s32_z(pg, va_32, va_32);\n        svint32_t vsqr_b = svmul_s32_z(pg, vb_32, vb_32);\n        \n        // Calculate products\n        svint32_t vprod = svmul_s32_z(pg, va_32, vb_32);\n        \n        // Accumulate sums\n        sum_squares += svaddv_s32(pg, vsqr_a);\n        sum_squares += svaddv_s32(pg, vsqr_b);\n        sum_products += svaddv_s32(pg, vprod);\n        sum_products += svaddv_s32(pg, vprod);\n        \n        A += svcntb();\n        B += svcntb();\n        \n        pg = svwhilelt_b8(A - (const int8_t*)A, length);\n        \n    } while (svptest_any(svptrue_b8(), pg));\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    do {\n        svint8_t va = svld1_s8(pg, A);\n        svint8_t vb = svld1_s8(pg, B);\n        \n        // Calculate squares\n        svint16_t va_16 = svmovlb_s16(va);\n        svint16_t vb_16 = svmovlb_s16(vb);\n        \n        svint32_t va_32 = svmovlb_s32(va_16); \n        svint32_t vb_32 = svmovlb_s32(vb_16);\n        \n        svint32_t vsq_a = svmul_s32_z(pg, va_32, va_32);\n        svint32_t vsq_b = svmul_s32_z(pg, vb_32, vb_32);\n        \n        // Calculate products\n        svint32_t vprod = svmul_s32_z(pg, va_32, vb_32);\n        \n        // Accumulate sums\n        sum_squares += svaddv_s32(pg, vsq_a);\n        sum_squares += svaddv_s32(pg, vsq_b);\n        sum_products += svaddv_s32(pg, vprod);\n        sum_products += svaddv_s32(pg, vprod);\n        \n        A += svcntb();\n        B += svcntb();\n        pg = svwhilelt_b8(A - (const int8_t*)A, length);\n        \n    } while (svptest_any(svptrue_b8(), pg));\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_squares = 0;\n    int64_t sum_products = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, length);\n    \n    do {\n        svint8_t va = svld1_s8(pg, A);\n        svint8_t vb = svld1_s8(pg, B);\n        \n        // Compute squares\n        svint16_t va_16 = svextb_s16_x(pg, va);\n        svint16_t vb_16 = svextb_s16_x(pg, vb);\n        \n        svint32_t va_sq = svmul_s32_x(pg, svextw_s32_x(pg, va_16), \n                                        svextw_s32_x(pg, va_16));\n        svint32_t vb_sq = svmul_s32_x(pg, svextw_s32_x(pg, vb_16),\n                                        svextw_s32_x(pg, vb_16));\n        \n        // Compute products\n        svint32_t vprod = svmul_s32_x(pg, svextw_s32_x(pg, va_16),\n                                        svextw_s32_x(pg, vb_16));\n        \n        // Accumulate\n        sum_squares += svaddv_s32(pg, va_sq);\n        sum_squares += svaddv_s32(pg, vb_sq);\n        sum_products += svaddv_s32(pg, vprod);\n        sum_products += svaddv_s32(pg, vprod);\n        \n        A += svcntb();\n        B += svcntb();\n        pg = svwhilelt_b8(A - (const int8_t*)A, length);\n        \n    } while (svptest_any(svptrue_b8(), pg));\n    \n    return sum_squares - sum_products;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    svbool_t pg;\n    svuint64_t va, vb;\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        va = svld1_u64(pg, &A[i]);\n        vb = svld1_u64(pg, &B[i]);\n        vb = svnot_u64_x(pg, vb);\n        svst1_u64(pg, &C[i], svand_u64_x(pg, va, vb));\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    svbool_t pg;\n    svuint64_t va, vb;\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        va = svld1_u64(pg, &A[i]);\n        vb = svld1_u64(pg, &B[i]);\n        vb = svnot_u64_x(pg, vb);\n        svst1_u64(pg, &C[i], svand_u64_x(pg, va, vb));\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    svbool_t pg;\n    svuint64_t va, vb;\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        va = svld1_u64(pg, &A[i]);\n        vb = svld1_u64(pg, &B[i]);\n        vb = svnot_u64_x(pg, vb);\n        svst1_u64(pg, &C[i], svand_u64_x(pg, va, vb));\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    svbool_t pg;\n    svuint64_t va, vb;\n    size_t i = 0;\n    \n    while (i < length) {\n        pg = svwhilelt_b64(i, length);\n        va = svld1_u64(pg, &A[i]);\n        vb = svld1_u64(pg, &B[i]);\n        vb = svnot_u64_x(pg, vb);\n        svst1_u64(pg, &C[i], svand_u64_x(pg, va, vb));\n        i += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    svbool_t pg;\n    svuint64_t va, vb;\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        pg = svwhilelt_b64(i, length);\n        va = svld1_u64(pg, &A[i]);\n        vb = svld1_u64(pg, &B[i]);\n        vb = svnot_u64_x(pg, vb);\n        svst1_u64(pg, &C[i], svand_u64_x(pg, va, vb));\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg;\n    svint8_t va, vb;\n    svint8_t one = svdup_n_s8(1);\n    svint8_t neg_one = svdup_n_s8(-1);\n    svint8_t zero = svdup_n_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        pg = svwhilelt_b8(i, length);\n        va = svld1_s8(pg, &A[i]);\n        vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_pos = svand_b_z(pg, svcmpgt_s8(pg, va, zero), \n                                        svcmpgt_s8(pg, vb, zero));\n        svbool_t both_neg = svand_b_z(pg, svcmplt_s8(pg, va, zero),\n                                        svcmplt_s8(pg, vb, zero));\n\n        svint8_t result = svsel_s8(both_pos, one,\n                          svsel_s8(both_neg, neg_one, zero));\n\n        svst1_s8(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg;\n    size_t i = 0;\n    \n    while(i < length) {\n        pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n        \n        svbool_t both_pos = svand_b_z(pg, svcmpgt_s8(pg, va, 0), svcmpgt_s8(pg, vb, 0));\n        svbool_t both_neg = svand_b_z(pg, svcmplt_s8(pg, va, 0), svcmplt_s8(pg, vb, 0));\n        \n        svint8_t vc = svdup_s8(0);\n        vc = svsel_s8(both_pos, svdup_s8(1), vc);\n        vc = svsel_s8(both_neg, svdup_s8(-1), vc);\n        \n        svst1_s8(pg, &C[i], vc);\n        \n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg;\n    svint8_t va, vb;\n    svint8_t ones = svdup_s8(1);\n    svint8_t neg_ones = svdup_s8(-1);\n    svint8_t zeros = svdup_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        pg = svwhilelt_b8(i, length);\n        va = svld1_s8(pg, &A[i]);\n        vb = svld1_s8(pg, &B[i]);\n\n        svbool_t both_pos = svand_b_z(pg, svcmpgt_s8(pg, va, zeros), \n                                        svcmpgt_s8(pg, vb, zeros));\n        svbool_t both_neg = svand_b_z(pg, svcmplt_s8(pg, va, zeros),\n                                        svcmplt_s8(pg, vb, zeros));\n\n        svint8_t result = svsel_s8(both_pos, ones,\n                          svsel_s8(both_neg, neg_ones, zeros));\n\n        svst1_s8(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg;\n    size_t i = 0;\n    \n    while (i < length) {\n        pg = svwhilelt_b8(i, length);\n        \n        svint8_t va = svld1_s8(pg, &A[i]);\n        svint8_t vb = svld1_s8(pg, &B[i]);\n        \n        svbool_t both_pos = svand_b_z(pg, svcmpgt_s8(pg, va, 0), svcmpgt_s8(pg, vb, 0));\n        svbool_t both_neg = svand_b_z(pg, svcmplt_s8(pg, va, 0), svcmplt_s8(pg, vb, 0));\n        \n        svint8_t result = svdup_s8(0);\n        result = svsel_s8(both_pos, svdup_s8(1), result);\n        result = svsel_s8(both_neg, svdup_s8(-1), result);\n        \n        svst1_s8(pg, &C[i], result);\n        \n        i += svcntb();\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    svbool_t pg;\n    svint8_t a, b;\n    svint8_t ones = svdup_n_s8(1);\n    svint8_t neg_ones = svdup_n_s8(-1);\n    svint8_t zeros = svdup_n_s8(0);\n\n    for (size_t i = 0; i < length; i += svcntb()) {\n        pg = svwhilelt_b8(i, length);\n        \n        a = svld1_s8(pg, &A[i]);\n        b = svld1_s8(pg, &B[i]);\n\n        svbool_t both_pos = svand_b_z(pg, svcmpgt_s8(pg, a, zeros), \n                                        svcmpgt_s8(pg, b, zeros));\n        svbool_t both_neg = svand_b_z(pg, svcmplt_s8(pg, a, zeros),\n                                        svcmplt_s8(pg, b, zeros));\n\n        svint8_t result = svsel_s8(both_pos, ones,\n                          svsel_s8(both_neg, neg_ones, zeros));\n\n        svst1_s8(pg, &C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    svbool_t pg;\n    svuint16_t va, vb, vc;\n    \n    // Process elements before midpoint using XOR\n    for (; i < midpoint; i += svcntw()) {\n        pg = svwhilelt_b16(i, midpoint);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]); \n        vc = sveor_u16_z(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Process elements after midpoint using AND\n    for (i = midpoint + 1; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]);\n        vc = svand_u16_z(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    svbool_t pg;\n    svuint16_t va, vb, vc;\n    \n    // Process elements before midpoint (XOR)\n    for (; i < midpoint; i += svcntw()) {\n        pg = svwhilelt_b16(i, midpoint);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]); \n        vc = sveor_u16_x(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n\n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Process elements after midpoint (AND)\n    i = midpoint + 1;\n    for (; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]);\n        vc = svand_u16_x(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    svbool_t pg;\n    svuint16_t va, vb, vc;\n    \n    // Process elements before midpoint using XOR\n    for (; i < midpoint; i += svcntw()) {\n        pg = svwhilelt_b16(i, midpoint);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]); \n        vc = sveor_u16_z(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Process elements after midpoint using AND\n    for (i = midpoint + 1; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]);\n        vc = svand_u16_z(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    svbool_t pg;\n    svuint16_t va, vb, vc;\n    \n    // Process elements before midpoint using XOR\n    for (; i < midpoint; i += svcntw()) {\n        pg = svwhilelt_b16(i, midpoint);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]); \n        vc = sveor_u16_x(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Process elements after midpoint using AND\n    for (i = midpoint + 1; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]);\n        vc = svand_u16_x(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i = 0;\n    \n    svbool_t pg;\n    svuint16_t va, vb, vc;\n    \n    // Process elements before midpoint using XOR\n    for (; i < midpoint; i += svcntw()) {\n        pg = svwhilelt_b16(i, midpoint);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]); \n        vc = sveor_u16_z(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n    \n    // Handle midpoint element\n    C[midpoint] = A[midpoint];\n    \n    // Process elements after midpoint using AND\n    for (i = midpoint + 1; i < length; i += svcntw()) {\n        pg = svwhilelt_b16(i, length);\n        va = svld1_u16(pg, &A[i]);\n        vb = svld1_u16(pg, &B[i]);\n        vc = svand_u16_z(pg, va, vb);\n        svst1_u16(pg, &C[i], vc);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, \n                            const bool* cond1, const bool* cond2, float* out,\n                            size_t dim1, size_t dim2, size_t dim3) {\n    \n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        // Load conditions\n        svbool_t c1 = svld1_b32(pg, (svbool_t*)&cond1[i]);\n        svbool_t c2 = svld1_b32(pg, (svbool_t*)&cond2[i]);\n        \n        // Load data vectors\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svfloat32_t b = svld1_f32(pg, &B[i]);\n        svfloat32_t c = svld1_f32(pg, &C[i]);\n        svfloat32_t d = svld1_f32(pg, &D[i]);\n\n        // Create masks for different conditions\n        svbool_t mask_a = svand_b_z(pg, c1, c2);           // cond1 && cond2\n        svbool_t mask_b = svand_b_z(pg, c1, svnot_b_z(pg, c2)); // cond1 && !cond2\n        svbool_t mask_c = svand_b_z(pg, svnot_b_z(pg, c1), c2); // !cond1 && cond2\n        svbool_t mask_d = svand_b_z(pg, svnot_b_z(pg, c1), svnot_b_z(pg, c2)); // !cond1 && !cond2\n\n        // Select values based on conditions\n        svfloat32_t result = svsel_f32(mask_a, a, \n                                     svsel_f32(mask_b, b,\n                                             svsel_f32(mask_c, c, d)));\n\n        // Store result\n        svst1_f32(pg, &out[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, \n                            const bool* cond1, const bool* cond2, float* out,\n                            size_t dim1, size_t dim2, size_t dim3) {\n    \n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        // Load conditions\n        svbool_t pred1 = svld1_b32(pg, cond1 + i);\n        svbool_t pred2 = svld1_b32(pg, cond2 + i);\n        \n        // Load data vectors\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        svfloat32_t c_vec = svld1_f32(pg, C + i);\n        svfloat32_t d_vec = svld1_f32(pg, D + i);\n\n        // Create masks for different conditions\n        svbool_t mask_a = svand_b_z(pg, pred1, pred2);\n        svbool_t mask_b = svand_b_z(pg, pred1, svnot_b_z(pg, pred2));\n        svbool_t mask_c = svand_b_z(pg, svnot_b_z(pg, pred1), pred2);\n        svbool_t mask_d = svand_b_z(pg, svnot_b_z(pg, pred1), svnot_b_z(pg, pred2));\n\n        // Select values based on conditions\n        svfloat32_t result = svsel_f32(mask_a, a_vec, \n                                     svsel_f32(mask_b, b_vec,\n                                             svsel_f32(mask_c, c_vec, d_vec)));\n\n        // Store result\n        svst1_f32(pg, out + i, result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, \n                            const bool* cond1, const bool* cond2, float* out,\n                            size_t dim1, size_t dim2, size_t dim3) {\n    \n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_size) {\n        svbool_t pg = svwhilelt_b32(i, total_size);\n        \n        // Load conditions\n        svbool_t c1 = svld1_b32(pg, (svbool_t*)&cond1[i]);\n        svbool_t c2 = svld1_b32(pg, (svbool_t*)&cond2[i]);\n\n        // Load data vectors\n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svfloat32_t b = svld1_f32(pg, &B[i]);\n        svfloat32_t c = svld1_f32(pg, &C[i]);\n        svfloat32_t d = svld1_f32(pg, &D[i]);\n\n        // Select based on cond1 && cond2\n        svbool_t mask_ab = svand_b_z(pg, c1, c2);\n        svfloat32_t sel_ab = svsel_f32(mask_ab, a, b);\n\n        // Select based on !cond1 && cond2 or !cond1 && !cond2\n        svbool_t mask_cd = svand_b_z(pg, svnot_b_z(pg, c1), c2);\n        svfloat32_t sel_cd = svsel_f32(mask_cd, c, d);\n\n        // Final selection between (A/B) and (C/D) results\n        svfloat32_t result = svsel_f32(c1, sel_ab, sel_cd);\n\n        // Store result\n        svst1_f32(pg, &out[i], result);\n\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        // Load conditions\n        svbool_t c1 = svld1_b8(pg, cond1 + i);\n        svbool_t c2 = svld1_b8(pg, cond2 + i);\n        \n        // Load data vectors\n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n\n        // Create masks for different conditions\n        svbool_t mask_a = svand_b_z(pg, c1, c2);\n        svbool_t mask_b = svand_b_z(pg, c1, svnot_b_z(pg, c2));\n        svbool_t mask_c = svand_b_z(pg, svnot_b_z(pg, c1), c2);\n        svbool_t mask_d = svand_b_z(pg, svnot_b_z(pg, c1), svnot_b_z(pg, c2));\n\n        // Select values based on conditions\n        svfloat32_t result = svsel_f32(mask_a, a, \n                                     svsel_f32(mask_b, b,\n                                             svsel_f32(mask_c, c, d)));\n\n        // Store result\n        svst1_f32(pg, out + i, result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svbool_t c1 = svld1_b32(pg, cond1 + i);\n        svbool_t c2 = svld1_b32(pg, cond2 + i);\n        \n        svfloat32_t a = svld1_f32(pg, A + i);\n        svfloat32_t b = svld1_f32(pg, B + i);\n        svfloat32_t c = svld1_f32(pg, C + i);\n        svfloat32_t d = svld1_f32(pg, D + i);\n        \n        svbool_t c1_and_c2 = svand_b_z(pg, c1, c2);\n        svbool_t c1_and_not_c2 = svand_b_z(pg, c1, svnot_b_z(pg, c2));\n        svbool_t not_c1_and_c2 = svand_b_z(pg, svnot_b_z(pg, c1), c2);\n        svbool_t not_c1_and_not_c2 = svand_b_z(pg, svnot_b_z(pg, c1), svnot_b_z(pg, c2));\n        \n        svfloat32_t result = svsel_f32(c1_and_c2, a,\n                             svsel_f32(c1_and_not_c2, b,\n                             svsel_f32(not_c1_and_c2, c, d)));\n        \n        svst1_f32(pg, out + i, result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, &A[i]);\n        \n        // Count bits using parallel population count\n        svuint32_t cnt = svcnt_u32_x(pg, input);\n        \n        // Convert 32-bit counts to 8-bit\n        svuint8_t result = svqxtunt_u32(svuint8_t_z(pg), cnt);\n        \n        // Store results\n        svst1b_u8(pg, &out[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, &A[i]);\n        \n        // Count bits using population count intrinsic\n        svuint32_t cnt = svcnt_u32_x(pg, input);\n        \n        // Convert 32-bit counts to 8-bit\n        svuint8_t cnt8 = svqxtunt_u32(cnt);\n        \n        // Store results\n        svst1b_u8(pg, &out[i], cnt8);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svptrue_b32();\n\n    while (i < total_elements) {\n        svbool_t pred = svwhilelt_b32(i, total_elements);\n        svuint32_t input = svld1_u32(pred, &A[i]);\n        \n        // Count bits in each 32-bit element\n        svuint32_t count = svcnt_u32_x(pred, input);\n        \n        // Convert 32-bit counts to 8-bit\n        svuint8_t count8 = svqxtnb_u16(svqxtnb_u32(count));\n        \n        // Store results\n        svst1b_u8(pred, &out[i], count8);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, &A[i]);\n        \n        // Count bits using parallel population count\n        svuint32_t cnt = svcnt_u32_x(pg, input);\n        \n        // Convert 32-bit counts to 8-bit\n        svuint8_t result = svqxtunt_u32(svqxtnb_u32(cnt));\n        \n        // Store results\n        svst1b_u8(pg, &out[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, total_size);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, &A[i]);\n        \n        // Count bits using parallel population count\n        svuint32_t cnt = svcnt_u32_x(pg, input);\n        \n        // Convert 32-bit counts to 8-bit\n        svuint8_t result = svqxtunt_u32(cnt);\n        \n        // Store results\n        svst1b_u8(pg, &out[i], result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, total_size);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        \n        // Create vector of 3s\n        svint32_t vec_three = svdup_n_s32(3);\n        \n        // Calculate remainder when divided by 3\n        svint32_t remainder = svrem_s32_z(pg, vec_a, vec_three);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        svbool_t div_by_3 = svcmpeq_s32(pg, remainder, svdup_n_s32(0));\n        \n        // Calculate absolute values\n        svint32_t abs_values = svabs_s32_z(pg, vec_a);\n        \n        // Select between original and absolute values based on mask\n        svint32_t result = svsel_s32(div_by_3, abs_values, vec_a);\n        \n        // Store result\n        svst1_s32(pg, &B[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        \n        // Check if divisible by 3\n        svint32_t vec_three = svdup_n_s32(3);\n        svint32_t vec_rem = svdiv_s32_z(pg, vec_a, vec_three);\n        vec_rem = svmul_s32_z(pg, vec_rem, vec_three);\n        svbool_t div_by_3 = svcmpeq_s32(pg, vec_rem, vec_a);\n        \n        // Get absolute values\n        svint32_t vec_abs = svabs_s32_z(pg, vec_a);\n        \n        // Select between original and absolute based on condition\n        svint32_t vec_result = svsel_s32(div_by_3, vec_abs, vec_a);\n        \n        // Store result\n        svst1_s32(pg, &B[i], vec_result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        \n        // Check if divisible by 3\n        svint32_t vec_div3 = svdiv_s32_z(pg, vec_a, svdup_s32(3));\n        svint32_t vec_mul3 = svmul_s32_z(pg, vec_div3, svdup_s32(3));\n        svbool_t div3_mask = svcmpeq_s32(pg, vec_a, vec_mul3);\n        \n        // Get absolute values\n        svint32_t vec_abs = svabs_s32_z(pg, vec_a);\n        \n        // Select between original and absolute based on divisibility mask\n        svint32_t vec_result = svsel_s32(div3_mask, vec_abs, vec_a);\n        \n        svst1_s32(pg, &B[i], vec_result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        \n        // Load vector of elements from A\n        svint32_t a = svld1_s32(pg, &A[i]);\n        \n        // Create vector of 3s\n        svint32_t three = svdup_n_s32(3);\n        \n        // Calculate remainder when divided by 3\n        svint32_t rem = svrem_s32_z(pg, a, three);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        svbool_t div_by_3 = svcmpeq_s32(pg, rem, svdup_n_s32(0));\n        \n        // Calculate absolute values\n        svint32_t abs_a = svabs_s32_z(pg, a);\n        \n        // Select between original and absolute values based on divisibility by 3\n        svint32_t result = svsel_s32(div_by_3, abs_a, a);\n        \n        // Store result\n        svst1_s32(pg, &B[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svint32_t vec_a = svld1_s32(pg, &A[i]);\n        \n        // Create vector of 3s\n        svint32_t vec_three = svdup_n_s32(3);\n        \n        // Calculate remainder when divided by 3\n        svint32_t remainder = svrem_s32_z(pg, vec_a, vec_three);\n        \n        // Create mask for elements divisible by 3 (remainder == 0)\n        svbool_t div_by_3 = svcmpeq(pg, remainder, 0);\n        \n        // Calculate absolute values\n        svint32_t abs_vec = svabs_s32_z(pg, vec_a);\n        \n        // Select between original and absolute values based on divisibility by 3\n        svint32_t result = svsel_s32(div_by_3, abs_vec, vec_a);\n        \n        // Store result\n        svst1_s32(pg, &B[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec_src = svld1_u32(pg, src);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        svuint32_t low_bits = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Perform rotation for elements where condition is true\n        svuint32_t rotated = svorr_n_u32_z(pg,\n                                          svlsr_n_u32_z(pg, vec_src, rotate_bits),\n                                          svlsl_n_u32_z(pg, vec_src, 32 - rotate_bits));\n                                          \n        // Perform bitwise NOT for elements where condition is false\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n        \n        // Select between rotated and negated based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        svst1_u32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(pg, pg)) {\n        svuint32_t vec_src = svld1_u32(pg, src);\n        \n        // Extract low 4 bits and check if all are 1\n        svuint32_t low_bits = svand_n_u32_x(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Perform rotation for elements where condition is true\n        svuint32_t rotated = svlsr_n_u32_x(pg, vec_src, rotate_bits);\n        svuint32_t shifted = svlsl_n_u32_x(pg, vec_src, 32 - rotate_bits);\n        svuint32_t rot_result = svorr_u32_x(pg, rotated, shifted);\n        \n        // Perform bitwise NOT for elements where condition is false\n        svuint32_t not_result = svnot_u32_x(pg, vec_src);\n        \n        // Select between rotated and NOT based on condition\n        svuint32_t result = svsel_u32(cond, rot_result, not_result);\n        \n        // Store result\n        svst1_u32(pg, dst, result);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        svuint32_t low_bits = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Perform rotation for elements where condition is true\n        svuint32_t rotated = svlsr_n_u32_z(pg, vec_src, rotate_bits);\n        svuint32_t shifted = svlsl_n_u32_z(pg, vec_src, 32 - rotate_bits);\n        svuint32_t rot_result = svorr_u32_z(pg, rotated, shifted);\n        \n        // Perform bitwise NOT for elements where condition is false\n        svuint32_t not_result = svnot_u32_z(pg, vec_src);\n        \n        // Select between rotated and NOT based on condition\n        svuint32_t result = svsel_u32(cond, rot_result, not_result);\n        \n        // Store result\n        svst1_u32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        svuint32_t low_bits = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Perform rotation if condition is true\n        svuint32_t rotated = svorr_n_u32_z(pg,\n                                          svlsr_n_u32_z(pg, vec_src, rotate_bits),\n                                          svlsl_n_u32_z(pg, vec_src, 32 - rotate_bits));\n                                          \n        // Perform bitwise NOT if condition is false\n        svuint32_t negated = svnot_u32_z(pg, vec_src);\n        \n        // Select between rotated and negated based on condition\n        svuint32_t result = svsel_u32(cond, rotated, negated);\n        \n        // Store result\n        svst1_u32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        \n        svuint32_t vec_src = svld1_u32(pg, &src[i]);\n        \n        // Check if low 4 bits are all 1 (0xF)\n        svuint32_t low_bits = svand_n_u32_z(pg, vec_src, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low_bits, 0xF);\n        \n        // Perform rotation if condition is true\n        svuint32_t rotated = svlsr_n_u32_z(pg, vec_src, rotate_bits);\n        svuint32_t shifted = svadd_n_u32_z(pg, svlsl_n_u32_z(pg, vec_src, 32 - rotate_bits), 0);\n        svuint32_t rot_result = svorr_u32_z(pg, rotated, shifted);\n        \n        // Perform bitwise NOT if condition is false\n        svuint32_t not_result = svnot_u32_z(pg, vec_src);\n        \n        // Select between rotated and NOT based on condition\n        svuint32_t result = svsel_u32(cond, rot_result, not_result);\n        \n        // Store result\n        svst1_u32(pg, &dst[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    float abs_epsilon = fabsf(epsilon);\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        svfloat32_t vb = svld1_f32(pg, &B[processed]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, va, vb);\n        \n        svbool_t gt_mask = svcmpgt_f32(pg, diff, svdup_f32(abs_epsilon));\n        svbool_t lt_mask = svcmplt_f32(pg, diff, svdup_f32(-abs_epsilon));\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(gt_mask, svdup_n_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg, &out[processed], result);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    float abs_epsilon = fabsf(epsilon);\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        svfloat32_t vb = svld1_f32(pg, &B[processed]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, va, vb);\n        \n        svbool_t gt_mask = svcmpgt_f32(pg, diff, svdup_f32(abs_epsilon));\n        svbool_t lt_mask = svcmplt_f32(pg, diff, svdup_f32(-abs_epsilon));\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(gt_mask, svdup_n_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg, &out[processed], result);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    float abs_epsilon = fabsf(epsilon);\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        svfloat32_t vb = svld1_f32(pg, &B[processed]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, va, vb);\n        \n        svbool_t gt_mask = svcmpgt_f32(pg, diff, svdup_f32(abs_epsilon));\n        svbool_t lt_mask = svcmplt_f32(pg, diff, svdup_f32(-abs_epsilon));\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(gt_mask, svdup_n_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg, &out[processed], result);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    float abs_epsilon = fabsf(epsilon);\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        svfloat32_t vb = svld1_f32(pg, &B[processed]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, va, vb);\n        \n        svbool_t gt_mask = svcmpgt_f32(pg, diff, svdup_f32(abs_epsilon));\n        svbool_t lt_mask = svcmplt_f32(pg, diff, svdup_f32(-abs_epsilon));\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(gt_mask, svdup_n_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg, &out[processed], result);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    svbool_t pg;\n    size_t processed = 0;\n    float abs_epsilon = fabsf(epsilon);\n\n    while (processed < length) {\n        pg = svwhilelt_b32(processed, length);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        svfloat32_t vb = svld1_f32(pg, &B[processed]);\n        \n        svfloat32_t diff = svsub_f32_z(pg, va, vb);\n        \n        svbool_t gt_mask = svcmpgt_f32(pg, diff, svdup_f32(abs_epsilon));\n        svbool_t lt_mask = svcmplt_f32(pg, diff, svdup_f32(-abs_epsilon));\n        \n        svint8_t result = svdup_n_s8(0);\n        result = svsel_s8(gt_mask, svdup_n_s8(1), result);\n        result = svsel_s8(lt_mask, svdup_n_s8(-1), result);\n        \n        svst1_s8(pg, &out[processed], result);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < size) {\n        pg = svwhilelt_b32(processed, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        \n        svint32_t vb = svcvt_s32_f32_z(pg, va);\n        \n        svst1_s32(pg, &B[processed], vb);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < size) {\n        pg = svwhilelt_b32(processed, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        \n        // Convert float to int with saturation\n        svint32_t vresult = svcvt_s32_f32_z(pg, va);\n        \n        // Store result\n        svst1_s32(pg, &B[processed], vresult);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < size) {\n        pg = svwhilelt_b32(processed, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        \n        // Convert float to int with saturation\n        svint32_t vresult = svcvt_s32_f32_z(pg, va);\n        \n        // Store result\n        svst1_s32(pg, &B[processed], vresult);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < size) {\n        pg = svwhilelt_b32(processed, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        \n        svint32_t vb = svcvt_s32_f32_z(pg, va);\n        \n        svst1_s32(pg, &B[processed], vb);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < size) {\n        pg = svwhilelt_b32(processed, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[processed]);\n        \n        // Convert float to int with saturation\n        svint32_t vresult = svcvt_s32_f32_z(pg, va);\n        \n        svst1_s32(pg, &B[processed], vresult);\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    do {\n        svint32_t vec_a = svld1_s32(pg, A);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t scaled = svmul_n_f32_x(pg, vec_f, (float)scale);\n        svst1_f32(pg, B, scaled);\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    do {\n        svint32_t vec_a = svld1_s32(pg, A);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t scaled = svmul_n_f32_x(pg, vec_f, (float)scale);\n        svst1_f32(pg, B, scaled);\n        \n        A += svcntw();\n        B += svcntw();\n        size -= svcntw();\n        pg = svwhilelt_b32(0, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    do {\n        svint32_t vec_a = svld1_s32(pg, A);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t vec_scaled = svmul_n_f32_x(pg, vec_f, (float)scale);\n        svst1_f32(pg, B, vec_scaled);\n        \n        A += svcntw();\n        B += svcntw();\n        size -= svcntw();\n        pg = svwhilelt_b32(0, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    do {\n        svint32_t vec_a = svld1_s32(pg, A);\n        svfloat32_t vec_f = svcvt_f32_s32_x(pg, vec_a);\n        svfloat32_t scaled = svmul_n_f32_x(pg, vec_f, (float)scale);\n        svst1_f32(pg, B, scaled);\n        \n        A += svcntw();\n        B += svcntw();\n        size -= svcntw();\n        pg = svwhilelt_b32(0, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    do {\n        svint32_t va = svld1_s32(pg, A);\n        svfloat32_t vf = svcvt_f32_s32_x(pg, va);\n        svfloat32_t vs = svmul_n_f32_x(pg, vf, (float)scale);\n        svst1_f32(pg, B, vs);\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(A - (const int32_t*)A, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    svbool_t pg;\n    size_t i = 0;\n    \n    while(i < size) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vround = svcvt_s32_f32_z(pg, svrintn_f32_z(pg, vdiv));\n        \n        svst1_s32(pg, &C[i], vround);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    svbool_t pg;\n    svfloat32_t va, vb, vdiv;\n    svint32_t vresult;\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        pg = svwhilelt_b32(i, size);\n        va = svld1_f32(pg, &A[i]);\n        vb = svld1_f32(pg, &B[i]);\n        \n        vdiv = svdiv_f32_z(pg, va, vb);\n        vresult = svcvtnt_s32_f32_z(pg, vdiv);\n        \n        svst1_s32(pg, &C[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    svbool_t pg;\n    size_t i = 0;\n    \n    while (i < size) {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vround = svcvt_s32_f32_z(pg, svrintn_f32_z(pg, vdiv));\n        \n        svst1_s32(pg, &C[i], vround);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    svbool_t pg;\n    size_t i = 0;\n    \n    do {\n        pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        \n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vround = svcvt_s32_f32_z(pg, svrintn_f32_z(pg, vdiv));\n        \n        svst1_s32(pg, &C[i], vround);\n        \n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svint32_t vround = svcvt_s32_f32_z(pg, svrintn_f32_z(pg, vdiv));\n        svst1_s32(pg, &C[i], vround);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat64_t vec_a;\n    svfloat32_t vec_b;\n    float max_float = FLT_MAX;\n    float min_float = -FLT_MAX;\n    svfloat64_t max_double = svdup_f64(max_float);\n    svfloat64_t min_double = svdup_f64(min_float);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        vec_a = svld1_f64(pg, &A[i]);\n        \n        // Clamp values between -FLT_MAX and FLT_MAX\n        vec_a = svmin_f64_z(pg, vec_a, max_double);\n        vec_a = svmax_f64_z(pg, vec_a, min_double);\n        \n        // Convert double to float\n        vec_b = svcvt_f32_f64_z(pg, vec_a);\n        \n        // Store result\n        svst1_f32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat64_t vec_a;\n    svfloat32_t vec_b;\n    float max_float = FLT_MAX;\n    float min_float = -FLT_MAX;\n    svfloat64_t max_double = svdup_f64(max_float);\n    svfloat64_t min_double = svdup_f64(min_float);\n    \n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        vec_a = svld1_f64(pg, &A[i]);\n        \n        // Clamp values between -FLT_MAX and FLT_MAX\n        vec_a = svmin_f64_z(pg, vec_a, max_double);\n        vec_a = svmax_f64_z(pg, vec_a, min_double);\n        \n        // Convert double to float\n        vec_b = svcvt_f32_f64_z(pg, vec_a);\n        \n        // Store result\n        svst1_f32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat64_t vec_a;\n    svfloat32_t vec_b;\n    float max_float = FLT_MAX;\n    float min_float = -FLT_MAX;\n    svfloat64_t max_double = svdup_f64(max_float);\n    svfloat64_t min_double = svdup_f64(min_float);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        vec_a = svld1_f64(pg, &A[i]);\n        \n        // Clamp values between -FLT_MAX and FLT_MAX\n        vec_a = svmin_f64_z(pg, vec_a, max_double);\n        vec_a = svmax_f64_z(pg, vec_a, min_double);\n        \n        // Convert double to float\n        vec_b = svcvt_f32_f64_z(pg, vec_a);\n        \n        // Store result\n        svst1_f32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat64_t a;\n    svfloat32_t b;\n    float fmax = FLT_MAX;\n    float fmin = -FLT_MAX;\n    svfloat64_t max_d = svdup_f64(fmax);\n    svfloat64_t min_d = svdup_f64(fmin);\n\n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        a = svld1_f64(pg, &A[i]);\n        \n        // Clamp values between -FLT_MAX and FLT_MAX\n        a = svmin_f64_z(pg, a, max_d);\n        a = svmax_f64_z(pg, a, min_d);\n        \n        // Convert double to float\n        b = svcvt_f32_f64_z(pg, a);\n        \n        // Store result\n        svst1_f32(pg, &B[i], b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    svbool_t pg;\n    svfloat64_t vec_a;\n    svfloat32_t vec_b;\n    float max_float = FLT_MAX;\n    float min_float = -FLT_MAX;\n    svfloat64_t max_double = svdup_f64(max_float);\n    svfloat64_t min_double = svdup_f64(min_float);\n    \n    for (size_t i = 0; i < size; i += svcntd()) {\n        pg = svwhilelt_b64(i, size);\n        vec_a = svld1_f64(pg, &A[i]);\n        \n        // Clamp values between -FLT_MAX and FLT_MAX\n        vec_a = svmin_f64_z(pg, vec_a, max_double);\n        vec_a = svmax_f64_z(pg, vec_a, min_double);\n        \n        // Convert double to float\n        vec_b = svcvt_f32_f64_z(pg, vec_a);\n        \n        // Store result\n        svst1_f32(pg, &B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b16(0, size);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, A);\n        svint32_t vec_b = svextb_s32_x(pg, vec_a);\n        svst1_s32(pg, B, vec_b);\n        \n        size_t vl = svcntw();\n        A += vl;\n        B += vl;\n        pg = svwhilelt_b16(0, size -= vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b16(0, size);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, A);\n        svint32_t vec_b = svextw_s32_x(pg, vec_a);\n        svst1_s32(pg, B, vec_b);\n        \n        size_t vl = svcntw();\n        A += vl;\n        B += vl;\n        pg = svwhilelt_b16(vl, size);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b16(0, size);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, A);\n        svint32_t vec_b = svextb_s32_x(pg, vec_a);\n        svst1_s32(pg, B, vec_b);\n        \n        size_t vl = svcntw();\n        A += vl;\n        B += vl;\n        pg = svwhilelt_b16(0, size -= vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b16(0, size);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, A);\n        svint32_t vec_b = svextw_s32_x(pg, vec_a);\n        svst1_s32(pg, B, vec_b);\n        \n        size_t vl = svcntw();\n        A += vl;\n        B += vl;\n        pg = svwhilelt_b16(0, size -= vl);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    svbool_t pg = svwhilelt_b16(0, size);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        svint16_t vec_a = svld1_s16(pg, A);\n        svint32_t vec_b = svextw_s32_x(pg, vec_a);\n        svst1_s32(pg, B, vec_b);\n        \n        size_t vl = svcntw();\n        A += vl;\n        B += vl;\n        pg = svwhilelt_b16(0, size -= vl);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    \n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, A);\n        svint32_t ctrl = svld1_s32(pg, control);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg, ctrl, 0);\n        \n        svfloat32_t normalized = svdiv_f32_z(normalize_mask,\n            svsub_f32_z(normalize_mask, a, min_val),\n            range);\n            \n        normalized = svmin_f32_z(normalize_mask, \n            svmax_f32_z(normalize_mask, normalized, 0.0f),\n            1.0f);\n            \n        svfloat32_t result = svsel_f32(normalize_mask, normalized, a);\n        \n        svst1_f32(pg, B, result);\n        \n        A += svcntw();\n        B += svcntw();\n        control += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    \n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, A);\n        svint32_t ctrl = svld1_s32(pg, control);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg, ctrl, 0);\n        \n        svfloat32_t normalized = svdiv_f32_z(normalize_mask, \n                                    svsub_f32_z(normalize_mask, a, min_val),\n                                    range);\n                                    \n        normalized = svminmax_f32_z(normalize_mask, normalized, 0.0f, 1.0f);\n        \n        svfloat32_t result = svsel_f32(normalize_mask, normalized, a);\n        \n        svst1_f32(pg, B, result);\n        \n        A += svcntw();\n        B += svcntw();\n        control += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    \n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, A);\n        svint32_t ctrl = svld1_s32(pg, control);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg, ctrl, 0);\n        \n        svfloat32_t normalized = svdiv_f32_z(normalize_mask,\n                                    svsub_f32_z(normalize_mask, a, min_val),\n                                    range);\n                                    \n        normalized = svmin_f32_z(normalize_mask, \n                        svmax_f32_z(normalize_mask, normalized, 0.0f),\n                        1.0f);\n                        \n        svfloat32_t result = svsel_f32(normalize_mask, normalized, a);\n        \n        svst1_f32(pg, B, result);\n        \n        A += svcntw();\n        B += svcntw();\n        control += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    \n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t a = svld1_f32(pg, A);\n        svint32_t ctrl = svld1_s32(pg, control);\n        \n        svbool_t normalize_mask = svcmpgt_s32(pg, ctrl, 0);\n        \n        svfloat32_t normalized = svdiv_f32_z(normalize_mask,\n                                            svsub_f32_z(normalize_mask, a, min_val),\n                                            range);\n                                            \n        normalized = svminmax_f32(normalize_mask, normalized, 0.0f, 1.0f);\n        \n        svfloat32_t result = svsel_f32(normalize_mask, normalized, a);\n        \n        svst1_f32(pg, B, result);\n        \n        A += svcntw();\n        B += svcntw();\n        control += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        svfloat32_t a = svld1_f32(pg, &A[i]);\n        svint32_t ctrl = svld1_s32(pg, &control[i]);\n        \n        svbool_t normalize = svcmpgt_s32(pg, ctrl, 0);\n        \n        svfloat32_t normalized = svdiv_f32_z(normalize, \n                                    svsub_f32_z(normalize, a, min_val),\n                                    range);\n        \n        normalized = svmin_f32_z(normalize, svmax_f32_z(normalize, normalized, 0.0f), 1.0f);\n        \n        svfloat32_t result = svsel_f32(normalize, normalized, a);\n        \n        svst1_f32(pg, &B[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, A);\n        \n        // Extract high 16 bits by right shifting 16 positions\n        svuint32_t high_bits = svlsr_n_u32_x(pg, input, 16);\n        \n        // Convert uint32 to float\n        svfloat32_t float_vals = svcvt_f32_u32_x(pg, high_bits);\n        \n        // Calculate square root\n        svfloat32_t result = svsqrt_f32_x(pg, float_vals);\n        \n        // Store result\n        svst1_f32(pg, B, result);\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        \n        // Extract high 16 bits by right shifting 16 positions\n        svuint32_t high_bits = svlsr_n_u32_x(pg, va, 16);\n        \n        // Convert uint32 to float\n        svfloat32_t vf = svcvt_f32_u32_x(pg, high_bits);\n        \n        // Calculate square root\n        svfloat32_t result = svsqrt_f32_x(pg, vf);\n        \n        // Store result\n        svst1_f32(pg, &B[i], result);\n        \n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        // Load uint32 values\n        svuint32_t va = svld1_u32(pg, A + i);\n        \n        // Shift right by 16 to get high 16 bits\n        svuint32_t shifted = svlsr_n_u32_x(pg, va, 16);\n        \n        // Convert uint32 to float\n        svfloat32_t vf = svcvt_f32_u32_x(pg, shifted);\n        \n        // Calculate square root\n        svfloat32_t result = svsqrt_f32_x(pg, vf);\n        \n        // Store result\n        svst1_f32(pg, B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    for (size_t i = 0; i < size; i += svcntw()) {\n        svuint32_t va = svld1_u32(pg, &A[i]);\n        \n        // Extract high 16 bits by right shifting 16 positions\n        svuint32_t high_bits = svlsr_n_u32_x(pg, va, 16);\n        \n        // Convert uint32 to float\n        svfloat32_t vf = svcvt_f32_u32_x(pg, high_bits);\n        \n        // Calculate square root\n        svfloat32_t result = svsqrt_f32_x(pg, vf);\n        \n        // Store result\n        svst1_f32(pg, &B[i], result);\n        \n        pg = svwhilelt_b32(i + svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t va = svld1_u32(pg, A);\n        \n        // Extract high 16 bits by right shifting 16 positions\n        svuint32_t high_bits = svlsr_n_u32_x(pg, va, 16);\n        \n        // Convert uint32 to float\n        svfloat32_t vf = svcvt_f32_u32_x(pg, high_bits);\n        \n        // Calculate square root\n        svfloat32_t result = svsqrt_f32_x(pg, vf);\n        \n        // Store result\n        svst1_f32(pg, B, result);\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t va = svld1_u32(pg, A);\n        svfloat32_t vb = svreinterpret_f32_u32(va);\n        svst1_f32(pg, B, vb);\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec_a = svld1_u32(pg, A);\n        svst1_f32(pg, B, svreinterpret_f32_u32(vec_a));\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg;\n    size_t processed = 0;\n    \n    while (processed < size) {\n        pg = svwhilelt_b32(processed, size);\n        \n        svuint32_t vec_a = svld1_u32(pg, &A[processed]);\n        svst1_f32(pg, &B[processed], svreinterpret_f32_u32(vec_a));\n        \n        processed += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec_a = svld1_u32(pg, A);\n        svst1_f32(pg, B, svreinterpret_f32_u32(vec_a));\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(A - (const uint32_t*)A, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    svbool_t pg = svwhilelt_b32(0, size);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec_a = svld1_u32(pg, A);\n        svst1_f32(pg, B, svreinterpret_f32_u32(vec_a));\n        \n        A += svcntw();\n        B += svcntw();\n        pg = svwhilelt_b32(svcntw(), size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    size_t i = 1;\n    svbool_t pg;\n    \n    while((pg = svwhilelt_b32(i, size))) {\n        svint32_t va = svld1_s32(pg, &A[i]);\n        svint32_t vprev = svld1_s32(pg, &A[i-1]);\n        svbool_t vcond = svld1rq_b32(pg, &cond[i]);\n        \n        svfloat32_t vdiff = svcvt_f32_s32_x(pg, svsub_s32_x(pg, va, vprev));\n        svfloat32_t vzero = svdup_f32(0.0f);\n        \n        svfloat32_t vresult = svsel_f32(vcond, vdiff, vzero);\n        \n        svst1_f32(pg, &diff[i], vresult);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    size_t i = 1;\n    svbool_t pg;\n    \n    while((pg = svwhilelt_b32(i, size))) {\n        svint32_t va = svld1_s32(pg, &A[i]);\n        svint32_t vprev = svld1_s32(pg, &A[i-1]);\n        svbool_t vcond = svld1_b32(pg, &cond[i]);\n        \n        // Calculate difference when condition is true\n        svfloat32_t vdiff = svcvt_f32_s32(pg, svsub_s32_z(vcond, va, vprev));\n        \n        // Set to 0 when condition is false\n        vdiff = svsel_f32(vcond, vdiff, svdup_f32(0.0f));\n        \n        svst1_f32(pg, &diff[i], vdiff);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    size_t i = 1;\n    svbool_t pg;\n    \n    while((pg = svwhilelt_b32(i, size))) {\n        svint32_t curr = svld1_s32(pg, &A[i]);\n        svint32_t prev = svld1_s32(pg, &A[i-1]);\n        svbool_t cond_mask = svld1rq_b32(pg, &cond[i]);\n        \n        svfloat32_t diff_vec = svcvt_f32_s32_x(pg, svsub_s32_x(pg, curr, prev));\n        svfloat32_t zero = svdup_f32(0.0f);\n        \n        svfloat32_t result = svsel_f32(cond_mask, diff_vec, zero);\n        \n        svst1_f32(pg, &diff[i], result);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    size_t i = 1;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        \n        // Load vectors\n        svint32_t curr = svld1_s32(pg, &A[i]);\n        svint32_t prev = svld1_s32(pg, &A[i-1]);\n        svbool_t mask = svld1rq_b32(pg, &cond[i]);\n        \n        // Calculate difference when condition is true\n        svint32_t diff_i = svsub_s32_z(mask, curr, prev);\n        \n        // Convert to float\n        svfloat32_t fdiff = svcvt_f32_s32_z(mask, diff_i);\n        \n        // Store result\n        svst1_f32(pg, &diff[i], fdiff);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    \n    size_t i = 1;\n    svbool_t pg;\n    \n    while((pg = svwhilelt_b32(i, size))) {\n        // Load vectors\n        svint32_t va = svld1_s32(pg, &A[i]);\n        svint32_t va_prev = svld1_s32(pg, &A[i-1]);\n        svbool_t vcond = svld1_b32(pg, &cond[i]);\n        \n        // Calculate difference when condition is true\n        svint32_t vdiff = svsub_s32_z(vcond, va, va_prev);\n        \n        // Convert to float\n        svfloat32_t vdiff_f = svcvt_f32_s32_z(vcond, vdiff);\n        \n        // Store result\n        svst1_f32(pg, &diff[i], vdiff_f);\n        \n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec32 = svld1_u32(pg, src);\n        svuint64_t vec64 = svuxtw_u64_x(pg, vec32);\n        vec64 = svorr_n_u64_x(pg, vec64, 0xFFFFFFFF00000000ULL);\n        svst1_u64(pg, dst, vec64);\n        \n        src += svcntw();\n        dst += svcntd();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec32 = svld1_u32(pg, src);\n        svuint64_t vec64 = svreinterpret_u64_u32(svzip1(vec32, svdup_n_u32(0xFFFFFFFF)));\n        svst1_u64(pg, dst, vec64);\n        \n        src += svcntw();\n        dst += svcntw();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec32 = svld1_u32(pg, src);\n        svuint64_t vec64 = svuxtw_u64_x(pg, vec32);\n        vec64 = svorr_u64_x(pg, vec64, svdup_n_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, dst, vec64);\n        \n        src += svcntw();\n        dst += svcntd();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec_src = svld1_u32(pg, src);\n        svuint64_t vec_dst = svlsl_n_u64_x(pg, svzext_u64(vec_src), 32);\n        vec_dst = svorr_n_u64_x(pg, vec_dst, 0xFFFFFFFF00000000ULL);\n        svst1_u64(pg, dst, vec_dst);\n        \n        src += svcntw();\n        dst += svcntd();\n        pg = svwhilelt_b32(svcntw(), length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    svbool_t pg = svwhilelt_b32(0, length);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t vec32 = svld1_u32(pg, src);\n        svuint64_t vec64 = svreinterpret_u64_u32(svext_u32(vec32, vec32, 0));\n        vec64 = svorr_z(pg, vec64, svdup_n_u64(0xFFFFFFFF00000000));\n        svst1_u64(pg, dst, vec64);\n        \n        src += svcntw();\n        dst += svcntd();\n        pg = svwhilelt_b32(src - (const uint32_t*)src, length);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, length);\n        \n        // Load indices\n        svint16_t idx = svld1_s16(p, &index[i]);\n        \n        // Convert indices to 64-bit for gather load\n        svint64_t idx64 = svcvt_s64_s16_x(p, idx);\n        \n        // Gather load from vec using indices\n        svfloat64_t elements = svld1_gather_s64index_f64(p, vec, idx64);\n        \n        // Add gathered elements to running sum\n        sum = svadd_f64_z(p, sum, elements);\n        \n        pg = p;\n    }\n    \n    // Horizontal sum of vector\n    return svaddv_f64(pg, sum);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, length);\n        svint16_t idx = svld1_s16(p, &index[i]);\n        svint64_t idx_ext = svextb_s64_x(p, svext_s64_x(p, svcvt_s64_s16_x(p, idx)));\n        svfloat64_t elements = svld1_gather_s64index_f64(p, vec, idx_ext);\n        sum = svfadd_x(p, sum, elements);\n    }\n    \n    return svaddv_f64(pg, sum);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t pred = svwhilelt_b64(i, length);\n        svint16_t idx = svld1_s16(pred, &index[i]);\n        svint64_t idx_ext = svextb_s64_x(pred, svcvt_s64_s16_x(pred, idx));\n        svfloat64_t gathered = svld1_gather_s64index_f64(pred, vec, idx_ext);\n        sum = svadd_f64_z(pred, sum, gathered);\n    }\n    \n    return svaddv_f64(pg, sum);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svbool_t pg = svwhilelt_b64(0, length);\n    svfloat64_t sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < length; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, length);\n        \n        // Load indices\n        svint16_t idx = svld1_s16(p, &index[i]);\n        \n        // Convert indices to 64-bit for gather load\n        svint64_t idx_64 = svextb_s64_x(p, svcvt_s64_s16_x(p, idx));\n        \n        // Gather load from vec using indices\n        svfloat64_t elements = svld1_gather_s64index_f64(p, vec, idx_64);\n        \n        // Add gathered elements to running sum\n        sum = svadd_f64_z(p, sum, elements);\n        \n        pg = p;\n    }\n    \n    // Horizontal sum of vector\n    return svaddv_f64(pg, sum);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    svbool_t pg;\n    size_t i = 0;\n\n    svfloat64_t acc = svdup_f64(0.0);\n\n    while (i < length) {\n        pg = svwhilelt_b16(i, length);\n        \n        // Load indices\n        svint16_t idx = svld1_s16(pg, &index[i]);\n        \n        // Convert indices to 64-bit for gathering doubles\n        svint64_t idx_64 = svcvt_s64_s16_x(pg, idx);\n        \n        // Gather elements using converted indices\n        svfloat64_t gathered = svld1_gather_s64index_f64(pg, vec, idx_64);\n        \n        // Accumulate gathered elements\n        acc = svadd_f64_z(pg, acc, gathered);\n        \n        i += svcntw();\n    }\n\n    // Horizontal sum of accumulated vector\n    return svaddv_f64(svptrue_b64(), acc);\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_row = i + ki;\n                size_t kernel_row = ki * kernel_size;\n                size_t input_idx = input_row * input_size + j;\n                \n                svbool_t pg = svwhilelt_b64(0, kernel_size);\n                \n                while (svptest_first(svptrue_b64(), pg)) {\n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_row]);\n                    \n                    sum = svmla_f64_x(pg, sum, input_vec, kernel_vec);\n                    \n                    input_idx += svcntd();\n                    kernel_row += svcntd();\n                    pg = svwhilelt_b64(kernel_row, kernel_size);\n                }\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            output[i * output_size + j] = (result > 0.0) ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_row = i + ki;\n                size_t kernel_row = ki * kernel_size;\n                size_t input_idx = input_row * input_size + j;\n                \n                svbool_t pg = svwhilelt_b64(0, kernel_size);\n                \n                while (svptest_first(svptrue_b64(), pg)) {\n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_row]);\n                    \n                    sum = svmla_f64_z(pg, sum, input_vec, kernel_vec);\n                    \n                    input_idx += svcntd();\n                    kernel_row += svcntd();\n                    pg = svwhilelt_b64(kernel_row, kernel_size);\n                }\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            output[i * output_size + j] = (result > 0.0) ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```cpp\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                size_t input_row = i + k;\n                size_t kernel_offset = k * kernel_size;\n                size_t input_offset = input_row * input_size + j;\n                \n                svbool_t pg = svwhilelt_b64(0, kernel_size);\n                \n                while (svptest_first(svptrue_b64(), pg)) {\n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_offset]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_offset]);\n                    \n                    sum = svmla_f64_x(pg, sum, input_vec, kernel_vec);\n                    \n                    input_offset += svcntd();\n                    kernel_offset += svcntd();\n                    pg = svwhilelt_b64(kernel_offset, kernel_size);\n                }\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            output[i * output_size + j] = result > 0.0 ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                size_t input_offset = (i + ki) * input_size + j;\n                size_t kernel_offset = ki * kernel_size;\n                \n                svbool_t pg = svwhilelt_b64(0, kernel_size);\n                \n                while (svptest_any(svptrue_b64(), pg)) {\n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_offset]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_offset]);\n                    \n                    sum = svmad_f64_z(pg, input_vec, kernel_vec, sum);\n                    \n                    input_offset += svcntd();\n                    kernel_offset += svcntd();\n                    pg = svwhilelt_b64(kernel_offset, kernel_size);\n                }\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            \n            // ReLU activation\n            output[i * output_size + j] = (result > 0.0) ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\nvoid simple_conv2d_simd(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            svfloat64_t sum = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                size_t input_row = i + k;\n                \n                for (size_t l = 0; l < kernel_size; l += svcntd()) {\n                    svbool_t pg = svwhilelt_b64(l, kernel_size);\n                    \n                    size_t input_col = j + l;\n                    size_t input_idx = input_row * input_size + input_col;\n                    size_t kernel_idx = k * kernel_size + l;\n                    \n                    svfloat64_t input_vec = svld1_f64(pg, &input[input_idx]);\n                    svfloat64_t kernel_vec = svld1_f64(pg, &kernel[kernel_idx]);\n                    \n                    sum = svmad_f64_z(pg, kernel_vec, input_vec, sum);\n                }\n            }\n            \n            double result = svaddv_f64(svptrue_b64(), sum);\n            \n            // Apply ReLU activation\n            output[i * output_size + j] = (result > 0.0) ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    const double* data = numbers.data();\n    size_t len = numbers.size();\n    \n    svbool_t pg = svwhilelt_b64(0, len);\n    \n    for (size_t i = 0; i < len-1; i++) {\n        double current = data[i];\n        size_t remaining = len - i - 1;\n        \n        svbool_t pg_remaining = svwhilelt_b64(0, remaining); \n        svfloat64_t current_vec = svdup_f64(current);\n        svfloat64_t next_vec = svld1_f64(pg_remaining, data + i + 1);\n        \n        svfloat64_t diff = svsub_f64_z(pg_remaining, current_vec, next_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg_remaining, diff);\n        \n        svbool_t cmp = svcmplt_f64(pg_remaining, abs_diff, threshold);\n        \n        if (svptest_any(pg_remaining, cmp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n\n    const double* arr = numbers.data();\n    size_t len = numbers.size();\n    \n    svbool_t pg = svwhilelt_b64(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svfloat64_t vec1 = svld1_f64(pg, arr);\n        \n        // Compare with shifted versions\n        for (size_t offset = 1; offset < svlen_f64(); offset++) {\n            svfloat64_t vec2 = svld1_f64(pg, arr + offset);\n            \n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, vec1, vec2));\n            svbool_t cmp = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n        }\n        \n        // Move to next set of elements\n        size_t vl = svcntd();\n        arr += vl;\n        len -= vl;\n        pg = svwhilelt_b64(0, len);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    const double* data = numbers.data();\n    size_t len = numbers.size();\n    \n    svbool_t pg = svwhilelt_b64(0, len);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svfloat64_t vec1 = svld1_f64(pg, data);\n        \n        // Compare with shifted versions\n        for (size_t offset = 1; offset < svcntd(); offset++) {\n            svfloat64_t vec2 = svld1_f64(pg, data + offset);\n            \n            // Calculate absolute differences\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, vec1, vec2));\n            \n            // Compare with threshold\n            svbool_t cmp = svcmplt_f64(pg, diff, threshold);\n            \n            // Check if any elements are closer than threshold\n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n        }\n        \n        // Move to next vector chunk\n        size_t vl = svcntd();\n        data += vl;\n        len -= vl;\n        pg = svwhilelt_b64(0, len);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) return false;\n    \n    const double* ptr = numbers.data();\n    size_t len = numbers.size();\n    \n    svbool_t pg = svwhilelt_b64(0, len);\n    \n    while (svptest_any(pg, pg)) {\n        svfloat64_t vec1 = svld1_f64(pg, ptr);\n        \n        // Compare with shifted versions\n        for (size_t offset = 1; offset < svcntd(); offset++) {\n            svfloat64_t vec2 = svld1_f64(pg, ptr + offset);\n            \n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, vec1, vec2));\n            svbool_t cmp = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n        }\n        \n        // Compare with elements in next vector\n        size_t vlen = svcntd();\n        svfloat64_t vec_next = svld1_f64(svwhilelt_b64(vlen, len), ptr + vlen);\n        \n        for (size_t i = 0; i < vlen && (i + vlen) < len; i++) {\n            svfloat64_t vec2 = svdup_f64(svextract_f64(vec_next, i));\n            svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, vec1, vec2));\n            svbool_t cmp = svcmplt_f64(pg, diff, threshold);\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n        }\n        \n        ptr += svcntd();\n        pg = svwhilelt_b64(ptr - numbers.data(), len);\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n\n    const double* data = numbers.data();\n    size_t len = numbers.size();\n    svbool_t pg = svwhilelt_b64(0, len);\n\n    for (size_t i = 0; i < len-1; i++) {\n        double current = data[i];\n        size_t remaining = len - i - 1;\n        svbool_t pg_rem = svwhilelt_b64(0, remaining);\n        \n        svfloat64_t current_vec = svdup_n_f64(current);\n        svfloat64_t next_vec = svld1_f64(pg_rem, data + i + 1);\n        \n        svfloat64_t diff = svsub_f64_z(pg_rem, current_vec, next_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg_rem, diff);\n        \n        svbool_t cmp = svcmplt_f64(pg_rem, abs_diff, threshold);\n        \n        if (svptest_any(pg_rem, cmp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n    svint32_t zero = svdup_n_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        running_sum = svadd_s32_z(pg, running_sum, vec);\n        svbool_t below_zero = svcmplt_s32(pg, running_sum, zero);\n        \n        if (svptest_any(pg, below_zero)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        running_sum = svadd_s32_z(pg, running_sum, vec);\n        \n        svint32_t zero = svdup_n_s32(0);\n        svbool_t cmp = svcmplt_s32(pg, running_sum, zero);\n        \n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        running_sum = svadd_s32_z(pg, running_sum, vec);\n        \n        // Check if any value is negative\n        svbool_t cmp = svcmplt_s32(pg, running_sum, 0);\n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        running_sum = svadd_s32_z(pg, running_sum, vec);\n        \n        svint32_t zeros = svdup_n_s32(0);\n        svbool_t cmp = svcmplt_s32(pg, running_sum, zeros);\n        \n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        running_sum = svadd_s32_z(pg, running_sum, vec);\n        \n        svint32_t zero = svdup_n_s32(0);\n        svbool_t cmp = svcmplt_s32(pg, running_sum, zero);\n        \n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t len = numbers.size();\n    double* data = numbers.data();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b64(0, len);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n    \n    // Reduce sum\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / len;\n\n    // Calculate absolute deviations using SVE\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t mad_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        svfloat64_t diff = svsub_f64_z(pg, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n        mad_vec = svadd_f64_z(pg, mad_vec, abs_diff);\n    }\n    \n    // Reduce MAD\n    double mad_sum = svaddv_f64(svptrue_b64(), mad_vec);\n    return mad_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t len = numbers.size();\n    double* data = numbers.data();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b64(0, len);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n    \n    // Reduce sum\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / len;\n\n    // Calculate absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        svfloat64_t diff = svsub_f64_z(pg, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n        abs_dev_sum = svadd_f64_z(pg, abs_dev_sum, abs_diff);\n    }\n    \n    // Reduce absolute deviations\n    double mad_sum = svaddv_f64(svptrue_b64(), abs_dev_sum);\n    return mad_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t len = numbers.size();\n    double* data = numbers.data();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b64(0, len);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n    \n    // Reduce sum\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / len;\n    \n    // Calculate absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        svfloat64_t diff = svsub_f64_z(pg, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n        abs_dev_sum = svadd_f64_z(pg, abs_dev_sum, abs_diff);\n    }\n    \n    // Reduce absolute deviations\n    double mad_sum = svaddv_f64(svptrue_b64(), abs_dev_sum);\n    \n    return mad_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t len = numbers.size();\n    double* data = numbers.data();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b64(0, len);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, vec);\n    }\n    \n    // Reduce sum\n    double sum = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = sum / len;\n    \n    // Calculate absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < len; i += svcntd()) {\n        pg = svwhilelt_b64(i, len);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        svfloat64_t diff = svsub_f64_z(pg, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n        abs_dev_sum = svadd_f64_z(pg, abs_dev_sum, abs_diff);\n    }\n    \n    // Reduce absolute deviations sum\n    double mad_sum = svaddv_f64(svptrue_b64(), abs_dev_sum);\n    \n    return mad_sum / len;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    \n    size_t n = numbers.size();\n    double* data = numbers.data();\n    \n    // Calculate mean first\n    svbool_t pg = svwhilelt_b64(0, n);\n    svfloat64_t sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        sum = svadd_f64_z(pg, sum, vec);\n    }\n    \n    double mean = svaddv_f64(svptrue_b64(), sum) / n;\n    \n    // Calculate absolute deviations\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_dev_sum = svdup_f64(0.0);\n    \n    for (size_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svfloat64_t vec = svld1_f64(pg, &data[i]);\n        svfloat64_t diff = svsub_f64_z(pg, vec, mean_vec);\n        svfloat64_t abs_diff = svabs_f64_z(pg, diff);\n        abs_dev_sum = svadd_f64_z(pg, abs_dev_sum, abs_diff);\n    }\n    \n    return svaddv_f64(svptrue_b64(), abs_dev_sum) / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t n = numbers.size();\n    std::vector<int> result(2 * n - 1);\n    \n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    size_t i = 0;\n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        \n        // Store original elements at even indices\n        svst1_s32(pg, &result[2*i], vec);\n        \n        // Store delimiter at odd indices\n        svbool_t pg_delim = svwhilelt_b32(0, n-2);\n        svint32_t delim_vec = svdup_n_s32(delimeter);\n        svst1_s32(pg_delim, &result[2*i+1], delim_vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n-1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = input_size * 2 - 1;\n    std::vector<int> result(output_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0, j = 0;\n    while (i < input_size - 1) {\n        size_t elements = std::min(vl, input_size - i);\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n\n        for (size_t k = 0; k < elements; k++) {\n            result[j] = svextw_s32_x(pg, vec, k);\n            result[j + 1] = delimeter;\n            j += 2;\n        }\n        \n        i += elements;\n    }\n\n    // Handle last element\n    if (i < input_size) {\n        result[j] = numbers[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = input_size * 2 - 1;\n    std::vector<int> result(output_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0, j = 0;\n    while (i < input_size - 1) {\n        size_t elements = std::min(vl, input_size - i);\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        \n        for (size_t k = 0; k < elements; k++) {\n            result[j] = svextw_s32_x(pg, vec, k);\n            result[j + 1] = delimeter;\n            j += 2;\n        }\n        \n        i += elements;\n    }\n\n    // Handle last element\n    result[output_size - 1] = numbers[input_size - 1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = input_size * 2 - 1;\n    std::vector<int> result(output_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0, j = 0;\n    while (i < input_size - 1) {\n        size_t elements = std::min(vl, input_size - i);\n        \n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        \n        for (size_t k = 0; k < elements; k++) {\n            result[j] = svextw_s32_x(pg, vec, k);\n            result[j + 1] = delimeter;\n            j += 2;\n        }\n        \n        i += elements;\n    }\n\n    // Handle last element\n    if (i < input_size) {\n        result[j] = numbers[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t input_size = numbers.size();\n    size_t output_size = input_size * 2 - 1;\n    std::vector<int> result(output_size);\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n\n    size_t i = 0, j = 0;\n    while (i < input_size - 1) {\n        size_t elements = std::min(vl, input_size - i);\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        \n        for (size_t k = 0; k < elements; k++) {\n            result[j] = svextw_s32_x(pg, vec, k);\n            result[j + 1] = delimeter;\n            j += 2;\n        }\n        \n        i += elements;\n    }\n\n    // Handle last element\n    result[output_size - 1] = numbers[input_size - 1];\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    svint16_t vec = svld1_s16(pg, numbers.data());\n    \n    int64_t sum = svaddv_s16(pg, vec);\n    int64_t prod = 1;\n    \n    while (svptest_any(pg, pg)) {\n        svint16_t active_elements = svsel_s16(pg, vec, svdup_n_s16(1));\n        prod *= svmulv_s16(pg, active_elements);\n        pg = svnot_z(pg, pg);\n    }\n\n    return {sum, prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    std::vector<int64_t> result(2);\n    \n    if (numbers.empty()) {\n        result[0] = 0;\n        result[1] = 1;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    svint16_t vec;\n    \n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (size_t i = 0; i < numbers.size(); i += svcntw()) {\n        pg = svwhilelt_b16(i, numbers.size());\n        vec = svld1_s16(pg, &numbers[i]);\n        \n        // Calculate sum\n        sum += svaddv_s16(pg, vec);\n        \n        // Calculate product \n        svint16_t prod_vec = svdup_s16(1);\n        prod_vec = svmul_s16_z(pg, vec, prod_vec);\n        product *= svmulv_s16(pg, prod_vec);\n    }\n    \n    result[0] = sum;\n    result[1] = product;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    std::vector<int64_t> result(2);\n    \n    if (numbers.empty()) {\n        result[0] = 0;\n        result[1] = 1;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    svint16_t vec;\n    \n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (size_t i = 0; i < numbers.size(); i += svcntw()) {\n        pg = svwhilelt_b16(i, numbers.size());\n        vec = svld1_s16(pg, &numbers[i]);\n        \n        sum += svaddv_s16(pg, vec);\n        \n        svint16_t prod_vec = svdup_s16(1);\n        prod_vec = svmul_s16_z(pg, prod_vec, vec);\n        product *= svmulv_s16(pg, prod_vec);\n    }\n    \n    result[0] = sum;\n    result[1] = product;\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    std::vector<int64_t> result(2);\n    \n    if (numbers.empty()) {\n        result[0] = 0;\n        result[1] = 1;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    svint16_t vec;\n    \n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (size_t i = 0; i < numbers.size(); i += svcntw()) {\n        pg = svwhilelt_b16(i, numbers.size());\n        vec = svld1_s16(pg, &numbers[i]);\n        \n        sum += svaddv_s16(pg, vec);\n        \n        svint16_t prod_vec = vec;\n        int16_t partial_prod = svmulv_s16(pg, prod_vec);\n        product *= partial_prod;\n    }\n    \n    result[0] = sum;\n    result[1] = product;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    std::vector<int64_t> result(2);\n    \n    if (numbers.empty()) {\n        result[0] = 0;\n        result[1] = 1;\n        return result;\n    }\n\n    svbool_t pg = svwhilelt_b16(0, numbers.size());\n    svint16_t vec;\n    \n    int64_t sum = 0;\n    int64_t product = 1;\n\n    for (size_t i = 0; i < numbers.size(); i += svcntw()) {\n        pg = svwhilelt_b16(i, numbers.size());\n        vec = svld1_s16(pg, &numbers[i]);\n        \n        // Calculate sum\n        sum += svaddv_s16(pg, vec);\n        \n        // Calculate product \n        svint16_t prod_vec = svdup_s16(1);\n        prod_vec = svmul_s16_z(pg, vec, prod_vec);\n        product *= svmulv_s16(pg, prod_vec);\n    }\n\n    result[0] = sum;\n    result[1] = product;\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t i = 1;\n    while (i < numbers.size()) {\n        size_t vl = svcntw();\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        svint32_t max_vec = svdup_n_s32(max_val);\n        \n        max_vec = svmax_s32_z(pg, vec, max_vec);\n        svst1_s32(pg, &result[i], max_vec);\n        \n        max_val = svlasta_s32(pg, max_vec);\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int max_so_far = numbers[0];\n    result[0] = max_so_far;\n\n    size_t i = 1;\n    while (i < numbers.size()) {\n        size_t vl = svcntw();\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        svint32_t max_vec = svdup_n_s32(max_so_far);\n        \n        max_vec = svmax_s32_z(pg, max_vec, vec);\n        svst1_s32(pg, &result[i], max_vec);\n        \n        max_so_far = svmaxv_s32(pg, max_vec);\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int max_val = numbers[0];\n    result[0] = max_val;\n\n    size_t i = 1;\n    while (i < numbers.size()) {\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        svint32_t max_vec = svdup_n_s32(max_val);\n        \n        max_vec = svmax_s32_z(pg, vec, max_vec);\n        svst1_s32(pg, &result[i], max_vec);\n        \n        max_val = svmaxv_s32(pg, max_vec);\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    size_t len = numbers.size();\n    std::vector<int> result(len);\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Initialize first element\n    result[0] = numbers[0];\n    svint32_t max_vec = svdup_n_s32(numbers[0]);\n    \n    // Process rest of array in chunks\n    for (size_t i = 1; i < len; i += vl) {\n        size_t chunk_size = std::min(vl, len - i);\n        \n        // Create predicate for this chunk\n        svbool_t pred = svwhilelt_b32(i, len);\n        \n        // Load chunk of input array\n        svint32_t vec = svld1_s32(pred, &numbers[i]);\n        \n        // Broadcast previous max to vector\n        svint32_t prev_max = svdup_n_s32(result[i-1]);\n        \n        // Compare with previous max\n        max_vec = svmax_s32_z(pred, vec, prev_max);\n        \n        // Store result\n        svst1_s32(pred, &result[i], max_vec);\n        \n        // Update running max for next iteration\n        if (chunk_size == vl) {\n            result[i + vl - 1] = svlastb_s32(pred, max_vec);\n        }\n    }\n    \n    // Sequential scan to ensure rolling max property\n    for (size_t i = 1; i < len; i++) {\n        result[i] = std::max(result[i], result[i-1]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result(numbers.size());\n    int current_max = numbers[0];\n    result[0] = current_max;\n\n    size_t i = 1;\n    while (i < numbers.size()) {\n        size_t vl = svcntw();\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        \n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        svint32_t max_vec = svdup_n_s32(current_max);\n        \n        max_vec = svmax_s32_z(pg, max_vec, vec);\n        svst1_s32(pg, &result[i], max_vec);\n        \n        current_max = svmaxv_s32(pg, max_vec);\n        i += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    // Get vector length\n    size_t vl = svcntb();\n    \n    // Process chunks of size vl\n    for(size_t i = 0; i < len; i += vl) {\n        size_t chunk = std::min(vl, len - i);\n        \n        // Create predicate for active elements\n        svbool_t pred = svwhilelt_b8(i, len);\n        \n        // Load data into vectors\n        svuint8_t va = svld1_u8(pred, (uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pred, (uint8_t*)&b[i]);\n        \n        // XOR operation\n        svuint8_t vxor = sveor_u8_z(pred, va, vb);\n        \n        // Store result\n        svst1_u8(pred, (uint8_t*)&result[i], vxor);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t va = svld1_u8(pg, (uint8_t*)a.data());\n        svuint8_t vb = svld1_u8(pg, (uint8_t*)b.data());\n        \n        // XOR the ASCII values and convert back to '0'/'1'\n        svuint8_t vxor = sveor_u8_z(pg, va, vb);\n        \n        // Convert ASCII '0'/'1' to 0/1\n        vxor = svsub_n_u8_z(pg, vxor, '0');\n        \n        // Convert 0/1 back to ASCII '0'/'1'\n        vxor = svadd_n_u8_z(pg, vxor, '0');\n        \n        svst1_u8(pg, (uint8_t*)result.data(), vxor);\n        \n        size_t vl = svcntb();\n        a = a.substr(vl);\n        b = b.substr(vl);\n        result = result.substr(vl);\n        pg = svwhilelt_b8(0, a.length());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    char *a_ptr = a.data();\n    char *b_ptr = b.data();\n    char *r_ptr = result.data();\n    \n    size_t i = 0;\n    svbool_t pg;\n    \n    while(i < len) {\n        pg = svwhilelt_b8(i, len);\n        \n        svuint8_t va = svld1_u8(pg, (uint8_t*)&a_ptr[i]);\n        svuint8_t vb = svld1_u8(pg, (uint8_t*)&b_ptr[i]);\n        \n        // Convert '0'/'1' chars to 0/1 values\n        va = svsub_u8_z(pg, va, svdup_u8('0'));\n        vb = svsub_u8_z(pg, vb, svdup_u8('0'));\n        \n        // XOR operation\n        svuint8_t vr = sveor_u8_z(pg, va, vb);\n        \n        // Convert back to '0'/'1' chars\n        vr = svadd_u8_z(pg, vr, svdup_u8('0'));\n        \n        svst1_u8(pg, (uint8_t*)&r_ptr[i], vr);\n        \n        i += svcntb();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    // Get vector length\n    size_t vl = svcntb();\n    \n    // Process chunks of size vl\n    for(size_t i = 0; i < len; i += vl) {\n        size_t chunk = std::min(vl, len - i);\n        \n        // Create predicate for active elements\n        svbool_t pred = svwhilelt_b8(i, len);\n        \n        // Load data into vectors\n        svuint8_t va = svld1_u8(pred, (uint8_t*)&a[i]);\n        svuint8_t vb = svld1_u8(pred, (uint8_t*)&b[i]);\n        \n        // XOR operation\n        svuint8_t vresult = sveor_u8_z(pred, va, vb);\n        \n        // Store result\n        svst1_u8(pred, (uint8_t*)&result[i], vresult);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n    \n    // Convert strings to arrays for SIMD processing\n    uint8_t* a_arr = new uint8_t[len];\n    uint8_t* b_arr = new uint8_t[len];\n    uint8_t* res_arr = new uint8_t[len];\n    \n    // Convert '0'/'1' chars to 0/1 integers\n    for(size_t i = 0; i < len; i++) {\n        a_arr[i] = a[i] - '0';\n        b_arr[i] = b[i] - '0';\n    }\n\n    size_t i = 0;\n    svbool_t pg;\n\n    while(i < len) {\n        pg = svwhilelt_b8(i, len);\n        \n        // Load vectors\n        svuint8_t va = svld1_u8(pg, &a_arr[i]);\n        svuint8_t vb = svld1_u8(pg, &b_arr[i]);\n        \n        // XOR operation\n        svuint8_t vres = sveor_u8_z(pg, va, vb);\n        \n        // Store result\n        svst1_u8(pg, &res_arr[i], vres);\n        \n        i += svcntb();\n    }\n\n    // Convert back to string\n    for(size_t i = 0; i < len; i++) {\n        result[i] = res_arr[i] + '0';\n    }\n    \n    delete[] a_arr;\n    delete[] b_arr;\n    delete[] res_arr;\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t n = strings.size();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svuint32_t indices = svindex_u32(0, 1);\n    svuint32_t max_lens = svdup_u32(0);\n    svuint32_t max_indices = svdup_u32(0);\n\n    while (svptest_first(pg, pg)) {\n        svuint32_t lens = svdup_u32(0);\n        \n        // Load string lengths into vector\n        for (size_t i = 0; i < svcntw(); i++) {\n            if (!svptest_first(svwhilelt_b32(i, n), pg)) break;\n            uint32_t idx = svlasta_u32(pg, indices);\n            lens = svset_u32(lens, i, strings[idx].length());\n        }\n\n        // Find max length and corresponding index\n        svbool_t pred = svcmpgt_u32(pg, lens, max_lens);\n        max_lens = svsel_u32(pred, lens, max_lens);\n        max_indices = svsel_u32(pred, indices, max_indices);\n\n        // Advance to next set of elements\n        indices = svadd_u32_x(pg, indices, svcntw());\n        pg = svwhilelt_b32(svlasta_u32(pg, indices), n);\n    }\n\n    // Reduce to find global maximum\n    uint32_t max_len_scalar = svmaxv_u32(svptrue_b32(), max_lens);\n    \n    // Find first index with max length\n    svbool_t max_pred = svcmpeq_n_u32(svptrue_b32(), max_lens, max_len_scalar);\n    uint32_t first_max_idx = svminv_u32(max_pred, max_indices);\n\n    return strings[first_max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t n = strings.size();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svuint32_t vindex = svindex_u32(0, 1);\n    svuint32_t vmax_len = svdup_u32(0);\n    svuint32_t vmax_idx = svdup_u32(0);\n\n    for (size_t i = 0; i < n; i += svcntw()) {\n        svuint32_t vlen = svdup_u32(0);\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        // Load string lengths into vector\n        for (size_t j = 0; j < svcntw() && (i + j) < n; j++) {\n            vlen = svset_u32(vlen, j, strings[i + j].length());\n        }\n\n        // Compare lengths and update max\n        svbool_t pred = svcmpgt_u32(p, vlen, vmax_len);\n        vmax_len = svsel_u32(pred, vlen, vmax_len);\n        \n        // Get indices of max lengths\n        svuint32_t curr_idx = svadd_u32_x(p, svdup_u32(i), vindex);\n        vmax_idx = svsel_u32(pred, curr_idx, vmax_idx);\n    }\n\n    // Reduce to find global max\n    uint32_t max_lengths[16];\n    uint32_t max_indices[16];\n    svst1_u32(pg, max_lengths, vmax_len);\n    svst1_u32(pg, max_indices, vmax_idx);\n\n    for (size_t i = 0; i < svcntw() && i < n; i++) {\n        if (max_lengths[i] > max_len) {\n            max_len = max_lengths[i];\n            max_idx = max_indices[i];\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vec_size = strings.size();\n    \n    svbool_t pg = svwhilelt_b32(0, vec_size);\n    \n    svuint32_t lengths = svdup_u32(0);\n    \n    for (size_t i = 0; i < vec_size; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, vec_size);\n        \n        // Load string lengths into vector\n        svuint32_t curr_lengths = svdup_u32(0);\n        for (size_t j = 0; j < svcntw() && (i + j) < vec_size; j++) {\n            curr_lengths = svset_u32(curr_lengths, j, strings[i + j].length());\n        }\n        \n        // Find max length in current chunk\n        svuint32_t max_vec = svmax_u32_z(p, lengths, curr_lengths);\n        \n        // Update global max if needed\n        uint32_t chunk_max = svmaxv_u32(p, max_vec);\n        if (chunk_max > max_len) {\n            // Find first occurrence of max length\n            for (size_t j = 0; j < svcntw() && (i + j) < vec_size; j++) {\n                if (strings[i + j].length() == chunk_max) {\n                    max_len = chunk_max;\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vec_len = strings.size();\n    \n    svbool_t pg = svwhilelt_b32(0, vec_len);\n    svuint32_t indices = svindex_u32(0, 1);\n    svuint32_t max_length = svdup_u32(0);\n    svuint32_t max_index = svdup_u32(0);\n    \n    while (svptest_first(pg, pg)) {\n        svuint32_t lengths = svdup_u32(0);\n        \n        // Load string lengths into vector\n        for (size_t i = 0; i < svcntw(); i++) {\n            if (!svptest_first(pg, svdup_b32(1))) break;\n            uint32_t idx = svlasta_u32(pg, indices);\n            lengths = svset_u32(lengths, i, strings[idx].length());\n            indices = svadd_u32_x(pg, indices, 1);\n        }\n        \n        // Find max length and corresponding index in this chunk\n        svbool_t pred = svcmpgt_u32(pg, lengths, max_length);\n        max_length = svsel_u32(pred, lengths, max_length);\n        max_index = svsel_u32(pred, indices, max_index);\n        \n        pg = svwhilelt_b32(svcntw(), vec_len);\n    }\n    \n    // Reduce to find global maximum\n    uint32_t curr_max_len = svmaxv_u32(svptrue_b32(), max_length);\n    \n    // Find first occurrence of max length\n    for (size_t i = 0; i < strings.size(); i++) {\n        if (strings[i].length() == curr_max_len) {\n            return strings[i];\n        }\n    }\n    \n    return strings[0];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    size_t max_len = 0;\n    size_t max_idx = 0;\n    size_t vec_len = strings.size();\n\n    svbool_t pg = svwhilelt_b32(0, vec_len);\n    svuint32_t lengths = svdup_u32(0);\n    \n    for (size_t i = 0; i < vec_len; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, vec_len);\n        \n        // Load string lengths into vector\n        svuint32_t curr_lengths = svdup_u32(0);\n        for (size_t j = 0; j < svcntw() && (i + j) < vec_len; j++) {\n            curr_lengths = svset_u32(curr_lengths, j, strings[i + j].length());\n        }\n        \n        // Compare with max lengths\n        svbool_t cmp = svcmpgt_u32(p, curr_lengths, lengths);\n        \n        // Update max lengths and indices where needed\n        lengths = svsel_u32(cmp, curr_lengths, lengths);\n        \n        // Find max length and index\n        uint32_t vec_max = svmaxv_u32(p, curr_lengths);\n        if (vec_max > max_len) {\n            max_len = vec_max;\n            // Find first occurrence of max length\n            for (size_t j = 0; j < svcntw() && (i + j) < vec_len; j++) {\n                if (strings[i + j].length() == max_len) {\n                    max_idx = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n    \n    while (svptest_any(pg, svbne_n_u64(vb, 0))) {\n        svuint64_t temp = vb;\n        vb = svrem_u64_x(pg, va, vb);\n        va = temp;\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n    \n    while (svptest_any(pg, svbne_n_u64(vb, 0))) {\n        svuint64_t temp = vb;\n        vb = svrem_u64_x(pg, va, vb);\n        va = temp;\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svbne_u64_z(pg, vb, svdup_u64(0)))) {\n        svuint64_t t = vb;\n        vb = svrem_u64_z(pg, va, vb);\n        va = t;\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n    \n    while (svptest_any(pg, svbne_u64_z(pg, vb, 0))) {\n        svuint64_t t = vb;\n        vb = svrem_u64_z(pg, va, vb);\n        va = t;\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_n_u64(a);\n    svuint64_t vb = svdup_n_u64(b);\n    \n    while (svptest_any(pg, svbne_n_u64(vb, 0))) {\n        svuint64_t temp = vb;\n        vb = svrem_u64_x(pg, va, vb);\n        va = temp;\n    }\n    \n    return svlasta_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    size_t len = numbers.size();\n\n    svbool_t pg = svwhilelt_b32(0, len-1);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &numbers[0]);\n        \n        for (size_t i = 1; i < len; i++) {\n            svfloat32_t vec2 = svld1_f32(pg, &numbers[i]);\n            svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n            \n            float min_val = svminv_f32(pg, diff);\n            \n            if (min_val < min_diff) {\n                svbool_t mask = svcmpeq_f32(pg, diff, svdup_f32(min_val));\n                size_t idx = svfirst_b32(mask);\n                \n                min_diff = min_val;\n                num1 = numbers[idx];\n                num2 = numbers[i + idx];\n                \n                if (num1 > num2) {\n                    std::swap(num1, num2);\n                }\n            }\n        }\n        \n        pg = svwhilelt_b32(svlen_f32(vec1), len-1);\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    size_t len = numbers.size();\n\n    svbool_t pg = svwhilelt_b32(0, len-1);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &numbers[0]);\n        \n        for(size_t i = 1; i < len; i++) {\n            svfloat32_t vec2 = svld1_f32(pg, &numbers[i]);\n            svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n            \n            float min_val = svminv_f32(pg, diff);\n            \n            if(min_val < min_diff) {\n                svbool_t mask = svcmpeq_f32(pg, diff, min_val);\n                size_t idx = svfirst_b32(mask);\n                \n                min_diff = min_val;\n                num1 = numbers[idx];\n                num2 = numbers[idx + i];\n                \n                if(num1 > num2) {\n                    std::swap(num1, num2);\n                }\n            }\n        }\n        \n        pg = svwhilelt_b32(svlen_f32(vec1), len-1);\n    }\n\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    \n    svbool_t pg = svptrue_b32();\n    svuint32_t indices = svindex_u32(0, 1);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svfloat32_t v1 = svld1_f32(p, &numbers[i]);\n        \n        for (size_t j = i + 1; j < n; j += svcntw()) {\n            svbool_t p2 = svwhilelt_b32(j, n);\n            svfloat32_t v2 = svld1_f32(p2, &numbers[j]);\n            \n            // Broadcast v1 elements\n            for (size_t k = 0; k < svcntw() && (i + k) < n; k++) {\n                float val = numbers[i + k];\n                svfloat32_t bcast = svdup_f32(val);\n                \n                // Calculate differences\n                svfloat32_t diff = svabs_f32_x(p2, svsub_f32_x(p2, bcast, v2));\n                \n                // Find minimum difference\n                svfloat32_t min_vals = svmin_f32_x(p2, diff, svdup_f32(min_diff));\n                float curr_min = svminv_f32(p2, min_vals);\n                \n                if (curr_min < min_diff) {\n                    // Find index where minimum occurred\n                    svbool_t min_mask = svcmpeq_f32(p2, diff, svdup_f32(curr_min));\n                    uint32_t min_idx = svlasta_u32(min_mask, svsel_u32(min_mask, svindex_u32(j, 1), svdup_u32(n)));\n                    \n                    min_diff = curr_min;\n                    num1 = val;\n                    num2 = numbers[min_idx];\n                    \n                    if (num2 < num1) {\n                        std::swap(num1, num2);\n                    }\n                }\n            }\n        }\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    size_t len = numbers.size();\n\n    svbool_t pg = svwhilelt_b32(0, len-1);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &numbers[0]);\n        \n        for(size_t i = 1; i < len; i++) {\n            svfloat32_t vec2 = svld1_f32(pg, &numbers[i]);\n            svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n            \n            float min_val;\n            svfloat32_t min_diff_vec = svdup_f32(min_diff);\n            svbool_t cmp = svcmplt_f32(pg, diff, min_diff_vec);\n            \n            if(svptest_any(pg, cmp)) {\n                min_val = svminv_f32(pg, diff);\n                \n                if(min_val < min_diff) {\n                    size_t idx = i + svfirstz_b32(svcmpeq_f32(pg, diff, svdup_f32(min_val)));\n                    if(idx < len) {\n                        min_diff = min_val;\n                        num1 = std::min(numbers[idx-i], numbers[idx]);\n                        num2 = std::max(numbers[idx-i], numbers[idx]);\n                    }\n                }\n            }\n        }\n        \n        pg = svwhilelt_b32(svlen_f32(vec1), len-1);\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    float min_diff = std::numeric_limits<float>::max();\n    float num1 = 0.0f, num2 = 0.0f;\n    size_t len = numbers.size();\n\n    svbool_t pg = svwhilelt_b32(0, len-1);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, &numbers[0]);\n        \n        for(size_t i = 1; i < len; i++) {\n            svfloat32_t vec2 = svld1_f32(pg, &numbers[i]);\n            \n            // Calculate absolute differences\n            svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, vec1, vec2));\n            \n            // Find minimum difference\n            float min_val = svminv_f32(pg, diff);\n            \n            // If new minimum found, update result\n            if(min_val < min_diff) {\n                // Find index of minimum difference\n                svbool_t min_mask = svcmpeq_f32(pg, diff, min_val);\n                uint32_t idx = svlasta_u32(min_mask, svindex_u32(0, 1));\n                \n                min_diff = min_val;\n                num1 = numbers[idx];\n                num2 = numbers[idx + i];\n            }\n        }\n        \n        pg = svwhilelt_b32(svlen_f32(vec1), len-1);\n    }\n\n    if(num2 < num1) {\n        std::swap(num1, num2);\n    }\n    \n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float* data = numbers.data();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Find min and max values\n    svfloat32_t vec_min = svdup_f32(data[0]);\n    svfloat32_t vec_max = svdup_f32(data[0]);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pred = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pred, &data[i]);\n        \n        vec_min = svminv_f32(pred, vec_min, vec);\n        vec_max = svmaxv_f32(pred, vec_max, vec);\n    }\n    \n    float min_val = svlastb_f32(vec_min);\n    float max_val = svlastb_f32(vec_max);\n    float range = max_val - min_val;\n    \n    // Scale the values\n    svfloat32_t vec_range = svdup_f32(range);\n    svfloat32_t vec_min_val = svdup_f32(min_val);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pred = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pred, &data[i]);\n        \n        // x = (x - min) / (max - min)\n        vec = svsub_f32_x(pred, vec, vec_min_val);\n        vec = svdiv_f32_x(pred, vec, vec_range);\n        \n        svst1_f32(pred, &data[i], vec);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float* data = numbers.data();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Find min and max values\n    svfloat32_t vec_min = svdup_f32(data[0]);\n    svfloat32_t vec_max = svdup_f32(data[0]);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        \n        vec_min = svminv_f32(pg, svmin_f32_z(pg, vec_min, vec));\n        vec_max = svmaxv_f32(pg, svmax_f32_z(pg, vec_max, vec));\n    }\n    \n    float min_val = svgetf32(vec_min, 0);\n    float max_val = svgetf32(vec_max, 0);\n    float range = max_val - min_val;\n    \n    // Scale the values\n    svfloat32_t vec_range = svdup_f32(range);\n    svfloat32_t vec_min_val = svdup_f32(min_val);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        \n        // (x - min) / (max - min)\n        svfloat32_t result = svdiv_f32_z(pg, \n                                        svsub_f32_z(pg, vec, vec_min_val),\n                                        vec_range);\n        \n        svst1_f32(pg, &data[i], result);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float* data = numbers.data();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Find min and max values\n    svfloat32_t vec_min = svdup_f32(data[0]);\n    svfloat32_t vec_max = svdup_f32(data[0]);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        vec_min = svminv_f32(pg, svmin_f32_z(pg, vec_min, vec));\n        vec_max = svmaxv_f32(pg, svmax_f32_z(pg, vec_max, vec));\n    }\n    \n    float min_val = svgetf32(vec_min, 0);\n    float max_val = svgetf32(vec_max, 0);\n    float range = max_val - min_val;\n    \n    // Scale the values\n    svfloat32_t vec_range = svdup_f32(range);\n    svfloat32_t vec_min_val = svdup_f32(min_val);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        vec = svsub_f32_z(pg, vec, vec_min_val);\n        vec = svdiv_f32_z(pg, vec, vec_range);\n        svst1_f32(pg, &data[i], vec);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float* data = numbers.data();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Find min and max values\n    svfloat32_t vec_min = svdup_f32(data[0]);\n    svfloat32_t vec_max = svdup_f32(data[0]);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        vec_min = svminv_f32(pg, svmin_f32_z(pg, vec_min, vec));\n        vec_max = svmaxv_f32(pg, svmax_f32_z(pg, vec_max, vec));\n    }\n    \n    float min_val = svlastb_f32(svptrue_b32(), vec_min);\n    float max_val = svlastb_f32(svptrue_b32(), vec_max);\n    float range = max_val - min_val;\n    \n    // Rescale values\n    svfloat32_t vec_range = svdup_f32(range);\n    svfloat32_t vec_min_val = svdup_f32(min_val);\n    \n    for (size_t i = 0; i < n; i += vl) {\n        size_t this_vl = (i + vl <= n) ? vl : n - i;\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        \n        // (x - min) / (max - min)\n        svfloat32_t result = svdiv_f32_z(pg, \n                                        svsub_f32_z(pg, vec, vec_min_val),\n                                        vec_range);\n        \n        svst1_f32(pg, &data[i], result);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t len = numbers.size();\n    float* data = numbers.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    svfloat32_t vec = svld1_f32(pg, data);\n    \n    // Find min and max values\n    float min_val = svminv_f32(pg, vec);\n    float max_val = svmaxv_f32(pg, vec);\n    \n    float range = max_val - min_val;\n    \n    // Create vectors with min_val and range\n    svfloat32_t vec_min = svdup_n_f32(min_val);\n    svfloat32_t vec_range = svdup_n_f32(range);\n    \n    // Process elements in chunks of vector length\n    for (size_t i = 0; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        vec = svld1_f32(pg, &data[i]);\n        \n        // Subtract min and divide by range\n        vec = svsub_f32_z(pg, vec, vec_min);\n        vec = svdiv_f32_z(pg, vec, vec_range);\n        \n        // Store result back\n        svst1_f32(pg, &data[i], vec);\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n/2);\n    svuint64_t indices = svindex_u64(1, 1);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t divisors = svdiv_u64_z(pg, vec_n, indices);\n    svuint64_t remainders = svmul_u64_z(pg, indices, divisors);\n    svbool_t is_divisor = svcmpeq_u64(pg, remainders, vec_n);\n    \n    uint64_t max_divisor = 1;\n    uint64_t i = 1;\n    while(svptest_first(pg, is_divisor)) {\n        if(svptest_any(pg, svand_z(pg, is_divisor, svcmpeq_n_u64(pg, indices, i)))) {\n            max_divisor = i;\n        }\n        i++;\n        if(i > n/2) break;\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n/2);\n    svuint64_t indices = svindex_u64(1, 1);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t divisors = svindex_u64(n/2, -1);\n    \n    while (svptest_first(pg, pg)) {\n        svuint64_t remainders = svurem_u64_z(pg, vec_n, divisors);\n        svbool_t zero_remainder = svcmpeq_u64(pg, remainders, 0);\n        \n        if (svptest_first(pg, zero_remainder)) {\n            uint64_t first_divisor = svlasta_u64(zero_remainder, divisors);\n            return first_divisor;\n        }\n        \n        divisors = svsub_u64_z(pg, divisors, svdup_n_u64(svlen_u64()));\n        pg = svwhilelt_b64(0, svlasta_u64(pg, divisors));\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n/2);\n    svuint64_t indices = svindex_u64(1, 1);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t divisors = svindex_u64(n/2, -1);\n    \n    while (svptest_first(pg, pg)) {\n        svuint64_t remainders = svurem_u64_z(pg, vec_n, divisors);\n        svbool_t zero_remainder = svcmpeq_n_u64(pg, remainders, 0);\n        \n        if (svptest_first(pg, zero_remainder)) {\n            uint64_t first_divisor = svlasta_u64(zero_remainder, divisors);\n            return first_divisor;\n        }\n        \n        uint64_t vl = svcntd();\n        divisors = svsub_n_u64_z(pg, divisors, vl);\n        pg = svwhilelt_b64(0, svlasta_u64(pg, divisors));\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```cpp\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n/2);\n    svuint64_t indices = svindex_u64(1, 1);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t divisors = svindex_u64(n/2, -1);\n    \n    while (svptest_first(pg, pg)) {\n        svuint64_t remainders = svurem_u64_z(pg, vec_n, divisors);\n        svbool_t is_divisor = svcmpeq_n_u64(pg, remainders, 0);\n        \n        if (svptest_first(pg, is_divisor)) {\n            uint64_t first_divisor = svlasta_u64(is_divisor, divisors);\n            return first_divisor;\n        }\n        \n        divisors = svsub_u64_z(pg, divisors, svdup_n_u64(1));\n        pg = svwhilelt_b64(0, svlasta_u64(pg, divisors));\n    }\n    \n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\nuint64_t largest_divisor_simd(uint64_t n) {\n    svbool_t pg = svwhilelt_b64(0, n/2);\n    svuint64_t indices = svindex_u64(1, 1);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t divisors = svadd_z(pg, indices, svdup_n_u64(1));\n    \n    svbool_t div_mask = svcmpeq_n_u64(pg, svdiv_z(pg, svmul_z(pg, svdiv_z(pg, vec_n, divisors), divisors), vec_n));\n    \n    uint64_t max_divisor = 1;\n    uint64_t vector_length = svcntd();\n    \n    for (uint64_t i = 0; i < n/2; i += vector_length) {\n        svbool_t curr_pg = svwhilelt_b64(i, n/2);\n        svuint64_t curr_divisors = svadd_z(curr_pg, svindex_u64(i+1, 1), svdup_n_u64(0));\n        svbool_t curr_div_mask = svcmpeq_n_u64(curr_pg, \n            svdiv_z(curr_pg, svmul_z(curr_pg, svdiv_z(curr_pg, vec_n, curr_divisors), curr_divisors), vec_n));\n        \n        svuint64_t valid_divisors = svsel_u64(curr_div_mask, curr_divisors, svdup_n_u64(0));\n        max_divisor = svmaxv_u64(curr_pg, valid_divisors) > max_divisor ? \n                     svmaxv_u64(curr_pg, valid_divisors) : max_divisor;\n    }\n    \n    return max_divisor;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n/2;\n    }\n    \n    svbool_t pg = svwhilelt_b32(0, (n-3)/2);\n    svint32_t indices = svindex_s32(0, 1);\n    svint32_t threes = svmul_n_s32_z(pg, indices, 2);\n    svint32_t candidates = svadd_n_s32_z(pg, threes, 3);\n    \n    int i = 3;\n    while (i * i <= n) {\n        svbool_t divmask = svcmpeq_n_s32(pg, svdiv_s32_z(pg, svdup_n_s32(n), candidates), 0);\n        \n        if (svptest_any(pg, divmask)) {\n            while (n % i == 0) {\n                factors.push_back(i);\n                n = n/i;\n            }\n        }\n        \n        i += 2;\n        pg = svwhilelt_b32(0, (n-i)/2);\n        indices = svindex_s32(0, 1); \n        threes = svmul_n_s32_z(pg, indices, 2);\n        candidates = svadd_n_s32_z(pg, threes, i);\n    }\n    \n    if (n > 2) {\n        factors.push_back(n);\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n / 2;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, (n-3)/2);\n    svint32_t indices = svindex_s32(3, 2);\n    svint32_t num = svdup_n_s32(n);\n    \n    while (n > 1) {\n        svint32_t potential_factors = indices;\n        svbool_t is_divisible = svCMPEQ_n_s32_z(pg, svdiv_s32_z(pg, num, potential_factors), 0);\n        \n        uint64_t first_divisible = svcntp_b32(pg, is_divisible);\n        \n        if (first_divisible == 0) {\n            if (n > 1) {\n                factors.push_back(n);\n                break;\n            }\n        } else {\n            int factor = svlasta_s32(is_divisible, potential_factors);\n            factors.push_back(factor);\n            n /= factor;\n            num = svdup_n_s32(n);\n        }\n        \n        if (!svptest_any(pg, pg)) {\n            if (n > 1) {\n                factors.push_back(n);\n            }\n            break;\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n = n/2;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, (n-3)/2);\n    svint32_t indices = svindex_s32(3, 2);\n    \n    while (n > 1) {\n        svint32_t candidates = svmul_x(pg, indices, indices);\n        svbool_t mask = svcmpgt_n_s32(pg, candidates, n);\n        svbool_t found = svnot_z(pg, mask);\n        \n        if (!svptest_any(pg, found)) {\n            int i = 3;\n            while (i * i <= n) {\n                if (n % i == 0) {\n                    factors.push_back(i);\n                    n = n/i;\n                    break;\n                }\n                i += 2;\n            }\n            if (i * i > n && n > 1) {\n                factors.push_back(n);\n                break;\n            }\n        } else {\n            svint32_t divisors = svsel_s32(found, indices, svdup_n_s32(0));\n            uint32_t first_divisor = svlasta_s32(found, divisors);\n            \n            if (n % first_divisor == 0) {\n                factors.push_back(first_divisor);\n                n = n/first_divisor;\n            }\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle special cases\n    if (n <= 1) return factors;\n    \n    // Get vector length\n    const int vl = svcntw();\n    \n    // Create vector of consecutive integers starting from 2\n    svint32_t vec_nums = svindex_s32(2, 1);\n    svbool_t pg = svwhilelt_b32(0, vl);\n    \n    while (n > 1) {\n        // Create predicate for numbers <= sqrt(n)\n        svbool_t pred = svwhilele_b32(pg, vec_nums, (int)sqrt(n));\n        \n        // Check which numbers divide n\n        svbool_t divides = svcmpeq_n_s32(pred, svdiv_n_s32_z(pred, svmul_n_s32_z(pred, \n                          svdiv_n_s32_z(pred, svdup_n_s32(n), vec_nums), vec_nums), n), 0);\n        \n        // Get first divisor\n        int divisor = 2;\n        if (svptest_first(pg, divides)) {\n            divisor = svlasta_s32(divides, vec_nums);\n        }\n        \n        // If no divisor found in current vector range, try next range\n        if (divisor == 2 && !svptest_any(pg, divides)) {\n            vec_nums = svadd_n_s32_z(pg, vec_nums, vl);\n            continue;\n        }\n        \n        // Add factor and divide n\n        factors.push_back(divisor);\n        n /= divisor;\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    \n    // Handle edge cases\n    if (n <= 1) return factors;\n\n    // Get vector length\n    const int vlen = svcntw();\n    \n    // Create vector of consecutive integers starting from 2\n    svbool_t pg = svwhilelt_b32(0, vlen);\n    svint32_t vec_nums = svindex_s32(2, 1);\n    \n    while (n > 1) {\n        // Create predicate for numbers <= sqrt(n)\n        svbool_t pred = svwhilele_b32(pg, vec_nums, (int)sqrt(n));\n        \n        // Check divisibility\n        svbool_t div_pred = svcmpeq_n_s32(pred, svmodv_s32_x(pred, svdup_n_s32(n), vec_nums), 0);\n        \n        // Find first divisor\n        uint32_t first_div = 0;\n        if (svptest_first(pg, div_pred)) {\n            first_div = svlasta_s32(div_pred, vec_nums);\n        }\n        \n        // If no divisor found in current vector range, move to next range\n        if (first_div == 0) {\n            vec_nums = svadd_n_s32_z(pg, vec_nums, vlen);\n            continue;\n        }\n        \n        // Add found divisor to factors\n        factors.push_back(first_div);\n        n /= first_div;\n        \n        // Reset vector if needed\n        if (first_div > 2) {\n            vec_nums = svindex_s32(2, 1);\n        }\n    }\n    \n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    size_t i = 0;\n    const size_t vl = svcntw();\n\n    while (i < l.size()) {\n        size_t this_vl = std::min(vl, l.size() - i);\n        \n        svbool_t pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        float buffer[vl];\n        svst1_f32(pos_mask, buffer, vec);\n        \n        for (size_t j = 0; j < this_vl; j++) {\n            if (svptest_first(svptrue_b32(), svdup_b32(svpfalse_b())) || \n                svptest_last(pos_mask, svptrue_b32())) {\n                if (buffer[j] > 0) {\n                    result.push_back(buffer[j]);\n                }\n            }\n        }\n        \n        i += this_vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    size_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create predicate for positive numbers\n        svbool_t pos_pred = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Count positive numbers in current chunk\n        uint32_t pos_count = svcntp_b32(svptrue_b32(), pos_pred);\n        \n        // Compress and store positive numbers\n        if (pos_count > 0) {\n            svfloat32_t pos_vec = svcompact_f32(pos_pred, vec);\n            size_t old_size = result.size();\n            result.resize(old_size + pos_count);\n            svst1_f32(svwhilelt_b32(0, pos_count), &result[old_size], pos_vec);\n        }\n        \n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t i = 0;\n    const size_t vl = svcntw();\n\n    while (i < l.size()) {\n        size_t this_vl = std::min(vl, l.size() - i);\n        \n        // Load vector\n        svfloat32_t vec = svld1_f32(svptrue_b32(), &l[i]);\n        \n        // Create predicate for positive numbers\n        svbool_t pred = svcmpgt_f32(svptrue_b32(), vec, svdup_n_f32(0.0f));\n        \n        // Count positive numbers in this chunk\n        uint64_t pos_count = svcntp_b32(svptrue_b32(), pred);\n        \n        // Compress the vector to only positive numbers\n        svfloat32_t pos_vec = svcompact_f32(pred, vec);\n        \n        // Resize result vector to fit new elements\n        size_t old_size = result.size();\n        result.resize(old_size + pos_count);\n        \n        // Store compressed positive numbers\n        svst1_f32(svptrue_b32(), &result[old_size], pos_vec);\n        \n        i += this_vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    size_t vl = svcntw();\n    size_t i = 0;\n    \n    while (i < l.size()) {\n        size_t chunk = std::min(vl, l.size() - i);\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        \n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        svbool_t positive_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        float buffer[chunk];\n        svst1_f32(positive_mask, buffer, vec);\n        \n        for (size_t j = 0; j < chunk; j++) {\n            if (svptest_first(svptrue_b32(), svcmpeq_n_f32(positive_mask, 1, j))) {\n                result.push_back(buffer[j]);\n            }\n        }\n        \n        i += chunk;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t i = 0;\n    size_t vl = svcntw();\n    \n    while (i < l.size()) {\n        size_t this_vl = std::min(vl, l.size() - i);\n        \n        // Load vector\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        \n        // Create mask for positive numbers\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Count positive numbers in this chunk\n        uint32_t pos_count = svcntp_b32(pg, pos_mask);\n        \n        // Compress vector to only positive numbers\n        svfloat32_t pos_vec = svcompact_f32(pos_mask, vec);\n        \n        // Resize result vector to fit new elements\n        size_t old_size = result.size();\n        result.resize(old_size + pos_count);\n        \n        // Store positive numbers\n        svst1_f32(svwhilelt_b32((uint64_t)0, (uint64_t)pos_count), \n                  &result[old_size], \n                  pos_vec);\n        \n        i += this_vl;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    \n    svbool_t pg = svwhilelt_b64(0, sqrt_n - 5);\n    \n    svint64_t indices = svindex_s64(0, 1);\n    svint64_t vec_6 = svdup_s64(6);\n    svint64_t start = svadd_z(pg, svmul_z(pg, indices, vec_6), svdup_s64(5));\n    \n    while (svptest_first(pg)) {\n        svint64_t i = start;\n        svint64_t i_plus_2 = svadd_z(pg, i, svdup_s64(2));\n        \n        svbool_t div_mask1 = svcmpeq_n_s64(pg, svdiv_z(pg, svdup_s64(n), i), 0);\n        svbool_t div_mask2 = svcmpeq_n_s64(pg, svdiv_z(pg, svdup_s64(n), i_plus_2), 0);\n        \n        if (svptest_any(pg, svorr_z(pg, div_mask1, div_mask2))) {\n            return false;\n        }\n        \n        start = svadd_z(pg, start, svmul_z(pg, vec_6, svdup_s64(svlen_s64())));\n        pg = svwhilelt_b64(svlen_s64(), sqrt_n - 5);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    \n    svbool_t pg = svwhilelt_b64(0, sqrt_n - 5);\n    \n    svint64_t indices = svindex_s64(0, 1);\n    svint64_t vec_6 = svdup_s64(6);\n    svint64_t start = svadd_z(pg, svmul_z(pg, indices, vec_6), svdup_s64(5));\n    \n    while (svptest_first(pg)) {\n        svint64_t i = start;\n        svint64_t i_plus_2 = svadd_z(pg, i, svdup_s64(2));\n        \n        svbool_t div_check = svorr_z(pg,\n            svcmpeq_n_s64(pg, svrem_z(pg, svdup_s64(n), i), 0),\n            svcmpeq_n_s64(pg, svrem_z(pg, svdup_s64(n), i_plus_2), 0)\n        );\n        \n        if (svptest_any(pg, div_check)) {\n            return false;\n        }\n        \n        indices = svadd_z(pg, indices, svdup_s64(1));\n        start = svadd_z(pg, svmul_z(pg, indices, vec_6), svdup_s64(5));\n        pg = svwhilelt_b64(svcntd() * svlasta(pg, indices), sqrt_n - 5);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = (int64_t)sqrt(n);\n    \n    svbool_t pg = svwhilelt_b64(0, sqrt_n - 5);\n    \n    svint64_t indices = svindex_s64(0, 1);\n    svint64_t vec_6 = svdup_s64(6);\n    svint64_t start = svadd_z(pg, svmul_z(pg, indices, vec_6), svdup_s64(5));\n    \n    while (svptest_first(pg, pg)) {\n        svint64_t i = start;\n        svint64_t i_plus_1 = svadd_z(pg, i, svdup_s64(1));\n        \n        svbool_t div_i = svcmpeq_n_s64(pg, svdiv_z(pg, svdup_n_s64(n), i), 0);\n        svbool_t div_i_plus_1 = svcmpeq_n_s64(pg, svdiv_z(pg, svdup_n_s64(n), i_plus_1), 0);\n        \n        if (svptest_any(pg, div_i) || svptest_any(pg, div_i_plus_1)) {\n            return false;\n        }\n        \n        start = svadd_z(pg, start, svmul_z(pg, vec_6, svlen_s64()));\n        pg = svwhilelt_b64(svlen_s64(), sqrt_n - 5);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    \n    svbool_t pg = svwhilelt_b64(0, sqrt_n - 5);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svint64_t indices = svindex_s64(0, 1);\n        svint64_t vec_i = svadd_x(pg, svmul_x(pg, indices, 6), 5);\n        \n        svbool_t div_check1 = svcmpeq_n_s64(pg, svrem_x(pg, n, vec_i), 0);\n        svbool_t div_check2 = svcmpeq_n_s64(pg, svrem_x(pg, n, svadd_x(pg, vec_i, 2)), 0);\n        \n        if (svptest_any(pg, svorr_z(pg, div_check1, div_check2))) {\n            return false;\n        }\n        \n        pg = svwhilelt_b64(svcntp_b64(svptrue_b64(), pg), sqrt_n - 5);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t sqrt_n = sqrt(n);\n    \n    svbool_t pg = svwhilelt_b64(0, sqrt_n - 5);\n    \n    svint64_t indices = svindex_s64(0, 1);\n    svint64_t fives = svdup_s64(5);\n    svint64_t sixes = svdup_s64(6);\n    \n    while (svptest_first(pg, pg)) {\n        svint64_t i = svadd_z(pg, fives, svmul_z(pg, sixes, indices));\n        svint64_t i_plus_2 = svadd_z(pg, i, svdup_s64(2));\n        \n        svbool_t div_by_i = svcmpeq_n_s64(pg, svdiv_z(pg, svdup_n_s64(n), i), 0);\n        svbool_t div_by_i_plus_2 = svcmpeq_n_s64(pg, svdiv_z(pg, svdup_n_s64(n), i_plus_2), 0);\n        \n        if (svptest_any(pg, svorr_z(pg, div_by_i, div_by_i_plus_2))) {\n            return false;\n        }\n        \n        indices = svadd_z(pg, indices, svdup_s64(1));\n        pg = svwhilelt_b64(svlen_s64(indices), sqrt_n - 5);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int n = s.length();\n    char* data = result.data();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    bool has_letters = false;\n    \n    while (svptest_first(pg, pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)data);\n        \n        // Check if character is a letter\n        svbool_t is_lower = svand_b_z(pg, \n            svand_b_z(pg, svge_u8(pg, chars, svdup_n_u8('a')),\n                         svle_u8(pg, chars, svdup_n_u8('z'))));\n                         \n        svbool_t is_upper = svand_b_z(pg, \n            svand_b_z(pg, svge_u8(pg, chars, svdup_n_u8('A')),\n                         svle_u8(pg, chars, svdup_n_u8('Z'))));\n                         \n        svbool_t is_letter = svorr_b_z(pg, is_lower, is_upper);\n        \n        if (svptest_any(pg, is_letter)) {\n            has_letters = true;\n            \n            // Convert case for letters\n            svuint8_t result_chars = svsel_u8(is_lower,\n                svsub_u8_x(pg, chars, svdup_n_u8(32)), // to upper\n                svsel_u8(is_upper,\n                    svadd_u8_x(pg, chars, svdup_n_u8(32)), // to lower\n                    chars)); // non-letters unchanged\n                    \n            svst1_u8(pg, (uint8_t*)data, result_chars);\n        }\n        \n        data += svcntb();\n        pg = svwhilelt_b8(svcntb(), n);\n    }\n    \n    // If no letters found, reverse the whole string\n    if (!has_letters) {\n        int left = 0;\n        int right = n - 1;\n        while (left < right) {\n            char temp = result[left];\n            result[left] = result[right];\n            result[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int n = s.length();\n    char* data = result.data();\n    \n    bool has_letters = false;\n    \n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        \n        svuint8_t chars = svld1_u8(pg, (uint8_t*)data + i);\n        \n        // Check if character is a letter\n        svbool_t is_upper = svand_z(pg, \n            svcmpge_u8(pg, chars, svdup_n_u8('A')),\n            svcmple_u8(pg, chars, svdup_n_u8('Z'))\n        );\n        \n        svbool_t is_lower = svand_z(pg,\n            svcmpge_u8(pg, chars, svdup_n_u8('a')), \n            svcmple_u8(pg, chars, svdup_n_u8('z'))\n        );\n        \n        svbool_t is_letter = svorr_z(pg, is_upper, is_lower);\n        \n        if (svptest_any(pg, is_letter)) {\n            has_letters = true;\n            \n            // Convert uppercase to lowercase by adding 32\n            svuint8_t upper_to_lower = svadd_m(pg, chars, is_upper, svdup_n_u8(32));\n            \n            // Convert lowercase to uppercase by subtracting 32  \n            svuint8_t result_chars = svsub_m(pg, upper_to_lower, is_lower, svdup_n_u8(32));\n            \n            svst1_u8(pg, (uint8_t*)data + i, result_chars);\n        }\n    }\n    \n    if (!has_letters) {\n        std::reverse(result.begin(), result.end());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int n = s.length();\n    char* data = result.data();\n    \n    bool has_letters = false;\n    \n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        \n        svuint8_t vec = svld1_u8(pg, (uint8_t*)data + i);\n        \n        // Check if character is a letter\n        svbool_t is_upper = svcmpge_n_u8(pg, vec, 'A') && svcmple_n_u8(pg, vec, 'Z');\n        svbool_t is_lower = svcmpge_n_u8(pg, vec, 'a') && svcmple_n_u8(pg, vec, 'z');\n        svbool_t is_letter = svorr_b_z(pg, is_upper, is_lower);\n        \n        if (svptest_any(pg, is_letter))\n            has_letters = true;\n            \n        // Convert uppercase to lowercase\n        svuint8_t upper_to_lower = svadd_m_n_u8(pg, vec, 32, is_upper);\n        \n        // Convert lowercase to uppercase  \n        svuint8_t case_converted = svsub_m_n_u8(pg, upper_to_lower, 32, is_lower);\n        \n        svst1_u8(pg, (uint8_t*)data + i, case_converted);\n    }\n    \n    if (!has_letters) {\n        int left = 0, right = n - 1;\n        while (left < right) {\n            std::swap(data[left], data[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int n = s.length();\n    char* data = result.data();\n    \n    bool has_letters = false;\n    \n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        \n        svuint8_t chars = svld1_u8(pg, (uint8_t*)data + i);\n        \n        // Check if character is a letter\n        svbool_t is_upper = svand_z(pg, \n            svcmpge_n_u8(pg, chars, 'A'),\n            svcmple_n_u8(pg, chars, 'Z')\n        );\n        \n        svbool_t is_lower = svand_z(pg,\n            svcmpge_n_u8(pg, chars, 'a'), \n            svcmple_n_u8(pg, chars, 'z')\n        );\n        \n        svbool_t is_letter = svorr_z(pg, is_upper, is_lower);\n        \n        // Convert case for letters\n        svuint8_t upper_to_lower = svadd_n_u8_m(is_upper, chars, 32);\n        svuint8_t lower_to_upper = svsub_n_u8_m(is_lower, chars, 32);\n        \n        // Merge results\n        chars = svsel(is_upper, upper_to_lower, chars);\n        chars = svsel(is_lower, lower_to_upper, chars);\n        \n        // Store back\n        svst1_u8(pg, (uint8_t*)data + i, chars);\n        \n        // Check if we found any letters\n        if (svptest_any(pg, is_letter))\n            has_letters = true;\n    }\n    \n    // If no letters found, reverse the whole string\n    if (!has_letters) {\n        int left = 0;\n        int right = n - 1;\n        while (left < right) {\n            std::swap(data[left], data[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\nstd::string solve_simd(const std::string& s) {\n    std::string result = s;\n    int n = s.length();\n    char* data = result.data();\n    \n    bool has_letters = false;\n    \n    for (int i = 0; i < n; i += svcntb()) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        \n        svuint8_t chars = svld1_u8(pg, (uint8_t*)data + i);\n        \n        // Check if character is a letter\n        svbool_t is_lower = svand_b_z(pg, \n            svand_b_z(pg, svge_u8(chars, svdup_n_u8('a')), svle_u8(chars, svdup_n_u8('z'))));\n            \n        svbool_t is_upper = svand_b_z(pg,\n            svand_b_z(pg, svge_u8(chars, svdup_n_u8('A')), svle_u8(chars, svdup_n_u8('Z'))));\n            \n        svbool_t is_letter = svorr_b_z(pg, is_lower, is_upper);\n        \n        if (svptest_any(pg, is_letter))\n            has_letters = true;\n            \n        // Convert case for letters\n        svuint8_t converted = svsel_u8(is_lower,\n            svsub_u8_z(pg, chars, svdup_n_u8(32)), // to upper\n            svadd_u8_z(pg, chars, svdup_n_u8(32))); // to lower\n            \n        svuint8_t result_chars = svsel_u8(is_letter, converted, chars);\n        \n        svst1_u8(pg, (uint8_t*)data + i, result_chars);\n    }\n    \n    // If no letters found, reverse the string\n    if (!has_letters) {\n        int left = 0;\n        int right = n - 1;\n        while (left < right) {\n            std::swap(data[left], data[right]);\n            left++;\n            right--;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Copy input to result\n    for(size_t i = 0; i < n; i++) {\n        result[i] = l[i];\n    }\n\n    // Count elements at indices divisible by 3\n    size_t third_count = (n + 2) / 3;\n    std::vector<int> thirds(third_count);\n    \n    // Extract elements at indices divisible by 3\n    size_t j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        thirds[j++] = l[i];\n    }\n\n    // Sort the extracted elements using SVE\n    size_t vl = svcntw();\n    for(size_t i = 0; i < third_count; i += vl) {\n        size_t this_vl = (third_count - i < vl) ? third_count - i : vl;\n        \n        svbool_t pg = svwhilelt_b32(i, third_count);\n        svint32_t v = svld1_s32(pg, &thirds[i]);\n        \n        // Bubble sort within vector\n        for(size_t k = 0; k < this_vl; k++) {\n            for(size_t m = 0; m < this_vl-k-1; m++) {\n                svbool_t cmp = svcmpgt_s32(pg, \n                    svdup_s32(svextw_s32_x(pg, v, m)),\n                    svdup_s32(svextw_s32_x(pg, v, m+1)));\n                \n                svint32_t tmp = v;\n                v = svsel_s32(cmp,\n                    svtrn1_s32(svext_s32(v, v, 1), v),\n                    v);\n            }\n        }\n        \n        svst1_s32(pg, &thirds[i], v);\n    }\n\n    // Put sorted elements back at indices divisible by 3\n    j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        result[i] = thirds[j++];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Calculate number of elements divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    \n    // Extract elements at indices divisible by 3\n    size_t j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        thirds[j++] = l[i];\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Copy non-divisible-by-3 elements directly\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    do {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t vec = svld1_s32(pg, l.data());\n        svint32_t mod3 = svdiv_n_s32_z(pg, svmul_n_s32_z(pg, svdiv_n_s32_z(pg, indices, 3), 3), 1);\n        svbool_t not_div3_mask = svcmpne_n_s32(pg, mod3, indices);\n        \n        svst1_s32(not_div3_mask, result.data(), vec);\n        \n        l = std::vector<int>(l.begin() + svcntw(), l.end());\n        result = std::vector<int>(result.begin() + svcntw(), result.end());\n        pg = svwhilelt_b32(0, l.size());\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    // Insert sorted elements at indices divisible by 3\n    j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        result[i] = thirds[j++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Calculate number of elements divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    \n    // Extract elements at indices divisible by 3\n    size_t j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        thirds[j++] = l[i];\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Copy non-divisible-by-3 elements directly\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    do {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t mod3 = svdiv_n_s32_z(pg, indices, 3);\n        mod3 = svmul_n_s32_z(pg, mod3, 3);\n        svbool_t not_div3 = svcmpne_s32(pg, indices, mod3);\n        \n        svint32_t src = svld1_s32(pg, &l[0]);\n        svst1_s32(not_div3, &result[0], src);\n        \n        l = std::vector<int>(l.begin() + svcntw(), l.end());\n        result = std::vector<int>(result.begin() + svcntw(), result.end());\n        pg = svwhilelt_b32(0, l.size());\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    // Copy sorted elements to indices divisible by 3\n    j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        result[i] = thirds[j++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Copy input to result\n    svbool_t pg = svwhilelt_b32(0, n);\n    svst1_s32(pg, result.data(), svld1_s32(pg, l.data()));\n    \n    // Count elements at indices divisible by 3\n    size_t third_count = (n + 2) / 3;\n    std::vector<int> thirds(third_count);\n    \n    // Extract elements at indices divisible by 3\n    size_t j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        if(i < n) {\n            thirds[j++] = l[i];\n        }\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.end());\n    \n    // Put sorted elements back\n    j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        if(i < n) {\n            result[i] = thirds[j++];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    \n    // Calculate number of elements divisible by 3\n    size_t third_size = (n + 2) / 3;\n    std::vector<int> thirds(third_size);\n    \n    // Extract elements at indices divisible by 3\n    size_t j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        thirds[j++] = l[i];\n    }\n    \n    // Sort the extracted elements\n    std::sort(thirds.begin(), thirds.begin() + j);\n    \n    // Copy non-divisible-by-3 elements directly\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    do {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t vec = svld1_s32(pg, l.data());\n        svint32_t mod3 = svrem_x(pg, indices, 3);\n        svbool_t not_div3 = svcmpne_n_s32(pg, mod3, 0);\n        \n        svst1_s32(not_div3, result.data(), vec);\n        \n        l.data() += svcntw();\n        result.data() += svcntw();\n    } while(svptest_any(pg, pg));\n    \n    // Put back sorted elements at indices divisible by 3\n    j = 0;\n    for(size_t i = 0; i < n; i += 3) {\n        result[i] = thirds[j++];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t len = l.size();\n    float* data = l.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    svfloat32_t max_vec = svdup_f32(max_val);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n    }\n    \n    return svmaxv_f32(svptrue_b32(), max_vec);\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    float* data = l.data();\n    size_t len = l.size();\n    \n    svfloat32_t max_vec = svdup_f32(data[0]);\n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n    }\n    \n    return svmaxv_f32(svptrue_b32(), max_vec);\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    float* data = l.data();\n    size_t len = l.size();\n    \n    svfloat32_t vec_max = svdup_f32(data[0]);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        size_t vl = svmin_n_u32(svcntw(), len - i);\n        svbool_t pg = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(pg, &data[i]);\n        vec_max = svmax_f32_z(pg, vec_max, vec);\n    }\n    \n    return svmaxv_f32(svptrue_b32(), vec_max);\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t len = l.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svfloat32_t max_vec = svdup_f32(max_val);\n\n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\nfloat max_element_simd(std::vector<float> l) {\n    float max_val = l[0];\n    size_t len = l.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svfloat32_t max_vec = svdup_f32(max_val);\n\n    while(svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &l[i]);\n        max_vec = svmax_f32_z(pg, max_vec, vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec_i = svindex_s32(i, 1);\n        \n        // Check divisibility by 11\n        svbool_t div11 = svcmpeq_n_s32(p, svrem_z(p, vec_i, 11), 0);\n        \n        // Check divisibility by 13  \n        svbool_t div13 = svcmpeq_n_s32(p, svrem_z(p, vec_i, 13), 0);\n        \n        // Combine conditions\n        svbool_t div = svorr_b_z(p, div11, div13);\n        \n        // Convert numbers to string to count 7s\n        svint32_t tens = svdiv_z(p, vec_i, 10);\n        svint32_t ones = svrem_z(p, vec_i, 10);\n        \n        svbool_t has7_ones = svcmpeq_n_s32(p, ones, 7);\n        svbool_t has7_tens = svcmpeq_n_s32(p, tens, 7);\n        \n        svbool_t has7 = svorr_b_z(p, has7_ones, has7_tens);\n        \n        // Final mask combining divisibility and contains 7\n        svbool_t final = svand_b_z(p, div, has7);\n        \n        // Count matches\n        count += (int)svcntp_b32(p, final);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        svint32_t vec_i = svindex_s32(i, 1);\n        \n        svbool_t div11 = svcmpeq_n_s32(p, svrem_z(p, vec_i, 11), 0);\n        svbool_t div13 = svcmpeq_n_s32(p, svrem_z(p, vec_i, 13), 0);\n        svbool_t div_either = svorr_b_z(p, div11, div13);\n        \n        svint32_t nums = svsel_s32(div_either, vec_i, svdup_n_s32(0));\n        \n        while (svptest_any(p, div_either)) {\n            svint32_t curr = svdup_n_s32(svlasta_s32(div_either, nums));\n            \n            while (curr[0] > 0) {\n                if (curr[0] % 10 == 7) count++;\n                curr[0] /= 10;\n            }\n            \n            nums = svsel_s32(div_either, \n                           svdup_n_s32(svlasta_s32(div_either, nums)), \n                           nums);\n            div_either = svnot_b_z(p, svcmpeq_n_s32(p, nums, 0));\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        svint32_t vec_i = svindex_s32(i, 1);\n        \n        svbool_t div11 = svcmpeq_n_s32(p, svmodv_s32_x(p, vec_i, 11), 0);\n        svbool_t div13 = svcmpeq_n_s32(p, svmodv_s32_x(p, vec_i, 13), 0);\n        svbool_t div_mask = svorr_b_z(p, div11, div13);\n        \n        svint32_t nums = svsel_s32(div_mask, vec_i, svdup_n_s32(0));\n        \n        while (svptest_any(p, div_mask)) {\n            svint32_t curr = svsel_s32(div_mask, nums, svdup_n_s32(0));\n            \n            svint32_t digits = curr;\n            while (svptest_any(p, svdup_n_s32(1))) {\n                svbool_t has_digits = svcmpgt_n_s32(p, digits, 0);\n                if (!svptest_any(p, has_digits)) break;\n                \n                svint32_t digit = svmodv_s32_x(p, digits, svdup_n_s32(10));\n                count += (int)svcntp_b32(p, svcmpeq_n_s32(p, digit, 7));\n                \n                digits = svdiv_n_s32_x(p, digits, 10);\n            }\n            \n            div_mask = svnot_b_z(p, div_mask);\n        }\n        \n        pg = p;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        svint32_t vec_i = svindex_s32(i, 1);\n        \n        svbool_t div11 = svcmpeq_n_s32(p, svrem_z(p, vec_i, 11), 0);\n        svbool_t div13 = svcmpeq_n_s32(p, svrem_z(p, vec_i, 13), 0);\n        svbool_t div_either = svorr_b_z(p, div11, div13);\n        \n        svint32_t nums = svsel_s32(div_either, vec_i, svdup_n_s32(0));\n        \n        while(svptest_any(p, div_either)) {\n            svint32_t curr = svdup_n_s32(svlasta_s32(div_either, nums));\n            \n            while(curr.s[0] > 0) {\n                if(curr.s[0] % 10 == 7) count++;\n                curr.s[0] /= 10;\n            }\n            \n            nums = svsel_s32(div_either, \n                           svdup_n_s32(0),\n                           nums);\n            div_either = svbic_b_z(p, div_either, div_either);\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (i = 0; i < n; i += svcntw()) {\n        svint32_t vec_i = svindex_s32(i, 1);\n        \n        svbool_t div11 = svcmpeq_n_s32(pg, svdiv_n_s32_z(pg, vec_i, 11), 0);\n        svbool_t div13 = svcmpeq_n_s32(pg, svdiv_n_s32_z(pg, vec_i, 13), 0);\n        svbool_t div_mask = svorr_b_z(pg, div11, div13);\n        \n        svint32_t nums = svsel_s32(div_mask, vec_i, svdup_n_s32(0));\n        \n        while (svptest_any(pg, div_mask)) {\n            svint32_t digit = svdiv_n_s32_z(pg, nums, 10);\n            svbool_t has_seven = svcmpeq_n_s32(pg, svand_n_s32_z(pg, nums, 10), 7);\n            count += (int)svcntp_b32(pg, has_seven);\n            nums = digit;\n        }\n        \n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create vector for even indices\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort even values\n    size_t even_size = even_values.size();\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < even_size; i++) {\n        for (size_t j = 0; j < even_size - i - 1; j += vl) {\n            size_t chunk = std::min(vl, even_size - j - 1);\n            \n            svbool_t pg = svwhilelt_b32(j, j + chunk);\n            \n            svfloat32_t v1 = svld1_f32(pg, &even_values[j]);\n            svfloat32_t v2 = svld1_f32(pg, &even_values[j + 1]);\n            \n            svbool_t cmp = svcmpgt_f32(pg, v1, v2);\n            \n            svfloat32_t temp = svsel_f32(cmp, v1, v2);\n            v2 = svsel_f32(cmp, v2, v1);\n            v1 = temp;\n            \n            svst1_f32(pg, &even_values[j], v1);\n            svst1_f32(pg, &even_values[j + 1], v2);\n        }\n    }\n\n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Create vector for even indices\n    std::vector<float> even;\n    for (size_t i = 0; i < n; i += 2) {\n        even.push_back(l[i]);\n    }\n    \n    // Sort even indices\n    size_t even_size = even.size();\n    float* even_ptr = even.data();\n    \n    for (size_t i = 0; i < even_size; i++) {\n        for (size_t j = i + 1; j < even_size; j++) {\n            svbool_t pg = svwhilelt_b32(0, 1);\n            svfloat32_t vi = svld1_f32(pg, &even_ptr[i]);\n            svfloat32_t vj = svld1_f32(pg, &even_ptr[j]);\n            svbool_t cmp = svcmpgt_f32(pg, vi, vj);\n            \n            if (svptest_any(pg, cmp)) {\n                float temp = even_ptr[i];\n                even_ptr[i] = even_ptr[j];\n                even_ptr[j] = temp;\n            }\n        }\n    }\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n\n    // Create vector for even indices\n    std::vector<float> even_values;\n    for (size_t i = 0; i < n; i += 2) {\n        even_values.push_back(l[i]);\n    }\n\n    // Sort even values\n    size_t even_size = even_values.size();\n    size_t vl = svcntw();\n\n    for (size_t i = 0; i < even_size; i++) {\n        for (size_t j = 0; j < even_size - i - 1; j += vl) {\n            size_t chunk = std::min(vl, even_size - j - 1);\n            \n            svbool_t pg = svwhilelt_b32(j, j + chunk);\n            \n            svfloat32_t v1 = svld1_f32(pg, &even_values[j]);\n            svfloat32_t v2 = svld1_f32(pg, &even_values[j + 1]);\n            \n            svbool_t cmp = svcmpgt_f32(pg, v1, v2);\n            \n            svfloat32_t temp = svsel_f32(cmp, v1, v2);\n            svst1_f32(pg, &even_values[j], svsel_f32(cmp, v2, v1));\n            svst1_f32(pg, &even_values[j + 1], temp);\n        }\n    }\n\n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even_values[even_idx++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Create vector for even indices\n    std::vector<float> even;\n    for (size_t i = 0; i < n; i += 2) {\n        even.push_back(l[i]);\n    }\n    \n    // Sort even indices\n    size_t even_size = even.size();\n    float* even_ptr = even.data();\n    \n    for (size_t i = 0; i < even_size; i++) {\n        for (size_t j = i + 1; j < even_size; j++) {\n            svbool_t pg = svwhilelt_b32(i, even_size);\n            svfloat32_t v1 = svld1_f32(pg, even_ptr + i);\n            svfloat32_t v2 = svld1_f32(pg, even_ptr + j);\n            \n            svbool_t cmp = svcmpgt_f32(pg, v1, v2);\n            if (svptest_any(pg, cmp)) {\n                float temp = even_ptr[i];\n                even_ptr[i] = even_ptr[j];\n                even_ptr[j] = temp;\n            }\n        }\n    }\n    \n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even[even_idx++];\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n <= 1) return l;\n    \n    // Create vector for even indices\n    std::vector<float> even;\n    for (size_t i = 0; i < n; i += 2) {\n        even.push_back(l[i]);\n    }\n\n    // Sort even indices using SVE\n    size_t even_size = even.size();\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < even_size; i++) {\n        for (size_t j = 0; j < even_size - i - 1; j += vl) {\n            size_t chunk = std::min(vl, even_size - j - 1);\n            \n            svbool_t pg = svwhilelt_b32(j, j + chunk);\n            \n            svfloat32_t v1 = svld1_f32(pg, &even[j]);\n            svfloat32_t v2 = svld1_f32(pg, &even[j + 1]);\n            \n            svbool_t cmp = svcmpgt_f32(pg, v1, v2);\n            \n            svfloat32_t temp = svsel_f32(cmp, v1, v2);\n            v2 = svsel_f32(cmp, v2, v1);\n            v1 = temp;\n            \n            svst1_f32(pg, &even[j], v1);\n            svst1_f32(pg, &even[j + 1], v2);\n        }\n    }\n\n    // Put sorted even values back\n    size_t even_idx = 0;\n    for (size_t i = 0; i < n; i += 2) {\n        l[i] = even[even_idx++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    const int n = l.size();\n    \n    for (int i = 0; i < n-2; i++) {\n        svbool_t pg = svwhilelt_b32(0, n-i-1);\n        \n        svint32_t v_i = svdup_n_s32(l[i]);\n        \n        for (int j = i+1; j < n-1; j++) {\n            svint32_t v_j = svdup_n_s32(l[j]);\n            \n            // Load remaining elements after j\n            svint32_t v_rem = svld1_s32(pg, &l[j+1]);\n            \n            // Calculate sum of pairs\n            svint32_t v_sum = svadd_s32_z(pg, v_i, v_j);\n            \n            // Check if negative of sum exists in remaining elements\n            svint32_t v_neg = svneg_s32_z(pg, v_sum);\n            svbool_t match = svcmpeq_s32(pg, v_rem, v_neg);\n            \n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    const int n = l.size();\n    \n    for (int i = 0; i < n-2; i++) {\n        int target = -l[i];\n        \n        // Get vector length\n        const int vl = svcntw();\n        \n        // Initialize indices for j loop\n        svbool_t pg = svwhilelt_b32(0, n-i-1);\n        \n        for (int j = i+1; j < n-1; j++) {\n            int remaining = -l[i] - l[j];\n            \n            // Create predicate for k loop\n            svbool_t pg_k = svwhilelt_b32(j+1, n);\n            \n            // Load vector of elements after j\n            svint32_t vec = svld1_s32(pg_k, &l[j+1]);\n            \n            // Compare with remaining\n            svbool_t match = svcmpeq_n_s32(pg_k, vec, remaining);\n            \n            // Check if any match found\n            if (svptest_any(pg_k, match)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    const int n = l.size();\n    \n    for (int i = 0; i < n-2; i++) {\n        svbool_t pg = svwhilelt_b32(0, n-i-1);\n        svint32_t v_i = svdup_n_s32(l[i]);\n        \n        for (int j = i+1; j < n-1; j++) {\n            svint32_t v_j = svdup_n_s32(l[j]);\n            \n            // Load remaining elements after j\n            svint32_t v_rem = svld1_s32(pg, &l[j+1]);\n            \n            // Calculate sum of pairs\n            svint32_t v_sum = svadd_s32_z(pg, v_i, v_j);\n            \n            // Check if negative of sum exists in remaining elements\n            svint32_t v_neg = svneg_s32_z(pg, v_sum);\n            svbool_t match = svcmpeq_s32(pg, v_rem, v_neg);\n            \n            if (svptest_any(pg, match)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    const int n = l.size();\n    \n    for (int i = 0; i < n-2; i++) {\n        int target = -l[i];\n        \n        // Get vector length\n        const int vl = svcntw();\n        \n        // Initialize indices for j and k\n        int j = i + 1;\n        int k = n - 1;\n        \n        while (j < k) {\n            // Calculate how many elements we can process\n            int elements = std::min(k - j, vl);\n            \n            // Load vectors\n            svbool_t pg = svwhilelt_b32(0, elements);\n            svint32_t vec_j = svld1_s32(pg, &l[j]);\n            \n            // Broadcast k value\n            svint32_t vec_k = svdup_n_s32(l[k]);\n            \n            // Calculate sums\n            svint32_t sums = svadd_s32_z(pg, vec_j, vec_k);\n            \n            // Compare with target\n            svbool_t matches = svcmpeq_s32(pg, sums, svdup_n_s32(target));\n            \n            // Check if we found any matches\n            if (svptest_any(pg, matches)) {\n                return true;\n            }\n            \n            // Update indices based on comparison\n            int sum = l[j] + l[k];\n            if (sum < target) {\n                j += elements;\n            } else {\n                k--;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    \n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-2; i++) {\n        int first = l[i];\n        \n        svbool_t pg = svwhilelt_b32(0, n-i-1);\n        \n        while (svptest_first(svptrue_b32(), pg)) {\n            svint32_t vec_j = svindex_s32(i+1, 1);\n            svint32_t vec_nums = svld1_s32(pg, &l[i+1]);\n            \n            svint32_t target = svdup_n_s32(-first);\n            \n            svbool_t pg2 = svwhilelt_b32(0, n-i-2);\n            while (svptest_first(svptrue_b32(), pg2)) {\n                svint32_t vec_k = svindex_s32(i+2, 1);\n                svint32_t vec_nums2 = svld1_s32(pg2, &l[i+2]);\n                \n                svint32_t sum = svadd_s32_z(pg2, vec_nums, vec_nums2);\n                svbool_t matches = svcmpeq_s32(pg2, sum, target);\n                \n                if (svptest_any(svptrue_b32(), matches)) {\n                    return true;\n                }\n                \n                pg2 = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg2), n-i-2);\n            }\n            \n            pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n-i-1);\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    int* src = l.data();\n    int* dst = result.data();\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    do {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t incremented = svadd_s32_z(pg, vec, 1);\n        svst1_s32(pg, dst + i, incremented);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    int* src = l.data();\n    int* dst = result.data();\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    do {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t inc = svadd_s32_z(pg, vec, 1);\n        svst1_s32(pg, dst + i, inc);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    int* src = l.data();\n    int* dst = result.data();\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    do {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t inc = svadd_s32_z(pg, vec, 1);\n        svst1_s32(pg, dst + i, inc);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    } while (svptest_any(svptrue_b32(), pg));\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    int* src = l.data();\n    int* dst = result.data();\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    do {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t incr = svadd_s32_z(pg, vec, 1);\n        svst1_s32(pg, dst + i, incr);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t len = l.size();\n    std::vector<int> result(len);\n    \n    int* src = l.data();\n    int* dst = result.data();\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    do {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t incr = svadd_s32_z(pg, vec, 1);\n        svst1_s32(pg, dst + i, incr);\n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    const int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (int i = 0; i < n-1; i++) {\n        int current = l[i];\n        int remaining = n - i - 1;\n        \n        svint32_t vec_current = svdup_n_s32(current);\n        \n        for (int j = 0; j < remaining; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, remaining);\n            \n            svint32_t vec_nums = svld1_s32(p, &l[i+1+j]);\n            svint32_t sums = svadd_s32_z(p, vec_current, vec_nums);\n            \n            svbool_t zero_found = svcmpeq_s32(p, sums, 0);\n            if (svptest_any(p, zero_found)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n    \n    const int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (int i = 0; i < n-1; i++) {\n        int curr = l[i];\n        int remaining = n - i - 1;\n        \n        svint32_t curr_vec = svdup_n_s32(curr);\n        \n        for (int j = 0; j < remaining; j += svcntw()) {\n            svbool_t pg_rem = svwhilelt_b32(j, remaining);\n            \n            svint32_t vec = svld1_s32(pg_rem, &l[i+1+j]);\n            svint32_t sum = svadd_s32_z(pg_rem, curr_vec, vec);\n            \n            svbool_t cmp = svcmpeq_s32(pg_rem, sum, svdup_n_s32(0));\n            if (svptest_any(pg_rem, cmp)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    size_t vl = svcntw();\n    size_t n = l.size();\n    \n    for (size_t i = 0; i < n-1; i++) {\n        size_t j = i + 1;\n        \n        while (j < n) {\n            size_t elements = std::min(vl, n - j);\n            \n            svbool_t pg = svwhilelt_b32(0, elements);\n            svint32_t v1 = svdup_n_s32(l[i]);\n            svint32_t v2 = svld1_s32(pg, &l[j]);\n            \n            svint32_t sum = svadd_s32_z(pg, v1, v2);\n            svbool_t cmp = svcmpeq_s32(pg, sum, svdup_n_s32(0));\n            \n            if (svptest_any(pg, cmp)) {\n                return true;\n            }\n            \n            j += elements;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    const int n = l.size();\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    for (int i = 0; i < n-1; i++) {\n        int current = l[i];\n        int remaining = n - i - 1;\n        \n        svint32_t vec_current = svdup_n_s32(current);\n        \n        for (int j = 0; j < remaining; j += svcntw()) {\n            svbool_t p = svwhilelt_b32(j, remaining);\n            \n            svint32_t vec_others = svld1_s32(p, &l[i+1+j]);\n            svint32_t vec_sum = svadd_s32_z(p, vec_current, vec_others);\n            \n            svbool_t zero_found = svcmpeq_s32(p, vec_sum, 0);\n            \n            if (svptest_any(p, zero_found)) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    if (l.size() < 2) return false;\n\n    size_t vl = svcntw();\n    size_t i, j;\n    \n    for (i = 0; i < l.size() - 1; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, l.size() - 1);\n        svint32_t v1 = svld1_s32(pg, &l[i]);\n        \n        for (j = i + 1; j < l.size(); j += vl) {\n            svbool_t pg2 = svwhilelt_b32(j, l.size());\n            svint32_t v2 = svld1_s32(pg2, &l[j]);\n            \n            // Compare each element in v1 with each element in v2\n            svbool_t pg_active = svand_b_z(pg, pg2);\n            \n            // For each element in v1\n            for (size_t k = i; k < std::min(i + vl, l.size() - 1); k++) {\n                svint32_t broadcast = svdup_n_s32(l[k]);\n                svint32_t sum = svadd_s32_z(pg_active, broadcast, v2);\n                svbool_t match = svcmpeq_s32(pg_active, sum, svdup_n_s32(0));\n                \n                if (svptest_any(pg_active, match)) {\n                    return true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    // Get vector length\n    const uint64_t vl = svcntd();\n    \n    // Create vector registers\n    svbool_t pg = svptrue_b64();\n    svint64_t vec_x = svdup_n_s64(x);\n    svint64_t vec_base = svdup_n_s64(base);\n    \n    while (x > 0) {\n        // Calculate remainder for each element\n        svint64_t vec_rem = svrem_x(pg, vec_x, vec_base);\n        \n        // Get remainder and convert to char\n        int64_t rem = svlasta_s64(pg, vec_rem);\n        result = (char)(rem + '0') + result;\n        \n        // Divide x by base\n        x /= base;\n        vec_x = svdup_n_s64(x);\n    }\n    \n    if (negative) {\n        result = \"-\" + result;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    std::string result;\n    bool negative = x < 0;\n    x = std::abs(x);\n\n    // Get vector length\n    const int vl = svcntd();\n    \n    // Create vector registers\n    svint64_t vec_x = svdup_n_s64(x);\n    svint64_t vec_base = svdup_n_s64(base);\n    svbool_t pred = svptrue_b64();\n    \n    while (x > 0) {\n        // Calculate remainder using vector operations\n        svint64_t vec_rem = svrem_x(pred, vec_x, vec_base);\n        int64_t remainder = svlasta_s64(pred, vec_rem);\n        \n        // Add digit to result\n        result = char('0' + remainder) + result;\n        \n        // Update x for next iteration\n        x /= base;\n        vec_x = svdup_n_s64(x);\n    }\n    \n    if (negative) {\n        result = \"-\" + result;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Get vector length\n    const uint64_t vl = svcntd();\n    \n    // Create vector of base values\n    svint64_t vec_base = svdup_s64(base);\n    \n    // Create vector of input x\n    svint64_t vec_x = svdup_s64(x);\n    \n    while (x > 0) {\n        // Create predicate for active lanes\n        svbool_t pred = svwhilelt_b64(0, vl);\n        \n        // Calculate remainders\n        svint64_t vec_rem = svdiv_z(pred, vec_x, vec_base);\n        vec_rem = svmls_z(pred, vec_x, vec_rem, vec_base);\n        \n        // Store remainder\n        int64_t rem = svlasta(pred, vec_rem);\n        digits[idx++] = rem + '0';\n        \n        // Update x\n        x /= base;\n        vec_x = svdup_s64(x);\n    }\n    \n    // Reverse the digits\n    std::string result;\n    for(int i = idx-1; i >= 0; i--) {\n        result += digits[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Get vector length\n    const uint64_t vl = svcntd();\n    \n    // Create vector registers\n    svbool_t pg = svptrue_b64();\n    svint64_t vec_x = svdup_n_s64(x);\n    svint64_t vec_base = svdup_n_s64(base);\n    \n    while (x > 0) {\n        // Calculate remainders in parallel\n        svint64_t vec_rem = svrem_x(pg, vec_x, vec_base);\n        \n        // Store remainder\n        int64_t rem;\n        svst1_s64(pg, &rem, vec_rem);\n        digits[idx++] = '0' + rem;\n        \n        // Update x\n        x /= base;\n        vec_x = svdup_n_s64(x);\n    }\n    \n    // Reverse the string\n    std::string result;\n    for(int i = idx-1; i >= 0; i--) {\n        result += digits[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) return \"0\";\n    \n    char digits[64];\n    int idx = 0;\n    \n    // Get vector length\n    const uint64_t vl = svcntd();\n    \n    // Create vector of base values\n    svint64_t vbase = svdup_n_s64(base);\n    \n    // Create vector of x values\n    svint64_t vx = svdup_n_s64(x);\n    \n    // Create predicate for active lanes\n    svbool_t pred = svptrue_b64();\n    \n    while (x > 0) {\n        // Calculate remainders in parallel\n        svint64_t vrem = svdiv_x(pred, vx, vbase);\n        vrem = svmls_x(pred, vx, vrem, vbase);\n        \n        // Store remainder\n        int64_t rem = svlasta_s64(pred, vrem);\n        digits[idx++] = rem + '0';\n        \n        // Update x\n        x /= base;\n        vx = svdup_n_s64(x);\n    }\n    \n    // Reverse the digits\n    std::string result;\n    for(int i = idx-1; i >= 0; i--) {\n        result += digits[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    int left = 0;\n    int right = len - 1;\n\n    while (left < right) {\n        svbool_t pg = svwhilelt_b8(left, right + 1);\n        \n        // Load characters from both ends\n        svuint8_t v_left = svld1_u8(pg, (uint8_t*)&str[left]);\n        \n        // Create reversed indices for right side\n        svuint8_t v_right = svld1_u8(pg, (uint8_t*)&str[right - svcntb() + 1]);\n        v_right = svrev_u8(v_right);\n\n        // Compare characters\n        svbool_t neq = svcmpne_u8(pg, v_left, v_right);\n        \n        // If any characters don't match, return false\n        if (svptest_any(pg, neq)) {\n            return false;\n        }\n\n        // Update indices\n        int vl = svcntb();\n        left += vl;\n        right -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const char* str = text.c_str();\n    size_t len = text.length();\n    \n    if (len <= 1) return true;\n    \n    const char* left = str;\n    const char* right = str + len - 1;\n    \n    while (left < right) {\n        svbool_t pg = svwhilelt_b8(0, right - left + 1);\n        \n        svuint8_t vl = svld1_u8(pg, (uint8_t*)left);\n        \n        // Load right side in reverse order\n        svuint8_t vr = svld1_u8(pg, (uint8_t*)right - svcntb() + 1);\n        vr = svrev_u8(vr);\n        \n        svbool_t cmp = svcmpeq_u8(pg, vl, vr);\n        \n        if (!svptest_first(pg, cmp))\n            return false;\n            \n        size_t inc = svcntb();\n        left += inc;\n        right -= inc;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) return true;\n    \n    const char* str = text.c_str();\n    size_t len = text.length();\n    size_t half_len = len / 2;\n    \n    for (size_t i = 0; i < half_len; i += svcntb()) {\n        size_t vl = svcntb();\n        if (i + vl > half_len) {\n            vl = half_len - i;\n        }\n        \n        svbool_t pg = svwhilelt_b8(i, half_len);\n        \n        svuint8_t v1 = svld1_u8(pg, (uint8_t*)&str[i]);\n        svuint8_t v2 = svld1_u8(pg, (uint8_t*)&str[len-i-vl]);\n        \n        svuint8_t rev = svrevb_u8_x(pg, v2);\n        \n        svbool_t cmp = svcmpeq_u8(pg, v1, rev);\n        if (!svptest_first(svptrue_b8(), cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    size_t i = 0;\n    size_t j = len - 1;\n\n    while (i < j) {\n        size_t remaining = j - i + 1;\n        svbool_t pg = svwhilelt_b8(i, remaining);\n\n        svuint8_t v1 = svld1_u8(pg, (uint8_t*)&str[i]);\n        \n        // Load characters from end in reverse\n        svuint8_t v2 = svld1_u8(pg, (uint8_t*)&str[j - svcntb() + 1]);\n        v2 = svrev_u8(v2);\n\n        svbool_t cmp = svcmpeq_u8(pg, v1, v2);\n        if (!svptest_first(pg, cmp)) {\n            return false;\n        }\n\n        size_t vl = svcntb();\n        i += vl;\n        j -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len <= 1) return true;\n\n    const char* str = text.c_str();\n    int left = 0;\n    int right = len - 1;\n\n    while (left < right) {\n        svbool_t pg = svwhilelt_b8(left, right + 1);\n        if (!svptest_any(pg, pg)) break;\n\n        svuint8_t v_left = svld1_u8(pg, (uint8_t*)&str[left]);\n        \n        // Load right side in reverse\n        svuint8_t v_right = svld1_u8(pg, (uint8_t*)&str[right - svcntb() + 1]);\n        v_right = svrev_u8(v_right);\n\n        svbool_t cmp = svcmpeq_u8(pg, v_left, v_right);\n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n\n        int vl = svcntb();\n        left += vl;\n        right -= vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    \n    int i = 0;\n    svbool_t pg = svwhilelt_b8(i, s.length());\n    \n    while(svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)&s[i]);\n        \n        // Subtract 5 from each char\n        svint8_t decoded = svsub_s8_z(pg, chars, 5);\n        \n        // Handle wrap around for values < 'a'\n        svbool_t wrap = svcmplt_n_s8(pg, decoded, 'a');\n        decoded = svadd_m(pg, decoded, wrap, 26);\n        \n        // Store result\n        svst1_s8(pg, (int8_t*)&out[i], decoded);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, s.length());\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), '\\0');\n    \n    int i = 0;\n    svbool_t pg = svwhilelt_b8(i, s.length());\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)&s[i]);\n        \n        // Subtract 5 from each char\n        svint8_t decoded = svsub_n_s8_z(pg, chars, 5);\n        \n        // Handle wraparound for chars that go below 'a'\n        svbool_t wrap = svcmplt_n_s8(pg, decoded, 'a');\n        decoded = svadd_n_s8_m(wrap, decoded, 26);\n        \n        // Store result\n        svst1_s8(pg, (int8_t*)&out[i], decoded);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, s.length());\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    \n    svbool_t pg = svwhilelt_b8(0, s.length());\n    size_t i = 0;\n    \n    while(svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)&s[i]);\n        \n        // Subtract 5 from each char\n        svint8_t decoded = svsub_n_s8_z(pg, chars, 5);\n        \n        // Handle wrap around for values < 'a'\n        svbool_t wrap = svcmplt_n_s8(pg, decoded, 'a');\n        decoded = svadd_m(pg, decoded, wrap, 26);\n        \n        // Store results\n        svst1_s8(pg, (int8_t*)&out[i], decoded);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, s.length());\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    \n    svbool_t pg = svwhilelt_b8(0, s.length());\n    size_t i = 0;\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)&s[i]);\n        \n        // Subtract 5 from each character\n        svint8_t decoded = svsub_n_s8_z(pg, chars, 5);\n        \n        // Handle wrap-around for characters that go below 'a'\n        svbool_t wrap = svcmplt_n_s8(pg, decoded, 'a');\n        decoded = svadd_m(pg, decoded, wrap, 26);\n        \n        // Store result\n        svst1_s8(pg, (int8_t*)&out[i], decoded);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, s.length());\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), 0);\n    \n    svbool_t pg = svwhilelt_b8(0, s.length());\n    size_t i = 0;\n    \n    while(svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)&s[i]);\n        \n        // Subtract 5 from each char\n        svint8_t decoded = svsub_n_s8_z(pg, chars, 5);\n        \n        // Handle wrap-around for values < 'a'\n        svbool_t needs_wrap = svcmplt_n_s8(pg, decoded, 'a');\n        svint8_t wrapped = svadd_n_s8_m(needs_wrap, decoded, 26);\n        \n        // Store results\n        svst1_s8(pg, (int8_t*)&out[i], wrapped);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, s.length());\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    const int* ptr = l.data();\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec = svld1_s32(pg, ptr);\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        \n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n        \n        ptr += svcntw();\n        pg = svwhilelt_b32(ptr - l.data(), n);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    const int* data = l.data();\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svbool_t all_below = svdup_b32(true);\n    \n    while(svptest_first(pg, all_below)) {\n        svint32_t vec = svld1_s32(pg, data);\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        all_below = svand_b_z(pg, all_below, cmp);\n        data += svcntw();\n        pg = svwhilelt_b32(data - l.data(), n);\n    }\n    \n    return svptest_first(svptrue_b32(), all_below);\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    const int* data = l.data();\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec = svld1_s32(pg, data);\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        \n        if (!svptest_all(pg, cmp)) {\n            return false;\n        }\n        \n        data += svcntw();\n        pg = svwhilelt_b32(data - l.data(), n);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    const int* data = l.data();\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    bool result = true;\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svint32_t vec = svld1_s32(pg, &data[i]);\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        if (!svptest_all(pg, cmp)) {\n            result = false;\n            break;\n        }\n        pg = svwhilelt_b32(i + svcntw(), n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    const int* data = l.data();\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svbool_t all_below = svdup_b32(true);\n    \n    while(svptest_first(pg, all_below)) {\n        svint32_t vec = svld1_s32(pg, data);\n        svbool_t cmp = svcmplt_s32(pg, vec, t);\n        all_below = svand_b_z(pg, all_below, cmp);\n        data += svcntw();\n        pg = svwhilelt_b32(data - l.data(), n);\n    }\n    \n    return svptest_last(svptrue_b32(), all_below);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count '<' as +1 and '>' as -1\n        svint8_t ones = svdup_n_s8(1);\n        svint8_t neg_ones = svdup_n_s8(-1);\n        svint8_t zeros = svdup_n_s8(0);\n        \n        svbool_t is_open = svcmpeq_n_s8(pg, vec, '<');\n        svbool_t is_close = svcmpeq_n_s8(pg, vec, '>');\n        \n        svint8_t counts = svsel_s8(is_open, ones, \n                          svsel_s8(is_close, neg_ones, zeros));\n                          \n        count += svaddv_s8(pg, counts);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), n);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count '<' as +1 and '>' as -1\n        svint8_t is_open = svcmpeq_n_s8(pg, vec, '<');\n        svint8_t is_close = svcmpeq_n_s8(pg, vec, '>');\n        \n        svint8_t ones = svdup_n_s8(1);\n        svint8_t neg_ones = svdup_n_s8(-1);\n        \n        svint8_t open_vals = svand_z(pg, is_open, ones);\n        svint8_t close_vals = svand_z(pg, is_close, neg_ones);\n        \n        svint8_t sum_vec = svadd_z(pg, open_vals, close_vals);\n        \n        // Add up all values in vector\n        int partial_sum = svaddv(pg, sum_vec);\n        count += partial_sum;\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), len);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_any(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count '<' as +1 and '>' as -1\n        svint8_t inc = svcmplt_n_s8(pg, vec, '>');  // '<' becomes -1, '>' becomes 0\n        svint8_t dec = svcmpeq_n_s8(pg, vec, '>');  // '>' becomes -1, '<' becomes 0\n        \n        // Update running count\n        count += svcntp_b8(pg, inc); // Count number of '<'\n        count -= svcntp_b8(pg, dec); // Subtract number of '>'\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), n);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count '<' as +1 and '>' as -1\n        svint8_t ones = svdup_n_s8(1);\n        svint8_t neg_ones = svdup_n_s8(-1);\n        svint8_t zeros = svdup_n_s8(0);\n        \n        svint8_t inc = svsel_s8(svcmpeq_s8(pg, vec, svdup_n_s8('<')), ones, zeros);\n        svint8_t dec = svsel_s8(svcmpeq_s8(pg, vec, svdup_n_s8('>')), neg_ones, zeros);\n        svint8_t changes = svadd_s8_x(pg, inc, dec);\n        \n        // Sum up the changes\n        count += svaddv_s8(pg, changes);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), n);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int count = 0;\n    const char* str = brackets.c_str();\n    const int len = brackets.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count '<' as +1 and '>' as -1\n        svint8_t is_open = svcmpeq_n_s8(pg, vec, '<');\n        svint8_t is_close = svcmpeq_n_s8(pg, vec, '>');\n        \n        svint8_t ones = svdup_n_s8(1);\n        svint8_t neg_ones = svdup_n_s8(-1);\n        \n        svint8_t changes = svsel_s8(is_open, ones, \n                          svsel_s8(is_close, neg_ones, svdup_n_s8(0)));\n        \n        // Sum the changes\n        count += svaddv_s8(pg, changes);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), len);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int count = 0;\n    const char* str = brackets.c_str();\n    int len = brackets.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count opening brackets\n        svbool_t is_open = svcmpeq_n_s8(pg, vec, '(');\n        count += svcntp_b8(pg, is_open);\n        \n        // Count closing brackets\n        svbool_t is_close = svcmpeq_n_s8(pg, vec, ')'); \n        count -= svcntp_b8(pg, is_close);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), len);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count opening brackets\n        svint8_t open_mask = svcmpeq_n_s8(pg, vec, '(');\n        count += svcntp_b8(pg, open_mask);\n        \n        // Count closing brackets\n        svint8_t close_mask = svcmpeq_n_s8(pg, vec, ')'); \n        count -= svcntp_b8(pg, close_mask);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), n);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    const size_t len = brackets.length();\n    if (len == 0) return true;\n    if (len % 2) return false;\n\n    int count = 0;\n    const char* data = brackets.c_str();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)&data[i]);\n        \n        // Count opening brackets as +1 and closing as -1\n        svint8_t is_open = svcmpeq_n_s8(pg, vec, '(');\n        svint8_t is_close = svcmpeq_n_s8(pg, vec, ')');\n        \n        svint8_t ones = svdup_n_s8(1);\n        svint8_t neg_ones = svdup_n_s8(-1);\n        \n        svint8_t changes = svadd_m_s8(pg,\n            svmul_m_s8(pg, is_open, ones),\n            svmul_m_s8(pg, is_close, neg_ones)\n        );\n        \n        // Sum the changes\n        count += svaddv_s8(pg, changes);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_any(pg, pg)) {\n        svint8_t vec = svld1_s8(pg, (int8_t*)str);\n        \n        // Count opening brackets\n        svint8_t open_mask = svcmpeq_n_s8(pg, vec, '(');\n        count += svcntp_b8(pg, open_mask);\n        \n        // Count closing brackets\n        svint8_t close_mask = svcmpeq_n_s8(pg, vec, ')'); \n        count -= svcntp_b8(pg, close_mask);\n        \n        // Check if count goes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), n);\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\nbool correct_bracketing_simd(std::string brackets) {\n    int n = brackets.length();\n    if (n == 0) return true;\n    if (n % 2) return false;\n\n    int count = 0;\n    const char* str = brackets.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)str);\n        \n        // Count opening brackets\n        svint8_t open_mask = svcmpeq_n_s8(pg, chars, '(');\n        count += svcntp_b8(pg, open_mask);\n        \n        // Count closing brackets\n        svint8_t close_mask = svcmpeq_n_s8(pg, chars, ')'); \n        count -= svcntp_b8(pg, close_mask);\n        \n        // Early exit if count becomes negative\n        if (count < 0) return false;\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - brackets.c_str(), n);\n    }\n    \n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    svbool_t pg = svwhilelt_b32(0, result.size());\n    \n    // Create vector of indices [1,2,3,...]\n    svfloat32_t indices = svindex_f32(1, 1);\n    \n    // Load input coefficients (skip first element)\n    svfloat32_t coeffs = svld1_f32(pg, xs.data() + 1);\n    \n    // Multiply coefficients by their indices\n    svfloat32_t derivatives = svmul_f32_z(pg, coeffs, indices);\n    \n    // Store results\n    svst1_f32(pg, result.data(), derivatives);\n\n    // Handle remaining elements\n    svuint64_t vl = svcntw();\n    size_t processed = svcnth();\n    \n    while (processed < result.size()) {\n        pg = svwhilelt_b32(processed, result.size());\n        indices = svindex_f32(processed + 1, 1); \n        coeffs = svld1_f32(pg, xs.data() + processed + 1);\n        derivatives = svmul_f32_z(pg, coeffs, indices);\n        svst1_f32(pg, result.data() + processed, derivatives);\n        processed += svcntw();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    // Get vector length\n    const int vl = svcntw();\n    \n    // Create index vector [0,1,2,...]\n    svuint32_t indices = svindex_u32(0, 1);\n    \n    // Process vectors\n    for (size_t i = 0; i < result.size(); i += vl) {\n        // Calculate how many elements remain\n        size_t this_vl = std::min(vl, (int)(result.size() - i));\n        \n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b32(i, result.size());\n        \n        // Load coefficients\n        svfloat32_t coef = svld1_f32(pred, &xs[i+1]);\n        \n        // Get current indices for this chunk\n        svuint32_t curr_indices = svadd_u32_z(pred, indices, i+1);\n        \n        // Convert to float for multiplication\n        svfloat32_t multipliers = svcvt_f32_u32_z(pred, curr_indices);\n        \n        // Multiply coefficient by index\n        svfloat32_t derivative = svmul_f32_z(pred, coef, multipliers);\n        \n        // Store result\n        svst1_f32(pred, &result[i], derivative);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    svbool_t pg = svwhilelt_b32(0, result.size());\n    svfloat32_t indices = svindex_f32(0, 1);\n    svfloat32_t coeffs;\n    \n    size_t i = 0;\n    do {\n        coeffs = svld1_f32(pg, &xs[i+1]);\n        indices = svindex_f32(i, 1); \n        svfloat32_t products = svmul_f32_z(pg, coeffs, svincw_f32(indices, 1));\n        svst1_f32(pg, &result[i], products);\n        i += svcntw();\n        pg = svwhilelt_b32(i, result.size());\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    svbool_t pg = svwhilelt_b32(0, result.size());\n    \n    // Create vector of indices [1,2,3,...]\n    svfloat32_t indices = svindex_f32(1, 1);\n    \n    // Load coefficients starting from index 1\n    svfloat32_t coeffs = svld1_f32(pg, &xs[1]);\n    \n    // Multiply coefficients by their indices\n    svfloat32_t derivatives = svmul_f32_z(pg, coeffs, indices);\n    \n    // Store result\n    svst1_f32(pg, &result[0], derivatives);\n    \n    // Handle remaining elements\n    svuint64_t vl = svcntw();\n    uint64_t vl_val = svget_vl(vl);\n    \n    for (size_t i = vl_val; i < result.size(); i += vl_val) {\n        pg = svwhilelt_b32(i, result.size());\n        indices = svindex_f32(i + 1, 1);\n        coeffs = svld1_f32(pg, &xs[i + 1]);\n        derivatives = svmul_f32_z(pg, coeffs, indices);\n        svst1_f32(pg, &result[i], derivatives);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    std::vector<float> result(xs.size() - 1);\n    \n    svbool_t pg = svwhilelt_b32(0, result.size());\n    \n    svfloat32_t indices = svindex_f32(1, 1);\n    svfloat32_t coeffs = svld1_f32(pg, &xs[1]);\n    \n    svfloat32_t derivatives = svmul_f32_z(pg, coeffs, indices);\n    svst1_f32(pg, &result[0], derivatives);\n\n    size_t vl = svcntw();\n    size_t i = vl;\n    \n    while (i < result.size()) {\n        pg = svwhilelt_b32(i, result.size());\n        indices = svindex_f32(i + 1, 1); \n        coeffs = svld1_f32(pg, &xs[i + 1]);\n        derivatives = svmul_f32_z(pg, coeffs, indices);\n        svst1_f32(pg, &result[i], derivatives);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Create predicate for vowels\n    svuint8_t vowels = svdup_n_u8('a');\n    svuint8_t vowels2 = svdup_n_u8('e'); \n    svuint8_t vowels3 = svdup_n_u8('i');\n    svuint8_t vowels4 = svdup_n_u8('o');\n    svuint8_t vowels5 = svdup_n_u8('u');\n    svuint8_t vowels6 = svdup_n_u8('A');\n    svuint8_t vowels7 = svdup_n_u8('E');\n    svuint8_t vowels8 = svdup_n_u8('I');\n    svuint8_t vowels9 = svdup_n_u8('O');\n    svuint8_t vowels10 = svdup_n_u8('U');\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t data = svld1_u8(pg, (uint8_t*)str + i);\n        \n        svbool_t match = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svorr_b_z(pg,\n                            svorr_b_z(pg,\n                                svorr_b_z(pg,\n                                    svorr_b_z(pg,\n                                        svorr_b_z(pg,\n                                            svcmpeq_n_u8(pg, data, 'a'),\n                                            svcmpeq_n_u8(pg, data, 'e')),\n                                        svcmpeq_n_u8(pg, data, 'i')),\n                                    svcmpeq_n_u8(pg, data, 'o')),\n                                svcmpeq_n_u8(pg, data, 'u')),\n                            svcmpeq_n_u8(pg, data, 'A')),\n                        svcmpeq_n_u8(pg, data, 'E')),\n                    svcmpeq_n_u8(pg, data, 'I')),\n                svcmpeq_n_u8(pg, data, 'O')),\n            svcmpeq_n_u8(pg, data, 'U'));\n\n        count += svcntp_b8(pg, match);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    // Check for 'y' or 'Y' at the end\n    if (len > 0 && (str[len-1] == 'y' || str[len-1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Create predicate for vowels\n    svuint8_t vowels = svdup_n_u8('a');\n    svbool_t is_a = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'a');\n    svbool_t is_e = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'e'); \n    svbool_t is_i = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'i');\n    svbool_t is_o = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'o');\n    svbool_t is_u = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'u');\n    svbool_t is_A = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'A');\n    svbool_t is_E = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'E');\n    svbool_t is_I = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'I');\n    svbool_t is_O = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'O');\n    svbool_t is_U = svcmpeq_n_u8(pg, svld1_u8(pg, (uint8_t*)str), 'U');\n\n    // Combine all vowel predicates\n    svbool_t is_vowel = svorr_b_z(pg, is_a, is_e);\n    is_vowel = svorr_b_z(pg, is_vowel, is_i);\n    is_vowel = svorr_b_z(pg, is_vowel, is_o);\n    is_vowel = svorr_b_z(pg, is_vowel, is_u);\n    is_vowel = svorr_b_z(pg, is_vowel, is_A);\n    is_vowel = svorr_b_z(pg, is_vowel, is_E);\n    is_vowel = svorr_b_z(pg, is_vowel, is_I);\n    is_vowel = svorr_b_z(pg, is_vowel, is_O);\n    is_vowel = svorr_b_z(pg, is_vowel, is_U);\n\n    // Count vowels\n    count = svcntp_b8(pg, is_vowel);\n\n    // Handle 'y'/'Y' at end\n    if (len > 0) {\n        char last = s[len-1];\n        if (last == 'y' || last == 'Y') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Create vectors with vowels for comparison\n    svuint8_t va = svdup_n_u8('a');\n    svuint8_t ve = svdup_n_u8('e'); \n    svuint8_t vi = svdup_n_u8('i');\n    svuint8_t vo = svdup_n_u8('o');\n    svuint8_t vu = svdup_n_u8('u');\n    svuint8_t vA = svdup_n_u8('A');\n    svuint8_t vE = svdup_n_u8('E');\n    svuint8_t vI = svdup_n_u8('I');\n    svuint8_t vO = svdup_n_u8('O');\n    svuint8_t vU = svdup_n_u8('U');\n    \n    int i;\n    for (i = 0; i < len; i += svcntb()) {\n        svuint8_t data = svld1_u8(pg, (uint8_t*)str + i);\n        \n        // Compare with each vowel\n        svbool_t match_a = svcmpeq_u8(pg, data, va);\n        svbool_t match_e = svcmpeq_u8(pg, data, ve);\n        svbool_t match_i = svcmpeq_u8(pg, data, vi);\n        svbool_t match_o = svcmpeq_u8(pg, data, vo);\n        svbool_t match_u = svcmpeq_u8(pg, data, vu);\n        svbool_t match_A = svcmpeq_u8(pg, data, vA);\n        svbool_t match_E = svcmpeq_u8(pg, data, vE);\n        svbool_t match_I = svcmpeq_u8(pg, data, vI);\n        svbool_t match_O = svcmpeq_u8(pg, data, vO);\n        svbool_t match_U = svcmpeq_u8(pg, data, vU);\n        \n        // Combine all matches\n        svbool_t is_vowel = svorr_b_z(pg, match_a, match_e);\n        is_vowel = svorr_b_z(pg, is_vowel, match_i);\n        is_vowel = svorr_b_z(pg, is_vowel, match_o);\n        is_vowel = svorr_b_z(pg, is_vowel, match_u);\n        is_vowel = svorr_b_z(pg, is_vowel, match_A);\n        is_vowel = svorr_b_z(pg, is_vowel, match_E);\n        is_vowel = svorr_b_z(pg, is_vowel, match_I);\n        is_vowel = svorr_b_z(pg, is_vowel, match_O);\n        is_vowel = svorr_b_z(pg, is_vowel, match_U);\n        \n        count += svcntp_b8(pg, is_vowel);\n        \n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    // Handle 'y' or 'Y' at the end separately\n    if (len > 0) {\n        char last = s[len-1];\n        if (last == 'y' || last == 'Y') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Create predicate for vowels\n    svuint8_t vowels = svdup_n_u8('a');\n    svuint8_t vowels2 = svdup_n_u8('e'); \n    svuint8_t vowels3 = svdup_n_u8('i');\n    svuint8_t vowels4 = svdup_n_u8('o');\n    svuint8_t vowels5 = svdup_n_u8('u');\n    svuint8_t vowels6 = svdup_n_u8('A');\n    svuint8_t vowels7 = svdup_n_u8('E');\n    svuint8_t vowels8 = svdup_n_u8('I');\n    svuint8_t vowels9 = svdup_n_u8('O');\n    svuint8_t vowels10 = svdup_n_u8('U');\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t data = svld1_u8(pg, (uint8_t*)str + i);\n        \n        svbool_t match = svcmpeq_u8(pg, data, vowels);\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels2));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels3));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels4));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels5));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels6));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels7));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels8));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels9));\n        match = svorr_b_z(pg, match, svcmpeq_u8(pg, data, vowels10));\n        \n        count += svcntp_b8(pg, match);\n        \n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    // Handle 'y' at the end\n    if (len > 0 && (s[len-1] == 'y' || s[len-1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Create predicate for vowels\n    svuint8_t vowels = svdup_n_u8('a');\n    svuint8_t vowels2 = svdup_n_u8('e'); \n    svuint8_t vowels3 = svdup_n_u8('i');\n    svuint8_t vowels4 = svdup_n_u8('o');\n    svuint8_t vowels5 = svdup_n_u8('u');\n    svuint8_t vowels6 = svdup_n_u8('A');\n    svuint8_t vowels7 = svdup_n_u8('E');\n    svuint8_t vowels8 = svdup_n_u8('I');\n    svuint8_t vowels9 = svdup_n_u8('O');\n    svuint8_t vowels10 = svdup_n_u8('U');\n\n    for (int i = 0; i < len; i += svcntb()) {\n        svuint8_t data = svld1_u8(pg, (uint8_t*)str + i);\n        \n        svbool_t match = svorr_b_z(pg,\n            svorr_b_z(pg,\n                svorr_b_z(pg,\n                    svorr_b_z(pg,\n                        svorr_b_z(pg,\n                            svorr_b_z(pg,\n                                svorr_b_z(pg,\n                                    svorr_b_z(pg,\n                                        svorr_b_z(pg,\n                                            svcmpeq_n_u8(pg, data, 'a'),\n                                            svcmpeq_n_u8(pg, data, 'e')),\n                                        svcmpeq_n_u8(pg, data, 'i')),\n                                    svcmpeq_n_u8(pg, data, 'o')),\n                                svcmpeq_n_u8(pg, data, 'u')),\n                            svcmpeq_n_u8(pg, data, 'A')),\n                        svcmpeq_n_u8(pg, data, 'E')),\n                    svcmpeq_n_u8(pg, data, 'I')),\n                svcmpeq_n_u8(pg, data, 'O')),\n            svcmpeq_n_u8(pg, data, 'U'));\n\n        count += svcntp_b8(pg, match);\n        pg = svwhilelt_b8(i + svcntb(), len);\n    }\n    \n    // Check for 'y' or 'Y' at the end\n    if (len > 0 && (str[len-1] == 'y' || str[len-1] == 'Y')) {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)str);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        svbool_t uppercase = svand_b_z(pg, \n                                     svge_n_s8(chars, 65),  \n                                     svle_n_s8(chars, 90));\n        \n        // Zero out non-uppercase chars\n        svint8_t upper_only = svand_z(uppercase, chars);\n        \n        // Sum the ASCII codes\n        sum += svaddv(uppercase, upper_only);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n    \n    const int len = s.length();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)s.c_str());\n        \n        // Create masks for uppercase letters (ASCII 65-90)\n        svbool_t upper_mask = svand_b_z(pg, \n                                      svcmpge_n_s8(pg, chars, 65),\n                                      svcmple_n_s8(pg, chars, 90));\n        \n        // Zero out non-uppercase characters\n        svint8_t upper_only = svand_z(upper_mask, chars);\n        \n        // Sum the ASCII codes\n        sum += svaddv(upper_mask, upper_only);\n        \n        s = s.substr(svcntb());\n        pg = svwhilelt_b8(0, s.length());\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n    \n    int sum = 0;\n    const int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)str);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        svbool_t uppercase = svand_z(pg, \n                                   svcmpge_n_s8(pg, chars, 65),\n                                   svcmple_n_s8(pg, chars, 90));\n        \n        // Zero out non-uppercase characters\n        svint8_t valid_chars = svand_z(pg, chars, svdup_n_s8_z(uppercase, -1));\n        \n        // Sum the ASCII codes\n        sum += svaddv(pg, valid_chars);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n    \n    int sum = 0;\n    const int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)str);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        svbool_t uppercase = svand_z(pg, \n                                   svcmpge_n_s8(pg, chars, 65),\n                                   svcmple_n_s8(pg, chars, 90));\n        \n        // Zero out non-uppercase chars\n        svint8_t valid_chars = svand_z(pg, chars, svdup_n_s8_z(uppercase, -1));\n        \n        // Sum the ASCII codes\n        sum += svaddv(pg, valid_chars);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\nint digitSum_simd(std::string s) {\n    if (s.empty()) return 0;\n    \n    int sum = 0;\n    const int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svint8_t chars = svld1_s8(pg, (int8_t*)str);\n        \n        // Create mask for uppercase letters (ASCII 65-90)\n        svbool_t uppercase = svand_z(pg, \n                                   svge_n_s8(chars, 65),\n                                   svle_n_s8(chars, 90));\n        \n        // Zero out non-uppercase chars and sum\n        svint8_t valid_chars = svand_z(pg, chars, svdup_n_s8_z(uppercase, -1));\n        sum += svaddv(pg, valid_chars);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n    \n    // Get vector length\n    int vl = svcntw();\n    \n    // Initialize predicates and vectors\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n    svint32_t idx_vec = svindex_s32(0, 1);\n    \n    // Process vector chunks\n    for (int i = 0; i < n; i += vl) {\n        pg = svwhilelt_b32(i, n);\n        \n        // Load chunk of input array\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        \n        // Create predicate for even numbers\n        svbool_t even_pred = svand_b_z(pg, svcmpeq_n_s32(pg, svand_n_s32_x(pg, data, 1), 0));\n        \n        // Find min even value in this chunk\n        svint32_t curr_min = svmin_s32_z(even_pred, data, min_vec);\n        \n        // Get first occurrence index of min value\n        svbool_t min_pred = svand_b_z(pg, svcmpeq_s32(pg, data, curr_min));\n        svint32_t curr_idx = svadd_n_s32_z(min_pred, idx_vec, i);\n        \n        // Extract min value and index\n        int chunk_min = svminv_s32(even_pred, data);\n        int chunk_idx = svminv_s32(min_pred, curr_idx);\n        \n        // Update global min if needed\n        if (chunk_min < min_even && chunk_min != 0) {\n            min_even = chunk_min;\n            min_idx = chunk_idx;\n        } else if (chunk_min == 0 && chunk_idx >= 0 && \n                  (min_even > 0 || (min_even == 0 && chunk_idx < min_idx))) {\n            min_even = 0;\n            min_idx = chunk_idx;\n        }\n    }\n\n    if (min_idx == -1) {\n        return {};\n    }\n    \n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &arr[0]);\n        \n        // Create mask for even numbers\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n        \n        // Get minimum even value in current vector\n        svint32_t min_vec = svmin_s32_z(even_mask, vec, svdup_n_s32(INT_MAX));\n        int32_t curr_min = svminv_s32(even_mask, min_vec);\n        \n        if (curr_min < min_even) {\n            // Find first occurrence of minimum value\n            svbool_t min_mask = svand_b_z(pg, even_mask, \n                                        svcmpeq_n_s32(pg, vec, curr_min));\n            min_even = curr_min;\n            min_idx = svfirst_s32(min_mask, 0);\n        }\n        \n        pg = svwhilelt_b32(svlen_s32(), n);\n    }\n    \n    if (min_idx == -1) {\n        return {};\n    }\n    \n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n\n    // Get vector length\n    int vl = svcntw();\n\n    // Initialize predicate for active lanes\n    svbool_t pg = svwhilelt_b32(0, n);\n\n    // Initialize min value vector with max int\n    svint32_t vmin = svdup_n_s32(INT_MAX);\n    svint32_t vidx = svindex_s32(0, 1);\n    \n    for (int i = 0; i < n; i += vl) {\n        // Load vector chunk\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &arr[i]);\n        \n        // Create predicate for even numbers\n        svbool_t even_pred = svand_z(p, svcmpeq_n_s32(p, svand_n_s32(p, vec, 1), 0));\n        \n        // Update running min and index for even numbers\n        svbool_t min_pred = svand_z(even_pred, svcmplt_s32(even_pred, vec, vmin));\n        vmin = svsel_s32(min_pred, vec, vmin);\n        vidx = svsel_s32(min_pred, svindex_s32(i, 1), vidx);\n    }\n\n    // Horizontal min reduction\n    min_even = svminv_s32(svptrue_b32(), vmin);\n    \n    // Find first occurrence of min value\n    pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += vl) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &arr[i]);\n        svbool_t match = svand_z(p, svcmpeq_n_s32(p, vec, min_even));\n        \n        if (svptest_any(p, match)) {\n            min_idx = i + svfirst_active_index32(match);\n            break;\n        }\n    }\n\n    if (min_even == INT_MAX || min_idx == -1) {\n        return {};\n    }\n\n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n\n    // Get vector length\n    const int vl = svcntw();\n\n    // Initialize predicate for active lanes\n    svbool_t pred = svwhilelt_b32(0, n);\n\n    // Initialize min value vector with max int\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n    svint32_t idx_vec = svindex_s32(0, 1);\n\n    for (int i = 0; i < n; i += vl) {\n        // Load vector of values\n        svint32_t data = svld1_s32(pred, &arr[i]);\n        \n        // Create mask for even numbers\n        svbool_t even_mask = svcmpeq_n_s32(pred, svand_n_s32_z(pred, data, 1), 0);\n        \n        // Get current indices\n        svint32_t curr_idx = svadd_n_s32_z(pred, idx_vec, i);\n\n        // Compare with current min\n        svbool_t cmp = svand_b_z(pred, even_mask, \n                                svcmplt_s32(pred, data, min_vec));\n\n        // Update min values and indices where needed\n        min_vec = svsel_s32(cmp, data, min_vec);\n\n        // Reduce to find minimum\n        int curr_min = svminv_s32(pred, min_vec);\n        \n        if (curr_min < min_even) {\n            min_even = curr_min;\n            \n            // Find first index with min value\n            svbool_t min_mask = svcmpeq_n_s32(pred, data, curr_min);\n            min_mask = svand_b_z(pred, min_mask, even_mask);\n            \n            if (svptest_any(pred, min_mask)) {\n                min_idx = i + svfindfit_b32(min_mask);\n            }\n        }\n\n        pred = svwhilelt_b32(i + vl, n);\n    }\n\n    if (min_idx == -1) {\n        return {};\n    }\n\n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int min_even = INT_MAX;\n    int min_idx = -1;\n\n    // Get vector length\n    const int vl = svcntw();\n\n    // Initialize predicates and vectors\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n    svint32_t idx_vec = svindex_s32(0, 1);\n\n    // Process vector chunks\n    for (int i = 0; i < n; i += vl) {\n        pg = svwhilelt_b32(i, n);\n        \n        // Load chunk of input array\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        \n        // Create predicate for even numbers\n        svbool_t even_pred = svand_b_z(pg, svcmpeq_n_s32(pg, svand_n_s32_z(pg, data, 1), 0));\n        \n        // Find minimum even value in this chunk\n        svint32_t curr_min = svmin_s32_z(even_pred, data, min_vec);\n        \n        // Get first occurrence index of minimum value\n        svbool_t min_pred = svand_b_z(pg, svcmpeq_s32(pg, data, curr_min));\n        svint32_t curr_idx = svadd_n_s32_z(min_pred, idx_vec, i);\n        \n        // Extract minimum value and index\n        if (svptest_any(pg, min_pred)) {\n            int chunk_min = svminv_s32(even_pred, data);\n            if (chunk_min < min_even) {\n                min_even = chunk_min;\n                min_idx = svminv_s32(min_pred, curr_idx);\n            }\n        }\n    }\n\n    if (min_idx == -1) {\n        return {};\n    }\n    \n    return {min_even, min_idx};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n    \n    // Allocate frequency array\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n    \n    // Count frequencies using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &lst[i]);\n        \n        // Update frequencies\n        for (int j = 0; j <= max_val; j++) {\n            svbool_t mask = svcmpeq_n_s32(p, vec, j);\n            freq[j] += (int)svcntp_b32(svptrue_b32(), mask);\n        }\n    }\n    \n    // Find result using SVE\n    int result = -1;\n    for (int i = 0; i <= max_val; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, max_val + 1);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t freqs = svld1_s32(p, &freq[i]);\n        \n        // Compare if frequency >= value\n        svbool_t mask = svand_b_z(p, svcmpge_s32(p, freqs, indices),\n                                    svcmpgt_n_s32(p, freqs, 0));\n                                    \n        if (svptest_any(svptrue_b32(), mask)) {\n            // Find maximum valid index\n            svint32_t valid_indices = svsel_s32(mask, indices, svdup_n_s32(-1));\n            int max_idx = svmaxv_s32(svptrue_b32(), valid_indices);\n            result = std::max(result, max_idx);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n    \n    // Find max element to determine frequency array size\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_max = svdup_n_s32(0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        vec_max = svmax_s32_z(pg, vec_max, vec);\n    }\n    \n    int max_val = svmaxv_s32(svptrue_b32(), vec_max);\n    \n    // Count frequencies\n    std::vector<int> freq(max_val + 1, 0);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Increment frequencies\n        svbool_t valid_pg = pg;\n        while (svptest_any(svptrue_b32(), valid_pg)) {\n            int val = svlasta_s32(valid_pg, vec);\n            freq[val]++;\n            valid_pg = svnot_b_z(pg, svdup_n_s32(val) == vec);\n        }\n    }\n    \n    // Find largest number with frequency >= value\n    int result = -1;\n    for (int i = 1; i <= max_val; i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    // Get vector length\n    int vl = svcntw();\n\n    // Process elements in chunks of vl\n    for (int i = 0; i < n; i += vl) {\n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b32(i, n);\n        \n        // Load vector of elements\n        svint32_t vec = svld1_s32(pred, &lst[i]);\n        \n        // For each loaded element, increment its frequency\n        svbool_t valid_pred = svwhilelt_b32(0, svlen(vec));\n        do {\n            int idx = svlasta_s32(valid_pred, vec);\n            freq[idx]++;\n            valid_pred = svnot_b_z(valid_pred, svcmpeq_n_s32(valid_pred, vec, idx));\n        } while (svptest_any(svptrue_b32(), valid_pred));\n    }\n\n    // Find max value that satisfies frequency >= value\n    int result = -1;\n    for (int i = 1; i <= max_val; i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n    \n    // Find max element to determine frequency array size\n    int max_elem = lst[0];\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_max = svdup_n_s32(max_elem);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        vec_max = svmax_s32_z(pg, vec_max, vec);\n    }\n    \n    max_elem = svmaxv_s32(svptrue_b32(), vec_max);\n    \n    // Create frequency array\n    std::vector<int> freq(max_elem + 1, 0);\n    \n    // Count frequencies using SVE\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // For each element in vector, increment its frequency\n        svbool_t active = pg;\n        while (svptest_any(svptrue_b32(), active)) {\n            int val = svlasta_s32(active, vec);\n            if (val >= 0 && val <= max_elem) {\n                freq[val]++;\n            }\n            active = svnot_b_z(active, svlasta_p_b32(active, active));\n        }\n    }\n    \n    // Find largest number where frequency >= number\n    int result = -1;\n    for (int i = 1; i <= max_elem; i++) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n    \n    // Allocate frequency array\n    int max_elem = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_elem + 1, 0);\n    \n    // Count frequencies using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &lst[i]);\n        \n        // Increment frequencies\n        for (int j = 0; j <= max_elem; j++) {\n            svbool_t mask = svcmpeq_n_s32(p, vec, j);\n            freq[j] += (int)svcntp_b32(svptrue_b32(), mask);\n        }\n    }\n    \n    // Find result using SVE\n    int result = -1;\n    for (int i = 0; i <= max_elem; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, max_elem + 1);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t freqs = svld1_s32(p, &freq[i]);\n        \n        // Compare if freq[i] >= i\n        svbool_t mask = svand_b_z(p, \n                                 svcmpge_s32(p, freqs, indices),\n                                 svcmpgt_n_s32(p, indices, 0));\n                                 \n        if (svptest_any(p, mask)) {\n            // Find max index where condition is true\n            svint32_t masked = svsel_s32(mask, indices, svdup_n_s32(-1));\n            int max_idx = svmaxv_s32(p, masked);\n            result = std::max(result, max_idx);\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t len = q.size();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t sum_vec = svdup_n_s32(0);\n    \n    for(size_t i = 0; i < len; i += vl) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t v = svld1_s32(p, &q[i]);\n        sum_vec = svadd_s32_z(p, sum_vec, v);\n    }\n    \n    int sum = svaddv_s32(pg, sum_vec);\n    \n    // Check if sum exceeds weight\n    if(sum > w) return false;\n    \n    // Check if palindrome using SVE\n    size_t half = len/2;\n    for(size_t i = 0; i < half; i += vl) {\n        size_t remaining = half - i;\n        size_t curr_vl = remaining < vl ? remaining : vl;\n        \n        svbool_t p = svwhilelt_b32(0, curr_vl);\n        \n        svint32_t v1 = svld1_s32(p, &q[i]);\n        svint32_t v2 = svld1_s32(p, &q[len-i-curr_vl]);\n        \n        svbool_t cmp = svcmpne_s32(p, v1, svrev_s32(v2));\n        \n        if(svptest_any(p, cmp))\n            return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t len = q.size();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t sum_vec = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(p, &q[i]);\n        sum_vec = svadd_s32_z(p, sum_vec, vec);\n    }\n    \n    int total = svaddv_s32(pg, sum_vec);\n    \n    // Check if sum exceeds weight\n    if (total > w) {\n        return false;\n    }\n    \n    // Check if palindrome using SVE\n    size_t half = len / 2;\n    for (size_t i = 0; i < half; i += vl) {\n        size_t remaining = half - i;\n        size_t curr_vl = remaining < vl ? remaining : vl;\n        \n        svbool_t p = svwhilelt_b32(0, curr_vl);\n        \n        svint32_t vec1 = svld1_s32(p, &q[i]);\n        svint32_t vec2 = svld1_s32(p, &q[len-i-curr_vl]);\n        vec2 = svrev_s32(vec2);\n        \n        svbool_t cmp = svcmpne_s32(p, vec1, vec2);\n        \n        if (svptest_any(p, cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t len = q.size();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t sum_vec = svdup_n_s32(0);\n    \n    for(size_t i = 0; i < len; i += vl) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(p, &q[i]);\n        sum_vec = svadd_s32_z(p, sum_vec, vec);\n    }\n    \n    int sum = svaddv_s32(pg, sum_vec);\n    \n    // Check if sum exceeds weight\n    if(sum > w) return false;\n    \n    // Check if palindrome using SVE\n    size_t half = len/2;\n    for(size_t i = 0; i < half; i += vl) {\n        size_t remaining = half - i;\n        size_t curr_vl = remaining < vl ? remaining : vl;\n        \n        svbool_t p = svwhilelt_b32(0, curr_vl);\n        \n        svint32_t vec1 = svld1_s32(p, &q[i]);\n        svint32_t vec2 = svld1_s32(p, &q[len-i-curr_vl]);\n        \n        svbool_t cmp = svcmpne_s32(p, vec1, svrev_s32(vec2));\n        \n        if(svptest_any(p, cmp))\n            return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    \n    // Get vector length\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Calculate sum\n    svint32_t vec = svld1_s32(pg, q.data());\n    int sum = svaddv_s32(pg, vec);\n    \n    // Check if sum exceeds weight\n    if (sum > w) {\n        return false;\n    }\n    \n    // Check if palindrome\n    int left = 0;\n    int right = n-1;\n    \n    while (left < right) {\n        svbool_t pg_cmp = svwhilelt_b32(left, right+1);\n        svint32_t vec_left = svld1_s32(pg_cmp, &q[left]);\n        svint32_t vec_right = svld1_s32(pg_cmp, &q[right]);\n        \n        svbool_t cmp = svcmpne_s32(pg_cmp, vec_left, vec_right);\n        if (svptest_any(pg_cmp, cmp)) {\n            return false;\n        }\n        \n        left += svcntw();\n        right -= svcntw(); \n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t len = q.size();\n    \n    // Get vector length\n    size_t vl = svcntw();\n    \n    // Calculate sum using SVE\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t sum_vec = svdup_n_s32(0);\n    \n    for (size_t i = 0; i < len; i += vl) {\n        svbool_t p = svwhilelt_b32(i, len);\n        svint32_t v = svld1_s32(p, &q[i]);\n        sum_vec = svadd_s32_z(p, sum_vec, v);\n    }\n    \n    int sum = svaddv_s32(pg, sum_vec);\n    \n    // Check if sum exceeds weight\n    if (sum > w) {\n        return false;\n    }\n    \n    // Check if palindrome using SVE\n    size_t half = len / 2;\n    for (size_t i = 0; i < half; i += vl) {\n        size_t remaining = half - i;\n        size_t curr_vl = remaining < vl ? remaining : vl;\n        \n        svbool_t p = svwhilelt_b32(0, curr_vl);\n        \n        svint32_t v1 = svld1_s32(p, &q[i]);\n        svint32_t v2 = svld1_s32(p, &q[len-i-curr_vl]);\n        \n        svbool_t cmp = svcmpne_s32(p, v1, svrev_s32(v2));\n        \n        if (svptest_any(p, cmp)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int vl = svcntw();\n    \n    // Process elements from both ends towards middle\n    for (int i = 0; i < n/2; i += vl) {\n        // Calculate number of elements to process in this iteration\n        int curr_vl = std::min(vl, n/2 - i);\n        \n        // Create index vectors for front and back elements\n        svbool_t pg = svwhilelt_b32(i, i + curr_vl);\n        \n        // Load front elements\n        svint32_t front = svld1_s32(pg, &arr[i]);\n        \n        // Load corresponding back elements in reverse\n        svint32_t back = svld1_s32(pg, &arr[n-1-i-curr_vl+1]);\n        back = svrev_s32(back);\n        \n        // Compare front and back elements\n        svbool_t neq = svcmpne_s32(pg, front, back);\n        \n        // Count number of unequal elements\n        changes += svcntp_b32(pg, neq);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    int vl = svcntw();\n    \n    // Create index vector\n    svbool_t pg = svwhilelt_b32(0, n/2);\n    svuint32_t indices = svindex_u32(0, 1);\n    \n    while(svptest_first(pg, pg)) {\n        // Load elements from front and back\n        svint32_t front = svld1_s32(pg, &arr[0]);\n        svint32_t back = svld1_s32(pg, &arr[n-vl]);\n        \n        // Reverse elements from back\n        back = svrev_s32(back);\n        \n        // Compare elements\n        svbool_t neq = svcmpne_s32(pg, front, back);\n        \n        // Count mismatches\n        changes += svcntp_b32(pg, neq);\n        \n        // Update pointers and predicate\n        arr.erase(arr.begin(), arr.begin() + vl);\n        arr.erase(arr.end() - vl, arr.end());\n        n -= 2*vl;\n        pg = svwhilelt_b32(0, n/2);\n    }\n    \n    // Handle remaining elements if any\n    for(int i = 0; i < n/2; i++) {\n        if(arr[i] != arr[n-1-i]) {\n            changes++;\n        }\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    int vl = svcntw();\n    \n    // Create index vector\n    svuint32_t indices = svindex_u32(0, 1);\n    \n    // Process elements from both ends towards middle\n    for (int i = 0; i < n/2; i += vl) {\n        // Calculate remaining elements to process\n        int remaining = std::min(vl, n/2 - i);\n        \n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b32(i, i + remaining);\n        \n        // Load elements from start\n        svint32_t v1 = svld1_s32(pred, &arr[i]);\n        \n        // Load elements from end in reverse\n        svint32_t v2 = svld1_s32(pred, &arr[n-1-i-remaining+1]);\n        v2 = svrev_s32(v2);\n        \n        // Compare elements\n        svbool_t neq = svcmpne_s32(pred, v1, v2);\n        \n        // Count mismatches\n        changes += svcntp_b32(pred, neq);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    int vl = svcntw();\n    \n    // Process elements from both ends towards middle\n    for (int i = 0; i < n/2; i += vl) {\n        // Calculate number of elements to process\n        int remaining = std::min(vl, n/2 - i);\n        \n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b32(i, i + remaining);\n        \n        // Load elements from start and end\n        svint32_t v1 = svld1_s32(pred, &arr[i]);\n        svint32_t v2 = svld1_s32(pred, &arr[n-i-remaining]);\n        \n        // Compare elements\n        svbool_t neq = svcmpne_s32(pred, v1, v2);\n        \n        // Count mismatches\n        changes += svcntp_b32(pred, neq);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    \n    // Get vector length\n    int vl = svcntw();\n    \n    // Process elements from both ends towards middle\n    for (int i = 0; i < n/2; i += vl) {\n        // Calculate remaining elements to process\n        int remaining = std::min(vl, n/2 - i);\n        \n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b32(i, i + remaining);\n        \n        // Load elements from start and end\n        svint32_t v1 = svld1_s32(pred, &arr[i]);\n        svint32_t v2 = svld1_s32(pred, &arr[n-i-remaining]);\n        \n        // Reverse elements from end\n        svint32_t v2_rev = svrev_s32(v2);\n        \n        // Compare elements\n        svbool_t neq = svcmpne_s32(pred, v1, v2_rev);\n        \n        // Count mismatches\n        changes += svcntp_b32(pred, neq);\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    // Get vector length\n    svbool_t pg = svptrue_b8();\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        svuint8_t vec = svdup_u8(1);\n        svuint64_t sum = svdupq_n_u64(0);\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svbool_t p = svwhilelt_b8(i, len);\n            sum = svadd_u64_z(pg, sum, svdupq_n_u64(svcntp_b8(p, svptrue_b8())));\n        }\n        \n        total1 += svaddv_u64(pg, sum);\n    }\n\n    // Process lst2  \n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        svuint8_t vec = svdup_u8(1);\n        svuint64_t sum = svdupq_n_u64(0);\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svbool_t p = svwhilelt_b8(i, len);\n            sum = svadd_u64_z(pg, sum, svdupq_n_u64(svcntp_b8(p, svptrue_b8())));\n        }\n        \n        total2 += svaddv_u64(pg, sum);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    // Get vector length\n    svbool_t pg = svptrue_b8();\n\n    // Process first vector\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        svuint8_t vec = svdup_n_u8(1);\n        svuint32_t sum = svdupq_n_u32(0);\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svbool_t p = svwhilelt_b8(i, len);\n            sum = svadd_u32_z(pg, sum, svdupq_n_u32(svcntp_b8(p, svptrue_b8())));\n        }\n        \n        total1 += svaddv_u32(pg, sum);\n    }\n\n    // Process second vector\n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        svuint8_t vec = svdup_n_u8(1);\n        svuint32_t sum = svdupq_n_u32(0);\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svbool_t p = svwhilelt_b8(i, len);\n            sum = svadd_u32_z(pg, sum, svdupq_n_u32(svcntp_b8(p, svptrue_b8())));\n        }\n        \n        total2 += svaddv_u32(pg, sum);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    // Get vector length\n    svbool_t pg = svptrue_b8();\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        svuint8_t chars = svdup_u8(0);\n        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(str.c_str());\n        svuint64_t sum = svdup_u64(0);\n\n        while (svlen_u8(pg) <= str.length()) {\n            chars = svld1_u8(pg, ptr);\n            sum = svadd_u64_z(pg, sum, svaddv_u8(pg, chars));\n            ptr += svlen_u8(pg);\n        }\n\n        // Handle remaining characters\n        size_t remaining = str.length() % svlen_u8(pg);\n        if (remaining > 0) {\n            svbool_t pg_remaining = svwhilelt_b8(0, remaining);\n            chars = svld1_u8(pg_remaining, ptr);\n            sum = svadd_u64_z(pg, sum, svaddv_u8(pg_remaining, chars));\n        }\n\n        total1 += svlasta_u64(pg, sum);\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        svuint8_t chars = svdup_u8(0);\n        const uint8_t* ptr = reinterpret_cast<const uint8_t*>(str.c_str());\n        svuint64_t sum = svdup_u64(0);\n\n        while (svlen_u8(pg) <= str.length()) {\n            chars = svld1_u8(pg, ptr);\n            sum = svadd_u64_z(pg, sum, svaddv_u8(pg, chars));\n            ptr += svlen_u8(pg);\n        }\n\n        // Handle remaining characters\n        size_t remaining = str.length() % svlen_u8(pg);\n        if (remaining > 0) {\n            svbool_t pg_remaining = svwhilelt_b8(0, remaining);\n            chars = svld1_u8(pg_remaining, ptr);\n            sum = svadd_u64_z(pg, sum, svaddv_u8(pg_remaining, chars));\n        }\n\n        total2 += svlasta_u64(pg, sum);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    svbool_t pg = svptrue_b8();\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        svuint8_t chars = svdup_u8(0);\n        size_t len = str.length();\n        size_t i;\n        \n        for (i = 0; i + svcntb() <= len; i += svcntb()) {\n            svuint8_t vec = svld1_u8(pg, (uint8_t*)&str[i]);\n            chars = svadd_u8_z(pg, chars, vec);\n        }\n        \n        // Handle remaining elements\n        if (i < len) {\n            svbool_t pg_rem = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1_u8(pg_rem, (uint8_t*)&str[i]);\n            chars = svadd_u8_z(pg_rem, chars, vec);\n        }\n        \n        total1 += svaddv_u8(pg, chars);\n    }\n\n    // Process lst2\n    for (const auto& str : lst2) {\n        svuint8_t chars = svdup_u8(0);\n        size_t len = str.length();\n        size_t i;\n        \n        for (i = 0; i + svcntb() <= len; i += svcntb()) {\n            svuint8_t vec = svld1_u8(pg, (uint8_t*)&str[i]);\n            chars = svadd_u8_z(pg, chars, vec);\n        }\n        \n        // Handle remaining elements\n        if (i < len) {\n            svbool_t pg_rem = svwhilelt_b8(i, len);\n            svuint8_t vec = svld1_u8(pg_rem, (uint8_t*)&str[i]);\n            chars = svadd_u8_z(pg_rem, chars, vec);\n        }\n        \n        total2 += svaddv_u8(pg, chars);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\nstd::vector<std::string> total_match_simd(const std::vector<std::string>& lst1, const std::vector<std::string>& lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n\n    size_t total1 = 0;\n    size_t total2 = 0;\n\n    // Get vector length\n    svbool_t pg = svptrue_b8();\n\n    // Process lst1\n    for (const auto& str : lst1) {\n        size_t len = str.length();\n        svuint8_t vec = svdup_u8(1);\n        svuint32_t sum = svdupq_n_u32(0);\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svbool_t p = svwhilelt_b8(i, len);\n            sum = svadd_u32_z(pg, sum, svdupq_n_u32(svcntp_b8(p, svptrue_b8())));\n        }\n        \n        total1 += svaddv_u32(pg, sum);\n    }\n\n    // Process lst2  \n    for (const auto& str : lst2) {\n        size_t len = str.length();\n        svuint8_t vec = svdup_u8(1);\n        svuint32_t sum = svdupq_n_u32(0);\n        \n        for (size_t i = 0; i < len; i += svcntb()) {\n            svbool_t p = svwhilelt_b8(i, len);\n            sum = svadd_u32_z(pg, sum, svdupq_n_u32(svcntp_b8(p, svptrue_b8())));\n        }\n        \n        total2 += svaddv_u32(pg, sum);\n    }\n\n    return (total2 < total1) ? lst2 : lst1;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_x = svdup_n_u64(x);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t result = svdup_n_u64(1);\n    \n    while (svmaxv_u64(pg, result) <= x) {\n        result = svmul_u64_z(pg, result, vec_n);\n        \n        if (svcmpeq_u64(pg, result, vec_x)) {\n            return true;\n        }\n        \n        if (svmaxv_u64(pg, result) > x) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_x = svdup_n_u64(x);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t result = svdup_n_u64(1);\n    \n    while (svmaxv_u64(pg, result) <= x) {\n        result = svmul_u64_z(pg, result, vec_n);\n        \n        if (svcmpeq_u64(pg, result, vec_x)) {\n            return true;\n        }\n        \n        if (svmaxv_u64(pg, result) > x) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_x = svdup_n_u64(x);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t result = svdup_n_u64(1);\n    \n    while (svmaxv_u64(pg, result) <= x) {\n        result = svmul_u64_z(pg, result, vec_n);\n        \n        svbool_t eq = svcmpeq_u64(pg, result, vec_x);\n        if (svptest_any(pg, eq)) {\n            return true;\n        }\n        \n        if (svmaxv_u64(pg, result) > x) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n == 1) return false;\n    if (n == 0) return false;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t vec_x = svdup_n_u64(x);\n    svuint64_t vec_result = svdup_n_u64(1);\n    \n    while (svmaxv_u64(pg, vec_result) <= x) {\n        vec_result = svmul_u64_z(pg, vec_result, vec_n);\n        \n        if (svmaxv_u64(pg, vec_result) == x) {\n            return true;\n        }\n        \n        if (svmaxv_u64(pg, vec_result) > x) {\n            return false;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```cpp\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) return false;\n    if (x == 1) return true;\n    if (n <= 1) return false;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_x = svdup_n_u64(x);\n    svuint64_t vec_n = svdup_n_u64(n);\n    svuint64_t result = svdup_n_u64(1);\n    \n    while (svmaxv_u64(pg, result) <= x) {\n        result = svmul_u64_z(pg, result, vec_n);\n        \n        if (svcmpeq_u64(pg, result, vec_x)) {\n            return true;\n        }\n        \n        if (svmaxv_u64(pg, result) > x) {\n            break;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Get vector length\n    const int vl = svcntb();\n    \n    // Process string in vector chunks\n    for (int i = 0; i < len; i += vl) {\n        // Create predicate for remaining elements\n        svbool_t pred = svwhilelt_b8(i, len);\n        \n        // Load chunk of string into vector\n        svuint8_t chars = svld1_u8(pred, (uint8_t*)&num[i]);\n        \n        // Create predicates for different character ranges\n        svbool_t is_digit = svand_b_z(pred, \n            svand_b_z(pred,\n                svcmpge_n_u8(pred, chars, '0'),\n                svcmple_n_u8(pred, chars, '9')\n            )\n        );\n        \n        svbool_t is_letter = svand_b_z(pred,\n            svand_b_z(pred, \n                svcmpge_n_u8(pred, chars, 'A'),\n                svcmple_n_u8(pred, chars, 'F')\n            )\n        );\n        \n        // Convert characters to values\n        svuint8_t digit_vals = svsub_n_u8_z(is_digit, chars, '0');\n        svuint8_t letter_vals = svadd_n_u8_z(is_letter, \n            svsub_n_u8_z(is_letter, chars, 'A'), 10);\n        \n        // Combine digit and letter values\n        svuint8_t values = svorr_u8_x(pred, digit_vals, letter_vals);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        svbool_t is_prime = svcmpne_n_u8(pred, values, 0);\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 1));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 4));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 6));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 8));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 9));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 10));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 12));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 14));\n        is_prime = svand_b_z(pred, is_prime, svcmpne_n_u8(pred, values, 15));\n        \n        // Count prime digits\n        count += svcntp_b8(pred, is_prime);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int count = 0;\n    const int len = num.length();\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        // Load string characters into vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)num.c_str());\n        \n        // Convert ASCII hex digits to values\n        svuint8_t values = svsubr_n_u8_z(pg, chars, '0');\n        svbool_t is_letter = svcmpge_n_u8(pg, chars, 'A');\n        values = svadd_u8_m(pg, values, is_letter, values, 10);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        svbool_t is_two = svcmpeq_n_u8(pg, values, 2);\n        svbool_t is_three = svcmpeq_n_u8(pg, values, 3); \n        svbool_t is_five = svcmpeq_n_u8(pg, values, 5);\n        svbool_t is_seven = svcmpeq_n_u8(pg, values, 7);\n        svbool_t is_eleven = svcmpeq_n_u8(pg, values, 11);\n        svbool_t is_thirteen = svcmpeq_n_u8(pg, values, 13);\n        \n        // Combine prime matches\n        svbool_t is_prime = svorr_b_z(pg, is_two, is_three);\n        is_prime = svorr_b_z(pg, is_prime, is_five);\n        is_prime = svorr_b_z(pg, is_prime, is_seven);\n        is_prime = svorr_b_z(pg, is_prime, is_eleven);\n        is_prime = svorr_b_z(pg, is_prime, is_thirteen);\n        \n        // Count matches\n        count += svcntp_b8(svptrue_b8(), is_prime);\n        \n        // Advance to next vector\n        size_t vl = svcntb();\n        num = num.substr(vl);\n        pg = svwhilelt_b8(0, num.length());\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n\n    const size_t len = num.length();\n    int count = 0;\n\n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    while (svptest_first(svptrue_b8(), pg)) {\n        // Load string characters into vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)num.c_str());\n        \n        // Check for digits 2,3,5,7\n        svbool_t is_2 = svcmpeq_n_u8(pg, chars, '2');\n        svbool_t is_3 = svcmpeq_n_u8(pg, chars, '3'); \n        svbool_t is_5 = svcmpeq_n_u8(pg, chars, '5');\n        svbool_t is_7 = svcmpeq_n_u8(pg, chars, '7');\n        \n        // Check for B(11) and D(13)\n        svbool_t is_B = svcmpeq_n_u8(pg, chars, 'B');\n        svbool_t is_D = svcmpeq_n_u8(pg, chars, 'D');\n\n        // Combine all matches\n        svbool_t is_prime = svorr_b_z(pg, is_2, is_3);\n        is_prime = svorr_b_z(pg, is_prime, is_5); \n        is_prime = svorr_b_z(pg, is_prime, is_7);\n        is_prime = svorr_b_z(pg, is_prime, is_B);\n        is_prime = svorr_b_z(pg, is_prime, is_D);\n\n        // Count matches\n        count += svcntp_b8(svptrue_b8(), is_prime);\n\n        // Update pointer and predicate for next iteration\n        size_t vl = svcntb();\n        num = num.substr(vl);\n        pg = svwhilelt_b8(0, num.length());\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int len = num.length();\n    int count = 0;\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        // Load string characters into vector\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)num.c_str());\n        \n        // Check for digits 2,3,5,7\n        svbool_t is_2 = svcmpeq_n_u8(pg, chars, '2');\n        svbool_t is_3 = svcmpeq_n_u8(pg, chars, '3'); \n        svbool_t is_5 = svcmpeq_n_u8(pg, chars, '5');\n        svbool_t is_7 = svcmpeq_n_u8(pg, chars, '7');\n        \n        // Check for B(11) and D(13)\n        svbool_t is_B = svcmpeq_n_u8(pg, chars, 'B');\n        svbool_t is_D = svcmpeq_n_u8(pg, chars, 'D');\n        \n        // Combine all matches\n        svbool_t is_prime = svorr_b_z(pg, is_2, is_3);\n        is_prime = svorr_b_z(pg, is_prime, is_5); \n        is_prime = svorr_b_z(pg, is_prime, is_7);\n        is_prime = svorr_b_z(pg, is_prime, is_B);\n        is_prime = svorr_b_z(pg, is_prime, is_D);\n        \n        // Count matches\n        count += svcntp_b8(svptrue_b8(), is_prime);\n        \n        // Update pointer and length\n        num = num.substr(svcntb());\n        len -= svcntb();\n        pg = svwhilelt_b8(0, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    int count = 0;\n    const size_t len = num.length();\n    const size_t vl = svcntb();\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Process chunks of the string\n    for (size_t i = 0; i < len; i += vl) {\n        // Load string data into vector\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)&num[i]);\n        \n        // Convert ASCII hex digits to values\n        svuint8_t values = svdup_u8(0);\n        \n        // Handle 0-9\n        svbool_t is_digit = svcmpge_n_u8(pg, data, '0');\n        is_digit = svand_z(pg, is_digit, svcmple_n_u8(pg, data, '9'));\n        values = svsel(is_digit, svsub_n_u8(data, '0'), values);\n        \n        // Handle A-F\n        svbool_t is_letter = svcmpge_n_u8(pg, data, 'A');\n        is_letter = svand_z(pg, is_letter, svcmple_n_u8(pg, data, 'F'));\n        values = svsel(is_letter, svadd_n_u8(svsub_n_u8(data, 'A'), 10), values);\n        \n        // Check for prime hex digits (2,3,5,7,11,13)\n        svbool_t is_prime = svcmpeq_n_u8(pg, values, 2);\n        is_prime = svorrb_z(pg, is_prime, svcmpeq_n_u8(pg, values, 3));\n        is_prime = svorrb_z(pg, is_prime, svcmpeq_n_u8(pg, values, 5));\n        is_prime = svorrb_z(pg, is_prime, svcmpeq_n_u8(pg, values, 7));\n        is_prime = svorrb_z(pg, is_prime, svcmpeq_n_u8(pg, values, 11)); // B\n        is_prime = svorrb_z(pg, is_prime, svcmpeq_n_u8(pg, values, 13)); // D\n        \n        // Count prime digits\n        count += svcntp_b8(pg, is_prime);\n        \n        // Update predicate for remaining elements\n        pg = svwhilelt_b8(i + vl, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int n = s.length() - 2;\n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svuint8_t v1 = svld1_u8(pg, (uint8_t*)&s[0]);\n        svuint8_t v2 = svld1_u8(pg, (uint8_t*)&s[1]); \n        svuint8_t v3 = svld1_u8(pg, (uint8_t*)&s[2]);\n\n        svbool_t neq1 = svcmpne_u8(pg, v1, v2);\n        svbool_t neq2 = svcmpne_u8(pg, v2, v3);\n        svbool_t neq3 = svcmpne_u8(pg, v1, v3);\n        \n        svbool_t all_diff = svand_b_z(pg, neq1, svand_b_z(pg, neq2, neq3));\n        \n        if (!svptest_all(pg, all_diff)) {\n            return false;\n        }\n        \n        size_t vl = svcntb();\n        pg = svwhilelt_b8(vl, n);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length() - 2;\n    svbool_t pg = svwhilelt_b8(0, len);\n\n    while (svptest_first(pg, pg)) {\n        svuint8_t vec1 = svld1_u8(pg, (uint8_t*)&s[0]);\n        svuint8_t vec2 = svld1_u8(pg, (uint8_t*)&s[1]); \n        svuint8_t vec3 = svld1_u8(pg, (uint8_t*)&s[2]);\n\n        svbool_t neq1 = svcmpne_u8(pg, vec1, vec2);\n        svbool_t neq2 = svcmpne_u8(pg, vec2, vec3);\n        svbool_t neq3 = svcmpne_u8(pg, vec1, vec3);\n\n        svbool_t all_diff = svand_b_z(pg, neq1, svand_b_z(pg, neq2, neq3));\n\n        if (!svptest_all(pg, all_diff)) {\n            return false;\n        }\n\n        size_t vl = svcntb();\n        pg = svwhilelt_b8(vl, len);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length() - 2;\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svuint8_t v1 = svld1_u8(pg, (uint8_t*)&s[0]);\n        svuint8_t v2 = svld1_u8(pg, (uint8_t*)&s[1]); \n        svuint8_t v3 = svld1_u8(pg, (uint8_t*)&s[2]);\n\n        svbool_t neq12 = svcmpne_u8(pg, v1, v2);\n        svbool_t neq23 = svcmpne_u8(pg, v2, v3);\n        svbool_t neq13 = svcmpne_u8(pg, v1, v3);\n        \n        svbool_t all_diff = svand_b_z(pg, neq12, svand_b_z(pg, neq23, neq13));\n        \n        if (!svptest_all(pg, all_diff)) {\n            return false;\n        }\n        \n        size_t vl = svcntb();\n        pg = svwhilelt_b8(vl, len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int n = s.length() - 2;\n    svbool_t pg = svwhilelt_b8(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svuint8_t v1 = svld1_u8(pg, (uint8_t*)&s[0]);\n        svuint8_t v2 = svld1_u8(pg, (uint8_t*)&s[1]); \n        svuint8_t v3 = svld1_u8(pg, (uint8_t*)&s[2]);\n\n        svbool_t neq1 = svcmpne_u8(pg, v1, v2);\n        svbool_t neq2 = svcmpne_u8(pg, v2, v3);\n        svbool_t neq3 = svcmpne_u8(pg, v1, v3);\n        \n        svbool_t all_diff = svand_z(pg, neq1, svand_z(pg, neq2, neq3));\n        \n        if (!svptest_all(pg, all_diff)) {\n            return false;\n        }\n        \n        size_t vl = svcntb();\n        pg = svwhilelt_b8(vl, n);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\nbool is_happy_simd(const std::string& s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const int len = s.length() - 2;\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svuint8_t vec1 = svld1_u8(pg, (uint8_t*)&s[0]);\n        svuint8_t vec2 = svld1_u8(pg, (uint8_t*)&s[1]); \n        svuint8_t vec3 = svld1_u8(pg, (uint8_t*)&s[2]);\n\n        svbool_t cmp12 = svcmpne_u8(pg, vec1, vec2);\n        svbool_t cmp23 = svcmpne_u8(pg, vec2, vec3);\n        svbool_t cmp13 = svcmpne_u8(pg, vec1, vec3);\n        \n        svbool_t all_diff = svand_b_z(pg, cmp12, svand_b_z(pg, cmp23, cmp13));\n        \n        if (!svptest_all(pg, all_diff)) {\n            return false;\n        }\n        \n        size_t vl = svcntb();\n        pg = svwhilelt_b8(vl, len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    size_t i = 3;\n\n    svbool_t pg = svwhilelt_b32(i, sqrt_len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t len_vec = svdup_n_u32(len);\n        svuint32_t remainders = svurem_u32_x(pg, len_vec, indices);\n        \n        svbool_t is_divisible = svcmpeq_u32(pg, remainders, 0);\n        \n        if (svptest_any(pg, is_divisible)) {\n            return false;\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, sqrt_len);\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    \n    svbool_t pg = svwhilelt_b32(0, sqrt_len);\n    svuint32_t indices = svindex_u32(3, 2);\n    svuint32_t len_vec = svdup_n_u32(len);\n    svbool_t is_divisible = svpfalse_b();\n\n    while (svptest_first(pg, svnot_z(pg, is_divisible))) {\n        svuint32_t remainders = svurem_x(pg, len_vec, indices);\n        is_divisible = svorr_z(pg, is_divisible, svcmpeq_n_u32(pg, remainders, 0));\n        indices = svadd_x(pg, indices, 2);\n        pg = svwhilelt_b32(svmaxv_u32(pg, indices), sqrt_len);\n    }\n\n    return !svptest_any(svptrue_b32(), is_divisible);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    \n    svbool_t pg = svwhilelt_b32(0, sqrt_len);\n    svuint32_t indices = svindex_u32(3, 2);\n    svuint32_t len_vec = svdup_n_u32(len);\n    svbool_t is_divisible = svpfalse_b();\n\n    while (svptest_any(pg, svnot_z(pg, is_divisible))) {\n        svuint32_t remainders = svurem_x(pg, len_vec, indices);\n        is_divisible = svorr_z(pg, is_divisible, svcmpeq_n_u32(pg, remainders, 0));\n        indices = svadd_x(pg, indices, 2);\n        pg = svwhilelt_b32(svmaxv_u32(pg, indices), sqrt_len);\n    }\n\n    return !svptest_any(svptrue_b32(), is_divisible);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if (len % 2 == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    \n    // Create vector of consecutive numbers from 3 to sqrt_len\n    svbool_t pg = svwhilelt_b32(0, sqrt_len - 2);\n    svuint32_t indices = svindex_u32(3, 2);\n    \n    // Create vector of remainders when dividing len by each number\n    svuint32_t divisors = svsel_u32(pg, indices, svdup_u32(0));\n    svuint32_t remainders = svdup_u32(len);\n    remainders = svdiv_x(pg, remainders, divisors);\n    remainders = svmul_x(pg, remainders, divisors);\n    \n    // Check if any remainder is 0 (meaning len is divisible by that number)\n    svbool_t is_divisible = svcmpeq_n_u32(pg, remainders, 0);\n    \n    // Reduce to single bool\n    return !svptest_any(pg, is_divisible);\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\nbool prime_length_simd(const std::string& str) {\n    size_t len = str.length();\n    \n    if (len <= 1) return false;\n    if (len == 2) return true;\n    if ((len & 1) == 0) return false;\n\n    size_t sqrt_len = sqrt(len);\n    \n    svbool_t pg = svwhilelt_b32(0, sqrt_len);\n    svuint32_t indices = svindex_u32(3, 2);\n    svuint32_t len_vec = svdup_n_u32(len);\n    svbool_t is_divisible = svpfalse_b();\n\n    while (svptest_first(pg, svnot_z(pg, is_divisible))) {\n        svuint32_t rem = svurem_x(pg, len_vec, indices);\n        is_divisible = svorr_z(pg, is_divisible, svcmpeq_x(pg, rem, 0));\n        indices = svadd_x(pg, indices, 2);\n        pg = svwhilelt_b32(svmaxv_u32(pg, indices), sqrt_len);\n    }\n\n    return !svptest_any(svptrue_b32(), is_divisible);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    svbool_t pg = svptrue_b64();\n    svuint64_t vec_N = svdup_n_u64(N);\n    svuint64_t sum = svdup_n_u64(0);\n    \n    while (svptest_any(pg, svdup_n_u64(N > 0))) {\n        // Extract digits in parallel\n        svuint64_t digits = svdiv_n_u64_z(pg, vec_N, 10);\n        svuint64_t remainder = svsub_u64_z(pg, vec_N, svmul_n_u64_z(pg, digits, 10));\n        \n        // Add remainder to sum\n        sum = svadd_u64_z(pg, sum, remainder);\n        \n        // Update N for next iteration\n        vec_N = digits;\n        N /= 10;\n    }\n\n    // Extract scalar sum\n    uint64_t final_sum = svlasta_u64(pg, sum);\n    \n    // Convert to binary string\n    if (final_sum == 0) return \"0\";\n    \n    std::string result;\n    while (final_sum > 0) {\n        result = (final_sum % 2 ? \"1\" : \"0\") + result;\n        final_sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to string to process digits\n    std::string num = std::to_string(N);\n    int len = num.length();\n    \n    // Create vector of digits\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t digits = svdup_n_s32(0);\n    \n    // Load digits into vector\n    for(int i = 0; i < len; i++) {\n        digits = svset_s32(digits, i, num[i] - '0');\n    }\n    \n    // Sum digits using SVE\n    int sum = svaddv_s32(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    while(sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result.empty() ? \"0\" : result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to string to process digits\n    std::string num = std::to_string(N);\n    int len = num.length();\n    \n    // Create vector of digits\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t digits = svdup_n_s32(0);\n    \n    // Load digits into vector\n    for(int i = 0; i < len; i++) {\n        digits = svset_s32(digits, i, num[i] - '0');\n    }\n    \n    // Sum digits using SVE\n    int sum = svaddv_s32(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    if(sum == 0) return \"0\";\n    \n    while(sum > 0) {\n        result = ((sum & 1) ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to string to process digits\n    std::string num = std::to_string(N);\n    int len = num.length();\n    \n    // Create vector of digits\n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t digits = svdup_n_s32(0);\n    \n    // Load digits into vector\n    for(int i = 0; i < len; i++) {\n        digits = svset_s32(digits, i, num[i] - '0');\n    }\n    \n    // Sum digits using SVE\n    int sum = svaddv_s32(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    if(sum == 0) return \"0\";\n    \n    while(sum > 0) {\n        result = (sum % 2 ? \"1\" : \"0\") + result;\n        sum /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\nstd::string solve_simd(uint64_t N) {\n    // Convert number to string to process digits\n    std::string num = std::to_string(N);\n    int len = num.length();\n    \n    // Create vector of digits\n    svuint8_t digits;\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Load digits into vector, converting from ASCII\n    digits = svsub_z(pg, \n                     svld1_u8(pg, (uint8_t*)num.c_str()),\n                     svdup_n_u8('0'));\n    \n    // Sum the digits using horizontal add\n    uint64_t sum = svaddv(pg, digits);\n    \n    // Convert sum to binary string\n    std::string result;\n    if(sum == 0) return \"0\";\n    \n    while(sum > 0) {\n        result = ((sum & 1) ? \"1\" : \"0\") + result;\n        sum >>= 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t odd_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, indices, 1), 1);\n    \n    svint32_t vec = svld1_s32(pg, lst.data());\n    svint32_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n    \n    svbool_t final_mask = svand_b_z(pg, odd_mask, even_mask);\n    \n    svint32_t masked_vec = svsel_s32(final_mask, vec, svdup_n_s32(0));\n    sum = svaddv_s32(pg, masked_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t odd_mask = svcmpne_n_s32(pg, svand_n_s32_z(pg, indices, 1), 0);\n    \n    svint32_t vec = svld1_s32(pg, lst.data());\n    svint32_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n    \n    svbool_t final_mask = svand_b_z(pg, odd_mask, even_mask);\n    \n    svint32_t masked_vec = svand_s32_z(final_mask, vec);\n    sum = svaddv_s32(final_mask, masked_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t odd_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, indices, 1), 1);\n    \n    svint32_t vec = svld1_s32(pg, lst.data());\n    svint32_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n    \n    svbool_t final_mask = svand_b_z(pg, odd_mask, even_mask);\n    \n    svint32_t masked_vec = svand_s32_z(final_mask, vec);\n    sum = svaddv_s32(final_mask, masked_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int result = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t odd_mask = svcmpne_n_s32(pg, svand_n_s32_z(pg, indices, 1), 0);\n    \n    svint32_t vec = svld1_s32(pg, lst.data());\n    svint32_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n    \n    svbool_t final_mask = svand_b_z(pg, odd_mask, even_mask);\n    \n    svint32_t masked_vec = svsel_s32(final_mask, vec, svdup_n_s32(0));\n    result = svaddv_s32(pg, masked_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int sum = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    svint32_t indices = svindex_s32(0, 1);\n    svbool_t odd_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, indices, 1), 1);\n    \n    svint32_t vec = svld1_s32(pg, lst.data());\n    svint32_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, vec, 1), 0);\n    \n    svbool_t final_mask = svand_b_z(pg, odd_mask, even_mask);\n    \n    svint32_t masked_vec = svand_s32_z(final_mask, vec);\n    sum = svaddv_s32(final_mask, masked_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    std::string result(s);\n    size_t len = s.length();\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b8(i, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&s[i]);\n        \n        // Multiply by 2 and shift by 2\n        svuint8_t shifted = svadd_u8_x(pg, chars, svdup_u8(4));\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], shifted);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    std::string result(s);\n    size_t len = s.length();\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b8(i, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&s[i]);\n        \n        // Multiply by 2 and shift down 2 places\n        svuint8_t shifted = svmul_n_u8_x(pg, chars, 2);\n        shifted = svadd_n_u8_x(pg, shifted, 2);\n        \n        // Handle wrapping around alphabet\n        svuint8_t wrapped = svand_n_u8_x(pg, shifted, 25);\n        wrapped = svadd_n_u8_x(pg, wrapped, 'a');\n        \n        svst1_u8(pg, (uint8_t*)&result[i], wrapped);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    std::string result(s);\n    size_t len = s.length();\n    char* data = result.data();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)data);\n        \n        // Shift by 4 (2 * 2)\n        svuint8_t shifted = svadd_u8_z(pg, chars, 4);\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)data, shifted);\n        \n        data += svcntb();\n        pg = svwhilelt_b8(data - result.data(), len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    std::string result(s.length(), 0);\n    size_t i = 0;\n    \n    svbool_t pg = svwhilelt_b8(i, s.length());\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)&s[i]);\n        \n        // Multiply by 2 and shift by 2\n        svuint8_t shifted = svadd_u8_x(pg, \n                                     svadd_u8_x(pg, input, input),  // multiply by 2\n                                     svdup_n_u8(2));                // add 2\n        \n        // Handle wrapping around alphabet\n        svuint8_t wrapped = svsub_u8_x(pg,\n                                      shifted,\n                                      svmul_n_u8_x(pg,\n                                                  svdiv_u8_x(pg, shifted, svdup_n_u8(26)),\n                                                  26));\n        \n        // Store result\n        svst1_u8(pg, (uint8_t*)&result[i], wrapped);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, s.length());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\nstd::string encrypt_simd(const std::string& s) {\n    if (s.empty()) return \"\";\n    \n    std::string result(s);\n    size_t len = s.length();\n    char* data = result.data();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)data);\n        \n        // Multiply by 2 and shift by 2\n        svuint8_t shifted = svadd_u8_x(pg, chars, svdup_n_u8(4));\n        \n        svst1_u8(pg, (uint8_t*)data, shifted);\n        \n        data += svcntb();\n        pg = svwhilelt_b8(data - result.data(), len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&result[i]);\n\n        // Create masks for different cases\n        svbool_t is_lower = svcmpge_n_u8(pg, chars, 'a') && svcmple_n_u8(pg, chars, 'z');\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A') && svcmple_n_u8(pg, chars, 'Z');\n        \n        // Convert case\n        svuint8_t to_upper = svsub_n_u8_z(is_lower, chars, 32);\n        svuint8_t to_lower = svadd_n_u8_z(is_upper, chars, 32);\n        chars = svsel_u8(is_lower, to_upper, chars);\n        chars = svsel_u8(is_upper, to_lower, chars);\n\n        // Handle vowels (both upper and lower case)\n        svbool_t is_vowel = svcmpeq_n_u8(pg, chars, 'a') || \n                           svcmpeq_n_u8(pg, chars, 'e') ||\n                           svcmpeq_n_u8(pg, chars, 'i') ||\n                           svcmpeq_n_u8(pg, chars, 'o') ||\n                           svcmpeq_n_u8(pg, chars, 'u') ||\n                           svcmpeq_n_u8(pg, chars, 'A') ||\n                           svcmpeq_n_u8(pg, chars, 'E') ||\n                           svcmpeq_n_u8(pg, chars, 'I') ||\n                           svcmpeq_n_u8(pg, chars, 'O') ||\n                           svcmpeq_n_u8(pg, chars, 'U');\n\n        // Replace vowels with char 2 ahead\n        svuint8_t vowel_replaced = svadd_n_u8_z(is_vowel, chars, 2);\n        chars = svsel_u8(is_vowel, vowel_replaced, chars);\n\n        // Store results back\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&result[i]);\n\n        // Check for vowels\n        svbool_t is_a = svcmpeq_n_u8(pg, chars, 'a');\n        svbool_t is_e = svcmpeq_n_u8(pg, chars, 'e'); \n        svbool_t is_i = svcmpeq_n_u8(pg, chars, 'i');\n        svbool_t is_o = svcmpeq_n_u8(pg, chars, 'o');\n        svbool_t is_u = svcmpeq_n_u8(pg, chars, 'u');\n        svbool_t is_A = svcmpeq_n_u8(pg, chars, 'A');\n        svbool_t is_E = svcmpeq_n_u8(pg, chars, 'E');\n        svbool_t is_I = svcmpeq_n_u8(pg, chars, 'I');\n        svbool_t is_O = svcmpeq_n_u8(pg, chars, 'O');\n        svbool_t is_U = svcmpeq_n_u8(pg, chars, 'U');\n\n        // Replace vowels\n        chars = svsel_u8(is_a, svdup_n_u8('C'), chars);\n        chars = svsel_u8(is_e, svdup_n_u8('G'), chars);\n        chars = svsel_u8(is_i, svdup_n_u8('K'), chars);\n        chars = svsel_u8(is_o, svdup_n_u8('Q'), chars);\n        chars = svsel_u8(is_u, svdup_n_u8('W'), chars);\n        chars = svsel_u8(is_A, svdup_n_u8('c'), chars);\n        chars = svsel_u8(is_E, svdup_n_u8('g'), chars);\n        chars = svsel_u8(is_I, svdup_n_u8('k'), chars);\n        chars = svsel_u8(is_O, svdup_n_u8('q'), chars);\n        chars = svsel_u8(is_U, svdup_n_u8('w'), chars);\n\n        // Swap case for non-vowels\n        svbool_t is_lower = svand_b_z(pg, svcmpge_n_u8(pg, chars, 'a'), svcmple_n_u8(pg, chars, 'z'));\n        svbool_t is_upper = svand_b_z(pg, svcmpge_n_u8(pg, chars, 'A'), svcmple_n_u8(pg, chars, 'Z'));\n        \n        chars = svsel_u8(is_lower, svsub_n_u8(chars, 32), chars);\n        chars = svsel_u8(is_upper, svadd_n_u8(chars, 32), chars);\n\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&result[i]);\n        \n        // Check for lowercase letters\n        svbool_t is_lower = svcmpge_n_u8(pg, chars, 'a');\n        is_lower = svand_z(pg, is_lower, svcmple_n_u8(pg, chars, 'z'));\n        \n        // Check for uppercase letters\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A'); \n        is_upper = svand_z(pg, is_upper, svcmple_n_u8(pg, chars, 'Z'));\n        \n        // Convert case\n        svuint8_t case_diff = svdup_n_u8('a' - 'A');\n        chars = svsel_u8(is_lower, svsub_u8_z(pg, chars, case_diff), chars);\n        chars = svsel_u8(is_upper, svadd_u8_z(pg, chars, case_diff), chars);\n        \n        // Check for vowels (after case conversion)\n        svbool_t is_vowel = svcmpeq_n_u8(pg, chars, 'A');\n        is_vowel = svorrb_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'E'));\n        is_vowel = svorrb_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'I')); \n        is_vowel = svorrb_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'O'));\n        is_vowel = svorrb_z(pg, is_vowel, svcmpeq_n_u8(pg, chars, 'U'));\n        \n        // Replace vowels with char 2 places ahead\n        svuint8_t vowel_chars = svadd_n_u8_z(pg, chars, 2);\n        chars = svsel_u8(is_vowel, vowel_chars, chars);\n        \n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&result[i]);\n\n        // Create masks for different character ranges\n        svbool_t is_lower = svcmpge_n_u8(pg, chars, 'a') && svcmple_n_u8(pg, chars, 'z');\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A') && svcmple_n_u8(pg, chars, 'Z');\n        \n        // Convert case\n        svuint8_t lower_to_upper = svsub_n_u8_z(is_lower, chars, 32);\n        svuint8_t upper_to_lower = svadd_n_u8_z(is_upper, chars, 32);\n        chars = svsel_u8(is_lower, lower_to_upper, chars);\n        chars = svsel_u8(is_upper, upper_to_lower, chars);\n\n        // Create masks for vowels (both cases)\n        svbool_t is_vowel = svcmpeq_n_u8(pg, chars, 'a') || svcmpeq_n_u8(pg, chars, 'A') ||\n                           svcmpeq_n_u8(pg, chars, 'e') || svcmpeq_n_u8(pg, chars, 'E') ||\n                           svcmpeq_n_u8(pg, chars, 'i') || svcmpeq_n_u8(pg, chars, 'I') ||\n                           svcmpeq_n_u8(pg, chars, 'o') || svcmpeq_n_u8(pg, chars, 'O') ||\n                           svcmpeq_n_u8(pg, chars, 'u') || svcmpeq_n_u8(pg, chars, 'U');\n\n        // Replace vowels with char 2 positions ahead\n        svuint8_t vowel_replaced = svadd_n_u8_z(is_vowel, chars, 2);\n        chars = svsel_u8(is_vowel, vowel_replaced, chars);\n\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\nstd::string encode_simd(const std::string& message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)&result[i]);\n\n        // Create masks for different cases\n        svbool_t is_lower = svcmpge_n_u8(pg, chars, 'a') && svcmple_n_u8(pg, chars, 'z');\n        svbool_t is_upper = svcmpge_n_u8(pg, chars, 'A') && svcmple_n_u8(pg, chars, 'Z');\n        \n        // Swap case\n        svuint8_t lower_to_upper = svsub_n_u8_z(is_lower, chars, 32);\n        svuint8_t upper_to_lower = svadd_n_u8_z(is_upper, chars, 32);\n        chars = svsel_u8(is_lower, lower_to_upper, chars);\n        chars = svsel_u8(is_upper, upper_to_lower, chars);\n\n        // Create vowel masks\n        svbool_t is_a = svcmpeq_n_u8(pg, chars, 'a') || svcmpeq_n_u8(pg, chars, 'A');\n        svbool_t is_e = svcmpeq_n_u8(pg, chars, 'e') || svcmpeq_n_u8(pg, chars, 'E');\n        svbool_t is_i = svcmpeq_n_u8(pg, chars, 'i') || svcmpeq_n_u8(pg, chars, 'I');\n        svbool_t is_o = svcmpeq_n_u8(pg, chars, 'o') || svcmpeq_n_u8(pg, chars, 'O');\n        svbool_t is_u = svcmpeq_n_u8(pg, chars, 'u') || svcmpeq_n_u8(pg, chars, 'U');\n\n        // Replace vowels with char 2 ahead\n        chars = svsel_u8(is_a, svdup_n_u8('C'), chars);\n        chars = svsel_u8(is_e, svdup_n_u8('G'), chars); \n        chars = svsel_u8(is_i, svdup_n_u8('K'), chars);\n        chars = svsel_u8(is_o, svdup_n_u8('Q'), chars);\n        chars = svsel_u8(is_u, svdup_n_u8('W'), chars);\n\n        svst1_u8(pg, (uint8_t*)&result[i], chars);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Extract all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check first key to determine expected case\n    bool expect_upper = isupper(keys[0][0]);\n    bool expect_lower = islower(keys[0][0]);\n    \n    if (!expect_upper && !expect_lower) {\n        return false;\n    }\n\n    // Process each key\n    for (const auto& key : keys) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n        size_t i = 0;\n\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        while (svptest_first(svptrue_b8(), pg)) {\n            svint8_t chars = svld1_s8(pg, (int8_t*)&str[i]);\n            \n            if (expect_upper) {\n                // Check if any char is not uppercase\n                svbool_t is_upper = svcmpge_s8(pg, chars, svdup_n_s8('A'));\n                svbool_t is_upper2 = svcmple_s8(pg, chars, svdup_n_s8('Z'));\n                svbool_t valid = svand_b_z(pg, is_upper, is_upper2);\n                \n                if (!svptest_all(pg, valid)) {\n                    return false;\n                }\n            } else {\n                // Check if any char is not lowercase\n                svbool_t is_lower = svcmpge_s8(pg, chars, svdup_n_s8('a')); \n                svbool_t is_lower2 = svcmple_s8(pg, chars, svdup_n_s8('z'));\n                svbool_t valid = svand_b_z(pg, is_lower, is_lower2);\n                \n                if (!svptest_all(pg, valid)) {\n                    return false;\n                }\n            }\n            \n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Extract all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check first key to determine if we should check for all upper or all lower\n    bool check_upper = isupper(keys[0][0]);\n    \n    // Process each key\n    for (const auto& key : keys) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n        \n        // Create predicate for valid characters\n        svbool_t pg = svwhilelt_b8(0, len);\n        \n        while (svptest_any(pg, pg)) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)str);\n            \n            if (check_upper) {\n                // Check if any char is not uppercase\n                svbool_t is_upper = svcmpge_u8(pg, chars, svdup_n_u8('A'));\n                svbool_t is_upper2 = svcmple_u8(pg, chars, svdup_n_u8('Z'));\n                svbool_t valid = svand_b_z(pg, is_upper, is_upper2);\n                \n                if (!svptest_all(pg, valid)) {\n                    return false;\n                }\n            } else {\n                // Check if any char is not lowercase\n                svbool_t is_lower = svcmpge_u8(pg, chars, svdup_n_u8('a')); \n                svbool_t is_lower2 = svcmple_u8(pg, chars, svdup_n_u8('z'));\n                svbool_t valid = svand_b_z(pg, is_lower, is_lower2);\n                \n                if (!svptest_all(pg, valid)) {\n                    return false;\n                }\n            }\n            \n            str += svcntb();\n            pg = svwhilelt_b8(len, len + svcntb());\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Extract all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check first key to determine expected case\n    bool expect_upper = isupper(keys[0][0]);\n    bool expect_lower = islower(keys[0][0]); \n    \n    if (!expect_upper && !expect_lower) {\n        return false;\n    }\n\n    // Process each key\n    for (const auto& key : keys) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n        \n        svbool_t pg = svwhilelt_b8(0, len);\n        \n        while (svptest_any(pg, pg)) {\n            svint8_t chars = svld1_s8(pg, (int8_t*)str);\n            \n            if (expect_upper) {\n                // Check if any char is lowercase\n                svbool_t is_lower = svcmpge_n_s8(pg, chars, 'a');\n                svbool_t is_lower_z = svand_z(pg, is_lower, \n                                            svcmple_n_s8(pg, chars, 'z'));\n                if (svptest_any(pg, is_lower_z)) {\n                    return false;\n                }\n            } else {\n                // Check if any char is uppercase  \n                svbool_t is_upper = svcmpge_n_s8(pg, chars, 'A');\n                svbool_t is_upper_z = svand_z(pg, is_upper,\n                                            svcmple_n_s8(pg, chars, 'Z')); \n                if (svptest_any(pg, is_upper_z)) {\n                    return false;\n                }\n            }\n            \n            str += svcntb();\n            pg = svwhilelt_b8(len - (str - key.c_str()), len);\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Extract all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check first key to determine if we should check for all upper or all lower\n    bool check_upper = isupper(keys[0][0]);\n    \n    // Process each key\n    for (const auto& key : keys) {\n        const char* str = key.c_str();\n        size_t len = key.length();\n        size_t i = 0;\n\n        svbool_t pg = svwhilelt_b8(i, len);\n        \n        while (svptest_first(svptrue_b8(), pg)) {\n            svint8_t chars = svld1_s8(pg, (int8_t*)&str[i]);\n            \n            if (check_upper) {\n                // Check if any char is not uppercase\n                svbool_t is_upper = svcmpge_s8(pg, chars, svdup_n_s8('A'));\n                svbool_t is_upper2 = svcmple_s8(pg, chars, svdup_n_s8('Z')); \n                svbool_t valid = svand_b_z(pg, is_upper, is_upper2);\n                \n                if (!svptest_all(pg, valid)) {\n                    return false;\n                }\n            } else {\n                // Check if any char is not lowercase\n                svbool_t is_lower = svcmpge_s8(pg, chars, svdup_n_s8('a'));\n                svbool_t is_lower2 = svcmple_s8(pg, chars, svdup_n_s8('z'));\n                svbool_t valid = svand_b_z(pg, is_lower, is_lower2);\n                \n                if (!svptest_all(pg, valid)) {\n                    return false;\n                }\n            }\n            \n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    // Extract all keys into a vector\n    std::vector<std::string> keys;\n    for (const auto& pair : dict) {\n        keys.push_back(pair.first);\n    }\n\n    // Check if first key is all lowercase or uppercase to determine mode\n    bool check_upper = std::isupper(keys[0][0]);\n    \n    // Process each key\n    for (const auto& key : keys) {\n        // Get length of current key\n        size_t len = key.length();\n        \n        // Process characters in chunks using SVE\n        for (size_t i = 0; i < len; i += svcntw()) {\n            // Create predicate for valid elements\n            svbool_t pred = svwhilelt_b32(i, len);\n            \n            // Load chunk of characters\n            svint32_t chars = svld1_s32(pred, (int32_t*)&key[i]);\n            \n            if (check_upper) {\n                // Check if any char is lowercase\n                svbool_t is_lower = svcmpge_n_s32(pred, chars, 'a');\n                svbool_t is_letter = svcmple_n_s32(pred, chars, 'z'); \n                svbool_t has_lower = svand_b_z(pred, is_lower, is_letter);\n                \n                if (svptest_any(pred, has_lower)) {\n                    return false;\n                }\n            } else {\n                // Check if any char is uppercase\n                svbool_t is_upper = svcmpge_n_s32(pred, chars, 'A');\n                svbool_t is_letter = svcmple_n_s32(pred, chars, 'Z');\n                svbool_t has_upper = svand_b_z(pred, is_upper, is_letter);\n                \n                if (svptest_any(pred, has_upper)) {\n                    return false;\n                }\n            }\n            \n            // Check if any char is non-alphabetic\n            svbool_t is_alpha = svcmpge_n_s32(pred, chars, 'A');\n            svbool_t is_upper_alpha = svcmple_n_s32(pred, chars, 'Z');\n            svbool_t is_lower_alpha = svcmpge_n_s32(pred, chars, 'a');\n            svbool_t is_lower_z = svcmple_n_s32(pred, chars, 'z');\n            \n            svbool_t upper_range = svand_b_z(pred, is_alpha, is_upper_alpha);\n            svbool_t lower_range = svand_b_z(pred, is_lower_alpha, is_lower_z);\n            svbool_t is_letter_range = svorr_b_z(pred, upper_range, lower_range);\n            \n            if (!svptest_all(pred, is_letter_range)) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    // Create predicate and vector registers\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_nums = svindex_s32(3, 2); // Start from 3, increment by 2\n    \n    for (int i = 3; i < n; i += 2) {\n        bool is_prime = true;\n        int sqrt_i = sqrt(i);\n        \n        // Check divisibility using SVE\n        svbool_t pred = svwhilelt_b32(0, primes.size());\n        svint32_t vec_primes = svld1_s32(pred, primes.data());\n        \n        while (svptest_first(pred, pred)) {\n            svint32_t remainders = svdiv_s32_z(pred, svdup_n_s32(i), vec_primes);\n            remainders = svmul_s32_z(pred, remainders, vec_primes);\n            remainders = svsub_n_s32_z(pred, remainders, i);\n            \n            svbool_t div_check = svcmpeq_s32(pred, remainders, 0);\n            if (svptest_any(pred, div_check)) {\n                is_prime = false;\n                break;\n            }\n            \n            pred = svwhilelt_b32(svlen_s32(), primes.size());\n            vec_primes = svld1_s32(pred, primes.data() + svlen_s32());\n        }\n        \n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    // Create SVE vectors and predicates\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers 3 to n-1 in SVE vector chunks\n    for (int i = 3; i < n; i += svcntw()) {\n        // Create vector of consecutive numbers\n        svint32_t vec_nums = svindex_s32(i, 1);\n        \n        // Create predicate for numbers in range\n        svbool_t pred = svcmplt_n_s32(pg, vec_nums, n);\n        \n        // For each number in vector chunk\n        svint32_t vec_num = svsel_s32(pred, vec_nums, svdup_n_s32(0));\n        uint64_t vl = svcntp_b32(pred, pred);\n        \n        for (uint64_t j = 0; j < vl; j++) {\n            int num = svextw_s32_x(pred, vec_num, j);\n            if (num == 0) continue;\n            \n            bool is_prime = true;\n            for (int k = 2; k * k <= num; k++) {\n                if (num % k == 0) {\n                    is_prime = false;\n                    break;\n                }\n            }\n            \n            if (is_prime) {\n                primes.push_back(num);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    // Create predicate for numbers up to n\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Create vector of consecutive integers starting from 3\n    svint32_t vec_nums = svindex_s32(3, 2);\n    \n    // Process numbers in chunks of vector length\n    for (int i = 3; i < n; i += svcntw()) {\n        svbool_t active = svwhilelt_b32(i, n);\n        svint32_t curr_nums = svadd_s32_z(active, vec_nums, svdup_s32(i - 3));\n        \n        // For each number, check if it's prime\n        svbool_t is_prime = svdup_b32(1);\n        \n        // Test divisibility up to sqrt(n)\n        for (int j = 2; j * j <= n; j++) {\n            svint32_t divisor = svdup_s32(j);\n            svint32_t remainder = svrem_s32_z(active, curr_nums, divisor);\n            svbool_t not_divisible = svcmpne_s32(active, remainder, svdup_s32(0));\n            is_prime = svand_b_z(active, is_prime, not_divisible);\n        }\n        \n        // Extract prime numbers and add to result vector\n        svint32_t prime_nums = svsel_s32(is_prime, curr_nums, svdup_s32(0));\n        \n        uint64_t vl = svcntp_b32(pg, is_prime);\n        for (uint64_t j = 0; j < vl; j++) {\n            int val = svextw_s32_x(svptrue_b32(), prime_nums, j);\n            if (val != 0 && val < n) {\n                primes.push_back(val);\n            }\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    // Create SVE vectors and predicates\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers 3 to n-1 in SVE vector chunks\n    for (int i = 3; i < n; i += svcntw()) {\n        // Create vector of consecutive integers\n        svint32_t vec_nums = svindex_s32(i, 1);\n        \n        // Create predicate for valid range\n        svbool_t valid = svcmplt_n_s32(pg, vec_nums, n);\n        \n        // For each number in chunk\n        svint32_t vec_div = svindex_s32(2, 1);\n        svbool_t is_prime = svptrue_b32();\n        \n        do {\n            // Check divisibility\n            svint32_t vec_rem = svdiv_s32_z(valid, vec_nums, vec_div);\n            vec_rem = svmls_s32_z(valid, vec_rem, vec_div, vec_nums);\n            svbool_t not_div = svcmpeq_n_s32(valid, vec_rem, 0);\n            \n            // Update prime flags\n            is_prime = svand_b_z(valid, is_prime, svnot_b_z(valid, not_div));\n            \n            // Increment divisor\n            vec_div = svadd_n_s32_z(valid, vec_div, 1);\n            \n        } while (svptest_any(valid, svcmplt_s32(valid, svmul_s32_z(valid, vec_div, vec_div), vec_nums)));\n        \n        // Extract prime numbers using predicate\n        svbool_t final_pred = svand_b_z(pg, valid, is_prime);\n        \n        // Store prime numbers\n        svint32_t prime_vals = svcompact_s32(final_pred, vec_nums);\n        uint64_t count = svcntp_b32(pg, final_pred);\n        \n        for (uint64_t j = 0; j < count; j++) {\n            primes.push_back(svextw_s32_x(pg, prime_vals, j));\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) return {};\n    \n    std::vector<int> primes;\n    primes.push_back(2);\n    \n    // Create predicate and vector types\n    svbool_t pg = svptrue_b32();\n    \n    // Process numbers 3 to n-1 in chunks\n    for (int i = 3; i < n; i += 2) {\n        bool is_prime = true;\n        int sqrt_i = sqrt(i);\n        \n        // Create vector of divisors\n        svint32_t vec_divisors = svindex_s32(3, 2);\n        \n        // Create vector of i values\n        svint32_t vec_i = svdup_n_s32(i);\n        \n        // Calculate vector length\n        uint64_t vl = svcntw();\n        \n        // Check divisibility in parallel chunks\n        for (int j = 3; j <= sqrt_i; j += vl * 2) {\n            // Create active predicate for valid divisors\n            svbool_t p = svwhilelt_b32(j, sqrt_i + 1);\n            \n            // Calculate remainders\n            svint32_t vec_rem = svdiv_z(p, vec_i, vec_divisors);\n            vec_rem = svmls_z(p, vec_i, vec_divisors, vec_rem);\n            \n            // Check if any remainder is 0\n            svbool_t is_div = svcmpeq_n_s32(p, vec_rem, 0);\n            \n            if (svptest_any(pg, is_div)) {\n                is_prime = false;\n                break;\n            }\n            \n            // Update divisors for next iteration\n            vec_divisors = svadd_n_s32_z(p, vec_divisors, vl * 2);\n        }\n        \n        if (is_prime) {\n            primes.push_back(i);\n        }\n    }\n    \n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)str);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_z(pg, svdup_b8(true), \n                                   svcmpeq_n_u8(pg, svindex_u8(0, 1), 0));\n        \n        // Check for uppercase vowels (A,E,I,O,U)\n        svbool_t isA = svcmpeq_n_u8(pg, chars, 'A');\n        svbool_t isE = svcmpeq_n_u8(pg, chars, 'E'); \n        svbool_t isI = svcmpeq_n_u8(pg, chars, 'I');\n        svbool_t isO = svcmpeq_n_u8(pg, chars, 'O');\n        svbool_t isU = svcmpeq_n_u8(pg, chars, 'U');\n        \n        // Combine vowel checks\n        svbool_t isVowel = svorr_z(pg,\n                           svorr_z(pg,\n                           svorr_z(pg,\n                           svorr_z(pg, isA, isE),\n                           isI),\n                           isO),\n                           isU);\n                           \n        // Combine with even index mask\n        svbool_t matches = svand_z(pg, even_mask, isVowel);\n        \n        // Count matches\n        count += svcntp_b8(svptrue_b8(), matches);\n        \n        // Update pointer and predicate for next iteration\n        size_t vl = svcntb();\n        str += vl;\n        pg = svwhilelt_b8(vl, len);\n        len -= vl;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)str);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_z(pg, pg, svdup_n_u8(1));\n        \n        // Create mask for uppercase vowels (A,E,I,O,U)\n        svuint8_t ch = svand_z(pg, chars, svdup_n_u8(0xDF)); // Convert to uppercase\n        svbool_t vowel_A = svcmpeq_n_u8(pg, ch, 'A');\n        svbool_t vowel_E = svcmpeq_n_u8(pg, ch, 'E');\n        svbool_t vowel_I = svcmpeq_n_u8(pg, ch, 'I');\n        svbool_t vowel_O = svcmpeq_n_u8(pg, ch, 'O');\n        svbool_t vowel_U = svcmpeq_n_u8(pg, ch, 'U');\n        \n        svbool_t vowel_mask = svorr_z(pg,\n                                svorr_z(pg,\n                                    svorr_z(pg,\n                                        svorr_z(pg, vowel_A, vowel_E),\n                                        vowel_I),\n                                    vowel_O),\n                                vowel_U);\n        \n        // Check if character is uppercase\n        svbool_t upper_mask = svand_z(pg,\n                                svcmpge_n_u8(pg, chars, 'A'),\n                                svcmple_n_u8(pg, chars, 'Z'));\n        \n        // Combine all conditions\n        svbool_t final_mask = svand_z(pg,\n                                svand_z(pg, even_mask, vowel_mask),\n                                upper_mask);\n        \n        count += svcntp_b8(svptrue_b8(), final_mask);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(svcntb(), len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)str);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_z(pg, svdup_b8(true), \n                                   svcmpeq_n_u8(svindex_u8(0, 1), 0));\n        \n        // Check for uppercase vowels A,E,I,O,U\n        svbool_t isA = svcmpeq_n_u8(pg, chars, 'A');\n        svbool_t isE = svcmpeq_n_u8(pg, chars, 'E'); \n        svbool_t isI = svcmpeq_n_u8(pg, chars, 'I');\n        svbool_t isO = svcmpeq_n_u8(pg, chars, 'O');\n        svbool_t isU = svcmpeq_n_u8(pg, chars, 'U');\n        \n        // Combine vowel masks\n        svbool_t isVowel = svorr_z(pg, isA, isE);\n        isVowel = svorr_z(pg, isVowel, isI);\n        isVowel = svorr_z(pg, isVowel, isO);\n        isVowel = svorr_z(pg, isVowel, isU);\n        \n        // Final mask for even indices with uppercase vowels\n        svbool_t final_mask = svand_z(pg, even_mask, isVowel);\n        \n        // Count matches\n        count += svcntp_b8(svptrue_b8(), final_mask);\n        \n        size_t vl = svcntb();\n        str += vl;\n        pg = svwhilelt_b8(vl, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)str);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_z(pg, pg, svnot_z(pg, svdup_b8(0xAA)));\n        \n        // Create mask for uppercase vowels (A,E,I,O,U)\n        svuint8_t v = svdup_n_u8(0);\n        v = svorr_z(pg, v, svcmpeq_n_u8(pg, chars, 'A'));\n        v = svorr_z(pg, v, svcmpeq_n_u8(pg, chars, 'E')); \n        v = svorr_z(pg, v, svcmpeq_n_u8(pg, chars, 'I'));\n        v = svorr_z(pg, v, svcmpeq_n_u8(pg, chars, 'O'));\n        v = svorr_z(pg, v, svcmpeq_n_u8(pg, chars, 'U'));\n        \n        // Combine masks and count matches\n        svbool_t match = svand_z(pg, even_mask, svptrue_b8());\n        match = svand_z(pg, match, svcmpne_n_u8(pg, v, 0));\n        \n        count += svcntp_b8(pg, match);\n        \n        str += svcntb();\n        pg = svwhilelt_b8(str - s.c_str(), len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\nint count_upper_simd(const std::string& s) {\n    int count = 0;\n    int len = s.length();\n    const char* str = s.c_str();\n    \n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    while (svptest_first(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (uint8_t*)str);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svand_z(pg, svdup_b8(true), \n                                   svcmpeq_n_u8(svindex_u8(0, 1), 0));\n        \n        // Check for uppercase vowels A,E,I,O,U\n        svbool_t isA = svcmpeq_n_u8(pg, chars, 'A');\n        svbool_t isE = svcmpeq_n_u8(pg, chars, 'E'); \n        svbool_t isI = svcmpeq_n_u8(pg, chars, 'I');\n        svbool_t isO = svcmpeq_n_u8(pg, chars, 'O');\n        svbool_t isU = svcmpeq_n_u8(pg, chars, 'U');\n        \n        // Combine vowel masks\n        svbool_t isVowel = svorr_z(pg, isA, isE);\n        isVowel = svorr_z(pg, isVowel, isI);\n        isVowel = svorr_z(pg, isVowel, isO);\n        isVowel = svorr_z(pg, isVowel, isU);\n        \n        // Final mask for even indices with uppercase vowels\n        svbool_t final_mask = svand_z(pg, even_mask, isVowel);\n        \n        // Count matches\n        count += svcntp_b8(svptrue_b8(), final_mask);\n        \n        size_t vl = svcntb();\n        str += vl;\n        pg = svwhilelt_b8(vl, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    // Get vector length\n    const int vl = svcntw();\n    \n    // Create index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Create vector with all 2's for increment\n    svint32_t twos = svdup_s32(2);\n    \n    // Process elements in chunks of vl\n    for (int i = 0; i < n; i += vl) {\n        // Get actual vector length for this iteration\n        int this_vl = (n - i < vl) ? n - i : vl;\n        \n        // Create predicate for active lanes\n        svbool_t pred = svwhilelt_b32(i, n);\n        \n        // Load base value\n        svint32_t base = svdup_s32(n + (i * 2));\n        \n        // Calculate values for this chunk\n        svint32_t values = svadd_s32_z(pred, base, svmul_s32_z(pred, indices, twos));\n        \n        // Store results\n        svst1_s32(pred, &result[i], values);\n        \n        // Update indices for next iteration\n        indices = svadd_s32_z(svptrue_b32(), indices, svdup_s32(vl));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    // Create vector of indices [0,1,2,...]\n    svbool_t pg = svwhilelt_b32(0, n-1);\n    svuint32_t indices = svindex_u32(1, 1);\n    \n    // Create vector of 2's for increment\n    svint32_t twos = svdup_n_s32(2);\n    \n    // Calculate remaining elements\n    svint32_t base = svdup_n_s32(n);\n    svint32_t increments = svmul_x(pg, svreinterpret_s32_u32(indices), twos);\n    svint32_t result_vec = svadd_x(pg, base, increments);\n    \n    // Store results\n    svst1_s32(pg, &result[1], result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    // Create vector of indices [0,1,2,...]\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Create vector with first value n\n    svint32_t vec = svdup_s32(n);\n    \n    // Add 2 to each index to get next number in sequence\n    svint32_t increment = svmul_n_s32_x(pg, indices, 2);\n    increment = svadd_n_s32_x(pg, increment, 2);\n    \n    // Add increment to base vector\n    svint32_t result_vec = svadd_s32_x(pg, vec, increment);\n    \n    // Store result\n    svst1_s32(pg, &result[1], result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    // Get vector length\n    const int vl = svcntw();\n    \n    // Initialize index vector\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Create predicate for active lanes\n    svbool_t pred = svwhilelt_b32(0, n-1);\n    \n    // Create vector with first value n\n    svint32_t vec = svdup_s32(n);\n    \n    // Add 2 to each index to get next number in sequence\n    svint32_t increment = svmul_n_s32_x(pred, indices, 2);\n    increment = svadd_n_s32_x(pred, increment, 2);\n    \n    // Add increment to base value\n    svint32_t result_vec = svadd_s32_x(pred, vec, increment);\n    \n    // Store result\n    svst1_s32(pred, &result[1], result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize first element\n    result[0] = n;\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    // Create vector of indices [0,1,2,...]\n    svint32_t indices = svindex_s32(0, 1);\n    \n    // Create vector with first value n\n    svint32_t vec = svdup_s32(n);\n    \n    // Add 2 to each element based on index\n    svint32_t increment = svmul_s32_z(pg, indices, svdup_s32(2));\n    increment = svadd_s32_z(pg, increment, svdup_s32(2));\n    \n    // Add increment to base vector\n    svint32_t result_vec = svadd_s32_z(pg, vec, increment);\n    \n    // Store result\n    svst1_s32(pg, &result[1], result_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t vl = svcntd();\n    \n    svbool_t pg = svwhilelt_b64(0, count);\n    svint64_t sum = svdup_s64(0);\n    svint64_t vec_idx = svindex_s64(0, 1);\n    \n    for (int64_t i = 0; i < count; i += vl) {\n        svbool_t p = svwhilelt_b64(i, count);\n        svint64_t vec = svadd_z(p, svdup_s64(n), vec_idx);\n        sum = svadd_m(p, sum, sum, vec);\n        vec_idx = svadd_n_s64_z(pg, vec_idx, vl);\n    }\n    \n    int64_t total = 0;\n    for (int64_t i = 0; i < vl; i++) {\n        total += svextract_s64(sum, i);\n    }\n    \n    int64_t avg = total / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t vl = svcntd();\n    \n    svbool_t pg = svwhilelt_b64(0, count);\n    svint64_t sum = svdup_s64(0);\n    svint64_t vec_idx = svindex_s64(0, 1);\n    \n    for (int64_t i = 0; i < count; i += vl) {\n        svint64_t vec = svadd_z(pg, svdup_s64(n + i), vec_idx);\n        sum = svadd_m(pg, sum, vec);\n        pg = svwhilelt_b64(i + vl, count);\n    }\n    \n    int64_t total = svaddv(svptrue_b64(), sum);\n    int64_t avg = total / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t vl = svcntd();\n    \n    svbool_t pg = svwhilelt_b64(0, count);\n    svint64_t sum = svdup_s64(0);\n    svint64_t vec_idx = svindex_s64(0, 1);\n    \n    for (int64_t i = 0; i < count; i += vl) {\n        svint64_t vec = svadd_s64_z(pg, svdup_s64(n + i), vec_idx);\n        sum = svadd_s64_m(pg, sum, sum, vec);\n        pg = svwhilelt_b64(i + vl, count);\n    }\n    \n    int64_t total = 0;\n    pg = svptrue_b64();\n    total = svaddv_s64(pg, sum);\n    \n    int64_t avg = total / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string binary;\n    while (avg > 0) {\n        binary = (avg % 2 ? \"1\" : \"0\") + binary;\n        avg /= 2;\n    }\n    \n    return binary;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t vl = svcntd();\n    \n    svbool_t pg = svwhilelt_b64(0, count);\n    svint64_t sum = svdup_s64(0);\n    svint64_t vec_idx = svindex_s64(0, 1);\n    \n    for (int64_t i = 0; i < count; i += vl) {\n        svbool_t p = svwhilelt_b64(i, count);\n        svint64_t vec = svadd_z(p, svdup_s64(n), vec_idx);\n        sum = svadd_m(p, sum, vec);\n        vec_idx = svadd_n_s64_z(pg, vec_idx, vl);\n    }\n    \n    int64_t total = 0;\n    svbool_t ptrue = svptrue_b64();\n    total = svaddv(ptrue, sum);\n    \n    int64_t avg = total / count;\n    \n    if (avg <= 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg % 2 ? \"1\" : \"0\") + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) return \"-1\";\n    \n    int64_t count = m - n + 1;\n    int64_t vl = svcntd();\n    \n    svbool_t pg = svwhilelt_b64(0, count);\n    svint64_t sum = svdup_s64(0);\n    svint64_t vec_idx = svindex_s64(0, 1);\n    \n    for (int64_t i = 0; i < count; i += vl) {\n        svint64_t vec = svadd_z(pg, svdup_s64(n + i), vec_idx);\n        sum = svadd_m(pg, sum, vec);\n        pg = svwhilelt_b64(i + vl, count);\n    }\n    \n    int64_t total = svaddv(svptrue_b64(), sum);\n    int64_t avg = total / count;\n    \n    if (avg == 0) return \"0\";\n    \n    std::string result;\n    while (avg > 0) {\n        result = (avg % 2 ? '1' : '0') + result;\n        avg /= 2;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    // Initialize indices vector starting from 1\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svadd_n_s32_z(pg, svindex_s32(0, 1), 1);\n    \n    // Process elements in chunks of vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        indices = svadd_n_s32_z(pg, svindex_s32(i, 1), 1);\n        \n        // Create mask for even indices\n        svbool_t even_mask = svcmpeq_n_s32(pg, svand_n_s32_z(pg, indices, 1), 0);\n        \n        // Calculate factorial for even indices\n        svint32_t fact = svdup_n_s32(1);\n        svint32_t j = svdup_n_s32(1);\n        svbool_t fact_pg = svand_b_z(pg, even_mask, pg);\n        \n        while (svptest_any(fact_pg)) {\n            fact = svmul_s32_z(fact_pg, fact, j);\n            fact = svand_n_s32_z(fact_pg, fact, 9999); // Modulo 10000\n            j = svadd_n_s32_z(fact_pg, j, 1);\n            fact_pg = svand_b_z(pg, even_mask, \n                               svcmplt_n_s32(pg, j, svadd_n_s32_z(pg, indices, 1)));\n        }\n        \n        // Calculate sum for odd indices\n        svint32_t sum = svmul_n_s32_z(pg, indices, \n                                     svadd_n_s32_z(pg, indices, 1));\n        sum = svdiv_n_s32_z(pg, sum, 2);\n        \n        // Combine results based on even/odd mask\n        svint32_t final = svsel(even_mask, fact, sum);\n        \n        // Store results\n        svst1_s32(pg, &result[i], final);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n    svint32_t ones = svdup_s32(1);\n    svint32_t zeros = svdup_s32(0);\n    svint32_t mod = svdup_s32(10000);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec_i = svindex_s32(i + 1, 1);\n        \n        // Calculate factorial for even indices\n        svint32_t fact = svdup_s32(1);\n        svint32_t j = ones;\n        \n        svbool_t p_fact = svwhilelt_b32(0, svadd_x(p, svmaxv_s32(p, vec_i), 1));\n        while (svptest_first(p_fact, svtrue_b32())) {\n            fact = svmul_x(p, fact, j);\n            fact = svmod_x(p, fact, mod);\n            j = svadd_x(p, j, ones);\n            p_fact = svwhilelt_b32(0, svsub_x(p, svadd_x(p, svmaxv_s32(p, vec_i), 1), \n                                             svadd_x(p, svmaxv_s32(p, j), -1)));\n        }\n        \n        // Calculate sum for odd indices\n        svint32_t sum = svmul_x(p, vec_i, svadd_x(p, vec_i, ones));\n        sum = svdiv_x(p, sum, svdup_s32(2));\n        \n        // Select based on even/odd\n        svbool_t is_even = svcmpeq_n_s32(p, svand_x(p, vec_i, svdup_s32(1)), 0);\n        svint32_t final = svsel(is_even, fact, sum);\n        \n        svst1_s32(p, &result[i], final);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n    svint32_t zeros = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n    svint32_t twos = svdup_s32(2);\n    svint32_t mod = svdup_s32(10000);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        // Get current indices\n        svint32_t curr_indices = svadd_s32_z(p, indices, svdup_s32(i-1));\n        \n        // Calculate factorial for even indices\n        svint32_t fact = ones;\n        for (int j = 1; j <= n; j++) {\n            svint32_t j_vec = svdup_s32(j);\n            svbool_t mask = svand_b_z(p, \n                                    svdup_b32(1),\n                                    svcmple_n_s32(j_vec, curr_indices));\n            fact = svmul_s32_m(mask, fact, j_vec);\n            fact = svrem_s32_z(p, fact, mod); // Keep result under 10000\n        }\n        \n        // Calculate sum for odd indices \n        svint32_t sum = svmul_s32_z(p, curr_indices, \n                                   svadd_s32_z(p, curr_indices, ones));\n        sum = svdiv_s32_z(p, sum, twos);\n        \n        // Select factorial or sum based on even/odd\n        svbool_t is_even = svcmpeq_n_s32(\n            svrem_s32_z(p, curr_indices, twos), 0);\n        \n        svint32_t final = svsel_s32(is_even, fact, sum);\n        \n        // Store results\n        svst1_s32(p, &result[i], final);\n        \n        indices = svadd_s32_z(pg, indices, svdup_s32(svcntw()));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n    svint32_t ones = svdup_s32(1);\n    svint32_t zeros = svdup_s32(0);\n    svint32_t mod = svdup_s32(10000);\n    \n    // Initialize result vector\n    svst1_s32(pg, result.data(), indices);\n    \n    // Process elements in chunks of vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        indices = svindex_s32(i + 1, 1);\n        \n        // Calculate factorial for even indices\n        svint32_t fact = svdup_s32(1);\n        for (int j = 1; j <= n; j++) {\n            svbool_t mask = svand_b_z(pg, svcmple_n_s32(pg, j, indices));\n            fact = svmul_m(mask, fact, svdup_n_s32(j));\n            fact = svrem_m(mask, fact, mod); // Keep result within bounds\n        }\n        \n        // Calculate sum for odd indices\n        svint32_t sum = svmul_s32_z(pg, indices, svadd_n_s32(indices, 1));\n        sum = svdiv_n_s32_z(pg, sum, 2);\n        \n        // Select between factorial and sum based on even/odd\n        svbool_t is_even = svcmpeq_n_s32(pg, svand_n_s32_z(pg, indices, 1), 0);\n        svint32_t result_vec = svsel(is_even, fact, sum);\n        \n        // Store results\n        svst1_s32(pg, &result[i], result_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t indices = svindex_s32(1, 1);\n    svint32_t ones = svdup_s32(1);\n    svint32_t zeros = svdup_s32(0);\n    svint32_t mod = svdup_s32(10000);\n    \n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec_i = svadd_s32_z(p, svindex_s32(i + 1, 1), zeros);\n        \n        // Calculate factorial for even indices\n        svint32_t fact = svdup_s32(1);\n        for (int j = 1; j <= n; j++) {\n            svbool_t p_fact = svand_b_z(p, p, svcmple_n_s32(svdup_s32(j), vec_i));\n            fact = svmul_s32_m(p_fact, fact, svdup_s32(j));\n            fact = svmod_s32_m(p_fact, fact, mod);\n        }\n        \n        // Calculate sum for odd indices\n        svint32_t sum = svmul_s32_z(p, vec_i, svadd_s32_z(p, vec_i, ones));\n        sum = svdiv_s32_z(p, sum, svdup_s32(2));\n        \n        // Select based on even/odd\n        svbool_t is_even = svcmpeq_n_s32(svand_s32_z(p, vec_i, svdup_s32(1)), 0);\n        svint32_t result_vec = svsel_s32(is_even, fact, sum);\n        \n        svst1_s32(p, &result[i], result_vec);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Create vector of consecutive integers from 1 to n\n    svint32_t indices = svindex_s32(1, 1);\n    \n    // Process numbers in chunks of vector length\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        // Get current chunk of numbers\n        svint32_t nums = svsel_s32(p, indices, svdup_s32(0));\n        indices = svadd_s32_z(p, indices, svdup_s32(svcntw()));\n        \n        // Check palindromes\n        svbool_t is_palindrome = svdup_b32(0);\n        \n        // Convert numbers to string representation\n        svint32_t nums_copy = nums;\n        svint32_t reversed = svdup_s32(0);\n        \n        // Reverse digits\n        svbool_t non_zero = svwhilelt_b32(0, n);\n        while (svptest_any(p, non_zero)) {\n            svint32_t digit = svdiv_s32_z(p, nums_copy, svdup_s32(10));\n            reversed = svadd_s32_z(p, svmul_s32_z(p, reversed, svdup_s32(10)), digit);\n            nums_copy = svdiv_s32_z(p, nums_copy, svdup_s32(10));\n            non_zero = svcmpne_s32(p, nums_copy, svdup_s32(0));\n        }\n        \n        // Compare original and reversed\n        is_palindrome = svcmpeq_s32(p, nums, reversed);\n        \n        // Count even/odd palindromes\n        svint32_t even_mask = svand_s32_z(p, nums, svdup_s32(1));\n        svbool_t is_even = svcmpeq_s32(p, even_mask, svdup_s32(0));\n        \n        result[0] += svcntp_b32(p, svand_b32(p, is_palindrome, is_even));\n        result[1] += svcntp_b32(p, svand_b32(p, is_palindrome, svnot_b_z(p, is_even)));\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Create vector of consecutive integers from 1 to n\n    svint32_t indices = svindex_s32(1, 1);\n    \n    while (svptest_first(pg, pg)) {\n        // Load current batch of numbers\n        svint32_t numbers = svsel_s32(pg, indices, svdup_s32(0));\n        \n        // Check palindromes\n        svbool_t is_palindrome = svdup_b32(0);\n        svint32_t temp = numbers;\n        svint32_t reversed = svdup_s32(0);\n        \n        // Reverse digits\n        svbool_t non_zero = svwhilelt_b32(0, n);\n        while (svptest_first(non_zero, temp != 0)) {\n            reversed = svmad_s32_x(non_zero, reversed, svdup_s32(10), \n                                 svand_s32_x(non_zero, temp, svdup_s32(10)));\n            temp = svdiv_s32_x(non_zero, temp, svdup_s32(10));\n        }\n        \n        // Compare original and reversed\n        is_palindrome = svcmpeq_s32(pg, numbers, reversed);\n        \n        // Count even palindromes\n        svbool_t is_even_palindrome = svand_b_z(pg, is_palindrome,\n            svcmpeq_n_s32(pg, svand_s32_z(pg, numbers, svdup_s32(1)), 0));\n        result[0] += svcntp_b32(pg, is_even_palindrome);\n        \n        // Count odd palindromes  \n        svbool_t is_odd_palindrome = svand_b_z(pg, is_palindrome,\n            svcmpne_n_s32(pg, svand_s32_z(pg, numbers, svdup_s32(1)), 0));\n        result[1] += svcntp_b32(pg, is_odd_palindrome);\n        \n        // Update indices and predicate for next iteration\n        indices = svadd_s32_z(pg, indices, svcntw());\n        pg = svwhilelt_b32(svcntw(), n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    \n    // Create predicate for active lanes\n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    // Create vector of consecutive integers from 1 to n\n    svint32_t indices = svindex_s32(1, 1);\n    \n    while (svptest_first(pg, pg)) {\n        // Get current values\n        svint32_t current = svsel_s32(pg, indices, svdup_s32(0));\n        \n        // For each number, check if it's a palindrome\n        svbool_t is_palindrome = svdup_b32(0);\n        svint32_t nums = current;\n        svint32_t reversed = svdup_s32(0);\n        \n        // Reverse digits\n        svbool_t non_zero = svwhilelt_b32(0, n);\n        while (svptest_first(non_zero, svpcmpne(nums, 0))) {\n            reversed = svadd_s32_z(non_zero, svmul_s32_z(non_zero, reversed, 10), \n                                 svmodulo_s32_z(non_zero, nums, 10));\n            nums = svdiv_s32_z(non_zero, nums, 10);\n        }\n        \n        // Check if palindrome\n        is_palindrome = svand_z(pg, pg, svcmpeq(current, reversed));\n        \n        // Count even/odd palindromes\n        svbool_t is_even = svand_z(pg, is_palindrome, \n                                  svcmpeq(svmodulo_s32_z(pg, current, 2), 0));\n        svbool_t is_odd = svand_z(pg, is_palindrome, \n                                 svcmpne(svmodulo_s32_z(pg, current, 2), 0));\n        \n        result[0] += svcntp_b32(pg, is_even);\n        result[1] += svcntp_b32(pg, is_odd);\n        \n        // Move to next block of numbers\n        indices = svadd_s32_m(pg, indices, svdup_s32(svcntw()));\n        pg = svwhilelt_b32(svcntp_b32(pg, pg), n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    \n    // Create vector of consecutive integers from 1 to n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svuint32_t indices = svindex_u32(0, 1);\n    indices = svadd_u32_z(pg, indices, 1);\n    \n    // Process each number up to n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        \n        // Get current batch of numbers\n        svuint32_t nums = svsel_u32(p, indices, svdup_u32(0));\n        \n        // Convert numbers to string to check palindrome\n        char str[16];\n        uint32_t val = svlasta_u32(p, nums);\n        sprintf(str, \"%u\", val);\n        int len = strlen(str);\n        \n        bool is_palindrome = true;\n        for (int j = 0; j < len/2; j++) {\n            if (str[j] != str[len-1-j]) {\n                is_palindrome = false;\n                break;\n            }\n        }\n        \n        if (is_palindrome) {\n            // Check if even or odd\n            svbool_t is_even = svcmpeq_n_u32(p, svand_u32_z(p, nums, 1), 0);\n            \n            // Count even palindromes\n            result[0] += svcntp_b32(p, is_even);\n            \n            // Count odd palindromes \n            result[1] += svcntp_b32(p, svnot_b_z(p, is_even));\n        }\n        \n        indices = svadd_n_u32_z(pg, indices, svcntw());\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    std::vector<int> result(2, 0);\n    \n    // Create vector of sequential integers from 1 to n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svuint32_t indices = svindex_u32(1, 1);\n    \n    while (svptest_first(pg, pg)) {\n        // Get current batch of numbers\n        svuint32_t numbers = svsel_u32(pg, indices, svdup_u32(0));\n        \n        // For each number, check if it's a palindrome\n        svbool_t is_palindrome = svdup_b32(0);\n        svuint32_t temp_nums = numbers;\n        svuint32_t reversed = svdup_u32(0);\n        \n        // Reverse digits\n        svbool_t non_zero = svwhilelt_b32(0, n);\n        while (svptest_first(non_zero, svpcmp_ne_u32(non_zero, temp_nums, 0))) {\n            reversed = svadd_u32_x(non_zero, svmul_u32_x(non_zero, reversed, 10), \n                                 svmod_u32_x(non_zero, temp_nums, 10));\n            temp_nums = svdiv_u32_x(non_zero, temp_nums, 10);\n        }\n        \n        // Check palindrome\n        is_palindrome = svcmpeq_u32(pg, numbers, reversed);\n        \n        // Count even palindromes\n        svbool_t is_even = svand_b_z(pg, is_palindrome, \n                                    svcmpeq_n_u32(svmod_u32_z(pg, numbers, 2), 0));\n        result[0] += svcntp_b32(pg, is_even);\n        \n        // Count odd palindromes  \n        svbool_t is_odd = svand_b_z(pg, is_palindrome,\n                                   svcmpne_n_u32(svmod_u32_z(pg, numbers, 2), 0));\n        result[1] += svcntp_b32(pg, is_odd);\n        \n        // Move to next batch\n        indices = svadd_u32_m(pg, indices, svdup_u32(svcntw()));\n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int* data = n.data();\n    int len = n.size();\n    \n    for (int i = 0; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &data[i]);\n        \n        // Get absolute values first\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Initialize sum vector with zeros\n        svint32_t sum = svdup_s32(0);\n        \n        // Process each number's digits\n        svbool_t active = pg;\n        while (svptest_any(pg, active)) {\n            // Get remainder (last digit)\n            svint32_t digit = svdiv_s32_z(active, abs_vec, 10);\n            svint32_t rem = svsub_s32_z(active, abs_vec, svmul_s32_z(active, digit, svdup_s32(10)));\n            \n            // For negative numbers, make first digit negative\n            svbool_t neg_mask = svand_b_z(active, svcmplt_n_s32(pg, vec, 0));\n            rem = svneg_s32_m(rem, neg_mask, rem);\n            \n            // Add digit to sum\n            sum = svadd_s32_m(active, sum, rem);\n            \n            // Update number for next iteration\n            abs_vec = digit;\n            \n            // Update active lanes - continue while number > 0\n            active = svand_b_z(pg, svcmpgt_n_s32(pg, abs_vec, 0));\n        }\n        \n        // Count numbers where sum > 0\n        svbool_t nonzero = svand_b_z(pg, svcmpne_n_s32(pg, sum, 0));\n        count += svcntp_b32(svptrue_b32(), nonzero);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int len = n.size();\n    int i = 0;\n    \n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &n[i]);\n        \n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t sum = svdup_s32(0);\n        \n        svbool_t active = pg;\n        while (svptest_any(pg, active)) {\n            svint32_t digit = svdiv_s32_z(active, abs_vec, 10);\n            svint32_t rem = svsub_s32_z(active, abs_vec, svmul_s32_z(active, digit, svdup_s32(10)));\n            \n            // For negative numbers, make first digit negative\n            svbool_t neg_mask = svcmplt_s32(pg, vec, svdup_s32(0));\n            svint32_t signed_rem = svneg_s32_m(rem, neg_mask, rem);\n            neg_mask = svpfalse_b();  // Clear mask after first digit\n            \n            sum = svadd_s32_z(active, sum, signed_rem);\n            abs_vec = digit;\n            active = svptest_any(pg, digit);\n        }\n        \n        svbool_t nonzero = svcmpne_s32(pg, sum, svdup_s32(0));\n        count += svcntp_b32(pg, nonzero);\n        \n        i += svcntw();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int* data = n.data();\n    int len = n.size();\n    \n    for (int i = 0; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &data[i]);\n        \n        // Get absolute values first\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Initialize sum vector with zeros\n        svint32_t digit_sums = svdup_s32(0);\n        \n        // Keep dividing by 10 and accumulating remainders until all numbers become 0\n        svbool_t active = svwhilelt_b32(i, len);\n        while (svptest_any(pg, svpcmpne_n_s32(pg, abs_vec, 0))) {\n            // Get remainder when divided by 10\n            svint32_t remainder = svmls_n_s32_z(pg, abs_vec, svdiv_n_s32_z(pg, abs_vec, 10), 10);\n            \n            // For negative numbers in original vector, make the first digit negative\n            svbool_t neg_mask = svcmplt_n_s32(pg, vec, 0);\n            remainder = svneg_s32_m(pg, remainder, neg_mask);\n            \n            // Add remainder to running sum\n            digit_sums = svadd_s32_z(pg, digit_sums, remainder);\n            \n            // Divide by 10 for next iteration\n            abs_vec = svdiv_n_s32_z(pg, abs_vec, 10);\n        }\n        \n        // Count numbers where digit sum is not 0\n        svbool_t nonzero = svcmpne_n_s32(pg, digit_sums, 0);\n        count += svcntp_b32(pg, nonzero);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int* data = n.data();\n    int len = n.size();\n    \n    for (int i = 0; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &data[i]);\n        \n        // Get absolute values first\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Initialize sum vector with zeros\n        svint32_t sum = svdup_s32(0);\n        \n        // Process each number's digits\n        svbool_t active = pg;\n        while (svptest_any(pg, active)) {\n            // Get remainder (last digit)\n            svint32_t digit = svrem_s32_z(active, abs_vec, svdup_s32(10));\n            \n            // Add digit to sum\n            sum = svadd_s32_m(active, sum, digit);\n            \n            // Divide by 10 for next iteration\n            abs_vec = svdiv_s32_z(active, abs_vec, svdup_s32(10));\n            \n            // Update active lanes - continue if number > 0\n            active = svand_b_z(pg, active, svcmpgt_n_s32(abs_vec, 0));\n        }\n        \n        // For negative numbers, make first digit negative\n        svbool_t neg_mask = svcmplt_n_s32(pg, vec, 0);\n        svint32_t first_digit = svneg_s32_m(neg_mask, sum);\n        sum = svsel_s32(neg_mask, first_digit, sum);\n        \n        // Count numbers with non-zero digit sum\n        svbool_t nonzero = svcmpne_n_s32(pg, sum, 0);\n        count += svcntp_b32(pg, nonzero);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) return 0;\n    \n    int count = 0;\n    int* data = n.data();\n    int len = n.size();\n    \n    for (int i = 0; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t vec = svld1_s32(pg, &data[i]);\n        \n        // Get absolute values first\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        \n        // Initialize sum vector with zeros\n        svint32_t sum = svdup_s32(0);\n        \n        // Process each number's digits\n        svbool_t active = pg;\n        while (svptest_any(pg, active)) {\n            // Get remainder (last digit)\n            svint32_t digit = svdiv_s32_z(active, abs_vec, 10);\n            svint32_t rem = svsub_s32_z(active, abs_vec, svmul_s32_z(active, digit, svdup_s32(10)));\n            \n            // For negative numbers, make first digit negative\n            svbool_t neg_mask = svand_b_z(active, svcmplt_n_s32(pg, vec, 0));\n            rem = svneg_s32_m(rem, neg_mask, rem);\n            \n            // Add digit to sum\n            sum = svadd_s32_z(active, sum, rem);\n            \n            // Update number for next iteration\n            abs_vec = digit;\n            \n            // Update active lanes - continue while number > 0\n            active = svand_b_z(pg, svcmpgt_n_s32(pg, abs_vec, 0));\n        }\n        \n        // Count numbers with non-zero digit sum\n        svbool_t nonzero = svcmpne_n_s32(pg, sum, 0);\n        count += svcntp_b32(pg, nonzero);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty() || arr.size() == 1) {\n        return true;\n    }\n\n    int n = arr.size();\n    int minVal = arr[0];\n    int minIdx = 0;\n\n    // Find minimum element and its index using SVE\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vmin = svdup_n_s32(INT_MAX);\n    svint32_t vidx = svindex_s32(0, 1);\n    svint32_t vcurr_idx = svdup_n_s32(0);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vdata = svld1_s32(pg, &arr[i]);\n        svbool_t vcmp = svcmplt_s32(pg, vdata, vmin);\n        vmin = svsel_s32(vcmp, vdata, vmin);\n        vcurr_idx = svsel_s32(vcmp, svadd_n_s32_z(pg, vidx, i), vcurr_idx);\n        vidx = svadd_n_s32_z(pg, vidx, svcntw());\n    }\n\n    minVal = svminv_s32(pg, vmin);\n    minIdx = svlasta_s32(svptrue_b32(), vcurr_idx);\n\n    // Check if array can be sorted with rotations\n    int prev = minVal;\n    int curr_idx = (minIdx + 1) % n;\n    int count = 1;\n\n    while (count < n) {\n        if (arr[curr_idx] < prev) {\n            return false;\n        }\n        prev = arr[curr_idx];\n        curr_idx = (curr_idx + 1) % n;\n        count++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n == 1) return true;\n\n    // Find minimum element and its index\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, arr.data());\n    int min_val = svminv_s32(pg, vec);\n    \n    // Find all indices where minimum occurs\n    int min_idx = 0;\n    for(int i = 0; i < n; i++) {\n        if(arr[i] == min_val) {\n            min_idx = i;\n            break;\n        }\n    }\n\n    // Check if array is sorted after rotation\n    svbool_t pg1 = svwhilelt_b32(0, n-1);\n    bool sorted = true;\n    \n    // Check first part: min_idx to end\n    for(int i = min_idx; i < n-1; i++) {\n        if(arr[i] > arr[i+1]) {\n            sorted = false;\n            break;\n        }\n    }\n    \n    if(sorted) {\n        // Check second part: start to min_idx\n        for(int i = 0; i < min_idx-1; i++) {\n            if(arr[i] > arr[i+1]) {\n                sorted = false;\n                break;\n            }\n        }\n        \n        // Check connection between parts\n        if(min_idx > 0 && arr[min_idx-1] > arr[n-1]) {\n            sorted = false;\n        }\n    }\n\n    return sorted;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n == 1) return true;\n\n    // Find minimum element and its index\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, arr.data());\n    int min_val = svminv_s32(pg, vec);\n    \n    // Find all positions where minimum occurs\n    svbool_t min_mask = svcmpeq_n_s32(pg, vec, min_val);\n    int min_idx = 0;\n    for (int i = 0; i < n; i++) {\n        if (svptest_first(pg, min_mask)) {\n            min_idx = i;\n            break;\n        }\n        min_mask = svext_b32(min_mask, min_mask, 1);\n    }\n\n    // Check if array is sorted after rotation\n    for (int i = 1; i < n; i++) {\n        int curr_idx = (min_idx + i) % n;\n        int prev_idx = (min_idx + i - 1) % n;\n        if (arr[curr_idx] < arr[prev_idx]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty() || arr.size() == 1) return true;\n    \n    int n = arr.size();\n    int vl = svcntw();\n    \n    // Find position of minimum element\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec_min = svdup_n_s32(INT_MAX);\n    svuint32_t vec_min_idx = svdup_n_u32(0);\n    svuint32_t vec_idx = svindex_u32(0, 1);\n    \n    for (int i = 0; i < n; i += vl) {\n        pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        svbool_t min_mask = svcmplt_s32(pg, vec, vec_min);\n        vec_min = svsel_s32(min_mask, vec, vec_min);\n        vec_min_idx = svsel_u32(min_mask, svadd_u32_x(pg, vec_idx, i), vec_min_idx);\n        vec_idx = svadd_u32_x(pg, vec_idx, vl);\n    }\n    \n    int min_idx = svlasta_u32(svptrue_b32(), vec_min_idx);\n    \n    // Check if array is sorted after rotation\n    pg = svwhilelt_b32(0, n-1);\n    int prev = arr[(min_idx + n - 1) % n];\n    \n    for (int i = 0; i < n; i++) {\n        int curr = arr[(min_idx + i) % n];\n        if (curr < prev) return false;\n        prev = curr;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) return true;\n    \n    int n = arr.size();\n    if (n == 1) return true;\n\n    // Find minimum element and its index\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t vec = svld1_s32(pg, arr.data());\n    int min_val = svminv_s32(pg, vec);\n    int min_idx = 0;\n    \n    for(int i = 0; i < n; i++) {\n        if(arr[i] == min_val) {\n            min_idx = i;\n            break;\n        }\n    }\n\n    // Check if elements are sorted after rotation\n    svbool_t pred;\n    int prev = arr[min_idx];\n    \n    // Check first part - from min_idx to end\n    for(int i = min_idx + 1; i < n; i++) {\n        if(arr[i] < prev) return false;\n        prev = arr[i];\n    }\n    \n    // Check second part - from start to min_idx\n    prev = arr[n-1];\n    for(int i = 0; i < min_idx; i++) {\n        if(arr[i] < prev) return false;\n        prev = arr[i];\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec1 = svld1_s32(pg, lst1.data());\n        svint32_t vec2 = svld1_s32(pg, lst2.data());\n        \n        // Count odd numbers in lst1\n        svint32_t mod1 = svand_s32_z(pg, vec1, 1);\n        svbool_t odd1 = svcmpne_s32(pg, mod1, 0);\n        odd_count1 += svcntp_b32(pg, odd1);\n        \n        // Count even numbers in lst2  \n        svint32_t mod2 = svand_s32_z(pg, vec2, 1);\n        svbool_t even2 = svcmpeq_s32(pg, mod2, 0);\n        even_count2 += svcntp_b32(pg, even2);\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n);\n    }\n\n    // If we have enough even numbers in lst2 to replace odd numbers in lst1\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count_lst1 = 0;\n    int even_count_lst2 = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec1 = svld1_s32(pg, lst1.data());\n        svint32_t vec2 = svld2_s32(pg, lst2.data());\n        \n        // Count odd numbers in lst1\n        svint32_t mod1 = svand_s32_z(pg, vec1, 1);\n        svbool_t is_odd1 = svcmpne_s32(pg, mod1, 0);\n        odd_count_lst1 += svcntp_b32(pg, is_odd1);\n        \n        // Count even numbers in lst2\n        svint32_t mod2 = svand_s32_z(pg, vec2, 1); \n        svbool_t is_even2 = svcmpeq_s32(pg, mod2, 0);\n        even_count_lst2 += svcntp_b32(pg, is_even2);\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n);\n    }\n\n    return (even_count_lst2 >= odd_count_lst1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec1 = svld1_s32(pg, lst1.data());\n        svint32_t vec2 = svld1_s32(pg, lst2.data());\n        \n        // Count odd numbers in lst1\n        svint32_t mod1 = svand_s32_x(pg, vec1, 1);\n        svbool_t is_odd1 = svcmpne_s32(pg, mod1, 0);\n        odd_count1 += svcntp_b32(pg, is_odd1);\n        \n        // Count even numbers in lst2  \n        svint32_t mod2 = svand_s32_x(pg, vec2, 1);\n        svbool_t is_even2 = svcmpeq_s32(pg, mod2, 0);\n        even_count2 += svcntp_b32(pg, is_even2);\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n);\n    }\n\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    // Get vector length\n    int vl = svcntw();\n    \n    // Process vectors in chunks of vl\n    for (int i = 0; i < n; i += vl) {\n        int chunk = std::min(vl, n - i);\n        \n        // Create predicate for active elements\n        svbool_t pred = svwhilelt_b32(i, n);\n        \n        // Load chunks from both vectors\n        svint32_t vec1 = svld1_s32(pred, &lst1[i]);\n        svint32_t vec2 = svld2_s32(pred, &lst2[i]);\n        \n        // Count odd numbers in lst1\n        svint32_t mod1 = svand_s32_x(pred, vec1, 1);\n        svbool_t odd1 = svcmpne_s32(pred, mod1, 0);\n        odd_count1 += svcntp_b32(pred, odd1);\n        \n        // Count even numbers in lst2  \n        svint32_t mod2 = svand_s32_x(pred, vec2, 1);\n        svbool_t even2 = svcmpeq_s32(pred, mod2, 0);\n        even_count2 += svcntp_b32(pred, even2);\n    }\n\n    // If we have enough even numbers in lst2 to replace odd numbers in lst1\n    if (even_count2 >= odd_count1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int n = lst1.size();\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec1 = svld1_s32(pg, lst1.data());\n        svint32_t vec2 = svld1_s32(pg, lst2.data());\n        \n        // Count odd numbers in lst1\n        svint32_t mod1 = svand_s32_x(pg, vec1, 1);\n        svbool_t is_odd1 = svcmpne_s32(pg, mod1, 0);\n        odd_count1 += svcntp_b32(pg, is_odd1);\n        \n        // Count even numbers in lst2  \n        svint32_t mod2 = svand_s32_x(pg, vec2, 1);\n        svbool_t is_even2 = svcmpeq_s32(pg, mod2, 0);\n        even_count2 += svcntp_b32(pg, is_even2);\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n);\n    }\n\n    return (even_count2 >= odd_count1) ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.c_str();\n        size_t len = str.length();\n        size_t i = 0;\n        \n        svbool_t pg;\n        while (i < len) {\n            pg = svwhilelt_b8(i, len);\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)ptr + i);\n            \n            // Convert chars to numeric values by subtracting '0'\n            svuint8_t nums = svsub_n_u8_z(pg, chars, '0');\n            \n            // Check for odd numbers using bitwise AND with 1\n            svuint8_t odds = svand_n_u8_z(pg, nums, 1);\n            \n            // Count number of 1s (odd numbers)\n            odd_count += svcntp_b8(pg, svcmpne_n_u8(pg, odds, 0));\n            \n            i += svcntb();\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" + \n                                 std::to_string(odd_count) + \n                                 \"ng \" + \n                                 std::to_string(odd_count) + \n                                 \" of the \" + \n                                 std::to_string(odd_count) + \n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const char* data = str.data();\n        size_t len = str.length();\n        size_t i = 0;\n        \n        svbool_t pg = svwhilelt_b8(i, len);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)data + i);\n            \n            // Convert chars to numbers by subtracting '0'\n            svuint8_t nums = svsub_n_u8_z(pg, chars, '0');\n            \n            // Check which numbers are odd using bitwise AND with 1\n            svuint8_t odds = svand_n_u8_z(pg, nums, 1);\n            \n            // Count number of 1s (odd numbers)\n            odd_count += svcntp_b8(pg, svcmpne_n_u8(pg, odds, 0));\n            \n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" + \n                                 std::to_string(odd_count) + \n                                 \"ng \" + \n                                 std::to_string(odd_count) + \n                                 \" of the \" + \n                                 std::to_string(odd_count) + \n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    const std::string prefix = \"the number of odd elements \";\n    const std::string middle = \"n the str\";\n    const std::string suffix = \"ng \";\n    const std::string end = \" of the \";\n    const std::string final = \"nput.\";\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        \n        svbool_t pg = svwhilelt_b8(0, len);\n        \n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)str.c_str());\n            \n            // Convert chars to numeric values by subtracting '0'\n            svuint8_t nums = svsub_u8_z(pg, chars, svdup_u8('0'));\n            \n            // Check for odd numbers using bitwise AND with 1\n            svbool_t odd_mask = svand_b_z(pg, pg, svlsr_n_u8_z(pg, nums, 7));\n            \n            // Count odd numbers in this chunk\n            odd_count += svcntp_b8(svptrue_b8(), odd_mask);\n            \n            pg = svwhilelt_b8(svcntp_b8(svptrue_b8(), pg), len);\n        }\n\n        std::string output = prefix + \n                           std::to_string(odd_count) + \n                           middle +\n                           std::to_string(odd_count) +\n                           suffix +\n                           std::to_string(odd_count) +\n                           end +\n                           std::to_string(odd_count) +\n                           final;\n                           \n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    const std::string prefix = \"the number of odd elements \";\n    const std::string middle = \"n the str\";\n    const std::string suffix = \"ng \";\n    const std::string end = \" of the \";\n    const std::string final = \"nput.\";\n    \n    for(const auto& str : lst) {\n        int odd_count = 0;\n        \n        svbool_t pg = svwhilelt_b8(0, str.length());\n        while(svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)str.data());\n            \n            // Convert ASCII digits to actual numbers by subtracting '0'\n            svuint8_t nums = svsub_n_u8_z(pg, chars, '0');\n            \n            // Check for odd numbers using bitwise AND with 1\n            svbool_t odd_mask = svand_n_u8_z(pg, nums, 1);\n            \n            // Count number of odd digits in this chunk\n            odd_count += svcntp_b8(svptrue_b8(), odd_mask);\n            \n            pg = svwhilelt_b8(svcntp_b8(svptrue_b8(), pg), str.length());\n        }\n        \n        std::string count_str = std::to_string(odd_count);\n        std::string output = prefix + count_str + middle + count_str + suffix + \n                           count_str + end + count_str + final;\n        result.push_back(output);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\nstd::vector<std::string> odd_count_simd(const std::vector<std::string>& lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    \n    for (const auto& str : lst) {\n        int odd_count = 0;\n        const char* ptr = str.c_str();\n        size_t len = str.length();\n        \n        svbool_t pg = svwhilelt_b8(0, len);\n        \n        while (svptest_first(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)ptr);\n            \n            // Convert chars to actual digits by subtracting '0'\n            svuint8_t digits = svsub_u8_z(pg, chars, svdup_n_u8('0'));\n            \n            // Check which digits are odd using bitwise AND with 1\n            svbool_t odd_mask = svcmpeq_n_u8(pg, svand_u8_z(pg, digits, svdup_n_u8(1)), 1);\n            \n            // Count odd digits in this vector\n            odd_count += svcntp_b8(svptrue_b8(), odd_mask);\n            \n            ptr += svcntb();\n            pg = svwhilelt_b8(ptr - str.c_str(), len);\n        }\n        \n        std::string template_str = \"the number of odd elements \" + \n                                 std::to_string(odd_count) + \n                                 \"n the str\" + \n                                 std::to_string(odd_count) + \n                                 \"ng \" + \n                                 std::to_string(odd_count) + \n                                 \" of the \" + \n                                 std::to_string(odd_count) + \n                                 \"nput.\";\n                                 \n        result.push_back(template_str);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    do {\n        svint64_t vec = svld1_s64(pg, &nums[0]);\n        svint64_t curr_sum_vec = svdup_s64(0);\n        \n        curr_sum_vec = svadd_s64_z(pg, curr_sum_vec, vec);\n        curr_sum = svaddv_s64(pg, curr_sum_vec);\n        \n        min_sum = std::min(min_sum, curr_sum);\n        \n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n        \n        size_t vl = svcntd();\n        nums += vl;\n        n -= vl;\n        pg = svwhilelt_b64(0, n);\n        \n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    do {\n        svint64_t vec = svld1_s64(pg, &nums[0]);\n        \n        // Calculate running sum\n        svint64_t sum_vec = svdup_s64(curr_sum);\n        sum_vec = svadd_s64_z(pg, sum_vec, vec);\n        \n        // Update min_sum\n        int64_t vec_min = svminv_s64(pg, sum_vec);\n        min_sum = std::min(min_sum, vec_min);\n        \n        // Update curr_sum for next iteration\n        curr_sum = svlastb_s64(pg, sum_vec);\n        \n        // Move predicate window\n        pg = svwhilelt_b64(svlen_s64(), n);\n        \n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint64_t vec = svld1_s64(pg, &nums[0]);\n        svint64_t curr_sum_vec = svdup_s64(0);\n        \n        curr_sum_vec = svadd_s64_z(pg, curr_sum_vec, vec);\n        int64_t local_min = svminv_s64(pg, curr_sum_vec);\n        min_sum = std::min(min_sum, local_min);\n        \n        for (size_t i = 1; i < n; i++) {\n            svint64_t shifted = svld1_s64(pg, &nums[i]);\n            curr_sum_vec = svadd_s64_z(pg, curr_sum_vec, shifted);\n            local_min = svminv_s64(pg, curr_sum_vec);\n            min_sum = std::min(min_sum, local_min);\n        }\n        \n        pg = svwhilelt_b64(n, n);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    do {\n        svint64_t vec = svld1_s64(pg, &nums[0]);\n        curr_sum = 0;\n        \n        svint64_t running_sum = svdup_s64(0);\n        svint64_t min_so_far = svdup_s64(INT64_MAX);\n        \n        running_sum = svadd_s64_z(pg, running_sum, vec);\n        min_so_far = svmin_s64_z(pg, min_so_far, running_sum);\n        \n        int64_t temp_sum[256];\n        svst1_s64(pg, temp_sum, running_sum);\n        svst1_s64(pg, &temp_sum[128], min_so_far);\n        \n        size_t vl = svcntd();\n        for (size_t i = 0; i < vl && i < n; i++) {\n            curr_sum = temp_sum[i];\n            min_sum = std::min(min_sum, curr_sum);\n            \n            for (size_t j = i + 1; j < n; j++) {\n                curr_sum += nums[j];\n                min_sum = std::min(min_sum, curr_sum);\n            }\n        }\n        \n        pg = svwhilelt_b64(n, n + svcntd());\n        \n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n    \n    int64_t min_sum = nums[0];\n    int64_t curr_sum = 0;\n    \n    svbool_t pg = svwhilelt_b64(0, n);\n    \n    while (svptest_first(pg, pg)) {\n        svint64_t vec = svld1_s64(pg, &nums[0]);\n        \n        svint64_t curr_sum_vec = svdup_s64(0);\n        svint64_t min_sum_vec = svdup_s64(INT64_MAX);\n        \n        curr_sum_vec = svadd_s64_z(pg, curr_sum_vec, vec);\n        min_sum_vec = svmin_s64_z(pg, min_sum_vec, curr_sum_vec);\n        \n        int64_t vec_curr_sum = svaddv_s64(pg, curr_sum_vec);\n        int64_t vec_min_sum = svminv_s64(pg, min_sum_vec);\n        \n        curr_sum = vec_curr_sum;\n        if (vec_min_sum < min_sum) {\n            min_sum = vec_min_sum;\n        }\n        \n        if (curr_sum < 0) {\n            curr_sum = 0;\n        }\n        \n        pg = svwhilelt_b64(svlen_s64(vec), n);\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Count total water units in each row using SVE\n    std::vector<int> water_per_row(rows);\n    \n    for (int i = 0; i < rows; i++) {\n        svbool_t pg = svwhilelt_b32(0, cols);\n        svint32_t sum = svdup_n_s32(0);\n        \n        for (int j = 0; j < cols; j += svcntw()) {\n            svint32_t vec = svld1_s32(pg, &grid[i][j]);\n            sum = svadd_s32_z(pg, sum, vec);\n            pg = svwhilelt_b32(j + svcntw(), cols);\n        }\n        \n        water_per_row[i] = svaddv_s32(svptrue_b32(), sum);\n    }\n    \n    // Calculate total trips needed\n    int total_trips = 0;\n    svbool_t pg = svwhilelt_b32(0, rows); \n    svint32_t cap_vec = svdup_n_s32(capacity);\n    \n    for (int i = 0; i < rows; i += svcntw()) {\n        svint32_t water_vec = svld1_s32(pg, &water_per_row[i]);\n        svint32_t trips = svdiv_s32_z(pg, water_vec, cap_vec);\n        svint32_t remainder = svmod_s32_z(pg, water_vec, cap_vec);\n        \n        // Add extra trip if there's remainder\n        svbool_t has_remainder = svcmpgt_n_s32(pg, remainder, 0);\n        trips = svadd_n_s32_m(has_remainder, trips, 1);\n        \n        total_trips += svaddv_s32(pg, trips);\n        pg = svwhilelt_b32(i + svcntw(), rows);\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_trips = 0;\n\n    // Create temporary array to store water levels\n    std::vector<int> water_levels(cols, 0);\n    \n    // For each row\n    for (int i = 0; i < rows; i++) {\n        const int* row = grid[i].data();\n        \n        svbool_t pg = svwhilelt_b32(0, cols);\n        \n        // Process elements in vectors\n        for (int j = 0; j < cols; j += svcntw()) {\n            // Load vector of water units from current row\n            svint32_t v_water = svld1_s32(pg, row + j);\n            \n            // Add to running water levels\n            svint32_t v_levels = svld1_s32(pg, water_levels.data() + j);\n            v_levels = svadd_s32_z(pg, v_levels, v_water);\n            svst1_s32(pg, water_levels.data() + j, v_levels);\n            \n            pg = svwhilelt_b32(j + svcntw(), cols);\n        }\n    }\n\n    // Count total trips needed\n    svbool_t pg = svwhilelt_b32(0, cols);\n    svint32_t v_capacity = svdup_n_s32(capacity);\n    \n    for (int j = 0; j < cols; j += svcntw()) {\n        svint32_t v_levels = svld1_s32(pg, water_levels.data() + j);\n        \n        // Divide by capacity and round up\n        svint32_t v_trips = svdiv_s32_z(pg, svadd_n_s32_z(pg, v_levels, capacity-1), v_capacity);\n        \n        // Sum trips\n        total_trips = svaddv_s32(pg, v_trips);\n        \n        pg = svwhilelt_b32(j + svcntw(), cols);\n    }\n\n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    \n    // Count total water units in each row using SVE\n    std::vector<int> row_sums(rows, 0);\n    \n    for (int i = 0; i < rows; i++) {\n        svbool_t pg = svwhilelt_b32(0, cols);\n        svint32_t sum = svdup_n_s32(0);\n        \n        for (int j = 0; j < cols; j += svcntw()) {\n            svint32_t vec = svld1_s32(pg, &grid[i][j]);\n            sum = svadd_s32_z(pg, sum, vec);\n            pg = svwhilelt_b32(j + svcntw(), cols);\n        }\n        \n        // Horizontal sum\n        row_sums[i] = svaddv_s32(svptrue_b32(), sum);\n    }\n    \n    // Calculate total trips needed\n    int total_trips = 0;\n    for (int i = 0; i < rows; i++) {\n        total_trips += (row_sums[i] + capacity - 1) / capacity;\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int> >& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) return 0;\n    \n    int rows = grid.size();\n    int cols = grid[0].size();\n    int total_trips = 0;\n\n    // Process each row\n    for (int i = 0; i < rows; i++) {\n        int water_units = 0;\n        \n        // Get vector length\n        const int vl = svcntw();\n        \n        // Initialize vectors\n        svbool_t pg = svwhilelt_b32(0, cols);\n        svint32_t sum = svdup_n_s32(0);\n        \n        // Process columns in vectors\n        for (int j = 0; j < cols; j += vl) {\n            // Load grid values\n            svbool_t p = svwhilelt_b32(j, cols);\n            svint32_t v = svld1_s32(p, &grid[i][j]);\n            \n            // Add up 1s\n            sum = svadd_s32_z(p, sum, v);\n        }\n            \n        // Horizontal sum\n        water_units = svaddv_s32(svptrue_b32(), sum);\n        \n        // Calculate trips needed\n        total_trips += (water_units + capacity - 1) / capacity;\n    }\n    \n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    if (grid.empty() || grid[0].empty()) {\n        return 0;\n    }\n\n    const int rows = grid.size();\n    const int cols = grid[0].size();\n    \n    std::vector<int> water_units(rows, 0);\n\n    // Count water units in each row using SVE\n    for (int i = 0; i < rows; i++) {\n        svbool_t pg = svwhilelt_b32(0, cols);\n        svint32_t sum = svdup_n_s32(0);\n        \n        for (int j = 0; j < cols; j += svcntw()) {\n            svint32_t vec = svld1_s32(pg, &grid[i][j]);\n            sum = svadd_s32_z(pg, sum, vec);\n            pg = svwhilelt_b32(j + svcntw(), cols);\n        }\n        \n        water_units[i] = svaddv_s32(svptrue_b32(), sum);\n    }\n\n    // Calculate number of bucket operations needed\n    int max_operations = 0;\n    for (int i = 0; i < rows; i++) {\n        int operations = (water_units[i] + capacity - 1) / capacity;\n        max_operations += operations;\n    }\n\n    return max_operations;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    const int16_t* data = lst.data();\n    \n    svbool_t pg = svwhilelt_b16(0, len);\n    \n    // Create index vector 0,1,2,3,...\n    svint16_t indices = svindex_s16(0, 1);\n    \n    // Create mask for even positions\n    svbool_t even_mask = svcmpeq_n_s16(pg, svand_n_s16_z(pg, indices, 1), 0);\n    \n    // Load vector elements\n    svint16_t vec = svld1_s16(pg, data);\n    \n    // Create mask for odd values\n    svbool_t odd_mask = svcmpne_n_s16(pg, svand_n_s16_z(pg, vec, 1), 0);\n    \n    // Combine masks to get odd values at even positions\n    svbool_t final_mask = svand_b_z(pg, even_mask, odd_mask);\n    \n    // Sum the selected elements\n    svint64_t sum_vec = svaddv_s64(final_mask, svextw_s64_x(final_mask, vec));\n    \n    sum = svlasta_s64(svptrue_b64(), sum_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    const int16_t* data = lst.data();\n    \n    svbool_t pg = svwhilelt_b16(0, len);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        // Load vector with predicate guard\n        svint16_t vec = svld1_s16(pg, data);\n        \n        // Create mask for even indices (0, 2, 4...)\n        svbool_t even_mask = svand_z(pg, svindex_b16(0, 1) == 0);\n        \n        // Create mask for odd values\n        svbool_t odd_mask = svand_z(pg, (vec & 1) != 0);\n        \n        // Combine masks to get odd values at even positions\n        svbool_t final_mask = svand_b(pg, even_mask, odd_mask);\n        \n        // Sum the matching elements\n        sum += svaddv(final_mask, vec);\n        \n        data += svcntw();\n        pg = svwhilelt_b16(data - lst.data(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    const int16_t* data = lst.data();\n    \n    svbool_t pg = svwhilelt_b16(0, len);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        // Load vector elements\n        svint16_t vec = svld1_s16(pg, data);\n        \n        // Create mask for even indices (0,2,4...)\n        svbool_t even_mask = svand_z(pg, svindex_s16(0, 1) == 0);\n        \n        // Create mask for odd values\n        svbool_t odd_mask = svand_z(pg, (vec & 1) != 0);\n        \n        // Combine masks to get odd values at even positions\n        svbool_t final_mask = svand_b_z(pg, even_mask, odd_mask);\n        \n        // Sum elements that match our criteria\n        sum += svaddv(final_mask, vec);\n        \n        data += svcntw();\n        pg = svwhilelt_b16(data - lst.data(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    const int16_t* data = lst.data();\n    \n    svbool_t pg = svwhilelt_b16(0, len);\n    \n    // Create index vector for even positions\n    svint16_t indices = svindex_s16(0, 1);\n    svbool_t even_mask = svcmpeq_n_s16(pg, svand_n_s16_z(pg, indices, 1), 0);\n    \n    // Load vector elements\n    svint16_t vec = svld1_s16(pg, data);\n    \n    // Create mask for odd numbers\n    svbool_t odd_mask = svcmpne_n_s16(pg, svand_n_s16_z(pg, vec, 1), 0);\n    \n    // Combine masks for even positions and odd numbers\n    svbool_t final_mask = svand_b_z(pg, even_mask, odd_mask);\n    \n    // Sum the selected elements\n    svint64_t sum_vec = svaddv_s64(final_mask, svextw_s64_x(final_mask, vec));\n    \n    sum = svlasta_s64(final_mask, sum_vec);\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    size_t len = lst.size();\n    const int16_t* data = lst.data();\n    \n    svbool_t pg = svwhilelt_b16(0, len);\n    \n    while (svptest_first(svptrue_b16(), pg)) {\n        // Load vector with predicate guard\n        svint16_t vec = svld1_s16(pg, data);\n        \n        // Create mask for even indices (0,2,4...)\n        svbool_t even_mask = svand_z(pg, svnot_z(pg, svcmpeq_n_s16(pg, svindex_s16(0, 1), 1)));\n        \n        // Create mask for odd values\n        svbool_t odd_mask = svand_z(pg, even_mask, svcmpne_n_s16(pg, svand_n_s16_z(pg, vec, 1), 0));\n        \n        // Sum elements that are both at even indices and odd values\n        sum += svaddv_s64(odd_mask, svextw_s64_x(odd_mask, svextw_s32_x(odd_mask, vec)));\n        \n        data += svcntw();\n        pg = svwhilelt_b16(data - lst.data(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, (int)arr.size());\n    int i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &arr[i]);\n        \n        // Check for numbers with at most 2 digits (0-99)\n        svbool_t mask = svcmplt_n_s32(pg, svabs(vec), 100);\n        \n        // Add elements that satisfy the condition\n        sum += svaddv_s32(mask, vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, (int)arr.size());\n    int i = 0;\n\n    svbool_t pg;\n    svint32_t vec_data, vec_abs;\n    svint32_t vec_99 = svdup_n_s32(99);\n    svint32_t vec_neg99 = svdup_n_s32(-99);\n\n    for (; i < len; i += svcntw()) {\n        pg = svwhilelt_b32(i, len);\n        \n        // Load vector elements\n        vec_data = svld1_s32(pg, &arr[i]);\n        \n        // Get absolute values\n        vec_abs = svabs_s32_z(pg, vec_data);\n        \n        // Compare if numbers are between -99 and 99 (two digits)\n        svbool_t mask = svand_b_z(pg,\n            svcmpgt_n_s32(pg, vec_abs, 0),\n            svand_b_z(pg,\n                svcmple_s32(pg, vec_data, vec_99),\n                svcmpge_s32(pg, vec_data, vec_neg99)\n            )\n        );\n        \n        // Add elements that satisfy the condition\n        sum += svaddv_s32(mask, vec_data);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, (int)arr.size());\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, arr.data());\n        \n        // Create mask for numbers with at most 2 digits (0-99)\n        svbool_t mask = svand_b_z(pg, \n                                 svcmplt_n_s32(pg, vec, 100),\n                                 svcmpge_n_s32(pg, vec, 0));\n                                 \n        // Add elements that satisfy the mask\n        sum += svaddv_s32(mask, vec);\n        \n        arr.erase(arr.begin(), arr.begin() + svcntw());\n        len -= svcntw();\n        pg = svwhilelt_b32(0, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int len = std::min(k, (int)arr.size());\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, arr.data());\n        \n        // Create mask for numbers with at most 2 digits (0-99)\n        svbool_t mask = svand_z(pg, \n                               svcmplt_n_s32(pg, vec, 100),\n                               svcmpge_n_s32(pg, vec, 0));\n                               \n        // Sum elements that match the mask\n        sum += svaddv(mask, vec);\n        \n        arr.erase(arr.begin(), arr.begin() + svcntw());\n        len -= svcntw();\n        pg = svwhilelt_b32(0, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\nint add_elements_simd(std::vector<int> arr, int k) {\n    int result = 0;\n    int len = std::min(k, (int)arr.size());\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(pg)) {\n        svint32_t vec = svld1_s32(pg, arr.data());\n        \n        // Check for numbers with at most 2 digits (0-99)\n        svbool_t mask = svcmplt_s32(pg, svabs_s32_z(pg, vec), 100);\n        \n        // Add elements that satisfy the condition\n        result += svaddv_s32(mask, vec);\n        \n        arr.erase(arr.begin(), arr.begin() + svcntw());\n        len -= svcntw();\n        pg = svwhilelt_b32(0, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, lst.size()-1);\n    \n    // Load vectors for current and next elements\n    svint32_t curr = svld1_s32(pg, lst.data());\n    svint32_t next = svld1_s32(pg, lst.data()+1);\n    \n    // Check if elements are in ascending order\n    svbool_t cmp = svcmplt_s32(pg, curr, next);\n    \n    // Check for duplicates\n    svbool_t eq = svcmpeq_s32(pg, curr, next);\n    \n    // Count duplicates for each element\n    svint32_t dup_counts = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t pg_i = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pg_i, &lst[i]);\n        \n        for (size_t j = i; j < lst.size(); j += svcntw()) {\n            svbool_t pg_j = svwhilelt_b32(j, lst.size());\n            svint32_t vec_j = svld1_s32(pg_j, &lst[j]);\n            \n            svbool_t matches = svcmpeq_s32(pg_i, vec, vec_j);\n            dup_counts = svadd_s32_m(pg_i, dup_counts, \n                                   svsel_s32(matches, ones, svdup_s32(0)));\n        }\n    }\n    \n    // Check if any element has more than 2 duplicates\n    svbool_t too_many_dups = svcmpgt_s32(pg, dup_counts, svdup_s32(2));\n    \n    // Reduce results\n    bool is_ascending = svptest_any(pg, svcmpneq_n_b32(pg, cmp, 0));\n    bool has_invalid_dups = svptest_any(pg, too_many_dups);\n    \n    return is_ascending && !has_invalid_dups;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i;\n\n    // Check if sorted in ascending order\n    for (i = 0; i + vl <= lst.size(); i += vl) {\n        svint32_t v1 = svld1_s32(pg, &lst[i]);\n        svint32_t v2 = svld1_s32(pg, &lst[i+1]);\n        \n        // Compare adjacent elements\n        svbool_t cmp = svcmpgt_s32(pg, v1, v2);\n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n\n        // Check for more than 1 duplicate\n        for (size_t j = i; j < i + vl && j + 2 < lst.size(); j++) {\n            if (lst[j] == lst[j+1] && lst[j] == lst[j+2]) {\n                return false;\n            }\n        }\n    }\n\n    // Handle remaining elements\n    for (; i + 1 < lst.size(); i++) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n        if (i + 2 < lst.size() && lst[i] == lst[i+1] && lst[i] == lst[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, lst.size()-1);\n    \n    // Load vectors for current and next elements\n    svint32_t curr = svld1_s32(pg, lst.data());\n    svint32_t next = svld1_s32(pg, lst.data()+1);\n    \n    // Check if elements are in ascending order\n    svbool_t cmp = svcmplt_s32(pg, curr, next);\n    \n    // Check for duplicates\n    svbool_t eq = svcmpeq_s32(pg, curr, next);\n    \n    // Count duplicates for each element\n    svint32_t dup_counts = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        svbool_t pg_i = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pg_i, &lst[i]);\n        \n        for (size_t j = i; j < lst.size(); j += svcntw()) {\n            svbool_t pg_j = svwhilelt_b32(j, lst.size());\n            svint32_t vec_j = svld1_s32(pg_j, &lst[j]);\n            \n            svbool_t eq_mask = svcmpeq_s32(pg_j, vec, vec_j);\n            dup_counts = svadd_s32_m(pg_j, dup_counts, \n                                   svsel_s32(eq_mask, ones, svdup_s32(0)));\n        }\n    }\n    \n    // Check if any element appears more than twice\n    svbool_t dup_check = svcmpgt_s32(pg, dup_counts, svdup_s32(2));\n    \n    // Reduce results\n    bool is_sorted = !svptest_any(pg, svnot_b_z(pg, cmp));\n    bool has_duplicates = svptest_any(pg, dup_check);\n    \n    return is_sorted && !has_duplicates;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() <= 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, lst.size()-1);\n    \n    // Load vectors for current and next elements\n    svint32_t curr = svld1_s32(pg, lst.data());\n    svint32_t next = svld1_s32(pg, lst.data()+1);\n    \n    // Check if elements are in ascending order\n    svbool_t cmp = svcmplt_s32(pg, curr, next);\n    \n    // Check for duplicates\n    svbool_t eq = svcmpeq_s32(pg, curr, next);\n    \n    // Count duplicates for each element\n    svint32_t dup_counts = svcntp_b32(pg, eq);\n    int total_dups = svlasta_s32(pg, dup_counts);\n    \n    // Process remaining elements in chunks\n    size_t processed = svcntw();\n    while (processed < lst.size()-1) {\n        pg = svwhilelt_b32(processed, lst.size()-1);\n        \n        curr = svld1_s32(pg, lst.data() + processed);\n        next = svld1_s32(pg, lst.data() + processed + 1);\n        \n        cmp = svand_z(pg, cmp, svcmplt_s32(pg, curr, next));\n        eq = svcmpeq_s32(pg, curr, next);\n        dup_counts = svcntp_b32(pg, eq);\n        total_dups += svlasta_s32(pg, dup_counts);\n        \n        processed += svcntw();\n    }\n\n    // Check if all elements are in ascending order and no more than one duplicate\n    bool is_ascending = svptest_any(svptrue_b32(), cmp);\n    return is_ascending && (total_dups <= 1);\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return true;\n    \n    size_t len = lst.size();\n    if (len == 1) return true;\n\n    svbool_t pg = svwhilelt_b32(0, len-1);\n    \n    // Check if sorted in ascending order\n    svint32_t vec1 = svld1_s32(pg, &lst[0]);\n    svint32_t vec2 = svld1_s32(pg, &lst[1]);\n    svbool_t cmp = svcmpge_s32(pg, vec1, vec2);\n    \n    if (svptest_any(pg, cmp)) {\n        return false;\n    }\n    \n    // Check for more than 1 duplicate\n    for (size_t i = 0; i < len-2; i += svcntw()) {\n        svbool_t pg_i = svwhilelt_b32(i, len-2);\n        svint32_t curr = svld1_s32(pg_i, &lst[i]);\n        svint32_t next = svld1_s32(pg_i, &lst[i+1]);\n        svint32_t nextnext = svld1_s32(pg_i, &lst[i+2]);\n        \n        svbool_t eq1 = svcmpeq_s32(pg_i, curr, next);\n        svbool_t eq2 = svcmpeq_s32(pg_i, next, nextnext);\n        svbool_t both_eq = svand_b_z(pg_i, eq1, eq2);\n        \n        if (svptest_any(pg_i, both_eq)) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    size_t len = arr.size();\n    const int* data = arr.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    svint32_t sum = svdup_n_s32(0);\n    svint32_t prod = svdup_n_s32(1);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec = svld1_s32(pg, data);\n        \n        // Calculate absolute values and add to sum\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        sum = svadd_s32_z(pg, sum, abs_vec);\n        \n        // Calculate signs (-1, 0, 1)\n        svint32_t signs = svdup_n_s32(0);\n        signs = svadd_n_s32_m(pg, signs, 1, svcmpgt_n_s32(pg, vec, 0));\n        signs = svsub_n_s32_m(pg, signs, 1, svcmplt_n_s32(pg, vec, 0));\n        \n        // Multiply signs\n        prod = svmul_s32_z(pg, prod, signs);\n        \n        data += svcntw();\n        pg = svwhilelt_b32(data - arr.data(), len);\n    }\n    \n    // Horizontal sum and product\n    int final_sum = svaddv_s32(svptrue_b32(), sum);\n    int final_prod = svmulv_s32(svptrue_b32(), prod);\n    \n    return final_prod == 0 ? 0 : final_sum * final_prod;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Get signs (-1, 0, 1)\n    svint32_t zeros = svdup_s32(0);\n    svint32_t ones = svdup_s32(1);\n    svint32_t neg_ones = svdup_s32(-1);\n    \n    svint32_t signs = svsel_s32(svcmpgt_s32(pg, vec, zeros), \n                               ones,\n                               svsel_s32(svcmplt_s32(pg, vec, zeros),\n                                        neg_ones,\n                                        zeros));\n    \n    // Get absolute values\n    svint32_t abs_vals = svabs_s32_x(pg, vec);\n    \n    // Calculate product of signs\n    svint32_t sign_prod = svdup_s32(1);\n    sign_prod = svmul_s32_x(pg, sign_prod, signs);\n    int final_sign = svaddv_s32(pg, sign_prod);\n    \n    // Calculate sum of absolute values\n    int abs_sum = svaddv_s32(pg, abs_vals);\n    \n    return final_sign * abs_sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Get signs (-1, 0, 1)\n    svint32_t zeros = svdup_n_s32(0);\n    svint32_t ones = svdup_n_s32(1);\n    svint32_t neg_ones = svdup_n_s32(-1);\n    \n    svint32_t signs = svsel_s32(svcmpgt_s32(pg, vec, zeros),\n                               ones,\n                               svsel_s32(svcmplt_s32(pg, vec, zeros),\n                                       neg_ones,\n                                       zeros));\n    \n    // Get absolute values\n    svint32_t abs_vals = svabs_s32_z(pg, vec);\n    \n    // Calculate product of signs\n    svint32_t sign_prod = svdup_n_s32(1);\n    sign_prod = svmul_s32_z(pg, sign_prod, signs);\n    int final_sign = svaddv_s32(pg, sign_prod);\n    \n    // Calculate sum of absolute values\n    int abs_sum = svaddv_s32(pg, abs_vals);\n    \n    return final_sign * abs_sum;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Get signs (-1, 0, 1)\n    svint32_t zeros = svdup_n_s32(0);\n    svint32_t ones = svdup_n_s32(1);\n    svint32_t neg_ones = svdup_n_s32(-1);\n    \n    svint32_t signs = svsel_s32(svcmpgt_s32(pg, vec, zeros), \n                               ones,\n                               svsel_s32(svcmplt_s32(pg, vec, zeros),\n                                       neg_ones,\n                                       zeros));\n    \n    // Get absolute values\n    svint32_t abs_vec = svabs_s32_z(pg, vec);\n    \n    // Calculate product of signs\n    svint32_t sign_prod = svdup_n_s32(1);\n    sign_prod = svmul_s32_z(pg, sign_prod, signs);\n    int final_sign = svaddv_s32(pg, sign_prod);\n    \n    // Calculate sum of absolute values\n    int abs_sum = svaddv_s32(pg, abs_vec);\n    \n    return abs_sum * final_sign;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    svbool_t pg = svwhilelt_b32(0, arr.size());\n    svint32_t vec = svld1_s32(pg, arr.data());\n    \n    // Calculate signs (-1, 0, 1)\n    svint32_t zeros = svdup_n_s32(0);\n    svint32_t ones = svdup_n_s32(1);\n    svint32_t neg_ones = svdup_n_s32(-1);\n    \n    svint32_t signs = svsel_s32(svcmpgt_s32(pg, vec, zeros),\n                               ones,\n                               svsel_s32(svcmplt_s32(pg, vec, zeros),\n                                       neg_ones,\n                                       zeros));\n    \n    // Calculate magnitudes\n    svint32_t abs_vals = svabs_s32_z(pg, vec);\n    \n    // Calculate product of signs\n    svint32_t sign_prod = svdup_n_s32(1);\n    sign_prod = svmul_s32_z(pg, sign_prod, signs);\n    int final_sign = svaddv_s32(pg, sign_prod);\n    \n    // Calculate sum of magnitudes\n    int mag_sum = svaddv_s32(pg, abs_vals);\n    \n    return final_sign * mag_sum;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = grid[0][0];\n        int minRow = 0, minCol = 0;\n        \n        for (int i = 0; i < n; i++) {\n            svbool_t pg = svwhilelt_b32(0, n);\n            svint32_t row = svld1_s32(pg, &grid[i][0]);\n            svint32_t minVec = svdup_s32(minVal);\n            \n            svbool_t cmp = svcmplt_s32(pg, row, minVec);\n            if (svptest_any(pg, cmp)) {\n                int32_t minArray[n];\n                svst1_s32(pg, minArray, row);\n                \n                for (int j = 0; j < n; j++) {\n                    if (minArray[j] < minVal) {\n                        minVal = minArray[j];\n                        minRow = i;\n                        minCol = j;\n                    }\n                }\n            }\n        }\n        result[0] = minVal;\n        return result;\n    }\n    \n    std::vector<int> bestPath(k, INT_MAX);\n    std::vector<std::pair<int,int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n            \n            std::function<void(int,int,int)> dfs = [&](int r, int c, int len) {\n                if (len == k) {\n                    if (path < bestPath) {\n                        bestPath = path;\n                    }\n                    return;\n                }\n                \n                for (auto& dir : dirs) {\n                    int nr = r + dir.first;\n                    int nc = c + dir.second;\n                    \n                    if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                        path.push_back(grid[nr][nc]);\n                        dfs(nr, nc, len + 1);\n                        path.pop_back();\n                    }\n                }\n            };\n            \n            dfs(i, j, 1);\n        }\n    }\n    \n    return bestPath;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    const int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = grid[0][0];\n        int minRow = 0, minCol = 0;\n        \n        for (int i = 0; i < n; i++) {\n            svbool_t pg = svwhilelt_b32(0, n);\n            svint32_t vrow = svld1_s32(pg, &grid[i][0]);\n            svint32_t vmin = svdup_n_s32(minVal);\n            \n            svbool_t cmp = svcmplt_s32(pg, vrow, vmin);\n            if (svptest_any(pg, cmp)) {\n                int32_t minArray[n];\n                svst1_s32(pg, minArray, vrow);\n                \n                for (int j = 0; j < n; j++) {\n                    if (minArray[j] < minVal) {\n                        minVal = minArray[j];\n                        minRow = i;\n                        minCol = j;\n                    }\n                }\n            }\n        }\n        result[0] = minVal;\n        return result;\n    }\n    \n    std::vector<int> bestPath(k, INT_MAX);\n    std::vector<std::pair<int,int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n            \n            std::function<void(int,int,int)> dfs = [&](int r, int c, int len) {\n                if (len == k) {\n                    if (path < bestPath) {\n                        bestPath = path;\n                    }\n                    return;\n                }\n                \n                svbool_t pg = svwhilelt_b32(0, dirs.size());\n                svint32_t vr = svdup_n_s32(r);\n                svint32_t vc = svdup_n_s32(c);\n                \n                for (const auto& dir : dirs) {\n                    int nr = r + dir.first;\n                    int nc = c + dir.second;\n                    \n                    if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                        path.push_back(grid[nr][nc]);\n                        dfs(nr, nc, len + 1);\n                        path.pop_back();\n                    }\n                }\n            };\n            \n            dfs(i, j, 1);\n        }\n    }\n    \n    return bestPath;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> curr_path(k);\n    std::vector<int> min_path(k, INT_MAX);\n    \n    // Direction arrays for 4 possible moves\n    int dx[] = {-1, 0, 1, 0};\n    int dy[] = {0, 1, 0, -1};\n\n    // Helper function to check if position is valid\n    auto isValid = [n](int x, int y) {\n        return x >= 0 && x < n && y >= 0 && y < n;\n    };\n\n    // DFS function to find minimum path\n    std::function<void(int, int, int)> dfs = [&](int x, int y, int len) {\n        curr_path[len] = grid[x][y];\n        \n        if (len == k-1) {\n            // Use SVE to compare paths\n            svbool_t pg = svwhilelt_b32(0, k);\n            svint32_t vcurr = svld1_s32(pg, curr_path.data());\n            svint32_t vmin = svld1_s32(pg, min_path.data());\n            \n            svbool_t cmp = svcmplt_s32(pg, vcurr, vmin);\n            svbool_t eq = svcmpeq_s32(pg, vcurr, vmin);\n            \n            if (svptest_any(pg, cmp)) {\n                // Current path is lexicographically smaller\n                svst1_s32(pg, min_path.data(), vcurr);\n            } else if (!svptest_any(pg, cmp) && !svptest_any(pg, eq)) {\n                // Current path is lexicographically larger\n                return;\n            }\n            return;\n        }\n\n        // Try all 4 directions\n        svbool_t pg = svwhilelt_b32(0, 4);\n        svint32_t vdx = svld1_s32(pg, dx);\n        svint32_t vdy = svld1_s32(pg, dy);\n        \n        for (int i = 0; i < 4; i++) {\n            int new_x = x + dx[i];\n            int new_y = y + dy[i];\n            if (isValid(new_x, new_y)) {\n                dfs(new_x, new_y, len + 1);\n            }\n        }\n    };\n\n    // Try all possible starting positions\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dfs(i, j, 0);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    std::vector<int> curr_path(k);\n    bool first_path = true;\n\n    // Get SVE vector length\n    const int vl = svcntw();\n\n    // Directions for neighbor cells: right, left, down, up\n    const int dx[] = {0, 0, 1, -1};\n    const int dy[] = {1, -1, 0, 0};\n\n    std::function<void(int, int, int)> dfs = [&](int x, int y, int len) {\n        curr_path[len] = grid[x][y];\n\n        if (len == k - 1) {\n            if (first_path) {\n                result = curr_path;\n                first_path = false;\n            } else {\n                // Compare paths using SVE\n                svbool_t pg = svwhilelt_b32(0, k);\n                svint32_t v_curr = svld1_s32(pg, curr_path.data());\n                svint32_t v_res = svld1_s32(pg, result.data());\n                \n                svbool_t cmp = svcmplt_s32(pg, v_curr, v_res);\n                if (svptest_first(pg, cmp)) {\n                    int idx = 0;\n                    while (idx < k && curr_path[idx] == result[idx]) idx++;\n                    if (idx < k && curr_path[idx] < result[idx]) {\n                        result = curr_path;\n                    }\n                }\n            }\n            return;\n        }\n\n        // Process neighbors in parallel using SVE\n        svbool_t pg = svwhilelt_b32(0, 4);\n        svint32_t v_dx = svld1_s32(pg, dx);\n        svint32_t v_dy = svld1_s32(pg, dy);\n        \n        for (int i = 0; i < 4; i++) {\n            int new_x = x + dx[i];\n            int new_y = y + dy[i];\n            \n            if (new_x >= 0 && new_x < n && new_y >= 0 && new_y < n) {\n                dfs(new_x, new_y, len + 1);\n            }\n        }\n    };\n\n    // Try all possible starting cells\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dfs(i, j, 0);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int n = grid.size();\n    std::vector<int> result(k);\n    \n    if (k == 1) {\n        int minVal = grid[0][0];\n        int minRow = 0, minCol = 0;\n        \n        for (int i = 0; i < n; i++) {\n            svbool_t pg = svwhilelt_b32(0, n);\n            svint32_t vrow = svld1_s32(pg, &grid[i][0]);\n            svint32_t vmin = svdup_n_s32(minVal);\n            \n            svbool_t cmp = svcmplt_s32(pg, vrow, vmin);\n            if (svptest_any(pg, cmp)) {\n                int32_t minInRow[n];\n                svst1_s32(pg, minInRow, vrow);\n                \n                for (int j = 0; j < n; j++) {\n                    if (minInRow[j] < minVal) {\n                        minVal = minInRow[j];\n                        minRow = i;\n                        minCol = j;\n                    }\n                }\n            }\n        }\n        result[0] = minVal;\n        return result;\n    }\n    \n    std::vector<int> bestPath(k, INT_MAX);\n    std::vector<std::pair<int,int>> dirs = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            std::vector<int> path;\n            path.push_back(grid[i][j]);\n            \n            std::function<void(int,int,int)> dfs = [&](int r, int c, int len) {\n                if (len == k) {\n                    if (path < bestPath) {\n                        bestPath = path;\n                    }\n                    return;\n                }\n                \n                svbool_t pg = svwhilelt_b32(0, dirs.size());\n                svint32_t vr = svdup_n_s32(r);\n                svint32_t vc = svdup_n_s32(c);\n                \n                for (const auto& d : dirs) {\n                    int nr = r + d.first;\n                    int nc = c + d.second;\n                    \n                    if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                        path.push_back(grid[nr][nc]);\n                        dfs(nr, nc, len + 1);\n                        path.pop_back();\n                    }\n                }\n            };\n            \n            dfs(i, j, 1);\n        }\n    }\n    \n    return bestPath;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to digits array\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create vector of digits\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec = svld1_u8(pg, digits);\n    \n    // Create mask for odd digits\n    svuint8_t two = svdup_n_u8(2);\n    svuint8_t rem = svdiv_x(pg, vec, two);\n    rem = svmls_x(pg, vec, rem, two);\n    svbool_t odd_mask = svcmpne_n_u8(pg, rem, 0);\n    \n    // Set even digits to 1 so they don't affect product\n    svuint8_t ones = svdup_n_u8(1);\n    vec = svsel_u8(odd_mask, vec, ones);\n    \n    // Calculate product\n    svuint8_t prod = svdup_n_u8(1);\n    prod = svmul_x(pg, prod, vec);\n    uint8_t result = svaddv_u8(pg, prod);\n    \n    // Check if any odd digits exist\n    uint8_t has_odd = 0;\n    svbool_t any_odd = svptest_any(pg, odd_mask);\n    if (!svptest_any(pg, odd_mask)) {\n        return 0;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to array of digits\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create vector of digits\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec = svld1_u8(pg, digits);\n    \n    // Create mask for odd digits\n    svuint8_t two = svdup_n_u8(2);\n    svuint8_t rem = svrem_x(pg, vec, two);\n    svbool_t odd_mask = svcmpne_n_u8(pg, rem, 0);\n    \n    // Zero out even digits\n    svuint8_t odd_digits = svsel_u8(odd_mask, vec, svdup_n_u8(1));\n    \n    // Multiply all digits\n    svuint8_t prod = svmul_z(odd_mask, odd_digits, odd_digits);\n    uint8_t result = svmaxv(odd_mask, prod);\n    \n    // Check if any odd digits exist\n    if (svptest_any(pg, odd_mask)) {\n        return result;\n    }\n    return 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to array of digits\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create vector predicate for len elements\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Load digits into vector\n    svuint8_t vec = svld1_u8(pg, digits);\n    \n    // Create mask for odd digits (digit & 1 == 1)\n    svbool_t odd_mask = svcmpne_n_u8(pg, svand_n_u8_x(pg, vec, 1), 0);\n    \n    // Initialize product to 1\n    uint64_t prod = 1;\n    \n    // Check if any odd digits exist\n    if (!svptest_any(pg, odd_mask)) {\n        return 0;\n    }\n    \n    // Multiply odd digits\n    svuint8_t odd_digits = svsel_u8(odd_mask, vec, svdup_n_u8(1));\n    \n    // Horizontal multiplication of odd digits\n    while (svptest_any(pg, odd_mask)) {\n        prod *= svaddv_u8(odd_mask, odd_digits);\n        break;\n    }\n    \n    return prod;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to array of digits\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create vector of digits\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t vec = svld1_u8(pg, digits);\n    \n    // Create mask for odd digits\n    svuint8_t two = svdup_n_u8(2);\n    svuint8_t rem = svurem_x(pg, vec, two);\n    svbool_t odd_mask = svcmpne_n_u8(pg, rem, 0);\n    \n    // Zero out even digits\n    svuint8_t odd_digits = svsel_u8(odd_mask, vec, svdup_n_u8(1));\n    \n    // Multiply all digits\n    svuint8_t prod = svmul_u8_z(odd_mask, odd_digits, svdup_n_u8(1));\n    uint8_t result = svmul_n_u8_x(pg, prod, 1);\n    \n    // Check if any odd digits exist\n    svbool_t has_odd = svptest_any(pg, odd_mask);\n    \n    return has_odd ? result : 0;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```cpp\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) return 0;\n    \n    // Convert number to array of digits\n    uint8_t digits[20];\n    int len = 0;\n    while (n > 0) {\n        digits[len++] = n % 10;\n        n /= 10;\n    }\n\n    // Create vector predicate for length\n    svbool_t pg = svwhilelt_b8(0, len);\n    \n    // Load digits into vector\n    svuint8_t vec = svld1_u8(pg, digits);\n    \n    // Create mask for odd digits (digit & 1 == 1)\n    svbool_t odd_mask = svcmpne_n_u8(pg, svand_n_u8_x(pg, vec, 1), 0);\n    \n    // Initialize product to 1\n    uint64_t product = 1;\n    \n    // Check if any odd digits exist\n    if (!svptest_any(pg, odd_mask)) {\n        return 0;\n    }\n    \n    // Multiply odd digits\n    svuint8_t odd_digits = svsel_u8(odd_mask, vec, svdup_n_u8(1));\n    \n    // Horizontal multiplication of odd digits\n    while (svptest_any(pg, odd_mask)) {\n        product *= svmaxv_u8(odd_mask, odd_digits);\n        odd_mask = svpfalse_b();\n    }\n    \n    return product;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t len = lst.size();\n    const float* ptr = lst.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        // Load vector elements\n        svfloat32_t vec = svld1_f32(pg, ptr);\n        \n        // Ceiling operation\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        \n        // Convert to integers\n        svint32_t int_vec = svcvt_s32_f32_x(pg, ceil_vec);\n        \n        // Square the values\n        svint64_t squares = svmul_s64_z(pg, \n                                      svcvt_s64_s32_x(pg, int_vec),\n                                      svcvt_s64_s32_x(pg, int_vec));\n        \n        // Add up all elements in the vector\n        result += svaddv_s64(pg, squares);\n        \n        // Update pointer and predicate for next iteration\n        ptr += svcntw();\n        pg = svwhilelt_b32(ptr - lst.data(), len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svfloat32_t sum = svdup_f32(0);\n\n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Ceiling operation\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        \n        // Square the values\n        svfloat32_t squared = svmul_f32_x(pg, ceil_vec, ceil_vec);\n        \n        // Accumulate sum\n        sum = svadd_f32_m(pg, sum, squared);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    // Horizontal sum\n    float total = svaddv_f32(svptrue_b32(), sum);\n    \n    return (uint64_t)total;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t len = lst.size();\n    const float* ptr = lst.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    svfloat32_t sum = svdup_f32(0.0f);\n    \n    while(svptest_first(pg, pg)) {\n        // Load vector elements\n        svfloat32_t vec = svld1_f32(pg, ptr);\n        \n        // Ceiling operation\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        \n        // Square the values\n        svfloat32_t squared = svmul_f32_x(pg, ceil_vec, ceil_vec);\n        \n        // Add to running sum\n        sum = svadd_f32_m(pg, sum, squared);\n        \n        ptr += svcntw();\n        pg = svwhilelt_b32(ptr - lst.data(), len);\n    }\n    \n    // Horizontal sum\n    result = (uint64_t)svaddv_f32(svptrue_b32(), sum);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    svfloat32_t sum = svdup_f32(0.0f);\n\n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Ceiling operation\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        \n        // Square the values\n        svfloat32_t square = svmul_f32_x(pg, ceil_vec, ceil_vec);\n        \n        // Accumulate sum\n        sum = svadd_f32_m(pg, sum, square);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    // Horizontal sum\n    float total = svaddv_f32(svptrue_b32(), sum);\n    \n    return (uint64_t)total;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    size_t len = lst.size();\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_first(svptrue_b32(), pg)) {\n        // Load vector elements\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        \n        // Ceiling operation\n        svfloat32_t ceil_vec = svceil_f32_x(pg, vec);\n        \n        // Convert to integers\n        svint32_t int_vec = svcvt_s32_f32_x(pg, ceil_vec);\n        \n        // Multiply elements by themselves\n        svint64_t square_vec = svmul_s64_z(pg, \n                                          svcvt_s64_s32_x(pg, int_vec),\n                                          svcvt_s64_s32_x(pg, int_vec));\n        \n        // Add up all elements\n        result += svaddv_s64_x(pg, square_vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int n = arr.size();\n    int result = -1;\n    \n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t curr = svld1_s32(pg, &arr[0]);\n        svint32_t next = svld1_s32(pg, &arr[1]); \n        \n        svbool_t cmp = svcmplt_s32(pg, next, curr);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            uint64_t first_true = svcntp_b32(svptrue_b32(), cmp);\n            int idx = svlasta_s32(cmp, svindex_s32(0, 1));\n            result = idx + 1;\n            break;\n        }\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n-1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int n = arr.size();\n    int result = -1;\n    \n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t curr = svld1_s32(pg, &arr[0]);\n        svint32_t next = svld1_s32(pg, &arr[1]);\n        \n        svbool_t cmp = svcmplt_s32(pg, next, curr);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            uint64_t first_true = svcntp_b32(svptrue_b32(), cmp);\n            int idx = svlasta_s32(cmp, svindex_s32(0, 1));\n            result = idx + 1;\n            break;\n        }\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n-1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n\n    int n = arr.size();\n    int result = -1;\n    \n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t curr = svld1_s32(pg, &arr[0]);\n        svint32_t next = svld1_s32(pg, &arr[1]);\n        \n        svbool_t cmp = svcmplt_s32(pg, next, curr);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            uint64_t first_true = svcntp_b32(svptrue_b32(), cmp);\n            int index = svlasta_s32(cmp, svindex_s32(0, 1)) + 1;\n            result = index;\n            break;\n        }\n        \n        size_t vl = svcntw();\n        pg = svwhilelt_b32(vl, n-1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n\n    int n = arr.size();\n    int result = -1;\n    \n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t curr = svld1_s32(pg, &arr[0]);\n        svint32_t next = svld1_s32(pg, &arr[1]);\n        \n        svbool_t cmp = svcmplt_s32(pg, next, curr);\n        \n        if (svptest_any(svptrue_b32(), cmp)) {\n            uint64_t first_true = svcntp_b32(svptrue_b32(), cmp);\n            int index = svlasta_s32(cmp, svindex_s32(0, 1)) + 1;\n            result = index;\n            break;\n        }\n        \n        pg = svwhilelt_b32(svcntp_b32(svptrue_b32(), pg), n-1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\nint can_arrange_simd(const std::vector<int>& arr) {\n    if (arr.size() < 2) return -1;\n\n    int n = arr.size();\n    int result = -1;\n    \n    svbool_t pg = svwhilelt_b32(0, n-1);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t curr = svld1_s32(pg, &arr[0]);\n        svint32_t next = svld1_s32(pg, &arr[1]);\n        \n        svbool_t cmp = svcmplt_s32(pg, next, curr);\n        \n        if (svptest_any(pg, cmp)) {\n            uint64_t first_true = svcntp_b32(svptrue_b32(), cmp);\n            uint64_t offset = 0;\n            \n            svbool_t tmp = cmp;\n            while (svptest_first(svptrue_b32(), tmp)) {\n                if (svptest_first(svptrue_b32(), tmp)) {\n                    result = offset + svlasta_index_s32(tmp, svindex_s32(0, 1)) + 1;\n                    break;\n                }\n                offset += svcntb();\n                tmp = svnot_z(pg, tmp);\n            }\n            break;\n        }\n        \n        size_t vl = svcntw();\n        pg = svwhilelt_b32(vl, n-1);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int max_neg = 0;\n    int min_pos = 0;\n    \n    svbool_t pg = svwhilelt_b32(0, lst.size());\n    svint32_t vec;\n    \n    svint32_t max_neg_vec = svdup_n_s32(INT32_MIN);\n    svint32_t min_pos_vec = svdup_n_s32(INT32_MAX);\n    \n    for (size_t i = 0; i < lst.size(); i += svcntw()) {\n        pg = svwhilelt_b32(i, lst.size());\n        vec = svld1_s32(pg, &lst[i]);\n        \n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s32(pg, vec, 0));\n        \n        if (svptest_any(pg, neg_mask)) {\n            max_neg_vec = svmax_m(neg_mask, max_neg_vec, vec);\n        }\n        \n        if (svptest_any(pg, pos_mask)) {\n            min_pos_vec = svmin_m(pos_mask, min_pos_vec, vec);\n        }\n    }\n    \n    int32_t max_neg_arr[1];\n    int32_t min_pos_arr[1];\n    \n    svst1_s32(svptrue_b32(), max_neg_arr, max_neg_vec);\n    svst1_s32(svptrue_b32(), min_pos_arr, min_pos_vec);\n    \n    max_neg = (max_neg_arr[0] == INT32_MIN) ? 0 : max_neg_arr[0];\n    min_pos = (min_pos_arr[0] == INT32_MAX) ? 0 : min_pos_arr[0];\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int vl = svcntw();\n    int max_neg = 0;\n    int min_pos = 0;\n    bool found_neg = false;\n    bool found_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        \n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Create predicates for negative and positive numbers\n        svbool_t neg_pred = svcmplt_s32(pg, vec, 0);\n        svbool_t pos_pred = svcmpgt_s32(pg, vec, 0);\n        \n        // Find max negative number\n        if (svptest_any(pg, neg_pred)) {\n            svint32_t neg_nums = svsel_s32(neg_pred, vec, svdup_s32(INT_MIN));\n            int curr_max_neg = svmaxv_s32(neg_pred, neg_nums);\n            \n            if (!found_neg) {\n                max_neg = curr_max_neg;\n                found_neg = true;\n            } else {\n                max_neg = std::max(max_neg, curr_max_neg);\n            }\n        }\n        \n        // Find min positive number\n        if (svptest_any(pg, pos_pred)) {\n            svint32_t pos_nums = svsel_s32(pos_pred, vec, svdup_s32(INT_MAX));\n            int curr_min_pos = svminv_s32(pos_pred, pos_nums);\n            \n            if (!found_pos) {\n                min_pos = curr_min_pos;\n                found_pos = true;\n            } else {\n                min_pos = std::min(min_pos, curr_min_pos);\n            }\n        }\n    }\n\n    return {found_neg ? max_neg : 0, found_pos ? min_pos : 0};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int vl = svcntw();\n    int max_neg = 0;\n    int min_pos = 0;\n    bool found_neg = false;\n    bool found_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        \n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Create predicates for negative and positive numbers\n        svbool_t neg_pred = svcmplt_s32(pg, vec, 0);\n        svbool_t pos_pred = svcmpgt_s32(pg, vec, 0);\n        \n        // Find max negative number\n        if (svptest_any(pg, neg_pred)) {\n            svint32_t neg_vals = svsel_s32(neg_pred, vec, svdup_s32(INT_MIN));\n            int curr_max_neg = svmaxv_s32(neg_pred, neg_vals);\n            \n            if (!found_neg || curr_max_neg > max_neg) {\n                max_neg = curr_max_neg;\n                found_neg = true;\n            }\n        }\n        \n        // Find min positive number  \n        if (svptest_any(pg, pos_pred)) {\n            svint32_t pos_vals = svsel_s32(pos_pred, vec, svdup_s32(INT_MAX));\n            int curr_min_pos = svminv_s32(pos_pred, pos_vals);\n            \n            if (!found_pos || curr_min_pos < min_pos) {\n                min_pos = curr_min_pos;\n                found_pos = true;\n            }\n        }\n    }\n\n    return {found_neg ? max_neg : 0, found_pos ? min_pos : 0};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int vl = svcntw();\n    int max_neg = 0;\n    int min_pos = 0;\n    bool found_neg = false;\n    bool found_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        \n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        \n        // Create masks for negative and positive numbers\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s32(pg, vec, 0));\n        \n        // Find max negative number\n        if (svptest_any(pg, neg_mask)) {\n            svint32_t neg_vals = svsel_s32(neg_mask, vec, svdup_s32(INT_MIN));\n            int curr_max_neg = svmaxv_s32(neg_mask, neg_vals);\n            if (!found_neg) {\n                max_neg = curr_max_neg;\n                found_neg = true;\n            } else {\n                max_neg = std::max(max_neg, curr_max_neg);\n            }\n        }\n        \n        // Find min positive number\n        if (svptest_any(pg, pos_mask)) {\n            svint32_t pos_vals = svsel_s32(pos_mask, vec, svdup_s32(INT_MAX));\n            int curr_min_pos = svminv_s32(pos_mask, pos_vals);\n            if (!found_pos) {\n                min_pos = curr_min_pos;\n                found_pos = true;\n            } else {\n                min_pos = std::min(min_pos, curr_min_pos);\n            }\n        }\n    }\n\n    return {found_neg ? max_neg : 0, found_pos ? min_pos : 0};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int vl = svcntw();\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    bool found_neg = false;\n    bool found_pos = false;\n\n    for (size_t i = 0; i < lst.size(); i += vl) {\n        svbool_t pg = svwhilelt_b32(i, lst.size());\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svbool_t pos_mask = svand_b_z(pg, svcmpgt_s32(pg, vec, 0));\n\n        if (svptest_any(pg, neg_mask)) {\n            found_neg = true;\n            int curr_max_neg = svmaxv_s32(neg_mask, vec);\n            max_neg = std::max(max_neg, curr_max_neg);\n        }\n\n        if (svptest_any(pg, pos_mask)) {\n            found_pos = true;\n            int curr_min_pos = svminv_s32(pos_mask, vec);\n            min_pos = std::min(min_pos, curr_min_pos);\n        }\n    }\n\n    return {found_neg ? max_neg : 0, found_pos ? min_pos : 0};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0 || n == 1) return 1;\n    \n    uint64_t result = 1;\n    \n    // Calculate factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        \n        // Get vector length\n        uint64_t vl = svcntd();\n        \n        // Initialize vectors\n        svbool_t pg = svwhilelt_b64(0, i);\n        svuint64_t acc = svdup_u64(1);\n        \n        // Process elements in chunks of vector length\n        for (uint64_t j = 0; j < i; j += vl) {\n            // Create vector of consecutive numbers\n            svuint64_t vec = svindex_u64(j + 1, 1);\n            \n            // Multiply accumulator by current vector elements\n            acc = svmul_x(pg, acc, vec);\n            \n            // Update predicate for next iteration\n            pg = svwhilelt_b64(j + vl, i);\n        }\n        \n        // Reduce vector to get final factorial\n        factorial = svaddv(svptrue_b64(), acc);\n        \n        // Multiply result by current factorial\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0 || n == 1) return 1;\n    \n    uint64_t result = 1;\n    \n    // Calculate factorial for each number from 1 to n\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t factorial = 1;\n        \n        // Get vector length\n        svbool_t pg = svwhilelt_b64(0, i);\n        \n        // Create vector of indices from 1 to i\n        svuint64_t vec_indices = svindex_u64(1, 1);\n        \n        // Multiply all elements\n        svuint64_t vec_product = svdup_u64(1);\n        \n        while (svptest_first(pg, pg)) {\n            vec_product = svmul_x(pg, vec_product, vec_indices);\n            pg = svwhilelt_b64(svcntd(), i);\n            vec_indices = svadd_x(pg, vec_indices, svcntd());\n        }\n        \n        // Reduce vector to get factorial\n        factorial = svmul_x(svptrue_b64(), factorial, \n                          svredmul_x(svptrue_b64(), vec_product));\n                          \n        // Multiply into final result\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0 || n == 1) return 1;\n    \n    uint64_t result = 1;\n    \n    // Calculate regular factorial for each number from 1 to n\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t vec_indices = svindex_u64(1, 1);\n    svuint64_t vec_result = svdup_u64(1);\n    \n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, n);\n        svuint64_t vec_curr = svindex_u64(i + 1, 1);\n        \n        // Calculate factorial for current chunk\n        svuint64_t vec_fact = svdup_u64(1);\n        for (uint64_t j = 1; j <= i + svcntd() && j <= n; j++) {\n            vec_fact = svmul_x(p, vec_fact, svdup_u64(j));\n        }\n        \n        // Multiply with running result\n        vec_result = svmul_x(p, vec_result, vec_fact);\n    }\n    \n    // Reduce vector to get final result\n    uint64_t temp_result = 1;\n    svbool_t pred = svptrue_b64();\n    temp_result = svmul_x(pred, temp_result, svreduc_mul_x(pred, vec_result));\n    \n    return temp_result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n <= 1) return 1;\n    \n    uint64_t result = 1;\n    \n    // Get vector length\n    uint64_t vl = svcntd();\n    \n    // Process each number from n down to 1\n    for (uint64_t i = n; i >= 1; i--) {\n        uint64_t factorial = 1;\n        \n        // Calculate factorial for current i using SVE\n        svbool_t pg = svwhilelt_b64(0, i);\n        svuint64_t vec_idx = svindex_u64(1, 1);\n        svuint64_t vec_factorial = svdup_u64(1);\n        \n        while (svptest_first(pg, pg)) {\n            vec_factorial = svmul_z(pg, vec_factorial, vec_idx);\n            vec_idx = svadd_z(pg, vec_idx, svdup_u64(vl));\n            pg = svwhilelt_b64(svlen_u64(vec_idx), i);\n        }\n        \n        // Reduce vector to get final factorial\n        factorial = svmul_n_u64_x(svptrue_b64(), vec_factorial, 1);\n        \n        // Multiply result by current factorial\n        result *= factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0 || n == 1) return 1;\n    \n    uint64_t result = 1;\n    uint64_t len = svcntd();\n    \n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t curr_factorial = 1;\n        \n        svbool_t pg = svwhilelt_b64(0, n-i+1);\n        svuint64_t vec_indices = svindex_u64(1, 1);\n        svuint64_t vec_result = svdup_u64(1);\n        \n        while (svptest_first(pg, pg)) {\n            vec_result = svmul_x(pg, vec_result, vec_indices);\n            vec_indices = svadd_x(pg, vec_indices, svdup_u64(len));\n            pg = svwhilelt_b64(svlen_u64(vec_indices), n-i+1);\n        }\n        \n        uint64_t temp[256];\n        svst1_u64(svptrue_b64(), temp, vec_result);\n        \n        for (uint64_t j = 0; j < svlen_u64(vec_result); j++) {\n            curr_factorial *= temp[j];\n        }\n        \n        result *= curr_factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    int sum = 0;\n    size_t i = 0;\n    const int* ptr = lst.data();\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr + i);\n        svint32_t indices = svadd_s32_z(pg, svindex_s32(i, 1), svdup_s32(0));\n        \n        // Create masks for multiples of 3 and 4\n        svbool_t mask3 = svcmpeq_s32(pg, svrem_s32_z(pg, indices, svdup_s32(3)), svdup_s32(0));\n        svbool_t mask4 = svcmpeq_s32(pg, svrem_s32_z(pg, indices, svdup_s32(4)), svdup_s32(0));\n        mask4 = svand_b_z(pg, mask4, svnot_b_z(pg, mask3));\n        \n        // Square elements at indices divisible by 3\n        svint32_t squared = svmul_s32_z(mask3, vec, vec);\n        vec = svsel_s32(mask3, squared, vec);\n        \n        // Cube elements at indices divisible by 4 (but not 3)\n        svint32_t cubed = svmul_s32_z(mask4, vec, svmul_s32_z(mask4, vec, vec));\n        vec = svsel_s32(mask4, cubed, vec);\n        \n        // Add to running sum\n        sum += svaddv_s32(pg, vec);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n\n    int sum = 0;\n    int n = lst.size();\n    const int* data = lst.data();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &data[i]);\n\n        // Create masks for multiples of 3 and 4\n        svbool_t mask3 = svcmpeq_n_s32(p, svmodv_s32_x(p, svindex_s32(i, 1), 3), 0);\n        svbool_t mask4 = svcmpeq_n_s32(p, svmodv_s32_x(p, svindex_s32(i, 1), 4), 0);\n        mask4 = svand_b_z(p, mask4, svnot_b_z(p, mask3));\n\n        // Square elements at indices divisible by 3\n        svint32_t squared = svmul_s32_z(mask3, vec, vec);\n        \n        // Cube elements at indices divisible by 4 (but not 3)\n        svint32_t cubed = svmul_s32_z(mask4, svmul_s32_z(mask4, vec, vec), vec);\n\n        // Combine results\n        svint32_t result = svsel(mask3, squared, vec);\n        result = svsel(mask4, cubed, result);\n\n        running_sum = svadd_s32_z(p, running_sum, result);\n    }\n\n    return svaddv_s32(pg, running_sum);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n\n    int sum = 0;\n    int n = lst.size();\n    const int* data = lst.data();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &data[i]);\n        \n        // Create masks for multiples of 3 and 4\n        svbool_t mask3 = svcmpeq_n_s32(p, svand_n_s32(svindex_s32(i, 1), 3), 0);\n        svbool_t mask4 = svcmpeq_n_s32(p, svand_n_s32(svindex_s32(i, 1), 4), 0);\n        mask4 = svand_b_z(p, mask4, svnot_b_z(p, mask3));\n\n        // Square elements at indices divisible by 3\n        svint32_t squared = svmul_s32_z(mask3, vec, vec);\n        \n        // Cube elements at indices divisible by 4 (but not 3)\n        svint32_t cubed = svmul_s32_z(mask4, svmul_s32_z(mask4, vec, vec), vec);\n        \n        // Combine results\n        svint32_t result = svsel(mask3, squared, vec);\n        result = svsel(mask4, cubed, result);\n        \n        running_sum = svadd_s32_z(p, running_sum, result);\n    }\n\n    return svaddv_s32(pg, running_sum);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n\n    int sum = 0;\n    int n = lst.size();\n    const int* data = lst.data();\n\n    svbool_t pg = svwhilelt_b32(0, n);\n    svint32_t running_sum = svdup_n_s32(0);\n\n    for (int i = 0; i < n; i += svcntw()) {\n        svbool_t p = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(p, &data[i]);\n\n        // Create masks for multiples of 3 and 4\n        svbool_t mask3 = svcmpeq_n_s32(p, svand_n_s32(svindex_s32(i, 1), 3), 0);\n        svbool_t mask4 = svcmpeq_n_s32(p, svand_n_s32(svindex_s32(i, 1), 4), 0);\n        mask4 = svand_b_z(p, mask4, svnot_b_z(p, mask3));\n\n        // Square elements at indices divisible by 3\n        svint32_t squared = svmul_s32_z(mask3, vec, vec);\n\n        // Cube elements at indices divisible by 4 (but not 3)\n        svint32_t cubed = svmul_s32_z(mask4, vec, svmul_s32_z(mask4, vec, vec));\n\n        // Combine results\n        svint32_t result = svsel(mask3, squared, vec);\n        result = svsel(mask4, cubed, result);\n\n        running_sum = svadd_s32_z(p, running_sum, result);\n    }\n\n    sum = svaddv_s32(pg, running_sum);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\nint sum_squares_simd(const std::vector<int>& lst) {\n    if (lst.empty()) return 0;\n    \n    int sum = 0;\n    size_t i = 0;\n    const int* ptr = lst.data();\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, ptr + i);\n        svint32_t indices = svadd_s32_z(pg, svindex_s32(i, 1), svdup_s32(0));\n        \n        svbool_t mod3 = svcmpeq_s32(pg, svrem_s32_z(pg, indices, svdup_s32(3)), svdup_s32(0));\n        svbool_t mod4 = svcmpeq_s32(pg, svrem_s32_z(pg, indices, svdup_s32(4)), svdup_s32(0));\n        \n        svint32_t squares = svmul_s32_z(mod3, vec, vec);\n        svint32_t cubes = svmul_s32_z(pg, svmul_s32_z(mod4, vec, vec), vec);\n        \n        svbool_t not_mod3 = svnot_b_z(pg, mod3);\n        svbool_t mod4_not_mod3 = svand_b_z(pg, mod4, not_mod3);\n        \n        svint32_t result = svsel_s32(mod3, squares, \n                            svsel_s32(mod4_not_mod3, cubes, vec));\n        \n        sum += svaddv_s32(pg, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int len = nums.size();\n    const int* data = nums.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while(svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, data);\n        \n        // Check if greater than 10\n        svbool_t gt10_mask = svcmpgt_s32(pg, vec, svdup_n_s32(10));\n        \n        // Get first digit\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit_vec = abs_vec;\n        svbool_t nonzero = svptest_first(svptrue_b32(), svcmpne_n_s32(pg, abs_vec, 0));\n        while(svptest_first(svptrue_b32(), nonzero)) {\n            first_digit_vec = svdiv_s32_z(pg, first_digit_vec, svdup_n_s32(10));\n            nonzero = svcmpgt_s32(pg, first_digit_vec, svdup_n_s32(9));\n        }\n        \n        // Get last digit\n        svint32_t last_digit_vec = svabs_s32_z(pg, svrem_s32_z(pg, vec, svdup_n_s32(10)));\n        \n        // Check if first and last digits are odd\n        svbool_t first_odd = svcmpne_n_s32(pg, \n            svrem_s32_z(pg, first_digit_vec, svdup_n_s32(2)), 0);\n        svbool_t last_odd = svcmpne_n_s32(pg,\n            svrem_s32_z(pg, last_digit_vec, svdup_n_s32(2)), 0);\n            \n        // Combine all conditions\n        svbool_t final_mask = svand_b_z(pg, gt10_mask, \n                                svand_b_z(pg, first_odd, last_odd));\n                                \n        count += svcntp_b32(svptrue_b32(), final_mask);\n        \n        data += svcntw();\n        pg = svwhilelt_b32(svcntw(), len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int len = nums.size();\n    const int *data = nums.data();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec = svld1_s32(pg, data);\n        \n        // Check if greater than 10\n        svbool_t gt_mask = svcmpgt_s32(pg, vec, svdup_n_s32(10));\n        \n        // Get first digit\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit_vec = abs_vec;\n        svbool_t continue_mask = svptest_first(pg, pg);\n        \n        while (svptest_first(continue_mask, continue_mask)) {\n            svbool_t gt_9_mask = svcmpgt_s32(pg, first_digit_vec, svdup_n_s32(9));\n            first_digit_vec = svdiv_s32_z(pg, first_digit_vec, svdup_n_s32(10));\n            continue_mask = svand_b_z(pg, gt_9_mask, continue_mask);\n        }\n        \n        // Get last digit\n        svint32_t last_digit_vec = svabs_s32_z(pg, svrem_s32_z(pg, vec, svdup_n_s32(10)));\n        \n        // Check if first and last digits are odd\n        svbool_t first_odd = svand_b_z(pg,\n            svcmpne_n_s32(pg, svrem_s32_z(pg, first_digit_vec, svdup_n_s32(2)), 0),\n            gt_mask);\n            \n        svbool_t last_odd = svand_b_z(pg,\n            svcmpne_n_s32(pg, svrem_s32_z(pg, last_digit_vec, svdup_n_s32(2)), 0),\n            first_odd);\n            \n        count += svcntp_b32(pg, last_odd);\n        \n        data += svcntw();\n        pg = svwhilelt_b32(data - nums.data(), len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int len = nums.size();\n    int i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &nums[i]);\n        \n        // Check if greater than 10\n        svbool_t gt10_mask = svcmpgt_s32(pg, vec, svdup_n_s32(10));\n        \n        // Get first digit\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit_vec = abs_vec;\n        svbool_t continue_mask = svptrue_b32();\n        \n        while (svptest_first(pg, continue_mask)) {\n            svbool_t div_mask = svcmpgt_s32(pg, first_digit_vec, svdup_n_s32(9));\n            first_digit_vec = svdiv_s32_z(pg, first_digit_vec, svdup_n_s32(10));\n            continue_mask = svand_b_z(pg, continue_mask, div_mask);\n        }\n        \n        // Get last digit\n        svint32_t last_digit_vec = svabs_s32_z(pg, svrem_s32_z(pg, vec, svdup_n_s32(10)));\n        \n        // Check if first and last digits are odd\n        svbool_t first_odd = svcmpne_n_s32(pg, \n            svrem_s32_z(pg, first_digit_vec, svdup_n_s32(2)), 0);\n        svbool_t last_odd = svcmpne_n_s32(pg,\n            svrem_s32_z(pg, last_digit_vec, svdup_n_s32(2)), 0);\n            \n        // Combine all conditions\n        svbool_t final_mask = svand_b_z(pg, gt10_mask, \n                                svand_b_z(pg, first_odd, last_odd));\n                                \n        count += svcntp_b32(svptrue_b32(), final_mask);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int len = nums.size();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(pg, pg)) {\n        svint32_t vec = svld1_s32(pg, &nums[0]);\n        \n        // Check if greater than 10\n        svbool_t gt10_mask = svcmpgt_s32(pg, vec, svdup_n_s32(10));\n        \n        // Get first digit by repeated division by 10\n        svint32_t temp = svabs_s32_z(pg, vec);\n        while (svptest_any(pg, svcmpgt_n_s32(pg, temp, 9))) {\n            temp = svdiv_s32_z(pg, temp, svdup_n_s32(10));\n        }\n        svbool_t first_odd = svand_b_z(pg, gt10_mask, \n                                     svcmpeq_n_s32(pg, svand_s32_z(pg, temp, svdup_n_s32(1)), 1));\n        \n        // Get last digit using modulo\n        svint32_t last_digit = svand_s32_z(pg, svabs_s32_z(pg, vec), svdup_n_s32(1));\n        svbool_t last_odd = svcmpeq_n_s32(pg, last_digit, 1);\n        \n        // Combine conditions\n        svbool_t final_mask = svand_b_z(pg, first_odd, last_odd);\n        \n        count += svcntp_b32(pg, final_mask);\n        \n        pg = svwhilelt_b32(len, len + svcntw());\n        len += svcntw();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\nint specialFilter_simd(const std::vector<int> &nums) {\n    int count = 0;\n    int len = nums.size();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, &nums[0]);\n        \n        // Check if greater than 10\n        svbool_t gt10_mask = svcmpgt_s32(pg, vec, svdup_n_s32(10));\n        \n        // Get first digit\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svint32_t first_digit_vec = abs_vec;\n        svbool_t non_zero = svptest_first(svptrue_b32(), svcmpne_n_s32(pg, abs_vec, 0));\n        while (svptest_first(svptrue_b32(), non_zero)) {\n            first_digit_vec = svdiv_s32_z(pg, first_digit_vec, svdup_n_s32(10));\n            non_zero = svcmpgt_s32(pg, first_digit_vec, svdup_n_s32(9));\n        }\n        \n        // Get last digit\n        svint32_t last_digit_vec = svabs_s32_z(pg, svrem_s32_z(pg, vec, svdup_n_s32(10)));\n        \n        // Check if first and last digits are odd\n        svbool_t first_odd = svcmpne_n_s32(pg, \n            svrem_s32_z(pg, first_digit_vec, svdup_n_s32(2)), \n            0);\n        svbool_t last_odd = svcmpne_n_s32(pg,\n            svrem_s32_z(pg, last_digit_vec, svdup_n_s32(2)),\n            0);\n            \n        // Combine all conditions\n        svbool_t final_mask = svand_b_z(pg, gt10_mask, \n                                svand_b_z(pg, first_odd, last_odd));\n                                \n        count += svcntp_b32(svptrue_b32(), final_mask);\n        \n        pg = svwhilelt_b32(len, len + svcntw());\n        len += svcntw();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array values using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t indices = svindex_u64(1, 1);\n    \n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        svbool_t p = svwhilelt_b64(i, n);\n        svuint64_t vec_i = svadd_z(p, svindex_u64(i+1, 1), svdup_u64(0));\n        svuint64_t squared = svmul_z(p, vec_i, vec_i);\n        svuint64_t result = svsub_z(p, squared, vec_i);\n        result = svadd_z(p, result, svdup_u64(1));\n        svst1_u64(p, &a[i], result);\n    }\n\n    uint64_t count = 0;\n    \n    // Count valid triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t pg = svwhilelt_b64(j+1, n);\n            svuint64_t vec_k = svld1_u64(pg, &a[j+1]);\n            svuint64_t sum = svadd_z(pg, svadd_z(pg, svdup_u64(a[i]), svdup_u64(a[j])), vec_k);\n            svuint64_t rem = svdiv_z(pg, sum, svdup_u64(3));\n            rem = svmul_z(pg, rem, svdup_u64(3));\n            svbool_t is_multiple = svcmpeq(pg, sum, rem);\n            count += svcntp_b64(svptrue_b64(), is_multiple);\n        }\n    }\n\n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array values using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t indices = svindex_u64(1, 1);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svuint64_t vec_i = svsel_u64(pg, indices, svdup_u64(0));\n        svuint64_t vec_isq = svmul_u64_x(pg, vec_i, vec_i);\n        svuint64_t vec_res = svsub_u64_x(pg, vec_isq, vec_i);\n        vec_res = svadd_u64_x(pg, vec_res, svdup_u64(1));\n        svst1_u64(pg, a, vec_res);\n        \n        indices = svadd_u64_x(svptrue_b64(), indices, svdup_u64(svcntd()));\n        pg = svwhilelt_b64(svcntd(), n);\n    }\n\n    // Check all possible triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t pg = svwhilelt_b64(j+1, n);\n            svuint64_t vec_k = svindex_u64(j+1, 1);\n            \n            while (svptest_first(svptrue_b64(), pg)) {\n                svuint64_t vec_ak = svld1_u64(pg, &a[svlasta_u64(pg, vec_k)]);\n                svuint64_t sum = svadd_u64_x(pg, svadd_u64_x(pg, svdup_u64(a[i]), svdup_u64(a[j])), vec_ak);\n                svuint64_t rem = svdiv_u64_x(pg, sum, svdup_u64(3));\n                rem = svmul_u64_x(pg, rem, svdup_u64(3));\n                svbool_t is_div = svcmpeq_u64(pg, sum, rem);\n                count += svcntp_b64(svptrue_b64(), is_div);\n                \n                vec_k = svadd_u64_x(svptrue_b64(), vec_k, svdup_u64(svcntd()));\n                pg = svwhilelt_b64(svlasta_u64(svptrue_b64(), vec_k), n);\n            }\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Generate array using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t indices = svindex_u64(1, 1);\n    \n    for (uint64_t i = 0; i < n; i += svcntd()) {\n        pg = svwhilelt_b64(i, n);\n        svuint64_t vec_i = svadd_z(pg, svindex_u64(i+1, 1), svdup_u64(0));\n        svuint64_t squared = svmul_z(pg, vec_i, vec_i);\n        svuint64_t result = svsub_z(pg, squared, vec_i);\n        result = svadd_z(pg, result, svdup_u64(1));\n        svst1_u64(pg, &a[i], result);\n    }\n\n    // Check all possible triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t pg_inner = svwhilelt_b64(j+1, n);\n            svuint64_t vec_i = svdup_u64(a[i]);\n            svuint64_t vec_j = svdup_u64(a[j]);\n            \n            for (uint64_t k = j+1; k < n; k += svcntd()) {\n                pg_inner = svwhilelt_b64(k, n);\n                svuint64_t vec_k = svld1_u64(pg_inner, &a[k]);\n                \n                svuint64_t sum = svadd_z(pg_inner, vec_i, vec_j);\n                sum = svadd_z(pg_inner, sum, vec_k);\n                \n                svuint64_t rem = svdiv_z(pg_inner, sum, svdup_u64(3));\n                rem = svmul_z(pg_inner, rem, svdup_u64(3));\n                svbool_t is_div = svcmpeq_z(pg_inner, sum, rem);\n                \n                count += svcntp_b64(svptrue_b64(), is_div);\n            }\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    // Allocate array\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Get vector length\n    uint64_t vl = svcntd();\n    \n    // Generate indices and compute array values\n    for (uint64_t i = 0; i < n; i += vl) {\n        uint64_t this_vl = (i + vl <= n) ? vl : n - i;\n        \n        svbool_t pg = svwhilelt_b64(i, n);\n        \n        svuint64_t indices = svadd_z(pg, svindex_u64(0, 1), i);\n        svuint64_t squares = svmul_z(pg, indices, indices);\n        svuint64_t values = svsub_z(pg, squares, indices);\n        values = svadd_z(pg, values, 1);\n        \n        svst1_u64(pg, &a[i], values);\n    }\n    \n    uint64_t count = 0;\n    \n    // Count valid triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            svbool_t pg = svwhilelt_b64(j+1, n);\n            svuint64_t vec_k = svindex_u64(j+1, 1);\n            \n            svuint64_t sum = svadd_z(pg, a[i], a[j]);\n            svuint64_t total = svadd_z(pg, sum, svld1_u64(pg, &a[j+1]));\n            \n            svuint64_t rem = svdiv_z(pg, total, 3);\n            rem = svmls_z(pg, total, rem, 3);\n            \n            svbool_t is_multiple = svcmpeq_z(pg, rem, 0);\n            count += svcntp_b64(svptrue_b64(), is_multiple);\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) return 0;\n    \n    uint64_t count = 0;\n    uint64_t* a = (uint64_t*)malloc(n * sizeof(uint64_t));\n    \n    // Calculate array values using SVE\n    svbool_t pg = svwhilelt_b64(0, n);\n    svuint64_t indices = svindex_u64(1, 1);\n    \n    while (svptest_first(svptrue_b64(), pg)) {\n        svuint64_t vec_i = svsel_u64(pg, indices, svdup_u64(0));\n        svuint64_t squared = svmul_u64_x(pg, vec_i, vec_i);\n        svuint64_t result = svsub_u64_x(pg, squared, vec_i);\n        result = svadd_u64_x(pg, result, svdup_u64(1));\n        svst1_u64(pg, a, result);\n        \n        indices = svadd_u64_m(pg, indices, svdup_u64(svcntw()));\n        pg = svwhilelt_b64(svlen_u64(indices), n);\n    }\n\n    // Check all possible triples\n    for (uint64_t i = 0; i < n-2; i++) {\n        for (uint64_t j = i+1; j < n-1; j++) {\n            for (uint64_t k = j+1; k < n; k++) {\n                if ((a[i] + a[j] + a[k]) % 3 == 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    free(a);\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n\n    svbool_t pg = svwhilelt_b32(0, (n-1)/2);\n    svuint32_t indices = svindex_u32(2, 1);\n    svuint32_t divisors = svsel_u32(pg, indices, svdup_u32(0));\n    \n    svbool_t is_divisible = svpfalse_b();\n    \n    do {\n        svuint32_t remainders = svurem_u32_z(pg, svdup_u32(n), divisors);\n        is_divisible = svorr_b_z(pg, is_divisible, svcmpeq_u32(pg, remainders, 0));\n        \n        if (svptest_any(pg, is_divisible)) {\n            return y;\n        }\n        \n        pg = svwhilelt_b32(svlen_u32(divisors), (n-1)/2);\n        indices = svadd_u32_z(pg, indices, svdup_u32(svlen_u32(divisors)));\n        divisors = svsel_u32(pg, indices, svdup_u32(0));\n        \n    } while (svptest_any(pg));\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    svbool_t pg = svwhilelt_b32(0, (n-1)/2);\n    svint32_t indices = svindex_s32(2, 1);\n    svint32_t divisors = svsel_s32(pg, indices, svdup_s32(0));\n    \n    svbool_t remainders = svcmpeq_s32(pg, svdup_s32(0), \n                                     svdiv_s32_z(pg, svdup_s32(n), divisors));\n    \n    if (svptest_any(pg, remainders)) {\n        return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    svbool_t pg = svwhilelt_b32(0, (n-1)/2);\n    svint32_t indices = svindex_s32(2, 1);\n    svint32_t divisors = svmul_n_s32_z(pg, indices, 1);\n    svint32_t remainders = svdiv_n_s32_z(pg, svdup_n_s32(n), 1);\n    remainders = svmsb_n_s32_z(pg, remainders, divisors, n);\n    \n    svbool_t is_zero = svcmpeq_s32(pg, remainders, 0);\n    if (svptest_any(pg, is_zero)) {\n        return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    int limit = (int)sqrt(n);\n    svbool_t pg = svwhilelt_b32(0, limit-1);\n    \n    svint32_t indices = svindex_s32(2, 1);\n    svint32_t n_vec = svdup_s32(n);\n    svint32_t rem = svdiv_s32_z(pg, n_vec, indices);\n    rem = svmls_s32_z(pg, rem, svdiv_s32_z(pg, n_vec, indices), indices);\n    \n    svbool_t is_divisible = svcmpeq_s32(pg, rem, 0);\n    \n    if (svptest_any(pg, is_divisible)) {\n        return y;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    \n    svbool_t pg = svwhilelt_b32(0, n/2);\n    svint32_t indices = svindex_s32(2, 1);\n    svint32_t divisors = svsel_s32(pg, indices, svdup_s32(0));\n    \n    svbool_t is_divisible = svpfalse_b();\n    \n    while (svptest_any(pg, svnot_b_z(pg, is_divisible))) {\n        svint32_t remainders = svdiv_s32_z(pg, svdup_s32(n), divisors);\n        remainders = svmul_s32_z(pg, remainders, divisors);\n        remainders = svsub_s32_z(pg, svdup_s32(n), remainders);\n        \n        is_divisible = svorr_b_z(pg, is_divisible, \n                                svcmpeq_s32(pg, remainders, svdup_s32(0)));\n        \n        pg = svwhilelt_b32(svlength_s32(divisors), n/2);\n        indices = svadd_s32_z(pg, indices, svdup_s32(svlength_s32(divisors)));\n        divisors = svsel_s32(pg, indices, svdup_s32(0));\n    }\n    \n    return svptest_any(svptrue_b32(), is_divisible) ? y : x;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    const float* ptr = lst.data();\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, ptr + i);\n        \n        // Check if numbers are negative\n        svbool_t pos_mask = svcmpge_f32(pg, vec, 0.0f);\n        \n        // Check if numbers are integers\n        svfloat32_t rounded = svrintz_f32_x(pg, vec);\n        svbool_t int_mask = svcmpeq_f32(pg, vec, rounded);\n        \n        // Check if numbers are odd\n        svint32_t int_vec = svcvt_s32_f32_x(pg, rounded);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_s32_x(pg, int_vec, 1), 0);\n        \n        // Combine all masks\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, pos_mask, int_mask), odd_mask);\n        \n        // Square the valid numbers\n        svfloat32_t squared = svmul_f32_z(final_mask, vec, vec);\n        \n        // Sum the squares\n        sum += (uint64_t)svaddv_f32(final_mask, squared);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    const float* ptr = lst.data();\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_first(svptrue_b32(), pg)) {\n        // Load vector\n        svfloat32_t vec = svld1_f32(pg, ptr + i);\n        \n        // Check if numbers are integers\n        svfloat32_t rounded = svrintz_f32_x(pg, vec);\n        svbool_t is_int = svcmpeq_f32(pg, vec, rounded);\n        \n        // Check if numbers are non-negative\n        svbool_t is_positive = svcmpge_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Convert to integers\n        svint32_t int_vec = svcvt_s32_f32_x(pg, vec);\n        \n        // Check for odd numbers\n        svbool_t is_odd = svcmpne_n_s32(pg, svand_s32_x(pg, int_vec, svdup_n_s32(1)), 0);\n        \n        // Combine masks\n        svbool_t valid_mask = svand_b_z(pg, svand_b_z(pg, is_int, is_positive), is_odd);\n        \n        // Square valid numbers\n        svfloat32_t squared = svmul_f32_z(valid_mask, vec, vec);\n        \n        // Sum the squares\n        sum += (uint64_t)svaddv_f32(valid_mask, squared);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    size_t i = 0;\n    const float* ptr = lst.data();\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        // Load vector\n        svfloat32_t vec = svld1_f32(pg, ptr + i);\n        \n        // Check if numbers are positive\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Check if numbers are integers\n        svfloat32_t rounded = svrintn_f32_x(pg, vec);\n        svbool_t int_mask = svcmpeq_f32(pg, vec, rounded);\n        \n        // Check if numbers are odd\n        svint32_t int_vec = svcvt_s32_f32_x(pg, rounded);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_s32_x(pg, int_vec, svdup_n_s32(1)), 0);\n        \n        // Combine masks\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, pos_mask, int_mask), odd_mask);\n        \n        // Square the valid numbers\n        svfloat32_t squared = svmul_f32_z(final_mask, vec, vec);\n        \n        // Sum the squares\n        sum += (uint64_t)svaddv_f32(final_mask, squared);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n\n    uint64_t sum = 0;\n    size_t i = 0;\n    const float* ptr = lst.data();\n    size_t len = lst.size();\n\n    svbool_t pg = svwhilelt_b32(i, len);\n    while (svptest_first(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1_f32(pg, ptr + i);\n        \n        // Check if numbers are integers\n        svfloat32_t rounded = svrinta_f32_x(pg, vec);\n        svbool_t is_integer = svcmpeq_f32(pg, vec, rounded);\n        \n        // Check if numbers are non-negative\n        svbool_t is_positive = svcmpge_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Convert to integers\n        svint32_t int_vec = svcvt_s32_f32_x(pg, vec);\n        \n        // Check for odd numbers\n        svbool_t is_odd = svcmpne_n_s32(pg, svand_s32_x(pg, int_vec, svdup_n_s32(1)), 0);\n        \n        // Combine all conditions\n        svbool_t valid = svand_b_z(pg, is_integer, is_positive);\n        valid = svand_b_z(pg, valid, is_odd);\n        \n        // Square the valid numbers\n        svfloat32_t squared = svmul_f32_z(valid, vec, vec);\n        \n        // Sum the squares\n        sum += (uint64_t)svaddv_f32(valid, squared);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, len);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\nuint64_t double_the_difference_simd(const std::vector<float>& lst) {\n    if (lst.empty()) return 0;\n    \n    uint64_t sum = 0;\n    const float* ptr = lst.data();\n    size_t len = lst.size();\n    \n    svbool_t pg = svwhilelt_b32(0, len);\n    \n    while (svptest_first(svptrue_b32(), pg)) {\n        // Load vector\n        svfloat32_t vec = svld1_f32(pg, ptr);\n        \n        // Check if numbers are positive\n        svbool_t pos_mask = svcmpgt_f32(pg, vec, svdup_f32(0.0f));\n        \n        // Check if numbers are integers\n        svfloat32_t rounded = svrintz_f32_x(pg, vec);\n        svbool_t int_mask = svcmpeq_f32(pg, vec, rounded);\n        \n        // Check if numbers are odd\n        svint32_t int_vec = svcvt_s32_f32_x(pg, rounded);\n        svbool_t odd_mask = svcmpne_n_s32(pg, svand_s32_x(pg, int_vec, svdup_n_s32(1)), 0);\n        \n        // Combine masks\n        svbool_t final_mask = svand_b_z(pg, svand_b_z(pg, pos_mask, int_mask), odd_mask);\n        \n        // Square the valid numbers\n        svfloat32_t squared = svmul_f32_z(final_mask, vec, vec);\n        \n        // Sum the squares\n        sum += (uint64_t)svaddv_f32(final_mask, squared);\n        \n        ptr += svcntw();\n        pg = svwhilelt_b32(ptr - lst.data(), len);\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    \n    int n = game.size();\n    int i = 0;\n    \n    svbool_t pg = svwhilelt_b32(i, n);\n    while(svptest_first(svptrue_b32(), pg)) {\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        // Calculate absolute difference\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t len = game.size();\n    std::vector<int> result(len);\n    \n    for (size_t i = 0; i < len; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        \n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        // Calculate difference\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        \n        // Get absolute value\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        // Store result\n        svst1_s32(pg, &result[i], abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        svst1_s32(pg, &result[i], abs_diff);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    \n    for (size_t i = 0; i < n; i += svcntw()) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        \n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        \n        // Calculate difference\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        \n        // Get absolute value\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        \n        // Store result\n        svst1_s32(pg, &result[i], abs_diff);\n    }\n    \n    return result;\n}\n```"}

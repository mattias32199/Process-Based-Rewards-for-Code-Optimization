{"task_id": "SimdBench_0_Neon", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int64x2_t src_low = vld1q_s64(src + i);\n        int64x2_t src_high = vld1q_s64(src + i + 2);\n        uint8x8_t mask_low = vld1_u8(mask + i);\n        uint8x8_t mask_high = vld1_u8(mask + i + 8);\n\n        uint8x8_t mask_low_expanded = vzip_u8(mask_low, mask_low).val[0];\n        uint8x8_t mask_high_expanded = vzip_u8(mask_high, mask_high).val[0];\n\n        int64x2_t dst_low = vbslq_s64(mask_low_expanded, src_low, vld1q_s64(dst + i));\n        int64x2_t dst_high = vbslq_s64(mask_high_expanded, src_high, vld1q_s64(dst + i + 2));\n\n        vst1q_s64(dst + i, dst_low);\n        vst1q_s64(dst + i + 2, dst_high);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int64x2_t src_low = vld1q_s64(src + i);\n        int64x2_t src_high = vld1q_s64(src + i + 2);\n        uint8x16_t mask_low = vld1q_u8(mask + i);\n        uint8x16_t mask_high = vld1q_u8(mask + i + 2);\n\n        uint8x16_t mask_low_64 = vzip1q_u8(mask_low, mask_low);\n        uint8x16_t mask_high_64 = vzip1q_u8(mask_high, mask_high);\n\n        int64x2_t dst_low = vbslq_s64(mask_low_64, src_low, vld1q_s64(dst + i));\n        int64x2_t dst_high = vbslq_s64(mask_high_64, src_high, vld1q_s64(dst + i + 2));\n\n        vst1q_s64(dst + i, dst_low);\n        vst1q_s64(dst + i + 2, dst_high);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int64x2_t src_low = vld1q_s64(src + i);\n        int64x2_t src_high = vld1q_s64(src + i + 2);\n        uint8x16_t mask_low = vld1q_u8(mask + i);\n        uint8x16_t mask_high = vld1q_u8(mask + i + 2);\n\n        uint8x16_t mask_low_expanded = vcombine_u8(vmovl_u8(vget_low_u8(mask_low)), vmovl_u8(vget_high_u8(mask_low)));\n        uint8x16_t mask_high_expanded = vcombine_u8(vmovl_u8(vget_low_u8(mask_high)), vmovl_u8(vget_high_u8(mask_high)));\n\n        int64x2_t dst_low = vbslq_s64(mask_low_expanded, src_low, vld1q_s64(dst + i));\n        int64x2_t dst_high = vbslq_s64(mask_high_expanded, src_high, vld1q_s64(dst + i + 2));\n\n        vst1q_s64(dst + i, dst_low);\n        vst1q_s64(dst + i + 2, dst_high);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int64x2_t src_low = vld1q_s64(src + i);\n        int64x2_t src_high = vld1q_s64(src + i + 2);\n        uint8x8_t mask_low = vld1_u8(mask + i);\n        uint8x8_t mask_high = vld1_u8(mask + i + 8);\n\n        uint8x8_t mask_low_dup = vdup_n_u8(mask_low[0]);\n        uint8x8_t mask_high_dup = vdup_n_u8(mask_high[0]);\n\n        int64x2_t dst_low = vbslq_s64(mask_low_dup, src_low, vld1q_s64(dst + i));\n        int64x2_t dst_high = vbslq_s64(mask_high_dup, src_high, vld1q_s64(dst + i + 2));\n\n        vst1q_s64(dst + i, dst_low);\n        vst1q_s64(dst + i + 2, dst_high);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int64x2_t src_low = vld1q_s64(src + i);\n        int64x2_t src_high = vld1q_s64(src + i + 2);\n        int64x2_t dst_low = vld1q_s64(dst + i);\n        int64x2_t dst_high = vld1q_s64(dst + i + 2);\n\n        uint8x8_t mask_low = vld1_u8((const uint8_t *)(mask + i));\n        uint8x8_t mask_high = vld1_u8((const uint8_t *)(mask + i + 4));\n\n        uint8x8_t mask_low_dup = vdup_n_u8(mask_low[0]);\n        uint8x8_t mask_high_dup = vdup_n_u8(mask_high[0]);\n\n        uint8x8_t mask_low_dup2 = vdup_n_u8(mask_low[1]);\n        uint8x8_t mask_high_dup2 = vdup_n_u8(mask_high[1]);\n\n        uint8x8_t mask_low_dup3 = vdup_n_u8(mask_low[2]);\n        uint8x8_t mask_high_dup3 = vdup_n_u8(mask_high[2]);\n\n        uint8x8_t mask_low_dup4 = vdup_n_u8(mask_low[3]);\n        uint8x8_t mask_high_dup4 = vdup_n_u8(mask_high[3]);\n\n        dst_low = vbslq_s64(mask_low_dup, src_low, dst_low);\n        dst_high = vbslq_s64(mask_high_dup, src_high, dst_high);\n\n        dst_low = vbslq_s64(mask_low_dup2, src_low, dst_low);\n        dst_high = vbslq_s64(mask_high_dup2, src_high, dst_high);\n\n        dst_low = vbslq_s64(mask_low_dup3, src_low, dst_low);\n        dst_high = vbslq_s64(mask_high_dup3, src_high, dst_high);\n\n        dst_low = vbslq_s64(mask_low_dup4, src_low, dst_low);\n        dst_high = vbslq_s64(mask_high_dup4, src_high, dst_high);\n\n        vst1q_s64(dst + i, dst_low);\n        vst1q_s64(dst + i + 2, dst_high);\n    }\n\n    for (; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t velement = vld1q_s32(&src[i]);\n        int32x4_t vtmp1 = vshrq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vresult = vdivq_s32(vaddq_s32(vmulq_s32(velement, vscale), vmulq_s32(vtmp1, vtmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        int element = src[i];\n        int tmp1 = (element * scale) >> 3;\n        int tmp2 = (element * scale) << 3;\n        dst[i] = (element * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    size_t i;\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t velement = vld1q_s32(&src[i]);\n        int32x4_t vtmp1 = vshrq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vresult = vdivq_s32(vaddq_s32(vmulq_s32(velement, vscale), vmulq_s32(vtmp1, vtmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        int tmp1 = (src[i] * scale) >> 3;\n        int tmp2 = (src[i] * scale) << 3;\n        dst[i] = (src[i] * scale + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t velement = vld1q_s32(&src[i]);\n        int32x4_t vtmp1 = vshrq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vresult = vdivq_s32(vaddq_s32(vmulq_s32(velement, vscale), vmulq_s32(vtmp1, vtmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    int32x4_t v7 = vdupq_n_s32(7);\n\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t velement = vld1q_s32(src + i);\n\n        int32x4_t vtmp1 = vshrq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vmulq_s32(velement, vscale), 3);\n\n        int32x4_t vresult = vdivq_s32(vaddq_s32(vmulq_s32(velement, vscale), vmulq_s32(vtmp1, vtmp2)), v7);\n\n        vst1q_s32(dst + i, vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    int32x4_t vscale = vdupq_n_s32(scale);\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t velement = vld1q_s32(&src[i]);\n        int32x4_t vtmp1 = vshrq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vtmp2 = vshlq_n_s32(vmulq_s32(velement, vscale), 3);\n        int32x4_t vresult = vdivq_s32(vaddq_s32(vmulq_s32(velement, vscale), vmulq_s32(vtmp1, vtmp2)), vdupq_n_s32(7));\n        vst1q_s32(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        float64x2_t v = vld1q_f64(src + r * cols + stride);\n        vst1q_f64(dst + r, v);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        float64x2_t vec = vld1q_f64(src + r * cols + stride);\n        vst1q_f64(dst + r, vec);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        float64x2_t src_val = vld1q_f64(&src[r * cols + stride]);\n        vst1q_f64(&dst[r], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        float64x2_t src_val = vld1q_f64(src + r * cols + stride);\n        vst1q_f64(dst + r, src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; ++r) {\n        float64x2_t src_val = vld1q_f64(&src[r * cols + stride]);\n        vst1q_f64(&dst[r], src_val);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t gather = vld4q_lane_f32(src, idx, 0);\n        vst1q_f32(&dst[i], gather);\n        float32x4_t scatter = vld1q_f32(&src[i]);\n        vst4q_lane_f32(dst, scatter, idx, 0);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t src_vals = vld4q_f32(&src[i]);\n\n        float32x4_t gather_vals = vld4q_f32(&src[idx[0]], &src[idx[1]], &src[idx[2]], &src[idx[3]]);\n        vst1q_f32(&dst[i], gather_vals);\n\n        vst4q_f32(&dst[idx[0]], &dst[idx[1]], &dst[idx[2]], &dst[idx[3]], src_vals);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t src_vals = vld4q_f32(&src[i]);\n        float32x4_t dst_vals = vld4q_f32(&dst[i]);\n\n        // Gather operation\n        float32x4_t gather_vals = {\n            src[idx[0]],\n            src[idx[1]],\n            src[idx[2]],\n            src[idx[3]]\n        };\n\n        // Scatter operation\n        dst[idx[0]] = src_vals[0];\n        dst[idx[1]] = src_vals[1];\n        dst[idx[2]] = src_vals[2];\n        dst[idx[3]] = src_vals[3];\n\n        vst1q_f32(&dst[i], gather_vals);\n    }\n\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n        dst[i] = src[indices[i]];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t src_vals = vld4q_f32(&src[i]);\n        float32x4_t dst_vals = vld4q_f32(&dst[i]);\n\n        float32x4_t gathered = vld4q_f32(&src[idx[0]]);\n        float32x4_t scattered = vld4q_f32(&src[idx[1]]);\n\n        vst4q_f32(&dst[i], gathered);\n        vst4q_f32(&dst[i + 4], scattered);\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i += 4) {\n        int32x4_t idx = vld1q_s32(&indices[i]);\n        float32x4_t src_vals = vld4q_f32(&src[i]);\n        float32x4_t dst_vals = vld4q_f32(&dst[i]);\n\n        float32x4_t gather_vals = vld4q_f32(&src[idx[0]]);\n        float32x4_t scatter_vals = vld4q_f32(&src[i]);\n\n        vst4q_f32(&dst[i], gather_vals);\n        vst4q_f32(&dst[idx[0]], scatter_vals);\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        int16x8_t a = vld1q_s16(&arr[i]);\n        int16x8_t b = vld1q_s16(&arr[j]);\n\n        int16x8_t temp = a;\n        a = b;\n        b = temp;\n\n        vst1q_s16(&arr[i], a);\n        vst1q_s16(&arr[j], b);\n\n        i += 8;\n        j -= 8;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        int16x8_t a = vld1q_s16(&arr[i]);\n        int16x8_t b = vld1q_s16(&arr[j]);\n\n        int16x8_t temp = a;\n        a = b;\n        b = temp;\n\n        vst1q_s16(&arr[i], a);\n        vst1q_s16(&arr[j], b);\n\n        i += 8;\n        j -= 8;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        int16x8_t a = vld1q_s16(&arr[i]);\n        int16x8_t b = vld1q_s16(&arr[j]);\n\n        int16x8_t temp = a;\n        a = b;\n        b = temp;\n\n        vst1q_s16(&arr[i], a);\n        vst1q_s16(&arr[j], b);\n\n        i += 8;\n        j -= 8;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        int16x8_t a = vld1q_s16(&arr[i]);\n        int16x8_t b = vld1q_s16(&arr[j]);\n\n        int16x8_t temp = a;\n        a = b;\n        b = temp;\n\n        vst1q_s16(&arr[i], a);\n        vst1q_s16(&arr[j], b);\n\n        i += 8;\n        j -= 8;\n    }\n\n    if (i == j) {\n        int16x8_t a = vld1q_s16(&arr[i]);\n        int16x8_t b = vld1q_s16(&arr[j]);\n\n        int16x8_t temp = a;\n        a = b;\n        b = temp;\n\n        vst1q_s16(&arr[i], a);\n        vst1q_s16(&arr[j], b);\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```cpp\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (i < j) {\n        int16x8_t a = vld1q_s16(&arr[i]);\n        int16x8_t b = vld1q_s16(&arr[j]);\n\n        int16x8_t temp = a;\n        a = b;\n        b = temp;\n\n        vst1q_s16(&arr[i], a);\n        vst1q_s16(&arr[j], b);\n\n        i += 8;\n        j -= 8;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * slice_size;\n    uint8_t *dst = slice;\n\n    for (size_t i = 0; i < slice_size; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        vst1q_u8(dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * slice_size;\n    uint8_t *dst = slice;\n\n    for (size_t i = 0; i < slice_size; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        vst1q_u8(dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * slice_size;\n    uint8_t *dst = slice;\n\n    for (size_t i = 0; i < slice_size; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        vst1q_u8(dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    const uint8_t *src = tensor + offset;\n\n    for (size_t i = 0; i < slice_size; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        vst1q_u8(slice + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    const uint8_t *src = tensor + slice_idx * slice_size;\n    uint8_t *dst = slice;\n\n    for (size_t i = 0; i < slice_size; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        vst1q_u8(dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ++ii) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; ++jj) {\n                    int16x8_t vec = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ++ii) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; ++jj) {\n                    int16x8_t vec = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; bj += 8) {\n                    int16x8_t vec = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = 0; bi < block_size; ++bi) {\n                for (size_t bj = 0; bj < block_size; bj += 8) {\n                    int16x8_t vec = vld1q_s16(&src[(i + bi) * cols + j + bj]);\n                    vst1q_s16(&dst[(j + bj) * rows + i + bi], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t ii = i; ii < i + block_size && ii < rows; ++ii) {\n                for (size_t jj = j; jj < j + block_size && jj < cols; ++jj) {\n                    int16x8_t vec = vld1q_s16(&src[ii * cols + jj]);\n                    vst1q_s16(&dst[jj * rows + ii], vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t stride = dim * dim;\n    size_t i;\n\n    for (i = 0; i < dim; i += 4) {\n        float32x4_t diag_vec = vld1q_f32(array + i * (stride + dim + 1));\n        sum_vec = vaddq_f32(sum_vec, diag_vec);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sum_vec);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i < dim; ++i) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t val_vec = vld1q_f32(&array[index]);\n        sum_vec = vaddq_f32(sum_vec, val_vec);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sum_vec);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t val_vec = vld1q_f32(&array[index]);\n        sum_vec = vaddq_f32(sum_vec, val_vec);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sum_vec);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i < dim; ++i) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t vec = vld1q_f32(&array[index]);\n        sum_vec = vaddq_f32(sum_vec, vec);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sum_vec);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i;\n\n    for (i = 0; i < dim; i++) {\n        size_t index = i * (dim * dim + dim + 1);\n        float32x4_t vec = vld1q_f32(&array[index]);\n        sum_vec = vaddq_f32(sum_vec, vec);\n    }\n\n    float sum[4];\n    vst1q_f32(sum, sum_vec);\n    return sum[0] + sum[1] + sum[2] + sum[3];\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (i = 0; i <= num_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_dst = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_dst);\n    }\n\n    for (; i < num_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (i = 0; i <= num_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_dst = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_dst);\n    }\n\n    for (; i < num_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (i = 0; i <= num_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_dst = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_dst);\n    }\n\n    for (; i < num_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(src + i);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(dst + i, v_result);\n    }\n\n    for (; i < num_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i;\n\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n\n    for (i = 0; i <= num_elements - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(&src[i]);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_dst = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(&dst[i], v_dst);\n    }\n\n    for (; i < num_elements; ++i) {\n        dst[i] = (src[i] > threshold) ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        for (size_t j = 0; j < cols; j += 2) {\n            double64x2_t vec = vld1q_f64(&src[src_row + j]);\n            vst1q_f64(&dst[dst_row + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        for (size_t j = 0; j < cols; j += 2) {\n            double32x2_t vec = vld1q_f64(&src[src_row + j]);\n            vst1q_f64(&dst[dst_row + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i] * cols;\n        size_t dst_row_index = i * cols;\n        for (size_t j = 0; j < cols; j += 2) {\n            double32x2_t src_vec = vld1q_f64(&src[src_row_index + j]);\n            vst1q_f64(&dst[dst_row_index + j], src_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        for (size_t j = 0; j < cols; j += 2) {\n            double64x2_t vec = vld1q_f64(&src[src_row + j]);\n            vst1q_f64(&dst[dst_row + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(&src[src_row + j]);\n            vst1q_f64(&dst[dst_row + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    int64x2_t two_vec = vdupq_n_s64(2);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(dst + i, sum);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    int64x2_t two_vec = vdupq_n_s64(2);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(dst + i, sum);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    int64x2_t two_vec = vdupq_n_s64(2);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(dst + i, sum);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    int64x2_t two_vec = vdupq_n_s64(2);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(dst + i, sum);\n    }\n\n    if (i < length) {\n        int64_t val1 = src1[i];\n        int64_t val2 = src2[i];\n        int64_t result = (val1 + val2 + scalar) / 2;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    int64x2_t two_vec = vdupq_n_s64(2);\n\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vec1 = vld1q_s64(src1 + i);\n        int64x2_t vec2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(vec1, vec2);\n        sum = vaddq_s64(sum, scalar_vec);\n        sum = vshrq_n_s64(sum, 1);\n        vst1q_s64(dst + i, sum);\n    }\n\n    if (i < length) {\n        int64x1_t vec1 = vld1_s64(src1 + i);\n        int64x1_t vec2 = vld1_s64(src2 + i);\n        int64x1_t sum = vadd_s64(vec1, vec2);\n        sum = vadd_s64(sum, vget_low_s64(scalar_vec));\n        sum = vshr_n_s64(sum, 1);\n        vst1_s64(dst + i, sum);\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&src[i]);\n        int32x4_t even_mask = {1, 0, 1, 0};\n        int32x4_t even_elements = vandq_s32(vec, even_mask);\n        min_val = vminq_s32(min_val, even_elements);\n    }\n\n    int min_scalar = vgetq_lane_s32(min_val, 0);\n    for (size_t j = 0; j < 4; ++j) {\n        int val = vgetq_lane_s32(min_val, j);\n        if (val < min_scalar) {\n            min_scalar = val;\n        }\n    }\n\n    for (; i < length; ++i) {\n        if (i % 2 == 0 && src[i] < min_scalar) {\n            min_scalar = src[i];\n        }\n    }\n\n    return min_scalar;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t even_mask = {0, 1, 0, 1};\n        int32x4_t even_elements = vbslq_s32(even_mask, vec, vdupq_n_s32(INT32_MAX));\n        min_val = vminq_s32(min_val, even_elements);\n    }\n\n    int min_scalar = vminvq_s32(min_val);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_scalar) {\n            min_scalar = src[i];\n        }\n    }\n\n    return min_scalar;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```cpp\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t even_mask = {1, 0, 1, 0};\n        int32x4_t even_elements = vbslq_s32(even_mask, vec, vdupq_n_s32(INT32_MAX));\n        min_val = vminq_s32(min_val, even_elements);\n    }\n\n    int min_vals[4];\n    vst1q_s32(min_vals, min_val);\n    int min_even = min_vals[0];\n    for (int j = 2; j < 4; j += 2) {\n        if (min_vals[j] < min_even) {\n            min_even = min_vals[j];\n        }\n    }\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_even) {\n            min_even = src[i];\n        }\n    }\n\n    return min_even;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    for (; i + 7 < length; i += 8) {\n        int32x4_t v0 = vld1q_s32(src + i);\n        int32x4_t v1 = vld1q_s32(src + i + 4);\n\n        int32x4_t even_mask = vdupq_n_s32(0xAAAAAAAA);\n        int32x4_t odd_mask = vdupq_n_s32(0x55555555);\n\n        int32x4_t even0 = vandq_s32(v0, even_mask);\n        int32x4_t even1 = vandq_s32(v1, even_mask);\n\n        min_val = vminq_s32(min_val, even0);\n        min_val = vminq_s32(min_val, even1);\n    }\n\n    int min_scalar = vminvq_s32(min_val);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_scalar) {\n            min_scalar = src[i];\n        }\n    }\n\n    return min_scalar;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    for (; i + 7 < length; i += 8) {\n        int32x4_t v0 = vld1q_s32(src + i);\n        int32x4_t v1 = vld1q_s32(src + i + 4);\n\n        int32x4_t even_mask = vdupq_n_s32(0xAAAAAAAA);\n        int32x4_t odd_mask = vdupq_n_s32(0x55555555);\n\n        int32x4_t even0 = vandq_s32(v0, even_mask);\n        int32x4_t even1 = vandq_s32(v1, even_mask);\n\n        min_val = vminq_s32(min_val, even0);\n        min_val = vminq_s32(min_val, even1);\n    }\n\n    int min_scalar = vminvq_s32(min_val);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_scalar) {\n            min_scalar = src[i];\n        }\n    }\n\n    return min_scalar;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    int32x4_t vshift = vdupq_n_s32(shift);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vsrc = vld1q_s32(src + i);\n        int32x4_t varith_shift = vshrq_s32(vsrc, vshift);\n        uint32x4_t vuint_src = vreinterpretq_u32_s32(vsrc);\n        uint32x4_t vlogical_shift = vshrq_u32(vuint_src, vshift);\n        int32x4_t vresult = vaddq_s32(varith_shift, vreinterpretq_s32_u32(vlogical_shift));\n        vst1q_s32(dst + i, vresult);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((unsigned int)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    int32x4_t shift_vec = vdupq_n_s32(shift);\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n\n        int32x4_t arith_shift = vshrq_n_s32(src_vec, shift);\n        int32x4_t logical_shift = vshrq_n_u32(vreinterpretq_u32_s32(src_vec), shift);\n\n        int32x4_t result = vaddq_s32(arith_shift, vreinterpretq_s32_u32(logical_shift));\n\n        vst1q_s32(dst + i, result);\n    }\n\n    for (; i < length; ++i) {\n        int arith_shift = src[i] >> shift;\n        int logical_shift = (uint32_t)src[i] >> shift;\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    int32x4_t vshift = vdupq_n_s32(shift);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t vsrc = vld1q_s32(&src[i]);\n        int32x4_t varith_shift = vshrq_s32(vsrc, vshift);\n        uint32x4_t vuint_src = vreinterpretq_u32_s32(vsrc);\n        uint32x4_t vlogical_shift = vshrq_u32(vuint_src, vshift);\n        int32x4_t vlogical_shift_s32 = vreinterpretq_s32_u32(vlogical_shift);\n        int32x4_t vresult = vaddq_s32(varith_shift, vlogical_shift_s32);\n        vst1q_s32(&dst[i], vresult);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((unsigned int)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i;\n    int32x4_t vshift = vdupq_n_s32(shift);\n    int32x4_t vshift_u = vdupq_n_s32(shift);\n\n    for (i = 0; i <= length - 4; i += 4) {\n        int32x4_t v = vld1q_s32(src + i);\n        int32x4_t v_arith_shift = vshrq_s32(v, vshift);\n        int32x4_t v_logical_shift = vshrq_u32(vreinterpretq_u32_s32(v), vshift_u);\n        int32x4_t v_result = vaddq_s32(v_arith_shift, v_logical_shift);\n        vst1q_s32(dst + i, v_result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((uint32_t)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    int32x4_t vshift = vdupq_n_s32(shift);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (; i <= length - 4; i += 4) {\n        int32x4_t vsrc = vld1q_s32(src + i);\n        int32x4_t varith_shift = vshrq_s32(vsrc, vshift);\n        uint32x4_t vuint_src = vreinterpretq_u32_s32(vsrc);\n        uint32x4_t vlogical_shift = vshrq_u32(vuint_src, vshift);\n        int32x4_t vlogical_shift_signed = vreinterpretq_s32_u32(vlogical_shift);\n        int32x4_t vresult = vaddq_s32(varith_shift, vlogical_shift_signed);\n        vst1q_s32(dst + i, vresult);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (src[i] >> shift) + ((unsigned int)src[i] >> shift);\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t size = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time using Neon intrinsics\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t size = rows * cols;\n    size_t i = 0;\n\n    // Process 4 elements at a time\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        int64x2_t sum_vec = vpaddlq_s32(vec);\n        sum += vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t size = rows * cols;\n    size_t i = 0;\n\n    int32x4_t vec_sum = vdupq_n_s32(0);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        vec_sum = vaddq_s32(vec_sum, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, vec_sum);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < size; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t size = rows * cols;\n    size_t i = 0;\n\n    int32x4_t vec_sum = vdupq_n_s32(0);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        vec_sum = vaddq_s32(vec_sum, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, vec_sum);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < size; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t size = rows * cols;\n    size_t i = 0;\n\n    int32x4_t vec_sum = vdupq_n_s32(0);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(matrix + i);\n        vec_sum = vaddq_s32(vec_sum, vec);\n    }\n\n    int32_t buffer[4];\n    vst1q_s32(buffer, vec_sum);\n    sum = buffer[0] + buffer[1] + buffer[2] + buffer[3];\n\n    for (; i < size; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t v_src = vld1q_s8(src + i);\n        int8x16_t v_max = vdupq_n_s8(max_value);\n\n        uint8x16_t v_cmp = vcgtq_s8(v_src, v_max);\n        uint8x16_t v_mask = vcltq_s8(v_src, v_max);\n\n        int8x16_t v_new_max = vbslq_s8(v_cmp, v_src, v_max);\n        uint8x16_t v_new_mask = vbslq_s8(v_cmp, vdupq_n_u8(1), vdupq_n_u8(0));\n\n        int8x16_t v_new_max_value = vmaxvq_s8(v_new_max);\n        uint8x16_t v_new_max_index = vmaxvq_u8(v_new_mask);\n\n        if (vgetq_lane_s8(v_new_max_value, 0) > max_value) {\n            max_value = vgetq_lane_s8(v_new_max_value, 0);\n            max_index = i + vgetq_lane_u8(v_new_max_index, 0);\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8x16_t max_vals = vdupq_n_s8(src[0]);\n    int8x16_t indices = vdupq_n_s8(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        size_t chunk_size = (length - i) < 16 ? (length - i) : 16;\n        int8x16_t vals = vld1q_s8(src + i);\n        int8x16_t cmp = vcgtq_s8(vals, max_vals);\n\n        max_vals = vbslq_s8(cmp, vals, max_vals);\n        indices = vbslq_s8(cmp, vdupq_n_s8(i), indices);\n    }\n\n    int8_t max_val = vmaxvq_s8(max_vals);\n    int8_t max_idx = vmaxvq_s8(indices);\n\n    for (size_t i = 0; i < length; ++i) {\n        if (src[i] == max_val) {\n            max_index = i;\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8x16_t max_vals = vdupq_n_s8(src[0]);\n    int8x16_t indices = vdupq_n_s8(0);\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t vals = vld1q_s8(src + i);\n        int8x16_t cmp = vcgtq_s8(vals, max_vals);\n        max_vals = vbslq_s8(cmp, vals, max_vals);\n        indices = vbslq_s8(cmp, vdupq_n_s8(i), indices);\n    }\n\n    int8_t max_val = vmaxvq_s8(max_vals);\n    int8_t max_idx = vmaxvq_s8(indices);\n\n    for (size_t i = 0; i < length; ++i) {\n        if (src[i] == max_val) {\n            max_index = i;\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t v_src = vld1q_s8(src + i);\n        int8x16_t v_max = vdupq_n_s8(max_value);\n\n        uint8x16_t v_cmp = vcgtq_s8(v_src, v_max);\n        uint8x16_t v_mask = v_cmp;\n\n        if (vmaxvq_u8(v_mask) != 0) {\n            uint8_t mask[16];\n            vst1q_u8(mask, v_mask);\n\n            for (int j = 0; j < 16; ++j) {\n                if (mask[j]) {\n                    max_index = i + j;\n                    max_value = src[max_index];\n                }\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    int8x16_t max_val = vdupq_n_s8(INT8_MIN);\n    int8x16_t indices = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    size_t max_index = 0;\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t current_vals = vld1q_s8(src + i);\n        uint8x16_t cmp = vcgtq_s8(current_vals, max_val);\n        max_val = vmaxq_s8(max_val, current_vals);\n        indices = vbslq_s8(cmp, indices, vdupq_n_s8(i));\n    }\n\n    int8x8_t max_val_low = vget_low_s8(max_val);\n    int8x8_t max_val_high = vget_high_s8(max_val);\n    int8x8_t max_val_combined = vmax_s8(max_val_low, max_val_high);\n\n    int8x8_t indices_low = vget_low_s8(indices);\n    int8x8_t indices_high = vget_high_s8(indices);\n    int8x8_t indices_combined = vbsl_s8(vcgt_s8(max_val_low, max_val_high), indices_low, indices_high);\n\n    int8x8_t max_val_final = vmax_s8(max_val_combined, vdup_n_s8(INT8_MIN));\n    int8x8_t indices_final = vbsl_s8(vcgt_s8(max_val_combined, vdup_n_s8(INT8_MIN)), indices_combined, vdup_n_s8(0));\n\n    int8_t max_val_scalar = vmaxv_s8(max_val_final);\n    int8_t max_index_scalar = vmaxv_s8(indices_final);\n\n    for (size_t i = 0; i < length; ++i) {\n        if (src[i] == max_val_scalar) {\n            max_index = i;\n            break;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint16x8_t src1_vec, src2_vec, mask_vec, result_vec;\n    uint16x8_t index_vec = {0, 1, 2, 3, 4, 5, 6, 7};\n    uint16x8_t mask_val = vdupq_n_u16(mask);\n\n    for (; i <= length - 8; i += 8) {\n        src1_vec = vld1q_u16(src1 + i);\n        src2_vec = vld1q_u16(src2 + i);\n\n        mask_vec = vandq_u16(vaddq_u16(index_vec, vdupq_n_u16(i)), mask_val);\n        result_vec = vbslq_u16(vcgtq_u16(mask_vec, vdupq_n_u16(0)), src1_vec, src2_vec);\n\n        vst1q_u16(dst + i, result_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n\n        uint32x4_t v_mask = vdupq_n_u32(mask);\n        uint32x4_t v_index = {i, i + 1, i + 2, i + 3};\n        uint32x4_t v_and = vandq_u32(v_mask, v_index);\n        uint16x8_t v_select = vbslq_u16(vcgtq_u32(v_and, vdupq_n_u32(0)), v_src1, v_src2);\n\n        vst1q_u16(dst + i, v_select);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint16x8_t src1_vec, src2_vec, mask_vec, result_vec;\n    uint16x8_t index_vec = {0, 1, 2, 3, 4, 5, 6, 7};\n    uint16x8_t mask_val = vdupq_n_u16(mask);\n\n    for (; i <= length - 8; i += 8) {\n        src1_vec = vld1q_u16(src1 + i);\n        src2_vec = vld1q_u16(src2 + i);\n\n        mask_vec = vandq_u16(vaddq_u16(index_vec, vdupq_n_u16(i)), mask_val);\n        mask_vec = vcgtq_u16(mask_vec, vdupq_n_u16(0));\n\n        result_vec = vbslq_u16(mask_vec, src1_vec, src2_vec);\n        vst1q_u16(dst + i, result_vec);\n\n        index_vec = vaddq_u16(index_vec, vdupq_n_u16(8));\n    }\n\n    for (; i < length; ++i) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v_src1 = vld1q_u16(src1 + i);\n        uint16x8_t v_src2 = vld1q_u16(src2 + i);\n\n        uint32x4_t v_mask = vdupq_n_u32(mask);\n        uint32x4_t v_index = {i, i + 1, i + 2, i + 3, i + 4, i + 5, i + 6, i + 7};\n        uint32x4_t v_and = vandq_u32(v_mask, v_index);\n\n        uint16x8_t v_result = vbslq_u16(v_and, v_src1, v_src2);\n\n        vst1q_u16(dst + i, v_result);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint16x8_t mask_vec = vdupq_n_u16(mask);\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n        uint16x8_t index_vec = vaddq_u16(vdupq_n_u16(i), vcombine_u16(vcreate_u16(0x00010000), vcreate_u16(0x00030002)));\n        uint16x8_t and_result = vandq_u16(index_vec, mask_vec);\n        uint16x8_t blend_result = vbslq_u16(vcgtq_u16(and_result, vdupq_n_u16(0)), src1_vec, src2_vec);\n        vst1q_u16(dst + i, blend_result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint32x4_t popcount = vcntq_u8(vreinterpretq_u8_u32(v));\n        vst1q_u32(dst + i, vaddvq_u32(popcount));\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint32x4_t count = vcntq_u8(vreinterpretq_u8_u32(v));\n        vst1q_u32(dst + i, vaddvq_u32(count));\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint32x4_t count = vcntq_u8(vreinterpretq_u8_u32(v));\n        vst1q_u32(dst + i, vaddvq_u32(count));\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint32x4_t popcount = vcntq_u8(vreinterpretq_u8_u32(v));\n        uint32x4_t result = vaddvq_u8(popcount);\n        vst1q_u32(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint32x4_t count = vcntq_u8(vreinterpretq_u8_u32(v));\n        vst1q_u32(dst + i, vaddvq_u32(count));\n    }\n    for (; i < length; ++i) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src1[i] + src2[i];\n        if (dst[i] < src1[i]) {\n            dst[i] = UINT16_MAX;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t vsum = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, vsum);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t vsum = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, vsum);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src1[i] + src2[i];\n        if (dst[i] < src1[i]) {\n            dst[i] = UINT16_MAX;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 8; i += 8) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, result);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src1[i] + src2[i] > UINT16_MAX ? UINT16_MAX : src1[i] + src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                float64x2_t c = vld1q_f64(&C[i * p + j]);\n\n                uint64x2_t mask_a = vandq_u64(vcgeq_f64(a, vdupq_n_f64(-100.0)), vcleq_f64(a, vdupq_n_f64(100.0)));\n                uint64x2_t mask_b = vandq_u64(vcgeq_f64(b, vdupq_n_f64(-100.0)), vcleq_f64(b, vdupq_n_f64(100.0)));\n\n                a = vbslq_f64(mask_a, a, vdupq_n_f64(0.0));\n                b = vbslq_f64(mask_b, b, vdupq_n_f64(0.0));\n\n                float64x2_t prod = vmulq_f64(a, b);\n                sum += vaddvq_f64(prod);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                float64x2_t c = vmulq_f64(a, b);\n\n                float64x2_t range_min = vdupq_n_f64(-100.0);\n                float64x2_t range_max = vdupq_n_f64(100.0);\n\n                uint64x2_t mask_a = vandq_u64(vcgeq_f64(a, range_min), vcleq_f64(a, range_max));\n                uint64x2_t mask_b = vandq_u64(vcgeq_f64(b, range_min), vcleq_f64(b, range_max));\n\n                uint64x2_t mask = vandq_u64(mask_a, mask_b);\n                c = vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(c), mask));\n\n                sum += vaddvq_f64(c);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                double a0 = A[i * n + k];\n                double a1 = A[i * n + k + 1];\n                double b0 = B[k * p + j];\n                double b1 = B[(k + 1) * p + j];\n\n                if (a0 >= -100 && a0 <= 100 && b0 >= -100 && b0 <= 100) {\n                    sum += a0 * b0;\n                }\n                if (a1 >= -100 && a1 <= 100 && b1 >= -100 && b1 <= 100) {\n                    sum += a1 * b1;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                float64x2_t c = vld1q_f64(&C[i * p + j]);\n\n                uint64x2_t mask_a = vandq_u64(vcgeq_f64(a, vdupq_n_f64(-100.0)), vcleq_f64(a, vdupq_n_f64(100.0)));\n                uint64x2_t mask_b = vandq_u64(vcgeq_f64(b, vdupq_n_f64(-100.0)), vcleq_f64(b, vdupq_n_f64(100.0)));\n\n                a = vbslq_f64(mask_a, a, vdupq_n_f64(0.0));\n                b = vbslq_f64(mask_b, b, vdupq_n_f64(0.0));\n\n                float64x2_t prod = vmulq_f64(a, b);\n                sum += vaddvq_f64(prod);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&A[i * n + k]);\n                float64x2_t b = vld1q_f64(&B[k * p + j]);\n                float64x2_t c = vld1q_f64(&C[i * p + j]);\n\n                uint64x2_t mask_a = vandq_u64(vcgeq_f64(a, vdupq_n_f64(-100.0)), vcleq_f64(a, vdupq_n_f64(100.0)));\n                uint64x2_t mask_b = vandq_u64(vcgeq_f64(b, vdupq_n_f64(-100.0)), vcleq_f64(b, vdupq_n_f64(100.0)));\n\n                a = vbslq_f64(mask_a, a, vdupq_n_f64(0.0));\n                b = vbslq_f64(mask_b, b, vdupq_n_f64(0.0));\n\n                float64x2_t prod = vmulq_f64(a, b);\n                sum += vaddvq_f64(prod);\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= size - 2; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n\n    if (i < size) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 2) {\n        int64x2_t a = vld1q_s64(&A[i]);\n        int64x2_t b = vld1q_s64(&B[i]);\n        int64x2_t c = vaddq_s64(a, b);\n        vst1q_s64(&C[i], c);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t vsum = vaddq_f32(v1, v2);\n        float32x4_t vround = vrndaq_f32(vsum);\n        vst1q_f32(dst + i, vround);\n    }\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t vsum = vaddq_f32(v1, v2);\n        int32x4_t vround = vcvtq_s32_f32(vsum);\n        float32x4_t vresult = vcvtq_f32_s32(vround);\n        vst1q_f32(dst + i, vresult);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t vsum = vaddq_f32(v1, v2);\n        int32x4_t vint = vcvtq_s32_f32(vsum);\n        float32x4_t vround = vcvtq_f32_s32(vint);\n        vst1q_f32(dst + i, vround);\n    }\n    for (; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndaq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n    for (; i < length; ++i) {\n        dst[i] = nearbyintf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t threshold = vdupq_n_f32(50.0f);\n    const float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    const float32x4_t one = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(src1 + i);\n        float32x4_t v_src2 = vld1q_f32(src2 + i);\n\n        uint32x4_t v_index = vaddq_u32(vdupq_n_u32(i), vcombine_u32(vcreate_u32(0), vcreate_u32(1)));\n        uint32x4_t v_mask = vandq_u32(v_index, vdupq_n_u32(1));\n        v_mask = vceqq_u32(v_mask, vdupq_n_u32(0));\n\n        float32x4_t v_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n        uint32x4_t v_cond = vandq_u32(vcgeq_f32(threshold, v_diff), v_mask);\n\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n        float32x4_t v_rounded = vceilq_f32(v_mul);\n\n        float32x4_t v_result = vbslq_f32(v_cond, v_rounded, neg_one);\n\n        vst1q_f32(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t threshold = vdupq_n_f32(50.0f);\n    const float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    const int32x4_t index_mask = vdupq_n_s32(1);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n        uint32x4_t mask = vcleq_f32(diff, threshold);\n\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i), vdupq_n_s32(0));\n        uint32x4_t index_masked = vandq_u32(vcgeq_s32(indices, vdupq_n_s32(0)), index_mask);\n\n        mask = vandq_u32(mask, index_masked);\n\n        float32x4_t result = vmulq_f32(v1, v2);\n        result = vceilq_f32(result);\n\n        result = vbslq_f32(mask, result, neg_one);\n\n        vst1q_f32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t threshold = vdupq_n_f32(50.0f);\n    const float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    const float32x4_t one = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(src1 + i);\n        float32x4_t v_src2 = vld1q_f32(src2 + i);\n\n        uint32x4_t v_index = vaddq_u32(vdupq_n_u32(i), vcombine_u32(vcreate_u32(0), vcreate_u32(1)));\n        uint32x4_t v_mask = vandq_u32(v_index, vdupq_n_u32(1));\n        v_mask = vceqq_u32(v_mask, vdupq_n_u32(0));\n\n        float32x4_t v_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n        uint32x4_t v_cond = vcltq_f32(v_diff, threshold);\n        v_cond = vandq_u32(v_cond, v_mask);\n\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n        float32x4_t v_round_up = vaddq_f32(v_mul, one);\n        v_round_up = vsubq_f32(v_round_up, vdupq_n_f32(0.000001f));\n\n        float32x4_t v_result = vbslq_f32(v_cond, v_round_up, neg_one);\n\n        vst1q_f32(dst + i, v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    float32x4_t v_50 = vdupq_n_f32(50.0f);\n    float32x4_t v_neg1 = vdupq_n_f32(-1.0f);\n    float32x4_t v_1 = vdupq_n_f32(1.0f);\n    float32x4_t v_0 = vdupq_n_f32(0.0f);\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(src1 + i);\n        float32x4_t v_src2 = vld1q_f32(src2 + i);\n\n        float32x4_t v_diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n        uint32x4_t v_mask = vandq_u32(vcltq_f32(v_diff, v_50), vceqq_f32(v_0, v_0));\n\n        uint32x4_t v_index_mask = vceqq_u32(vandq_u32(v_mask, v_mask), vceqq_u32(v_mask, v_mask));\n        v_index_mask = vandq_u32(v_index_mask, vceqq_u32(v_index_mask, v_index_mask));\n\n        float32x4_t v_mul = vmulq_f32(v_src1, v_src2);\n        float32x4_t v_round_up = vaddq_f32(v_mul, v_1);\n\n        float32x4_t v_result = vbslq_f32(v_index_mask, v_round_up, v_neg1);\n\n        vst1q_f32(dst + i, v_result);\n    }\n\n    for (; i < length; ++i) {\n        if (fabsf(src1[i] - src2[i]) <= 50.0f && i % 2 == 0) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const float32x4_t threshold = vdupq_n_f32(50.0f);\n    const float32x4_t neg_one = vdupq_n_f32(-1.0f);\n    const float32x4_t one = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < length; i += 4) {\n        float32x4_t v_src1 = vld1q_f32(src1 + i);\n        float32x4_t v_src2 = vld1q_f32(src2 + i);\n\n        float32x4_t diff = vabsq_f32(vsubq_f32(v_src1, v_src2));\n        uint32x4_t mask = vandq_u32(vcleq_f32(diff, threshold), vceqq_u32(vandq_u32(vdupq_n_u32(i), vdupq_n_u32(2)), vdupq_n_u32(0)));\n\n        float32x4_t result = vmulq_f32(v_src1, v_src2);\n        result = vaddq_f32(result, vdupq_n_f32(0.5f));\n        result = vmaxq_f32(result, neg_one);\n\n        uint32x4_t mask_neg_one = vmvnq_u32(mask);\n        result = vbslq_f32(mask, result, neg_one);\n\n        vst1q_f32(dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t num_elements = m * n;\n    size_t num_elements_per_iteration = 2; // 2 doubles per iteration (128-bit register)\n\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n\n    for (i = 0; i < num_elements; i += num_elements_per_iteration) {\n        float64x2_t v_mat = vld1q_f64(&mat[i]);\n        float64x2_t v_result = vmulq_f64(v_mat, v_scalar);\n        vst1q_f64(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t size = m * n;\n    size_t i = 0;\n\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n\n    for (; i <= size - 2; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(&mat[i]);\n        float64x2_t result_vec = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(&dst[i], result_vec);\n    }\n\n    if (i < size) {\n        float64x1_t mat_scalar = vld1_f64(&mat[i]);\n        float64x1_t result_scalar = vmul_f64(mat_scalar, vget_low_f64(scalar_vec));\n        vst1_f64(&dst[i], result_scalar);\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t num_elements = m * n;\n    size_t num_elements_simd = num_elements & ~3;\n\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n\n    for (i = 0; i < num_elements_simd; i += 4) {\n        float64x2_t v_mat0 = vld1q_f64(&mat[i]);\n        float64x2_t v_mat1 = vld1q_f64(&mat[i + 2]);\n        float64x2_t v_dst0 = vmulq_f64(v_mat0, v_scalar);\n        float64x2_t v_dst1 = vmulq_f64(v_mat1, v_scalar);\n        vst1q_f64(&dst[i], v_dst0);\n        vst1q_f64(&dst[i + 2], v_dst1);\n    }\n\n    for (i = num_elements_simd; i < num_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t num_elements = m * n;\n    size_t num_elements_simd = num_elements & ~3;\n\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n\n    for (i = 0; i < num_elements_simd; i += 4) {\n        float64x2_t v_mat0 = vld1q_f64(&mat[i]);\n        float64x2_t v_mat1 = vld1q_f64(&mat[i + 2]);\n        float64x2_t v_dst0 = vmulq_f64(v_mat0, v_scalar);\n        float64x2_t v_dst1 = vmulq_f64(v_mat1, v_scalar);\n        vst1q_f64(&dst[i], v_dst0);\n        vst1q_f64(&dst[i + 2], v_dst1);\n    }\n\n    for (i = num_elements_simd; i < num_elements; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    size_t num_elements = m * n;\n    size_t num_elements_per_iter = 2; // 2 doubles per iteration (128-bit register)\n\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n\n    for (i = 0; i < num_elements; i += num_elements_per_iter) {\n        float64x2_t v_mat = vld1q_f64(&mat[i]);\n        float64x2_t v_result = vmulq_f64(v_mat, v_scalar);\n        vst1q_f64(&dst[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_vec = vaddq_f32(sum_vec, vmulq_f32(vec, vec));\n        }\n        float sum[4];\n        vst1q_f32(sum, sum_vec);\n        float row_norm = sqrt(sum[0] + sum[1] + sum[2] + sum[3]);\n\n        float32x4_t norm_vec = vdupq_n_f32(row_norm);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vdivq_f32(vec, norm_vec);\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        float* row = mat + i * n;\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            sum_vec = vfmaq_f32(sum_vec, vec, vec);\n        }\n\n        float sum[4];\n        vst1q_f32(sum, sum_vec);\n        float row_norm = sqrtf(sum[0] + sum[1] + sum[2] + sum[3]);\n\n        float32x4_t norm_vec = vdupq_n_f32(row_norm);\n\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t vec = vld1q_f32(row + j);\n            vec = vdivq_f32(vec, norm_vec);\n            vst1q_f32(row + j, vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_vec = vmlaq_f32(sum_vec, vec, vec);\n        }\n\n        float sum[4];\n        vst1q_f32(sum, sum_vec);\n        float row_sum = sum[0] + sum[1] + sum[2] + sum[3];\n\n        for (; j < n; ++j) {\n            float val = mat[i * n + j];\n            row_sum += val * val;\n        }\n\n        float norm = sqrtf(row_sum);\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n\n        j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vdivq_f32(vec, norm_vec);\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_vec = vaddq_f32(sum_vec, vmulq_f32(vec, vec));\n        }\n\n        float sum = vaddvq_f32(sum_vec);\n\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum);\n\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        j = 0;\n\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vdivq_f32(vec, norm_vec);\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            sum_vec = vaddq_f32(sum_vec, vmulq_f32(vec, vec));\n        }\n\n        float sum = vaddvq_f32(sum_vec);\n\n        for (; j < n; ++j) {\n            sum += mat[i * n + j] * mat[i * n + j];\n        }\n\n        float norm = sqrtf(sum);\n\n        float32x4_t norm_vec = vdupq_n_f32(norm);\n        j = 0;\n\n        for (; j <= n - 4; j += 4) {\n            float32x4_t vec = vld1q_f32(&mat[i * n + j]);\n            vec = vdivq_f32(vec, norm_vec);\n            vst1q_f32(&mat[i * n + j], vec);\n        }\n\n        for (; j < n; ++j) {\n            mat[i * n + j] /= norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                acc = vfmaq_f64(acc, a, b);\n            }\n            float64x2_t result = vrndq_f64(acc);\n            vst1q_f64(&dst[i * p + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                acc = vfmaq_f64(acc, a, b);\n            }\n            float64x2_t rounded = vrndq_f64(acc);\n            vst1q_f64(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                acc = vfmaq_f64(acc, a, b);\n            }\n            float64x2_t rounded = vrndq_f64(acc);\n            vst1q_f64(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                acc = vfmaq_f64(acc, a, b);\n            }\n            float64x2_t rounded = vrndq_f64(acc);\n            vst1q_f64(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k += 2) {\n                float64x2_t a = vld1q_f64(&mat1[i * n + k]);\n                float64x2_t b = vld1q_f64(&mat2[k * p + j]);\n                acc = vfmaq_f64(acc, a, b);\n            }\n            float64x2_t rounded = vrndq_f64(acc);\n            vst1q_f64(&dst[i * p + j], rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            float32x4_t col0 = vtrn1q_f32(row0, row2);\n            float32x4_t col1 = vtrn2q_f32(row0, row2);\n            float32x4_t col2 = vtrn1q_f32(row1, row3);\n            float32x4_t col3 = vtrn2q_f32(row1, row3);\n\n            row0 = vtrn1q_f32(col0, col2);\n            row1 = vtrn2q_f32(col0, col2);\n            row2 = vtrn1q_f32(col1, col3);\n            row3 = vtrn2q_f32(col1, col3);\n\n            float32x4_t round_quarter = vdupq_n_f32(0.25f);\n            row0 = vrndaq_f32(vaddq_f32(row0, round_quarter));\n            row1 = vrndaq_f32(vaddq_f32(row1, round_quarter));\n            row2 = vrndaq_f32(vaddq_f32(row2, round_quarter));\n            row3 = vrndaq_f32(vaddq_f32(row3, round_quarter));\n\n            vst1q_f32(&dst[j * rows + i], row0);\n            vst1q_f32(&dst[(j + 1) * rows + i], row1);\n            vst1q_f32(&dst[(j + 2) * rows + i], row2);\n            vst1q_f32(&dst[(j + 3) * rows + i], row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float quarter = 0.25f;\n    const float half_quarter = 0.125f;\n    const float three_quarters = 0.75f;\n    const float three_half_quarter = 0.625f;\n\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            float32x4_t col0 = vtrn1q_f32(row0, row2);\n            float32x4_t col1 = vtrn2q_f32(row0, row2);\n            float32x4_t col2 = vtrn1q_f32(row1, row3);\n            float32x4_t col3 = vtrn2q_f32(row1, row3);\n\n            row0 = vtrn1q_f32(col0, col2);\n            row1 = vtrn2q_f32(col0, col2);\n            row2 = vtrn1q_f32(col1, col3);\n            row3 = vtrn2q_f32(col1, col3);\n\n            float32x4_t round0 = vaddq_f32(row0, vdupq_n_f32(half_quarter));\n            float32x4_t round1 = vaddq_f32(row1, vdupq_n_f32(half_quarter));\n            float32x4_t round2 = vaddq_f32(row2, vdupq_n_f32(half_quarter));\n            float32x4_t round3 = vaddq_f32(row3, vdupq_n_f32(half_quarter));\n\n            round0 = vrndmq_f32(round0);\n            round1 = vrndmq_f32(round1);\n            round2 = vrndmq_f32(round2);\n            round3 = vrndmq_f32(round3);\n\n            round0 = vmulq_f32(round0, vdupq_n_f32(quarter));\n            round1 = vmulq_f32(round1, vdupq_n_f32(quarter));\n            round2 = vmulq_f32(round2, vdupq_n_f32(quarter));\n            round3 = vmulq_f32(round3, vdupq_n_f32(quarter));\n\n            vst1q_f32(&dst[j * rows + i], round0);\n            vst1q_f32(&dst[(j + 1) * rows + i], round1);\n            vst1q_f32(&dst[(j + 2) * rows + i], round2);\n            vst1q_f32(&dst[(j + 3) * rows + i], round3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float round_factor = 0.25f;\n    const float round_factor_vec = vdupq_n_f32(round_factor);\n\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4_t row0 = vld1q_f32(&src[i * cols + j]);\n            float32x4_t row1 = vld1q_f32(&src[(i + 1) * cols + j]);\n            float32x4_t row2 = vld1q_f32(&src[(i + 2) * cols + j]);\n            float32x4_t row3 = vld1q_f32(&src[(i + 3) * cols + j]);\n\n            float32x4_t col0 = vtrn1q_f32(row0, row1);\n            float32x4_t col1 = vtrn2q_f32(row0, row1);\n            float32x4_t col2 = vtrn1q_f32(row2, row3);\n            float32x4_t col3 = vtrn2q_f32(row2, row3);\n\n            row0 = vtrn1q_f32(col0, col2);\n            row1 = vtrn2q_f32(col0, col2);\n            row2 = vtrn1q_f32(col1, col3);\n            row3 = vtrn2q_f32(col1, col3);\n\n            row0 = vaddq_f32(row0, round_factor_vec);\n            row1 = vaddq_f32(row1, round_factor_vec);\n            row2 = vaddq_f32(row2, round_factor_vec);\n            row3 = vaddq_f32(row3, round_factor_vec);\n\n            row0 = vrndq_f32(row0);\n            row1 = vrndq_f32(row1);\n            row2 = vrndq_f32(row2);\n            row3 = vrndq_f32(row3);\n\n            vst1q_f32(&dst[j * rows + i], row0);\n            vst1q_f32(&dst[(j + 1) * rows + i], row1);\n            vst1q_f32(&dst[(j + 2) * rows + i], row2);\n            vst1q_f32(&dst[(j + 3) * rows + i], row3);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    float32x4_t round_quarter = vdupq_n_f32(0.25f);\n    float32x4_t round_factor = vdupq_n_f32(4.0f);\n\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4x4_t src_data;\n            src_data.val[0] = vld1q_f32(src + i * cols + j);\n            src_data.val[1] = vld1q_f32(src + i * cols + j + 1);\n            src_data.val[2] = vld1q_f32(src + i * cols + j + 2);\n            src_data.val[3] = vld1q_f32(src + i * cols + j + 3);\n\n            float32x4x4_t transposed_data;\n            transposed_data.val[0] = vtrn1q_f32(src_data.val[0], src_data.val[2]);\n            transposed_data.val[1] = vtrn2q_f32(src_data.val[0], src_data.val[2]);\n            transposed_data.val[2] = vtrn1q_f32(src_data.val[1], src_data.val[3]);\n            transposed_data.val[3] = vtrn2q_f32(src_data.val[1], src_data.val[3]);\n\n            float32x4x4_t final_data;\n            final_data.val[0] = vtrn1q_f32(transposed_data.val[0], transposed_data.val[2]);\n            final_data.val[1] = vtrn2q_f32(transposed_data.val[0], transposed_data.val[2]);\n            final_data.val[2] = vtrn1q_f32(transposed_data.val[1], transposed_data.val[3]);\n            final_data.val[3] = vtrn2q_f32(transposed_data.val[1], transposed_data.val[3]);\n\n            final_data.val[0] = vaddq_f32(vmulq_f32(final_data.val[0], round_factor), round_quarter);\n            final_data.val[1] = vaddq_f32(vmulq_f32(final_data.val[1], round_factor), round_quarter);\n            final_data.val[2] = vaddq_f32(vmulq_f32(final_data.val[2], round_factor), round_quarter);\n            final_data.val[3] = vaddq_f32(vmulq_f32(final_data.val[3], round_factor), round_quarter);\n\n            final_data.val[0] = vrndmq_f32(vsubq_f32(final_data.val[0], round_quarter));\n            final_data.val[1] = vrndmq_f32(vsubq_f32(final_data.val[1], round_quarter));\n            final_data.val[2] = vrndmq_f32(vsubq_f32(final_data.val[2], round_quarter));\n            final_data.val[3] = vrndmq_f32(vsubq_f32(final_data.val[3], round_quarter));\n\n            vst1q_f32(dst + j * rows + i, final_data.val[0]);\n            vst1q_f32(dst + j * rows + i + 1, final_data.val[1]);\n            vst1q_f32(dst + j * rows + i + 2, final_data.val[2]);\n            vst1q_f32(dst + j * rows + i + 3, final_data.val[3]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float round_quarter = 0.25f;\n    float32x4_t v_round_quarter = vdupq_n_f32(round_quarter);\n\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            float32x4x4_t src_vec = vld4q_f32(src + i * cols + j);\n\n            float32x4x4_t dst_vec;\n            dst_vec.val[0] = vaddq_f32(src_vec.val[0], v_round_quarter);\n            dst_vec.val[1] = vaddq_f32(src_vec.val[1], v_round_quarter);\n            dst_vec.val[2] = vaddq_f32(src_vec.val[2], v_round_quarter);\n            dst_vec.val[3] = vaddq_f32(src_vec.val[3], v_round_quarter);\n\n            dst_vec.val[0] = vrndq_f32(dst_vec.val[0]);\n            dst_vec.val[1] = vrndq_f32(dst_vec.val[1]);\n            dst_vec.val[2] = vrndq_f32(dst_vec.val[2]);\n            dst_vec.val[3] = vrndq_f32(dst_vec.val[3]);\n\n            vst4q_f32(dst + j * rows + i, dst_vec);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t v_sub = vsubq_f32(v1, v2);\n        float32x4_t v_round = vrndmq_f32(v_sub);\n        vst1q_f32(&dst[i], v_round);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t v_sub = vsubq_f32(v1, v2);\n        float32x4_t v_round = vrndmq_f32(v_sub);\n        vst1q_f32(&dst[i], v_round);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t v_sub = vsubq_f32(v1, v2);\n        float32x4_t v_round = vrndmq_f32(v_sub);\n        vst1q_f32(&dst[i], v_round);\n    }\n\n    for (; i < size; ++i) {\n        dst[i] = nearbyintf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t v_sub = vsubq_f32(v1, v2);\n        float32x4_t v_round = vrndmq_f32(v_sub);\n        vst1q_f32(&dst[i], v_round);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v1 = vld1q_f32(&tensor1[i]);\n        float32x4_t v2 = vld1q_f32(&tensor2[i]);\n        float32x4_t v_sub = vsubq_f32(v1, v2);\n        float32x4_t v_round = vrndmq_f32(v_sub);\n        vst1q_f32(&dst[i], v_round);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += 2) {\n        float64x2_t v1 = vld1q_f64(&mat1[i]);\n        float64x2_t v2 = vld1q_f64(&mat2[i]);\n        float64x2_t v3 = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i], v3);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i, j;\n    for (i = 0; i < m; ++i) {\n        for (j = 0; j < n; j += 2) {\n            float64x2_t v1 = vld1q_f64(&mat1[i * n + j]);\n            float64x2_t v2 = vld1q_f64(&mat2[i * n + j]);\n            float64x2_t result = vmulq_f64(v1, v2);\n            vst1q_f64(&dst[i * n + j], result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t i;\n    for (i = 0; i < m * n; i += 2) {\n        float64x2_t v1 = vld1q_f64(&mat1[i]);\n        float64x2_t v2 = vld1q_f64(&mat2[i]);\n        float64x2_t v3 = vmulq_f64(v1, v2);\n        vst1q_f64(&dst[i], v3);\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t a = vld1q_f32(&mat[i * n + j]);\n            float32x4_t b = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, a, b);\n        }\n        float sum_arr[4];\n        vst1q_f32(sum_arr, sum);\n        float result = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t a = vld1q_f32(&mat[i * n + j]);\n            float32x4_t b = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, a, b);\n        }\n        float sum_arr[4];\n        vst1q_f32(sum_arr, sum);\n        float total = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n        for (; j < n; ++j) {\n            total += mat[i * n + j] * vec[j];\n        }\n        dst[i] = total;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t a = vld1q_f32(&mat[i * n + j]);\n            float32x4_t b = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, a, b);\n        }\n        float sum_arr[4];\n        vst1q_f32(sum_arr, sum);\n        float total = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n        for (; j < n; ++j) {\n            total += mat[i * n + j] * vec[j];\n        }\n        dst[i] = total;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j <= n - 4; j += 4) {\n            float32x4_t a = vld1q_f32(&mat[i * n + j]);\n            float32x4_t b = vld1q_f32(&vec[j]);\n            sum = vmlaq_f32(sum, a, b);\n        }\n        float sum_array[4];\n        vst1q_f32(sum_array, sum);\n        float result = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n        for (; j < n; ++j) {\n            result += mat[i * n + j] * vec[j];\n        }\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float32x4_t sum = vdupq_n_f32(0.0f);\n        for (size_t j = 0; j < n; j += 4) {\n            float32x4_t a = vld1q_f32(&mat[i * n + j]);\n            float32x4_t b = vld1q_f32(&vec[j]);\n            sum = vfmaq_f32(sum, a, b);\n        }\n        dst[i] = vaddvq_f32(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    for (; i <= num_elements - 4; i += 4) {\n        float64x2_t v0 = vld1q_f64(mat + i);\n        float64x2_t v1 = vld1q_f64(mat + i + 2);\n        sum += vaddvq_f64(v0) + vaddvq_f64(v1);\n    }\n\n    for (; i < num_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / num_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    for (; i <= num_elements - 4; i += 4) {\n        float64x2_t v0 = vld1q_f64(mat + i);\n        float64x2_t v1 = vld1q_f64(mat + i + 2);\n        float64x2_t vsum = vaddq_f64(v0, v1);\n        sum += vaddvq_f64(vsum);\n    }\n\n    for (; i < num_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / num_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);\n        sum += vaddvq_f64(vec);\n    }\n\n    // Process remaining elements if any\n    for (; i < num_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / num_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);\n        sum += vaddvq_f64(vec);\n    }\n\n    // Process remaining elements if any\n    for (; i < num_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / num_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t num_elements = m * n;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= num_elements - 2; i += 2) {\n        float64x2_t vec = vld1q_f64(&mat[i]);\n        sum += vaddvq_f64(vec);\n    }\n\n    // Process remaining elements if any\n    for (; i < num_elements; ++i) {\n        sum += mat[i];\n    }\n\n    return sum / num_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        if (cols >= 4) {\n            for (size_t j = 0; j < cols - 3; j += 4) {\n                int32x4_t v1 = vld1q_s32(row + j);\n                int32x4_t v2 = vld1q_s32(row + j + 1);\n\n                uint32x4_t cmp = ascending ? vcgeq_s32(v1, v2) : vcleq_s32(v1, v2);\n                uint32x4_t mask = vandq_u32(cmp, vextq_u32(cmp, cmp, 1));\n\n                if (vmaxvq_u32(mask) == 0) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = 1; j < cols; ++j) {\n            if ((ascending && row[j - 1] > row[j]) || (!ascending && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        if (cols >= 4) {\n            for (size_t j = 0; j < cols - 3; j += 4) {\n                int32x4_t v1 = vld1q_s32(row + j);\n                int32x4_t v2 = vld1q_s32(row + j + 1);\n                int32x4_t v3 = vld1q_s32(row + j + 2);\n                int32x4_t v4 = vld1q_s32(row + j + 3);\n\n                uint32x4_t cmp1 = ascending ? vcltq_s32(v1, v2) : vcgtq_s32(v1, v2);\n                uint32x4_t cmp2 = ascending ? vcltq_s32(v2, v3) : vcgtq_s32(v2, v3);\n                uint32x4_t cmp3 = ascending ? vcltq_s32(v3, v4) : vcgtq_s32(v3, v4);\n\n                if (vaddvq_u32(cmp1) != 4 || vaddvq_u32(cmp2) != 4 || vaddvq_u32(cmp3) != 4) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        if (cols < 4) {\n            for (size_t j = 1; j < cols; ++j) {\n                if ((ascending && row[j-1] > row[j]) || (!ascending && row[j-1] < row[j])) {\n                    return false;\n                }\n            }\n        } else {\n            size_t j = 0;\n            for (; j <= cols - 4; j += 4) {\n                int32x4_t v1 = vld1q_s32(row + j);\n                int32x4_t v2 = vld1q_s32(row + j + 1);\n\n                uint32x4_t cmp = ascending ? vcgtq_s32(v1, v2) : vcltq_s32(v1, v2);\n\n                if (vmaxvq_u32(cmp) != 0) {\n                    return false;\n                }\n            }\n\n            for (; j < cols - 1; ++j) {\n                if ((ascending && row[j] > row[j+1]) || (!ascending && row[j] < row[j+1])) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        if (cols >= 4) {\n            for (size_t j = 0; j < cols - 3; j += 4) {\n                int32x4_t v1 = vld1q_s32(row + j);\n                int32x4_t v2 = vld1q_s32(row + j + 1);\n\n                uint32x4_t cmp = ascending ? vcgeq_s32(v1, v2) : vcleq_s32(v1, v2);\n                uint32x4_t mask = vandq_u32(cmp, vextq_u32(cmp, cmp, 1));\n\n                if (vmaxvq_u32(mask) == 0) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = 1; j < cols; ++j) {\n            if ((ascending && row[j - 1] > row[j]) || (!ascending && row[j - 1] < row[j])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool ascending = directions[i];\n\n        if (cols >= 4) {\n            for (size_t j = 0; j < cols - 3; j += 4) {\n                int32x4_t v1 = vld1q_s32(row + j);\n                int32x4_t v2 = vld1q_s32(row + j + 1);\n                int32x4_t v3 = vld1q_s32(row + j + 2);\n                int32x4_t v4 = vld1q_s32(row + j + 3);\n\n                uint32x4_t cmp1 = ascending ? vcltq_s32(v1, v2) : vcgtq_s32(v1, v2);\n                uint32x4_t cmp2 = ascending ? vcltq_s32(v2, v3) : vcgtq_s32(v2, v3);\n                uint32x4_t cmp3 = ascending ? vcltq_s32(v3, v4) : vcgtq_s32(v3, v4);\n\n                if (vaddvq_u32(cmp1) != 4 || vaddvq_u32(cmp2) != 4 || vaddvq_u32(cmp3) != 4) {\n                    return false;\n                }\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if ((ascending && row[j] > row[j + 1]) || (!ascending && row[j] < row[j + 1])) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    int16x8_t vone = vdupq_n_s16(1);\n    int16x8_t vhalf_base = vdupq_n_s16(base / 2);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(src + i);\n        int16x8_t vquotient = vsrc / vbase;\n        int16x8_t vproduct = vquotient * vbase;\n        int16x8_t vremainder = vsrc - vproduct;\n        uint16x8_t vmask = vremainder >= vhalf_base;\n        int16x8_t vadjust = vdupq_n_s16(0);\n        vadjust = vbslq_s16(vmask, vone, vadjust);\n        int16x8_t vresult = vproduct + vadjust * vbase;\n        vst1q_s16(dst + i, vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    int16x8_t vone = vdupq_n_s16(1);\n    int16x8_t vhalf_base = vdupq_n_s16(base / 2);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vquotient = vsrc / vbase;\n        int16x8_t vproduct = vquotient * vbase;\n        int16x8_t vremainder = vsrc - vproduct;\n        uint16x8_t vmask = vremainder >= vhalf_base;\n        int16x8_t vadjust = vdupq_n_s16(0);\n        vadjust = vbslq_s16(vmask, vone, vadjust);\n        int16x8_t vresult = vproduct + vadjust;\n        vst1q_s16(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    int16x8_t vone = vdupq_n_s16(1);\n    int16x8_t vhalf_base = vdupq_n_s16(base / 2);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vquotient = vsrc / vbase;\n        int16x8_t vproduct = vquotient * vbase;\n        int16x8_t vadjust = vproduct + vhalf_base;\n        uint16x8_t vcmp = vcleq_s16(vsrc, vadjust);\n        int16x8_t vresult = vbslq_s16(vcmp, vproduct, vproduct - vbase);\n        vst1q_s16(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    int16x8_t vone = vdupq_n_s16(1);\n    int16x8_t vhalf_base = vdupq_n_s16(base / 2);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vquotient = vsrc / vbase;\n        int16x8_t vremainder = vsrc % vbase;\n        int16x8_t vadjust = vremainder >= vhalf_base ? vone : vdupq_n_s16(0);\n        int16x8_t vresult = vquotient * vbase + vadjust * vbase;\n        vst1q_s16(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16x8_t vbase = vdupq_n_s16(base);\n    int16x8_t vone = vdupq_n_s16(1);\n    int16x8_t vhalf_base = vdupq_n_s16(base / 2);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t vsrc = vld1q_s16(&src[i]);\n        int16x8_t vquotient = vsrc / vbase;\n        int16x8_t vproduct = vquotient * vbase;\n        int16x8_t vremainder = vsrc - vproduct;\n        uint16x8_t vmask = vremainder >= vhalf_base;\n        vquotient = vquotient + vselq_s16(vmask, vone, vdupq_n_s16(0));\n        int16x8_t vresult = vquotient * vbase;\n        vst1q_s16(&dst[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(vector + j);\n            float64x2_t mat = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(vec, mat);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(vector + j);\n            float64x2_t mat = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(vec, mat);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(vector + j);\n            float64x2_t mat = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(vec, mat);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(vector + j);\n            float64x2_t mat = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(vec, mat);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(vector + j);\n            float64x2_t mat = vld1q_f64(row + j);\n            uint64x2_t cmp = vceqq_f64(vec, mat);\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        count += vaddvq_u8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        count += vaddvq_u8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        count += vaddvq_u8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        count += vaddvq_u8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n\n    for (size_t i = 0; i < total_elements; i += 16) {\n        uint8x16_t vecA = vld1q_u8(A + i);\n        uint8x16_t vecB = vld1q_u8(B + i);\n        uint8x16_t eq = vceqq_u8(vecA, vecB);\n        count += vaddvq_u8(eq);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        int64x2_t vresult = vsubq_s64(vmulq_s64(va, vx), vabsq_s64(vy));\n        vst1q_s64(&y[i], vresult);\n    }\n    if (i < length) {\n        int64x1_t va_single = vdup_n_s64(a);\n        int64x1_t vx_single = vld1_s64(&x[i]);\n        int64x1_t vy_single = vld1_s64(&y[i]);\n        int64x1_t vresult_single = vsub_s64(vmul_s64(va_single, vx_single), vabs_s64(vy_single));\n        vst1_s64(&y[i], vresult_single);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        int64x2_t vresult = vsubq_s64(vmulq_s64(va, vx), vabsq_s64(vy));\n        vst1q_s64(&y[i], vresult);\n    }\n    if (i < length) {\n        int64x1_t va1 = vdup_n_s64(a);\n        int64x1_t vx1 = vld1_s64(&x[i]);\n        int64x1_t vy1 = vld1_s64(&y[i]);\n        int64x1_t vresult1 = vsub_s64(vmul_s64(va1, vx1), vabs_s64(vy1));\n        vst1_s64(&y[i], vresult1);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        int64x2_t vresult = vsubq_s64(vmulq_s64(vx, va), vy);\n        vresult = vabsq_s64(vresult);\n        vst1q_s64(&y[i], vresult);\n    }\n    for (; i < length; ++i) {\n        y[i] = llabs(a * x[i] - y[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i;\n    int64x2_t va = vdupq_n_s64(a);\n    for (i = 0; i < length; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        int64x2_t vax = vmulq_s64(va, vx);\n        int64x2_t vabsy = vabsq_s64(vy);\n        int64x2_t vresult = vsubq_s64(vax, vabsy);\n        vst1q_s64(&y[i], vresult);\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    int64x2_t va = vdupq_n_s64(a);\n    for (; i <= length - 2; i += 2) {\n        int64x2_t vx = vld1q_s64(&x[i]);\n        int64x2_t vy = vld1q_s64(&y[i]);\n        int64x2_t vresult = vsubq_s64(vmulq_s64(va, vx), vabsq_s64(vy));\n        vst1q_s64(&y[i], vresult);\n    }\n    if (i < length) {\n        int64x1_t va1 = vdup_n_s64(a);\n        int64x1_t vx1 = vld1_s64(&x[i]);\n        int64x1_t vy1 = vld1_s64(&y[i]);\n        int64x1_t vresult1 = vsub_s64(vmul_s64(va1, vx1), vabs_s64(vy1));\n        vst1_s64(&y[i], vresult1);\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(INT16_MAX);\n    int16x8_t vmax = vdupq_n_s16(INT16_MIN);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t v = vld1q_s16(vec + i);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_val = vminq_s16(vmin);\n    int16_t max_val = vmaxq_s16(vmax);\n\n    for (size_t i = 0; i < 8; ++i) {\n        min_val = min(min_val, vgetq_lane_s16(vmin, i));\n        max_val = max(max_val, vgetq_lane_s16(vmax, i));\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(INT16_MAX);\n    int16x8_t vmax = vdupq_n_s16(INT16_MIN);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t v = vld1q_s16(vec + i);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_num = vmin[0];\n    int16_t max_num = vmax[0];\n\n    for (int i = 1; i < 8; ++i) {\n        min_num = min(min_num, vmin[i]);\n        max_num = max(max_num, vmax[i]);\n    }\n\n    MinMaxPair result;\n    result.min_num = min_num;\n    result.max_num = max_num;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(INT16_MAX);\n    int16x8_t vmax = vdupq_n_s16(INT16_MIN);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t v = vld1q_s16(&vec[i]);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_val = vminq_s16(vmin);\n    int16_t max_val = vmaxq_s16(vmax);\n\n    for (size_t i = 0; i < 8; ++i) {\n        min_val = min(min_val, vgetq_lane_s16(vmin, i));\n        max_val = max(max_val, vgetq_lane_s16(vmax, i));\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(INT16_MAX);\n    int16x8_t vmax = vdupq_n_s16(INT16_MIN);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t v = vld1q_s16(vec + i);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_val = INT16_MAX;\n    int16_t max_val = INT16_MIN;\n\n    for (int i = 0; i < 8; ++i) {\n        min_val = min(min_val, vgetq_lane_s16(vmin, i));\n        max_val = max(max_val, vgetq_lane_s16(vmax, i));\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(INT16_MAX);\n    int16x8_t vmax = vdupq_n_s16(INT16_MIN);\n\n    for (size_t i = 0; i < length; i += 8) {\n        int16x8_t v = vld1q_s16(vec + i);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16_t min_val = vminq_s16(vmin);\n    int16_t max_val = vmaxq_s16(vmax);\n\n    for (size_t i = 0; i < 8; ++i) {\n        min_val = min(min_val, vgetq_lane_s16(vmin, i));\n        max_val = max(max_val, vgetq_lane_s16(vmax, i));\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            int32x4_t v1 = vld1q_s32(row + j);\n            int32x4_t v2 = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcltq_s32(v1, v2);\n            if (vaddvq_u32(cmp) != 4) {\n                return false;\n            }\n        }\n\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        for (size_t j = 0; j < cols - 4; j += 4) {\n            int32x4_t v1 = vld1q_s32(row + j);\n            int32x4_t v2 = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcltq_s32(v1, v2);\n            if (vaddvq_u32(cmp) != 4) {\n                return false;\n            }\n        }\n        for (size_t j = cols - (cols % 4); j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t v1 = vld1q_s32(row + j);\n            int32x4_t v2 = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcltq_s32(v1, v2);\n\n            if (vaddvq_u32(cmp) != 4) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        for (; j <= cols - 4; j += 4) {\n            int32x4_t v1 = vld1q_s32(row + j);\n            int32x4_t v2 = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcltq_s32(v1, v2);\n\n            if (vaddvq_u32(cmp) != 4) {\n                return false;\n            }\n        }\n\n        for (; j < cols - 1; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        size_t j = 0;\n\n        for (; j + 4 < cols; j += 4) {\n            int32x4_t v1 = vld1q_s32(row + j);\n            int32x4_t v2 = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcltq_s32(v1, v2);\n\n            if (vaddvq_u32(cmp) != 4) {\n                return false;\n            }\n        }\n\n        for (; j + 1 < cols; ++j) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_col; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_row; ++block_col) {\n            const int* current_block = matrix + block_row * block_size * cols + block_col * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t first = vld1q_s32(first_block + i * block_size + j);\n                    int32x4_t current = vld1q_s32(current_block + i * block_size + j);\n                    uint32x4_t result = vceqq_s32(first, current);\n\n                    if (vaddvq_u32(result) != 4) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || block_size > rows || block_size > cols || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_col; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_row; ++block_col) {\n            const int* current_block = matrix + block_row * block_size * cols + block_col * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t first = vld1q_s32(first_block + i * block_size + j);\n                    int32x4_t current = vld1q_s32(current_block + i * block_size + j);\n                    uint32x4_t cmp = vceqq_s32(first, current);\n\n                    if (vaddvq_u32(cmp) != 16) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || block_size > rows || block_size > cols || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_row = rows / block_size;\n    size_t num_blocks_col = cols / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_row; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_col; ++block_col) {\n            const int* first_block = matrix + block_row * block_size * cols + block_col * block_size;\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t first_block_vec = vld1q_s32(first_block + i * cols + j);\n                    for (size_t k = 1; k < num_blocks_row; ++k) {\n                        for (size_t l = 0; l < num_blocks_col; ++l) {\n                            const int* current_block = matrix + k * block_size * cols + l * block_size;\n                            int32x4_t current_block_vec = vld1q_s32(current_block + i * cols + j);\n                            uint32x4_t cmp_result = vceqq_s32(first_block_vec, current_block_vec);\n                            if (vaddvq_u32(cmp_result) != 16) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || block_size > rows || block_size > cols || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_col; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_row; ++block_col) {\n            const int* current_block = matrix + block_row * block_size * cols + block_col * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t first = vld1q_s32(first_block + i * block_size + j);\n                    int32x4_t current = vld1q_s32(current_block + i * block_size + j);\n                    uint32x4_t cmp = vceqq_s32(first, current);\n\n                    if (vaddvq_u32(cmp) != 16) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || block_size > rows || block_size > cols || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t num_blocks_row = cols / block_size;\n    size_t num_blocks_col = rows / block_size;\n\n    for (size_t block_row = 0; block_row < num_blocks_col; ++block_row) {\n        for (size_t block_col = 0; block_col < num_blocks_row; ++block_col) {\n            const int* current_block = matrix + block_row * block_size * cols + block_col * block_size;\n\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; j += 4) {\n                    int32x4_t first = vld1q_s32(first_block + i * block_size + j);\n                    int32x4_t current = vld1q_s32(current_block + i * block_size + j);\n                    uint32x4_t result = vceqq_s32(first, current);\n\n                    if (vaddvq_u32(result) != 4) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block[block_size / 2];\n\n    for (size_t i = 0; i < block_size / 2; ++i) {\n        first_block[i] = vld1q_f64(&vec[i * 2]);\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size / 2; ++i) {\n            float64x2_t current_block = vld1q_f64(&vec[block * block_size + i * 2]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block[i], current_block));\n            uint64x2_t mask = vcgtq_f64(diff, tol_vec);\n            if (vaddvq_u64(mask) != 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || block_size > length || length % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return false;\n    }\n\n    double32x2_t tol_vec = vdupq_n_f64(tolerance);\n\n    for (size_t i = 0; i < block_size; i += 2) {\n        double32x2_t first_block = vld1q_f64(&vec[i]);\n\n        for (size_t block = 1; block < num_blocks; ++block) {\n            double32x2_t current_block = vld1q_f64(&vec[block * block_size + i]);\n            uint64x2_t cmp = vcleq_f64(vabsq_f64(vsubq_f64(first_block, current_block)), tol_vec);\n\n            if (vgetq_lane_u64(cmp, 0) == 0 || vgetq_lane_u64(cmp, 1) == 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block[block_size / 2];\n\n    for (size_t i = 0; i < block_size / 2; ++i) {\n        first_block[i] = vld1q_f64(&vec[i * 2]);\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size / 2; ++i) {\n            float64x2_t current_block = vld1q_f64(&vec[block * block_size + i * 2]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block[i], current_block));\n            uint64x2_t mask = vcgtq_f64(diff, tol_vec);\n            if (vgetq_lane_u64(vreinterpretq_u64_f64(mask), 0) || vgetq_lane_u64(vreinterpretq_u64_f64(mask), 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n    float64x2_t first_block[block_size / 2];\n\n    for (size_t i = 0; i < block_size / 2; ++i) {\n        first_block[i] = vld1q_f64(&vec[i * 2]);\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size / 2; ++i) {\n            float64x2_t current_block = vld1q_f64(&vec[block * block_size + i * 2]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(first_block[i], current_block));\n            uint64x2_t mask = vcgeq_f64(diff, tol_vec);\n            if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || block_size > length) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n\n    for (size_t i = 0; i < num_blocks; ++i) {\n        const double* block_start = vec + i * block_size;\n        float64x2_t block0 = vld1q_f64(block_start);\n\n        for (size_t j = 1; j < block_size / 2; ++j) {\n            float64x2_t block_j = vld1q_f64(block_start + j * 2);\n            float64x2_t diff = vabsq_f64(vsubq_f64(block0, block_j));\n            uint64x2_t cmp = vcgtq_f64(diff, tol_vec);\n            if (vaddvq_u64(cmp) != 0) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t values = vld1q_f64(row + j);\n            sum = vfmaq_f64(sum, values, values);\n        }\n\n        double row_sum = vaddvq_f64(sum);\n        result[i] = row_sum > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t values = vld1q_f64(row + j);\n            sum = vfmaq_f64(sum, values, values);\n        }\n\n        double row_sum = vaddvq_f64(sum);\n        result[i] = row_sum > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        float64x2_t sum = vdupq_n_f64(0.0);\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t values = vld1q_f64(row + j);\n            sum = vfmaq_f64(sum, values, values);\n        }\n\n        double row_sum = vaddvq_f64(sum);\n        result[i] = row_sum > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        float64x2_t sum = vdupq_n_f64(0.0);\n        const double* row = matrix + i * cols;\n\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t values = vld1q_f64(row + j);\n            sum = vfmaq_f64(sum, values, values);\n        }\n\n        double row_sum = vaddvq_f64(sum);\n        result[i] = row_sum > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row = matrix + i * cols;\n        float64x2_t sum = vdupq_n_f64(0.0);\n        for (size_t j = 0; j < cols; j += 2) {\n            float64x2_t values = vld1q_f64(row + j);\n            sum = vaddq_f64(sum, vmulq_f64(values, values));\n        }\n        float64_t norm_squared = vaddvq_f64(sum);\n        result[i] = norm_squared > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(A + i);\n        uint32x4_t vecB = vld1q_u32(B + i);\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        vst1q_u32(C + i, vecC);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i, c);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t vecA = vld1q_u32(A + i);\n        uint32x4_t vecB = vld1q_u32(B + i);\n        uint32x4_t vecC = vorrq_u32(vecA, vecB);\n        vst1q_u32(C + i, vecC);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint32x4_t b = vld1q_u32(B + i);\n        uint32x4_t c = vorrq_u32(a, b);\n        vst1q_u32(C + i, c);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint32x4_t b = vld1q_u32(&B[i]);\n        uint32x4_t result = vorrq_u32(a, b);\n        vst1q_u32(&C[i], result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t vec_a = vld1q_s8(A + i);\n        int8x16_t vec_b = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_b));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_b));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        sum_of_products += vaddvq_s32(sum_prod_low) + vaddvq_s32(sum_prod_high);\n\n        int16x8_t square_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_a));\n        int16x8_t square_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_a));\n\n        int32x4_t sum_square_low = vpaddlq_s16(square_low);\n        int32x4_t sum_square_high = vpaddlq_s16(square_high);\n\n        sum_of_squares += vaddvq_s32(sum_square_low) + vaddvq_s32(sum_square_high);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t vec_a = vld1q_s8(A + i);\n        int8x16_t vec_b = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_b));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_b));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        sum_of_products += vaddvq_s32(sum_prod_low) + vaddvq_s32(sum_prod_high);\n\n        int16x8_t square_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_a));\n        int16x8_t square_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_a));\n\n        int32x4_t sum_square_low = vpaddlq_s16(square_low);\n        int32x4_t sum_square_high = vpaddlq_s16(square_high);\n\n        sum_of_squares += vaddvq_s32(sum_square_low) + vaddvq_s32(sum_square_high);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t vec_a = vld1q_s8(A + i);\n        int8x16_t vec_b = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_b));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_b));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        sum_of_products += vaddvq_s32(sum_prod_low) + vaddvq_s32(sum_prod_high);\n\n        int16x8_t square_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_a));\n        int16x8_t square_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_a));\n\n        int32x4_t sum_square_low = vpaddlq_s16(square_low);\n        int32x4_t sum_square_high = vpaddlq_s16(square_high);\n\n        sum_of_squares += vaddvq_s32(sum_square_low) + vaddvq_s32(sum_square_high);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t vec_a = vld1q_s8(A + i);\n        int8x16_t vec_b = vld1q_s8(B + i);\n\n        int16x8_t prod_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_b));\n        int16x8_t prod_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_b));\n\n        int32x4_t sum_prod_low = vpaddlq_s16(prod_low);\n        int32x4_t sum_prod_high = vpaddlq_s16(prod_high);\n\n        sum_of_products += vaddvq_s32(sum_prod_low) + vaddvq_s32(sum_prod_high);\n\n        int16x8_t square_low = vmull_s8(vget_low_s8(vec_a), vget_low_s8(vec_a));\n        int16x8_t square_high = vmull_s8(vget_high_s8(vec_a), vget_high_s8(vec_a));\n\n        int32x4_t sum_square_low = vpaddlq_s16(square_low);\n        int32x4_t sum_square_high = vpaddlq_s16(square_high);\n\n        sum_of_squares += vaddvq_s32(sum_square_low) + vaddvq_s32(sum_square_high);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_of_squares = 0;\n    int64_t sum_of_products = 0;\n\n    for (size_t i = 0; i < length; i += 16) {\n        int8x16_t vec_a = vld1q_s8(A + i);\n        int8x16_t vec_b = vld1q_s8(B + i);\n\n        int16x8_t vec_a_low = vmovl_s8(vget_low_s8(vec_a));\n        int16x8_t vec_a_high = vmovl_s8(vget_high_s8(vec_a));\n        int16x8_t vec_b_low = vmovl_s8(vget_low_s8(vec_b));\n        int16x8_t vec_b_high = vmovl_s8(vget_high_s8(vec_b));\n\n        int32x4_t vec_a_low_sq = vmull_s16(vget_low_s16(vec_a_low), vget_low_s16(vec_a_low));\n        int32x4_t vec_a_high_sq = vmull_s16(vget_high_s16(vec_a_low), vget_high_s16(vec_a_low));\n        int32x4_t vec_b_low_sq = vmull_s16(vget_low_s16(vec_b_low), vget_low_s16(vec_b_low));\n        int32x4_t vec_b_high_sq = vmull_s16(vget_high_s16(vec_b_low), vget_high_s16(vec_b_low));\n\n        int32x4_t vec_a_low_high_sq = vmull_s16(vget_low_s16(vec_a_high), vget_low_s16(vec_a_high));\n        int32x4_t vec_a_high_high_sq = vmull_s16(vget_high_s16(vec_a_high), vget_high_s16(vec_a_high));\n        int32x4_t vec_b_low_high_sq = vmull_s16(vget_low_s16(vec_b_high), vget_low_s16(vec_b_high));\n        int32x4_t vec_b_high_high_sq = vmull_s16(vget_high_s16(vec_b_high), vget_high_s16(vec_b_high));\n\n        int32x4_t vec_a_sq = vpaddq_s32(vec_a_low_sq, vec_a_high_sq);\n        int32x4_t vec_b_sq = vpaddq_s32(vec_b_low_sq, vec_b_high_sq);\n        int32x4_t vec_a_high_sq = vpaddq_s32(vec_a_low_high_sq, vec_a_high_high_sq);\n        int32x4_t vec_b_high_sq = vpaddq_s32(vec_b_low_high_sq, vec_b_high_high_sq);\n\n        int32x4_t vec_a_sq_sum = vpaddq_s32(vec_a_sq, vec_a_high_sq);\n        int32x4_t vec_b_sq_sum = vpaddq_s32(vec_b_sq, vec_b_high_sq);\n\n        sum_of_squares += vaddvq_s32(vec_a_sq_sum) + vaddvq_s32(vec_b_sq_sum);\n\n        int32x4_t vec_prod_low = vmull_s16(vget_low_s16(vec_a_low), vget_low_s16(vec_b_low));\n        int32x4_t vec_prod_high = vmull_s16(vget_high_s16(vec_a_low), vget_high_s16(vec_b_low));\n        int32x4_t vec_prod_low_high = vmull_s16(vget_low_s16(vec_a_high), vget_low_s16(vec_b_high));\n        int32x4_t vec_prod_high_high = vmull_s16(vget_high_s16(vec_a_high), vget_high_s16(vec_b_high));\n\n        int32x4_t vec_prod_sum = vpaddq_s32(vec_prod_low, vec_prod_high);\n        int32x4_t vec_prod_high_sum = vpaddq_s32(vec_prod_low_high, vec_prod_high_high);\n\n        int32x4_t vec_prod_total = vpaddq_s32(vec_prod_sum, vec_prod_high_sum);\n\n        sum_of_products += vaddvq_s32(vec_prod_total);\n    }\n\n    return sum_of_squares - sum_of_products;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vbicq_u64(a, b);\n        vst1q_u64(&C[i], not_b);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i += 2) {\n        uint64x2_t a = vld1q_u64(&A[i]);\n        uint64x2_t b = vld1q_u64(&B[i]);\n        uint64x2_t not_b = vmvnq_u64(b);\n        uint64x2_t result = vandq_u64(a, not_b);\n        vst1q_u64(&C[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcleq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcleq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vorrq_s8(vandq_s8(both_pos, vdupq_n_s8(1)), vandq_s8(both_neg, vdupq_n_s8(-1)));\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_positive = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_positive = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_negative = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_negative = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_positive = vandq_u8(a_positive, b_positive);\n        uint8x16_t both_negative = vandq_u8(a_negative, b_negative);\n\n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_positive, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_negative, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_neg, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_pos = vcgtq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_pos = vcgtq_s8(b, vdupq_n_s8(0));\n        uint8x16_t a_neg = vcltq_s8(a, vdupq_n_s8(0));\n        uint8x16_t b_neg = vcltq_s8(b, vdupq_n_s8(0));\n\n        uint8x16_t both_pos = vandq_u8(a_pos, b_pos);\n        uint8x16_t both_neg = vandq_u8(a_neg, b_neg);\n\n        int8x16_t result = vdupq_n_s8(0);\n        result = vbslq_s8(both_pos, vdupq_n_s8(1), result);\n        result = vbslq_s8(both_neg, vdupq_n_s8(-1), result);\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 16; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        int8x16_t pos_mask = vandq_s8(a, b);\n        pos_mask = vcltq_s8(pos_mask, vdupq_n_s8(0));\n        pos_mask = vandq_s8(pos_mask, vdupq_n_s8(1));\n\n        int8x16_t neg_mask = vandq_s8(a, b);\n        neg_mask = vcltq_s8(vdupq_n_s8(0), neg_mask);\n        neg_mask = vandq_s8(neg_mask, vdupq_n_s8(-1));\n\n        int8x16_t result = vorrq_s8(pos_mask, neg_mask);\n\n        vst1q_s8(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    for (i = 0; i < midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(&C[i], result);\n    }\n\n    for (i = midpoint; i < length; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(&C[i], result);\n    }\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    for (i = 0; i < midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(&C[i], result);\n    }\n\n    for (i = midpoint; i < length; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(&C[i], result);\n    }\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t i = 0;\n    size_t midpoint = length / 2;\n\n    // Process elements before the midpoint\n    for (; i + 8 <= midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t xor_result = veorq_u16(a, b);\n        uint16x8_t and_result = vandq_u16(a, b);\n        uint16x8_t result = vorrq_u16(xor_result, and_result);\n        vst1q_u16(&C[i], result);\n    }\n\n    // Process the remaining elements before the midpoint\n    for (; i < midpoint; ++i) {\n        C[i] = (A[i] ^ B[i]) | (A[i] & B[i]);\n    }\n\n    // Keep the value in A for the element exactly at the midpoint\n    if (length % 2 == 1) {\n        C[midpoint] = A[midpoint];\n    }\n\n    // Process elements after the midpoint\n    for (i = midpoint + 1; i + 8 <= length; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        vst1q_u16(&C[i], a);\n    }\n\n    // Process the remaining elements after the midpoint\n    for (; i < length; ++i) {\n        C[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    for (i = 0; i < midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t result = veorq_u16(a, b);\n        vst1q_u16(&C[i], result);\n    }\n\n    for (i = midpoint; i < length; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t result = vandq_u16(a, b);\n        vst1q_u16(&C[i], result);\n    }\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    size_t i;\n\n    for (i = 0; i < midpoint; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t xor_result = veorq_u16(a, b);\n        uint16x8_t and_result = vandq_u16(a, b);\n        uint16x8_t result = vorrq_u16(xor_result, and_result);\n        vst1q_u16(&C[i], result);\n    }\n\n    if (midpoint % 8 != 0) {\n        for (; i < midpoint; ++i) {\n            C[i] = (A[i] ^ B[i]) & (A[i] & B[i]);\n        }\n    }\n\n    if (length % 2 != 0) {\n        C[midpoint] = A[midpoint];\n    }\n\n    for (i = midpoint + 1; i < length; i += 8) {\n        uint16x8_t a = vld1q_u16(&A[i]);\n        uint16x8_t b = vld1q_u16(&B[i]);\n        uint16x8_t xor_result = veorq_u16(a, b);\n        uint16x8_t and_result = vandq_u16(a, b);\n        uint16x8_t result = vorrq_u16(xor_result, and_result);\n        vst1q_u16(&C[i], result);\n    }\n\n    if ((length - midpoint - 1) % 8 != 0) {\n        for (; i < length; ++i) {\n            C[i] = (A[i] ^ B[i]) & (A[i] & B[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t mask_true_true = vandq_u32(mask1, mask2);\n        uint32x4_t mask_true_false = vandq_u32(mask1, vnegq_u32(mask2));\n        uint32x4_t mask_false_true = vandq_u32(vnegq_u32(mask1), mask2);\n        uint32x4_t mask_false_false = vandq_u32(vnegq_u32(mask1), vnegq_u32(mask2));\n\n        float32x4_t vec_A = vld1q_f32(&A[i]);\n        float32x4_t vec_B = vld1q_f32(&B[i]);\n        float32x4_t vec_C = vld1q_f32(&C[i]);\n        float32x4_t vec_D = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(mask_true_true, vec_A, vbslq_f32(mask_true_false, vec_B, vbslq_f32(mask_false_true, vec_C, vec_D)));\n\n        vst1q_f32(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t mask_true_true = vandq_u32(mask1, mask2);\n        uint32x4_t mask_true_false = vandq_u32(mask1, vnegq_u32(mask2));\n        uint32x4_t mask_false_true = vandq_u32(vnegq_u32(mask1), mask2);\n        uint32x4_t mask_false_false = vandq_u32(vnegq_u32(mask1), vnegq_u32(mask2));\n\n        float32x4_t vec_A = vld1q_f32(&A[i]);\n        float32x4_t vec_B = vld1q_f32(&B[i]);\n        float32x4_t vec_C = vld1q_f32(&C[i]);\n        float32x4_t vec_D = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(mask_true_true, vec_A, vbslq_f32(mask_true_false, vec_B, vbslq_f32(mask_false_true, vec_C, vec_D)));\n\n        vst1q_f32(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i < total_elements; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t mask1_true = vceqq_u32(mask1, vdupq_n_u32(1));\n        uint32x4_t mask2_true = vceqq_u32(mask2, vdupq_n_u32(1));\n\n        uint32x4_t mask1_false = vbicq_u32(vdupq_n_u32(1), mask1_true);\n        uint32x4_t mask2_false = vbicq_u32(vdupq_n_u32(1), mask2_true);\n\n        uint32x4_t mask_A = vandq_u32(mask1_true, mask2_true);\n        uint32x4_t mask_B = vandq_u32(mask1_true, mask2_false);\n        uint32x4_t mask_C = vandq_u32(mask1_false, mask2_true);\n        uint32x4_t mask_D = vandq_u32(mask1_false, mask2_false);\n\n        float32x4_t vec_A = vld1q_f32(&A[i]);\n        float32x4_t vec_B = vld1q_f32(&B[i]);\n        float32x4_t vec_C = vld1q_f32(&C[i]);\n        float32x4_t vec_D = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(mask_A, vec_A, vbslq_f32(mask_B, vec_B, vbslq_f32(mask_C, vec_C, vec_D)));\n\n        vst1q_f32(&out[i], result);\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i <= total_elements - 4; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t mask1_true = vceqq_u32(mask1, vdupq_n_u32(1));\n        uint32x4_t mask2_true = vceqq_u32(mask2, vdupq_n_u32(1));\n\n        uint32x4_t mask1_false = vbicq_u32(vdupq_n_u32(1), mask1_true);\n        uint32x4_t mask2_false = vbicq_u32(vdupq_n_u32(1), mask2_true);\n\n        uint32x4_t mask1_true_and_mask2_true = vandq_u32(mask1_true, mask2_true);\n        uint32x4_t mask1_true_and_mask2_false = vandq_u32(mask1_true, mask2_false);\n        uint32x4_t mask1_false_and_mask2_true = vandq_u32(mask1_false, mask2_true);\n        uint32x4_t mask1_false_and_mask2_false = vandq_u32(mask1_false, mask2_false);\n\n        float32x4_t vec_A = vld1q_f32(&A[i]);\n        float32x4_t vec_B = vld1q_f32(&B[i]);\n        float32x4_t vec_C = vld1q_f32(&C[i]);\n        float32x4_t vec_D = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(mask1_true_and_mask2_true, vec_A, vbslq_f32(mask1_true_and_mask2_false, vec_B, vbslq_f32(mask1_false_and_mask2_true, vec_C, vec_D)));\n\n        vst1q_f32(&out[i], result);\n    }\n\n    for (; i < total_elements; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        uint32x4_t mask1 = vld1q_u32((const uint32_t*)&cond1[i]);\n        uint32x4_t mask2 = vld1q_u32((const uint32_t*)&cond2[i]);\n\n        uint32x4_t mask = vorrq_u32(vandq_u32(mask1, mask2), vandq_u32(vmvnq_u32(mask1), vmvnq_u32(mask2)));\n\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecC = vld1q_f32(&C[i]);\n        float32x4_t vecD = vld1q_f32(&D[i]);\n\n        float32x4_t result = vbslq_f32(mask, vecA, vecB);\n        result = vbslq_f32(vmvnq_u32(mask), result, vecC);\n        result = vbslq_f32(vmvnq_u32(mask2), result, vecD);\n\n        vst1q_f32(&out[i], result);\n    }\n\n    for (; i < size; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(a));\n        uint8x8_t sum = vpadd_u8(vpadd_u8(count, count), vpadd_u8(count, count));\n        uint8x8_t result = vpadd_u8(sum, sum);\n        vst1_lane_u8(&out[i], result, 0);\n        vst1_lane_u8(&out[i + 1], result, 1);\n        vst1_lane_u8(&out[i + 2], result, 2);\n        vst1_lane_u8(&out[i + 3], result, 3);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t size = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(a));\n        uint8x8_t sum = vpadd_u8(vpadd_u8(count, count), vpadd_u8(count, count));\n        vst1_u8(&out[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(a));\n        uint8x8_t sum = vpadd_u8(count, count);\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        vst1_u8(&out[i], sum);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(a));\n        uint8x8_t count2 = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(a, 8)));\n        uint8x8_t count3 = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(a, 16)));\n        uint8x8_t count4 = vcnt_u8(vreinterpret_u8_u32(vshrq_n_u32(a, 24)));\n        uint8x8_t total_count = vadd_u8(vadd_u8(count, count2), vadd_u8(count3, count4));\n        vst1_u8(&out[i], total_count);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint8x8_t count = vcnt_u8(vreinterpret_u8_u32(a));\n        uint8x8_t sum = vpadd_u8(count, count);\n        sum = vpadd_u8(sum, sum);\n        sum = vpadd_u8(sum, sum);\n        vst1_lane_u8(&out[i], sum, 0);\n        vst1_lane_u8(&out[i + 1], sum, 1);\n        vst1_lane_u8(&out[i + 2], sum, 2);\n        vst1_lane_u8(&out[i + 3], sum, 3);\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t v0 = vdupq_n_s32(0);\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t va = vld1q_s32(&A[i]);\n        uint32x4_t vcond = vceqq_s32(vandq_s32(va, v3), v0);\n        int32x4_t vabs = vabsq_s32(va);\n        int32x4_t vresult = vbslq_s32(vcond, va, vabs);\n        vst1q_s32(&B[i], vresult);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vecA = vld1q_s32(&A[i]);\n        int32x4_t vecB = vecA;\n\n        uint32x4_t mask = vtstq_u32((uint32x4_t)vecA, vdupq_n_u32(3));\n        uint32x4_t absMask = vandq_u32(mask, (uint32x4_t)vabsq_s32(vecA));\n\n        vecB = (int32x4_t)vbslq_u32(mask, absMask, (uint32x4_t)vecA);\n\n        vst1q_s32(&B[i], vecB);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vecA = vld1q_s32(&A[i]);\n        int32x4_t vecB = vecA;\n\n        uint32x4_t mask = vceqq_s32(vandq_s32(vecA, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t absVecA = vabsq_s32(vecA);\n\n        vecB = vbslq_s32(mask, vecB, absVecA);\n\n        vst1q_s32(&B[i], vecB);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    int32x4_t v3 = vdupq_n_s32(3);\n    int32x4_t v0 = vdupq_n_s32(0);\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t va = vld1q_s32(&A[i]);\n        uint32x4_t vcond = vceqq_s32(vandq_s32(va, v3), v0);\n        int32x4_t vabs = vabsq_s32(va);\n        int32x4_t vresult = vbslq_s32(vcond, va, vabs);\n        vst1q_s32(&B[i], vresult);\n    }\n\n    for (; i < size; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t size = rows * cols;\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vecA = vld1q_s32(&A[i]);\n        int32x4_t vecB = vecA;\n\n        uint32x4_t mask = vceqq_s32(vandq_s32(vecA, vdupq_n_s32(3)), vdupq_n_s32(0));\n        int32x4_t absVecA = vabsq_s32(vecA);\n\n        vecB = vbslq_s32(mask, absVecA, vecA);\n\n        vst1q_s32(&B[i], vecB);\n    }\n\n    for (; i < size; ++i) {\n        B[i] = (A[i] % 3 == 0) ? abs(A[i]) : A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32x4_t v_rotate_bits = vdupq_n_u32(rotate_bits);\n    uint32x4_t v_all_ones = vdupq_n_u32(0xF);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&src[i]);\n        uint32x4_t v_low_bits = vandq_u32(v_src, v_all_ones);\n        uint32x4_t v_cond = vceqq_u32(v_low_bits, v_all_ones);\n\n        uint32x4_t v_rotated = vsriq_n_u32(v_src, v_src, rotate_bits);\n        uint32x4_t v_negated = vmvnq_u32(v_src);\n\n        uint32x4_t v_result = vbslq_u32(v_cond, v_rotated, v_negated);\n\n        vst1q_u32(&dst[i], v_result);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits);\n    uint32x4_t mask = vdupq_n_u32(0xF);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t all_ones = vceqq_u32(low_bits, mask);\n\n        uint32x4_t rotated = vorrq_u32(vshlq_u32(src_vec, rotate_bits_vec), vshrq_n_u32(src_vec, 32 - rotate_bits));\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        uint32x4_t result = vbslq_u32(all_ones, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] << rotate_bits) | (src[i] >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i;\n    uint32x4_t v_src, v_dst, v_rotate, v_neg, v_mask, v_cond;\n    uint32x4_t v_ones = vdupq_n_u32(0xF);\n    uint32x4_t v_rotate_bits = vdupq_n_u32(rotate_bits);\n\n    for (i = 0; i < length; i += 4) {\n        v_src = vld1q_u32(&src[i]);\n\n        v_mask = vandq_u32(v_src, v_ones);\n        v_cond = vceqq_u32(v_mask, v_ones);\n\n        v_rotate = vshrq_n_u32(v_src, 32 - rotate_bits);\n        v_rotate = vorrq_u32(v_rotate, vshlq_u32(v_src, v_rotate_bits));\n\n        v_neg = vmvnq_u32(v_src);\n\n        v_dst = vbslq_u32(v_cond, v_rotate, v_neg);\n\n        vst1q_u32(&dst[i], v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32x4_t rotate_bits_vec = vdupq_n_u32(rotate_bits);\n    uint32x4_t mask = vdupq_n_u32(0xF);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint32x4_t low_bits = vandq_u32(src_vec, mask);\n        uint32x4_t condition = vceqq_u32(low_bits, mask);\n\n        uint32x4_t rotated = vsriq_n_u32(vshlq_n_u32(src_vec, rotate_bits), src_vec, 32 - rotate_bits);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n\n        uint32x4_t result = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(&dst[i], result);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t src_val = src[i];\n        if ((src_val & 0xF) == 0xF) {\n            dst[i] = (src_val << rotate_bits) | (src_val >> (32 - rotate_bits));\n        } else {\n            dst[i] = ~src_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    uint32x4_t v_rotate_bits = vdupq_n_u32(rotate_bits);\n    uint32x4_t v_all_ones = vdupq_n_u32(0xF);\n\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t v_src = vld1q_u32(&src[i]);\n        uint32x4_t v_low_bits = vandq_u32(v_src, v_all_ones);\n        uint32x4_t v_cond = vceqq_u32(v_low_bits, v_all_ones);\n\n        uint32x4_t v_rotated = vsriq_n_u32(v_src, v_src, rotate_bits);\n        uint32x4_t v_negated = vmvnq_u32(v_src);\n\n        uint32x4_t v_result = vbslq_u32(v_cond, v_rotated, v_negated);\n        vst1q_u32(&dst[i], v_result);\n    }\n\n    for (; i < length; ++i) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x4_t v_out = vdupq_n_s8(0);\n        v_out = vbslq_s8(v_gt, vdupq_n_s8(1), v_out);\n        v_out = vbslq_s8(v_lt, vdupq_n_s8(-1), v_out);\n\n        vst1q_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vdupq_n_f32(-epsilon);\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t a_vec = vld1q_f32(&A[i]);\n        float32x4_t b_vec = vld1q_f32(&B[i]);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n\n        uint32x4_t gt_mask = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff_vec, neg_epsilon_vec);\n\n        int8x8_t result = vdup_n_s8(0);\n        result = vset_lane_s8(1, result, 0);\n        result = vset_lane_s8(-1, result, 1);\n\n        int8x8_t gt_result = vbsl_s8(gt_mask, result, vdup_n_s8(0));\n        int8x8_t lt_result = vbsl_s8(lt_mask, result, vdup_n_s8(0));\n\n        int8x8_t final_result = vorr_s8(gt_result, lt_result);\n\n        vst1_s8(&out[i], final_result);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t epsilon_vec = vdupq_n_f32(epsilon);\n    float32x4_t neg_epsilon_vec = vdupq_n_f32(-epsilon);\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t a_vec = vld1q_f32(&A[i]);\n        float32x4_t b_vec = vld1q_f32(&B[i]);\n        float32x4_t diff_vec = vsubq_f32(a_vec, b_vec);\n\n        uint32x4_t gt_mask = vcgtq_f32(diff_vec, epsilon_vec);\n        uint32x4_t lt_mask = vcltq_f32(diff_vec, neg_epsilon_vec);\n\n        int8x8_t result = vdup_n_s8(0);\n        result = vset_lane_s8(1, result, 0);\n        result = vset_lane_s8(-1, result, 1);\n\n        int8x8_t gt_result = vbsl_s8(gt_mask, result, vdup_n_s8(0));\n        int8x8_t lt_result = vbsl_s8(lt_mask, result, vdup_n_s8(0));\n\n        int8x8_t final_result = vorr_s8(gt_result, lt_result);\n        vst1_s8(&out[i], final_result);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v_a = vld1q_f32(&A[i]);\n        float32x4_t v_b = vld1q_f32(&B[i]);\n\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x4_t v_out = vdupq_n_s8(0);\n        v_out = vbslq_s8(v_gt, vdupq_n_s8(1), v_out);\n        v_out = vbslq_s8(v_lt, vdupq_n_s8(-1), v_out);\n\n        vst1q_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    size_t i = 0;\n    float32x4_t v_epsilon = vdupq_n_f32(epsilon);\n    float32x4_t v_neg_epsilon = vdupq_n_f32(-epsilon);\n\n    for (; i <= length - 4; i += 4) {\n        float32x4_t v_A = vld1q_f32(&A[i]);\n        float32x4_t v_B = vld1q_f32(&B[i]);\n        float32x4_t v_diff = vsubq_f32(v_A, v_B);\n\n        uint32x4_t v_gt = vcgtq_f32(v_diff, v_epsilon);\n        uint32x4_t v_lt = vcltq_f32(v_diff, v_neg_epsilon);\n\n        int8x8_t v_out = vcombine_s8(\n            vmovn_s16(vcombine_s16(\n                vmovn_s32(vreinterpretq_s32_u32(v_gt)),\n                vmovn_s32(vreinterpretq_s32_u32(v_lt))\n            )),\n            vdup_n_s8(0)\n        );\n\n        vst1_s8(&out[i], v_out);\n    }\n\n    for (; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon) {\n            out[i] = 1;\n        } else if (diff < -epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vA = vld1q_f32(A + i);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vB = vmaxq_s32(vB, vdupq_n_s32(INT32_MIN));\n        vB = vminq_s32(vB, vdupq_n_s32(INT32_MAX));\n        vst1q_s32(B + i, vB);\n    }\n    for (; i < size; ++i) {\n        int32_t val = (int32_t)A[i];\n        if (val > INT32_MAX) val = INT32_MAX;\n        if (val < INT32_MIN) val = INT32_MIN;\n        B[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vB = vmaxq_s32(vB, vdupq_n_s32(INT32_MIN));\n        vB = vminq_s32(vB, vdupq_n_s32(INT32_MAX));\n        vst1q_s32(&B[i], vB);\n    }\n    for (; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n        if (B[i] > INT32_MAX) B[i] = INT32_MAX;\n        if (B[i] < INT32_MIN) B[i] = INT32_MIN;\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vA = vld1q_f32(A + i);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vB = vmaxq_s32(vB, vdupq_n_s32(INT32_MIN));\n        vB = vminq_s32(vB, vdupq_n_s32(INT32_MAX));\n        vst1q_s32(B + i, vB);\n    }\n    for (; i < size; ++i) {\n        int32_t val = (int32_t)A[i];\n        if (val > INT32_MAX) val = INT32_MAX;\n        if (val < INT32_MIN) val = INT32_MIN;\n        B[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    float32x4_t vf_min = vdupq_n_f32((float)INT32_MIN);\n    float32x4_t vf_max = vdupq_n_f32((float)INT32_MAX);\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vf = vld1q_f32(&A[i]);\n        int32x4_t vi = vcvtq_s32_f32(vf);\n        uint32x4_t vf_lt_min = vcltq_f32(vf, vf_min);\n        uint32x4_t vf_gt_max = vcgtq_f32(vf, vf_max);\n        vi = vbslq_s32(vf_lt_min, vdupq_n_s32(INT32_MIN), vi);\n        vi = vbslq_s32(vf_gt_max, vdupq_n_s32(INT32_MAX), vi);\n        vst1q_s32(&B[i], vi);\n    }\n\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vA = vld1q_f32(&A[i]);\n        int32x4_t vB = vcvtq_s32_f32(vA);\n        vB = vmaxq_s32(vB, vdupq_n_s32(INT32_MIN));\n        vB = vminq_s32(vB, vdupq_n_s32(INT32_MAX));\n        vst1q_s32(&B[i], vB);\n    }\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, scale_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, scale_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, scale_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32((float)scale);\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, scale_vec);\n        vst1q_f32(&B[i], b_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float32x4_t scale_vec = vdupq_n_f32(static_cast<float>(scale));\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&A[i]);\n        float32x4_t vec_b = vcvtq_f32_s32(vec_a);\n        vec_b = vmulq_f32(vec_b, scale_vec);\n        vst1q_f32(&B[i], vec_b);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtq_s32_f32(div_result);\n        vst1q_s32(&C[i], rounded_result);\n    }\n    for (; i < size; ++i) {\n        C[i] = (int32_t)(A[i] / B[i] + 0.5f);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecC = vdivq_f32(vecA, vecB);\n        int32x4_t vecD = vcvtq_s32_f32(vecC);\n        vst1q_s32(&C[i], vecD);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecC = vdivq_f32(vecA, vecB);\n        int32x4_t vecD = vcvtq_s32_f32(vecC);\n        vst1q_s32(&C[i], vecD);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t a = vld1q_f32(&A[i]);\n        float32x4_t b = vld1q_f32(&B[i]);\n        float32x4_t div_result = vdivq_f32(a, b);\n        int32x4_t rounded_result = vcvtq_s32_f32(div_result);\n        vst1q_s32(&C[i], rounded_result);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t vecA = vld1q_f32(&A[i]);\n        float32x4_t vecB = vld1q_f32(&B[i]);\n        float32x4_t vecC = vdivq_f32(vecA, vecB);\n        int32x4_t vecD = vcvtq_s32_f32(vecC);\n        vst1q_s32(&C[i], vecD);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    size_t i = 0;\n    float32x4_t v_flt_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_neg_flt_max = vdupq_n_f32(-FLT_MAX);\n\n    for (; i <= size - 4; i += 4) {\n        float64x2_t v_a0 = vld1q_f64(A + i);\n        float64x2_t v_a1 = vld1q_f64(A + i + 2);\n\n        float32x4_t v_b = vcombine_f32(vcvt_f32_f64(v_a0), vcvt_f32_f64(v_a1));\n\n        v_b = vmaxq_f32(v_b, v_neg_flt_max);\n        v_b = vminq_f32(v_b, v_flt_max);\n\n        vst1q_f32(B + i, v_b);\n    }\n\n    for (; i < size; ++i) {\n        float val = (float)A[i];\n        if (val > FLT_MAX) {\n            val = FLT_MAX;\n        } else if (val < -FLT_MAX) {\n            val = -FLT_MAX;\n        }\n        B[i] = val;\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    float32x4_t v_flt_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_neg_flt_max = vdupq_n_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float64x2_t v_a0 = vld1q_f64(A + i);\n        float64x2_t v_a1 = vld1q_f64(A + i + 2);\n\n        float32x4_t v_b0 = vcvt_f32_f64(v_a0);\n        float32x4_t v_b1 = vcvt_f32_f64(v_a1);\n\n        v_b0 = vmaxq_f32(v_b0, v_neg_flt_max);\n        v_b0 = vminq_f32(v_b0, v_flt_max);\n\n        v_b1 = vmaxq_f32(v_b1, v_neg_flt_max);\n        v_b1 = vminq_f32(v_b1, v_flt_max);\n\n        vst1q_f32(B + i, v_b0);\n        vst1q_f32(B + i + 2, v_b1);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x4_t max_val = vdupq_n_f32(FLT_MAX);\n    const float32x4_t min_val = vdupq_n_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t result;\n\n        if (i + 3 < size) {\n            float64x2_t a0 = vld1q_f64(A + i);\n            float64x2_t a1 = vld1q_f64(A + i + 2);\n\n            float32x4_t b0 = vcvt_f32_f64(a0);\n            float32x4_t b1 = vcvt_f32_f64(a1);\n\n            result = vcombine_f32(vget_low_f32(b0), vget_low_f32(b1));\n        } else {\n            float64x2_t a0 = vld1q_f64(A + i);\n            float32x4_t b0 = vcvt_f32_f64(a0);\n\n            if (i + 2 < size) {\n                float64x2_t a1 = vld1q_f64(A + i + 2);\n                float32x4_t b1 = vcvt_f32_f64(a1);\n                result = vcombine_f32(vget_low_f32(b0), vget_low_f32(b1));\n            } else {\n                result = b0;\n            }\n        }\n\n        result = vmaxq_f32(result, min_val);\n        result = vminq_f32(result, max_val);\n\n        vst1q_f32(B + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    float32x4_t v_flt_max = vdupq_n_f32(FLT_MAX);\n    float32x4_t v_neg_flt_max = vdupq_n_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float64x2_t v_a0 = vld1q_f64(A + i);\n        float64x2_t v_a1 = vld1q_f64(A + i + 2);\n\n        float32x4_t v_b = vcombine_f32(vcvt_f32_f64(v_a0), vcvt_f32_f64(v_a1));\n\n        v_b = vmaxq_f32(v_b, v_neg_flt_max);\n        v_b = vminq_f32(v_b, v_flt_max);\n\n        vst1q_f32(B + i, v_b);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const float32x4_t max_val = vdupq_n_f32(FLT_MAX);\n    const float32x4_t min_val = vdupq_n_f32(-FLT_MAX);\n\n    for (size_t i = 0; i < size; i += 2) {\n        float64x2_t a = vld1q_f64(&A[i]);\n        float32x4_t b = vcvt_f32_f64(a);\n\n        b = vmaxq_f32(b, min_val);\n        b = vminq_f32(b, max_val);\n\n        vst1q_f32(&B[i], b);\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t a = vld1q_s16(&A[i]);\n        int32x4_t b_low = vmovl_s16(vget_low_s16(a));\n        int32x4_t b_high = vmovl_s16(vget_high_s16(a));\n        vst1q_s32(&B[i], b_low);\n        vst1q_s32(&B[i + 4], b_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t a = vld1q_s16(A + i);\n        int32x4_t b_low = vmovl_s16(vget_low_s16(a));\n        int32x4_t b_high = vmovl_s16(vget_high_s16(a));\n        vst1q_s32(B + i, b_low);\n        vst1q_s32(B + i + 4, b_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t a = vld1q_s16(&A[i]);\n        int32x4_t b_low = vmovl_s16(vget_low_s16(a));\n        int32x4_t b_high = vmovl_s16(vget_high_s16(a));\n        vst1q_s32(&B[i], b_low);\n        vst1q_s32(&B[i + 4], b_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 8; i += 8) {\n        int16x8_t a = vld1q_s16(&A[i]);\n        int32x4_t b_low = vmovl_s16(vget_low_s16(a));\n        int32x4_t b_high = vmovl_s16(vget_high_s16(a));\n        vst1q_s32(&B[i], b_low);\n        vst1q_s32(&B[i + 4], b_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i;\n    for (i = 0; i <= size - 8; i += 8) {\n        int16x8_t a = vld1q_s16(&A[i]);\n        int32x4_t b_low = vmovl_s16(vget_low_s16(a));\n        int32x4_t b_high = vmovl_s16(vget_high_s16(a));\n        vst1q_s32(&B[i], b_low);\n        vst1q_s32(&B[i + 4], b_high);\n    }\n    for (; i < size; ++i) {\n        B[i] = A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n    float32x4_t v_max_val = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n    int32x4_t v_zero_int = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v_A = vld1q_f32(&A[i]);\n        int32x4_t v_control = vld1q_s32(&control[i]);\n\n        uint32x4_t v_mask = vcgtq_s32(v_control, v_zero_int);\n\n        float32x4_t v_diff = vsubq_f32(v_A, v_min_val);\n        float32x4_t v_range = vsubq_f32(v_max_val, v_min_val);\n        float32x4_t v_normalized = vdivq_f32(v_diff, v_range);\n\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(v_mask, v_normalized, v_A);\n\n        vst1q_f32(&B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n    float32x4_t v_max_val = vdupq_n_f32(max_val);\n    float32x4_t v_range = vsubq_f32(v_max_val, v_min_val);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v_A = vld1q_f32(&A[i]);\n        int32x4_t v_control = vld1q_s32(&control[i]);\n\n        uint32x4_t v_mask = vcgtq_s32(v_control, vdupq_n_s32(0));\n        float32x4_t v_normalized = vdivq_f32(vsubq_f32(v_A, v_min_val), v_range);\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(v_mask, v_normalized, v_A);\n        vst1q_f32(&B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n    float32x4_t v_max_val = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t v_control = vld1q_s32(&control[i]);\n        float32x4_t v_A = vld1q_f32(&A[i]);\n\n        uint32x4_t v_mask = vcgtq_s32(v_control, vdupq_n_s32(0));\n        float32x4_t v_normalized = vsubq_f32(v_A, v_min_val);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max_val, v_min_val));\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(v_mask, v_normalized, v_A);\n        vst1q_f32(&B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n    float32x4_t v_max_val = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t v_control = vld1q_s32(&control[i]);\n        float32x4_t v_A = vld1q_f32(&A[i]);\n\n        uint32x4_t v_mask = vcgtq_s32(v_control, vdupq_n_s32(0));\n\n        float32x4_t v_normalized = vsubq_f32(v_A, v_min_val);\n        v_normalized = vdivq_f32(v_normalized, vsubq_f32(v_max_val, v_min_val));\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(v_mask, v_normalized, v_A);\n\n        vst1q_f32(&B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float32x4_t v_min_val = vdupq_n_f32(min_val);\n    float32x4_t v_max_val = vdupq_n_f32(max_val);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n    int32x4_t v_zero_int = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        float32x4_t v_A = vld1q_f32(&A[i]);\n        int32x4_t v_control = vld1q_s32(&control[i]);\n\n        uint32x4_t v_mask = vcgtq_s32(v_control, v_zero_int);\n\n        float32x4_t v_diff = vsubq_f32(v_A, v_min_val);\n        float32x4_t v_range = vsubq_f32(v_max_val, v_min_val);\n        float32x4_t v_normalized = vdivq_f32(v_diff, v_range);\n\n        v_normalized = vmaxq_f32(v_normalized, v_zero);\n        v_normalized = vminq_f32(v_normalized, v_one);\n\n        float32x4_t v_result = vbslq_f32(v_mask, v_normalized, v_A);\n\n        vst1q_f32(&B[i], v_result);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint16x4_t high_bits = vshrn_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(&B[i], sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint16x4_t high_bits = vshrn_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(&B[i], sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint16x4_t high_bits = vshrn_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(&B[i], sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(A + i);\n        uint16x4_t high_bits = vshrn_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(B + i, sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        uint16x4_t high_16_bits = vshrn_n_u32(a, 16);\n        float32x4_t f = vcvtq_f32_u32(high_16_bits);\n        float32x4_t sqrt_f = vsqrtq_f32(f);\n        vst1q_f32(&B[i], sqrt_f);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        float32x4_t b = vreinterpretq_f32_u32(a);\n        vst1q_f32(&B[i], b);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        float32x4_t b = vreinterpretq_f32_u32(a);\n        vst1q_f32(&B[i], b);\n    }\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        float32x4_t b = vreinterpretq_f32_u32(a);\n        vst1q_f32(&B[i], b);\n    }\n    for (; i < size; ++i) {\n        B[i] = *(const float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        float32x4_t b = vreinterpretq_f32_u32(a);\n        vst1q_f32(&B[i], b);\n    }\n    for (; i < size; ++i) {\n        B[i] = *(float*)&A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i += 4) {\n        uint32x4_t a = vld1q_u32(&A[i]);\n        float32x4_t b = vreinterpretq_f32_u32(a);\n        vst1q_f32(&B[i], b);\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n\n    // Handle the first element\n    diff[0] = 0.0f;\n    i = 1;\n\n    // Process the rest of the elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        // Load 4 elements from A and cond\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        int32x4_t a_prev_vec = vld1q_s32(&A[i - 1]);\n        uint32x4_t cond_vec = vld1q_u32((const uint32_t*)&cond[i]);\n\n        // Compute the difference\n        int32x4_t diff_vec = vsubq_s32(a_vec, a_prev_vec);\n\n        // Convert the difference to float\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_vec);\n\n        // Set diff to 0.0f where cond is false\n        uint32x4_t mask = vceqq_u32(cond_vec, vdupq_n_u32(0));\n        diff_float_vec = vbslq_f32(mask, vdupq_n_f32(0.0f), diff_float_vec);\n\n        // Store the result\n        vst1q_f32(&diff[i], diff_float_vec);\n    }\n\n    // Handle the remaining elements\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    const size_t unroll_factor = 4;\n\n    // Handle the first element\n    diff[0] = 0.0f;\n    i = 1;\n\n    // Process the rest of the elements\n    for (; i <= size - unroll_factor; i += unroll_factor) {\n        int32x4_t a_vec = vld1q_s32(&A[i]);\n        int32x4_t a_prev_vec = vld1q_s32(&A[i - 1]);\n\n        int32x4_t diff_vec = vsubq_s32(a_vec, a_prev_vec);\n\n        uint8x16_t cond_vec = vld1q_u8((const uint8_t*)&cond[i]);\n        uint8x16_t mask = vmovl_u8(vget_low_u8(cond_vec));\n        uint8x16_t mask_high = vmovl_high_u8(cond_vec);\n\n        uint32x4_t mask_low = vmovl_u16(vget_low_u16(mask));\n        uint32x4_t mask_high = vmovl_high_u16(mask);\n        uint32x4_t mask_low_high = vmovl_u16(vget_high_u16(mask_high));\n\n        float32x4_t diff_float_vec = vcvtq_f32_s32(diff_vec);\n        float32x4_t zero_vec = vdupq_n_f32(0.0f);\n\n        float32x4_t result_low = vbslq_f32(mask_low, diff_float_vec, zero_vec);\n        float32x4_t result_high = vbslq_f32(mask_low_high, diff_float_vec, zero_vec);\n\n        vst1q_f32(&diff[i], result_low);\n        vst1q_f32(&diff[i + 4], result_high);\n    }\n\n    // Handle the remaining elements\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    int32x4_t vA_prev = vdupq_n_s32(A[0]);\n    int32x4_t vA_curr;\n    uint32x4_t vCond;\n    float32x4_t vDiff;\n    float32x4_t vZero = vdupq_n_f32(0.0f);\n\n    for (; i <= size - 4; i += 4) {\n        vA_curr = vld1q_s32(&A[i]);\n        vCond = vld1q_u32((const uint32_t*)&cond[i]);\n\n        int32x4_t vDiff_int = vsubq_s32(vA_curr, vA_prev);\n        vDiff = vcvtq_f32_s32(vDiff_int);\n\n        vDiff = vbslq_f32(vCond, vDiff, vZero);\n\n        vst1q_f32(&diff[i], vDiff);\n\n        vA_prev = vA_curr;\n    }\n\n    diff[0] = 0.0f;\n\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n\n    diff[0] = 0.0f;\n\n    for (size_t i = 1; i < size; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n\n        uint8x16_t c = vld1q_u8((const uint8_t*)&cond[i]);\n        uint8x16_t c_prev = vld1q_u8((const uint8_t*)&cond[i - 1]);\n\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n\n        uint8x16_t mask = vandq_u8(c, c_prev);\n        mask = vzip1q_u8(mask, mask);\n\n        int32x4_t masked_diff = vreinterpretq_s32_u8(vandq_u8(vreinterpretq_u8_s32(diff_int), mask));\n\n        float32x4_t diff_float = vcvtq_f32_s32(masked_diff);\n\n        vst1q_f32(&diff[i], diff_float);\n    }\n\n    for (size_t i = size - (size % 4); i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    size_t i = 0;\n    size_t simd_size = size / 4 * 4;\n\n    // Handle the first element\n    diff[0] = 0.0f;\n    i = 1;\n\n    // Process elements in chunks of 4\n    for (; i < simd_size; i += 4) {\n        int32x4_t a = vld1q_s32(&A[i]);\n        int32x4_t a_prev = vld1q_s32(&A[i - 1]);\n        int32x4_t diff_int = vsubq_s32(a, a_prev);\n\n        uint8x16_t cond_vec = vld1q_u8((const uint8_t*)&cond[i]);\n        uint8x16_t cond_mask = vmovl_u8(vget_low_u8(cond_vec));\n        cond_mask = vcombine_u8(cond_mask, vmovl_u8(vget_high_u8(cond_vec)));\n\n        uint32x4_t cond_mask_32 = vmovl_u16(vget_low_u16(cond_mask));\n        cond_mask_32 = vcombine_u32(cond_mask_32, vmovl_u16(vget_high_u16(cond_mask)));\n\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n        float32x4_t zero = vdupq_n_f32(0.0f);\n\n        float32x4_t result = vbslq_f32(cond_mask_32, diff_float, zero);\n        vst1q_f32(&diff[i], result);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = static_cast<float>(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n    uint64x2_t ones_vec = vdupq_n_u64(0xFFFFFFFF00000000);\n\n    for (; i <= length - 4; i += 4) {\n        src_vec = vld1q_u32(src + i);\n        dst_vec = vreinterpretq_u64_u32(src_vec);\n        dst_vec = vorrq_u64(dst_vec, ones_vec);\n        vst1q_u64(dst + i, dst_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n\n    for (; i <= length - 4; i += 4) {\n        src_vec = vld1q_u32(&src[i]);\n        dst_vec = vreinterpretq_u64_u32(vcombine_u32(src_vec, ones));\n        vst1q_u64(&dst[i], dst_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(&src[i]);\n        uint64x2_t dst_vec0 = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t dst_vec1 = vmovl_u32(vget_high_u32(src_vec));\n        dst_vec0 = vorrq_u64(dst_vec0, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        dst_vec1 = vorrq_u64(dst_vec1, vdupq_n_u64(0xFFFFFFFF00000000ULL));\n        vst1q_u64(&dst[i], dst_vec0);\n        vst1q_u64(&dst[i + 2], dst_vec1);\n    }\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n    uint32x4_t ones = vdupq_n_u32(0xFFFFFFFF);\n\n    for (; i <= length - 4; i += 4) {\n        src_vec = vld1q_u32(&src[i]);\n        dst_vec = vreinterpretq_u64_u32(vcombine_u32(src_vec, ones));\n        vst1q_u64(&dst[i], dst_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i]) | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    uint32x4_t src_vec;\n    uint64x2_t dst_vec;\n    uint64x2_t ones = vdupq_n_u64(0xFFFFFFFF00000000);\n\n    for (; i <= length - 4; i += 4) {\n        src_vec = vld1q_u32(src + i);\n        dst_vec = vreinterpretq_u64_u32(vmovl_u32(vget_low_u32(src_vec)));\n        dst_vec = vorrq_u64(dst_vec, ones);\n        vst1q_u64(dst + i, dst_vec);\n\n        dst_vec = vreinterpretq_u64_u32(vmovl_u32(vget_high_u32(src_vec)));\n        dst_vec = vorrq_u64(dst_vec, ones);\n        vst1q_u64(dst + i + 2, dst_vec);\n    }\n\n    for (; i < length; ++i) {\n        dst[i] = ((uint64_t)src[i] & 0xFFFFFFFF) | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx32 = vmovl_s16(vget_low_s16(idx));\n\n        float64x2_t v1 = vld1q_f64(&vec[idx32[0]]);\n        float64x2_t v2 = vld1q_f64(&vec[idx32[1]]);\n\n        float64x2_t sum_vec = vaddq_f64(v1, v2);\n        sum += vaddvq_f64(sum_vec);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx32 = vmovl_s16(vget_low_s16(idx));\n\n        float64x2_t v1 = vld1q_f64(&vec[idx32[0]]);\n        float64x2_t v2 = vld1q_f64(&vec[idx32[1]]);\n\n        float64x2_t sum_vec = vaddq_f64(v1, v2);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx32 = vmovl_s16(vget_low_s16(idx));\n        uint64x2_t idx64 = vmovl_u32(vget_low_u32(idx32));\n\n        float64x2_t val = vld2q_f64(&vec[0])[vgetq_lane_u64(idx64, 0)];\n        sum += vgetq_lane_f64(val, 0) + vgetq_lane_f64(val, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    for (; i <= length - 4; i += 4) {\n        int16x4_t indices = vld1_s16(&index[i]);\n        uint32x4_t uindices = vmovl_u16(vreinterpret_s16_u16(indices));\n        float64x2_t v0 = vld1q_f64(&vec[indices[0]]);\n        float64x2_t v1 = vld1q_f64(&vec[indices[2]]);\n        float64x2_t v2 = vld1q_f64(&vec[indices[1]]);\n        float64x2_t v3 = vld1q_f64(&vec[indices[3]]);\n        float64x2_t sum0 = vaddq_f64(v0, v2);\n        float64x2_t sum1 = vaddq_f64(v1, v3);\n        float64x2_t sum2 = vaddq_f64(sum0, sum1);\n        sum += vaddvq_f64(sum2);\n    }\n\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    size_t i = 0;\n\n    // Process 2 elements at a time using Neon intrinsics\n    for (; i <= length - 2; i += 2) {\n        int16x4_t idx = vld1_s16(&index[i]);\n        int32x2_t idx32 = vmovl_s16(vget_low_s16(idx));\n\n        float64x2_t val1 = vld1q_f64(&vec[idx32[0]]);\n        float64x2_t val2 = vld1q_f64(&vec[idx32[1]]);\n\n        float64x2_t sum_vec = vaddq_f64(val1, val2);\n        sum += vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    }\n\n    // Process remaining elements\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    double32x2_t input_val = vdup_n_f64(input[input_index]);\n                    double32x2_t kernel_val = vdup_n_f64(kernel[kernel_index]);\n                    sum = vadd_f64(sum, vmul_f64(input_val, kernel_val));\n                }\n            }\n            double sum_scalar = vget_lane_f64(sum, 0) + vget_lane_f64(sum, 1);\n            output[i * output_size + j] = sum_scalar > 0 ? sum_scalar : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t output_index = 0;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    double32x2_t input_val = vld1_f64(&input[input_index]);\n                    double32x2_t kernel_val = vld1_f64(&kernel[kernel_index]);\n\n                    sum = vfma_f64(sum, input_val, kernel_val);\n                }\n            }\n\n            double sum_scalar[2];\n            vst1_f64(sum_scalar, sum);\n            double result = sum_scalar[0] + sum_scalar[1];\n            output[output_index++] = result > 0 ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t output_index = 0;\n\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double32x2_t sum = vdup_n_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n\n                    double32x2_t input_val = vld1_f64(&input[input_index]);\n                    double32x2_t kernel_val = vld1_f64(&kernel[kernel_index]);\n\n                    sum = vadd_f64(sum, vmul_f64(input_val, kernel_val));\n                }\n            }\n\n            double result = vget_lane_f64(sum, 0) + vget_lane_f64(sum, 1);\n            output[output_index++] = result > 0 ? result : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    const int size = numbers.size();\n    const int step = 4; // Assuming 4 elements per SIMD register (float64x2_t)\n\n    float64x2_t thresh_vec = vdupq_n_f64(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float64x2_t vec1 = vdupq_n_f64(numbers[i]);\n\n        for (int j = i + 1; j < size; j += step) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n            float64x2_t diff = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t cmp = vcltq_f64(diff, thresh_vec);\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    const int size = numbers.size();\n    const int step = 4; // Assuming 4 elements per SIMD register (float64x2_t)\n\n    for (int i = 0; i < size; i += step) {\n        float64x2_t v1 = vld1q_f64(&numbers[i]);\n        for (int j = i + step; j < size; j += step) {\n            float64x2_t v2 = vld1q_f64(&numbers[j]);\n            float64x2_t diff = vsubq_f64(v1, v2);\n            float64x2_t abs_diff = vabsq_f64(diff);\n            uint64x2_t cmp = vcltq_f64(abs_diff, vdupq_n_f64(threshold));\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    const int size = numbers.size();\n    const int step = 4; // Assuming AVX2-like processing with 4 doubles per register\n\n    float32x4_t v_threshold = vdupq_n_f32(threshold);\n\n    for (int i = 0; i < size; ++i) {\n        float32x4_t v_a = vdupq_n_f32(numbers[i]);\n\n        for (int j = i + 1; j < size; j += step) {\n            float32x4_t v_b = vld1q_f32(&numbers[j]);\n            float32x4_t v_diff = vabsq_f32(vsubq_f32(v_a, v_b));\n            uint32x4_t v_cmp = vcltq_f32(v_diff, v_threshold);\n\n            if (vanyq_u32(v_cmp)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double>& numbers, double threshold) {\n    const int size = numbers.size();\n    const int step = 4; // Assuming 4 elements per SIMD register (float64x2_t)\n\n    for (int i = 0; i < size; i += step) {\n        float64x2_t vec1 = vld1q_f64(&numbers[i]);\n\n        for (int j = i + step; j < size; j += step) {\n            float64x2_t vec2 = vld1q_f64(&numbers[j]);\n\n            float64x2_t diff = vabsq_f64(vsubq_f64(vec1, vec2));\n            uint64x2_t cmp = vcltq_f64(diff, vdupq_n_f64(threshold));\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    const int size = numbers.size();\n    const int step = 4; // Number of elements processed per iteration\n\n    for (int i = 0; i < size; i += step) {\n        float32x4_t v_threshold = vdupq_n_f32(threshold);\n        float32x4_t v_a = vld1q_f32(&numbers[i]);\n\n        for (int j = i + 1; j < size; j += step) {\n            float32x4_t v_b = vld1q_f32(&numbers[j]);\n\n            float32x4_t v_diff = vabsq_f32(vsubq_f32(v_a, v_b));\n            uint32x4_t v_cmp = vcltq_f32(v_diff, v_threshold);\n\n            if (vanyq_u32(v_cmp)) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```c++\nbool below_zero_simd(std::vector<int> operations) {\n    int32x4_t balance = vdupq_n_s32(0);\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < operations.size(); i += 4) {\n        int32x4_t ops = vld1q_s32(&operations[i]);\n        balance = vaddq_s32(balance, ops);\n\n        uint32x4_t mask = vcltq_s32(balance, zero);\n        if (vmaxvq_u32(mask) != 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n    float32x4_t mad_sum = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, v);\n    }\n\n    mean = vdupq_n_f32(vaddvq_f32(sum) / n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        mad_sum = vaddq_f32(mad_sum, vabsq_f32(vsubq_f32(v, mean)));\n    }\n\n    return vaddvq_f32(mad_sum) / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    float32x4_t mean_vec = vdupq_n_f32(0.0f);\n    float32x4_t mad_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t num_vec = vld1q_f32(&numbers[i]);\n        sum_vec = vaddq_f32(sum_vec, num_vec);\n    }\n\n    float sum = vaddvq_f32(sum_vec);\n    float mean = sum / n;\n    mean_vec = vdupq_n_f32(mean);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t num_vec = vld1q_f32(&numbers[i]);\n        float32x4_t diff_vec = vabsq_f32(vsubq_f32(num_vec, mean_vec));\n        mad_vec = vaddq_f32(mad_vec, diff_vec);\n    }\n\n    float mad_sum = vaddvq_f32(mad_vec);\n    return mad_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    for (size_t i = 0; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    float32x4_t vmean = vdupq_n_f32(mean);\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vx = vld1q_f32(&numbers[i]);\n        float32x4_t vad = vabsq_f32(vsubq_f32(vx, vmean));\n        vsum = vaddq_f32(vsum, vad);\n    }\n\n    float sum_array[4];\n    vst1q_f32(sum_array, vsum);\n    double total_sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n\n    return total_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    float32x4_t abs_diff_sum_vec = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        sum_vec = vaddq_f32(sum_vec, vec);\n    }\n\n    float sum = vaddvq_f32(sum_vec);\n    float mean = sum / n;\n\n    float32x4_t mean_vec = vdupq_n_f32(mean);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        float32x4_t diff_vec = vsubq_f32(vec, mean_vec);\n        float32x4_t abs_diff_vec = vabsq_f32(diff_vec);\n        abs_diff_sum_vec = vaddq_f32(abs_diff_sum_vec, abs_diff_vec);\n    }\n\n    float abs_diff_sum = vaddvq_f32(abs_diff_sum_vec);\n    return abs_diff_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    float32x4_t sum = vdupq_n_f32(0.0f);\n    float32x4_t mean = vdupq_n_f32(0.0f);\n    float32x4_t mad_sum = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        sum = vaddq_f32(sum, v);\n    }\n\n    mean = vdupq_n_f32(vaddvq_f32(sum) / n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t v = vld1q_f32(&numbers[i]);\n        mad_sum = vaddq_f32(mad_sum, vabsq_f32(vsubq_f32(v, mean)));\n    }\n\n    return vaddvq_f32(mad_sum) / n;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t num_vec = vld1q_s32(&numbers[i]);\n\n        int32x4_t mask = vcltq_s32(vdupq_n_s32(i), vdupq_n_s32(numbers.size()));\n        num_vec = vbslq_s32(mask, num_vec, zero_vec);\n\n        result.insert(result.end(), &num_vec[0], &num_vec[0] + 4);\n        if (i + 4 < numbers.size()) {\n            result.insert(result.end(), &delim_vec[0], &delim_vec[0] + 4);\n        }\n    }\n\n    if (numbers.size() % 4 != 0) {\n        size_t start = numbers.size() - (numbers.size() % 4);\n        for (size_t i = start; i < numbers.size(); ++i) {\n            result.push_back(numbers[i]);\n            if (i != numbers.size() - 1) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t num_vec = vld1q_s32(&numbers[i]);\n\n        int32x4_t mask = vcgtq_s32(num_vec, zero_vec);\n        int32x4_t result_vec = vbslq_s32(mask, num_vec, delim_vec);\n\n        int32_t result_arr[4];\n        vst1q_s32(result_arr, result_vec);\n\n        for (int j = 0; j < 4 && i + j < numbers.size(); ++j) {\n            result.push_back(result_arr[j]);\n            if (i + j + 1 < numbers.size()) {\n                result.push_back(delimeter);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {};\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t numbers_vec;\n    int32x4_t result_vec;\n\n    size_t i = 0;\n    for (; i + 4 <= numbers.size(); i += 4) {\n        numbers_vec = vld1q_s32(&numbers[i]);\n        result_vec = vzip1q_s32(numbers_vec, delim_vec);\n        vst1q_s32(&result[result.size()], result_vec);\n        result_vec = vzip2q_s32(numbers_vec, delim_vec);\n        vst1q_s32(&result[result.size()], result_vec);\n        result.push_back(delimeter);\n    }\n\n    for (; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i != numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t num_vec = vld1q_s32(&numbers[i]);\n\n        int32x4_t mask = vcgtq_s32(num_vec, zero_vec);\n        int32x4_t delim_mask = vandq_s32(mask, delim_vec);\n\n        int32x4_t result_vec = vsetq_lane_s32(numbers[i], delim_mask, 0);\n        result_vec = vsetq_lane_s32(delimeter, result_vec, 1);\n        result_vec = vsetq_lane_s32(numbers[i + 1], result_vec, 2);\n        result_vec = vsetq_lane_s32(delimeter, result_vec, 3);\n\n        vst1q_s32(&result[result.size()], result_vec);\n        result.resize(result.size() + 4);\n    }\n\n    result.pop_back();\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    std::vector<int> result;\n    result.reserve(numbers.size() * 2 - 1);\n\n    int32x4_t delim_vec = vdupq_n_s32(delimeter);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < numbers.size(); i += 4) {\n        int32x4_t num_vec = vld1q_s32(&numbers[i]);\n\n        int32x4_t mask = vcgtq_s32(zero_vec, num_vec);\n        int32x4_t delim_masked = vandq_s32(delim_vec, mask);\n\n        int32x4_t result_vec = vsetq_lane_s32(numbers[i], result_vec, 0);\n        result_vec = vsetq_lane_s32(delim_masked, result_vec, 1);\n        result_vec = vsetq_lane_s32(numbers[i + 1], result_vec, 2);\n        result_vec = vsetq_lane_s32(delim_masked, result_vec, 3);\n\n        vst1q_s32(&result[result.size()], result_vec);\n        result.resize(result.size() + 4);\n    }\n\n    result.pop_back();\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int n = numbers.size();\n    int i = 0;\n\n    // Process elements in chunks of 8\n    for (; i <= n - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Sum\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n\n        // Product\n        int16_t prod_arr[8];\n        vst1q_s16(prod_arr, vec);\n        for (int j = 0; j < 8; ++j) {\n            product *= prod_arr[j];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    int size = numbers.size();\n\n    if (size == 0) {\n        return {0, 1};\n    }\n\n    int i = 0;\n    int16x8_t sum_vec = vdupq_n_s16(0);\n    int16x8_t prod_vec = vdupq_n_s16(1);\n\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n        sum_vec = vaddq_s16(sum_vec, vec);\n        prod_vec = vmulq_s16(prod_vec, vec);\n    }\n\n    sum = vaddvq_s16(sum_vec);\n    product = vgetq_lane_s16(prod_vec, 0) * vgetq_lane_s16(prod_vec, 1) *\n              vgetq_lane_s16(prod_vec, 2) * vgetq_lane_s16(prod_vec, 3) *\n              vgetq_lane_s16(prod_vec, 4) * vgetq_lane_s16(prod_vec, 5) *\n              vgetq_lane_s16(prod_vec, 6) * vgetq_lane_s16(prod_vec, 7);\n\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    // Process elements in chunks of 8\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Sum\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n\n        // Product\n        int16_t arr[8];\n        vst1q_s16(arr, vec);\n        for (int j = 0; j < 8; ++j) {\n            product *= arr[j];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int n = numbers.size();\n    int i = 0;\n\n    // Process elements in chunks of 8\n    for (; i <= n - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Sum\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n\n        // Product\n        int16_t arr[8];\n        vst1q_s16(arr, vec);\n        for (int j = 0; j < 8; ++j) {\n            product *= arr[j];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```c++\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n\n    if (numbers.empty()) {\n        return {sum, product};\n    }\n\n    int size = numbers.size();\n    int i = 0;\n\n    // Process elements in chunks of 8\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&numbers[i]);\n\n        // Sum\n        int32x4_t sum_low = vpaddlq_s16(vec);\n        int32x2_t sum_pair = vpadd_s32(vget_low_s32(sum_low), vget_high_s32(sum_low));\n        sum += vget_lane_s32(sum_pair, 0) + vget_lane_s32(sum_pair, 1);\n\n        // Product\n        int16_t prod_arr[8];\n        vst1q_s16(prod_arr, vec);\n        for (int j = 0; j < 8; ++j) {\n            product *= prod_arr[j];\n        }\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        sum += numbers[i];\n        product *= numbers[i];\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        int32x4_t current_vec = vdupq_n_s32(numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        result[i] = vgetq_lane_s32(max_vec, 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_val = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); i += 4) {\n        int32x4_t current_vals = vld1q_s32(&numbers[i]);\n        max_val = vmaxq_s32(max_val, current_vals);\n\n        int32x4_t temp = max_val;\n        for (int j = 0; j < 4 && i + j < numbers.size(); ++j) {\n            result[i + j] = vgetq_lane_s32(temp, 0);\n            temp = vextq_s32(temp, temp, 1);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    int32x4_t max_val = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (int i = 1; i < n; i += 4) {\n        int32x4_t current_vals = vld1q_s32(&numbers[i]);\n        max_val = vmaxq_s32(max_val, current_vals);\n\n        int32_t max_vals[4];\n        vst1q_s32(max_vals, max_val);\n\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            result[i + j] = max_vals[j];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_vec = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        int32x4_t current_vec = vdupq_n_s32(numbers[i]);\n        max_vec = vmaxq_s32(max_vec, current_vec);\n        result[i] = vgetq_lane_s32(max_vec, 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    std::vector<int> result(numbers.size());\n    if (numbers.empty()) return result;\n\n    int32x4_t max_val = vdupq_n_s32(numbers[0]);\n    result[0] = numbers[0];\n\n    for (size_t i = 1; i < numbers.size(); i += 4) {\n        int32x4_t current_vals = vld1q_s32(&numbers[i]);\n        max_val = vmaxq_s32(max_val, current_vals);\n\n        int32x4_t result_vals = max_val;\n        for (int j = 0; j < 4 && i + j < numbers.size(); ++j) {\n            result[i + j] = vgetq_lane_s32(result_vals, j);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.length();\n    std::string result(len, '0');\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec_a = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vec_b = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vec_result = veorq_u8(vec_a, vec_b);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), vec_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    const std::string* longest = &strings[0];\n    size_t max_length = longest->size();\n\n    size_t i = 1;\n    for (; i <= strings.size() - 4; i += 4) {\n        uint32x4_t lengths = {\n            static_cast<uint32_t>(strings[i].size()),\n            static_cast<uint32_t>(strings[i + 1].size()),\n            static_cast<uint32_t>(strings[i + 2].size()),\n            static_cast<uint32_t>(strings[i + 3].size())\n        };\n\n        uint32x4_t max_lengths = vdupq_n_u32(max_length);\n        uint32x4_t cmp = vcltq_u32(max_lengths, lengths);\n\n        if (vmaxvq_u32(cmp) != 0) {\n            uint32_t mask = vgetq_lane_u32(cmp, 0);\n            if (mask) {\n                max_length = strings[i].size();\n                longest = &strings[i];\n            }\n            mask = vgetq_lane_u32(cmp, 1);\n            if (mask) {\n                max_length = strings[i + 1].size();\n                longest = &strings[i + 1];\n            }\n            mask = vgetq_lane_u32(cmp, 2);\n            if (mask) {\n                max_length = strings[i + 2].size();\n                longest = &strings[i + 2];\n            }\n            mask = vgetq_lane_u32(cmp, 3);\n            if (mask) {\n                max_length = strings[i + 3].size();\n                longest = &strings[i + 3];\n            }\n        }\n    }\n\n    for (; i < strings.size(); ++i) {\n        if (strings[i].size() > max_length) {\n            max_length = strings[i].size();\n            longest = &strings[i];\n        }\n    }\n\n    return *longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    const std::string* longest = &strings[0];\n    size_t max_length = longest->size();\n\n    size_t i = 1;\n    for (; i <= strings.size() - 4; i += 4) {\n        const std::string* str1 = &strings[i];\n        const std::string* str2 = &strings[i + 1];\n        const std::string* str3 = &strings[i + 2];\n        const std::string* str4 = &strings[i + 3];\n\n        uint32x4_t lengths = { static_cast<uint32_t>(str1->size()),\n                                static_cast<uint32_t>(str2->size()),\n                                static_cast<uint32_t>(str3->size()),\n                                static_cast<uint32_t>(str4->size()) };\n\n        uint32x4_t max_lengths = vdupq_n_u32(max_length);\n        uint32x4_t cmp = vcgtq_u32(lengths, max_lengths);\n\n        if (vgetq_lane_u32(cmp, 0)) {\n            longest = str1;\n            max_length = str1->size();\n        }\n        if (vgetq_lane_u32(cmp, 1)) {\n            longest = str2;\n            max_length = str2->size();\n        }\n        if (vgetq_lane_u32(cmp, 2)) {\n            longest = str3;\n            max_length = str3->size();\n        }\n        if (vgetq_lane_u32(cmp, 3)) {\n            longest = str4;\n            max_length = str4->size();\n        }\n    }\n\n    for (; i < strings.size(); ++i) {\n        if (strings[i].size() > max_length) {\n            longest = &strings[i];\n            max_length = strings[i].size();\n        }\n    }\n\n    return *longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    const std::string* longest = &strings[0];\n    size_t max_length = longest->size();\n\n    for (size_t i = 1; i < strings.size(); ++i) {\n        const std::string* current = &strings[i];\n        size_t current_length = current->size();\n\n        if (current_length > max_length) {\n            longest = current;\n            max_length = current_length;\n        }\n    }\n\n    return *longest;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    size_t max_length = 0;\n    std::string longest_string = strings[0];\n\n    for (const auto& str : strings) {\n        size_t length = str.length();\n        if (length > max_length) {\n            max_length = length;\n            longest_string = str;\n        }\n    }\n\n    return longest_string;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n\n    const size_t num_strings = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n\n    for (size_t i = 0; i < num_strings; i += 4) {\n        uint32x4_t lengths = vdupq_n_u32(0);\n        uint32x4_t indices = vdupq_n_u32(0);\n\n        for (size_t j = 0; j < 4 && i + j < num_strings; ++j) {\n            lengths = vsetq_lane_u32(strings[i + j].size(), lengths, j);\n            indices = vsetq_lane_u32(i + j, indices, j);\n        }\n\n        uint32x4_t max_lengths = vdupq_n_u32(max_length);\n        uint32x4_t mask = vcgtq_u32(lengths, max_lengths);\n\n        max_length = vmaxvq_u32(vbslq_u32(mask, lengths, max_lengths));\n        max_index = vgetq_lane_u32(vbslq_u32(mask, indices, vdupq_n_u32(max_index)), 0);\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t vec = vcreate_u64(a);\n    vec = vsetq_lane_u64(b, vec, 1);\n\n    while (vgetq_lane_u64(vec, 0) != vgetq_lane_u64(vec, 1)) {\n        if (vgetq_lane_u64(vec, 0) > vgetq_lane_u64(vec, 1)) {\n            vec = vsubq_u64(vec, vdupq_n_u64(vgetq_lane_u64(vec, 1)));\n        } else {\n            vec = vsubq_u64(vdupq_n_u64(vgetq_lane_u64(vec, 0)), vec);\n        }\n    }\n\n    return vgetq_lane_u64(vec, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t vec = vcreate_u64(a);\n    vec = vsetq_lane_u64(b, vec, 1);\n\n    while (vgetq_lane_u64(vec, 0) != vgetq_lane_u64(vec, 1)) {\n        uint64x2_t temp = vminq_u64(vec, vsubq_u64(vec, vdupq_n_u64(1)));\n        vec = vbslq_u64(vcgeq_u64(vec, temp), vec, temp);\n    }\n\n    return vgetq_lane_u64(vec, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t vec = vcreate_u64(a);\n    vec = vsetq_lane_u64(b, vec, 1);\n\n    while (vgetq_lane_u64(vec, 0) != vgetq_lane_u64(vec, 1)) {\n        uint64_t a = vgetq_lane_u64(vec, 0);\n        uint64_t b = vgetq_lane_u64(vec, 1);\n\n        if (a > b) {\n            vec = vsetq_lane_u64(a - b, vec, 0);\n        } else {\n            vec = vsetq_lane_u64(b - a, vec, 1);\n        }\n    }\n\n    return vgetq_lane_u64(vec, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t vec = vcreate_u64(a);\n    vec = vsetq_lane_u64(b, vec, 1);\n\n    while (vgetq_lane_u64(vec, 0) != vgetq_lane_u64(vec, 1)) {\n        uint64_t a = vgetq_lane_u64(vec, 0);\n        uint64_t b = vgetq_lane_u64(vec, 1);\n\n        if (a > b) {\n            vec = vsetq_lane_u64(a - b, vec, 0);\n        } else {\n            vec = vsetq_lane_u64(b - a, vec, 1);\n        }\n    }\n\n    return vgetq_lane_u64(vec, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t vec = vcreate_u64(a);\n    vec = vsetq_lane_u64(b, vec, 1);\n\n    while (vgetq_lane_u64(vec, 0) != vgetq_lane_u64(vec, 1)) {\n        vec = vsubq_u64(vec, vminq_u64(vec, vrev64q_u64(vec)));\n    }\n\n    return vgetq_lane_u64(vec, 0);\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n\n    for (size_t i = 0; i < n; ++i) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += 4) {\n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n            float diff_arr[4];\n            vst1q_f32(diff_arr, diff);\n\n            for (int k = 0; k < 4 && j + k < n; ++k) {\n                if (diff_arr[k] < min_diff) {\n                    min_diff = diff_arr[k];\n                    closest_pair[0] = std::min(numbers[i], numbers[j + k]);\n                    closest_pair[1] = std::max(numbers[i], numbers[j + k]);\n                }\n            }\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(const std::vector<float>& numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n\n    for (size_t i = 0; i < n; ++i) {\n        float32x4_t v1 = vld1q_dup_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += 4) {\n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n            float diff_array[4];\n            vst1q_f32(diff_array, diff);\n\n            for (int k = 0; k < 4 && j + k < n; ++k) {\n                if (diff_array[k] < min_diff) {\n                    min_diff = diff_array[k];\n                    closest_pair[0] = std::min(numbers[i], numbers[j + k]);\n                    closest_pair[1] = std::max(numbers[i], numbers[j + k]);\n                }\n            }\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n\n    for (size_t i = 0; i < n; ++i) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += 4) {\n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n            float diff_arr[4];\n            vst1q_f32(diff_arr, diff);\n\n            for (int k = 0; k < 4 && j + k < n; ++k) {\n                if (diff_arr[k] < min_diff) {\n                    min_diff = diff_arr[k];\n                    closest_pair[0] = std::min(numbers[i], numbers[j + k]);\n                    closest_pair[1] = std::max(numbers[i], numbers[j + k]);\n                }\n            }\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec_a = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 4; j < n; j += 4) {\n            float32x4_t vec_b = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(vec_a, vec_b));\n            float32x2_t min_diff_half = vmin_f32(vget_low_f32(diff), vget_high_f32(diff));\n            float min_diff_scalar = vget_lane_f32(vmin_f32(min_diff_half, min_diff_half), 0);\n\n            if (min_diff_scalar < min_diff) {\n                min_diff = min_diff_scalar;\n                for (size_t k = 0; k < 4; ++k) {\n                    for (size_t l = 0; l < 4; ++l) {\n                        float diff_scalar = std::abs(numbers[i + k] - numbers[j + l]);\n                        if (diff_scalar == min_diff_scalar) {\n                            closest_pair[0] = std::min(numbers[i + k], numbers[j + l]);\n                            closest_pair[1] = std::max(numbers[i + k], numbers[j + l]);\n                            return closest_pair;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <limits>\n\nstd::vector<float> find_closest_elements_simd(const std::vector<float>& numbers) {\n    size_t n = numbers.size();\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n\n    for (size_t i = 0; i < n; ++i) {\n        float32x4_t v1 = vld1q_f32(&numbers[i]);\n        for (size_t j = i + 1; j < n; j += 4) {\n            float32x4_t v2 = vld1q_f32(&numbers[j]);\n            float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n            float diff_arr[4];\n            vst1q_f32(diff_arr, diff);\n\n            for (int k = 0; k < 4 && j + k < n; ++k) {\n                if (diff_arr[k] < min_diff) {\n                    min_diff = diff_arr[k];\n                    closest_pair[0] = std::min(numbers[i], numbers[j + k]);\n                    closest_pair[1] = std::max(numbers[i], numbers[j + k]);\n                }\n            }\n        }\n    }\n\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int size = numbers.size();\n    std::vector<float> result(size);\n    float32x4_t min_vec = vdupq_n_f32(numbers[0]);\n    float32x4_t max_vec = vdupq_n_f32(numbers[0]);\n\n    for (int i = 0; i < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, vec);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float min_val = vminvq_f32(min_vec);\n    float max_val = vmaxvq_f32(max_vec);\n    float scale = 1.0f / (max_val - min_val);\n\n    float32x4_t scale_vec = vdupq_n_f32(scale);\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n\n    for (int i = 0; i < size; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, min_val_vec);\n        vec = vmulq_f32(vec, scale_vec);\n        vst1q_f32(&result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float32x4_t min_vec = vdupq_n_f32(numbers[0]);\n    float32x4_t max_vec = vdupq_n_f32(numbers[0]);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, vec);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float min_val = vminvq_f32(min_vec);\n    float max_val = vmaxvq_f32(max_vec);\n    float scale = 1.0f / (max_val - min_val);\n\n    float32x4_t scale_vec = vdupq_n_f32(scale);\n    float32x4_t min_vec_scaled = vdupq_n_f32(min_val);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, min_vec_scaled);\n        vec = vmulq_f32(vec, scale_vec);\n        vst1q_f32(&result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float32x4_t min_vec = vdupq_n_f32(numbers[0]);\n    float32x4_t max_vec = vdupq_n_f32(numbers[0]);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        min_vec = vminq_f32(min_vec, vec);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float min_val = vminvq_f32(min_vec);\n    float max_val = vmaxvq_f32(max_vec);\n    float scale = 1.0f / (max_val - min_val);\n\n    float32x4_t scale_vec = vdupq_n_f32(scale);\n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, min_val_vec);\n        vec = vmulq_f32(vec, scale_vec);\n        vst1q_f32(&result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float32x4_t min_val = vdupq_n_f32(numbers[0]);\n    float32x4_t max_val = vdupq_n_f32(numbers[0]);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        min_val = vminq_f32(min_val, vec);\n        max_val = vmaxq_f32(max_val, vec);\n    }\n\n    float min_scalar = vminvq_f32(min_val);\n    float max_scalar = vmaxvq_f32(max_val);\n\n    float32x4_t range = vdupq_n_f32(max_scalar - min_scalar);\n    float32x4_t min_vec = vdupq_n_f32(min_scalar);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, min_vec);\n        vec = vdivq_f32(vec, range);\n        vst1q_f32(&result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n\n    float32x4_t min_val = vdupq_n_f32(numbers[0]);\n    float32x4_t max_val = vdupq_n_f32(numbers[0]);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        min_val = vminq_f32(min_val, vec);\n        max_val = vmaxq_f32(max_val, vec);\n    }\n\n    float min_scalar = vminvq_f32(min_val);\n    float max_scalar = vmaxvq_f32(max_val);\n\n    float32x4_t range = vdupq_n_f32(max_scalar - min_scalar);\n    float32x4_t min_vec = vdupq_n_f32(min_scalar);\n\n    for (size_t i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, min_vec);\n        vec = vdivq_f32(vec, range);\n        vst1q_f32(&result[i], vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t i = n / 2;\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_i = vdupq_n_u64(i);\n    uint64x2_t vec_result = vdupq_n_u64(result);\n\n    while (i > 1) {\n        uint64x2_t vec_remainder = vremq_u64(vec_n, vec_i);\n        uint64x2_t vec_zero = vdupq_n_u64(0);\n        uint64x2_t vec_mask = vceqq_u64(vec_remainder, vec_zero);\n\n        if (vgetq_lane_u64(vec_mask, 0) || vgetq_lane_u64(vec_mask, 1)) {\n            result = i;\n            break;\n        }\n\n        i--;\n        vec_i = vdupq_n_u64(i);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t i = n / 2;\n    uint64x2_t vec_n = vdupq_n_u64(n);\n    uint64x2_t vec_i = vdupq_n_u64(i);\n    uint64x2_t vec_result = vdupq_n_u64(result);\n\n    while (i > 1) {\n        uint64x2_t vec_remainder = vsubq_u64(vec_n, vec_i);\n        uint64x2_t vec_divisible = vceqq_u64(vec_remainder, vdupq_n_u64(0));\n        uint64_t divisible = vgetq_lane_u64(vec_divisible, 0) || vgetq_lane_u64(vec_divisible, 1);\n\n        if (divisible) {\n            vec_result = vec_i;\n            break;\n        }\n\n        vec_i = vsubq_u64(vec_i, vdupq_n_u64(1));\n        i--;\n    }\n\n    result = vgetq_lane_u64(vec_result, 0);\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t div_vec = vdupq_n_u64(2);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(div_vec, 0) < n) {\n        uint64x2_t rem_vec = vsubq_u64(n_vec, vdivq_u64(n_vec, div_vec));\n        uint64x2_t is_zero_vec = vceqq_u64(rem_vec, vdupq_n_u64(0));\n        if (vgetq_lane_u64(is_zero_vec, 0)) {\n            result = vgetq_lane_u64(div_vec, 0);\n        }\n        div_vec = vaddq_u64(div_vec, one_vec);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t div_vec = vdupq_n_u64(2);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    for (uint64_t i = 2; i * i <= n; ++i) {\n        uint64x2_t i_vec = vdupq_n_u64(i);\n        uint64x2_t rem_vec = vsubq_u64(n_vec, vmulq_u64(i_vec, vdivq_u64(n_vec, i_vec)));\n        uint64x2_t is_divisible = vceqq_u64(rem_vec, one_vec);\n\n        if (vgetq_lane_u64(is_divisible, 0) || vgetq_lane_u64(is_divisible, 1)) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t div_vec = vdupq_n_u64(2);\n    uint64x2_t one_vec = vdupq_n_u64(1);\n\n    for (uint64_t i = 2; i * i <= n; ++i) {\n        uint64x2_t i_vec = vdupq_n_u64(i);\n        uint64x2_t mod_vec = vmodq_u64(n_vec, i_vec);\n        uint64x2_t cmp_vec = vceqq_u64(mod_vec, one_vec);\n\n        if (vgetq_lane_u64(cmp_vec, 0) && i > result) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t v_n = vdupq_n_s32(n);\n    int32x4_t v_i = vdupq_n_s32(2);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    while (vgetq_lane_s32(v_n, 0) > 1) {\n        uint32x4_t v_div = vdivq_s32(v_n, v_i);\n        uint32x4_t v_mul = vmulq_s32(v_div, v_i);\n        uint32x4_t v_eq = vceqq_s32(v_n, v_mul);\n\n        if (vgetq_lane_u32(v_eq, 0)) {\n            factors.push_back(vgetq_lane_s32(v_i, 0));\n            v_n = vdivq_s32(v_n, v_i);\n        } else {\n            v_i = vaddq_s32(v_i, v_one);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t v_n = vdupq_n_s32(n);\n    int32x4_t v_2 = vdupq_n_s32(2);\n    int32x4_t v_1 = vdupq_n_s32(1);\n\n    while (vgetq_lane_s32(v_n, 0) > 1) {\n        uint32x4_t v_div = vdivq_u32(v_n, v_2);\n        uint32x4_t v_mul = vmulq_u32(v_div, v_2);\n        uint32x4_t v_eq = vceqq_u32(v_n, v_mul);\n\n        if (vgetq_lane_u32(v_eq, 0)) {\n            factors.push_back(2);\n            v_n = vdivq_s32(v_n, v_2);\n        } else {\n            int32x4_t v_i = vaddq_s32(v_2, v_1);\n            int32x4_t v_sqrt = vsqrtq_s32(v_n);\n            int32x4_t v_found = vdupq_n_s32(0);\n\n            while (vgetq_lane_s32(v_i, 0) <= vgetq_lane_s32(v_sqrt, 0)) {\n                uint32x4_t v_div = vdivq_u32(v_n, v_i);\n                uint32x4_t v_mul = vmulq_u32(v_div, v_i);\n                uint32x4_t v_eq = vceqq_u32(v_n, v_mul);\n\n                if (vgetq_lane_u32(v_eq, 0)) {\n                    factors.push_back(vgetq_lane_s32(v_i, 0));\n                    v_n = vdivq_s32(v_n, v_i);\n                    v_found = vaddq_s32(v_found, v_1);\n                    break;\n                }\n                v_i = vaddq_s32(v_i, v_2);\n            }\n\n            if (vgetq_lane_s32(v_found, 0) == 0) {\n                factors.push_back(vgetq_lane_s32(v_n, 0));\n                break;\n            }\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t dividers = {2, 3, 5, 7};\n    int32x4_t ones = vdupq_n_s32(1);\n    int32x4_t n_vec = vdupq_n_s32(n);\n\n    while (n > 1) {\n        uint32x4_t mask = vcleq_s32(n_vec, dividers);\n        int32x4_t remainder = vsubq_s32(n_vec, dividers);\n        uint32x4_t is_divisible = vandq_u32(vceqq_s32(remainder, vdupq_n_s32(0)), mask);\n\n        if (vmaxvq_u32(is_divisible) > 0) {\n            int32_t div = vgetq_lane_s32(dividers, vmaxvq_u32(is_divisible));\n            factors.push_back(div);\n            n /= div;\n            n_vec = vdupq_n_s32(n);\n        } else {\n            dividers = vaddq_s32(dividers, ones);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t v_n = vdupq_n_s32(n);\n    int32x4_t v_two = vdupq_n_s32(2);\n    int32x4_t v_div = v_n;\n\n    while (vgetq_lane_s32(v_div, 0) > 1) {\n        int32x4_t v_mod = vdivq_s32(v_div, v_two);\n        v_mod = vmulq_s32(v_mod, v_two);\n        v_mod = vsubq_s32(v_div, v_mod);\n\n        uint32x4_t v_mask = vceqq_s32(v_mod, vdupq_n_s32(0));\n        if (vgetq_lane_u32(vreinterpretq_u32_s32(v_mask), 0)) {\n            factors.push_back(2);\n            v_div = vdivq_s32(v_div, v_two);\n        } else {\n            int32x4_t v_i = vdupq_n_s32(3);\n            int32x4_t v_sqrt = vsqrtq_s32(v_div);\n            while (vgetq_lane_s32(v_i, 0) <= vgetq_lane_s32(v_sqrt, 0)) {\n                v_mod = vdivq_s32(v_div, v_i);\n                v_mod = vmulq_s32(v_mod, v_i);\n                v_mod = vsubq_s32(v_div, v_mod);\n\n                v_mask = vceqq_s32(v_mod, vdupq_n_s32(0));\n                if (vgetq_lane_u32(vreinterpretq_u32_s32(v_mask), 0)) {\n                    factors.push_back(vgetq_lane_s32(v_i, 0));\n                    v_div = vdivq_s32(v_div, v_i);\n                } else {\n                    v_i = vaddq_s32(v_i, v_two);\n                }\n            }\n            if (vgetq_lane_s32(v_div, 0) > 1) {\n                factors.push_back(vgetq_lane_s32(v_div, 0));\n                break;\n            }\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int32x4_t v_n = vdupq_n_s32(n);\n    int32x4_t v_i = vdupq_n_s32(2);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    while (vgetq_lane_s32(v_n, 0) > 1) {\n        uint32x4_t v_div = vdivq_s32(v_n, v_i);\n        uint32x4_t v_mul = vmulq_s32(v_div, v_i);\n        uint32x4_t v_eq = vceqq_s32(v_n, v_mul);\n\n        if (vgetq_lane_u32(v_eq, 0)) {\n            factors.push_back(vgetq_lane_s32(v_i, 0));\n            v_n = vdivq_s32(v_n, v_i);\n        } else {\n            v_i = vaddq_s32(v_i, v_one);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        if (vgetq_lane_f32(vec, 0) > 0) result.push_back(vgetq_lane_f32(vec, 0));\n        if (vgetq_lane_f32(vec, 1) > 0) result.push_back(vgetq_lane_f32(vec, 1));\n        if (vgetq_lane_f32(vec, 2) > 0) result.push_back(vgetq_lane_f32(vec, 2));\n        if (vgetq_lane_f32(vec, 3) > 0) result.push_back(vgetq_lane_f32(vec, 3));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        if (vgetq_lane_f32(vec, 0) > 0) result.push_back(vgetq_lane_f32(vec, 0));\n        if (vgetq_lane_f32(vec, 1) > 0) result.push_back(vgetq_lane_f32(vec, 1));\n        if (vgetq_lane_f32(vec, 2) > 0) result.push_back(vgetq_lane_f32(vec, 2));\n        if (vgetq_lane_f32(vec, 3) > 0) result.push_back(vgetq_lane_f32(vec, 3));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    const float32x4_t zero = vdupq_n_f32(0.0f);\n    const int32x4_t mask = vdupq_n_s32(0xFFFFFFFF);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t cmp = vcltq_f32(vec, zero);\n        int32x4_t cmp_mask = vreinterpretq_s32_u32(cmp);\n        int32x4_t result_mask = vandq_s32(cmp_mask, mask);\n        float32x4_t result_vec = vbslq_f32(result_mask, zero, vec);\n\n        float result_arr[4];\n        vst1q_f32(result_arr, result_vec);\n\n        for (int j = 0; j < 4 && i + j < l.size(); ++j) {\n            if (result_arr[j] > 0) {\n                result.push_back(result_arr[j]);\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    const float* data = l.data();\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n        float32x4_t positive_vec = vbslq_f32(mask, vec, vdupq_n_f32(0.0f));\n\n        float positive[4];\n        vst1q_f32(positive, positive_vec);\n\n        for (int j = 0; j < 4; ++j) {\n            if (positive[j] > 0) {\n                result.push_back(positive[j]);\n            }\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (data[i] > 0) {\n            result.push_back(data[i]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float>& l) {\n    std::vector<float> result;\n    result.reserve(l.size());\n\n    float32x4_t zero = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        if (vgetq_lane_u32(vreinterpretq_u32_f32(mask), 0)) result.push_back(vgetq_lane_f32(vec, 0));\n        if (vgetq_lane_u32(vreinterpretq_u32_f32(mask), 1)) result.push_back(vgetq_lane_f32(vec, 1));\n        if (vgetq_lane_u32(vreinterpretq_u32_f32(mask), 2)) result.push_back(vgetq_lane_f32(vec, 2));\n        if (vgetq_lane_u32(vreinterpretq_u32_f32(mask), 3)) result.push_back(vgetq_lane_f32(vec, 3));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    int64_t inc = 2;\n    int64_t limit = sqrt(n);\n\n    while (i <= limit) {\n        int64x2_t divisors = vld1q_s64(&i);\n        int64x2_t remainders = vmodq_s64(divisors, vdupq_s64(n));\n        int64x2_t zeros = veorq_s64(remainders, remainders);\n\n        if (vgetq_lane_s64(remainders, 0) == 0 || vgetq_lane_s64(remainders, 1) == 0) {\n            return false;\n        }\n\n        i += inc;\n        inc = 6 - inc;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    int64_t inc = 2;\n    int64_t limit = sqrt(n);\n\n    while (i <= limit) {\n        int64x2_t v_i = vdupq_n_s64(i);\n        int64x2_t v_n = vdupq_n_s64(n);\n        uint64x2_t v_rem = vremq_u64(v_n, v_i);\n\n        if (vgetq_lane_u64(v_rem, 0) == 0 || vgetq_lane_u64(v_rem, 1) == 0) {\n            return false;\n        }\n\n        i += inc;\n        inc = 6 - inc;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    int64_t inc = 2;\n    int64_t limit = sqrt(n);\n\n    while (i <= limit) {\n        int64x2_t divisors = vld1q_s64(&i);\n        int64x2_t remainders = vdivq_s64(vdupq_n_s64(n), divisors);\n        int64x2_t products = vmulq_s64(remainders, divisors);\n        int64x2_t differences = vsubq_s64(vdupq_n_s64(n), products);\n\n        if (vgetq_lane_s64(differences, 0) == 0 || vgetq_lane_s64(differences, 1) == 0) {\n            return false;\n        }\n\n        i += inc;\n        inc = 6 - inc;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    int64_t inc = 2;\n    int64_t limit = (int64_t)sqrt(n);\n\n    while (i <= limit) {\n        int64x2_t divisors = vld1q_s64(&i);\n        int64x2_t remainders = vmodq_s64(divisors, vdupq_n_s64(n));\n        uint64x2_t mask = vceqq_s64(remainders, vdupq_n_s64(0));\n\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            return false;\n        }\n\n        i += inc;\n        inc = 6 - inc;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n <= 3) return true;\n    if (n % 2 == 0 || n % 3 == 0) return false;\n\n    int64_t i = 5;\n    int64_t inc = 2;\n    int64_t limit = (int64_t)sqrt(n);\n\n    while (i <= limit) {\n        int64x2_t v_i = vdupq_n_s64(i);\n        int64x2_t v_n = vdupq_n_s64(n);\n        int64x2_t v_mod = vmodq_s64(v_n, v_i);\n\n        if (vgetq_lane_s64(v_mod, 0) == 0 || vgetq_lane_s64(v_mod, 1) == 0) {\n            return false;\n        }\n\n        i += inc;\n        inc = 6 - inc;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    const char* input = s.c_str();\n    char* output = &result[0];\n    size_t length = s.length();\n    bool has_letters = false;\n\n    // Check if there are any letters in the string\n    for (size_t i = 0; i < length; ++i) {\n        if (isalpha(input[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (has_letters) {\n        // Reverse case for letters using SIMD\n        for (size_t i = 0; i < length; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(input + i));\n            uint8x16_t lower_mask = vdupq_n_u8(0x20);\n            uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n            uint8x16_t is_lower = vandq_u8(vec, lower_mask);\n            uint8x16_t is_upper = vbicq_u8(vec, lower_mask);\n            uint8x16_t is_letter = vorrq_u8(is_lower, is_upper);\n            uint8x16_t case_reversed = veorq_u8(vec, lower_mask);\n            uint8x16_t result_vec = vbslq_u8(is_letter, case_reversed, vec);\n            vst1q_u8(reinterpret_cast<uint8_t*>(output + i), result_vec);\n        }\n    } else {\n        // Reverse the entire string\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    const char* input = s.c_str();\n    char* output = &result[0];\n    size_t length = s.length();\n    bool has_letters = false;\n\n    // Check if there are any letters in the string\n    for (size_t i = 0; i < length; ++i) {\n        if (isalpha(input[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (has_letters) {\n        // Reverse case for letters using SIMD\n        for (size_t i = 0; i < length; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(input + i));\n            uint8x16_t lower_mask = vdupq_n_u8(0x20);\n            uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n            uint8x16_t is_lower = vandq_u8(vcgeq_u8(vec, vdupq_n_u8('a')), vcleq_u8(vec, vdupq_n_u8('z')));\n            uint8x16_t is_upper = vandq_u8(vcgeq_u8(vec, vdupq_n_u8('A')), vcleq_u8(vec, vdupq_n_u8('Z')));\n            uint8x16_t lower_to_upper = vandq_u8(is_lower, lower_mask);\n            uint8x16_t upper_to_lower = vandq_u8(is_upper, upper_mask);\n            uint8x16_t result_vec = veorq_u8(vec, vorrq_u8(lower_to_upper, upper_to_lower));\n            vst1q_u8(reinterpret_cast<uint8_t*>(output + i), result_vec);\n        }\n    } else {\n        // Reverse the string\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    const char* input = s.c_str();\n    char* output = &result[0];\n    size_t len = s.length();\n    bool has_letters = false;\n\n    // Check if there are any letters in the string\n    for (size_t i = 0; i < len; ++i) {\n        if (isalpha(input[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (has_letters) {\n        // Reverse case for letters using SIMD\n        for (size_t i = 0; i < len; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(input + i));\n            uint8x16_t lower_mask = vdupq_n_u8(0x20);\n            uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n            uint8x16_t is_lower = vandq_u8(vcgeq_u8(vec, vdupq_n_u8('a')), vcleq_u8(vec, vdupq_n_u8('z')));\n            uint8x16_t is_upper = vandq_u8(vcgeq_u8(vec, vdupq_n_u8('A')), vcleq_u8(vec, vdupq_n_u8('Z')));\n            uint8x16_t lower_to_upper = vandq_u8(is_lower, lower_mask);\n            uint8x16_t upper_to_lower = vandq_u8(is_upper, upper_mask);\n            uint8x16_t result_vec = veorq_u8(vec, vorrq_u8(lower_to_upper, upper_to_lower));\n            vst1q_u8(reinterpret_cast<uint8_t*>(output + i), result_vec);\n        }\n    } else {\n        // Reverse the string\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    const char* input = s.c_str();\n    char* output = &result[0];\n    size_t length = s.size();\n    bool has_letters = false;\n\n    // Check if there are any letters in the string\n    for (size_t i = 0; i < length; ++i) {\n        if (isalpha(input[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (has_letters) {\n        // Process the string in chunks of 16 bytes (128 bits)\n        for (size_t i = 0; i < length; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(input + i));\n\n            // Create masks for lowercase and uppercase letters\n            uint8x16_t lower_mask = vandq_u8(vec, vdupq_n_u8(0x20));\n            uint8x16_t upper_mask = vandq_u8(vec, vdupq_n_u8(0x40));\n\n            // Check for lowercase letters\n            uint8x16_t is_lower = vcgeq_u8(lower_mask, vdupq_n_u8('a'));\n            is_lower = vandq_u8(is_lower, vcgeq_u8(vdupq_n_u8('z'), lower_mask));\n\n            // Check for uppercase letters\n            uint8x16_t is_upper = vcgeq_u8(upper_mask, vdupq_n_u8('A'));\n            is_upper = vandq_u8(is_upper, vcgeq_u8(vdupq_n_u8('Z'), upper_mask));\n\n            // Convert lowercase to uppercase\n            uint8x16_t to_upper = vandq_u8(is_lower, vdupq_n_u8(0x20));\n            vec = vsubq_u8(vec, to_upper);\n\n            // Convert uppercase to lowercase\n            uint8x16_t to_lower = vandq_u8(is_upper, vdupq_n_u8(0x20));\n            vec = vaddq_u8(vec, to_lower);\n\n            vst1q_u8(reinterpret_cast<uint8_t*>(output + i), vec);\n        }\n    } else {\n        // Reverse the string if no letters are present\n        std::reverse(result.begin(), result.end());\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    std::string result = s;\n    const char* input = s.c_str();\n    char* output = &result[0];\n    size_t length = s.size();\n    bool has_letters = false;\n\n    // Check if the string contains any letters\n    for (size_t i = 0; i < length; ++i) {\n        if (isalpha(input[i])) {\n            has_letters = true;\n            break;\n        }\n    }\n\n    if (has_letters) {\n        // Reverse case for letters\n        for (size_t i = 0; i < length; i += 16) {\n            uint8x16_t vec = vld1q_u8((const uint8_t*)&input[i]);\n            uint8x16_t lower_mask = vdupq_n_u8(0x20);\n            uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n            uint8x16_t is_lower = vandq_u8(vcgeq_u8(vec, vdupq_n_u8('a')), vcleq_u8(vec, vdupq_n_u8('z')));\n            uint8x16_t is_upper = vandq_u8(vcgeq_u8(vec, vdupq_n_u8('A')), vcleq_u8(vec, vdupq_n_u8('Z')));\n            uint8x16_t lower_to_upper = vandq_u8(is_lower, lower_mask);\n            uint8x16_t upper_to_lower = vandq_u8(is_upper, upper_mask);\n            vec = veorq_u8(vec, vorrq_u8(lower_to_upper, upper_to_lower));\n            vst1q_u8((uint8_t*)&output[i], vec);\n        }\n    } else {\n        // Reverse the string\n        for (size_t i = 0; i < length / 2; ++i) {\n            std::swap(output[i], output[length - i - 1]);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> sorted_thirds;\n\n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n\n    // Place sorted elements back into the original vector\n    int sorted_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        l[i] = sorted_thirds[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> sorted_thirds;\n\n    // Collect elements at indices divisible by 3\n    for (int i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n\n    // Sort the collected elements\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n\n    // Place sorted elements back into the original vector\n    int sorted_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        l[i] = sorted_thirds[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> sorted_thirds;\n\n    for (int i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n\n    int sorted_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        l[i] = sorted_thirds[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> sorted_thirds;\n\n    for (int i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n\n    int sorted_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        l[i] = sorted_thirds[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    std::vector<int> sorted_thirds;\n\n    for (int i = 0; i < n; i += 3) {\n        sorted_thirds.push_back(l[i]);\n    }\n\n    std::sort(sorted_thirds.begin(), sorted_thirds.end());\n\n    int sorted_index = 0;\n    for (int i = 0; i < n; i += 3) {\n        l[i] = sorted_thirds[sorted_index++];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_vec = vdupq_n_f32(-FLT_MAX);\n    size_t i = 0;\n\n    for (; i <= l.size() - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_vals[4];\n    vst1q_f32(max_vals, max_vec);\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; ++j) {\n        if (max_vals[j] > max_val) {\n            max_val = max_vals[j];\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_vec = vdupq_n_f32(-std::numeric_limits<float>::infinity());\n    size_t i = 0;\n\n    for (; i <= l.size() - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_vals[4];\n    vst1q_f32(max_vals, max_vec);\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; ++j) {\n        if (max_vals[j] > max_val) {\n            max_val = max_vals[j];\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_vec = vdupq_n_f32(-std::numeric_limits<float>::infinity());\n    size_t n = l.size();\n    size_t i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_vals[4];\n    vst1q_f32(max_vals, max_vec);\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; ++j) {\n        if (max_vals[j] > max_val) {\n            max_val = max_vals[j];\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_vec = vdupq_n_f32(-INFINITY);\n    size_t n = l.size();\n    size_t i = 0;\n\n    for (; i + 3 < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_vals[4];\n    vst1q_f32(max_vals, max_vec);\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; ++j) {\n        if (max_vals[j] > max_val) {\n            max_val = max_vals[j];\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c++\nfloat max_element_simd(std::vector<float> l) {\n    float32x4_t max_vec = vdupq_n_f32(-FLT_MAX);\n    size_t i = 0;\n\n    for (; i <= l.size() - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, vec);\n    }\n\n    float max_vals[4];\n    vst1q_f32(max_vals, max_vec);\n    float max_val = max_vals[0];\n    for (int j = 1; j < 4; ++j) {\n        if (max_vals[j] > max_val) {\n            max_val = max_vals[j];\n        }\n    }\n\n    for (; i < l.size(); ++i) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        uint32x4_t mask11 = vceqq_s32(v, vmovq_n_s32(11));\n        uint32x4_t mask13 = vceqq_s32(v, vmovq_n_s32(13));\n        uint32x4_t mask = vorrq_u32(mask11, mask13);\n\n        int32x4_t v7 = vdupq_n_s32(7);\n        uint32x4_t mask7 = vceqq_s32(v, v7);\n\n        uint32x4_t result = vandq_u32(mask, mask7);\n        count += vaddvq_u32(result);\n    }\n\n    // Process remaining integers\n    for (; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && i % 10 == 7) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process in chunks of 4\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        uint32x4_t mask11 = vceqq_s32(v, vmodq_s32(v, vdupq_n_s32(11)));\n        uint32x4_t mask13 = vceqq_s32(v, vmodq_s32(v, vdupq_n_s32(13)));\n        uint32x4_t mask = vorrq_u32(mask11, mask13);\n\n        int32x4_t v7 = vdupq_n_s32(7);\n        uint32x4_t mask7 = vceqq_s32(v, v7);\n\n        uint32x4_t final_mask = vandq_u32(mask, mask7);\n        count += vaddvq_u32(final_mask);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && i == 7) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        uint32x4_t mask11 = vceqq_s32(v, vmodq_s32(v, vdupq_n_s32(11)));\n        uint32x4_t mask13 = vceqq_s32(v, vmodq_s32(v, vdupq_n_s32(13)));\n        uint32x4_t mask = vorrq_u32(mask11, mask13);\n\n        uint32x4_t v7 = vdupq_n_u32(7);\n        uint32x4_t v10 = vdupq_n_u32(10);\n        uint32x4_t v100 = vdupq_n_u32(100);\n        uint32x4_t v1000 = vdupq_n_u32(1000);\n        uint32x4_t v10000 = vdupq_n_u32(10000);\n\n        uint32x4_t count7 = vandq_u32(mask, vceqq_u32(v7, vandq_u32(v, vdupq_n_u32(1))));\n        count7 = vorrq_u32(count7, vandq_u32(mask, vceqq_u32(v7, vandq_u32(vdivq_u32(v, v10), vdupq_n_u32(1)))));\n        count7 = vorrq_u32(count7, vandq_u32(mask, vceqq_u32(v7, vandq_u32(vdivq_u32(v, v100), vdupq_n_u32(1)))));\n        count7 = vorrq_u32(count7, vandq_u32(mask, vceqq_u32(v7, vandq_u32(vdivq_u32(v, v1000), vdupq_n_u32(1)))));\n        count7 = vorrq_u32(count7, vandq_u32(mask, vceqq_u32(v7, vandq_u32(vdivq_u32(v, v10000), vdupq_n_u32(1)))));\n\n        count += vaddvq_u32(count7);\n    }\n\n    // Process remaining integers\n    for (; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && (i % 10 == 7 || i / 10 % 10 == 7 || i / 100 % 10 == 7 || i / 1000 % 10 == 7 || i / 10000 % 10 == 7)) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Define the vector constants for divisibility checks\n    int32x4_t v_11 = vdupq_n_s32(11);\n    int32x4_t v_13 = vdupq_n_s32(13);\n    int32x4_t v_7 = vdupq_n_s32(7);\n    int32x4_t v_10 = vdupq_n_s32(10);\n\n    // Process in chunks of 4\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v_i = vaddq_s32(vdupq_n_s32(i), vcreate32(0, 1, 2, 3));\n        uint32x4_t v_div11 = vtstq_u32(v_i, v_11);\n        uint32x4_t v_div13 = vtstq_u32(v_i, v_13);\n        uint32x4_t v_mask = vorrq_u32(v_div11, v_div13);\n\n        // Check for the digit 7 in each number\n        uint32x4_t v_count = vdupq_n_u32(0);\n        for (int j = 0; j < 4; ++j) {\n            int32_t num = vgetq_lane_s32(v_i, j);\n            if (vgetq_lane_u32(v_mask, j)) {\n                while (num > 0) {\n                    if (num % 10 == 7) {\n                        v_count = vaddq_u32(v_count, v_1);\n                    }\n                    num /= 10;\n                }\n            }\n        }\n        count += vaddvq_u32(v_count);\n    }\n\n    // Process remaining elements\n    for (; i < n; ++i) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    ++count;\n                }\n                num /= 10;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    int count = 0;\n    int i = 0;\n\n    // Process 4 integers at a time\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&i);\n        uint32x4_t mask11 = vceqq_s32(vandq_s32(v, vdupq_n_s32(11)), vdupq_n_s32(0));\n        uint32x4_t mask13 = vceqq_s32(vandq_s32(v, vdupq_n_s32(13)), vdupq_n_s32(0));\n        uint32x4_t mask = vorrq_u32(mask11, mask13);\n\n        int32x4_t v7 = vdupq_n_s32(7);\n        uint32x4_t mask7 = vceqq_s32(v, v7);\n\n        uint32x4_t result = vandq_u32(mask, mask7);\n        count += vaddvq_u32(result);\n    }\n\n    // Process remaining integers\n    for (; i < n; ++i) {\n        if ((i % 11 == 0 || i % 13 == 0) && i == 7) {\n            ++count;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t even_values = vdupq_n_f32(0.0f);\n    float32x4_t odd_values = vdupq_n_f32(0.0f);\n    float32x4_t mask = vdupq_n_f32(1.0f);\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t even_mask = vandq_f32(vec, mask);\n        float32x4_t odd_mask = vbicq_f32(vec, mask);\n\n        even_values = vaddq_f32(even_values, even_mask);\n        odd_values = vaddq_f32(odd_values, odd_mask);\n\n        mask = vrev64q_f32(mask);\n    }\n\n    std::vector<float> even_vec;\n    for (int i = 0; i < n; i += 2) {\n        even_vec.push_back(l[i]);\n    }\n    std::sort(even_vec.begin(), even_vec.end());\n\n    for (int i = 0, j = 0; i < n; i += 2, j++) {\n        l[i] = even_vec[j];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t even_values = vdupq_n_f32(0.0f);\n    float32x4_t odd_values = vdupq_n_f32(0.0f);\n    float32x4_t mask = vdupq_n_f32(0.0f);\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t even_mask = vdupq_n_f32(1.0f);\n        float32x4_t odd_mask = vdupq_n_f32(0.0f);\n\n        for (int j = 0; j < 4; ++j) {\n            if ((i + j) % 2 == 0) {\n                even_values = vsetq_lane_f32(l[i + j], even_values, j);\n                even_mask = vsetq_lane_f32(1.0f, even_mask, j);\n            } else {\n                odd_values = vsetq_lane_f32(l[i + j], odd_values, j);\n                odd_mask = vsetq_lane_f32(1.0f, odd_mask, j);\n            }\n        }\n\n        mask = vorrq_f32(mask, even_mask);\n        vec = vbslq_f32(even_mask, even_values, vec);\n        vec = vbslq_f32(odd_mask, odd_values, vec);\n        vst1q_f32(&l[i], vec);\n    }\n\n    std::sort(l.begin(), l.begin() + (n + 1) / 2 * 2);\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t even_mask = vdupq_n_f32(1.0f);\n        float32x4_t odd_mask = vdupq_n_f32(0.0f);\n\n        for (int j = 0; j < 4; ++j) {\n            if ((i + j) % 2 == 0) {\n                even_values = vsetq_lane_f32(l[i + j], even_values, j);\n                even_mask = vsetq_lane_f32(1.0f, even_mask, j);\n            } else {\n                odd_values = vsetq_lane_f32(l[i + j], odd_values, j);\n                odd_mask = vsetq_lane_f32(1.0f, odd_mask, j);\n            }\n        }\n\n        vec = vbslq_f32(even_mask, even_values, vec);\n        vec = vbslq_f32(odd_mask, odd_values, vec);\n        vst1q_f32(&l[i], vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t even_values = vdupq_n_f32(0.0f);\n    float32x4_t odd_values = vdupq_n_f32(0.0f);\n    std::vector<float> even_elements;\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t mask = vdupq_n_f32(1.0f);\n        mask = vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(mask), vdupq_n_u32(0xAAAAAAAA)));\n\n        even_values = vbslq_f32(mask, vec, even_values);\n        odd_values = vbslq_f32(mask, odd_values, vec);\n\n        vst1q_f32(&l[i], odd_values);\n        vst1q_f32(&l[i + 2], even_values);\n\n        even_elements.push_back(vgetq_lane_f32(even_values, 0));\n        even_elements.push_back(vgetq_lane_f32(even_values, 2));\n    }\n\n    std::sort(even_elements.begin(), even_elements.end());\n\n    for (int i = 0, j = 0; i < n; i += 4, j += 2) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t mask = vdupq_n_f32(1.0f);\n        mask = vreinterpretq_f32_u32(vandq_u32(vreinterpretq_u32_f32(mask), vdupq_n_u32(0xAAAAAAAA)));\n\n        float32x4_t sorted_even = vdupq_n_f32(even_elements[j]);\n        float32x4_t sorted_even2 = vdupq_n_f32(even_elements[j + 1]);\n\n        vec = vbslq_f32(mask, sorted_even, vec);\n        vec = vbslq_f32(mask, sorted_even2, vec);\n\n        vst1q_f32(&l[i], vec);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t even_values = vdupq_n_f32(0.0f);\n    float32x4_t odd_values = vdupq_n_f32(0.0f);\n    float32x4_t mask = vdupq_n_f32(1.0f);\n\n    for (int i = 0; i < n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x4_t even_mask = vandq_f32(vec, mask);\n        float32x4_t odd_mask = vbicq_f32(vec, mask);\n\n        even_values = vaddq_f32(even_values, even_mask);\n        odd_values = vaddq_f32(odd_values, odd_mask);\n\n        mask = vrev64q_f32(mask);\n    }\n\n    std::vector<float> even_vec;\n    for (int i = 0; i < n; i += 2) {\n        even_vec.push_back(l[i]);\n    }\n    std::sort(even_vec.begin(), even_vec.end());\n\n    for (int i = 0, j = 0; i < n; i += 2, j++) {\n        l[i] = even_vec[j];\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t vec_even = vdupq_n_f32(0.0f);\n    float32x4_t vec_odd = vdupq_n_f32(0.0f);\n    std::vector<float> even_values;\n\n    for (int i = 0; i < n; i += 4) {\n        vec_even = vld1q_f32(&l[i]);\n        vec_odd = vld1q_f32(&l[i + 1]);\n\n        float32x4_t even_mask = vsetq_lane_f32(1.0f, vdupq_n_f32(0.0f), 0);\n        even_mask = vsetq_lane_f32(1.0f, even_mask, 2);\n\n        float32x4_t even_values_vec = vmulq_f32(vec_even, even_mask);\n        even_values.push_back(vgetq_lane_f32(even_values_vec, 0));\n        even_values.push_back(vgetq_lane_f32(even_values_vec, 2));\n    }\n\n    std::sort(even_values.begin(), even_values.end());\n\n    int even_index = 0;\n    for (int i = 0; i < n; i += 4) {\n        vec_even = vld1q_f32(&l[i]);\n        vec_odd = vld1q_f32(&l[i + 1]);\n\n        vec_even = vsetq_lane_f32(even_values[even_index++], vec_even, 0);\n        vec_even = vsetq_lane_f32(even_values[even_index++], vec_even, 2);\n\n        vst1q_f32(&l[i], vec_even);\n        vst1q_f32(&l[i + 1], vec_odd);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; ++j) {\n            int32x4_t b = vdupq_n_s32(l[j]);\n            int32x4_t sum_ab = vaddq_s32(a, b);\n            for (int k = j + 1; k < n; k += 4) {\n                int32x4_t c = vld1q_s32(&l[k]);\n                int32x4_t sum_abc = vaddq_s32(sum_ab, c);\n                uint32x4_t mask = vceqq_s32(sum_abc, vdupq_n_s32(0));\n                if (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 0) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 1) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 2) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; ++j) {\n            int32x4_t b = vdupq_n_s32(l[j]);\n            int32x4_t sum_ab = vaddq_s32(a, b);\n\n            int k = j + 1;\n            for (; k <= n - 4; k += 4) {\n                int32x4_t c = vld1q_s32(&l[k]);\n                uint32x4_t mask = vceqq_s32(sum_ab, vnegq_s32(c));\n                if (vmaxvq_u32(mask) != 0) return true;\n            }\n\n            for (; k < n; ++k) {\n                if (l[i] + l[j] + l[k] == 0) return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```c++\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; ++j) {\n            int32x4_t b = vdupq_n_s32(l[j]);\n            int32x4_t sum_ab = vaddq_s32(a, b);\n\n            for (int k = j + 1; k < n; k += 4) {\n                int32x4_t c = vld1q_s32(&l[k]);\n                int32x4_t sum_abc = vaddq_s32(sum_ab, c);\n                uint32x4_t mask = vceqq_s32(sum_abc, vdupq_n_s32(0));\n\n                if (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 0) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 1) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 2) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        int32x4_t a = vdupq_n_s32(l[i]);\n        for (int j = i + 1; j < n - 1; ++j) {\n            int32x4_t b = vdupq_n_s32(l[j]);\n            int32x4_t sum_ab = vaddq_s32(a, b);\n\n            for (int k = j + 1; k < n; k += 4) {\n                int32x4_t c = vld1q_s32(&l[k]);\n                int32x4_t sum_abc = vaddq_s32(sum_ab, c);\n                uint32x4_t mask = vceqq_s32(sum_abc, vdupq_n_s32(0));\n\n                if (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 0) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 1) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 2) ||\n                    vgetq_lane_u32(vreinterpretq_u32_s32(mask), 3)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int32x4_t a = vdupq_n_s32(l[i]);\n            int32x4_t b = vdupq_n_s32(l[j]);\n            int32x4_t c = vld1q_s32(&l[j + 1]);\n\n            int32x4_t sum = vaddq_s32(a, b);\n            sum = vaddq_s32(sum, c);\n\n            uint32x4_t mask = vceqq_s32(sum, vdupq_n_s32(0));\n            if (vgetq_lane_u32(vreinterpretq_u32_s32(mask), 0) ||\n                vgetq_lane_u32(vreinterpretq_u32_s32(mask), 1) ||\n                vgetq_lane_u32(vreinterpretq_u32_s32(mask), 2) ||\n                vgetq_lane_u32(vreinterpretq_u32_s32(mask), 3)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int32x4_t increment = vdupq_n_s32(1);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, increment);\n        vst1q_s32(&l[i], vec);\n    }\n\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int32x4_t increment = vdupq_n_s32(1);\n    size_t size = l.size();\n    size_t i;\n\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, increment);\n        vst1q_s32(&l[i], vec);\n    }\n\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int32x4_t increment = vdupq_n_s32(1);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, increment);\n        vst1q_s32(&l[i], vec);\n    }\n\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int32x4_t increment = vdupq_n_s32(1);\n    size_t size = l.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, increment);\n        vst1q_s32(&l[i], vec);\n    }\n\n    for (; i < size; ++i) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```c++\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int32x4_t increment = vdupq_n_s32(1);\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        vec = vaddq_s32(vec, increment);\n        vst1q_s32(&l[i], vec);\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(const std::vector<int>& l) {\n    const int size = l.size();\n    if (size < 2) return false;\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < size; j += 4) {\n            int32x4_t vec_b = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(vec_a, vec_b);\n            uint32x4_t zero_mask = vceqq_s32(sum, vdupq_n_s32(0));\n            if (vmaxvq_u32(zero_mask) != 0) return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    const int size = l.size();\n    if (size < 2) return false;\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < size; j += 4) {\n            int32x4_t vec2 = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(vec1, vec2);\n            uint32x4_t zero_mask = vceqq_s32(sum, vdupq_n_s32(0));\n            if (vmaxvq_u32(zero_mask) != 0) return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    const int size = l.size();\n    if (size < 2) return false;\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < size; j += 4) {\n            int32x4_t vec_b = vld1q_s32(&l[j]);\n            int32x4_t neg_b = vnegq_s32(vec_b);\n            uint32x4_t cmp = vceqq_s32(vec_a, neg_b);\n            if (vaddvq_u32(cmp) > 0) return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```c++\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    const int size = l.size();\n    if (size < 2) return false;\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < size; j += 4) {\n            int32x4_t vec2 = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(vec1, vec2);\n            uint32x4_t zero_mask = vceqq_s32(sum, vdupq_n_s32(0));\n            if (vmaxvq_u32(zero_mask) != 0) return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t vec_a = vld1q_s32(&l[i]);\n        for (int j = i + 4; j < n; j += 4) {\n            int32x4_t vec_b = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(vec_a, vec_b);\n            uint32x4_t zero_mask = vceqq_s32(sum, vdupq_n_s32(0));\n            if (vmaxvq_u32(zero_mask) != 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int64x2_t x_vec = vdupq_n_s64(x);\n\n    while (x > 0) {\n        int64x2_t remainder_vec = vdivq_s64(x_vec, base_vec);\n        int64x2_t quotient_vec = vsubq_s64(x_vec, vmulq_s64(remainder_vec, base_vec));\n        int64_t remainder = vgetq_lane_s64(remainder_vec, 0);\n        result = std::to_string(remainder) + result;\n        x_vec = quotient_vec;\n        x = vgetq_lane_s64(x_vec, 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int64x2_t x_vec = vdupq_n_s64(x);\n\n    while (x > 0) {\n        int64x2_t quotient = vdivq_s64(x_vec, base_vec);\n        int64x2_t remainder = vsubq_s64(x_vec, vmulq_s64(quotient, base_vec));\n\n        int64_t rem = vgetq_lane_s64(remainder, 0);\n        result = std::to_string(rem) + result;\n\n        x_vec = quotient;\n        x = vgetq_lane_s64(x_vec, 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int8x16_t zero_vec = vdupq_n_s8(0);\n    int8x16_t digit_vec = vdupq_n_s8(0);\n\n    while (x > 0) {\n        int64_t remainder = x % base;\n        x /= base;\n\n        digit_vec = vsetq_lane_s8(remainder + '0', digit_vec, 0);\n\n        if (x == 0) {\n            break;\n        }\n\n        digit_vec = vextq_s8(digit_vec, zero_vec, 1);\n    }\n\n    for (int i = 0; i < 16; ++i) {\n        char digit = vgetq_lane_s8(digit_vec, i);\n        if (digit != 0) {\n            result += digit;\n        }\n    }\n\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    int8_t digits[64];\n    int count = 0;\n\n    while (x > 0) {\n        digits[count++] = x % base;\n        x /= base;\n    }\n\n    for (int i = count - 1; i >= 0; --i) {\n        result += '0' + digits[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    std::string result;\n    int8x16_t base_vec = vdupq_n_s8(base);\n    int64x2_t x_vec = vdupq_n_s64(x);\n\n    while (x > 0) {\n        int64x2_t remainder_vec = vdivq_s64(x_vec, base_vec);\n        int64x2_t quotient_vec = vsubq_s64(x_vec, vmulq_s64(remainder_vec, base_vec));\n        int64_t remainder = vgetq_lane_s64(remainder_vec, 0);\n        x = vgetq_lane_s64(quotient_vec, 0);\n        result = std::to_string(remainder) + result;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    const char* str = text.c_str();\n    int len = text.length();\n    int i = 0;\n\n    while (i <= len - 16) {\n        uint8x16_t vec1 = vld1q_u8((const uint8_t*)(str + i));\n        uint8x16_t vec2 = vld1q_u8((const uint8_t*)(str + len - i - 16));\n        uint8x16_t rev_vec2 = vrev64q_u8(vec2);\n\n        if (vminvq_u8(vceqq_u8(vec1, rev_vec2)) != 0xFF) {\n            return false;\n        }\n        i += 16;\n    }\n\n    while (i < len) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n        i++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n\n    for (size_t i = 0; i < len / 2; i += 16) {\n        uint8x16_t left = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t right = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + len - i - 16));\n\n        uint8x16_t reversed_right = vrev64q_u8(right);\n\n        if (vminvq_u8(vceqq_u8(left, reversed_right)) != 0xFF) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    int len = text.length();\n    if (len == 0) return true;\n\n    int i = 0;\n    int j = len - 1;\n\n    while (i < j) {\n        uint8x16_t vec1 = vld1q_u8(reinterpret_cast<const uint8_t*>(&text[i]));\n        uint8x16_t vec2 = vld1q_u8(reinterpret_cast<const uint8_t*>(&text[j]));\n\n        uint8x16_t cmp = vceqq_u8(vec1, vec2);\n        uint8x16_t mask = vandq_u8(cmp, vdupq_n_u8(0xFF));\n\n        if (vaddvq_u8(mask) != 16 * 0xFF) {\n            return false;\n        }\n\n        i += 16;\n        j -= 16;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    const char* str = text.c_str();\n    int len = text.length();\n    int i = 0;\n\n    while (i <= len - 16) {\n        uint8x16_t vec1 = vld1q_u8((const uint8_t*)(str + i));\n        uint8x16_t vec2 = vld1q_u8((const uint8_t*)(str + len - i - 16));\n        uint8x16_t rev_vec2 = vrev64q_u8(vec2);\n\n        if (vminvq_u8(vceqq_u8(vec1, rev_vec2)) != 0xFF) {\n            return false;\n        }\n        i += 16;\n    }\n\n    while (i < len) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n        i++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\nbool is_palindrome_simd(std::string text) {\n    const char* str = text.c_str();\n    size_t len = text.length();\n    size_t i = 0;\n\n    while (i + 16 <= len) {\n        uint8x16_t left = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t right = vld1q_u8(reinterpret_cast<const uint8_t*>(str + len - i - 16));\n        uint8x16_t reversed_right = vrev64q_u8(right);\n\n        if (vminvq_u8(vceqq_u8(left, reversed_right)) != 0xFF) {\n            return false;\n        }\n        i += 16;\n    }\n\n    while (i < len) {\n        if (str[i] != str[len - i - 1]) {\n            return false;\n        }\n        i++;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int i;\n    int len = s.length();\n    int remainder = len % 16;\n\n    for (i = 0; i < len - remainder; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(5);\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t z = vdupq_n_u8('z');\n\n        uint8x16_t decoded = vsubq_u8(input, shift);\n        uint8x16_t mask = vcgeq_u8(decoded, a);\n        decoded = vbslq_u8(mask, decoded, vaddq_u8(decoded, vdupq_n_u8(26)));\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    for (i = len - remainder; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int i;\n    int len = s.length();\n    int remainder = len % 16;\n\n    for (i = 0; i < len - remainder; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(5);\n        uint8x16_t base = vdupq_n_u8('a');\n        uint8x16_t result = vsubq_u8(input, shift);\n        result = vsubq_u8(result, base);\n        result = vaddq_u8(result, vdupq_n_u8(26));\n        result = vremq_u8(result, vdupq_n_u8(26));\n        result = vaddq_u8(result, base);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), result);\n    }\n\n    for (i = len - remainder; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int i;\n    int len = s.length();\n    int remainder = len % 16;\n\n    for (i = 0; i < len - remainder; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(5);\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t z = vdupq_n_u8('z');\n\n        uint8x16_t decoded = vsubq_u8(input, shift);\n        uint8x16_t mask = vcgeq_u8(decoded, a);\n        decoded = vbslq_u8(mask, decoded, vsubq_u8(decoded, vdupq_n_u8(26)));\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    for (i = len - remainder; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int i;\n    int len = s.length();\n    int remainder = len % 16;\n\n    for (i = 0; i < len - remainder; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(5);\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t z = vdupq_n_u8('z');\n\n        uint8x16_t decoded = vsubq_u8(input, shift);\n        uint8x16_t mask = vcgeq_u8(decoded, a);\n        decoded = vbslq_u8(mask, decoded, vsubq_u8(vaddq_u8(decoded, vdupq_n_u8(26)), shift));\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    for (i = len - remainder; i < len; i++) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out(s.length(), ' ');\n    int length = s.length();\n    int i;\n\n    for (i = 0; i <= length - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t offset = vdupq_n_u8(5);\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t z = vdupq_n_u8('z');\n\n        uint8x16_t decoded = vsubq_u8(input, offset);\n        uint8x16_t mask = vcgeq_u8(decoded, a);\n        decoded = vbslq_u8(mask, decoded, vsubq_u8(vaddq_u8(decoded, vdupq_n_u8(26)), offset));\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&out[i]), decoded);\n    }\n\n    for (; i < length; ++i) {\n        int w = ((int)s[i] - 5 - (int)'a' + 26) % 26 + (int)'a';\n        out[i] = (char)w;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    bool result = true;\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcgeq_s32(vec, threshold);\n        uint32_t mask = vaddvq_u32(cmp);\n        if (mask != 0) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    bool result = true;\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcgeq_s32(vec, threshold);\n        uint32x4_t any_above = vorrq_u32(cmp, cmp);\n        if (vgetq_lane_u32(any_above, 0) != 0) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    bool result = true;\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcgeq_s32(vec, threshold);\n        uint32x4_t any_above = vorrq_u32(cmp, cmp);\n        if (vgetq_lane_u32(any_above, 0) != 0) {\n            result = false;\n            break;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\nbool below_threshold_simd(std::vector<int> l, int t) {\n    const int* data = l.data();\n    int size = l.size();\n    int i = 0;\n\n    int32x4_t threshold = vdupq_n_s32(t);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(data + i);\n        uint32x4_t result = vcgeq_s32(vec, threshold);\n        if (vmaxvq_u32(result) != 0) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```c++\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int32x4_t threshold = vdupq_n_s32(t);\n    bool result = true;\n\n    for (size_t i = 0; i < l.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcgeq_s32(vec, threshold);\n        result &= (vmaxvq_u32(cmp) == 0);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t count = 0;\n    const char* str = brackets.c_str();\n    size_t len = brackets.length();\n\n    // Process 16 characters at a time\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32_t open_count = vaddvq_s32(vreinterpretq_s32_u8(open_mask));\n        int32_t close_count = vaddvq_s32(vreinterpretq_s32_u8(close_mask));\n\n        count += open_count - close_count;\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (size_t i = (len / 16) * 16; i < len; ++i) {\n        if (brackets[i] == '<') {\n            ++count;\n        } else if (brackets[i] == '>') {\n            --count;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    const char* data = brackets.c_str();\n    size_t length = brackets.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32x4_t open_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(open_mask)));\n        int32x4_t close_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(close_mask)));\n\n        balance += vgetq_lane_s32(open_count, 0) - vgetq_lane_s32(close_count, 0);\n        balance += vgetq_lane_s32(open_count, 1) - vgetq_lane_s32(close_count, 1);\n        balance += vgetq_lane_s32(open_count, 2) - vgetq_lane_s32(close_count, 2);\n        balance += vgetq_lane_s32(open_count, 3) - vgetq_lane_s32(close_count, 3);\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (data[i] == '<') {\n            ++balance;\n        } else if (data[i] == '>') {\n            --balance;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    const char* data = brackets.c_str();\n    size_t length = brackets.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32x4_t open_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(open_mask)));\n        int32x4_t close_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(close_mask)));\n\n        balance += vaddvq_s32(open_count) - vaddvq_s32(close_count);\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (data[i] == '<') {\n            ++balance;\n        } else if (data[i] == '>') {\n            --balance;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    const char* data = brackets.c_str();\n    size_t length = brackets.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i <= length - 16; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32x4_t open_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(open_mask)));\n        int32x4_t close_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(close_mask)));\n\n        balance += vgetq_lane_s32(open_count, 0) - vgetq_lane_s32(close_count, 0);\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (data[i] == '<') {\n            ++balance;\n        } else if (data[i] == '>') {\n            --balance;\n        }\n        if (balance < 0) return false;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t count = 0;\n    const char* str = brackets.c_str();\n    size_t len = brackets.length();\n\n    for (size_t i = 0; i < len; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        uint8x16_t open_bracket = vdupq_n_u8('<');\n        uint8x16_t close_bracket = vdupq_n_u8('>');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32x4_t open_count = vpaddlq_s32(vpaddlq_s16(vpaddlq_s8(vreinterpretq_s8_u8(open_mask))));\n        int32x4_t close_count = vpaddlq_s32(vpaddlq_s16(vpaddlq_s8(vreinterpretq_s8_u8(close_mask))));\n\n        count += vgetq_lane_s32(open_count, 0) - vgetq_lane_s32(close_count, 0);\n        if (count < 0) {\n            return false;\n        }\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t count = 0;\n    int32x4_t vcount = vdupq_n_s32(0);\n    int32x4_t vone = vdupq_n_s32(1);\n    int32x4_t vnegone = vdupq_n_s32(-1);\n\n    for (size_t i = 0; i < brackets.size(); i += 4) {\n        uint8x16_t vbrackets = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.data() + i));\n        uint8x16_t vopen = vdupq_n_u8('(');\n        uint8x16_t vclose = vdupq_n_u8(')');\n\n        uint8x16_t vopen_mask = vceqq_u8(vbrackets, vopen);\n        uint8x16_t vclose_mask = vceqq_u8(vbrackets, vclose);\n\n        int32x4_t vopen_count = vpaddlq_s16(vpaddlq_s8(vreinterpretq_s8_u8(vopen_mask)));\n        int32x4_t vclose_count = vpaddlq_s16(vpaddlq_s8(vreinterpretq_s8_u8(vclose_mask)));\n\n        vcount = vaddq_s32(vcount, vsubq_s32(vopen_count, vclose_count));\n    }\n\n    count = vaddvq_s32(vcount);\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.size();\n    int32x4_t open_count = vdupq_n_s32(0);\n    int32x4_t close_count = vdupq_n_s32(0);\n    int32x4_t open_bracket = vdupq_n_s32('(');\n    int32x4_t close_bracket = vdupq_n_s32(')');\n\n    for (int i = 0; i < len; i += 4) {\n        int32x4_t chunk = vld1q_s32(reinterpret_cast<const int32_t*>(brackets.data() + i));\n        uint32x4_t open_mask = vceqq_s32(chunk, open_bracket);\n        uint32x4_t close_mask = vceqq_s32(chunk, close_bracket);\n\n        open_count = vaddq_s32(open_count, vreinterpretq_s32_u32(vandq_u32(open_mask, vdupq_n_u32(1))));\n        close_count = vaddq_s32(close_count, vreinterpretq_s32_u32(vandq_u32(close_mask, vdupq_n_u32(1))));\n    }\n\n    int32_t open_sum = vaddvq_s32(open_count);\n    int32_t close_sum = vaddvq_s32(close_count);\n\n    return open_sum == close_sum;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    const char* data = brackets.c_str();\n    size_t length = brackets.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t open_bracket = vdupq_n_u8('(');\n        uint8x16_t close_bracket = vdupq_n_u8(')');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32x4_t open_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(open_mask)));\n        int32x4_t close_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(close_mask)));\n\n        balance += vgetq_lane_s32(open_count, 0) - vgetq_lane_s32(close_count, 0);\n        if (balance < 0) return false;\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (data[i] == '(') {\n            ++balance;\n        } else if (data[i] == ')') {\n            --balance;\n            if (balance < 0) return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t balance = 0;\n    const char* data = brackets.c_str();\n    size_t length = brackets.length();\n    size_t i = 0;\n\n    // Process 16 characters at a time\n    for (; i + 16 <= length; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t open_bracket = vdupq_n_u8('(');\n        uint8x16_t close_bracket = vdupq_n_u8(')');\n\n        uint8x16_t open_mask = vceqq_u8(vec, open_bracket);\n        uint8x16_t close_mask = vceqq_u8(vec, close_bracket);\n\n        int32x4_t open_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(open_mask)));\n        int32x4_t close_count = vpaddlq_s32(vpaddlq_s16(vreinterpretq_s16_u8(close_mask)));\n\n        balance += vgetq_lane_s32(open_count, 0) - vgetq_lane_s32(close_count, 0);\n        balance += vgetq_lane_s32(open_count, 2) - vgetq_lane_s32(close_count, 2);\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    // Process remaining characters\n    for (; i < length; ++i) {\n        if (data[i] == '(') {\n            ++balance;\n        } else if (data[i] == ')') {\n            --balance;\n        }\n\n        if (balance < 0) {\n            return false;\n        }\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int len = brackets.size();\n    if (len % 16 != 0) {\n        len += 16 - (len % 16);\n    }\n\n    int16x8_t open_bracket = vdupq_n_s16('(');\n    int16x8_t close_bracket = vdupq_n_s16(')');\n    int16x8_t zero = vdupq_n_s16(0);\n    int16x8_t one = vdupq_n_s16(1);\n\n    int16x8_t count = zero;\n\n    for (int i = 0; i < len; i += 16) {\n        int16x8_t chunk1 = vld1q_s16(reinterpret_cast<const int16_t*>(brackets.data() + i));\n        int16x8_t chunk2 = vld1q_s16(reinterpret_cast<const int16_t*>(brackets.data() + i + 8));\n\n        int16x8_t open_count1 = vceqq_s16(chunk1, open_bracket);\n        int16x8_t close_count1 = vceqq_s16(chunk1, close_bracket);\n        int16x8_t open_count2 = vceqq_s16(chunk2, open_bracket);\n        int16x8_t close_count2 = vceqq_s16(chunk2, close_bracket);\n\n        count = vaddq_s16(count, open_count1);\n        count = vsubq_s16(count, close_count1);\n        count = vaddq_s16(count, open_count2);\n        count = vsubq_s16(count, close_count2);\n\n        int16x8_t mask1 = vcltq_s16(count, zero);\n        int16x8_t mask2 = vcltq_s16(count, zero);\n\n        if (vaddvq_s16(mask1) || vaddvq_s16(mask2)) {\n            return false;\n        }\n    }\n\n    int16x8_t final_count = vpaddq_s16(count, count);\n    final_count = vpaddq_s16(final_count, final_count);\n    final_count = vpaddq_s16(final_count, final_count);\n\n    return vgetq_lane_s16(final_count, 0) == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, indices, prod;\n    float32x4_t ones = vdupq_n_f32(1.0f);\n    float32x4_t inc = vdupq_n_f32(4.0f);\n    float32x4_t index = vsetq_lane_f32(1.0f, vdupq_n_f32(0.0f), 0);\n    index = vsetq_lane_f32(2.0f, index, 1);\n    index = vsetq_lane_f32(3.0f, index, 2);\n    index = vsetq_lane_f32(4.0f, index, 3);\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        coeffs = vld1q_f32(&xs[i]);\n        indices = vaddq_f32(index, ones);\n        prod = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i - 1], prod);\n        index = vaddq_f32(index, inc);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, indices, prod;\n    float32x4_t ones = vdupq_n_f32(1.0f);\n    float32x4_t inc = vdupq_n_f32(4.0f);\n    float32x4_t index = vsetq_lane_f32(1.0f, index, 0);\n    index = vsetq_lane_f32(2.0f, index, 1);\n    index = vsetq_lane_f32(3.0f, index, 2);\n    index = vsetq_lane_f32(4.0f, index, 3);\n\n    for (size_t i = 1; i < xs.size(); i += 4) {\n        coeffs = vld1q_f32(&xs[i]);\n        indices = vaddq_f32(index, ones);\n        prod = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i - 1], prod);\n        index = vaddq_f32(index, inc);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, indices, products;\n    float32x4_t ones = vdupq_n_f32(1.0f);\n    float32x4_t inc = vdupq_n_f32(4.0f);\n\n    for (size_t i = 0; i < xs.size() - 3; i += 4) {\n        coeffs = vld1q_f32(&xs[i + 1]);\n        indices = vaddq_f32(ones, vdupq_n_f32(static_cast<float>(i)));\n        products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n        ones = vaddq_f32(ones, inc);\n    }\n\n    for (size_t i = (xs.size() - 1) & ~3; i < xs.size() - 1; ++i) {\n        result[i] = xs[i + 1] * (i + 1);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    std::vector<float> result(n - 1);\n\n    for (int i = 0; i < n - 1; i += 4) {\n        float32x4_t coeffs = vld1q_f32(&xs[i]);\n        float32x4_t indices = {i + 1, i + 2, i + 3, i + 4};\n        float32x4_t products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i], products);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    std::vector<float> result(xs.size() - 1);\n    float32x4_t coeffs, indices, products;\n    float32x4_t ones = vdupq_n_f32(1.0f);\n    float32x4_t index = vdupq_n_f32(1.0f);\n\n    for (size_t i = 1; i < xs.size(); ++i) {\n        coeffs = vld1q_f32(&xs[i]);\n        indices = vaddq_f32(index, ones);\n        products = vmulq_f32(coeffs, indices);\n        vst1q_f32(&result[i - 1], products);\n        index = vaddq_f32(index, vdupq_n_f32(4.0f));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('a');\n    uint8x16_t vowels_mask = vdupq_n_u8(0);\n\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('y', vowels, 5);\n    vowels = vsetq_lane_u8('A', vowels, 6);\n    vowels = vsetq_lane_u8('E', vowels, 7);\n    vowels = vsetq_lane_u8('I', vowels, 8);\n    vowels = vsetq_lane_u8('O', vowels, 9);\n    vowels = vsetq_lane_u8('U', vowels, 10);\n    vowels = vsetq_lane_u8('Y', vowels, 11);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t cmp = vceqq_u8(chunk, vowels);\n        vowels_mask = vorrq_u8(vowels_mask, cmp);\n    }\n\n    uint8x16_t sum = vpaddq_u8(vowels_mask, vowels_mask);\n    sum = vpaddq_u8(sum, sum);\n    sum = vpaddq_u8(sum, sum);\n\n    uint8_t result[16];\n    vst1q_u8(result, sum);\n\n    for (int i = 0; i < 16; ++i) {\n        count += result[i];\n    }\n\n    if (len > 0 && str[len - 1] == 'y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('a');\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('A', vowels, 5);\n    vowels = vsetq_lane_u8('E', vowels, 6);\n    vowels = vsetq_lane_u8('I', vowels, 7);\n    vowels = vsetq_lane_u8('O', vowels, 8);\n    vowels = vsetq_lane_u8('U', vowels, 9);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t mask = vceqq_u8(chunk, vowels);\n        count += vaddvq_u8(vandq_u8(mask, vdupq_n_u8(1)));\n    }\n\n    if (len > 0 && str[len - 1] == 'y' || str[len - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('a');\n    uint8x16_t vowels_upper = vdupq_n_u8('A');\n    uint8x16_t y_vowel = vdupq_n_u8('y');\n    uint8x16_t y_vowel_upper = vdupq_n_u8('Y');\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n\n        uint8x16_t is_a = vceqq_u8(chunk, vowels);\n        uint8x16_t is_e = vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('e' - 'a')));\n        uint8x16_t is_i = vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('i' - 'a')));\n        uint8x16_t is_o = vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('o' - 'a')));\n        uint8x16_t is_u = vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('u' - 'a')));\n\n        uint8x16_t is_A = vceqq_u8(chunk, vowels_upper);\n        uint8x16_t is_E = vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('E' - 'A')));\n        uint8x16_t is_I = vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('I' - 'A')));\n        uint8x16_t is_O = vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('O' - 'A')));\n        uint8x16_t is_U = vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('U' - 'A')));\n\n        uint8x16_t is_y = vceqq_u8(chunk, y_vowel);\n        uint8x16_t is_Y = vceqq_u8(chunk, y_vowel_upper);\n\n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_a, is_e), is_i), is_o), is_u),\n                                       vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_A, is_E), is_I), is_O), is_U));\n\n        if (i + 16 >= len && len > 0 && (str[len - 1] == 'y' || str[len - 1] == 'Y')) {\n            is_vowel = vorrq_u8(is_vowel, is_y);\n            is_vowel = vorrq_u8(is_vowel, is_Y);\n        }\n\n        count += vaddvq_u8(vandq_u8(is_vowel, vdupq_n_u8(1)));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('a');\n    uint8x16_t vowels_upper = vdupq_n_u8('A');\n    uint8x16_t y_vowel = vdupq_n_u8('y');\n    uint8x16_t y_vowel_upper = vdupq_n_u8('Y');\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t is_vowel = vorrq_u8(\n            vorrq_u8(\n                vorrq_u8(\n                    vorrq_u8(\n                        vceqq_u8(chunk, vowels),\n                        vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('e' - 'a')))\n                    ),\n                    vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('i' - 'a')))\n                ),\n                vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('o' - 'a')))\n            ),\n            vceqq_u8(chunk, vaddq_u8(vowels, vdupq_n_u8('u' - 'a')))\n        );\n\n        uint8x16_t is_vowel_upper = vorrq_u8(\n            vorrq_u8(\n                vorrq_u8(\n                    vorrq_u8(\n                        vceqq_u8(chunk, vowels_upper),\n                        vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('E' - 'A')))\n                    ),\n                    vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('I' - 'A')))\n                ),\n                vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('O' - 'A')))\n            ),\n            vceqq_u8(chunk, vaddq_u8(vowels_upper, vdupq_n_u8('U' - 'A')))\n        );\n\n        uint8x16_t is_y_vowel = vandq_u8(vceqq_u8(chunk, y_vowel), vdupq_n_u8((i + 15 < len) ? 0 : 1));\n        uint8x16_t is_y_vowel_upper = vandq_u8(vceqq_u8(chunk, y_vowel_upper), vdupq_n_u8((i + 15 < len) ? 0 : 1));\n\n        uint8x16_t is_vowel_total = vorrq_u8(vorrq_u8(is_vowel, is_vowel_upper), vorrq_u8(is_y_vowel, is_y_vowel_upper));\n\n        count += vaddvq_u8(is_vowel_total);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('a');\n    vowels = vsetq_lane_u8('e', vowels, 1);\n    vowels = vsetq_lane_u8('i', vowels, 2);\n    vowels = vsetq_lane_u8('o', vowels, 3);\n    vowels = vsetq_lane_u8('u', vowels, 4);\n    vowels = vsetq_lane_u8('y', vowels, 5);\n    vowels = vsetq_lane_u8('A', vowels, 6);\n    vowels = vsetq_lane_u8('E', vowels, 7);\n    vowels = vsetq_lane_u8('I', vowels, 8);\n    vowels = vsetq_lane_u8('O', vowels, 9);\n    vowels = vsetq_lane_u8('U', vowels, 10);\n    vowels = vsetq_lane_u8('Y', vowels, 11);\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t mask = vceqq_u8(chunk, vowels);\n        uint8x16_t result = vandq_u8(mask, vdupq_n_u8(1));\n        count += vaddvq_u8(result);\n    }\n\n    if (len > 0 && str[len - 1] == 'y' || str[len - 1] == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcleq_u8(chars, vdupq_n_u8('Z')));\n        uint8x16_t upper_chars = vandq_u8(chars, upper_mask);\n\n        // Sum the ASCII values of the upper characters\n        uint8x16_t ascii_values = vpaddq_u8(upper_chars, vdupq_n_u8(0));\n        ascii_values = vpaddq_u8(ascii_values, vdupq_n_u8(0));\n        sum += vgetq_lane_u8(ascii_values, 0) + vgetq_lane_u8(ascii_values, 1);\n    }\n\n    // Process remaining characters\n    for (int i = (length / 16) * 16; i < length; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += str[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    // Process 16 characters at a time\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8((const uint8_t*)(str + i));\n        uint8x16_t upper_mask = vandq_u8(chars, vdupq_n_u8(0x20));\n        uint8x16_t is_upper = vceqq_u8(upper_mask, chars);\n        uint8x16_t ascii_values = vandq_u8(chars, is_upper);\n        uint8x16_t sum_vector = vpaddq_u8(vpaddq_u8(ascii_values, ascii_values), vpaddq_u8(ascii_values, ascii_values));\n        sum += vaddvq_u8(sum_vector);\n    }\n\n    // Process remaining characters\n    for (int i = (length / 16) * 16; i < length; ++i) {\n        if (isupper(str[i])) {\n            sum += str[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t upper_mask = vcgeq_u8(chars, vdupq_n_u8('A'));\n        upper_mask = vandq_u8(upper_mask, vcleq_u8(chars, vdupq_n_u8('Z')));\n        uint8x16_t upper_chars = vandq_u8(chars, upper_mask);\n\n        uint8x8_t lower_half = vget_low_u8(upper_chars);\n        uint8x8_t upper_half = vget_high_u8(upper_chars);\n\n        sum += vaddv_u8(lower_half);\n        sum += vaddv_u8(upper_half);\n    }\n\n    for (int i = (length / 16) * 16; i < length; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += str[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    for (int i = 0; i <= length - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t upper_mask = vcgtq_u8(chars, vdupq_n_u8('A' - 1));\n        upper_mask = vandq_u8(upper_mask, vcleq_u8(chars, vdupq_n_u8('Z')));\n        uint8x16_t ascii_values = vandq_u8(chars, upper_mask);\n        sum += vaddvq_u8(ascii_values);\n    }\n\n    for (int i = (length / 16) * 16; i < length; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += str[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    int sum = 0;\n    const char* str = s.c_str();\n    int len = s.length();\n\n    uint8x16_t upper_bound = vdupq_n_u8('Z');\n    uint8x16_t lower_bound = vdupq_n_u8('A');\n    uint8x16_t sum_vec = vdupq_n_u8(0);\n\n    for (int i = 0; i <= len - 16; i += 16) {\n        uint8x16_t chars = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t is_upper = vcgeq_u8(vcgeq_u8(chars, lower_bound), upper_bound);\n        uint8x16_t upper_chars = vandq_u8(chars, is_upper);\n        sum_vec = vaddq_u8(sum_vec, upper_chars);\n    }\n\n    uint8x8_t sum_vec_low = vget_low_u8(sum_vec);\n    uint8x8_t sum_vec_high = vget_high_u8(sum_vec);\n    sum_vec_low = vadd_u8(sum_vec_low, sum_vec_high);\n    sum_vec_low = vpadd_u8(sum_vec_low, sum_vec_low);\n    sum_vec_low = vpadd_u8(sum_vec_low, sum_vec_low);\n    sum += vget_lane_u8(sum_vec_low, 0);\n\n    for (int i = (len / 16) * 16; i < len; ++i) {\n        if (str[i] >= 'A' && str[i] <= 'Z') {\n            sum += str[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int32x4_t min_even = vdupq_n_s32(INT_MAX);\n    int32x4_t min_index = vdupq_n_s32(INT_MAX);\n    int32x4_t even_mask = vdupq_n_s32(0x1);\n    int32x4_t index_offset = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t indices = vaddq_s32(index_offset, vdupq_n_s32(i));\n\n        int32x4_t is_even = vandq_s32(values, even_mask);\n        is_even = vceqq_s32(is_even, vdupq_n_s32(0));\n\n        int32x4_t even_values = vbslq_s32(is_even, values, vdupq_n_s32(INT_MAX));\n        int32x4_t even_indices = vbslq_s32(is_even, indices, vdupq_n_s32(INT_MAX));\n\n        min_even = vminq_s32(min_even, even_values);\n        min_index = vminq_s32(min_index, even_indices);\n\n        index_offset = vaddq_s32(index_offset, vdupq_n_s32(4));\n    }\n\n    int32_t min_even_arr[4];\n    int32_t min_index_arr[4];\n    vst1q_s32(min_even_arr, min_even);\n    vst1q_s32(min_index_arr, min_index);\n\n    int min_value = INT_MAX;\n    int min_idx = INT_MAX;\n    for (int i = 0; i < 4; ++i) {\n        if (min_even_arr[i] < min_value) {\n            min_value = min_even_arr[i];\n            min_idx = min_index_arr[i];\n        }\n    }\n\n    if (min_value == INT_MAX) {\n        return {};\n    }\n\n    return {min_value, min_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return {};\n\n    int min_even = INT_MAX;\n    int min_index = -1;\n\n    int32x4_t min_even_vec = vdupq_n_s32(INT_MAX);\n    int32x4_t min_index_vec = vdupq_n_s32(-1);\n    int32x4_t index_vec = {0, 1, 2, 3};\n\n    for (int i = 0; i <= n - 4; i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t even_mask = vcgeq_s32(vandq_s32(values, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t even_values = vandq_s32(values, even_mask);\n        int32x4_t is_min_even = vcltq_s32(even_values, min_even_vec);\n        min_even_vec = vbslq_s32(is_min_even, even_values, min_even_vec);\n        min_index_vec = vbslq_s32(is_min_even, index_vec, min_index_vec);\n        index_vec = vaddq_s32(index_vec, vdupq_n_s32(4));\n    }\n\n    int32_t min_even_arr[4];\n    int32_t min_index_arr[4];\n    vst1q_s32(min_even_arr, min_even_vec);\n    vst1q_s32(min_index_arr, min_index_vec);\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_even_arr[i] < min_even) {\n            min_even = min_even_arr[i];\n            min_index = min_index_arr[i];\n        }\n    }\n\n    for (int i = n - (n % 4); i < n; ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < min_even) {\n            min_even = arr[i];\n            min_index = i;\n        }\n    }\n\n    if (min_index == -1) return {};\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT_MAX);\n    int32x4_t min_idx = vdupq_n_s32(INT_MAX);\n    int32x4_t indices = {0, 1, 2, 3};\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t even_mask = vcgeq_s32(vandq_s32(values, vdupq_n_s32(1)), vdupq_n_s32(0));\n        int32x4_t even_values = vandq_s32(values, even_mask);\n        int32x4_t even_indices = vandq_s32(indices, even_mask);\n\n        uint32x4_t cmp = vcltq_s32(even_values, min_val);\n        min_val = vbslq_s32(cmp, even_values, min_val);\n        min_idx = vbslq_s32(cmp, even_indices, min_idx);\n\n        indices = vaddq_s32(indices, vdupq_n_s32(4));\n    }\n\n    int min_value = INT_MAX;\n    int min_index = INT_MAX;\n\n    for (int i = 0; i < 4; ++i) {\n        int val = vgetq_lane_s32(min_val, i);\n        int idx = vgetq_lane_s32(min_idx, i);\n        if (val < min_value) {\n            min_value = val;\n            min_index = idx;\n        }\n    }\n\n    if (min_value == INT_MAX) {\n        return {};\n    }\n\n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int32x4_t min_val = vdupq_n_s32(INT_MAX);\n    int32x4_t min_idx = vdupq_n_s32(INT_MAX);\n    int32x4_t even_mask = vdupq_n_s32(1);\n    int32x4_t indices = {0, 1, 2, 3};\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t is_even = vandq_s32(values, even_mask);\n        uint32x4_t mask = vceqq_s32(is_even, vdupq_n_s32(0));\n\n        int32x4_t current_indices = vaddq_s32(indices, vdupq_n_s32(i));\n        indices = vaddq_s32(indices, vdupq_n_s32(4));\n\n        int32x4_t new_min_val = vbslq_s32(mask, min_val, values);\n        int32x4_t new_min_idx = vbslq_s32(mask, min_idx, current_indices);\n\n        min_val = vminq_s32(min_val, new_min_val);\n        min_idx = vminq_s32(min_idx, new_min_idx);\n    }\n\n    int32_t min_val_arr[4];\n    int32_t min_idx_arr[4];\n    vst1q_s32(min_val_arr, min_val);\n    vst1q_s32(min_idx_arr, min_idx);\n\n    int smallest_val = INT_MAX;\n    int smallest_idx = INT_MAX;\n\n    for (int i = 0; i < 4; ++i) {\n        if (min_val_arr[i] < smallest_val) {\n            smallest_val = min_val_arr[i];\n            smallest_idx = min_idx_arr[i];\n        }\n    }\n\n    if (smallest_val == INT_MAX || smallest_val % 2 != 0) {\n        return {};\n    }\n\n    return {smallest_val, smallest_idx};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int32x4_t min_even = vdupq_n_s32(INT32_MAX);\n    int32x4_t min_index = vdupq_n_s32(INT32_MAX);\n    int32x4_t even_mask = vdupq_n_s32(1);\n    int32x4_t index = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < arr.size(); i += 4) {\n        int32x4_t values = vld1q_s32(&arr[i]);\n        int32x4_t is_even = vandq_s32(values, even_mask);\n        is_even = vceqq_s32(is_even, vdupq_n_s32(0));\n\n        int32x4_t current_index = vaddq_s32(index, vdupq_n_s32(i));\n        int32x4_t masked_values = vbslq_s32(is_even, values, vdupq_n_s32(INT32_MAX));\n        int32x4_t masked_index = vbslq_s32(is_even, current_index, vdupq_n_s32(INT32_MAX));\n\n        min_even = vminq_s32(min_even, masked_values);\n        min_index = vminq_s32(min_index, masked_index);\n\n        index = vaddq_s32(index, vdupq_n_s32(4));\n    }\n\n    int32_t min_even_scalar = vgetq_lane_s32(min_even, 0);\n    int32_t min_index_scalar = vgetq_lane_s32(min_index, 0);\n\n    for (int i = 1; i < 4; ++i) {\n        int32_t current_even = vgetq_lane_s32(min_even, i);\n        int32_t current_index = vgetq_lane_s32(min_index, i);\n\n        if (current_even < min_even_scalar) {\n            min_even_scalar = current_even;\n            min_index_scalar = current_index;\n        } else if (current_even == min_even_scalar && current_index < min_index_scalar) {\n            min_index_scalar = current_index;\n        }\n    }\n\n    if (min_even_scalar == INT32_MAX) {\n        return {};\n    }\n\n    return {min_even_scalar, min_index_scalar};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vcgeq_s32(v, vdupq_n_s32(0));\n        int32x4_t valid = vbslq_s32(mask, v, vdupq_n_s32(0));\n\n        for (int j = 0; j < 4; ++j) {\n            int val = vgetq_lane_s32(valid, j);\n            if (val > 0) {\n                freq[val]++;\n            }\n        }\n    }\n\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vcltq_s32(v, vdupq_n_s32(max_val + 1));\n        int32x4_t indices = vbslq_s32(mask, v, vdupq_n_s32(0));\n        for (int j = 0; j < 4; ++j) {\n            freq[indices[j]]++;\n        }\n    }\n\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vcltq_s32(v, vdupq_n_s32(max_val + 1));\n        int32x4_t indices = vbslq_s32(mask, v, vdupq_n_s32(0));\n\n        for (int j = 0; j < 4; ++j) {\n            int index = vgetq_lane_s32(indices, j);\n            if (index > 0) {\n                freq[index]++;\n            }\n        }\n    }\n\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vcltq_s32(v, vdupq_n_s32(0));\n        v = vbslq_s32(mask, vdupq_n_s32(0), v);\n\n        int32_t values[4];\n        vst1q_s32(values, v);\n\n        for (int j = 0; j < 4; ++j) {\n            if (values[j] > 0) {\n                freq[values[j]]++;\n            }\n        }\n    }\n\n    for (int i = max_val; i > 0; --i) {\n        if (freq[i] >= i) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int max_val = *std::max_element(lst.begin(), lst.end());\n    std::vector<int> freq(max_val + 1, 0);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        uint32x4_t mask = vcltq_s32(v, vdupq_n_s32(0));\n        v = vbslq_s32(mask, vdupq_n_s32(0), v);\n\n        uint32x4_t indices = vaddq_u32(v, vdupq_n_u32(1));\n        uint32x4_t inc = vdupq_n_u32(1);\n\n        for (int j = 0; j < 4; ++j) {\n            freq[vgetq_lane_u32(indices, j)] += vgetq_lane_u32(inc, j);\n        }\n    }\n\n    int result = -1;\n    for (int i = 1; i <= max_val; ++i) {\n        if (freq[i] >= i) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindrome = true;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    int i;\n\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&q[i]);\n        sum += vaddvq_s32(v);\n    }\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    if (sum > w) {\n        return false;\n    }\n\n    for (i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindrome = true;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindrome = true;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t temp[4];\n    vst1q_s32(temp, sum_vec);\n    sum = temp[0] + temp[1] + temp[2] + temp[3];\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int sum = 0;\n    bool is_palindrome = true;\n\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - i - 1]) {\n            is_palindrome = false;\n            break;\n        }\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int i;\n    for (i = 0; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, vec);\n    }\n\n    int32_t sum_array[4];\n    vst1q_s32(sum_array, sum_vec);\n    sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n\n    for (; i < n; ++i) {\n        sum += q[i];\n    }\n\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    for (; i <= n / 2 - 4; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n\n        uint32x4_t mask = vceqq_s32(left, right);\n        uint32x4_t not_mask = vmvnq_u32(mask);\n\n        changes += vaddvq_u32(not_mask);\n    }\n\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    while (i <= n / 2) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n\n        uint32x4_t mask = vceqq_s32(left, right);\n        uint32x4_t not_mask = vmvnq_u32(mask);\n\n        changes += vaddvq_u32(not_mask);\n\n        i += 4;\n    }\n\n    if (n % 2 == 1 && arr[n / 2 - 1] != arr[n / 2 + 1]) {\n        changes++;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    for (; i <= n / 2 - 4; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n\n        uint32x4_t cmp = vceqq_s32(left, right);\n        uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n        uint32x4_t diff = vandq_u32(vmvnq_u32(cmp), mask);\n\n        changes += vaddvq_u32(diff);\n    }\n\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    for (; i <= n / 2 - 4; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n        uint32x4_t mask = vceqq_s32(left, right);\n        uint32x4_t not_mask = vmvnq_u32(mask);\n        changes += vaddvq_u32(not_mask);\n    }\n\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    int i = 0;\n\n    for (; i <= n / 2 - 4; i += 4) {\n        int32x4_t left = vld1q_s32(&arr[i]);\n        int32x4_t right = vld1q_s32(&arr[n - i - 4]);\n\n        uint32x4_t cmp = vceqq_s32(left, right);\n        uint32x4_t mask = vcltq_u32(cmp, vdupq_n_u32(1));\n\n        changes += vaddvq_u32(mask);\n    }\n\n    for (; i < n / 2; ++i) {\n        if (arr[i] != arr[n - i - 1]) {\n            ++changes;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars_lst1 = 0;\n    int total_chars_lst2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars_lst1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars_lst2 += str.size();\n    }\n\n    if (total_chars_lst1 <= total_chars_lst2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars2 += str.size();\n    }\n\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars2 += str.size();\n    }\n\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars2 += str.size();\n    }\n\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total_chars1 = 0;\n    int total_chars2 = 0;\n\n    for (const auto& str : lst1) {\n        total_chars1 += str.size();\n    }\n\n    for (const auto& str : lst2) {\n        total_chars2 += str.size();\n    }\n\n    if (total_chars1 <= total_chars2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vresult = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(vresult, 0) <= x && vgetq_lane_u64(vresult, 1) <= x) {\n        vresult = vmulq_u64(vresult, vn);\n        if (vgetq_lane_u64(vresult, 0) == x || vgetq_lane_u64(vresult, 1) == x) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    uint64_t power = n;\n    while (power <= x) {\n        if (power == x) {\n            return true;\n        }\n        if (power > UINT64_MAX / n) {\n            break;\n        }\n        power *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return n == 1;\n    }\n\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t power_vec = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(power_vec, 0) <= x && vgetq_lane_u64(power_vec, 1) <= x) {\n        power_vec = vmulq_u64(power_vec, n_vec);\n        if (vgetq_lane_u64(power_vec, 0) == x || vgetq_lane_u64(power_vec, 1) == x) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 0) {\n        return x == 1;\n    }\n\n    uint64x2_t vx = vdupq_n_u64(x);\n    uint64x2_t vn = vdupq_n_u64(n);\n    uint64x2_t vpow = vdupq_n_u64(1);\n    uint64x2_t vone = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(vpow, 0) <= x && vgetq_lane_u64(vpow, 1) <= x) {\n        vpow = vmulq_u64(vpow, vn);\n        if (vgetq_lane_u64(vpow, 0) == x || vgetq_lane_u64(vpow, 1) == x) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return n == 1;\n    }\n\n    uint64x2_t n_vec = vdupq_n_u64(n);\n    uint64x2_t x_vec = vdupq_n_u64(x);\n    uint64x2_t power_vec = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(power_vec, 0) <= x && vgetq_lane_u64(power_vec, 1) <= x) {\n        power_vec = vmulq_u64(power_vec, n_vec);\n        if (vgetq_lane_u64(power_vec, 0) == x || vgetq_lane_u64(power_vec, 1) == x) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const char* hex_str = num.c_str();\n    int len = num.length();\n    int prime_count = 0;\n\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vsetq_lane_u8(1, prime_mask, 2);  // '2'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 3);  // '3'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 5);  // '5'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 7);  // '7'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xB); // 'B' (11)\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xD); // 'D' (13)\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t hex_chunk = vld1q_u8((const uint8_t*)&hex_str[i]);\n        uint8x16_t is_prime = vqtbl1q_u8(prime_mask, hex_chunk);\n        uint8x16_t prime_count_chunk = vcntq_u8(is_prime);\n        prime_count += vaddvq_u8(prime_count_chunk);\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const char* hex_str = num.c_str();\n    int len = num.length();\n    int prime_count = 0;\n\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vsetq_lane_u8(1, prime_mask, 2);  // '2'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 3);  // '3'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 5);  // '5'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 7);  // '7'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xB); // 'B'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xD); // 'D'\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t hex_chunk = vld1q_u8((const uint8_t*)(hex_str + i));\n        uint8x16_t is_prime = vqtbl1q_u8(prime_mask, hex_chunk);\n        uint8x8_t is_prime_low = vget_low_u8(is_prime);\n        uint8x8_t is_prime_high = vget_high_u8(is_prime);\n\n        prime_count += vaddv_u8(is_prime_low);\n        prime_count += vaddv_u8(is_prime_high);\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const char* hex_str = num.c_str();\n    int len = num.length();\n    int prime_count = 0;\n\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vsetq_lane_u8(1, prime_mask, 2);  // '2'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 3);  // '3'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 5);  // '5'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 7);  // '7'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xB); // 'B'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xD); // 'D'\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t hex_chunk = vld1q_u8((const uint8_t*)(hex_str + i));\n        uint8x16_t is_prime = vqtbl1q_u8(prime_mask, hex_chunk);\n        uint8x16_t prime_count_chunk = vpaddq_u8(vpaddq_u8(is_prime, is_prime), vpaddq_u8(is_prime, is_prime));\n        prime_count += vaddvq_u8(prime_count_chunk);\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    const char* hex_str = num.c_str();\n    int len = num.length();\n    int prime_count = 0;\n\n    uint8x16_t prime_mask = vdupq_n_u8(0);\n    prime_mask = vsetq_lane_u8(1, prime_mask, 2);  // '2'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 3);  // '3'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 5);  // '5'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 7);  // '7'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xB); // 'B'\n    prime_mask = vsetq_lane_u8(1, prime_mask, 0xD); // 'D'\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t hex_chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(hex_str + i));\n        uint8x16_t is_prime = vqtbl1q_u8(prime_mask, hex_chunk);\n        uint8x8_t is_prime_low = vget_low_u8(is_prime);\n        uint8x8_t is_prime_high = vget_high_u8(is_prime);\n\n        prime_count += vaddv_u8(is_prime_low);\n        prime_count += vaddv_u8(is_prime_high);\n    }\n\n    return prime_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int count = 0;\n    const char* hex_str = num.c_str();\n    int len = num.length();\n\n    // Define the prime hex digits: 2, 3, 5, 7, B, D\n    uint8x16_t prime_digits = vdupq_n_u8(0x02);\n    prime_digits = vorrq_u8(prime_digits, vdupq_n_u8(0x03));\n    prime_digits = vorrq_u8(prime_digits, vdupq_n_u8(0x05));\n    prime_digits = vorrq_u8(prime_digits, vdupq_n_u8(0x07));\n    prime_digits = vorrq_u8(prime_digits, vdupq_n_u8(0x0B));\n    prime_digits = vorrq_u8(prime_digits, vdupq_n_u8(0x0D));\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t hex_chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(hex_str + i));\n        uint8x16_t is_prime = vceqq_u8(hex_chunk, prime_digits);\n        count += vaddvq_u8(vandq_u8(is_prime, vdupq_n_u8(1)));\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char *data = s.c_str();\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i <= len - 3; i += 4) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t vec1 = vextq_u8(vec, vec, 1);\n        uint8x16_t vec2 = vextq_u8(vec, vec, 2);\n\n        uint8x16_t cmp1 = vceqq_u8(vec, vec1);\n        uint8x16_t cmp2 = vceqq_u8(vec, vec2);\n        uint8x16_t cmp3 = vceqq_u8(vec1, vec2);\n\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        uint64x2_t result64 = vpaddlq_u8(result);\n        uint64_t result_sum = vaddvq_u64(result64);\n\n        if (result_sum != 0) {\n            return false;\n        }\n    }\n\n    for (; i < len - 2; ++i) {\n        if (data[i] == data[i + 1] || data[i] == data[i + 2] || data[i + 1] == data[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char *data = s.c_str();\n    size_t len = s.length();\n\n    for (size_t i = 0; i <= len - 3; i += 4) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t v1 = vextq_u8(v, v, 1);\n        uint8x16_t v2 = vextq_u8(v, v, 2);\n\n        uint8x16_t cmp1 = vceqq_u8(v, v1);\n        uint8x16_t cmp2 = vceqq_u8(v, v2);\n        uint8x16_t cmp3 = vceqq_u8(v1, v2);\n\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        if (vmaxvq_u8(result) != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char *data = s.c_str();\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i <= len - 4; i += 4) {\n        uint8x8_t v = vld1_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x8_t v1 = vext_u8(v, v, 1);\n        uint8x8_t v2 = vext_u8(v, v, 2);\n        uint8x8_t v3 = vext_u8(v, v, 3);\n\n        uint8x8_t eq1 = vceq_u8(v, v1);\n        uint8x8_t eq2 = vceq_u8(v, v2);\n        uint8x8_t eq3 = vceq_u8(v, v3);\n\n        uint8x8_t or_eq = vorr_u8(eq1, eq2);\n        or_eq = vorr_u8(or_eq, eq3);\n\n        uint8x8_t not_eq = vmvn_u8(or_eq);\n        uint8x8_t all_eq = vand_u8(eq1, eq2);\n        all_eq = vand_u8(all_eq, eq3);\n\n        if (vmaxv_u8(all_eq) != 0) {\n            return false;\n        }\n    }\n\n    for (; i < len - 2; ++i) {\n        if (data[i] == data[i + 1] || data[i] == data[i + 2] || data[i + 1] == data[i + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char *data = s.c_str();\n    size_t len = s.length();\n\n    for (size_t i = 0; i <= len - 3; i += 4) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x8_t vec1 = vget_low_u8(vec);\n        uint8x8_t vec2 = vget_high_u8(vec);\n\n        uint8x8_t vec1_shifted = vext_u8(vec1, vec1, 1);\n        uint8x8_t vec1_shifted2 = vext_u8(vec1, vec1, 2);\n\n        uint8x8_t vec2_shifted = vext_u8(vec2, vec2, 1);\n        uint8x8_t vec2_shifted2 = vext_u8(vec2, vec2, 2);\n\n        uint8x8_t cmp1 = vceq_u8(vec1, vec1_shifted);\n        uint8x8_t cmp2 = vceq_u8(vec1, vec1_shifted2);\n        uint8x8_t cmp3 = vceq_u8(vec1_shifted, vec1_shifted2);\n\n        uint8x8_t cmp4 = vceq_u8(vec2, vec2_shifted);\n        uint8x8_t cmp5 = vceq_u8(vec2, vec2_shifted2);\n        uint8x8_t cmp6 = vceq_u8(vec2_shifted, vec2_shifted2);\n\n        uint8x8_t or1 = vorr_u8(cmp1, cmp2);\n        uint8x8_t or2 = vorr_u8(or1, cmp3);\n\n        uint8x8_t or3 = vorr_u8(cmp4, cmp5);\n        uint8x8_t or4 = vorr_u8(or3, cmp6);\n\n        uint8x8_t or_final = vorr_u8(or2, or4);\n\n        uint64x2_t or_final64 = vpaddlq_u8(or_final);\n        uint64x1_t or_final32 = vpadd_u64(vget_low_u64(or_final64), vget_high_u64(or_final64));\n\n        if (vget_lane_u64(or_final32, 0) != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n\n    const char *data = s.c_str();\n    size_t len = s.length();\n\n    for (size_t i = 0; i <= len - 3; i += 4) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n\n        uint8x16_t vec1 = vextq_u8(vec, vec, 1);\n        uint8x16_t vec2 = vextq_u8(vec, vec, 2);\n\n        uint8x16_t cmp1 = vceqq_u8(vec, vec1);\n        uint8x16_t cmp2 = vceqq_u8(vec, vec2);\n        uint8x16_t cmp3 = vceqq_u8(vec1, vec2);\n\n        uint8x16_t result = vorrq_u8(cmp1, cmp2);\n        result = vorrq_u8(result, cmp3);\n\n        uint64x2_t result64 = vpaddlq_u8(result);\n        uint64x1_t result_sum = vadd_u64(vget_low_u64(result64), vget_high_u64(result64));\n\n        if (vget_lane_u64(result_sum, 0) != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length <= 1) return false;\n    if (length == 2) return true;\n    if (length % 2 == 0) return false;\n\n    int limit = std::sqrt(length);\n    int i = 3;\n\n    while (i <= limit) {\n        if (length % i == 0) return false;\n        i += 2;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length <= 1) return false;\n    if (length == 2 || length == 3) return true;\n    if (length % 2 == 0 || length % 3 == 0) return false;\n\n    int limit = std::sqrt(length);\n    int i = 5;\n    while (i <= limit) {\n        if (length % i == 0 || length % (i + 2) == 0) return false;\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length <= 1) return false;\n    if (length == 2 || length == 3) return true;\n    if (length % 2 == 0 || length % 3 == 0) return false;\n\n    int limit = std::sqrt(length);\n    int i = 5;\n    while (i <= limit) {\n        if (length % i == 0 || length % (i + 2) == 0) return false;\n        i += 6;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    int len = str.length();\n    if (len < 2) return false;\n\n    int limit = (int)sqrt(len) + 1;\n    intx2_t vlen = vdup_n_s32(len);\n    intx2_t vone = vdup_n_s32(1);\n    intx2_t vtwo = vdup_n_s32(2);\n\n    for (int i = 2; i <= limit; i++) {\n        intx2_t vi = vdup_n_s32(i);\n        uint32x2_t vrem = vrem_s32(vlen, vi);\n        uint32x2_t vcmp = vceq_s32(vrem, vone);\n        if (vget_lane_u32(vcmp, 0) || vget_lane_u32(vcmp, 1)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cmath>\n\nbool prime_length_simd(const std::string & str) {\n    int length = str.length();\n    if (length <= 1) return false;\n    if (length == 2) return true;\n\n    int limit = static_cast<int>(std::sqrt(length)) + 1;\n    int i = 2;\n\n    while (i <= limit) {\n        int32x4_t v_i = vdupq_n_s32(i);\n        int32x4_t v_length = vdupq_n_s32(length);\n        int32x4_t v_remainder = vsubq_s32(v_length, vmulq_s32(v_i, vdivq_s32(v_length, v_i)));\n\n        if (vgetq_lane_s32(v_remainder, 0) == 0) return false;\n\n        i += 4;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64x2_t vec = vdupq_n_u64(N);\n    uint64x2_t mask = vdupq_n_u64(0x0F0F0F0F0F0F0F0F);\n    uint64x2_t sum = vandq_u64(vec, mask);\n    sum = vpaddq_u64(sum, sum);\n    sum = vpaddq_u64(sum, sum);\n    sum = vpaddq_u64(sum, sum);\n    uint64_t result = vgetq_lane_u64(sum, 0);\n\n    result = (result & 0x0F) + ((result >> 4) & 0x0F) + ((result >> 8) & 0x0F) + ((result >> 12) & 0x0F) +\n             ((result >> 16) & 0x0F) + ((result >> 20) & 0x0F) + ((result >> 24) & 0x0F) + ((result >> 28) & 0x0F) +\n             ((result >> 32) & 0x0F) + ((result >> 36) & 0x0F) + ((result >> 40) & 0x0F) + ((result >> 44) & 0x0F) +\n             ((result >> 48) & 0x0F) + ((result >> 52) & 0x0F) + ((result >> 56) & 0x0F) + ((result >> 60) & 0x0F);\n\n    std::string binary = \"\";\n    while (result > 0) {\n        binary = (result % 2 == 0 ? \"0\" : \"1\") + binary;\n        result /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64x2_t vec = vdupq_n_u64(N);\n    uint64x2_t mask = vdupq_n_u64(0x0F0F0F0F0F0F0F0F);\n    uint64x2_t sum = vandq_u64(vec, mask);\n    sum = vpaddq_u64(sum, sum);\n    sum = vpaddq_u64(sum, sum);\n    sum = vpaddq_u64(sum, sum);\n    uint64_t result = vgetq_lane_u64(sum, 0);\n\n    result = (result & 0x0F) + ((result >> 4) & 0x0F) + ((result >> 8) & 0x0F) + ((result >> 12) & 0x0F) +\n             ((result >> 16) & 0x0F) + ((result >> 20) & 0x0F) + ((result >> 24) & 0x0F) + ((result >> 28) & 0x0F) +\n             ((result >> 32) & 0x0F) + ((result >> 36) & 0x0F) + ((result >> 40) & 0x0F) + ((result >> 44) & 0x0F) +\n             ((result >> 48) & 0x0F) + ((result >> 52) & 0x0F) + ((result >> 56) & 0x0F) + ((result >> 60) & 0x0F);\n\n    std::string binary = \"\";\n    while (result > 0) {\n        binary = (result % 2 == 0 ? \"0\" : \"1\") + binary;\n        result /= 2;\n    }\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64x2_t vec = vdupq_n_u64(N);\n    uint64x2_t sum = vdupq_n_u64(0);\n\n    for (int i = 0; i < 64; i += 8) {\n        uint8x8_t bytes = vmovn_u16(vreinterpretq_u16_u64(vec));\n        uint8x8_t mask = vcgt_u8(bytes, vdup_n_u8(0));\n        sum = vpadal_u8(sum, vand_u8(bytes, mask));\n        vec = vshrq_n_u64(vec, 8);\n    }\n\n    uint64_t total_sum = vaddvq_u64(sum);\n\n    std::string binary_sum;\n    while (total_sum > 0) {\n        binary_sum = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary_sum;\n        total_sum /= 2;\n    }\n\n    return binary_sum.empty() ? \"0\" : binary_sum;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint8x16_t digits = vdupq_n_u8(0);\n    uint8x16_t mask = vdupq_n_u8(0x0F);\n    uint8x16_t sum = vdupq_n_u8(0);\n\n    for (int i = 0; i < 8; ++i) {\n        uint8_t digit = N & 0xFF;\n        N >>= 8;\n\n        uint8x16_t byte = vdupq_n_u8(digit);\n        uint8x16_t low_nibble = vandq_u8(byte, mask);\n        uint8x16_t high_nibble = vshrq_n_u8(byte, 4);\n\n        sum = vaddq_u8(sum, low_nibble);\n        sum = vaddq_u8(sum, high_nibble);\n    }\n\n    uint8x16_t sum_low = vpaddq_u8(sum, sum);\n    sum_low = vpaddq_u8(sum_low, sum_low);\n    sum_low = vpaddq_u8(sum_low, sum_low);\n\n    uint8_t total_sum = vgetq_lane_u8(sum_low, 0);\n\n    std::string binary_result;\n    while (total_sum > 0) {\n        binary_result = (total_sum % 2 == 0 ? \"0\" : \"1\") + binary_result;\n        total_sum /= 2;\n    }\n\n    return binary_result.empty() ? \"0\" : binary_result;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64x2_t vec = vdupq_n_u64(N);\n    uint64x2_t mask = vdupq_n_u64(0x0F0F0F0F0F0F0F0F);\n    uint64x2_t sum = vdupq_n_u64(0);\n\n    vec = vandq_u64(vec, mask);\n    sum = vpaddq_u64(sum, vec);\n    sum = vpaddq_u64(sum, sum);\n\n    uint64_t result = vgetq_lane_u64(sum, 0);\n\n    std::string binary;\n    while (result) {\n        binary = (result % 2 ? \"1\" : \"0\") + binary;\n        result /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 1;\n\n    while (i <= n - 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t mask = {1, 1, 1, 1};\n        int32x4_t even_mask = {0, 1, 0, 1};\n        int32x4_t even_elements = vandq_s32(vec, even_mask);\n        int32x4_t odd_indices = vandq_s32(mask, even_mask);\n        int32x4_t result = vandq_s32(even_elements, odd_indices);\n\n        sum += vgetq_lane_s32(result, 0);\n        sum += vgetq_lane_s32(result, 2);\n\n        i += 4;\n    }\n\n    for (; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int n = lst.size();\n    int i = 1;\n\n    while (i + 3 < n) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t mask = {1, 0, 1, 0};\n        vec = vandq_s32(vec, mask);\n        sum += vgetq_lane_s32(vec, 0) + vgetq_lane_s32(vec, 2);\n        i += 4;\n    }\n\n    for (; i < n; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 1;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t mask = {1, 0, 1, 0};\n        int32x4_t even_mask = vandq_s32(vec, mask);\n        sum += vgetq_lane_s32(even_mask, 0) + vgetq_lane_s32(even_mask, 2);\n    }\n\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 1;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t mask = {1, 0, 1, 0};\n        int32x4_t even_mask = vandq_s32(vec, mask);\n        sum += vgetq_lane_s32(even_mask, 0) + vgetq_lane_s32(even_mask, 2);\n    }\n\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 1;\n\n    while (i <= size - 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t even_mask = vdupq_n_s32(1);\n        int32x4_t even_elements = vandq_s32(vec, even_mask);\n        int32x4_t sum_vec = vpaddq_s32(even_elements, even_elements);\n        sum += vgetq_lane_s32(sum_vec, 0) + vgetq_lane_s32(sum_vec, 2);\n        i += 4;\n    }\n\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t shift = vdupq_n_u8(4); // Shift by 4 positions\n        uint8x16_t output = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), output);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(4);\n        uint8x16_t encrypted = vaddq_u8(vec, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(4); // Shift by 4 positions\n        uint8x16_t output = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), output);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(4); // Shift by 4 positions\n        uint8x16_t encrypted = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result = s;\n    size_t len = s.length();\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        uint8x16_t shift = vdupq_n_u8(4); // Shift by 4 positions\n        uint8x16_t encrypted = vaddq_u8(input, shift);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), encrypted);\n    }\n\n    for (; i < len; ++i) {\n        result[i] = s[i] + 4;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.size();\n    size_t i = 0;\n\n    // Vectors for vowels and their replacements\n    const char8_t vowels[] = \"aeiouAEIOU\";\n    const char8_t replacements[] = \"cgikqCGIKQ\";\n\n    uint8x16_t v_vowels = vld1q_u8((const uint8_t*)vowels);\n    uint8x16_t v_replacements = vld1q_u8((const uint8_t*)replacements);\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t v_message = vld1q_u8((const uint8_t*)&message[i]);\n\n        // Swap case\n        uint8x16_t v_upper = vandq_u8(v_message, vdupq_n_u8(0xDF)); // 'a' -> 'A'\n        uint8x16_t v_lower = vandq_u8(v_message, vdupq_n_u8(0x5F)); // 'A' -> 'a'\n        uint8x16_t v_swapped = vbslq_u8(vtstq_u8(v_message, vdupq_n_u8(0x20)), v_lower, v_upper);\n\n        // Replace vowels\n        uint8x16_t v_mask = vceqq_u8(v_swapped, v_vowels);\n        uint8x16_t v_replaced = vbslq_u8(v_mask, v_replacements, v_swapped);\n\n        vst1q_u8((uint8_t*)&result[i], v_replaced);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c = (c - 'a' + 'A');\n        } else if (c >= 'A' && c <= 'Z') {\n            c = (c - 'A' + 'a');\n        }\n\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c += 2;\n        } else if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            c += 2;\n        }\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i;\n\n    for (i = 0; i <= len - 16; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n        uint8x16_t swapped_case = veorq_u8(vec, lower_mask);\n\n        // Replace vowels\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t e = vdupq_n_u8('e');\n        uint8x16_t i = vdupq_n_u8('i');\n        uint8x16_t o = vdupq_n_u8('o');\n        uint8x16_t u = vdupq_n_u8('u');\n        uint8x16_t A = vdupq_n_u8('A');\n        uint8x16_t E = vdupq_n_u8('E');\n        uint8x16_t I = vdupq_n_u8('I');\n        uint8x16_t O = vdupq_n_u8('O');\n        uint8x16_t U = vdupq_n_u8('U');\n\n        uint8x16_t g = vdupq_n_u8('g');\n        uint8x16_t j = vdupq_n_u8('j');\n        uint8x16_t k = vdupq_n_u8('k');\n        uint8x16_t q = vdupq_n_u8('q');\n        uint8x16_t w = vdupq_n_u8('w');\n        uint8x16_t G = vdupq_n_u8('G');\n        uint8x16_t J = vdupq_n_u8('J');\n        uint8x16_t K = vdupq_n_u8('K');\n        uint8x16_t Q = vdupq_n_u8('Q');\n        uint8x16_t W = vdupq_n_u8('W');\n\n        uint8x16_t mask_a = vceqq_u8(vec, a);\n        uint8x16_t mask_e = vceqq_u8(vec, e);\n        uint8x16_t mask_i = vceqq_u8(vec, i);\n        uint8x16_t mask_o = vceqq_u8(vec, o);\n        uint8x16_t mask_u = vceqq_u8(vec, u);\n        uint8x16_t mask_A = vceqq_u8(vec, A);\n        uint8x16_t mask_E = vceqq_u8(vec, E);\n        uint8x16_t mask_I = vceqq_u8(vec, I);\n        uint8x16_t mask_O = vceqq_u8(vec, O);\n        uint8x16_t mask_U = vceqq_u8(vec, U);\n\n        uint8x16_t replaced = vbslq_u8(mask_a, g, vec);\n        replaced = vbslq_u8(mask_e, j, replaced);\n        replaced = vbslq_u8(mask_i, k, replaced);\n        replaced = vbslq_u8(mask_o, q, replaced);\n        replaced = vbslq_u8(mask_u, w, replaced);\n        replaced = vbslq_u8(mask_A, G, replaced);\n        replaced = vbslq_u8(mask_E, J, replaced);\n        replaced = vbslq_u8(mask_I, K, replaced);\n        replaced = vbslq_u8(mask_O, Q, replaced);\n        replaced = vbslq_u8(mask_U, W, replaced);\n\n        uint8x16_t final_vec = vbslq_u8(vcgeq_u8(vec, vdupq_n_u8('A')), swapped_case, replaced);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n    }\n\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20;\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20;\n        }\n\n        switch (c) {\n            case 'a': c = 'g'; break;\n            case 'e': c = 'j'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'G'; break;\n            case 'E': c = 'J'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.length();\n    size_t i = 0;\n\n    // Define constants for case swapping and vowel replacement\n    const uint8x16_t lower_to_upper = vdupq_n_u8('a' - 'A');\n    const uint8x16_t upper_to_lower = vdupq_n_u8('A' - 'a');\n    const uint8x16_t vowels = vdupq_n_u8('a');\n    const uint8x16_t replacements = vdupq_n_u8('c');\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        uint8x16_t is_lower = vcgeq_u8(vandq_u8(chunk, vdupq_n_u8(0x20)), vowels);\n        uint8x16_t is_upper = vcgeq_u8(vandq_u8(chunk, vdupq_n_u8(0x20)), vaddq_u8(vowels, vdupq_n_u8('A' - 'a')));\n        uint8x16_t swapped_case = vorrq_u8(\n            vandq_u8(is_lower, vsubq_u8(chunk, lower_to_upper)),\n            vandq_u8(is_upper, vaddq_u8(chunk, upper_to_lower))\n        );\n\n        // Replace vowels\n        uint8x16_t is_vowel = vorrq_u8(\n            vcgeq_u8(vandq_u8(chunk, vdupq_n_u8(0xDF)), vdupq_n_u8('a')),\n            vcgeq_u8(vandq_u8(chunk, vdupq_n_u8(0xDF)), vdupq_n_u8('A'))\n        );\n        uint8x16_t replaced_vowels = vorrq_u8(\n            vandq_u8(is_vowel, replacements),\n            vandq_u8(vmvnq_u8(is_vowel), swapped_case)\n        );\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), replaced_vowels);\n    }\n\n    // Handle remaining characters\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c -= 'a' - 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c += 'a' - 'A';\n        }\n\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            c += 2;\n        }\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.size();\n    size_t i = 0;\n\n    // Process in chunks of 16 bytes (128 bits)\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n        uint8x16_t swapped_case = veorq_u8(vec, lower_mask);\n\n        // Replace vowels\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t e = vdupq_n_u8('e');\n        uint8x16_t i = vdupq_n_u8('i');\n        uint8x16_t o = vdupq_n_u8('o');\n        uint8x16_t u = vdupq_n_u8('u');\n        uint8x16_t A = vdupq_n_u8('A');\n        uint8x16_t E = vdupq_n_u8('E');\n        uint8x16_t I = vdupq_n_u8('I');\n        uint8x16_t O = vdupq_n_u8('O');\n        uint8x16_t U = vdupq_n_u8('U');\n\n        uint8x16_t c = vdupq_n_u8('c');\n        uint8x16_t g = vdupq_n_u8('g');\n        uint8x16_t C = vdupq_n_u8('C');\n        uint8x16_t G = vdupq_n_u8('G');\n\n        uint8x16_t mask_a = vceqq_u8(vec, a);\n        uint8x16_t mask_e = vceqq_u8(vec, e);\n        uint8x16_t mask_i = vceqq_u8(vec, i);\n        uint8x16_t mask_o = vceqq_u8(vec, o);\n        uint8x16_t mask_u = vceqq_u8(vec, u);\n        uint8x16_t mask_A = vceqq_u8(vec, A);\n        uint8x16_t mask_E = vceqq_u8(vec, E);\n        uint8x16_t mask_I = vceqq_u8(vec, I);\n        uint8x16_t mask_O = vceqq_u8(vec, O);\n        uint8x16_t mask_U = vceqq_u8(vec, U);\n\n        uint8x16_t replaced = vbslq_u8(mask_a, c, vec);\n        replaced = vbslq_u8(mask_e, g, replaced);\n        replaced = vbslq_u8(mask_i, c, replaced);\n        replaced = vbslq_u8(mask_o, g, replaced);\n        replaced = vbslq_u8(mask_u, c, replaced);\n        replaced = vbslq_u8(mask_A, C, replaced);\n        replaced = vbslq_u8(mask_E, G, replaced);\n        replaced = vbslq_u8(mask_I, C, replaced);\n        replaced = vbslq_u8(mask_O, G, replaced);\n        replaced = vbslq_u8(mask_U, C, replaced);\n\n        uint8x16_t final_vec = vbslq_u8(vcgeq_u8(vec, upper_mask), swapped_case, replaced);\n\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n    }\n\n    // Process remaining bytes\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20;\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20;\n        }\n\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result = message;\n    size_t len = message.size();\n    size_t i = 0;\n\n    // Process in chunks of 16 bytes (128 bits)\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(&message[i]));\n\n        // Swap case\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n        uint8x16_t swapped_case = veorq_u8(vec, lower_mask);\n\n        // Replace vowels\n        uint8x16_t a = vdupq_n_u8('a');\n        uint8x16_t e = vdupq_n_u8('e');\n        uint8x16_t i = vdupq_n_u8('i');\n        uint8x16_t o = vdupq_n_u8('o');\n        uint8x16_t u = vdupq_n_u8('u');\n        uint8x16_t A = vdupq_n_u8('A');\n        uint8x16_t E = vdupq_n_u8('E');\n        uint8x16_t I = vdupq_n_u8('I');\n        uint8x16_t O = vdupq_n_u8('O');\n        uint8x16_t U = vdupq_n_u8('U');\n\n        uint8x16_t c = vdupq_n_u8('c');\n        uint8x16_t g = vdupq_n_u8('g');\n        uint8x16_t C = vdupq_n_u8('C');\n        uint8x16_t G = vdupq_n_u8('G');\n\n        uint8x16_t mask_a = vceqq_u8(vec, a);\n        uint8x16_t mask_e = vceqq_u8(vec, e);\n        uint8x16_t mask_i = vceqq_u8(vec, i);\n        uint8x16_t mask_o = vceqq_u8(vec, o);\n        uint8x16_t mask_u = vceqq_u8(vec, u);\n        uint8x16_t mask_A = vceqq_u8(vec, A);\n        uint8x16_t mask_E = vceqq_u8(vec, E);\n        uint8x16_t mask_I = vceqq_u8(vec, I);\n        uint8x16_t mask_O = vceqq_u8(vec, O);\n        uint8x16_t mask_U = vceqq_u8(vec, U);\n\n        uint8x16_t replaced = vbslq_u8(mask_a, c, vec);\n        replaced = vbslq_u8(mask_e, g, replaced);\n        replaced = vbslq_u8(mask_i, c, replaced);\n        replaced = vbslq_u8(mask_o, g, replaced);\n        replaced = vbslq_u8(mask_u, c, replaced);\n        replaced = vbslq_u8(mask_A, C, replaced);\n        replaced = vbslq_u8(mask_E, G, replaced);\n        replaced = vbslq_u8(mask_I, C, replaced);\n        replaced = vbslq_u8(mask_O, G, replaced);\n        replaced = vbslq_u8(mask_U, C, replaced);\n\n        uint8x16_t final_vec = veorq_u8(replaced, lower_mask);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), final_vec);\n    }\n\n    // Process remaining bytes\n    for (; i < len; ++i) {\n        char c = message[i];\n        if (c >= 'a' && c <= 'z') {\n            c ^= 0x20;\n        } else if (c >= 'A' && c <= 'Z') {\n            c ^= 0x20;\n        }\n\n        switch (c) {\n            case 'a': c = 'c'; break;\n            case 'e': c = 'g'; break;\n            case 'i': c = 'k'; break;\n            case 'o': c = 'q'; break;\n            case 'u': c = 'w'; break;\n            case 'A': c = 'C'; break;\n            case 'E': c = 'G'; break;\n            case 'I': c = 'K'; break;\n            case 'O': c = 'Q'; break;\n            case 'U': c = 'W'; break;\n        }\n\n        result[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        uint8x16_t lower_mask = vdupq_n_u8('a' - 1);\n        uint8x16_t upper_mask = vdupq_n_u8('Z' + 1);\n        uint8x16_t lower_check = vcgtq_u8(vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str())), lower_mask);\n        uint8x16_t upper_check = vcltq_u8(vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str())), upper_mask);\n\n        uint8x16_t is_lower = vandq_u8(lower_check, upper_check);\n        uint8x16_t is_upper = vandq_u8(vcgeq_u8(vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str())), vdupq_n_u8('A')),\n                                       vcleq_u8(vld1q_u8(reinterpret_cast<const uint8_t*>(key.c_str())), vdupq_n_u8('Z')));\n\n        all_lower &= (vmaxvq_u8(is_lower) != 0);\n        all_upper &= (vmaxvq_u8(is_upper) != 0);\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n\n        for (size_t i = 0; i < key.size(); i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            uint8x16_t lower_vec = vandq_u8(vec, lower_mask);\n            uint8x16_t upper_vec = vandq_u8(vec, upper_mask);\n\n            all_lower &= vminvq_u8(vceqq_u8(vec, lower_vec)) != 0;\n            all_upper &= vminvq_u8(vceqq_u8(vec, upper_vec)) != 0;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        uint8x16_t lower_mask = vdupq_n_u8('a' - 1);\n        uint8x16_t upper_mask = vdupq_n_u8('Z' + 1);\n\n        for (size_t i = 0; i < key.size(); i += 16) {\n            uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            uint8x16_t lower_check = vcgtq_u8(chunk, lower_mask);\n            uint8x16_t upper_check = vcltq_u8(chunk, upper_mask);\n\n            uint8x16_t is_lower = vandq_u8(lower_check, upper_check);\n            uint8x16_t is_upper = vandq_u8(vcgeq_u8(chunk, vdupq_n_u8('A')), vcleq_u8(chunk, vdupq_n_u8('Z')));\n\n            all_lower &= (vmaxvq_u8(is_lower) != 0);\n            all_upper &= (vmaxvq_u8(is_upper) != 0);\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        uint8x16_t lower_mask = vdupq_n_u8('a' - 1);\n        uint8x16_t upper_mask = vdupq_n_u8('Z' + 1);\n\n        for (size_t i = 0; i < key.size(); i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            uint8x16_t lower_check = vcgtq_u8(vec, lower_mask);\n            uint8x16_t upper_check = vcltq_u8(vec, upper_mask);\n\n            uint8x16_t is_lower = vandq_u8(lower_check, vceqq_u8(vec, vsubq_u8(vec, vdupq_n_u8('a' - 'A'))));\n            uint8x16_t is_upper = vandq_u8(upper_check, vceqq_u8(vec, vaddq_u8(vec, vdupq_n_u8('a' - 'A'))));\n\n            all_lower &= (vmaxvq_u8(is_lower) != 0);\n            all_upper &= (vmaxvq_u8(is_upper) != 0);\n        }\n\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        uint8x16_t lower_mask = vdupq_n_u8(0x20);\n        uint8x16_t upper_mask = vdupq_n_u8(0xDF);\n\n        for (size_t i = 0; i < key.size(); i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n            uint8x16_t lower_vec = vandq_u8(vec, lower_mask);\n            uint8x16_t upper_vec = vandq_u8(vec, upper_mask);\n\n            all_lower &= vminvq_u8(lower_vec) == 0;\n            all_upper &= vminvq_u8(upper_vec) == 0;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Initialize a bitmask to mark non-prime numbers\n    uint8x16_t bitmask = vdupq_n_u8(0xFF);\n    bitmask = vsetq_lane_u8(0, bitmask, 0); // 0 and 1 are not primes\n    bitmask = vsetq_lane_u8(0, bitmask, 1);\n\n    for (int i = 2; i < n; i++) {\n        if (vgetq_lane_u8(bitmask, i / 8) & (1 << (i % 8))) {\n            primes.push_back(i);\n            for (int j = i * i; j < n; j += i) {\n                bitmask = vsetq_lane_u8(vgetq_lane_u8(bitmask, j / 8) & ~(1 << (j % 8)), bitmask, j / 8);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    uint32x4_t ones = vdupq_n_u32(1);\n    uint32x4_t incr = vdupq_n_u32(4);\n    uint32x4_t idx = vdupq_n_u32(3);\n\n    for (int i = 3; i < n; i += 4) {\n        uint32x4_t current = vaddq_u32(idx, vdupq_n_u32(i));\n        uint32x4_t is_prime = vdupq_n_u32(1);\n\n        for (int j = 3; j * j <= n; j += 2) {\n            uint32x4_t div = vdupq_n_u32(j);\n            uint32x4_t mod = vmodq_u32(current, div);\n            is_prime = vandq_u32(is_prime, vceqq_u32(mod, vdupq_n_u32(0)));\n        }\n\n        uint32_t prime_flags[4];\n        vst1q_u32(prime_flags, is_prime);\n\n        for (int k = 0; k < 4 && i + k < n; ++k) {\n            if (prime_flags[k]) {\n                primes.push_back(i + k);\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = is_prime[1] = false;\n\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Initialize a bitmask to mark non-prime numbers\n    uint8x16_t bitmask = vdupq_n_u8(0xFF);\n    bitmask = vsetq_lane_u8(0, bitmask, 0); // 0 and 1 are not primes\n    bitmask = vsetq_lane_u8(0, bitmask, 1);\n\n    for (int i = 2; i < n; i += 16) {\n        uint8x16_t indices = vdupq_n_u8(i);\n        indices = vaddq_u8(indices, vcreate_u8(0x0102030405060708090A0B0C0D0E0F));\n\n        uint8x16_t is_prime = vandq_u8(bitmask, vcltq_u8(indices, vdupq_n_u8(n)));\n\n        for (int j = 0; j < 16; ++j) {\n            if (vgetq_lane_u8(is_prime, j)) {\n                bool prime = true;\n                for (int k = 2; k * k <= i + j; ++k) {\n                    if ((i + j) % k == 0) {\n                        prime = false;\n                        break;\n                    }\n                }\n                if (prime) {\n                    primes.push_back(i + j);\n                }\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> count_up_to_simd(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    // Initialize a bitmask to mark non-prime numbers\n    uint8x16_t bitmask = vdupq_n_u8(0xFF);\n    bitmask = vsetq_lane_u8(0, bitmask, 0); // 0 and 1 are not primes\n    bitmask = vsetq_lane_u8(0, bitmask, 1);\n\n    for (int i = 2; i < n; i += 16) {\n        uint8x16_t indices = vdupq_n_u8(i);\n        indices = vaddq_u8(indices, vcreate_u8(0x0102030405060708090A0B0C0D0E0F));\n\n        uint8x16_t is_prime = vandq_u8(bitmask, vcltq_u8(indices, vdupq_n_u8(n)));\n\n        for (int j = 0; j < 16; ++j) {\n            if (vgetq_lane_u8(is_prime, j)) {\n                bool prime = true;\n                for (int k = 2; k * k <= i + j; ++k) {\n                    if ((i + j) % k == 0) {\n                        prime = false;\n                        break;\n                    }\n                }\n                if (prime) {\n                    primes.push_back(i + j);\n                }\n            }\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    const char* data = s.c_str();\n    int length = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vdupq_n_u8('A');\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)(data + i));\n        uint8x16_t mask = vceqq_u8(chunk, vowels);\n        uint8x16_t even_mask = vandq_u8(mask, vdupq_n_u8(0x55));\n        count += vaddvq_u8(even_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    uint8x16_t vowels = vmovq_n_u8('A');\n    vowels = vsetq_lane_u8('E', vowels, 1);\n    vowels = vsetq_lane_u8('I', vowels, 2);\n    vowels = vsetq_lane_u8('O', vowels, 3);\n    vowels = vsetq_lane_u8('U', vowels, 4);\n\n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t mask = vcgeq_u8(chunk, vowels);\n        mask = vandq_u8(mask, vcleq_u8(chunk, vaddq_u8(vowels, vmovq_n_u8(4))));\n\n        uint8x16_t even_mask = vandq_u8(mask, vmovq_n_u8(0xAA));\n        uint8x16_t result = vpaddq_u8(even_mask, even_mask);\n        result = vpaddq_u8(result, result);\n        result = vpaddq_u8(result, result);\n\n        count += vgetq_lane_u8(result, 0);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    uint8x16_t vowels = vmovq_n_u8('A') | vmovq_n_u8('E') | vmovq_n_u8('I') | vmovq_n_u8('O') | vmovq_n_u8('U');\n    uint8x16_t mask = vmovq_n_u8(0x01);\n\n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t is_upper = vandq_u8(vceqq_u8(chunk, vowels), mask);\n        uint8x16_t even_indices = vandq_u8(is_upper, vmovq_n_u8(0x55));\n        count += vaddvq_u8(even_indices);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    const char* str = s.c_str();\n    int length = s.length();\n\n    uint8x16_t vowels = vmovq_n_u8('A') | vmovq_n_u8('E') | vmovq_n_u8('I') | vmovq_n_u8('O') | vmovq_n_u8('U');\n    uint8x16_t mask = vmovq_n_u8(0x01);\n\n    for (int i = 0; i < length; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t is_upper = vandq_u8(vceqq_u8(chunk, vowels), mask);\n        uint8x16_t even_indices = vandq_u8(is_upper, vmovq_n_u8(0x55));\n\n        count += vaddvq_u8(even_indices);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```c++\nint count_upper_simd(const std::string & s) {\n    const char* str = s.c_str();\n    int len = s.length();\n    int count = 0;\n\n    uint8x16_t vowels = vmovq_n_u8('A');\n    vowels = vorrq_u8(vowels, vmovq_n_u8('E'));\n    vowels = vorrq_u8(vowels, vmovq_n_u8('I'));\n    vowels = vorrq_u8(vowels, vmovq_n_u8('O'));\n    vowels = vorrq_u8(vowels, vmovq_n_u8('U'));\n\n    for (int i = 0; i < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8((const uint8_t*)&str[i]);\n        uint8x16_t mask = vceqq_u8(chunk, vowels);\n        uint8x16_t even_mask = vandq_u8(mask, vmovq_n_u8(0x55));\n        count += vaddvq_u8(even_mask);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = n % 2 == 0 ? vdupq_n_s32(2) : vdupq_n_s32(2);\n    int32x4_t current = vdupq_n_s32(n);\n    int32x4_t index = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t store_index = vaddq_s32(index, vdupq_n_s32(i));\n        int32x4_t store_values = vaddq_s32(current, vmulq_s32(store_index, increment));\n\n        if (i + 0 < n) result[i + 0] = vgetq_lane_s32(store_values, 0);\n        if (i + 1 < n) result[i + 1] = vgetq_lane_s32(store_values, 1);\n        if (i + 2 < n) result[i + 2] = vgetq_lane_s32(store_values, 2);\n        if (i + 3 < n) result[i + 3] = vgetq_lane_s32(store_values, 3);\n\n        current = vaddq_s32(current, vmulq_s32(vdupq_n_s32(4), increment));\n        index = vaddq_s32(index, vdupq_n_s32(4));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_start = vdupq_n_s32(n);\n    int32x4_t v_step = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n    int32x4_t v_index = {0, 1, 2, 3};\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_current = vaddq_s32(v_start, vmulq_s32(v_index, v_step));\n        vst1q_s32(result.data() + i, v_current);\n\n        v_start = vaddq_s32(v_start, vmulq_n_s32(v_step, 4));\n        v_index = vaddq_s32(v_index, vdupq_n_s32(4));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = n % 2 == 0 ? vdupq_n_s32(2) : vdupq_n_s32(2);\n    int32x4_t base = vdupq_n_s32(n);\n    int32x4_t index = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current = vaddq_s32(base, vmulq_s32(index, increment));\n        base = vaddq_s32(base, increment);\n        index = vaddq_s32(index, vdupq_n_s32(4));\n\n        if (i + 3 < n) {\n            vst1q_s32(&result[i], current);\n        } else {\n            if (i < n) result[i] = vgetq_lane_s32(current, 0);\n            if (i + 1 < n) result[i + 1] = vgetq_lane_s32(current, 1);\n            if (i + 2 < n) result[i + 2] = vgetq_lane_s32(current, 2);\n            if (i + 3 < n) result[i + 3] = vgetq_lane_s32(current, 3);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t increment = n % 2 == 0 ? vdupq_n_s32(2) : vdupq_n_s32(2);\n    int32x4_t base = vdupq_n_s32(n);\n    int32x4_t index = vdupq_n_s32(0);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t current = vaddq_s32(base, vmulq_s32(index, increment));\n        if (i + 0 < n) result[i + 0] = vgetq_lane_s32(current, 0);\n        if (i + 1 < n) result[i + 1] = vgetq_lane_s32(current, 1);\n        if (i + 2 < n) result[i + 2] = vgetq_lane_s32(current, 2);\n        if (i + 3 < n) result[i + 3] = vgetq_lane_s32(current, 3);\n        index = vaddq_s32(index, vdupq_n_s32(4));\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_start = vdupq_n_s32(n);\n    int32x4_t v_step = vdupq_n_s32(n % 2 == 0 ? 2 : 1);\n    int32x4_t v_index = vdupq_n_s32(0);\n    int32x4_t v_inc = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_current = vaddq_s32(v_start, vmulq_s32(v_index, v_step));\n        vst1q_s32(&result[i], v_current);\n        v_index = vaddq_s32(v_index, v_inc);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_m = vdupq_n_s64(m);\n    int64x2_t vec_count = vdupq_n_s64(count);\n\n    int64x2_t vec_sum = vdupq_n_s64(0);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t vec_i = vaddq_s64(vec_n, vdupq_n_s64(i - n));\n        vec_sum = vaddq_s64(vec_sum, vec_i);\n    }\n\n    sum = vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    // Use Neon intrinsics to compute the sum in parallel\n    int64x2_t v_n = vdupq_n_s64(n);\n    int64x2_t v_m = vdupq_n_s64(m);\n    int64x2_t v_count = vdupq_n_s64(count);\n    int64x2_t v_one = vdupq_n_s64(1);\n\n    int64x2_t v_sum = vdupq_n_s64(0);\n    int64x2_t v_i = v_n;\n\n    for (int64_t i = 0; i < count; i += 2) {\n        v_sum = vaddq_s64(v_sum, v_i);\n        v_i = vaddq_s64(v_i, v_one);\n    }\n\n    sum = vgetq_lane_s64(v_sum, 0) + vgetq_lane_s64(v_sum, 1);\n\n    int64_t avg = sum / count;\n    int64_t rounded_avg = (sum + count / 2) / count;\n\n    std::string binary = \"\";\n    while (rounded_avg > 0) {\n        binary = (rounded_avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t vec_n = vdupq_n_s64(n);\n    int64x2_t vec_m = vdupq_n_s64(m);\n    int64x2_t vec_count = vdupq_n_s64(count);\n    int64x2_t vec_one = vdupq_n_s64(1);\n\n    int64x2_t vec_i = vec_n;\n    int64x2_t vec_sum = vdupq_n_s64(0);\n\n    while (vgetq_lane_s64(vec_i, 0) <= m) {\n        vec_sum = vaddq_s64(vec_sum, vec_i);\n        vec_i = vaddq_s64(vec_i, vec_one);\n    }\n\n    sum = vgetq_lane_s64(vec_sum, 0) + vgetq_lane_s64(vec_sum, 1);\n\n    int64_t avg = sum / count;\n    int64_t rounded_avg = (sum + count / 2) / count;\n\n    std::string binary = \"\";\n    while (rounded_avg > 0) {\n        binary = std::to_string(rounded_avg % 2) + binary;\n        rounded_avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64x2_t nm = vcreate64_u64((uint64_t)m << 32 | (uint64_t)n);\n    int64x2_t sum = vpaddq_s64(nm, nm);\n    int64_t total_sum = vgetq_lane_s64(sum, 0);\n\n    int64_t count = m - n + 1;\n    int64_t avg = total_sum / count;\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = (avg % 2 == 0 ? \"0\" : \"1\") + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n\n    int64_t sum = 0;\n    int64_t count = m - n + 1;\n\n    int64x2_t v_n = vdupq_n_s64(n);\n    int64x2_t v_m = vdupq_n_s64(m);\n    int64x2_t v_count = vdupq_n_s64(count);\n\n    int64x2_t v_sum = vdupq_n_s64(0);\n\n    for (int64_t i = n; i <= m; i += 2) {\n        int64x2_t v_i = vdupq_n_s64(i);\n        int64x2_t v_i1 = vaddq_s64(v_i, vdupq_n_s64(1));\n\n        v_sum = vaddq_s64(v_sum, v_i);\n        if (i + 1 <= m) {\n            v_sum = vaddq_s64(v_sum, v_i1);\n        }\n    }\n\n    sum = vgetq_lane_s64(v_sum, 0) + vgetq_lane_s64(v_sum, 1);\n\n    int64_t avg = sum / count;\n\n    std::string binary = \"\";\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n\n    return binary.empty() ? \"0\" : binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_mod = vdupq_n_s32(10000);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_two = vdupq_n_s32(2);\n    int32x4_t v_index = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_i = vaddq_s32(v_index, vdupq_n_s32(i));\n        int32x4_t v_factorial = v_one;\n        int32x4_t v_sum = v_one;\n\n        for (int j = 2; j <= i + 4; ++j) {\n            int32x4_t v_j = vdupq_n_s32(j);\n            int32x4_t v_mask = vcgeq_s32(v_i, v_j);\n            v_factorial = vmulq_s32(v_factorial, vandq_s32(v_j, v_mask));\n            v_sum = vaddq_s32(v_sum, vandq_s32(v_j, v_mask));\n        }\n\n        int32x4_t v_even_mask = vtstq_s32(v_i, v_one);\n        int32x4_t v_result = vbslq_s32(v_even_mask, v_factorial, v_sum);\n        v_result = vmodq_s32(v_result, v_mod);\n\n        for (int k = 0; k < 4 && i + k < n; ++k) {\n            result[i + k] = vgetq_lane_s32(v_result, k);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_factorial = vdupq_n_s32(1);\n    int32x4_t v_sum = vdupq_n_s32(0);\n    int32x4_t v_index = vdupq_n_s32(1);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_mod = vdupq_n_s32(10000);\n    int32x4_t v_even_mask = vdupq_n_s32(0x1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_i = vaddq_s32(v_index, vdupq_n_s32(i));\n        int32x4_t v_even = vandq_s32(v_i, v_even_mask);\n\n        int32x4_t v_fact = v_factorial;\n        int32x4_t v_s = v_sum;\n\n        for (int j = 0; j < 4; ++j) {\n            int32x4_t v_j = vdupq_n_s32(j + 1);\n            v_fact = vmulq_s32(v_fact, v_j);\n            v_s = vaddq_s32(v_s, v_j);\n        }\n\n        v_fact = vmulq_s32(v_fact, v_even);\n        v_fact = vsubq_s32(v_fact, v_even);\n        v_fact = vaddq_s32(v_fact, v_s);\n\n        v_fact = vmodq_s32(v_fact, v_mod);\n\n        vst1q_s32(&result[i], v_fact);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t mod = vdupq_n_s32(10000);\n    int32x4_t one = vdupq_n_s32(1);\n    int32x4_t two = vdupq_n_s32(2);\n    int32x4_t four = vdupq_n_s32(4);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t indices = vaddq_s32(vdupq_n_s32(i), vsetq_lane_s32(1, vdupq_n_s32(0), 0));\n        indices = vaddq_s32(indices, vsetq_lane_s32(1, vdupq_n_s32(0), 1));\n        indices = vaddq_s32(indices, vsetq_lane_s32(1, vdupq_n_s32(0), 2));\n        indices = vaddq_s32(indices, vsetq_lane_s32(1, vdupq_n_s32(0), 3));\n\n        int32x4_t is_even = vtstq_s32(indices, one);\n        int32x4_t fact = one;\n        int32x4_t sum = one;\n\n        for (int j = 2; j <= n; ++j) {\n            int32x4_t j_vec = vdupq_n_s32(j);\n            fact = vmulq_s32(fact, j_vec);\n            sum = vaddq_s32(sum, j_vec);\n            fact = vandq_s32(fact, vceqq_s32(is_even, one));\n            sum = vandq_s32(sum, vceqq_s32(is_even, zero));\n        }\n\n        fact = vmodq_s32(fact, mod);\n        sum = vmodq_s32(sum, mod);\n\n        int32x4_t res = vorrq_s32(fact, sum);\n\n        if (i + 3 < n) {\n            vst1q_s32(&result[i], res);\n        } else {\n            int32_t temp[4];\n            vst1q_s32(temp, res);\n            for (int k = 0; k < n - i; ++k) {\n                result[i + k] = temp[k];\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_factorial = vdupq_n_s32(1);\n    int32x4_t v_sum = vdupq_n_s32(0);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_two = vdupq_n_s32(2);\n    int32x4_t v_mod = vdupq_n_s32(10000);\n    int32x4_t v_index = vdupq_n_s32(1);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_i = vaddq_s32(v_index, vdupq_n_s32(i));\n        int32x4_t v_even = vtstq_s32(v_i, v_one);\n        int32x4_t v_mask = vceqq_s32(v_even, v_one);\n\n        v_factorial = vmulq_s32(v_factorial, v_i);\n        v_factorial = vmodq_s32(v_factorial, v_mod);\n\n        v_sum = vaddq_s32(v_sum, v_i);\n\n        int32x4_t v_result = vbslq_s32(v_mask, v_factorial, v_sum);\n\n        for (int j = 0; j < 4 && i + j < n; ++j) {\n            result[i + j] = vgetq_lane_s32(v_result, j);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n);\n    int32x4_t v_factorial = vdupq_n_s32(1);\n    int32x4_t v_sum = vdupq_n_s32(0);\n    int32x4_t v_index = vdupq_n_s32(1);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_two = vdupq_n_s32(2);\n    int32x4_t v_mod = vdupq_n_s32(10000);\n\n    for (int i = 0; i < n; i += 4) {\n        int32x4_t v_i = vaddq_s32(v_index, vdupq_n_s32(i));\n        int32x4_t v_even_mask = vtstq_s32(v_i, v_one);\n        int32x4_t v_even = vandq_s32(v_even_mask, v_i);\n\n        v_sum = vaddq_s32(v_sum, v_even);\n        v_factorial = vmulq_s32(v_factorial, v_even);\n        v_factorial = vmodq_s32(v_factorial, v_mod);\n\n        int32x4_t v_odd = vsubq_s32(v_i, v_even);\n        int32x4_t v_odd_sum = vmulq_s32(v_odd, vaddq_s32(v_odd, v_one));\n        v_odd_sum = vshrq_n_s32(v_odd_sum, 1);\n\n        int32x4_t v_result = vbslq_s32(v_even_mask, v_factorial, v_odd_sum);\n        vst1q_s32(&result[i], v_result);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Process numbers in chunks of 8\n    for (int i = 1; i <= n; i += 8) {\n        int32x4_t numbers1 = vld1q_s32(&i);\n        int32x4_t numbers2 = vld1q_s32(&i + 4);\n\n        // Check if numbers are palindromes\n        int32x4_t palindromes1 = vceqq_s32(numbers1, vreinterpretq_s32_u32(vrev32q_u32(vreinterpretq_u32_s32(numbers1))));\n        int32x4_t palindromes2 = vceqq_s32(numbers2, vreinterpretq_s32_u32(vrev32q_u32(vreinterpretq_u32_s32(numbers2))));\n\n        // Check if palindromes are even or odd\n        int32x4_t even_mask1 = vandq_s32(palindromes1, vdupq_n_s32(1));\n        int32x4_t odd_mask1 = vbicq_s32(palindromes1, even_mask1);\n        int32x4_t even_mask2 = vandq_s32(palindromes2, vdupq_n_s32(1));\n        int32x4_t odd_mask2 = vbicq_s32(palindromes2, even_mask2);\n\n        // Count even and odd palindromes\n        even_count += vaddvq_s32(even_mask1) + vaddvq_s32(even_mask2);\n        odd_count += vaddvq_s32(odd_mask1) + vaddvq_s32(odd_mask2);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        int num = i;\n        int reversed = 0;\n        int temp = num;\n\n        while (temp > 0) {\n            reversed = reversed * 10 + temp % 10;\n            temp /= 10;\n        }\n\n        if (num == reversed) {\n            if (num % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    // Process numbers in chunks of 8\n    for (int i = 1; i <= n; i += 8) {\n        int32x4_t numbers1 = vld1q_s32(&i);\n        int32x4_t numbers2 = vld1q_s32(&i + 4);\n\n        // Check if numbers are palindromes\n        int32x4_t palindromes1 = vceqq_s32(numbers1, vreinterpretq_s32_u32(vrev32q_u32(vreinterpretq_u32_s32(numbers1))));\n        int32x4_t palindromes2 = vceqq_s32(numbers2, vreinterpretq_s32_u32(vrev32q_u32(vreinterpretq_u32_s32(numbers2))));\n\n        // Check if palindromes are even or odd\n        int32x4_t even_mask1 = vandq_s32(palindromes1, vdupq_n_s32(1));\n        int32x4_t odd_mask1 = vbicq_s32(palindromes1, vdupq_n_s32(1));\n        int32x4_t even_mask2 = vandq_s32(palindromes2, vdupq_n_s32(1));\n        int32x4_t odd_mask2 = vbicq_s32(palindromes2, vdupq_n_s32(1));\n\n        // Count even and odd palindromes\n        even_count += vaddvq_s32(even_mask1) + vaddvq_s32(even_mask2);\n        odd_count += vaddvq_s32(odd_mask1) + vaddvq_s32(odd_mask2);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    int32x4_t ones = vdupq_n_s32(1);\n    int32x4_t twos = vdupq_n_s32(2);\n    int32x4_t fives = vdupq_n_s32(5);\n    int32x4_t tens = vdupq_n_s32(10);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t numbers = vaddq_s32(vdupq_n_s32(i), ones);\n        int32x4_t reversed = vrev64q_s32(numbers);\n        int32x4_t is_palindrome = vceqq_s32(numbers, reversed);\n\n        int32x4_t even_mask = vandq_s32(is_palindrome, vceqq_s32(vandq_s32(numbers, ones), vdupq_n_s32(0)));\n        int32x4_t odd_mask = vandq_s32(is_palindrome, vceqq_s32(vandq_s32(numbers, ones), ones));\n\n        even_count += vaddvq_s32(even_mask);\n        odd_count += vaddvq_s32(odd_mask);\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n\n    int32x4_t ones = vdupq_n_s32(1);\n    int32x4_t twos = vdupq_n_s32(2);\n    int32x4_t tens = vdupq_n_s32(10);\n    int32x4_t twenties = vdupq_n_s32(20);\n    int32x4_t hundreds = vdupq_n_s32(100);\n    int32x4_t thousands = vdupq_n_s32(1000);\n\n    for (int i = 1; i <= n; i += 4) {\n        int32x4_t numbers = vaddq_s32(vdupq_n_s32(i), ones);\n        int32x4_t tens_digit = vdivq_s32(numbers, tens);\n        int32x4_t units_digit = vsubq_s32(numbers, vmulq_s32(tens_digit, tens));\n        int32x4_t reversed = vaddq_s32(vmulq_s32(tens_digit, ones), units_digit);\n\n        uint32x4_t is_palindrome = vceqq_s32(numbers, reversed);\n        uint32x4_t is_even = vceqq_s32(vandq_s32(numbers, ones), vdupq_n_s32(0));\n\n        even_count += vaddvq_s32(vandq_s32(is_palindrome, is_even));\n        odd_count += vaddvq_s32(vandq_s32(is_palindrome, vceqq_s32(is_even, vdupq_n_s32(0))));\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4; ++j) {\n            int32_t num = vgetq_lane_s32(abs_vec, j);\n            int32_t sum = 0;\n            while (num > 0) {\n                sum += num % 10;\n                num /= 10;\n            }\n            sum_vec = vsetq_lane_s32(sum, sum_vec, j);\n        }\n\n        uint32x4_t mask = vcgtq_s32(sum_vec, vdupq_n_s32(0));\n        count += vaddvq_u32(vmovl_u16(vreinterpret_u16_u32(mask)));\n    }\n\n    for (; i < size; ++i) {\n        int num = abs(n[i]);\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4; ++j) {\n            int32x4_t digit_vec = vdupq_n_s32(0);\n            int32x4_t temp_vec = abs_vec;\n            int32x4_t mask = vdupq_n_s32(10);\n\n            while (vgetq_lane_s32(temp_vec, j) > 0) {\n                digit_vec = vaddq_s32(digit_vec, vandq_s32(temp_vec, vdupq_n_s32(1)));\n                temp_vec = vdivq_s32(temp_vec, mask);\n            }\n\n            sum_vec = vaddq_s32(sum_vec, digit_vec);\n        }\n\n        int32x4_t result = vcgtq_s32(sum_vec, vdupq_n_s32(0));\n        count += vaddvq_s32(result);\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        num = abs(num);\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t abs_v = vabsq_s32(v);\n        int32x4_t sum = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4; ++j) {\n            int32x4_t digit = vdupq_n_s32(0);\n            int32x4_t temp = abs_v;\n\n            while (vmaxvq_s32(temp) > 0) {\n                digit = vaddq_s32(digit, vshrq_n_s32(vandq_s32(temp, vdupq_n_s32(15)), 4));\n                temp = vshrq_n_s32(temp, vdupq_n_s32(4));\n            }\n\n            sum = vaddq_s32(sum, digit);\n            abs_v = vshrq_n_s32(abs_v, vdupq_n_s32(4));\n        }\n\n        uint32x4_t mask = vcgtq_s32(sum, vdupq_n_s32(0));\n        count += vaddvq_u32(vmovl_u16(vget_low_u16(vreinterpretq_u16_u32(mask))));\n        count += vaddvq_u32(vmovl_high_u16(vreinterpretq_u16_u32(mask)));\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n\n        while (num != 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&n[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t sum_vec = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4; ++j) {\n            int32x4_t digit_vec = vdupq_n_s32(0);\n            int32x4_t temp_vec = abs_vec;\n\n            while (vgetq_lane_s32(temp_vec, j) > 0) {\n                digit_vec = vaddq_s32(digit_vec, vdupq_n_s32(vgetq_lane_s32(temp_vec, j) % 10));\n                temp_vec = vdupq_n_s32(vgetq_lane_s32(temp_vec, j) / 10);\n            }\n\n            sum_vec = vaddq_s32(sum_vec, digit_vec);\n        }\n\n        uint32x4_t mask = vcgtq_s32(sum_vec, vdupq_n_s32(0));\n        count += vaddvq_u32(mask);\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        num = abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```c++\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int size = n.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t abs_v = vabsq_s32(v);\n        int32x4_t sum_v = vdupq_n_s32(0);\n\n        for (int j = 0; j < 4; ++j) {\n            int32x4_t digit = vdupq_n_s32(0);\n            int32x4_t temp = abs_v;\n            int32x4_t mask = vdupq_n_s32(0);\n\n            for (int k = 0; k < 10; ++k) {\n                digit = vshrq_n_s32(temp, 28);\n                sum_v = vaddq_s32(sum_v, digit);\n                temp = vmulq_n_s32(temp, 10);\n                mask = vtstq_s32(temp, vdupq_n_s32(0xF0000000));\n                temp = vandq_s32(temp, vdupq_n_s32(0x0FFFFFFF));\n            }\n        }\n\n        int32x4_t result = vcgtq_s32(sum_v, vdupq_n_s32(0));\n        count += vaddvq_s32(result);\n    }\n\n    for (; i < size; ++i) {\n        int num = n[i];\n        int sum = 0;\n        bool negative = num < 0;\n        num = abs(num);\n\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n\n        if (negative) {\n            sum -= 1;\n        }\n\n        if (sum > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int min_index = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n\n    int start = min_index;\n    for (int i = 0; i < n; ++i) {\n        int current = (start + i) % n;\n        int next = (start + i + 1) % n;\n        if (arr[current] > arr[next]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int32x4_t min_val = vdupq_n_s32(arr[0]);\n    int32x4_t max_val = vdupq_n_s32(arr[0]);\n    int32x4_t diff = vdupq_n_s32(0);\n\n    for (int i = 0; i < N; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        min_val = vminq_s32(min_val, vec);\n        max_val = vmaxq_s32(max_val, vec);\n        diff = vsubq_s32(max_val, min_val);\n    }\n\n    int min = vminvq_s32(min_val);\n    int max = vmaxvq_s32(max_val);\n    int diff_val = vmaxvq_s32(diff);\n\n    if (diff_val == 0) return true;\n\n    int min_index = -1;\n    int max_index = -1;\n\n    for (int i = 0; i < N; ++i) {\n        if (arr[i] == min) min_index = i;\n        if (arr[i] == max) max_index = i;\n    }\n\n    if (min_index == -1 || max_index == -1) return false;\n\n    for (int i = 0; i < N; ++i) {\n        int j = (min_index + i) % N;\n        int k = (max_index + i) % N;\n        if (arr[j] > arr[(j + 1) % N] || arr[k] > arr[(k + 1) % N]) return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int min_index = 0;\n    int min_value = arr[0];\n\n    for (int i = 1; i < N; ++i) {\n        if (arr[i] < min_value) {\n            min_value = arr[i];\n            min_index = i;\n        }\n    }\n\n    int start = min_index;\n    int end = (min_index - 1 + N) % N;\n\n    for (int i = 0; i < N; ++i) {\n        if (arr[start] > arr[end]) {\n            return false;\n        }\n        start = end;\n        end = (end - 1 + N) % N;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n\n    int min_index = 0;\n    for (int i = 0; i < n; ++i) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n\n    int start = min_index;\n    for (int i = 0; i < n; ++i) {\n        int current = (start + i) % n;\n        int next = (start + i + 1) % n;\n        if (arr[current] > arr[next]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int N = arr.size();\n    if (N == 0) return true;\n\n    int min_index = 0;\n    int min_val = arr[0];\n\n    for (int i = 1; i < N; i++) {\n        if (arr[i] < min_val) {\n            min_val = arr[i];\n            min_index = i;\n        }\n    }\n\n    int start = min_index;\n    int end = (min_index - 1 + N) % N;\n\n    for (int i = 0; i < N; i++) {\n        if (arr[start] > arr[end]) {\n            return false;\n        }\n        start = end;\n        end = (end - 1 + N) % N;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    const int* ptr1 = lst1.data();\n    const int* ptr2 = lst2.data();\n    int size = lst1.size();\n\n    int even_count1 = 0;\n    int odd_count1 = 0;\n    int even_count2 = 0;\n    int odd_count2 = 0;\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(ptr1 + i);\n        int32x4_t vec2 = vld1q_s32(ptr2 + i);\n\n        uint32x4_t mask1 = vceqq_s32(vandq_s32(vec1, vdupq_n_s32(1)), vdupq_n_s32(0));\n        uint32x4_t mask2 = vceqq_s32(vandq_s32(vec2, vdupq_n_s32(1)), vdupq_n_s32(0));\n\n        even_count1 += vaddvq_u32(mask1);\n        odd_count1 += 4 - vaddvq_u32(mask1);\n        even_count2 += vaddvq_u32(mask2);\n        odd_count2 += 4 - vaddvq_u32(mask2);\n    }\n\n    if (odd_count1 <= even_count2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    const int* ptr1 = lst1.data();\n    const int* ptr2 = lst2.data();\n    size_t size = lst1.size();\n\n    int32x4_t even_mask = vdupq_n_s32(1);\n    int32x4_t odd_mask = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(ptr1 + i);\n        int32x4_t vec2 = vld1q_s32(ptr2 + i);\n\n        uint32x4_t is_even1 = vtstq_u32(vec1, even_mask);\n        uint32x4_t is_even2 = vtstq_u32(vec2, even_mask);\n\n        uint32x4_t is_odd1 = vtstq_u32(vec1, odd_mask);\n        uint32x4_t is_odd2 = vtstq_u32(vec2, odd_mask);\n\n        uint32x4_t can_exchange = vandq_u32(is_odd1, is_even2);\n\n        if (vmaxvq_u32(can_exchange) == 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    const int* ptr1 = lst1.data();\n    const int* ptr2 = lst2.data();\n    size_t size = lst1.size();\n\n    int32x4_t even_mask = vdupq_n_s32(1);\n    int32x4_t odd_mask = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(ptr1 + i);\n        int32x4_t vec2 = vld1q_s32(ptr2 + i);\n\n        uint32x4_t is_even1 = vtstq_u32(vec1, even_mask);\n        uint32x4_t is_even2 = vtstq_u32(vec2, even_mask);\n\n        uint32x4_t is_odd1 = vtstq_u32(vec1, odd_mask);\n        uint32x4_t is_odd2 = vtstq_u32(vec2, odd_mask);\n\n        uint32x4_t can_exchange = vandq_u32(is_odd1, is_even2);\n\n        if (vmaxvq_u32(can_exchange) == 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    const int size = lst1.size();\n    int32x4_t even_mask = vdupq_n_s32(1);\n    int32x4_t odd_mask = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n\n        uint32x4_t odd_elements1 = vtstq_u32(vec1, even_mask);\n        uint32x4_t odd_elements2 = vtstq_u32(vec2, even_mask);\n\n        uint32x4_t can_exchange = vandq_u32(odd_elements1, odd_elements2);\n\n        if (vmaxvq_u32(can_exchange) == 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    const int size = lst1.size();\n    int32x4_t even_mask = vdupq_n_s32(1);\n    int32x4_t odd_mask = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t vec1 = vld1q_s32(&lst1[i]);\n        int32x4_t vec2 = vld1q_s32(&lst2[i]);\n\n        uint32x4_t even_check1 = vtstq_u32(vec1, even_mask);\n        uint32x4_t even_check2 = vtstq_u32(vec2, even_mask);\n\n        uint32x4_t odd_check1 = vtstq_u32(vec1, odd_mask);\n        uint32x4_t odd_check2 = vtstq_u32(vec2, odd_mask);\n\n        if (vmaxvq_u32(odd_check1) != 0 && vmaxvq_u32(even_check2) == 0) {\n            return \"NO\";\n        }\n    }\n\n    return \"YES\";\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t odd_mask = vandq_u8(vec, vdupq_n_u8(1));\n            uint8x16_t odd_counts = vcntq_u8(odd_mask);\n            odd_count += vaddvq_u8(odd_counts);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time using Neon intrinsics\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t odd_mask = vandq_u8(vec, vdupq_n_u8(1));\n            odd_count += vaddvq_u8(vceqq_u8(odd_mask, vdupq_n_u8(1)));\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        // Construct the result string\n        std::string result_str = \"the number of odd elements \";\n        result_str += std::to_string(odd_count);\n        result_str += \"n the str\";\n        result_str += std::to_string(odd_count);\n        result_str += \"ng \";\n        result_str += std::to_string(odd_count);\n        result_str += \" of the \";\n        result_str += std::to_string(odd_count);\n        result_str += \"nput.\";\n\n        result.push_back(result_str);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t odd_mask = vandq_u8(vec, vdupq_n_u8(1));\n            odd_count += vaddvq_u8(vceqq_u8(odd_mask, vdupq_n_u8(1)));\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t odd_mask = vandq_u8(vec, vdupq_n_u8(1));\n            uint8x16_t odd_counts = vcntq_u8(odd_mask);\n            odd_count += vaddvq_u8(odd_counts);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n\n    for (const auto& str : lst) {\n        int odd_count = 0;\n        size_t len = str.length();\n        size_t i = 0;\n\n        // Process 16 characters at a time using Neon intrinsics\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(str.data() + i));\n            uint8x16_t odd_mask = vandq_u8(vec, vdupq_n_u8(1));\n            uint8x16_t odd_counts = vpaddlq_u8(vpaddlq_u8(odd_mask));\n            odd_count += vgetq_lane_u16(odd_counts, 0) + vgetq_lane_u16(odd_counts, 1) +\n                         vgetq_lane_u16(odd_counts, 2) + vgetq_lane_u16(odd_counts, 3) +\n                         vgetq_lane_u16(odd_counts, 4) + vgetq_lane_u16(odd_counts, 5) +\n                         vgetq_lane_u16(odd_counts, 6) + vgetq_lane_u16(odd_counts, 7);\n        }\n\n        // Process remaining characters\n        for (; i < len; ++i) {\n            if ((str[i] - '0') % 2 != 0) {\n                ++odd_count;\n            }\n        }\n\n        std::string output = \"the number of odd elements \" + std::to_string(odd_count) +\n                             \"n the str\" + std::to_string(odd_count) +\n                             \"ng \" + std::to_string(odd_count) +\n                             \" of the \" + std::to_string(odd_count) + \"nput.\";\n        result.push_back(output);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n\n    int size = nums.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int64x2_t v1 = vld1q_s64(&nums[i]);\n        int64x2_t v2 = vld1q_s64(&nums[i + 2]);\n\n        int64x2_t sum1 = vpaddq_s64(v1, v2);\n        int64x2_t sum2 = vpaddq_s64(sum1, sum1);\n\n        current_sum += vgetq_lane_s64(sum2, 0);\n\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n    }\n\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```c++\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    int64_t n = nums.size();\n\n    for (int64_t i = 0; i < n; i += 2) {\n        int64x2_t vec = vld1q_s64(&nums[i]);\n        current_sum += vaddvq_s64(vec);\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n\n    size_t size = nums.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int64x2_t v0 = vld1q_s64(&nums[i]);\n        int64x2_t v1 = vld1q_s64(&nums[i + 2]);\n\n        int64x2_t sum0 = vpaddq_s64(v0, v1);\n        int64_t sum = vgetq_lane_s64(sum0, 0) + vgetq_lane_s64(sum0, 1);\n\n        current_sum += sum;\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n\n    int64x2_t min_vec = vdupq_n_s64(INT64_MAX);\n    int64x2_t current_vec = vdupq_n_s64(0);\n\n    size_t size = nums.size();\n    size_t i = 0;\n\n    for (; i + 1 < size; i += 2) {\n        int64x2_t nums_vec = vld1q_s64(&nums[i]);\n        current_vec = vaddq_s64(current_vec, nums_vec);\n        min_vec = vminq_s64(min_vec, current_vec);\n    }\n\n    int64_t min_val[2];\n    vst1q_s64(min_val, min_vec);\n    min_sum = std::min(min_sum, std::min(min_val[0], min_val[1]));\n\n    for (; i < size; ++i) {\n        current_sum += nums[i];\n        min_sum = std::min(min_sum, current_sum);\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t min_sum = std::numeric_limits<int64_t>::max();\n    int64_t current_sum = 0;\n    int64_t min_val = std::numeric_limits<int64_t>::max();\n\n    int size = nums.size();\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int64x2_t v0 = vld1q_s64(&nums[i]);\n        int64x2_t v1 = vld1q_s64(&nums[i + 2]);\n\n        int64x2_t min_v0 = vminq_s64(v0, v1);\n        int64x2_t min_v1 = vminq_s64(min_v0, vdupq_n_s64(min_val));\n\n        min_val = vminvq_s64(min_v1);\n    }\n\n    for (; i < size; ++i) {\n        min_val = std::min(min_val, nums[i]);\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    int num_rows = grid.size();\n    int num_cols = grid[0].size();\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int j = 0;\n\n        for (; j <= num_cols - 16; j += 16) {\n            uint8x16_t water = vld1q_u8(reinterpret_cast<const uint8_t*>(row + j));\n            total_water += vaddvq_u8(water);\n        }\n\n        for (; j < num_cols; ++j) {\n            total_water += row[j];\n        }\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    int num_rows = grid.size();\n    int num_cols = grid[0].size();\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int j = 0;\n\n        for (; j <= num_cols - 16; j += 16) {\n            uint8x16_t water = vld1q_u8(row + j);\n            uint8x16_t sum = vpaddlq_u8(water);\n            sum = vpaddlq_u8(sum);\n            sum = vpaddlq_u8(sum);\n            total_water += vgetq_lane_u32(vreinterpretq_u32_u8(sum), 0);\n        }\n\n        for (; j < num_cols; ++j) {\n            total_water += row[j];\n        }\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    int num_rows = grid.size();\n    int num_cols = grid[0].size();\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int j = 0;\n\n        for (; j <= num_cols - 16; j += 16) {\n            uint8x16_t water = vld1q_u8(reinterpret_cast<const uint8_t*>(row + j));\n            uint8x16_t sum = vpaddlq_u8(water);\n            sum = vpaddlq_u8(sum);\n            sum = vpaddlq_u8(sum);\n            total_water += vgetq_lane_u8(sum, 0);\n        }\n\n        for (; j < num_cols; ++j) {\n            total_water += row[j];\n        }\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    int num_rows = grid.size();\n    int num_cols = grid[0].size();\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int j = 0;\n\n        for (; j <= num_cols - 16; j += 16) {\n            uint8x16_t water = vld1q_u8(row + j);\n            uint8x16_t sum = vpaddlq_u8(vpaddlq_u8(water));\n            total_water += vgetq_lane_u32(vreinterpret_u32_u8(sum), 0) +\n                          vgetq_lane_u32(vreinterpret_u32_u8(sum), 1) +\n                          vgetq_lane_u32(vreinterpret_u32_u8(sum), 2) +\n                          vgetq_lane_u32(vreinterpret_u32_u8(sum), 3);\n        }\n\n        for (; j < num_cols; ++j) {\n            total_water += row[j];\n        }\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int>>& grid, int capacity) {\n    int total_water = 0;\n    int num_rows = grid.size();\n    int num_cols = grid[0].size();\n\n    for (int i = 0; i < num_rows; ++i) {\n        const int* row = grid[i].data();\n        int j = 0;\n\n        for (; j <= num_cols - 16; j += 16) {\n            uint8x16_t water = vld1q_u8(row + j);\n            uint8x16_t sum = vpaddlq_u8(water);\n            sum = vpaddlq_u8(sum);\n            sum = vpaddlq_u8(sum);\n            total_water += vgetq_lane_u32(vreinterpretq_u32_u8(sum), 0);\n        }\n\n        for (; j < num_cols; ++j) {\n            total_water += row[j];\n        }\n    }\n\n    return (total_water + capacity - 1) / capacity;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        int16x8_t odd_elements = vandq_s16(vec, odd_mask);\n        int16x8_t odd_elements_mask = vcgtq_s16(odd_elements, vdupq_n_s16(0));\n        int16x8_t odd_elements_sum = vpaddq_s16(odd_elements_mask);\n        sum += vgetq_lane_s16(odd_elements_sum, 0) + vgetq_lane_s16(odd_elements_sum, 1);\n    }\n\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n\n    for (int i = 0; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        int16x8_t even_mask = {0, 1, 0, 1, 0, 1, 0, 1};\n\n        int16x8_t odd_elements = vandq_s16(vec, odd_mask);\n        int16x8_t even_positions = vandq_s16(vec, even_mask);\n\n        int16x8_t result = vandq_s16(odd_elements, even_positions);\n\n        sum += vaddvq_s16(result);\n    }\n\n    for (int i = (size / 8) * 8; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    for (; i <= size - 8; i += 8) {\n        int16x8_t v = vld1q_s16(&lst[i]);\n        int16x8_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        int16x8_t odd_elements = vandq_s16(v, odd_mask);\n        int16x4_t sum_low = vpadd_s16(vget_low_s16(odd_elements), vget_low_s16(odd_elements));\n        int16x4_t sum_high = vpadd_s16(vget_high_s16(odd_elements), vget_high_s16(odd_elements));\n        sum += vget_lane_s16(sum_low, 0) + vget_lane_s16(sum_low, 1) + vget_lane_s16(sum_high, 0) + vget_lane_s16(sum_high, 1);\n    }\n\n    for (; i < size; i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    for (; i <= size - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n        int16x8_t odd_mask = {1, 0, 1, 0, 1, 0, 1, 0};\n        int16x8_t odd_elements = vandq_s16(vec, odd_mask);\n        int16x8_t odd_elements_mask = vceqq_s16(odd_elements, odd_mask);\n        int16x8_t odd_elements_sum = vpaddq_s16(odd_elements_mask);\n        sum += vgetq_lane_s16(odd_elements_sum, 0) + vgetq_lane_s16(odd_elements_sum, 1);\n    }\n\n    for (; i < size; ++i) {\n        if (i % 2 == 0 && lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c++\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    int size = lst.size();\n\n    for (int i = 0; i < size; i += 8) {\n        int16x8_t vec = vld1q_s16(&lst[i]);\n\n        uint16x8_t odd_mask = vmovq_n_u16(1);\n        uint16x8_t even_mask = vmovq_n_u16(0);\n\n        uint16x8_t odd_elements = vandq_u16(vreinterpretq_u16_s16(vec), odd_mask);\n        uint16x8_t even_elements = vandq_u16(vreinterpretq_u16_s16(vec), even_mask);\n\n        uint16x8_t result = vandq_u16(odd_elements, even_mask);\n\n        int16x8_t result_s16 = vreinterpretq_s16_u16(result);\n\n        int16x4_t sum_low = vpadd_s16(vget_low_s16(result_s16), vget_low_s16(result_s16));\n        int16x4_t sum_high = vpadd_s16(vget_high_s16(result_s16), vget_high_s16(result_s16));\n\n        sum += vget_lane_s16(sum_low, 0) + vget_lane_s16(sum_low, 1) +\n               vget_lane_s16(sum_high, 0) + vget_lane_s16(sum_high, 1);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t mask = vandq_s32(vcgtq_s32(v, vdupq_n_s32(9)), vcltq_s32(v, vdupq_n_s32(100)));\n        int32x4_t filtered = vbslq_s32(mask, v, vdupq_n_s32(0));\n        sum += vaddvq_s32(filtered);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= 10 && arr[i] < 100) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t mask = vandq_s32(vcgeq_s32(v, vdupq_n_s32(10)), vcleq_s32(v, vdupq_n_s32(99)));\n        int32x4_t filtered = vbslq_s32(mask, v, vdupq_n_s32(0));\n        sum += vaddvq_s32(filtered);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t mask = vandq_s32(vcgeq_s32(v, vdupq_n_s32(10)), vcleq_s32(v, vdupq_n_s32(99)));\n        int32x4_t filtered = vbslq_s32(mask, v, vdupq_n_s32(0));\n        sum += vaddvq_s32(filtered);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t mask = vandq_s32(vcgeq_s32(v, vdupq_n_s32(10)), vcleq_s32(v, vdupq_n_s32(99)));\n        int32x4_t filtered = vandq_s32(v, mask);\n        sum += vaddvq_s32(filtered);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int sum = 0;\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t mask = vandq_s32(vcgtq_s32(v, vdupq_n_s32(9)), vcgtq_s32(vdupq_n_s32(99), v));\n        int32x4_t filtered = vandq_s32(v, mask);\n        sum += vaddvq_s32(filtered);\n    }\n\n    // Process remaining elements\n    for (; i < k; ++i) {\n        if (arr[i] >= 10 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() < 2) {\n        return true;\n    }\n\n    int32x4_t prev = vdupq_n_s32(lst[0]);\n    int32x4_t curr;\n    int32x4_t mask;\n\n    for (size_t i = 1; i < lst.size(); i += 4) {\n        curr = vld1q_s32(&lst[i]);\n\n        mask = vcltq_s32(prev, curr);\n        if (vaddvq_s32(mask) != 16) {\n            return false;\n        }\n\n        mask = vceqq_s32(prev, curr);\n        if (vaddvq_s32(mask) != 0) {\n            return false;\n        }\n\n        prev = curr;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    if (lst.size() < 2) {\n        return true;\n    }\n\n    const int* data = lst.data();\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Check for duplicates using SIMD\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(data + i);\n        int32x4_t v_next = vld1q_s32(data + i + 1);\n        uint32x4_t eq = vceqq_s32(v, v_next);\n        if (vaddvq_u32(eq) > 0) {\n            return false;\n        }\n    }\n\n    // Check for duplicates in the remaining elements\n    for (; i < size - 1; ++i) {\n        if (data[i] == data[i + 1]) {\n            return false;\n        }\n    }\n\n    // Check if the list is sorted using SIMD\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(data + i);\n        int32x4_t v_next = vld1q_s32(data + i + 1);\n        uint32x4_t lt = vcltq_s32(v, v_next);\n        if (vaddvq_u32(lt) < 4) {\n            return false;\n        }\n    }\n\n    // Check the remaining elements\n    for (; i < size - 1; ++i) {\n        if (data[i] >= data[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\nbool is_sorted_simd(const std::vector<int> & lst) {\n    const int* data = lst.data();\n    int size = lst.size();\n\n    if (size < 2) {\n        return true;\n    }\n\n    for (int i = 0; i < size - 1; i += 4) {\n        int32x4_t v1 = vld1q_s32(data + i);\n        int32x4_t v2 = vld1q_s32(data + i + 1);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n        if (vaddvq_u32(cmp) != 4) {\n            return false;\n        }\n\n        if (i + 4 < size) {\n            int32x4_t v3 = vld1q_s32(data + i + 2);\n            uint32x4_t cmp2 = vcltq_s32(v2, v3);\n            if (vaddvq_u32(cmp2) != 4) {\n                return false;\n            }\n        }\n    }\n\n    for (int i = 1; i < size; ++i) {\n        if (data[i] == data[i - 1] && (i + 1 < size && data[i] == data[i + 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    const int* data = lst.data();\n    int size = lst.size();\n\n    if (size < 2) {\n        return true;\n    }\n\n    for (int i = 0; i < size - 1; i += 4) {\n        int32x4_t v1 = vld1q_s32(data + i);\n        int32x4_t v2 = vld1q_s32(data + i + 1);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n        if (vaddvq_u32(cmp) != 4) {\n            return false;\n        }\n\n        if (i + 4 < size) {\n            int32x4_t v3 = vld1q_s32(data + i + 2);\n            uint32x4_t cmp2 = vcltq_s32(v2, v3);\n            if (vaddvq_u32(cmp2) != 4) {\n                return false;\n            }\n        }\n    }\n\n    for (int i = 1; i < size; ++i) {\n        if (lst[i] == lst[i - 1] && (i + 1 < size && lst[i] == lst[i + 1])) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int>& lst) {\n    if (lst.size() < 2) {\n        return true;\n    }\n\n    const int* data = lst.data();\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Check for duplicates using SIMD\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(data + i);\n        int32x4_t v_next = vld1q_s32(data + i + 1);\n        uint32x4_t eq = vceqq_s32(v, v_next);\n        if (vaddvq_u32(eq) > 0) {\n            return false;\n        }\n    }\n\n    // Check for duplicates in the remaining elements\n    for (; i < size - 1; ++i) {\n        if (data[i] == data[i + 1]) {\n            return false;\n        }\n    }\n\n    // Check for sorted order using SIMD\n    for (i = 0; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(data + i);\n        int32x4_t v_next = vld1q_s32(data + i + 1);\n        uint32x4_t lt = vcltq_s32(v, v_next);\n        if (vaddvq_u32(lt) < 4) {\n            return false;\n        }\n    }\n\n    // Check for sorted order in the remaining elements\n    for (; i < size - 1; ++i) {\n        if (data[i] > data[i + 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int>& arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i = 0;\n    for (; i <= arr.size() - 4; i += 4) {\n        int32x4_t val_vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_val_vec = vabsq_s32(val_vec);\n        sum_vec = vaddq_s32(sum_vec, abs_val_vec);\n\n        int32x4_t sign_mask = vcltq_s32(val_vec, zero_vec);\n        sign_vec = vmulq_s32(sign_vec, vbslq_s32(sign_mask, neg_one_vec, sign_mask));\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int sign = vgetq_lane_s32(sign_vec, 0);\n\n    for (; i < arr.size(); ++i) {\n        sum += abs(arr[i]);\n        if (arr[i] < 0) {\n            sign *= -1;\n        } else if (arr[i] == 0) {\n            sign = 0;\n        }\n    }\n\n    return sum * sign;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int32x4_t one_vec = vdupq_n_s32(1);\n    int32x4_t neg_one_vec = vdupq_n_s32(-1);\n\n    size_t i = 0;\n    size_t size = arr.size();\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n\n        int32x4_t sign = vbslq_s32(vceqq_s32(vec, zero_vec), zero_vec, vbslq_s32(vcltq_s32(vec, zero_vec), neg_one_vec, one_vec));\n        sign_vec = vmulq_s32(sign_vec, sign);\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int sign = vgetq_lane_s32(sign_vec, 0) * vgetq_lane_s32(sign_vec, 1) * vgetq_lane_s32(sign_vec, 2) * vgetq_lane_s32(sign_vec, 3);\n\n    for (; i < size; ++i) {\n        sum += abs(arr[i]);\n        sign *= (arr[i] > 0) - (arr[i] < 0);\n    }\n\n    return sum * sign;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_vec = vdupq_n_s32(1);\n\n    size_t i = 0;\n    size_t size = arr.size();\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n\n        int32x4_t sign_vec = vshrq_n_s32(vec, 31);\n        sign_vec = veorq_s32(sign_vec, vdupq_n_s32(1));\n        prod_vec = vmulq_s32(prod_vec, sign_vec);\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int prod = vgetq_lane_s32(prod_vec, 0) * vgetq_lane_s32(prod_vec, 1) * vgetq_lane_s32(prod_vec, 2) * vgetq_lane_s32(prod_vec, 3);\n\n    for (; i < size; ++i) {\n        sum += abs(arr[i]);\n        prod *= (arr[i] >> 31) ^ 1;\n    }\n\n    return sum * prod;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t prod_signs_vec = vdupq_n_s32(1);\n\n    size_t i = 0;\n    size_t size = arr.size();\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n\n        int32x4_t signs = vshrq_n_s32(vec, 31);\n        signs = veorq_s32(signs, vdupq_n_s32(1));\n        prod_signs_vec = vmulq_s32(prod_signs_vec, signs);\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int prod_signs = vgetq_lane_s32(prod_signs_vec, 0) * vgetq_lane_s32(prod_signs_vec, 1) *\n                     vgetq_lane_s32(prod_signs_vec, 2) * vgetq_lane_s32(prod_signs_vec, 3);\n\n    for (; i < size; ++i) {\n        sum += abs(arr[i]);\n        prod_signs *= (arr[i] == 0) ? 0 : (arr[i] > 0) ? 1 : -1;\n    }\n\n    return sum * prod_signs;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```c++\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int32x4_t sign_vec = vdupq_n_s32(1);\n\n    size_t i = 0;\n    for (; i <= arr.size() - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_vec = vaddq_s32(sum_vec, abs_vec);\n\n        int32x4_t zero_mask = vceqq_s32(vec, vdupq_n_s32(0));\n        int32x4_t sign_mask = vshrq_n_s32(vec, 31);\n        sign_mask = veorq_s32(sign_mask, zero_mask);\n        sign_mask = vsubq_s32(vdupq_n_s32(1), sign_mask);\n        sign_vec = vmulq_s32(sign_vec, sign_mask);\n    }\n\n    int sum = vaddvq_s32(sum_vec);\n    int sign = vgetq_lane_s32(sign_vec, 0);\n\n    for (; i < arr.size(); ++i) {\n        sum += abs(arr[i]);\n        sign *= (arr[i] == 0) ? 0 : (arr[i] < 0) ? -1 : 1;\n    }\n\n    return sum * sign;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, std::numeric_limits<int>::max());\n    std::vector<int> current_path(k);\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            current_path[0] = grid[start_row][start_col];\n            std::vector<std::pair<int, int>> stack = {{start_row, start_col}};\n            std::vector<int> visited(N, 0);\n\n            while (!stack.empty()) {\n                auto [row, col] = stack.back();\n                stack.pop_back();\n                visited[row] = col + 1;\n\n                for (int step = 1; step < k; ++step) {\n                    std::vector<std::pair<int, int>> neighbors;\n                    if (row > 0) neighbors.emplace_back(row - 1, col);\n                    if (row < N - 1) neighbors.emplace_back(row + 1, col);\n                    if (col > 0) neighbors.emplace_back(row, col - 1);\n                    if (col < N - 1) neighbors.emplace_back(row, col + 1);\n\n                    int min_neighbor = std::numeric_limits<int>::max();\n                    for (const auto& [nr, nc] : neighbors) {\n                        if (visited[nr] != nc + 1) {\n                            min_neighbor = std::min(min_neighbor, grid[nr][nc]);\n                        }\n                    }\n\n                    current_path[step] = min_neighbor;\n                    stack.emplace_back(row, col);\n                }\n\n                if (current_path < min_path) {\n                    min_path = current_path;\n                }\n\n                visited[row] = 0;\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, std::numeric_limits<int>::max());\n    std::vector<int> current_path(k);\n\n    auto is_valid = [&](int x, int y) {\n        return x >= 0 && x < N && y >= 0 && y < N;\n    };\n\n    auto dfs = [&](auto&& self, int x, int y, int depth) -> void {\n        if (depth == k) {\n            if (current_path < min_path) {\n                min_path = current_path;\n            }\n            return;\n        }\n\n        int directions[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        for (auto& dir : directions) {\n            int nx = x + dir[0];\n            int ny = y + dir[1];\n            if (is_valid(nx, ny)) {\n                current_path[depth] = grid[nx][ny];\n                self(self, nx, ny, depth + 1);\n            }\n        }\n    };\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            current_path[0] = grid[i][j];\n            dfs(dfs, i, j, 1);\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, std::numeric_limits<int>::max());\n    std::vector<int> current_path(k);\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            current_path[0] = grid[start_row][start_col];\n            std::vector<std::pair<int, int>> stack = {{start_row, start_col}};\n            std::vector<std::vector<bool>> visited(N, std::vector<bool>(N, false));\n            visited[start_row][start_col] = true;\n\n            while (!stack.empty()) {\n                auto [row, col] = stack.back();\n                stack.pop_back();\n\n                if (stack.size() == k) {\n                    if (current_path < min_path) {\n                        min_path = current_path;\n                    }\n                    continue;\n                }\n\n                std::vector<std::pair<int, int>> neighbors = {\n                    {row - 1, col}, {row + 1, col}, {row, col - 1}, {row, col + 1}\n                };\n\n                for (auto [nr, nc] : neighbors) {\n                    if (nr >= 0 && nr < N && nc >= 0 && nc < N && !visited[nr][nc]) {\n                        current_path[stack.size()] = grid[nr][nc];\n                        stack.push_back({nr, nc});\n                        visited[nr][nc] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<int> minPath(k, std::numeric_limits<int>::max());\n    std::vector<int> currentPath(k);\n\n    for (int startRow = 0; startRow < N; ++startRow) {\n        for (int startCol = 0; startCol < N; ++startCol) {\n            currentPath[0] = grid[startRow][startCol];\n            for (int step = 1; step < k; ++step) {\n                int minVal = std::numeric_limits<int>::max();\n                for (int dr = -1; dr <= 1; ++dr) {\n                    for (int dc = -1; dc <= 1; ++dc) {\n                        if (dr == 0 && dc == 0) continue;\n                        int newRow = startRow + dr;\n                        int newCol = startCol + dc;\n                        if (newRow >= 0 && newRow < N && newCol >= 0 && newCol < N) {\n                            minVal = std::min(minVal, grid[newRow][newCol]);\n                        }\n                    }\n                }\n                currentPath[step] = minVal;\n            }\n\n            if (std::lexicographical_compare(currentPath.begin(), currentPath.end(), minPath.begin(), minPath.end())) {\n                minPath = currentPath;\n            }\n        }\n    }\n\n    return minPath;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int>>& grid, int k) {\n    int N = grid.size();\n    std::vector<int> min_path(k, INT_MAX);\n    std::vector<int> current_path(k);\n\n    for (int start_row = 0; start_row < N; ++start_row) {\n        for (int start_col = 0; start_col < N; ++start_col) {\n            current_path[0] = grid[start_row][start_col];\n            std::vector<std::pair<int, int>> stack = {{start_row, start_col}};\n\n            while (!stack.empty()) {\n                auto [row, col] = stack.back();\n                stack.pop_back();\n\n                for (int step = 1; step < k; ++step) {\n                    std::vector<std::pair<int, int>> neighbors;\n                    if (row > 0) neighbors.emplace_back(row - 1, col);\n                    if (row < N - 1) neighbors.emplace_back(row + 1, col);\n                    if (col > 0) neighbors.emplace_back(row, col - 1);\n                    if (col < N - 1) neighbors.emplace_back(row, col + 1);\n\n                    for (const auto& [n_row, n_col] : neighbors) {\n                        current_path[step] = grid[n_row][n_col];\n                        stack.emplace_back(n_row, n_col);\n                    }\n                }\n\n                if (current_path < min_path) {\n                    min_path = current_path;\n                }\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\nuint64_t digits_simd(uint64_t n) {\n    uint64x2_t product = vdupq_n_u64(1);\n    uint64x2_t zero = vdupq_n_u64(0);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n    uint64x2_t ten = vdupq_n_u64(10);\n\n    while (n > 0) {\n        uint64x2_t digit = vdupq_n_u64(n % 10);\n        uint64x2_t is_odd = vandq_u64(vsubq_u64(digit, one), one);\n        product = vmulq_u64(product, vbslq_u64(is_odd, digit, one));\n        n /= 10;\n    }\n\n    uint64x2_t result = vgetq_lane_u64(product, 0);\n    return vgetq_lane_u64(vmaxq_u64(result, zero), 0);\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\nuint64_t digits_simd(uint64_t n) {\n    uint64x2_t product = vdupq_n_u64(1);\n    uint64x2_t zero = vdupq_n_u64(0);\n    uint64x2_t mask = vdupq_n_u64(1);\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        uint64x2_t current_digit = vdupq_n_u64(digit);\n        uint64x2_t is_odd = vandq_u64(current_digit, mask);\n\n        product = vmulq_u64(product, vbslq_u64(is_odd, current_digit, vdupq_n_u64(1)));\n    }\n\n    uint64_t result = vgetq_lane_u64(product, 0) * vgetq_lane_u64(product, 1);\n    return result == 1 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\nuint64_t digits_simd(uint64_t n) {\n    uint64x2_t product = vdupq_n_u64(1);\n    uint64x2_t zero = vdupq_n_u64(0);\n    uint64x2_t mask = vdupq_n_u64(1);\n\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n\n        uint64x2_t current_digit = vdupq_n_u64(digit);\n        uint64x2_t is_odd = vandq_u64(vandq_u64(current_digit, mask), mask);\n\n        product = vmulq_u64(product, vmaxq_u64(is_odd, zero));\n    }\n\n    uint64_t result = vgetq_lane_u64(product, 0) * vgetq_lane_u64(product, 1);\n    return result == 1 ? 0 : result;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\nuint64_t digits_simd(uint64_t n) {\n    uint64x2_t product = vdupq_n_u64(1);\n    uint64x2_t zero = vdupq_n_u64(0);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n    uint64x2_t ten = vdupq_n_u64(10);\n\n    while (n > 0) {\n        uint64x2_t digit = vdupq_n_u64(n % 10);\n        uint64x2_t is_odd = vandq_u64(vsubq_u64(digit, one), one);\n        product = vmulq_u64(product, vmaxq_u64(is_odd, one));\n        n /= 10;\n    }\n\n    uint64x2_t result = vmaxq_u64(vgetq_lane_u64(product, 0), vgetq_lane_u64(product, 1));\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\nuint64_t digits_simd(uint64_t n) {\n    uint64x2_t product = vdupq_n_u64(1);\n    uint64x2_t zero = vdupq_n_u64(0);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n    uint64x2_t ten = vdupq_n_u64(10);\n\n    while (n > 0) {\n        uint64x2_t digit = vdupq_n_u64(n % 10);\n        uint64x2_t is_odd = vandq_u64(vsubq_u64(digit, one), one);\n        product = vmulq_u64(product, vmaxq_u64(is_odd, one));\n        n /= 10;\n    }\n\n    uint64x2_t result = vmaxq_u64(product, zero);\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    float32x4_t vec_sum = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec);\n        vec = vmulq_f32(vec, vec);\n        vec_sum = vaddq_f32(vec_sum, vec);\n    }\n\n    float sum_array[4];\n    vst1q_f32(sum_array, vec_sum);\n    sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t size = lst.size();\n    size_t i = 0;\n\n    // Process elements in chunks of 4\n    for (; i + 3 < size; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        float32x4_t v_ceil = vcvtq_f32_u32(vcvtq_u32_f32(v));\n        float32x4_t v_squared = vmulq_f32(v_ceil, v_ceil);\n        float32x2_t v_sum = vadd_f32(vget_low_f32(v_squared), vget_high_f32(v_squared));\n        sum += vget_lane_f32(v_sum, 0) + vget_lane_f32(v_sum, 1);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float val = ceilf(lst[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    const float* data = lst.data();\n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        vec = vcvtq_f32_u32(vcvtq_u32_f32(vec));\n        vec = vmulq_f32(vec, vec);\n        float32x2_t sum_vec = vpadd_f32(vget_low_f32(vec), vget_high_f32(vec));\n        sum += vget_lane_f32(sum_vec, 0) + vget_lane_f32(sum_vec, 1);\n    }\n\n    for (; i < size; ++i) {\n        sum += std::ceil(lst[i]) * std::ceil(lst[i]);\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```c++\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    const float* data = lst.data();\n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        vec = vceilq_f32(vec);\n        vec = vmulq_f32(vec, vec);\n        float32x2_t sum_vec = vpadd_f32(vget_low_f32(vec), vget_high_f32(vec));\n        sum += vget_lane_f32(sum_vec, 0) + vget_lane_f32(sum_vec, 1);\n    }\n\n    for (; i < size; ++i) {\n        float val = std::ceil(data[i]);\n        sum += val * val;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    float32x4_t vec_sum = vdupq_n_f32(0.0f);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        vec = vceilq_f32(vec);\n        vec = vmulq_f32(vec, vec);\n        vec_sum = vaddq_f32(vec_sum, vec);\n    }\n\n    float sum_array[4];\n    vst1q_f32(sum_array, vec_sum);\n    sum = sum_array[0] + sum_array[1] + sum_array[2] + sum_array[3];\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    int i = 0;\n\n    while (i <= n - 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n\n        if (vaddvq_u32(cmp) != 4) {\n            uint32x4_t indices = {i, i + 1, i + 2, i + 3};\n            uint32x4_t mask = vandq_u32(cmp, indices);\n            result = vmaxvq_u32(mask);\n            break;\n        }\n\n        i += 4;\n    }\n\n    for (; i < n - 1; ++i) {\n        if (arr[i] >= arr[i + 1]) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n\n        if (vaddvq_u32(cmp) != 4) {\n            uint32_t mask = vgetq_lane_u32(cmp, 0);\n            if (mask == 0) result = i;\n            mask = vgetq_lane_u32(cmp, 1);\n            if (mask == 0) result = i + 1;\n            mask = vgetq_lane_u32(cmp, 2);\n            if (mask == 0) result = i + 2;\n            mask = vgetq_lane_u32(cmp, 3);\n            if (mask == 0) result = i + 3;\n        }\n    }\n\n    for (; i < n - 1; ++i) {\n        if (arr[i] >= arr[i + 1]) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int>& arr) {\n    const int size = arr.size();\n    if (size < 2) return -1;\n\n    int max_index = -1;\n    int i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n\n        if (vaddvq_u32(cmp) < 4) {\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] >= arr[i + j + 1]) {\n                    max_index = i + j;\n                }\n            }\n        }\n    }\n\n    for (; i < size - 1; ++i) {\n        if (arr[i] >= arr[i + 1]) {\n            max_index = i;\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n        uint32x4_t mask = vmovq_n_u32(0xFFFFFFFF);\n\n        if (vgetq_lane_u32(cmp, 0) == 0) result = i;\n        if (vgetq_lane_u32(cmp, 1) == 0) result = i + 1;\n        if (vgetq_lane_u32(cmp, 2) == 0) result = i + 2;\n        if (vgetq_lane_u32(cmp, 3) == 0) result = i + 3;\n    }\n\n    for (; i < n - 1; ++i) {\n        if (arr[i] >= arr[i + 1]) {\n            result = i;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```c++\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) return -1;\n\n    int result = -1;\n    int i = 0;\n\n    while (i <= n - 4) {\n        int32x4_t v1 = vld1q_s32(&arr[i]);\n        int32x4_t v2 = vld1q_s32(&arr[i + 1]);\n\n        uint32x4_t cmp = vcltq_s32(v1, v2);\n\n        if (vaddvq_u32(cmp) != 4) {\n            for (int j = 0; j < 4; ++j) {\n                if (arr[i + j] >= arr[i + j + 1]) {\n                    result = i + j + 1;\n                }\n            }\n            break;\n        }\n\n        i += 4;\n    }\n\n    while (i < n - 1) {\n        if (arr[i] >= arr[i + 1]) {\n            result = i + 1;\n        }\n        ++i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t v_neg_max = vdupq_n_s32(INT32_MIN);\n    int32x4_t v_pos_min = vdupq_n_s32(INT32_MAX);\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    int neg_max = INT32_MIN;\n    int pos_min = INT32_MAX;\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v_data = vld1q_s32(&lst[i]);\n\n        int32x4_t v_neg = vminq_s32(v_data, v_zero);\n        int32x4_t v_pos = vmaxq_s32(v_data, v_zero);\n\n        v_neg_max = vmaxq_s32(v_neg_max, v_neg);\n        v_pos_min = vminq_s32(v_pos_min, v_pos);\n    }\n\n    int32x2_t v_neg_max_lo = vget_low_s32(v_neg_max);\n    int32x2_t v_neg_max_hi = vget_high_s32(v_neg_max);\n    int32x2_t v_pos_min_lo = vget_low_s32(v_pos_min);\n    int32x2_t v_pos_min_hi = vget_high_s32(v_pos_min);\n\n    neg_max = std::max(neg_max, std::max(vget_lane_s32(v_neg_max_lo, 0), std::max(vget_lane_s32(v_neg_max_lo, 1), std::max(vget_lane_s32(v_neg_max_hi, 0), vget_lane_s32(v_neg_max_hi, 1)))));\n    pos_min = std::min(pos_min, std::min(vget_lane_s32(v_pos_min_lo, 0), std::min(vget_lane_s32(v_pos_min_lo, 1), std::min(vget_lane_s32(v_pos_min_hi, 0), vget_lane_s32(v_pos_min_hi, 1)))));\n\n    if (neg_max == INT32_MIN) neg_max = 0;\n    if (pos_min == INT32_MAX) pos_min = 0;\n\n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t vmax_neg = vdupq_n_s32(INT_MIN);\n    int32x4_t vmin_pos = vdupq_n_s32(INT_MAX);\n    int32x4_t vzero = vdupq_n_s32(0);\n\n    for (size_t i = 0; i < lst.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n\n        int32x4_t vneg = vminq_s32(v, vzero);\n        int32x4_t vpos = vmaxq_s32(v, vzero);\n\n        vmax_neg = vmaxq_s32(vmax_neg, vneg);\n        vmin_pos = vminq_s32(vmin_pos, vpos);\n    }\n\n    int32_t max_neg = vmaxvq_s32(vmax_neg);\n    int32_t min_pos = vminvq_s32(vmin_pos);\n\n    if (max_neg == INT_MIN) max_neg = 0;\n    if (min_pos == INT_MAX) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcgeq_s32(vec, vdupq_n_s32(0));\n        int32x4_t pos_mask = vcleq_s32(vec, vdupq_n_s32(0));\n\n        int32x4_t neg_values = vbslq_s32(neg_mask, vec, vdupq_n_s32(std::numeric_limits<int>::min()));\n        int32x4_t pos_values = vbslq_s32(pos_mask, vec, vdupq_n_s32(std::numeric_limits<int>::max()));\n\n        max_neg = vmaxq_s32(max_neg, neg_values);\n        min_pos = vminq_s32(min_pos, pos_values);\n    }\n\n    int max_neg_scalar = vmaxvq_s32(max_neg);\n    int min_pos_scalar = vminvq_s32(min_pos);\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > max_neg_scalar) {\n            max_neg_scalar = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < min_pos_scalar) {\n            min_pos_scalar = lst[i];\n        }\n    }\n\n    return {max_neg_scalar < 0 ? max_neg_scalar : 0, min_pos_scalar > 0 ? min_pos_scalar : 0};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t v_neg_max = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t v_pos_min = vdupq_n_s32(std::numeric_limits<int>::max());\n\n    size_t size = lst.size();\n    size_t i = 0;\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t v_neg = vminq_s32(v, vdupq_n_s32(0));\n        int32x4_t v_pos = vmaxq_s32(v, vdupq_n_s32(0));\n\n        v_neg_max = vmaxq_s32(v_neg_max, v_neg);\n        v_pos_min = vminq_s32(v_pos_min, v_pos);\n    }\n\n    int neg_max = std::numeric_limits<int>::min();\n    int pos_min = std::numeric_limits<int>::max();\n\n    for (; i < size; ++i) {\n        if (lst[i] < 0 && lst[i] > neg_max) {\n            neg_max = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < pos_min) {\n            pos_min = lst[i];\n        }\n    }\n\n    int32_t neg_max_arr[4];\n    int32_t pos_min_arr[4];\n    vst1q_s32(neg_max_arr, v_neg_max);\n    vst1q_s32(pos_min_arr, v_pos_min);\n\n    for (int j = 0; j < 4; ++j) {\n        if (neg_max_arr[j] > neg_max) {\n            neg_max = neg_max_arr[j];\n        }\n        if (pos_min_arr[j] < pos_min) {\n            pos_min = pos_min_arr[j];\n        }\n    }\n\n    return { neg_max < 0 ? neg_max : 0, pos_min > 0 ? pos_min : 0 };\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int32x4_t max_neg = vdupq_n_s32(std::numeric_limits<int>::min());\n    int32x4_t min_pos = vdupq_n_s32(std::numeric_limits<int>::max());\n\n    size_t i = 0;\n    for (; i + 4 <= lst.size(); i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t neg_mask = vcgeq_s32(vec, vdupq_n_s32(0));\n        int32x4_t pos_mask = vcleq_s32(vec, vdupq_n_s32(0));\n\n        max_neg = vmaxq_s32(max_neg, vandq_s32(vec, neg_mask));\n        min_pos = vminq_s32(min_pos, vandq_s32(vec, pos_mask));\n    }\n\n    int max_neg_val = std::numeric_limits<int>::min();\n    int min_pos_val = std::numeric_limits<int>::max();\n\n    for (; i < lst.size(); ++i) {\n        if (lst[i] < 0 && lst[i] > max_neg_val) {\n            max_neg_val = lst[i];\n        }\n        if (lst[i] > 0 && lst[i] < min_pos_val) {\n            min_pos_val = lst[i];\n        }\n    }\n\n    max_neg_val = vmaxvq_s32(max_neg);\n    min_pos_val = vminvq_s32(min_pos);\n\n    return {max_neg_val < 0 ? max_neg_val : 0, min_pos_val > 0 ? min_pos_val : 0};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64x2_t i_vec = vdupq_n_u64(i);\n        uint64x2_t factorial = vdupq_n_u64(1);\n\n        for (uint64_t j = 1; j <= i; ++j) {\n            uint64x2_t j_vec = vdupq_n_u64(j);\n            factorial = vmulq_u64(factorial, j_vec);\n        }\n\n        result = vmulq_u64(result, factorial);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t i = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(i, 0) <= n) {\n        uint64x2_t temp = vdupq_n_u64(1);\n        uint64x2_t j = vdupq_n_u64(1);\n        uint64x2_t current_i = vdupq_n_u64(vgetq_lane_u64(i, 0));\n\n        while (vgetq_lane_u64(j, 0) <= vgetq_lane_u64(current_i, 0)) {\n            temp = vmulq_u64(temp, j);\n            j = vaddq_u64(j, one);\n        }\n\n        result = vmulq_u64(result, temp);\n        i = vaddq_u64(i, one);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t i = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(i, 0) <= n) {\n        uint64x2_t temp = vdupq_n_u64(1);\n        uint64x2_t j = vdupq_n_u64(1);\n\n        while (vgetq_lane_u64(j, 0) <= vgetq_lane_u64(i, 0)) {\n            temp = vmulq_u64(temp, j);\n            j = vaddq_u64(j, one);\n        }\n\n        result = vmulq_u64(result, temp);\n        i = vaddq_u64(i, one);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t factorial = 1;\n\n    for (uint64_t i = 1; i <= n; ++i) {\n        factorial *= i;\n        result *= factorial;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64x2_t result = vdupq_n_u64(1);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t i = vdupq_n_u64(1);\n\n    while (vgetq_lane_u64(i, 0) <= n) {\n        result = vmulq_u64(result, i);\n        i = vaddq_u64(i, one);\n    }\n\n    return vgetq_lane_u64(result, 0);\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n\n        // Create masks for multiples of 3 and 4\n        uint32x4_t mask3 = vceqq_u32(vandq_u32(indices, vdupq_n_u32(3)), vdupq_n_u32(0));\n        uint32x4_t mask4 = vceqq_u32(vandq_u32(indices, vdupq_n_u32(4)), vdupq_n_u32(0));\n        uint32x4_t mask3_not = vbicq_u32(mask4, mask3);\n\n        // Square elements at multiples of 3\n        int32x4_t squared = vmulq_s32(vec, vec);\n        int32x4_t result = vbslq_s32(mask3, squared, vec);\n\n        // Cube elements at multiples of 4 but not 3\n        int32x4_t cubed = vmulq_s32(vmulq_s32(vec, vec), vec);\n        result = vbslq_s32(mask3_not, cubed, result);\n\n        // Sum the results\n        sum += vaddvq_s32(result);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using Neon intrinsics\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n        uint32x4_t mask_mult_3 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n        uint32x4_t mask_mult_4 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(4)), vdupq_n_s32(0));\n        uint32x4_t mask_mult_4_not_3 = vandq_u32(mask_mult_4, vmvnq_u32(mask_mult_3));\n\n        int32x4_t squared = vmulq_s32(v, v);\n        int32x4_t cubed = vmulq_s32(v, vmulq_s32(v, v));\n\n        int32x4_t result = vbslq_s32(mask_mult_3, squared, vbslq_s32(mask_mult_4_not_3, cubed, v));\n\n        sum += vaddvq_s32(result);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using SIMD\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n\n        // Create masks for multiples of 3 and 4\n        uint32x4_t mask_mult_3 = vcgeq_s32(vandq_s32(indices, vdupq_n_s32(2)), vdupq_n_s32(0));\n        uint32x4_t mask_mult_4 = vcgeq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n\n        // Square elements at multiples of 3\n        int32x4_t squared = vmulq_s32(v, v);\n        v = vbslq_s32(mask_mult_3, squared, v);\n\n        // Cube elements at multiples of 4 but not 3\n        int32x4_t cubed = vmulq_s32(vmulq_s32(v, v), v);\n        v = vbslq_s32(vandq_u32(mask_mult_4, vmvnq_u32(mask_mult_3)), cubed, v);\n\n        // Sum the elements\n        sum += vaddvq_s32(v);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using SIMD\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n\n        // Create masks for multiples of 3 and 4\n        uint32x4_t mask3 = vcgeq_s32(vandq_s32(indices, vdupq_n_s32(2)), vdupq_n_s32(2));\n        uint32x4_t mask4 = vcgeq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(3));\n        uint32x4_t mask3_not = vbicq_u32(vdupq_n_u32(0xFFFFFFFF), mask3);\n\n        // Apply masks\n        int32x4_t v_squared = vmulq_s32(v, v);\n        int32x4_t v_cubed = vmulq_s32(v, vmulq_s32(v, v));\n        int32x4_t result = vbslq_s32(mask3, v_squared, vbslq_s32(vandq_u32(mask4, mask3_not), v_cubed, v));\n\n        // Sum the results\n        sum += vaddvq_s32(result);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int>& lst) {\n    int sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process 4 elements at a time using SIMD\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        int32x4_t indices = {i, i + 1, i + 2, i + 3};\n\n        // Check if indices are multiples of 3\n        uint32x4_t mask3 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(2)), vdupq_n_s32(0));\n        // Check if indices are multiples of 4\n        uint32x4_t mask4 = vceqq_s32(vandq_s32(indices, vdupq_n_s32(3)), vdupq_n_s32(0));\n\n        // Square elements where index is a multiple of 3\n        int32x4_t squared = vmulq_s32(v, v);\n        v = vbslq_s32(mask3, squared, v);\n\n        // Cube elements where index is a multiple of 4 but not 3\n        int32x4_t cubed = vmulq_s32(vmulq_s32(v, v), v);\n        v = vbslq_s32(vandq_u32(mask4, vmvnq_u32(mask3)), cubed, v);\n\n        // Sum the elements\n        sum += vaddvq_s32(v);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    const int* data = nums.data();\n    int size = nums.size();\n\n    int32x4_t v_ten = vdupq_n_s32(10);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_three = vdupq_n_s32(3);\n    int32x4_t v_five = vdupq_n_s32(5);\n    int32x4_t v_seven = vdupq_n_s32(7);\n    int32x4_t v_nine = vdupq_n_s32(9);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t v_nums = vld1q_s32(data + i);\n        int32x4_t v_abs_nums = vabsq_s32(v_nums);\n\n        uint32x4_t v_gt_ten = vcgtq_s32(v_abs_nums, v_ten);\n\n        int32x4_t v_first_digit = v_nums;\n        int32x4_t v_last_digit = v_nums;\n\n        for (int j = 0; j < 3; ++j) {\n            v_first_digit = vshrq_n_s32(v_first_digit, 1);\n            v_last_digit = vshrq_n_s32(v_last_digit, 4);\n        }\n\n        v_first_digit = vandq_s32(v_first_digit, vdupq_n_s32(0xF));\n        v_last_digit = vandq_s32(v_last_digit, vdupq_n_s32(0xF));\n\n        uint32x4_t v_first_odd = vorrq_u32(\n            vorrq_u32(vceqq_s32(v_first_digit, v_one), vceqq_s32(v_first_digit, v_three)),\n            vorrq_u32(vceqq_s32(v_first_digit, v_five), vceqq_s32(v_first_digit, v_seven))\n        );\n        v_first_odd = vorrq_u32(v_first_odd, vceqq_s32(v_first_digit, v_nine));\n\n        uint32x4_t v_last_odd = vorrq_u32(\n            vorrq_u32(vceqq_s32(v_last_digit, v_one), vceqq_s32(v_last_digit, v_three)),\n            vorrq_u32(vceqq_s32(v_last_digit, v_five), vceqq_s32(v_last_digit, v_seven))\n        );\n        v_last_odd = vorrq_u32(v_last_odd, vceqq_s32(v_last_digit, v_nine));\n\n        uint32x4_t v_special = vandq_u32(v_gt_ten, vandq_u32(v_first_odd, v_last_odd));\n\n        count += vaddvq_u32(v_special);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int i = 0;\n\n    // Load constants for comparison\n    int32x4_t ten = vdupq_n_s32(10);\n    int32x4_t odd_digits = vdupq_n_s32(0x55555555); // 01010101... in binary\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Check if elements are greater than 10\n        uint32x4_t mask_gt_10 = vcgtq_s32(vec, ten);\n\n        // Extract first and last digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digit = vshrq_n_s32(abs_vec, 31 - __builtin_clz(10));\n        int32x4_t last_digit = vabsq_s32(vandq_s32(abs_vec, vdupq_n_s32(9)));\n\n        // Check if first and last digits are odd\n        uint32x4_t mask_first_odd = vandq_u32(vreinterpretq_u32_s32(first_digit), odd_digits);\n        uint32x4_t mask_last_odd = vandq_u32(vreinterpretq_u32_s32(last_digit), odd_digits);\n\n        // Combine masks\n        uint32x4_t mask = vandq_u32(mask_gt_10, vandq_u32(mask_first_odd, mask_last_odd));\n\n        // Count the number of 1s in the mask\n        count += vaddvq_u32(mask);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int first_digit = abs(num) / 1000000000 % 10;\n            int last_digit = abs(num) % 10;\n            if ((first_digit & 1) && (last_digit & 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int i = 0;\n\n    // Define masks for odd digits\n    const int32x4_t odd_mask = vdupq_n_s32(0x11111111);\n\n    // Process in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n\n        // Check if elements are greater than 10\n        uint32x4_t gt_10_mask = vcgtq_s32(v, vdupq_n_s32(10));\n\n        // Extract first and last digits\n        int32x4_t abs_v = vabsq_s32(v);\n        int32x4_t first_digit = vshrq_n_s32(abs_v, 28);\n        int32x4_t last_digit = vabsq_s32(vandq_s32(abs_v, vdupq_n_s32(0xF)));\n\n        // Check if first and last digits are odd\n        uint32x4_t first_odd_mask = vandq_u32(vreinterpretq_u32_s32(first_digit), odd_mask);\n        uint32x4_t last_odd_mask = vandq_u32(vreinterpretq_u32_s32(last_digit), odd_mask);\n\n        // Combine masks\n        uint32x4_t combined_mask = vandq_u32(gt_10_mask, vandq_u32(first_odd_mask, last_odd_mask));\n\n        // Count the number of 1s in the combined mask\n        count += vaddvq_u32(combined_mask);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int first_digit = abs(num) / 1000000000 % 10;\n            int last_digit = abs(num) % 10;\n            if ((first_digit & 1) && (last_digit & 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```c++\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int i = 0;\n\n    // Define masks for odd digits\n    const int32x4_t odd_mask = vdupq_n_s32(0x11111111); // 0x11111111 in hex is 1717986918 in decimal\n    const int32x4_t mask_10 = vdupq_n_s32(10);\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n        int32x4_t abs_vec = vabsq_s32(vec);\n\n        // Check if the number is greater than 10\n        uint32x4_t gt_10_mask = vcgtq_s32(abs_vec, mask_10);\n\n        // Extract first and last digits\n        int32x4_t first_digit = vshrq_n_s32(abs_vec, 28); // Shift right to get the first digit\n        int32x4_t last_digit = vabsq_s32(vandq_s32(abs_vec, vdupq_n_s32(0xF))); // Mask to get the last digit\n\n        // Check if both digits are odd\n        uint32x4_t first_odd_mask = vtstq_s32(first_digit, odd_mask);\n        uint32x4_t last_odd_mask = vtstq_s32(last_digit, odd_mask);\n\n        // Combine masks\n        uint32x4_t combined_mask = vandq_u32(gt_10_mask, vandq_u32(first_odd_mask, last_odd_mask));\n\n        // Count the number of 1s in the combined mask\n        count += vaddvq_u32(combined_mask);\n    }\n\n    // Handle remaining elements\n    for (; i < size; ++i) {\n        int num = nums[i];\n        int abs_num = abs(num);\n        if (abs_num > 10) {\n            int first_digit = abs_num / 1000000000 % 10;\n            int last_digit = abs_num % 10;\n            if ((first_digit & 1) && (last_digit & 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int size = nums.size();\n    int i = 0;\n\n    // Define masks for odd digits\n    const int32x4_t odd_digits_mask = vdupq_n_s32(0x55555555);\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&nums[i]);\n\n        // Check if elements are greater than 10\n        uint32x4_t gt_10_mask = vcgtq_s32(vec, vdupq_n_s32(10));\n\n        // Extract first and last digits\n        int32x4_t abs_vec = vabsq_s32(vec);\n        int32x4_t first_digit = vshrq_n_s32(abs_vec, 31 - __builtin_clz(1000000000));\n        int32x4_t last_digit = vabsq_s32(vandq_s32(abs_vec, vdupq_n_s32(9)));\n\n        // Check if first and last digits are odd\n        uint32x4_t first_odd_mask = vtstq_s32(first_digit, odd_digits_mask);\n        uint32x4_t last_odd_mask = vtstq_s32(last_digit, odd_digits_mask);\n\n        // Combine masks\n        uint32x4_t combined_mask = vandq_u32(gt_10_mask, vandq_u32(first_odd_mask, last_odd_mask));\n\n        // Count the number of 1s in the combined mask\n        count += vaddvq_u32(vshrn_n_u64(vreinterpretq_u64_u32(combined_mask), 32));\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        int num = nums[i];\n        if (num > 10) {\n            int first_digit = abs(num) / 1000000000;\n            int last_digit = abs(num) % 10;\n            if ((first_digit & 1) && (last_digit & 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t i, j, k;\n    uint64x2_t v_i, v_j, v_k;\n    uint64x2_t v_a_i, v_a_j, v_a_k;\n    uint64x2_t v_sum;\n    uint64x2_t v_mod;\n    uint64x2_t v_zero = vdupq_n_u64(0);\n    uint64x2_t v_three = vdupq_n_u64(3);\n\n    for (i = 1; i <= n - 2; i += 2) {\n        v_i = vdupq_n_u64(i);\n        v_a_i = vsubq_u64(vmulq_u64(v_i, v_i), v_i);\n        v_a_i = vaddq_u64(v_a_i, vdupq_n_u64(1));\n\n        for (j = i + 1; j <= n - 1; j += 2) {\n            v_j = vdupq_n_u64(j);\n            v_a_j = vsubq_u64(vmulq_u64(v_j, v_j), v_j);\n            v_a_j = vaddq_u64(v_a_j, vdupq_n_u64(1));\n\n            for (k = j + 1; k <= n; k += 2) {\n                v_k = vdupq_n_u64(k);\n                v_a_k = vsubq_u64(vmulq_u64(v_k, v_k), v_k);\n                v_a_k = vaddq_u64(v_a_k, vdupq_n_u64(1));\n\n                v_sum = vaddq_u64(v_a_i, v_a_j);\n                v_sum = vaddq_u64(v_sum, v_a_k);\n                v_mod = vsubq_u64(v_sum, vandq_u64(v_sum, v_three));\n\n                if (vgetq_lane_u64(v_mod, 0) == 0) count++;\n                if (vgetq_lane_u64(v_mod, 1) == 0) count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t i, j, k;\n\n    for (i = 1; i <= n; ++i) {\n        uint64_t ai = i * i - i + 1;\n        for (j = i + 1; j <= n; ++j) {\n            uint64_t aj = j * j - j + 1;\n            for (k = j + 1; k <= n; ++k) {\n                uint64_t ak = k * k - k + 1;\n\n                uint64x2_t vec1 = vld1q_u64(&ai);\n                uint64x2_t vec2 = vld1q_u64(&aj);\n                uint64x2_t vec3 = vld1q_u64(&ak);\n\n                uint64x2_t sum = vaddq_u64(vaddq_u64(vec1, vec2), vec3);\n\n                uint64_t sum_scalar = vgetq_lane_u64(sum, 0);\n\n                if (sum_scalar % 3 == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t i, j, k;\n\n    for (i = 1; i <= n; ++i) {\n        uint64_t ai = i * i - i + 1;\n        for (j = i + 1; j <= n; ++j) {\n            uint64_t aj = j * j - j + 1;\n            for (k = j + 1; k <= n; ++k) {\n                uint64_t ak = k * k - k + 1;\n\n                uint64x2_t vec = {ai + aj + ak, 0};\n                uint64x2_t mod3 = vdivq_u64(vec, vdupq_n_u64(3));\n                mod3 = vmulq_u64(mod3, vdupq_n_u64(3));\n                uint64x2_t result = vsubq_u64(vec, mod3);\n\n                if (vgetq_lane_u64(result, 0) == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t i, j, k;\n\n    for (i = 1; i <= n; ++i) {\n        uint64_t ai = i * i - i + 1;\n        for (j = i + 1; j <= n; ++j) {\n            uint64_t aj = j * j - j + 1;\n            for (k = j + 1; k <= n; ++k) {\n                uint64_t ak = k * k - k + 1;\n\n                uint64x2_t vec1 = vdupq_n_u64(ai);\n                uint64x2_t vec2 = vdupq_n_u64(aj);\n                uint64x2_t vec3 = vdupq_n_u64(ak);\n\n                uint64x2_t sum = vaddq_u64(vaddq_u64(vec1, vec2), vec3);\n                uint64x2_t mod3 = vsubq_u64(sum, vmulq_u64(vdivq_u64(sum, vdupq_n_u64(3)), vdupq_n_u64(3)));\n\n                if (vgetq_lane_u64(mod3, 0) == 0) {\n                    ++count;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count = 0;\n    uint64_t i, j, k;\n    uint64x2_t v_i, v_j, v_k;\n    uint64x2_t v_a_i, v_a_j, v_a_k;\n    uint64x2_t v_sum;\n    uint64x2_t v_mod3;\n    uint64x2_t v_zero = vdupq_n_u64(0);\n    uint64x2_t v_three = vdupq_n_u64(3);\n\n    for (i = 1; i <= n; i++) {\n        v_i = vdupq_n_u64(i);\n        v_a_i = vsubq_u64(vmulq_u64(v_i, v_i), v_i);\n        v_a_i = vaddq_u64(v_a_i, vdupq_n_u64(1));\n\n        for (j = i + 1; j <= n; j++) {\n            v_j = vdupq_n_u64(j);\n            v_a_j = vsubq_u64(vmulq_u64(v_j, v_j), v_j);\n            v_a_j = vaddq_u64(v_a_j, vdupq_n_u64(1));\n\n            for (k = j + 1; k <= n; k += 2) {\n                v_k = vdupq_n_u64(k);\n                v_a_k = vsubq_u64(vmulq_u64(v_k, v_k), v_k);\n                v_a_k = vaddq_u64(v_a_k, vdupq_n_u64(1));\n\n                v_sum = vaddq_u64(v_a_i, v_a_j);\n                v_sum = vaddq_u64(v_sum, v_a_k);\n\n                v_mod3 = vsubq_u64(v_sum, vandq_u64(v_sum, v_three));\n                v_mod3 = vceqq_u64(v_mod3, v_zero);\n\n                if (vgetq_lane_u64(v_mod3, 0)) count++;\n                if (vgetq_lane_u64(v_mod3, 1)) count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n\n    uint32x4_t mask = vdupq_n_u32(0);\n    uint32x4_t one = vdupq_n_u32(1);\n\n    for (int i = 2; i * i <= n; ++i) {\n        uint32x4_t i_vec = vdupq_n_u32(i);\n        uint32x4_t div = vdivq_u32(n_vec, i_vec);\n        uint32x4_t mod = vmlsq_u32(n_vec, div, i_vec);\n        mask = vorrq_u32(mask, vceqq_u32(mod, vdupq_n_u32(0)));\n    }\n\n    uint32x4_t is_prime = vceqq_u32(mask, vdupq_n_u32(0));\n    int32x4_t result = vbslq_s32(is_prime, x_vec, y_vec);\n\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_2 = vdupq_n_s32(2);\n    int32x4_t vec_3 = vdupq_n_s32(3);\n    int32x4_t vec_5 = vdupq_n_s32(5);\n    int32x4_t vec_7 = vdupq_n_s32(7);\n\n    uint32x4_t mask = vandq_u32(vcgeq_s32(vec_n, vec_2), vcgeq_s32(vec_n, vec_3));\n    mask = vandq_u32(mask, vandq_u32(vcgeq_s32(vec_n, vec_5), vcgeq_s32(vec_n, vec_7)));\n\n    uint32x4_t prime_mask = vandq_u32(mask, vandq_u32(vceqq_s32(vec_n, vec_2), vceqq_s32(vec_n, vec_3)));\n    prime_mask = vorrq_u32(prime_mask, vandq_u32(vceqq_s32(vec_n, vec_5), vceqq_s32(vec_n, vec_7)));\n\n    uint32_t is_prime = vgetq_lane_u32(prime_mask, 0);\n\n    return is_prime ? x : y;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_2 = vdupq_n_s32(2);\n    int32x4_t vec_3 = vdupq_n_s32(3);\n    int32x4_t vec_5 = vdupq_n_s32(5);\n    int32x4_t vec_7 = vdupq_n_s32(7);\n\n    uint32x4_t mask = vandq_u32(\n        vcgeq_s32(vec_n, vec_2),\n        vandq_u32(\n            vcgeq_s32(vec_n, vec_3),\n            vandq_u32(\n                vcgeq_s32(vec_n, vec_5),\n                vcgeq_s32(vec_n, vec_7)\n            )\n        )\n    );\n\n    uint32x4_t prime_mask = vandq_u32(\n        vceqq_s32(vec_n, vec_2),\n        vorrq_u32(\n            vceqq_s32(vec_n, vec_3),\n            vorrq_u32(\n                vceqq_s32(vec_n, vec_5),\n                vceqq_s32(vec_n, vec_7)\n            )\n        )\n    );\n\n    uint32x4_t result_mask = vandq_u32(mask, prime_mask);\n    int32x4_t result = vbslq_s32(result_mask, vdupq_n_s32(x), vdupq_n_s32(y));\n\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t vec_n = vdupq_n_s32(n);\n    int32x4_t vec_2 = vdupq_n_s32(2);\n    int32x4_t vec_3 = vdupq_n_s32(3);\n    int32x4_t vec_5 = vdupq_n_s32(5);\n    int32x4_t vec_7 = vdupq_n_s32(7);\n\n    uint32x4_t mask_2 = vceqq_s32(vec_n, vec_2);\n    uint32x4_t mask_3 = vceqq_s32(vec_n, vec_3);\n    uint32x4_t mask_5 = vceqq_s32(vec_n, vec_5);\n    uint32x4_t mask_7 = vceqq_s32(vec_n, vec_7);\n\n    uint32x4_t mask_prime = vorrq_u32(mask_2, vorrq_u32(mask_3, vorrq_u32(mask_5, mask_7)));\n\n    int32x4_t vec_x = vdupq_n_s32(x);\n    int32x4_t vec_y = vdupq_n_s32(y);\n\n    int32x4_t result = vbslq_s32(mask_prime, vec_x, vec_y);\n\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    int32x4_t n_vec = vdupq_n_s32(n);\n    int32x4_t x_vec = vdupq_n_s32(x);\n    int32x4_t y_vec = vdupq_n_s32(y);\n\n    int32x4_t result = vbslq_s32(vcgeq_s32(n_vec, vdupq_n_s32(2)), x_vec, y_vec);\n\n    return vgetq_lane_s32(result, 0);\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t mask = vandq_u32(vcgeq_f32(v, vdupq_n_f32(0)), vcltq_f32(v, vdupq_n_f32(INT_MAX)));\n        uint32x4_t odd_mask = vandq_u32(mask, vceqq_f32(vandq_f32(v, vdupq_n_f32(1)), vdupq_n_f32(0)));\n        float32x4_t odd_squares = vmulq_f32(vmulq_f32(v, v), vreinterpretq_f32_u32(odd_mask));\n        sum += vaddvq_f32(odd_squares);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float num = lst[i];\n        if (num >= 0 && num < INT_MAX && fmod(num, 2) != 0) {\n            sum += num * num;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t mask = vandq_u32(vcvtq_u32_f32(v), vdupq_n_u32(1)); // Check if the number is odd\n        mask = vandq_u32(mask, vcgeq_f32(v, vdupq_n_f32(0))); // Check if the number is non-negative\n        float32x4_t squares = vmulq_f32(v, v); // Compute squares\n        squares = vmulq_f32(squares, vcvtq_f32_u32(mask)); // Zero out non-odd or negative numbers\n        sum += vaddvq_f32(squares); // Sum the squares\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float num = lst[i];\n        if (num >= 0 && fmod(num, 2) != 0) {\n            sum += num * num;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t mask = vandq_u32(vcgeq_f32(v, vdupq_n_f32(0.0f)), vcltq_f32(v, vdupq_n_f32(INT_MAX)));\n        mask = vandq_u32(mask, vceqq_f32(vsubq_f32(v, vcvtq_f32_u32(vcvtq_u32_f32(v))), vdupq_n_f32(0.0f)));\n        mask = vandq_u32(mask, vcgeq_f32(vsubq_f32(v, vdupq_n_f32(1.0f)), vdupq_n_f32(0.0f)));\n        float32x4_t odd_squares = vmulq_f32(v, v);\n        odd_squares = vbslq_f32(mask, odd_squares, vdupq_n_f32(0.0f));\n        sum += vaddvq_f32(odd_squares);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float num = lst[i];\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += num * num;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    const int32_t* data = reinterpret_cast<const int32_t*>(lst.data());\n    int size = lst.size();\n\n    int32x4_t v_zero = vdupq_n_s32(0);\n    int32x4_t v_one = vdupq_n_s32(1);\n    int32x4_t v_two = vdupq_n_s32(2);\n    int32x4_t v_sum = vdupq_n_s32(0);\n\n    for (int i = 0; i < size; i += 4) {\n        int32x4_t v_data = vld1q_s32(data + i);\n        int32x4_t v_abs_data = vabsq_s32(v_data);\n        uint32x4_t v_is_odd = vceqq_u32(vandq_u32(vcvtq_u32_s32(v_abs_data), v_one), v_one);\n        uint32x4_t v_is_positive = vcgtq_s32(v_data, v_zero);\n        uint32x4_t v_mask = vandq_u32(v_is_odd, v_is_positive);\n        int32x4_t v_squared = vmulq_s32(v_data, v_data);\n        v_squared = vbslq_s32(v_mask, v_squared, v_zero);\n        v_sum = vaddq_s32(v_sum, v_squared);\n    }\n\n    int32x2_t v_sum_low = vadd_s32(vget_low_s32(v_sum), vget_high_s32(v_sum));\n    sum = vget_lane_s32(vpadd_s32(v_sum_low, v_sum_low), 0);\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c++\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int size = lst.size();\n    int i = 0;\n\n    // Process elements in chunks of 4\n    for (; i <= size - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        uint32x4_t mask = vandq_u32(vcgeq_f32(v, vdupq_n_f32(0.0f)), vcltq_f32(v, vdupq_n_f32(INT_MAX)));\n        mask = vandq_u32(mask, vceqq_f32(vsubq_f32(v, vcvtq_f32_u32(vcvtq_u32_f32(v))), vdupq_n_f32(0.0f)));\n        mask = vandq_u32(mask, vcgeq_f32(vsubq_f32(v, vdupq_n_f32(1.0f)), vdupq_n_f32(0.0f)));\n\n        float32x4_t odd_squares = vmulq_f32(v, v);\n        odd_squares = vbslq_f32(mask, odd_squares, vdupq_n_f32(0.0f));\n\n        sum += vaddvq_f32(odd_squares);\n    }\n\n    // Process remaining elements\n    for (; i < size; ++i) {\n        float num = lst[i];\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += num * num;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> result(size);\n\n    for (size_t i = 0; i < size; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        int32x4_t diff_vec = vabsq_s32(vsubq_s32(game_vec, guess_vec));\n\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        int32x4_t zero_vec = vdupq_n_s32(0);\n        uint32x4_t mask_vec = vceqq_s32(game_vec, guess_vec);\n\n        int32x4_t result_vec = vbslq_s32(mask_vec, zero_vec, diff_vec);\n\n        vst1q_s32(&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n        int32x4_t zero_vec = vdupq_n_s32(0);\n        uint32x4_t mask_vec = vceqq_s32(game_vec, guess_vec);\n\n        int32x4_t result_vec = vbslq_s32(mask_vec, zero_vec, diff_vec);\n\n        vst1q_s32(&result[i], result_vec);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n\n    for (size_t i = 0; i < n; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n\n        int32x4_t diff_vec = vabdq_s32(game_vec, guess_vec);\n\n        vst1q_s32(&result[i], diff_vec);\n    }\n\n    return result;\n}\n```"}

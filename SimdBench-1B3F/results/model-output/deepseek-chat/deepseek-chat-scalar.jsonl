{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int element = src[i];\n        int scaled = element * scale;\n        int tmp1 = scaled >> 3;\n        int tmp2 = scaled << 3;\n        dst[i] = (scaled + tmp1 * tmp2) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather operation\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter operation\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t offset = slice_idx * slice_size;\n    for (size_t i = 0; i < slice_size; i++) {\n        slice[i] = tensor[offset + i];\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = i; bi < i + block_size && bi < rows; bi++) {\n                for (size_t bj = j; bj < j + block_size && bj < cols; bj++) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = i; bi < i + block_size && bi < rows; bi++) {\n                for (size_t bj = j; bj < j + block_size && bj < cols; bj++) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = i; bi < i + block_size && bi < rows; bi++) {\n                for (size_t bj = j; bj < j + block_size && bj < cols; bj++) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = i; bi < i + block_size && bi < rows; ++bi) {\n                for (size_t bj = j; bj < j + block_size && bj < cols; ++bj) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            for (size_t bi = i; bi < i + block_size && bi < rows; bi++) {\n                for (size_t bj = j; bj < j + block_size && bj < cols; bj++) {\n                    dst[bj * rows + bi] = src[bi * cols + bj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * dim * dim + i * dim + i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found_even || src[i] < min) {\n            min = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found_even || src[i] < min) {\n            min = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found_even || src[i] < min) {\n            min = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found_even || src[i] < min) {\n            min = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min : -1;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min = -1;\n    int found_even = 0;\n    \n    for (size_t i = 0; i < length; i += 2) {\n        if (!found_even || src[i] < min) {\n            min = src[i];\n            found_even = 1;\n        }\n    }\n    \n    return found_even ? min : -1;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith_shift = src[i] >> shift;\n        int logic_shift = (int)((unsigned int)src[i] >> shift);\n        dst[i] = arith_shift + logic_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < rows * cols; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = x + (x >> 8);\n        x = x + (x >> 16);\n        dst[i] = x & 0x3F;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a = A[i * n + k];\n                double b = B[k * p + j];\n                if (a >= -100.0 && a <= 100.0 && b >= -100.0 && b <= 100.0) {\n                    sum += a * b;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\n#include <math.h>\n\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float norm = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            norm += val * val;\n        }\n        norm = sqrtf(norm);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            value = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = value;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4) / 4;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = diff >= 0 ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = truncf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = diff >= 0 ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\n#include <math.h>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        dst[i] = truncf(tensor1[i] - tensor2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = diff >= 0 ? floorf(diff) : ceilf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m * n; i++) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        dst[i] = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            dst[i] += mat[i * n + j] * vec[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total_elements = m * n;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += mat[i];\n    }\n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    for (size_t i = 0; i < m * n; ++i) {\n        sum += mat[i];\n    }\n    return sum / (m * n);\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols - 1; j++) {\n            int current = matrix[i * cols + j];\n            int next = matrix[i * cols + j + 1];\n            if (directions[i]) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            int current = matrix[i * cols + j];\n            int previous = matrix[i * cols + j - 1];\n            if (directions[i]) {\n                if (current < previous) {\n                    return false;\n                }\n            } else {\n                if (current > previous) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 1; j < cols; j++) {\n            int prev = matrix[i * cols + j - 1];\n            int curr = matrix[i * cols + j];\n            if (ascending) {\n                if (prev > curr) {\n                    return false;\n                }\n            } else {\n                if (prev < curr) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols - 1; j++) {\n            int current = matrix[i * cols + j];\n            int next = matrix[i * cols + j + 1];\n            if (directions[i]) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool ascending = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            int current = matrix[i * cols + j];\n            int next = matrix[i * cols + j + 1];\n            if (ascending) {\n                if (current > next) {\n                    return false;\n                }\n            } else {\n                if (current < next) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t remainder = value % base;\n        dst[i] = value - remainder;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t remainder = value % base;\n        dst[i] = value - remainder;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t remainder = value % base;\n        dst[i] = value - remainder;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t remainder = value % base;\n        dst[i] = value - remainder;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t value = src[i];\n        int16_t remainder = value % base;\n        dst[i] = value - remainder;\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <string.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (memcmp(matrix + i * cols, vector, cols * sizeof(double)) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    \n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t val = a * x[i] - y[i];\n        y[i] = val < 0 ? -val : val;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t val = a * x[i] - y[i];\n        y[i] = val < 0 ? -val : val;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t temp = a * x[i] - y[i];\n        y[i] = llabs(temp);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t val = a * x[i] - y[i];\n        y[i] = llabs(val);\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t val = a * x[i] - y[i];\n        y[i] = llabs(val);\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    \n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols - 1; j++) {\n            if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t blocks_rows = rows / block_size;\n    size_t blocks_cols = cols / block_size;\n\n    for (size_t block_i = 0; block_i < blocks_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < blocks_cols; ++block_j) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t matrix_row = block_i * block_size + i;\n                    size_t matrix_col = block_j * block_size + j;\n                    size_t first_block_row = i;\n                    size_t first_block_col = j;\n                    if (matrix[matrix_row * cols + matrix_col] != first_block[first_block_row * cols + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t blocks_rows = rows / block_size;\n    size_t blocks_cols = cols / block_size;\n\n    for (size_t block_i = 0; block_i < blocks_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < blocks_cols; ++block_j) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t matrix_row = block_i * block_size + i;\n                    size_t matrix_col = block_j * block_size + j;\n                    size_t first_block_row = i;\n                    size_t first_block_col = j;\n                    if (matrix[matrix_row * cols + matrix_col] != first_block[first_block_row * cols + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t blocks_rows = rows / block_size;\n    size_t blocks_cols = cols / block_size;\n\n    for (size_t block_i = 0; block_i < blocks_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < blocks_cols; ++block_j) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t matrix_row = block_i * block_size + i;\n                    size_t matrix_col = block_j * block_size + j;\n                    size_t first_block_row = i;\n                    size_t first_block_col = j;\n                    if (matrix[matrix_row * cols + matrix_col] != first_block[first_block_row * block_size + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t blocks_rows = rows / block_size;\n    size_t blocks_cols = cols / block_size;\n\n    for (size_t block_i = 0; block_i < blocks_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < blocks_cols; ++block_j) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t matrix_row = block_i * block_size + i;\n                    size_t matrix_col = block_j * block_size + j;\n                    size_t first_block_row = i;\n                    size_t first_block_col = j;\n                    if (matrix[matrix_row * cols + matrix_col] != first_block[first_block_row * cols + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    const int* first_block = matrix;\n    size_t blocks_rows = rows / block_size;\n    size_t blocks_cols = cols / block_size;\n\n    for (size_t block_i = 0; block_i < blocks_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < blocks_cols; ++block_j) {\n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t global_row = block_i * block_size + i;\n                    size_t global_col = block_j * block_size + j;\n                    size_t first_block_row = i;\n                    size_t first_block_col = j;\n                    if (matrix[global_row * cols + global_col] != first_block[first_block_row * cols + first_block_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stdbool.h>\n#include <math.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks == 0) {\n        return false;\n    }\n\n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            if (fabs(vec[i] - vec[block * block_size + i]) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n        double norm = sqrt(sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n        double norm = sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <math.h>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = matrix[i * cols + j];\n            sum += val * val;\n        }\n        result[i] = sqrt(sum) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq_A = 0;\n    int64_t sum_sq_B = 0;\n    int64_t sum_prod = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_sq_A += A[i] * A[i];\n        sum_sq_B += B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n    \n    return (sum_sq_A + sum_sq_B) - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq_A = 0;\n    int64_t sum_sq_B = 0;\n    int64_t sum_prod = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_sq_A += A[i] * A[i];\n        sum_sq_B += B[i] * B[i];\n        sum_prod += A[i] * B[i];\n    }\n    \n    return (sum_sq_A + sum_sq_B) - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq_A = 0;\n    int64_t sum_sq_B = 0;\n    int64_t sum_prod = 0;\n    \n    for (size_t i = 0; i < length; i++) {\n        sum_sq_A += (int64_t)A[i] * A[i];\n        sum_sq_B += (int64_t)B[i] * B[i];\n        sum_prod += (int64_t)A[i] * B[i];\n    }\n    \n    return (sum_sq_A + sum_sq_B) - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (A[i] * A[i]) + (B[i] * B[i]);\n        sum_prod += A[i] * B[i];\n    }\n    return sum_sq - (2 * sum_prod);\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        sum_sq += (A[i] * A[i]) + (B[i] * B[i]);\n        sum_prod += A[i] * B[i];\n    }\n    return sum_sq - 2 * sum_prod;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i == mid && length % 2 == 1) {\n            C[i] = A[i];\n        } else if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i == mid && length % 2 == 1) {\n            C[i] = A[i];\n        } else if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i == mid && length % 2 == 1) {\n            C[i] = A[i];\n        } else if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t midpoint = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i == midpoint && length % 2 == 1) {\n            C[i] = A[i];\n        } else if (i < midpoint) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < length; ++i) {\n        if (i == mid && length % 2 == 1) {\n            C[i] = A[i];\n        } else if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        bool c1 = cond1[i];\n        bool c2 = cond2[i];\n        if (c1 && c2) {\n            out[i] = A[i];\n        } else if (c1 && !c2) {\n            out[i] = B[i];\n        } else if (!c1 && c2) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        bool c1 = cond1[i];\n        bool c2 = cond2[i];\n        if (c1 && c2) {\n            out[i] = A[i];\n        } else if (c1 && !c2) {\n            out[i] = B[i];\n        } else if (!c1 && c2) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        bool c1 = cond1[i];\n        bool c2 = cond2[i];\n        if (c1 && c2) {\n            out[i] = A[i];\n        } else if (c1 && !c2) {\n            out[i] = B[i];\n        } else if (!c1 && c2) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        bool c1 = cond1[i];\n        bool c2 = cond2[i];\n        if (c1 && c2) {\n            out[i] = A[i];\n        } else if (c1 && !c2) {\n            out[i] = B[i];\n        } else if (!c1 && c2) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```c\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        bool c1 = cond1[i];\n        bool c2 = cond2[i];\n        if (c1 && c2) {\n            out[i] = A[i];\n        } else if (c1 && !c2) {\n            out[i] = B[i];\n        } else if (!c1 && c2) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value != 0) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t value = A[i];\n        uint8_t count = 0;\n        while (value != 0) {\n            count += value & 1;\n            value >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val != 0) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val != 0) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        uint32_t val = A[i];\n        uint8_t count = 0;\n        while (val != 0) {\n            count += val & 1;\n            val >>= 1;\n        }\n        out[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows * cols; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rotate_bits) | (src[i] << (32 - rotate_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float val = A[i];\n        if (val > INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float div = A[i] / B[i];\n        C[i] = (int32_t)roundf(div);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float div = A[i] / B[i];\n        C[i] = (int32_t)roundf(div);\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float div = A[i] / B[i];\n        if (div >= INT32_MAX) {\n            C[i] = INT32_MAX;\n        } else if (div <= INT32_MIN) {\n            C[i] = INT32_MIN;\n        } else {\n            C[i] = (int32_t)roundf(div);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float div = A[i] / B[i];\n        if (div >= INT32_MAX) {\n            C[i] = INT32_MAX;\n        } else if (div <= INT32_MIN) {\n            C[i] = INT32_MIN;\n        } else {\n            C[i] = (int32_t)roundf(div);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        float div = A[i] / B[i];\n        C[i] = (int32_t)roundf(div);\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / range;\n            if (val < 0.0f) {\n                val = 0.0f;\n            } else if (val > 1.0f) {\n                val = 1.0f;\n            }\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high16 = A[i] >> 16;\n        float converted = (float)high16;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high16 = A[i] >> 16;\n        float converted = (float)high16;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high16 = A[i] >> 16;\n        float converted = (float)high16;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_val = (float)high_bits;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float float_val = (float)high_bits;\n        B[i] = sqrtf(float_val);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        memcpy(&B[i], &A[i], sizeof(float));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    memcpy(B, A, size * sizeof(float));\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    memcpy(B, A, size * sizeof(float));\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t val = A[i];\n        memcpy(&B[i], &val, sizeof(float));\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    memcpy(B, A, size * sizeof(float));\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    \n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        if (index[i] >= 0 && (size_t)index[i] < length) {\n            sum += vec[index[i]];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            \n            size_t output_idx = i * output_size + j;\n            output[output_idx] = fmax(0.0, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            \n            size_t output_idx = i * output_size + j;\n            output[output_idx] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            output[i * output_size + j] = fmax(0.0, sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    sum += input[(i + ki) * input_size + (j + kj)] * kernel[ki * kernel_size + kj];\n                }\n            }\n            output[i * output_size + j] = sum > 0 ? sum : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <math.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            \n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_idx = (i + ki) * input_size + (j + kj);\n                    size_t kernel_idx = ki * kernel_size + kj;\n                    sum += input[input_idx] * kernel[kernel_idx];\n                }\n            }\n            \n            size_t output_idx = i * output_size + j;\n            output[output_idx] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        for (size_t j = i + 1; j < numbers.size(); ++j) {\n            if (std::abs(numbers[i] - numbers[j]) < threshold) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double mad = 0.0;\n    for (double num : numbers) {\n        mad += std::abs(num - mean);\n    }\n    return mad / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    \n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    \n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    std::string result;\n    for (size_t i = 0; i < a.size(); ++i) {\n        result += (a[i] == b[i]) ? '0' : '1';\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string result = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > result.length()) {\n            result = str;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (const auto& str : strings) {\n        if (str.length() > longest_str.length()) {\n            longest_str = str;\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string result = strings[0];\n    for (const auto& s : strings) {\n        if (s.length() > result.length()) {\n            result = s;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b){\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = FLT_MAX;\n    std::vector<float> result(2);\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i+1];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i-1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i-1];\n            result[1] = numbers[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i+1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = std::abs(numbers[i+1] - numbers[i]);\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i+1];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        float diff = numbers[i] - numbers[i-1];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i-1];\n            result[1] = numbers[i];\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.size() < 2) return numbers;\n    auto min_max = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *min_max.first;\n    float max_val = *min_max.second;\n    if (min_val == max_val) {\n        std::fill(numbers.begin(), numbers.end(), 0.0f);\n        return numbers;\n    }\n    float range = max_val - min_val;\n    for (auto& num : numbers) {\n        num = (num - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    for (float &num : numbers) {\n        num = (num - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    for (float &num : numbers) {\n        num = (num - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    \n    for (float &num : numbers) {\n        num = (num - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    float range = max_val - min_val;\n    \n    for (float &num : numbers) {\n        num = (num - min_val) / range;\n    }\n    \n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    if (n <= 1) {\n        return 0;\n    }\n    for (uint64_t i = n / 2; i >= 1; i--) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    if (n <= 1) {\n        return 0;\n    }\n    for (uint64_t i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    if (n <= 1) {\n        return 0;\n    }\n    for (uint64_t i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    if (n <= 1) {\n        return 0;\n    }\n    for (uint64_t i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\nuint64_t largest_divisor(uint64_t n) {\n    if (n <= 1) {\n        return 0;\n    }\n    for (uint64_t i = n / 2; i >= 1; --i) {\n        if (n % i == 0) {\n            return i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n    for (int i = 2; i * i <= n; ++i) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int64_t i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (!has_letter) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    \n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (!has_letter) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    \n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (!has_letter) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    \n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (!has_letter) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    \n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (isalpha(c)) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (!has_letter) {\n        return std::string(s.rbegin(), s.rend());\n    }\n    \n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            if (islower(c)) {\n                result += toupper(c);\n            } else {\n                result += tolower(c);\n            }\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 3, j++) {\n        if (i < l.size()) {\n            l[i] = temp[j];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 3, j++) {\n        if (i < l.size()) {\n            l[i] = temp[j];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 3, j++) {\n        if (i < l.size()) {\n            l[i] = temp[j];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 3, j++) {\n        if (i < l.size()) {\n            l[i] = temp[j];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (size_t i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 3, j++) {\n        if (i < l.size()) {\n            l[i] = temp[j];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (float num : l) {\n        if (num > max) {\n            max = num;\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (float num : l) {\n        if (num > max) {\n            max = num;\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (float num : l) {\n        if (num > max) {\n            max = num;\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\nfloat max_element(std::vector<float> l){\n    float max = l[0];\n    for (float num : l) {\n        if (num > max) {\n            max = num;\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            while (num > 0) {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_elements;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_elements.push_back(l[i]);\n    }\n    std::sort(even_elements.begin(), even_elements.end());\n    for (size_t i = 1, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_elements[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    for (size_t i = 1, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    for (size_t i = 1, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    for (size_t i = 1, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_indices;\n    for (size_t i = 1; i < l.size(); i += 2) {\n        even_indices.push_back(l[i]);\n    }\n    std::sort(even_indices.begin(), even_indices.end());\n    for (size_t i = 1, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even_indices[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) continue;\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size() - 2; ++i) {\n        int left = i + 1;\n        int right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) {\n        return false;\n    }\n    std::sort(l.begin(), l.end());\n    for (size_t i = 0; i < l.size() - 2; ++i) {\n        if (i > 0 && l[i] == l[i-1]) {\n            continue;\n        }\n        size_t left = i + 1;\n        size_t right = l.size() - 1;\n        while (left < right) {\n            int sum = l[i] + l[left] + l[right];\n            if (sum == 0) {\n                return true;\n            } else if (sum < 0) {\n                ++left;\n            } else {\n                --right;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    std::vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}```"}
{"task_id": "SimdBench_83", "completion": "```cpp#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& num : l) {\n        num += 1;\n    }\n    return l;\n}```"}
{"task_id": "SimdBench_83", "completion": "```cpp#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    std::vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}```"}
{"task_id": "SimdBench_83", "completion": "```cpp#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    std::vector<int> result;\n    for (int num : l) {\n        result.push_back(num + 1);\n    }\n    return result;\n}```"}
{"task_id": "SimdBench_83", "completion": "```cpp#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& num : l) {\n        num += 1;\n    }\n    return l;\n}```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result;\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n    while (x > 0) {\n        result += '0' + (x % base);\n        x /= base;\n    }\n    if (is_negative) {\n        result += '-';\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result;\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n    while (x > 0) {\n        result += '0' + (x % base);\n        x /= base;\n    }\n    if (is_negative) {\n        result += '-';\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result;\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n    while (x > 0) {\n        result += '0' + (x % base);\n        x /= base;\n    }\n    if (is_negative) {\n        result += '-';\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result;\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n    while (x > 0) {\n        result += '0' + (x % base);\n        x /= base;\n    }\n    if (is_negative) {\n        result += '-';\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string result;\n    bool is_negative = false;\n    if (x < 0) {\n        is_negative = true;\n        x = -x;\n    }\n    while (x > 0) {\n        result += std::to_string(x % base);\n        x /= base;\n    }\n    if (is_negative) {\n        result += '-';\n    }\n    std::reverse(result.begin(), result.end());\n    return result;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\nbool is_palindrome(std::string text){\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\nstd::string decode_shift(std::string s){\n    std::string out;\n    int i;\n    for (i=0;i<s.length();i++)\n    {\n        int w=((int)s[i]-5-(int)'a'+26)%26+(int)'a';   \n        out=out+(char)w;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\nbool below_threshold(std::vector<int>l, int t){\n    for(int num : l){\n        if(num >= t){\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n            if (balance < 0) {\n                return false;\n            }\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '<') {\n            stack.push(c);\n        } else if (c == '>') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> stack;\n    for (char c : brackets) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                return false;\n            }\n            stack.pop();\n        }\n    }\n    return stack.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <stack>\n\nbool correct_bracketing(std::string brackets) {\n    std::stack<char> s;\n    for (char c : brackets) {\n        if (c == '(') {\n            s.push(c);\n        } else {\n            if (s.empty()) {\n                return false;\n            }\n            s.pop();\n        }\n    }\n    return s.empty();\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs){\n    std::vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(xs[i] * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char &c : s) {\n        char lower = tolower(c);\n        if (lower == 'a' || lower == 'e' || lower == 'i' || lower == 'o' || lower == 'u') {\n            count++;\n        }\n    }\n    if (!s.empty()) {\n        char last = tolower(s.back());\n        if (last == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        }\n    }\n    if (!s.empty()) {\n        char last = tolower(s.back());\n        if (last == 'y') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        }\n    }\n    if (!s.empty()) {\n        char last = tolower(s.back());\n        if (last == 'y') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        } else if (c == 'y' && i == s.size() - 1) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); ++i) {\n        char c = tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            ++count;\n        }\n    }\n    if (!s.empty()) {\n        char last = tolower(s.back());\n        if (last == 'y') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_value = INT_MAX;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_value) {\n            smallest_value = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    if (smallest_index == -1) {\n        return {};\n    } else {\n        return {smallest_value, smallest_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_value = INT_MAX;\n    int smallest_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_value) {\n            smallest_value = arr[i];\n            smallest_index = i;\n        }\n    }\n\n    if (smallest_index == -1) {\n        return {};\n    } else {\n        return {smallest_value, smallest_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int smallest_even = INT_MAX;\n    int index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_even) {\n            smallest_even = arr[i];\n            index = i;\n        }\n    }\n\n    if (index == -1) {\n        return {};\n    } else {\n        return {smallest_even, index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallest_value = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_value) {\n            smallest_value = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    } else {\n        return {smallest_value, smallest_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int smallest_value = INT_MAX;\n    int smallest_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0 && arr[i] < smallest_value) {\n            smallest_value = arr[i];\n            smallest_index = i;\n        }\n    }\n    \n    if (smallest_index == -1) {\n        return {};\n    } else {\n        return {smallest_value, smallest_index};\n    }\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (const auto& pair : freq) {\n        if (pair.first == pair.second && pair.first > max_num) {\n            max_num = pair.first;\n        }\n    }\n    \n    return max_num;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (const auto& pair : freq) {\n        if (pair.first == pair.second) {\n            if (pair.first > max_num) {\n                max_num = pair.first;\n            }\n        }\n    }\n    \n    return max_num;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (const auto& pair : freq) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            if (pair.first > max_num) {\n                max_num = pair.first;\n            }\n        }\n    }\n    \n    return max_num;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (const auto& pair : freq) {\n        if (pair.first == pair.second && pair.first > max_num) {\n            max_num = pair.first;\n        }\n    }\n    \n    return max_num;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int max_num = -1;\n    for (const auto& pair : freq) {\n        if (pair.first > 0 && pair.second >= pair.first) {\n            if (pair.first > max_num) {\n                max_num = pair.first;\n            }\n        }\n    }\n    \n    return max_num;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    if (sum > w) {\n        return false;\n    }\n    std::vector<int> reversed_q(q.rbegin(), q.rend());\n    return q == reversed_q;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    \n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    \n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto count_chars = [](const std::vector<std::string>& vec) {\n        return std::accumulate(vec.begin(), vec.end(), 0, \n            [](int sum, const std::string& s) { return sum + s.size(); });\n    };\n    \n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n    \n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto count_chars = [](const std::vector<std::string>& vec) {\n        return std::accumulate(vec.begin(), vec.end(), 0, \n            [](int sum, const std::string& s) { return sum + s.size(); });\n    };\n    \n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n    \n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int count1 = 0;\n    for (const auto &s : lst1) {\n        count1 += s.size();\n    }\n    int count2 = 0;\n    for (const auto &s : lst2) {\n        count2 += s.size();\n    }\n    if (count1 < count2) {\n        return lst1;\n    } else if (count2 < count1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <numeric>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto count_chars = [](const std::vector<std::string>& vec) {\n        return std::accumulate(vec.begin(), vec.end(), 0, \n            [](int sum, const std::string& s) { return sum + s.size(); });\n    };\n    \n    int count1 = count_chars(lst1);\n    int count2 = count_chars(lst2);\n    \n    if (count1 <= count2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int count1 = 0;\n    for (const auto &s : lst1) {\n        count1 += s.size();\n    }\n    int count2 = 0;\n    for (const auto &s : lst2) {\n        count2 += s.size();\n    }\n    if (count1 < count2) {\n        return lst1;\n    } else if (count2 < count1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    uint64_t power = 1;\n    while (power <= x) {\n        if (power == x) {\n            return true;\n        }\n        if (power > UINT64_MAX / n) {\n            break;\n        }\n        power *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    \n    uint64_t product = 1;\n    while (product < x) {\n        product *= n;\n        if (product == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    \n    uint64_t product = 1;\n    while (product <= x) {\n        if (product == x) {\n            return true;\n        }\n        product *= n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n#include <math.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n    uint64_t power = 1;\n    while (power < x) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <unordered_set>\n\nint hex_key(const std::string & num) {\n    std::unordered_set<char> primes = {'2', '3', '5', '7', 'B', 'D'};\n    int count = 0;\n    for (char c : num) {\n        if (primes.find(c) != primes.end()) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.size() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.size() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\nbool is_happy(const std::string & s){\n    if (s.size() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.size() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i < s.size() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int i = 3; i <= std::sqrt(n); i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool is_prime(int n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n <= 3) {\n        return true;\n    }\n    if (n % 2 == 0 || n % 3 == 0) {\n        return false;\n    }\n    for (int i = 5; i * i <= n; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nbool prime_length(const std::string & str) {\n    return is_prime(str.length());\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    if (sum == 0) {\n        return \"0\";\n    }\n    \n    std::string binary;\n    while (sum > 0) {\n        binary += (sum % 2) + '0';\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    std::string binary;\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += (sum % 2) + '0';\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    std::string binary;\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += (sum % 2) + '0';\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    std::string binary;\n    if (sum == 0) {\n        return \"0\";\n    }\n    while (sum > 0) {\n        binary += (sum % 2) + '0';\n        sum /= 2;\n    }\n    std::reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    \n    std::string binary;\n    if (sum == 0) {\n        binary = \"0\";\n    } else {\n        while (sum > 0) {\n            binary += (sum % 2) + '0';\n            sum /= 2;\n        }\n        std::reverse(binary.begin(), binary.end());\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); ++i) {\n        if(i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); ++i) {\n        if(i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); ++i) {\n        if(i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); ++i) {\n        if(i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\nint add(std::vector<int> lst){\n    int sum = 0;\n    for(int i = 0; i < lst.size(); ++i) {\n        if(i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = base + ((c - base + 4) % 26);\n        }\n        result += c;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            result += ((c - base + 4) % 26) + base;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            c = base + (c - base + 4) % 26;\n        }\n        result += c;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            char rotated = ((c - base + 4) % 26) + base;\n            result += rotated;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (isalpha(c)) {\n            char base = islower(c) ? 'a' : 'A';\n            char rotated = ((c - base + 4) % 26) + base;\n            result += rotated;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u') {\n            char base = isupper(c) ? 'A' : 'a';\n            char shifted = ((tolower(c) - 'a' + 2) % 26) + base;\n            result += shifted;\n        } else {\n            if (isupper(c)) {\n                result += tolower(c);\n            } else {\n                result += toupper(c);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u') {\n            char new_char;\n            if (tolower(c) == 'y') {\n                new_char = 'a';\n            } else if (tolower(c) == 'z') {\n                new_char = 'b';\n            } else {\n                new_char = tolower(c) + 2;\n            }\n            if (isupper(c)) {\n                new_char = toupper(new_char);\n            }\n            result += new_char;\n        } else {\n            if (isupper(c)) {\n                result += tolower(c);\n            } else {\n                result += toupper(c);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u') {\n            char new_char = tolower(c) + 2;\n            if (new_char > 'z') {\n                new_char -= 26;\n            }\n            if (isupper(c)) {\n                new_char = toupper(new_char);\n            }\n            result += new_char;\n        } else {\n            if (isupper(c)) {\n                result += tolower(c);\n            } else {\n                result += toupper(c);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u') {\n            char new_char;\n            if (tolower(c) == 'y') {\n                new_char = 'a';\n            } else if (tolower(c) == 'z') {\n                new_char = 'b';\n            } else {\n                new_char = tolower(c) + 2;\n            }\n            if (isupper(c)) {\n                new_char = toupper(new_char);\n            }\n            result += new_char;\n        } else {\n            if (isupper(c)) {\n                result += tolower(c);\n            } else {\n                result += toupper(c);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (tolower(c) == 'a' || tolower(c) == 'e' || tolower(c) == 'i' || tolower(c) == 'o' || tolower(c) == 'u') {\n            char new_char;\n            if (tolower(c) == 'y') {\n                new_char = 'a';\n            } else if (tolower(c) == 'z') {\n                new_char = 'b';\n            } else {\n                new_char = tolower(c) + 2;\n            }\n            if (isupper(c)) {\n                new_char = toupper(new_char);\n            }\n            result += new_char;\n        } else {\n            if (isupper(c)) {\n                result += tolower(c);\n            } else {\n                result += toupper(c);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!std::islower(c)) {\n                all_lower = false;\n            }\n            if (!std::isupper(c)) {\n                all_upper = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!islower(c)) {\n                all_lower = false;\n            }\n            if (!isupper(c)) {\n                all_upper = false;\n            }\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!isalpha(c)) {\n                return false;\n            }\n            if (islower(c)) {\n                all_upper = false;\n            } else if (isupper(c)) {\n                all_lower = false;\n            }\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!std::islower(c)) {\n                all_lower = false;\n            }\n            if (!std::isupper(c)) {\n                all_upper = false;\n            }\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <map>\n#include <string>\n#include <cctype>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& pair : dict) {\n        const std::string& key = pair.first;\n        for (char c : key) {\n            if (!std::islower(c)) {\n                all_lower = false;\n            }\n            if (!std::isupper(c)) {\n                all_upper = false;\n            }\n        }\n        if (!all_lower && !all_upper) {\n            return false;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int num = 2; num < n; ++num) {\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(num); ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int num = 2; num < n; ++num) {\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(num); ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n    \n    for (int num = 2; num < n; ++num) {\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(num); ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n    \n    for (int num = 2; num < n; ++num) {\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(num); ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    std::vector<int> primes;\n    if (n <= 2) return primes;\n\n    for (int num = 2; num < n; ++num) {\n        bool is_prime = true;\n        for (int i = 2; i <= std::sqrt(num); ++i) {\n            if (num % i == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (is_prime) {\n            primes.push_back(num);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (size_t i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (current % 2 == 1) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (current % 2 == 1) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(current);\n        if (current % 2 == 1) {\n            current += 2;\n        } else {\n            current += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = (n + m) * (m - n + 1) / 2;\n    int64_t avg = sum / (m - n + 1);\n    std::string binary;\n    if (avg == 0) {\n        return \"0\";\n    }\n    while (avg > 0) {\n        binary = std::to_string(avg % 2) + binary;\n        avg /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = (n + m) * (m - n + 1) / 2;\n    int64_t average = sum / (m - n + 1);\n    std::string binary;\n    if (average == 0) {\n        return \"0\";\n    }\n    while (average > 0) {\n        binary = std::to_string(average % 2) + binary;\n        average /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t average = sum / (m - n + 1);\n    std::string binary;\n    if (average == 0) {\n        return \"0\";\n    }\n    while (average > 0) {\n        binary = std::to_string(average % 2) + binary;\n        average /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t average = sum / (m - n + 1);\n    std::string binary;\n    if (average == 0) {\n        return \"0\";\n    }\n    while (average > 0) {\n        binary = std::to_string(average % 2) + binary;\n        average /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t sum = 0;\n    for (int64_t i = n; i <= m; ++i) {\n        sum += i;\n    }\n    int64_t average = sum / (m - n + 1);\n    std::string binary;\n    if (average == 0) {\n        return \"0\";\n    }\n    while (average > 0) {\n        binary = std::to_string(average % 2) + binary;\n        average /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 2 == 0) {\n            int factorial = 1;\n            for (int j = 1; j <= i; ++j) {\n                factorial = (factorial * j) % 10000;\n            }\n            result.push_back(factorial);\n        } else {\n            int sum = 0;\n            for (int j = 1; j <= i; ++j) {\n                sum += j;\n            }\n            result.push_back(sum);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0;\n    int odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool isPalindrome(int num) {\n    std::string s = std::to_string(num);\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0;\n    int odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0;\n    int odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool isPalindrome(int num) {\n    std::string s = std::to_string(num);\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0;\n    int odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool isPalindrome(int num) {\n    std::string s = std::to_string(num);\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0;\n    int odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (isPalindrome(i)) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            int first_digit = num;\n            while (abs(first_digit) >= 10) {\n                first_digit /= 10;\n            }\n            sum += 2 * first_digit;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (num < 0) {\n            int first_digit = num;\n            while (abs(first_digit) >= 10) {\n                first_digit /= 10;\n            }\n            sum += 2 * first_digit;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        bool isNegative = num < 0;\n        int firstDigit = temp;\n        while (firstDigit >= 10) {\n            firstDigit /= 10;\n        }\n        if (isNegative) {\n            sum -= firstDigit;\n            temp -= firstDigit * pow(10, (int)log10(temp));\n        }\n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        bool isNegative = num < 0;\n        \n        if (temp == 0) {\n            sum = 0;\n        } else {\n            int firstDigit = temp;\n            while (firstDigit >= 10) {\n                firstDigit /= 10;\n            }\n            if (isNegative) {\n                firstDigit = -firstDigit;\n            }\n            sum += firstDigit;\n            temp -= abs(firstDigit);\n            \n            while (temp > 0) {\n                int digit = temp % 10;\n                sum += digit;\n                temp /= 10;\n            }\n        }\n        \n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        int sum = 0;\n        int temp = abs(num);\n        bool isNegative = num < 0;\n        \n        if (temp == 0) {\n            continue;\n        }\n        \n        int firstDigit = temp;\n        while (firstDigit >= 10) {\n            firstDigit /= 10;\n        }\n        \n        if (isNegative) {\n            sum -= firstDigit;\n            temp -= firstDigit * pow(10, (int)log10(temp));\n        }\n        \n        while (temp > 0) {\n            sum += temp % 10;\n            temp /= 10;\n        }\n        \n        if (sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int n = arr.size();\n    int pivot = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i-1]) {\n            pivot = i;\n            break;\n        }\n    }\n    \n    if (pivot == 0) {\n        return true;\n    }\n    \n    std::vector<int> shifted;\n    shifted.insert(shifted.end(), arr.begin() + pivot, arr.end());\n    shifted.insert(shifted.end(), arr.begin(), arr.begin() + pivot);\n    \n    for (int i = 1; i < n; ++i) {\n        if (shifted[i] < shifted[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int n = arr.size();\n    int pivot = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i-1]) {\n            pivot = i;\n            break;\n        }\n    }\n    \n    if (pivot == 0) {\n        return true;\n    }\n    \n    std::vector<int> rotated;\n    rotated.insert(rotated.end(), arr.begin() + pivot, arr.end());\n    rotated.insert(rotated.end(), arr.begin(), arr.begin() + pivot);\n    \n    for (int i = 1; i < n; ++i) {\n        if (rotated[i] < rotated[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int n = arr.size();\n    int pivot = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i-1]) {\n            pivot = i;\n            break;\n        }\n    }\n    \n    if (pivot == 0) {\n        return true;\n    }\n    \n    std::vector<int> shifted;\n    shifted.insert(shifted.end(), arr.begin() + pivot, arr.end());\n    shifted.insert(shifted.end(), arr.begin(), arr.begin() + pivot);\n    \n    for (int i = 1; i < n; ++i) {\n        if (shifted[i] < shifted[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int n = arr.size();\n    int pivot = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i-1]) {\n            pivot = i;\n            break;\n        }\n    }\n    \n    if (pivot == 0) {\n        return true;\n    }\n    \n    std::vector<int> shifted;\n    shifted.insert(shifted.end(), arr.begin() + pivot, arr.end());\n    shifted.insert(shifted.end(), arr.begin(), arr.begin() + pivot);\n    \n    for (int i = 1; i < n; ++i) {\n        if (shifted[i] < shifted[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    \n    int n = arr.size();\n    int pivot = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[i-1]) {\n            pivot = i;\n            break;\n        }\n    }\n    \n    if (pivot == 0) {\n        return true;\n    }\n    \n    std::vector<int> shifted;\n    shifted.insert(shifted.end(), arr.begin() + pivot, arr.end());\n    shifted.insert(shifted.end(), arr.begin(), arr.begin() + pivot);\n    \n    for (int i = 1; i < n; ++i) {\n        if (shifted[i] < shifted[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n    \n    if (odd_in_lst1 <= even_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n    \n    if (odd_in_lst1 <= even_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n    \n    if (odd_in_lst1 <= even_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n    \n    if (odd_in_lst1 <= even_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd_in_lst1 = 0;\n    int even_in_lst2 = 0;\n    \n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd_in_lst1++;\n        }\n    }\n    \n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even_in_lst2++;\n        }\n    }\n    \n    if (odd_in_lst1 <= even_in_lst2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = std::count_if(s.begin(), s.end(), [](char c) { return (c - '0') % 2 != 0; });\n        std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string res = \"the number of odd elements \";\n        res += std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \";\n        res += std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if ((c - '0') % 2 != 0) {\n                count++;\n            }\n        }\n        std::string res = \"the number of odd elements \" + std::to_string(count) + \"n the str\" + std::to_string(count) + \"ng \" + std::to_string(count) + \" of the \" + std::to_string(count) + \"nput.\";\n        result.push_back(res);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    \n    for (int64_t num : nums) {\n        current_sum += num;\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    \n    for (int64_t num : nums) {\n        current_sum += num;\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    \n    for (int64_t num : nums) {\n        current_sum += num;\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    \n    for (int64_t num : nums) {\n        current_sum += num;\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t min_sum = INT64_MAX;\n    int64_t current_sum = 0;\n    \n    for (int64_t num : nums) {\n        current_sum += num;\n        if (current_sum < min_sum) {\n            min_sum = current_sum;\n        }\n        if (current_sum > 0) {\n            current_sum = 0;\n        }\n    }\n    \n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total = 0;\n    for (const auto &row : grid) {\n        int row_sum = 0;\n        for (int val : row) {\n            row_sum += val;\n        }\n        total += std::ceil(static_cast<double>(row_sum) / capacity);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total = 0;\n    for (const auto & row : grid) {\n        int sum = 0;\n        for (int val : row) {\n            sum += val;\n        }\n        total += std::ceil(static_cast<double>(sum) / capacity);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total = 0;\n    for (const auto &row : grid) {\n        int sum = 0;\n        for (int val : row) {\n            sum += val;\n        }\n        total += std::ceil(static_cast<double>(sum) / capacity);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total = 0;\n    for (const auto & row : grid) {\n        int sum = 0;\n        for (int val : row) {\n            sum += val;\n        }\n        total += std::ceil(static_cast<double>(sum) / capacity);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    int total = 0;\n    for (const auto & well : grid) {\n        int sum = 0;\n        for (int water : well) {\n            sum += water;\n        }\n        total += std::ceil(static_cast<double>(sum) / capacity);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty()) return true;\n    \n    std::unordered_map<int, int> count;\n    for (int num : lst) {\n        if (++count[num] > 2) {\n            return false;\n        }\n    }\n    \n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty()) return true;\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n        if (seen.count(lst[i]) > 0) {\n            return false;\n        }\n        seen.insert(lst[i]);\n    }\n    if (seen.count(lst.back()) > 0) {\n        return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty()) return true;\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n        if (seen.count(lst[i]) {\n            return false;\n        }\n        seen.insert(lst[i]);\n    }\n    if (lst.size() > 1 && seen.count(lst.back())) {\n        return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_set>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty()) return true;\n    std::unordered_set<int> seen;\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n        if (seen.count(lst[i]) > 0) {\n            return false;\n        }\n        seen.insert(lst[i]);\n    }\n    if (seen.count(lst.back()) > 0) {\n        return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty()) return true;\n    std::unordered_map<int, int> count;\n    for (int num : lst) {\n        if (++count[num] > 2) {\n            return false;\n        }\n    }\n    for (size_t i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sum = 0;\n    int product = 1;\n    for (int num : arr) {\n        sum += abs(num);\n        if (num > 0) {\n            product *= 1;\n        } else if (num < 0) {\n            product *= -1;\n        } else {\n            product *= 0;\n        }\n    }\n    return sum * product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sum = 0;\n    int product = 1;\n    for (int num : arr) {\n        sum += abs(num);\n        if (num > 0) {\n            product *= 1;\n        } else if (num < 0) {\n            product *= -1;\n        } else {\n            product *= 0;\n        }\n    }\n    return sum * product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sum = 0;\n    int product = 1;\n    for (int num : arr) {\n        sum += abs(num);\n        if (num > 0) {\n            product *= 1;\n        } else if (num < 0) {\n            product *= -1;\n        } else {\n            product *= 0;\n        }\n    }\n    return sum * product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sum = 0;\n    int product = 1;\n    for (int num : arr) {\n        sum += abs(num);\n        if (num > 0) {\n            product *= 1;\n        } else if (num < 0) {\n            product *= -1;\n        } else {\n            product *= 0;\n        }\n    }\n    return sum * product;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int product = 1;\n    int sum = 0;\n    for (int num : arr) {\n        if (num > 0) {\n            product *= 1;\n        } else if (num < 0) {\n            product *= -1;\n        } else {\n            product = 0;\n        }\n        sum += abs(num);\n    }\n    return product * sum;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int value;\n    int x;\n    int y;\n    vector<int> path;\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    priority_queue<State, vector<State>, function<bool(const State&, const State&)>> pq(\n        [](const State& a, const State& b) {\n            if (a.path.size() != b.path.size()) {\n                return a.path.size() > b.path.size();\n            }\n            for (size_t i = 0; i < a.path.size(); ++i) {\n                if (a.path[i] != b.path[i]) {\n                    return a.path[i] > b.path[i];\n                }\n            }\n            return false;\n        });\n\n    // Find the smallest value in the grid to start\n    int min_val = INT_MAX;\n    int start_x = -1, start_y = -1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    // Directions: up, down, left, right\n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n\n    // Initialize priority queue with the smallest value\n    pq.push({min_val, start_x, start_y, {min_val}});\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.path.size() == k) {\n            return current.path;\n        }\n\n        for (int i = 0; i < 4; ++i) {\n            int nx = current.x + dx[i];\n            int ny = current.y + dy[i];\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                vector<int> new_path = current.path;\n                new_path.push_back(grid[nx][ny]);\n                pq.push({grid[nx][ny], nx, ny, new_path});\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int value;\n    int x;\n    int y;\n    vector<int> path;\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    priority_queue<State, vector<State>, function<bool(const State&, const State&)>> pq(\n        [](const State& a, const State& b) {\n            if (a.path.size() != b.path.size()) {\n                return a.path.size() > b.path.size();\n            }\n            for (size_t i = 0; i < a.path.size(); ++i) {\n                if (a.path[i] != b.path[i]) {\n                    return a.path[i] > b.path[i];\n                }\n            }\n            return false;\n        }\n    );\n\n    // Find the smallest value in the grid to start\n    int min_val = INT_MAX;\n    int start_x = -1, start_y = -1;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                start_x = i;\n                start_y = j;\n            }\n        }\n    }\n\n    // Directions: up, down, left, right\n    const int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    // Push initial states\n    State initial;\n    initial.value = min_val;\n    initial.x = start_x;\n    initial.y = start_y;\n    initial.path = {min_val};\n    pq.push(initial);\n\n    while (!pq.empty()) {\n        State current = pq.top();\n        pq.pop();\n\n        if (current.path.size() == k) {\n            return current.path;\n        }\n\n        for (const auto& dir : dirs) {\n            int nx = current.x + dir[0];\n            int ny = current.y + dir[1];\n\n            if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                State next;\n                next.value = grid[nx][ny];\n                next.x = nx;\n                next.y = ny;\n                next.path = current.path;\n                next.path.push_back(grid[nx][ny]);\n                pq.push(next);\n            }\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int i, j;\n    vector<int> path;\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    vector<int> result;\n    int min_val = INT_MAX;\n    \n    // Find the cell with the smallest value to start\n    int start_i = 0, start_j = 0;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                start_i = i;\n                start_j = j;\n            }\n        }\n    }\n    \n    // BFS queue\n    queue<State> q;\n    q.push({start_i, start_j, {grid[start_i][start_j]}});\n    \n    while (!q.empty()) {\n        State current = q.front();\n        q.pop();\n        \n        if (current.path.size() == k) {\n            if (result.empty() || current.path < result) {\n                result = current.path;\n            }\n            continue;\n        }\n        \n        // Explore all neighbors\n        int di[] = {-1, 1, 0, 0};\n        int dj[] = {0, 0, -1, 1};\n        \n        vector<pair<int, pair<int, int>>> neighbors;\n        for (int d = 0; d < 4; ++d) {\n            int ni = current.i + di[d];\n            int nj = current.j + dj[d];\n            if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                neighbors.push_back({grid[ni][nj], {ni, nj}});\n            }\n        }\n        \n        // Sort neighbors by their grid value to explore in order\n        sort(neighbors.begin(), neighbors.end());\n        \n        for (auto& neighbor : neighbors) {\n            int ni = neighbor.second.first;\n            int nj = neighbor.second.second;\n            vector<int> new_path = current.path;\n            new_path.push_back(grid[ni][nj]);\n            q.push({ni, nj, new_path});\n            \n            // Early termination if we find a path that can't be better\n            if (!result.empty() && new_path.size() == k && new_path >= result) {\n                continue;\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int value;\n    int x;\n    int y;\n    vector<int> path;\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    vector<State> starts;\n    \n    // Find all possible starting positions (cells with smallest values)\n    int min_val = INT_MAX;\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_val) {\n                min_val = grid[i][j];\n                starts.clear();\n                starts.push_back({grid[i][j], i, j, {grid[i][j]}});\n            } else if (grid[i][j] == min_val) {\n                starts.push_back({grid[i][j], i, j, {grid[i][j]}});\n            }\n        }\n    }\n    \n    // Directions: up, down, left, right\n    const int dx[] = {-1, 1, 0, 0};\n    const int dy[] = {0, 0, -1, 1};\n    \n    vector<int> result;\n    \n    for (auto& start : starts) {\n        queue<State> q;\n        q.push(start);\n        \n        while (!q.empty()) {\n            State current = q.front();\n            q.pop();\n            \n            if (current.path.size() == k) {\n                if (result.empty() || current.path < result) {\n                    result = current.path;\n                }\n                continue;\n            }\n            \n            // Explore all neighbors\n            for (int d = 0; d < 4; ++d) {\n                int nx = current.x + dx[d];\n                int ny = current.y + dy[d];\n                \n                if (nx >= 0 && nx < N && ny >= 0 && ny < N) {\n                    vector<int> new_path = current.path;\n                    new_path.push_back(grid[nx][ny]);\n                    q.push({grid[nx][ny], nx, ny, new_path});\n                }\n            }\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int i, j;\n    vector<int> path;\n    State(int i, int j, vector<int> path) : i(i), j(j), path(move(path)) {}\n};\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int N = grid.size();\n    vector<int> min_path;\n    int min_start = INT_MAX;\n    vector<pair<int, int>> start_positions;\n\n    // Find the smallest starting value and its positions\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (grid[i][j] < min_start) {\n                min_start = grid[i][j];\n                start_positions.clear();\n                start_positions.emplace_back(i, j);\n            } else if (grid[i][j] == min_start) {\n                start_positions.emplace_back(i, j);\n            }\n        }\n    }\n\n    if (k == 1) {\n        return {min_start};\n    }\n\n    min_path = vector<int>(k, INT_MAX);\n    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n\n    for (auto& start : start_positions) {\n        queue<State> q;\n        q.emplace(start.first, start.second, vector<int>{grid[start.first][start.second]});\n\n        while (!q.empty()) {\n            auto current = q.front();\n            q.pop();\n\n            if (current.path.size() == k) {\n                if (current.path < min_path) {\n                    min_path = current.path;\n                }\n                continue;\n            }\n\n            if (current.path.size() > k) {\n                continue;\n            }\n\n            // Early termination if current path is already worse than min_path\n            bool worse = false;\n            for (int i = 0; i < current.path.size(); ++i) {\n                if (current.path[i] > min_path[i]) {\n                    worse = true;\n                    break;\n                } else if (current.path[i] < min_path[i]) {\n                    break;\n                }\n            }\n            if (worse) {\n                continue;\n            }\n\n            for (auto& dir : dirs) {\n                int ni = current.i + dir[0];\n                int nj = current.j + dir[1];\n                if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                    vector<int> new_path = current.path;\n                    new_path.push_back(grid[ni][nj]);\n                    q.emplace(ni, nj, new_path);\n                }\n            }\n        }\n    }\n\n    return min_path;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int has_odd = 0;\n    \n    while (n > 0) {\n        int digit = n % 10;\n        if (digit % 2 != 0) {\n            product *= digit;\n            has_odd = 1;\n        }\n        n /= 10;\n    }\n    \n    return has_odd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        float ceiling = std::ceil(num);\n        sum += ceiling * ceiling;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        float ceiling = ceil(num);\n        sum += static_cast<uint64_t>(ceiling * ceiling);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        float ceiling = std::ceil(num);\n        sum += static_cast<uint64_t>(ceiling * ceiling);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        float ceiling = std::ceil(num);\n        sum += static_cast<uint64_t>(ceiling * ceiling);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        float ceiling = ceil(num);\n        sum += static_cast<uint64_t>(ceiling * ceiling);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] <= arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] <= arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] <= arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] <= arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i > 0; --i) {\n        if (arr[i] <= arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n    \n    largest_neg = (max_neg != INT_MIN) ? max_neg : 0;\n    smallest_pos = (min_pos != INT_MAX) ? min_pos : 0;\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n    \n    largest_neg = (max_neg != INT_MIN) ? max_neg : 0;\n    smallest_pos = (min_pos != INT_MAX) ? min_pos : 0;\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < 0) {\n            if (num > max_neg) {\n                max_neg = num;\n            }\n        } else if (num > 0) {\n            if (num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n    \n    largest_neg = (max_neg != INT_MIN) ? max_neg : 0;\n    smallest_pos = (min_pos != INT_MAX) ? min_pos : 0;\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n        }\n        if (num > 0 && num < min_pos) {\n            min_pos = num;\n        }\n    }\n    \n    largest_neg = (max_neg != INT_MIN) ? max_neg : 0;\n    smallest_pos = (min_pos != INT_MAX) ? min_pos : 0;\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_neg = 0;\n    int smallest_pos = 0;\n    int max_neg = INT_MIN;\n    int min_pos = INT_MAX;\n    \n    for (int num : lst) {\n        if (num < 0 && num > max_neg) {\n            max_neg = num;\n        }\n        if (num > 0 && num < min_pos) {\n            min_pos = num;\n        }\n    }\n    \n    largest_neg = (max_neg != INT_MIN) ? max_neg : 0;\n    smallest_pos = (min_pos != INT_MAX) ? min_pos : 0;\n    \n    return {largest_neg, smallest_pos};\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        result *= current_factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        result *= current_factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        result *= current_factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_factorial = 1;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        result *= current_factorial;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_factorial = 1;\n    for (uint64_t i = 1; i <= n; ++i) {\n        current_factorial *= i;\n        result *= current_factorial;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int num = lst[i];\n        if (i % 3 == 0) {\n            num *= num;\n        } else if (i % 4 == 0) {\n            num = num * num * num;\n        }\n        sum += num;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int num = lst[i];\n        if (i % 3 == 0) {\n            num = num * num;\n        } else if (i % 4 == 0) {\n            num = num * num * num;\n        }\n        sum += num;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        int val = lst[i];\n        if (i % 3 == 0) {\n            val = val * val;\n        } else if (i % 4 == 0) {\n            val = val * val * val;\n        }\n        sum += val;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) continue;\n        \n        int abs_num = std::abs(num);\n        int last_digit = abs_num % 10;\n        if (last_digit % 2 == 0) continue;\n        \n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        if (first_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) continue;\n        \n        int abs_num = abs(num);\n        int last_digit = abs_num % 10;\n        if (last_digit % 2 == 0) continue;\n        \n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        if (first_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) {\n            continue;\n        }\n        \n        int abs_num = abs(num);\n        int last_digit = abs_num % 10;\n        if (last_digit % 2 == 0) {\n            continue;\n        }\n        \n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        \n        if (first_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) continue;\n        \n        int abs_num = std::abs(num);\n        int last_digit = abs_num % 10;\n        if (last_digit % 2 == 0) continue;\n        \n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        if (first_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) continue;\n        \n        int abs_num = abs(num);\n        int last_digit = abs_num % 10;\n        if (last_digit % 2 == 0) continue;\n        \n        int first_digit = abs_num;\n        while (first_digit >= 10) {\n            first_digit /= 10;\n        }\n        if (first_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        uint64_t mod = val % 3;\n        if (mod == 0) count0++;\n        else if (mod == 1) count1++;\n        else count2++;\n    }\n    \n    uint64_t total = 0;\n    total += count0 * (count0 - 1) * (count0 - 2) / 6;\n    total += count1 * count2 * count0;\n    total += count1 * (count1 - 1) * (count1 - 2) / 6;\n    total += count2 * (count2 - 1) * (count2 - 2) / 6;\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <array>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::array<uint64_t, 3> count = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    \n    uint64_t result = 0;\n    // All three elements are \u2261 0 mod 3\n    result += count[0] * (count[0] - 1) * (count[0] - 2) / 6;\n    // All three elements are \u2261 1 mod 3\n    result += count[1] * (count[1] - 1) * (count[1] - 2) / 6;\n    // All three elements are \u2261 2 mod 3\n    result += count[2] * (count[2] - 1) * (count[2] - 2) / 6;\n    // One from each residue class (0, 1, 2)\n    result += count[0] * count[1] * count[2];\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```c++\n#include <vector>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    int count0 = 0, count1 = 0, count2 = 0;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        int mod = val % 3;\n        if (mod == 0) count0++;\n        else if (mod == 1) count1++;\n        else count2++;\n    }\n    \n    uint64_t total = 0;\n    total += static_cast<uint64_t>(count0) * (count0 - 1) * (count0 - 2) / 6;\n    total += static_cast<uint64_t>(count1) * (count1 - 1) * (count1 - 2) / 6;\n    total += static_cast<uint64_t>(count2) * (count2 - 1) * (count2 - 2) / 6;\n    total += static_cast<uint64_t>(count0) * count1 * count2;\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::vector<uint64_t> a(n);\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    \n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        uint64_t mod = val % 3;\n        if (mod == 0) count0++;\n        else if (mod == 1) count1++;\n        else count2++;\n    }\n    \n    uint64_t total = 0;\n    total += count0 * (count0 - 1) * (count0 - 2) / 6;\n    total += count1 * count2 * count0;\n    total += count1 * (count1 - 1) * (count1 - 2) / 6;\n    total += count2 * (count2 - 1) * (count2 - 2) / 6;\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```c++\n#include <vector>\n#include <array>\n\nuint64_t get_max_triples(uint64_t n) {\n    std::array<uint64_t, 3> count = {0, 0, 0};\n    for (uint64_t i = 1; i <= n; ++i) {\n        uint64_t val = i * i - i + 1;\n        count[val % 3]++;\n    }\n    uint64_t result = 0;\n    result += count[0] * (count[0] - 1) * (count[0] - 2) / 6;\n    result += count[1] * (count[1] - 1) * (count[1] - 2) / 6;\n    result += count[2] * (count[2] - 1) * (count[2] - 2) / 6;\n    result += count[0] * count[1] * count[2];\n    return result;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return y;\n        }\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            int int_num = static_cast<int>(num);\n            sum += int_num * int_num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num >= 0 && num == static_cast<int>(num) && static_cast<int>(num) % 2 != 0) {\n            sum += static_cast<int>(num) * static_cast<int>(num);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(std::abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        if (game[i] == guess[i]) {\n            result.push_back(0);\n        } else {\n            result.push_back(abs(game[i] - guess[i]));\n        }\n    }\n    return result;\n}\n```"}

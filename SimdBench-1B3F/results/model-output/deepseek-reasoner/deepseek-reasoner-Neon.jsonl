{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 7 < length; i += 8) {\n        uint8x8_t mask_u8 = vld1_u8((const uint8_t*)(mask + i));\n        mask_u8 = vcgt_u8(mask_u8, vdup_n_u8(0));\n        int8x8_t mask_s8 = vreinterpret_s8_u8(mask_u8);\n        \n        int16x8_t mask_s16 = vmovl_s8(mask_s8);\n        int32x4_t mask_s32_low = vmovl_s16(vget_low_s16(mask_s16));\n        int32x4_t mask_s32_high = vmovl_s16(vget_high_s16(mask_s16));\n        \n        int64x2_t mask64_0 = vmovl_s32(vget_low_s32(mask_s32_low));\n        int64x2_t mask64_1 = vmovl_s32(vget_high_s32(mask_s32_low));\n        int64x2_t mask64_2 = vmovl_s32(vget_low_s32(mask_s32_high));\n        int64x2_t mask64_3 = vmovl_s32(vget_high_s32(mask_s32_high));\n        \n        int64x2_t src0 = vld1q_s64(src + i);\n        int64x2_t src1 = vld1q_s64(src + i + 2);\n        int64x2_t src2 = vld1q_s64(src + i + 4);\n        int64x2_t src3 = vld1q_s64(src + i + 6);\n        \n        int64x2_t dst0 = vld1q_s64(dst + i);\n        int64x2_t dst1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst3 = vld1q_s64(dst + i + 6);\n        \n        dst0 = vbslq_s64(vreinterpretq_u64_s64(mask64_0), src0, dst0);\n        dst1 = vbslq_s64(vreinterpretq_u64_s64(mask64_1), src1, dst1);\n        dst2 = vbslq_s64(vreinterpretq_u64_s64(mask64_2), src2, dst2);\n        dst3 = vbslq_s64(vreinterpretq_u64_s64(mask64_3), src3, dst3);\n        \n        vst1q_s64(dst + i, dst0);\n        vst1q_s64(dst + i + 2, dst1);\n        vst1q_s64(dst + i + 4, dst2);\n        vst1q_s64(dst + i + 6, dst3);\n    }\n    \n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    \n    if (length >= 16) {\n        for (; i <= length - 16; i += 16) {\n            uint8x16_t mask_vec = vld1q_u8((const uint8_t*)(mask + i));\n            mask_vec = vandq_u8(mask_vec, vdupq_n_u8(1));\n            mask_vec = vreinterpretq_u8_s8(vnegq_s8(vreinterpretq_s8_u8(mask_vec)));\n            \n            uint64x2_t mask64 = vreinterpretq_u64_u8(mask_vec);\n            uint64_t mask_low = vgetq_lane_u64(mask64, 0);\n            uint64_t mask_high = vgetq_lane_u64(mask64, 1);\n            \n            for (int j = 0; j < 8; j += 2) {\n                uint64_t byte0 = (mask_low >> (j * 8)) & 0xFF;\n                uint64_t byte1 = (mask_low >> ((j+1) * 8)) & 0xFF;\n                uint64_t mask0 = byte0 ? UINT64_MAX : 0;\n                uint64_t mask1 = byte1 ? UINT64_MAX : 0;\n                uint64x2_t mask_vec_pair = vcombine_u64(vcreate_u64(mask0), vcreate_u64(mask1));\n                \n                uint64x2_t src_data = vld1q_u64(src + i + j);\n                uint64x2_t dst_data = vld1q_u64(dst + i + j);\n                dst_data = vbslq_u64(mask_vec_pair, src_data, dst_data);\n                vst1q_u64(dst + i + j, dst_data);\n            }\n            \n            for (int j = 0; j < 8; j += 2) {\n                uint64_t byte0 = (mask_high >> (j * 8)) & 0xFF;\n                uint64_t byte1 = (mask_high >> ((j+1) * 8)) & 0xFF;\n                uint64_t mask0 = byte0 ? UINT64_MAX : 0;\n                uint64_t mask1 = byte1 ? UINT64_MAX : 0;\n                uint64x2_t mask_vec_pair = vcombine_u64(vcreate_u64(mask0), vcreate_u64(mask1));\n                \n                uint64x2_t src_data = vld1q_u64(src + i + 8 + j);\n                uint64x2_t dst_data = vld1q_u64(dst + i + 8 + j);\n                dst_data = vbslq_u64(mask_vec_pair, src_data, dst_data);\n                vst1q_u64(dst + i + 8 + j, dst_data);\n            }\n        }\n    }\n    \n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        uint8x8_t mask_u8 = vld1_u8((const uint8_t*)(mask + i));\n        uint8x8_t mask_cmp = vcgt_u8(mask_u8, vdup_n_u8(0));\n        int8x8_t mask8 = vreinterpret_s8_u8(mask_cmp);\n        int16x8_t mask16 = vmovl_s8(mask8);\n        int32x4_t mask32_low = vmovl_s16(vget_low_s16(mask16));\n        int32x4_t mask32_high = vmovl_s16(vget_high_s16(mask16));\n        int64x2_t mask64_0 = vmovl_s32(vget_low_s32(mask32_low));\n        int64x2_t mask64_1 = vmovl_s32(vget_high_s32(mask32_low));\n        int64x2_t mask64_2 = vmovl_s32(vget_low_s32(mask32_high));\n        int64x2_t mask64_3 = vmovl_s32(vget_high_s32(mask32_high));\n        int64x2_t src0 = vld1q_s64(src + i);\n        int64x2_t src1 = vld1q_s64(src + i + 2);\n        int64x2_t src2 = vld1q_s64(src + i + 4);\n        int64x2_t src3 = vld1q_s64(src + i + 6);\n        int64x2_t dst0 = vld1q_s64(dst + i);\n        int64x2_t dst1 = vld1q_s64(dst + i + 2);\n        int64x2_t dst2 = vld1q_s64(dst + i + 4);\n        int64x2_t dst3 = vld1q_s64(dst + i + 6);\n        dst0 = vbslq_s64(vreinterpretq_u64_s64(mask64_0), src0, dst0);\n        dst1 = vbslq_s64(vreinterpretq_u64_s64(mask64_1), src1, dst1);\n        dst2 = vbslq_s64(vreinterpretq_u64_s64(mask64_2), src2, dst2);\n        dst3 = vbslq_s64(vreinterpretq_u64_s64(mask64_3), src3, dst3);\n        vst1q_s64(dst + i, dst0);\n        vst1q_s64(dst + i + 2, dst1);\n        vst1q_s64(dst + i + 4, dst2);\n        vst1q_s64(dst + i + 6, dst3);\n    }\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    // Process two elements per iteration\n    for (; i + 2 <= length; i += 2) {\n        bool m0 = mask[i];\n        bool m1 = mask[i + 1];\n        \n        int64x2_t src_vec = vld1q_s64(src + i);\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        \n        uint64x2_t mask_vec = vdupq_n_u64(0);\n        mask_vec = vsetq_lane_u64(m0 ? UINT64_MAX : 0, mask_vec, 0);\n        mask_vec = vsetq_lane_u64(m1 ? UINT64_MAX : 0, mask_vec, 1);\n        \n        int64x2_t res_vec = vbslq_s64(mask_vec, src_vec, dst_vec);\n        vst1q_s64(dst + i, res_vec);\n    }\n    // Process any remaining element\n    if (i < length) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <string.h>\n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 2; i += 2) {\n        uint64_t mask0 = mask[i] ? UINT64_MAX : 0;\n        uint64_t mask1 = mask[i+1] ? UINT64_MAX : 0;\n        uint64x2_t mask_vec = (uint64x2_t){mask0, mask1};\n        int64x2_t src_vec = vld1q_s64(src + i);\n        int64x2_t dst_vec = vld1q_s64(dst + i);\n        int64x2_t res = vreinterpretq_s64_u64(\n            vbslq_u64(\n                mask_vec,\n                vreinterpretq_u64_s64(src_vec),\n                vreinterpretq_u64_s64(dst_vec)\n            )\n        );\n        vst1q_s64(dst + i, res);\n    }\n    for (; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t vscale = vdupq_n_s32(scale);\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vsrc = vld1q_s32(src + i);\n        int32x4_t va = vmulq_s32(vsrc, vscale);\n        int32x4_t tmp1 = vshrq_n_s32(va, 3);\n        int32x4_t tmp2 = vshlq_n_s32(va, 3);\n        int32x4_t product = vmulq_s32(tmp1, tmp2);\n        int32x4_t s = vaddq_s32(va, product);\n        int32_t s0 = vgetq_lane_s32(s, 0) / 7;\n        int32_t s1 = vgetq_lane_s32(s, 1) / 7;\n        int32_t s2 = vgetq_lane_s32(s, 2) / 7;\n        int32_t s3 = vgetq_lane_s32(s, 3) / 7;\n        int32x4_t vresult = vsetq_lane_s32(s0, vdupq_n_s32(0), 0);\n        vresult = vsetq_lane_s32(s1, vresult, 1);\n        vresult = vsetq_lane_s32(s2, vresult, 2);\n        vresult = vsetq_lane_s32(s3, vresult, 3);\n        vst1q_s32(dst + i, vresult);\n    }\n    for (; i < length; i++) {\n        int32_t a = src[i] * scale;\n        int32_t tmp1 = a >> 3;\n        int32_t tmp2 = a << 3;\n        int32_t product = tmp1 * tmp2;\n        dst[i] = (a + product) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    int32x4_t v_scale = vdupq_n_s32(scale);\n\n    for (; i + 3 < length; i += 4) {\n        int32x4_t v_src = vld1q_s32(src + i);\n        int32x4_t v_x = vmulq_s32(v_src, v_scale);\n        int32x4_t v_x_sq = vmulq_s32(v_x, v_x);\n        int32x4_t v_total = vaddq_s32(v_x, v_x_sq);\n\n        int32_t total[4];\n        vst1q_s32(total, v_total);\n        for (int j = 0; j < 4; j++) {\n            dst[i + j] = total[j] / 7;\n        }\n    }\n\n    for (; i < length; i++) {\n        int32_t x = src[i] * scale;\n        int32_t x_sq = x * x;\n        dst[i] = (x + x_sq) / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    if (length == 0) return;\n    \n    int32x4_t scale_vec = vdupq_n_s32(scale);\n    const uint32_t magic = 613566757; // Magic number for division by 7\n    size_t i = 0;\n\n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x4_t scaled = vmulq_s32(vec, scale_vec);\n        int32x4_t tmp1 = vshrq_n_s32(scaled, 3);\n        int32x4_t tmp2 = vshlq_n_s32(scaled, 3);\n        int32x4_t product = vmulq_s32(tmp1, tmp2);\n        int32x4_t sum = vaddq_s32(scaled, product);\n        \n        int32x4_t sign_mask = vshrq_n_s32(sum, 31);\n        int32x4_t abs_sum = vabsq_s32(sum);\n        uint32x4_t u_abs_sum = vreinterpretq_u32_s32(abs_sum);\n        \n        uint32x2_t low = vget_low_u32(u_abs_sum);\n        uint32x2_t high = vget_high_u32(u_abs_sum);\n        uint64x2_t plow = vmull_u32(low, vdup_n_u32(magic));\n        uint64x2_t phigh = vmull_u32(high, vdup_n_u32(magic));\n        uint32x2_t t_low = vshrn_n_u64(plow, 32);\n        uint32x2_t t_high = vshrn_n_u64(phigh, 32);\n        uint32x4_t t = vcombine_u32(t_low, t_high);\n        \n        uint32x4_t q0 = vsubq_u32(u_abs_sum, t);\n        q0 = vshrq_n_u32(q0, 1);\n        q0 = vaddq_u32(t, q0);\n        q0 = vshrq_n_u32(q0, 2);\n        int32x4_t result = vreinterpretq_s32_u32(q0);\n        result = vsubq_s32(veorq_s32(result, sign_mask), sign_mask);\n        \n        vst1q_s32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        int32_t n = src[i];\n        int32_t scaled = n * scale;\n        int32_t tmp1 = scaled >> 3;\n        int32_t tmp2 = scaled << 3;\n        int32_t product = tmp1 * tmp2;\n        int32_t sum = scaled + product;\n        \n        int32_t sign = sum >> 31;\n        int32_t abs_sum = sum < 0 ? -sum : sum;\n        uint32_t t = ((uint64_t)abs_sum * magic) >> 32;\n        uint32_t q0 = (abs_sum - t) >> 1;\n        q0 = (t + q0) >> 2;\n        int32_t result = (int32_t)q0;\n        if (sign) result = -result;\n        dst[i] = result;\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    const int32_t M = 2454267027;\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t vec_src = vld1q_s32(src + i);\n        int32x4_t x = vmulq_n_s32(vec_src, scale);\n        int32x4_t tmp1 = vshrq_n_s32(x, 3);\n        int32x4_t tmp2 = vshlq_n_s32(x, 3);\n        int32x4_t product = vmulq_s32(tmp1, tmp2);\n        int32x4_t sum = vaddq_s32(x, product);\n        \n        int32x4_t M_vec = vdupq_n_s32(M);\n        int64x2_t low_prod = vmull_s32(vget_low_s32(sum), vget_low_s32(M_vec));\n        int64x2_t high_prod = vmull_s32(vget_high_s32(sum), vget_high_s32(M_vec));\n        low_prod = vshrq_n_s64(low_prod, 34);\n        high_prod = vshrq_n_s64(high_prod, 34);\n        int32x2_t low_res = vmovn_s64(low_prod);\n        int32x2_t high_res = vmovn_s64(high_prod);\n        int32x4_t result = vcombine_s32(low_res, high_res);\n        \n        vst1q_s32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        int32_t x = src[i] * scale;\n        int32_t tmp1 = x >> 3;\n        int32_t tmp2 = x << 3;\n        int32_t product = tmp1 * tmp2;\n        int32_t sum = x + product;\n        dst[i] = (int32_t)((int64_t)sum * M >> 34);\n    }\n}\n```"}
{"task_id": "SimdBench_1_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t src_vec = vld1q_s32(src + i);\n        int32x4_t x_vec = vmulq_n_s32(src_vec, scale);\n        int32x4_t tmp1_vec = vshrq_n_s32(x_vec, 3);\n        int32x4_t tmp2_vec = vshlq_n_s32(x_vec, 3);\n\n        int64x2_t product_low = vmull_s32(vget_low_s32(tmp1_vec), vget_low_s32(tmp2_vec));\n        int64x2_t product_high = vmull_s32(vget_high_s32(tmp1_vec), vget_high_s32(tmp2_vec));\n        \n        int64x2_t x_low = vmovl_s32(vget_low_s32(x_vec));\n        int64x2_t x_high = vmovl_s32(vget_high_s32(x_vec));\n        \n        int64x2_t sum_low = vaddq_s64(x_low, product_low);\n        int64x2_t sum_high = vaddq_s64(x_high, product_high);\n        \n        long long sum0 = vgetq_lane_s64(sum_low, 0);\n        long long sum1 = vgetq_lane_s64(sum_low, 1);\n        long long sum2 = vgetq_lane_s64(sum_high, 0);\n        long long sum3 = vgetq_lane_s64(sum_high, 1);\n        \n        int32_t res0 = (int32_t)(sum0 / 7);\n        int32_t res1 = (int32_t)(sum1 / 7);\n        int32_t res2 = (int32_t)(sum2 / 7);\n        int32_t res3 = (int32_t)(sum3 / 7);\n        \n        int32x4_t res_vec = vdupq_n_s32(0);\n        res_vec = vsetq_lane_s32(res0, res_vec, 0);\n        res_vec = vsetq_lane_s32(res1, res_vec, 1);\n        res_vec = vsetq_lane_s32(res2, res_vec, 2);\n        res_vec = vsetq_lane_s32(res3, res_vec, 3);\n        \n        vst1q_s32(dst + i, res_vec);\n    }\n    \n    for (; i < length; i++) {\n        int x = src[i] * scale;\n        int tmp1 = x >> 3;\n        int tmp2 = x << 3;\n        long long product = (long long)tmp1 * tmp2;\n        long long sum = (long long)x + product;\n        dst[i] = (int)(sum / 7);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    for (; r + 1 < rows; r += 2) {\n        float64x1_t a0 = vld1_f64(src + r * cols + stride);\n        float64x1_t a1 = vld1_f64(src + (r + 1) * cols + stride);\n        float64x2_t vec = vcombine_f64(a0, a1);\n        vst1q_f64(dst + r, vec);\n    }\n    if (r < rows) {\n        float64x1_t last = vld1_f64(src + r * cols + stride);\n        vst1_f64(dst + r, last);\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    if (rows == 0) \n        return;\n\n    size_t r = 0;\n    for (; r + 1 < rows; r += 2) {\n        const double* row0_ptr = src + r * cols + stride;\n        const double* row1_ptr = src + (r + 1) * cols + stride;\n        \n        double64x1_t d0 = vld1_f64(row0_ptr);\n        double64x1_t d1 = vld1_f64(row1_ptr);\n        double64x2_t combined = vcombine_f64(d0, d1);\n        \n        vst1q_f64(dst + r, combined);\n    }\n\n    if (r < rows) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t r = 0;\n    for (; r <= rows - 2; r += 2) {\n        const double *row0 = src + r * cols;\n        const double *row1 = row0 + cols;\n        float64x2_t v = vdupq_n_f64(0);\n        v = vld1q_lane_f64(row0 + stride, v, 0);\n        v = vld1q_lane_f64(row1 + stride, v, 1);\n        vst1q_f64(dst + r, v);\n    }\n    if (r < rows) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    if (rows == 0) return;\n\n    size_t r = 0;\n    for (; r <= rows - 2; r += 2) {\n        const double* addr0 = src + r * cols + stride;\n        const double* addr1 = src + (r + 1) * cols + stride;\n        float64x1_t a0 = vld1_f64(addr0);\n        float64x1_t a1 = vld1_f64(addr1);\n        float64x2_t v = vcombine_f64(a0, a1);\n        vst1q_f64(dst + r, v);\n    }\n\n    if (r < rows) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    if (rows == 0) return;\n\n    size_t r = 0;\n    for (; r + 1 < rows; r += 2) {\n        const double* row0_ptr = src + r * cols + stride;\n        const double* row1_ptr = src + (r + 1) * cols + stride;\n        \n        float64x1_t val0 = vld1_f64(row0_ptr);\n        float64x1_t val1 = vld1_f64(row1_ptr);\n        float64x2_t combined = vcombine_f64(val0, val1);\n        \n        vst1q_f64(dst + r, combined);\n    }\n\n    if (r < rows) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    \n    // Gather: dst[i] = src[indices[i]]\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        float32x4_t gathered = vdupq_n_f32(0);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 0)], gathered, 0);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx, 3)], gathered, 3);\n        vst1q_f32(dst + i, gathered);\n    }\n    for (; i < length; ++i) {\n        dst[i] = src[indices[i]];\n    }\n    \n    i = 0;\n    \n    // Scatter: dst[indices[i]] = src[i]\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        float32x4_t vals = vld1q_f32(src + i);\n        dst[vgetq_lane_s32(idx, 0)] = vgetq_lane_f32(vals, 0);\n        dst[vgetq_lane_s32(idx, 1)] = vgetq_lane_f32(vals, 1);\n        dst[vgetq_lane_s32(idx, 2)] = vgetq_lane_f32(vals, 2);\n        dst[vgetq_lane_s32(idx, 3)] = vgetq_lane_f32(vals, 3);\n    }\n    for (; i < length; ++i) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        float32x4_t gathered = vdupq_n_f32(0.0f);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 0)], gathered, 0);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], gathered, 1);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], gathered, 2);\n        gathered = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], gathered, 3);\n        vst1q_f32(dst + i, gathered);\n    }\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t scatter_idx = vld1q_s32(indices + i);\n        float32x4_t values = vld1q_f32(src + i);\n        dst[vgetq_lane_s32(scatter_idx, 0)] = vgetq_lane_f32(values, 0);\n        dst[vgetq_lane_s32(scatter_idx, 1)] = vgetq_lane_f32(values, 1);\n        dst[vgetq_lane_s32(scatter_idx, 2)] = vgetq_lane_f32(values, 2);\n        dst[vgetq_lane_s32(scatter_idx, 3)] = vgetq_lane_f32(values, 3);\n    }\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    // Gather pass: dst[i] = src[indices[i]]\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        float32x4_t res_vec;\n        res_vec = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 0)], res_vec, 0);\n        res_vec = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 1)], res_vec, 1);\n        res_vec = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 2)], res_vec, 2);\n        res_vec = vsetq_lane_f32(src[vgetq_lane_s32(idx_vec, 3)], res_vec, 3);\n        vst1q_f32(dst + i, res_vec);\n    }\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Scatter pass: dst[indices[i]] = src[i]\n    i = 0;\n    for (; i + 3 < length; i += 4) {\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        float32x4_t val_vec = vld1q_f32(src + i);\n        dst[vgetq_lane_s32(idx_vec, 0)] = vgetq_lane_f32(val_vec, 0);\n        dst[vgetq_lane_s32(idx_vec, 1)] = vgetq_lane_f32(val_vec, 1);\n        dst[vgetq_lane_s32(idx_vec, 2)] = vgetq_lane_f32(val_vec, 2);\n        dst[vgetq_lane_s32(idx_vec, 3)] = vgetq_lane_f32(val_vec, 3);\n    }\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n\n    // Step 1: Gather operation (dst[i] = src[indices[i]])\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        float32x4_t vals = vld1q_gather_f32(src, idx_vec);\n        vst1q_f32(dst + i, vals);\n    }\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n\n    // Step 2: Scatter operation (dst[indices[i]] = src[i])\n    i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t idx_vec = vld1q_s32(indices + i);\n        float32x4_t src_vals = vld1q_f32(src + i);\n        vst1q_scatter_f32(dst, idx_vec, src_vals);\n    }\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        int32x4_t byte_offsets = vshlq_n_s32(idx, 2);\n        float32x4_t res = vld1q_gather_f32(src, byte_offsets);\n        vst1q_f32(dst + i, res);\n    }\n    for (; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    \n    i = 0;\n    for (; i <= length - 4; i += 4) {\n        int32x4_t idx = vld1q_s32(indices + i);\n        int32x4_t byte_offsets = vshlq_n_s32(idx, 2);\n        float32x4_t vals = vld1q_f32(src + i);\n        vst1q_scatter_f32(dst, byte_offsets, vals);\n    }\n    for (; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left < right) {\n        if (right - left + 1 >= 16) {\n            int16x8_t left_vec = vld1q_s16(arr + left);\n            int16x8_t right_vec = vld1q_s16(arr + right - 7);\n\n            int16x8_t rev_left_vec = vrev64q_s16(left_vec);\n            rev_left_vec = vextq_s16(rev_left_vec, rev_left_vec, 4);\n            int16x8_t rev_right_vec = vrev64q_s16(right_vec);\n            rev_right_vec = vextq_s16(rev_right_vec, rev_right_vec, 4);\n\n            vst1q_s16(arr + left, rev_right_vec);\n            vst1q_s16(arr + right - 7, rev_left_vec);\n\n            left += 8;\n            right -= 8;\n        } else {\n            int16_t temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left <= right - 15) {\n        int16x8_t left_vec = vld1q_s16(arr + left);\n        int16x8_t right_vec = vld1q_s16(arr + right - 7);\n\n        int16x8_t rev_left = vrev64q_s16(left_vec);\n        rev_left = vextq_s16(rev_left, rev_left, 4);\n        int16x8_t rev_right = vrev64q_s16(right_vec);\n        rev_right = vextq_s16(rev_right, rev_right, 4);\n\n        vst1q_s16(arr + left, rev_right);\n        vst1q_s16(arr + right - 7, rev_left);\n\n        left += 8;\n        right -= 8;\n    }\n\n    while (left < right) {\n        int16_t temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (end < start) {\n        return;\n    }\n    uint64_t i = start;\n    uint64_t j = end;\n\n    while (j - i >= 15) {\n        int16x8_t L = vld1q_s16(arr + i);\n        int16x8_t R = vld1q_s16(arr + j - 7);\n\n        int16x8_t L_rev_temp = vrev64q_s16(L);\n        int16x8_t L_rev = vextq_s16(L_rev_temp, L_rev_temp, 4);\n\n        int16x8_t R_rev_temp = vrev64q_s16(R);\n        int16x8_t R_rev = vextq_s16(R_rev_temp, R_rev_temp, 4);\n\n        vst1q_s16(arr + i, R_rev);\n        vst1q_s16(arr + j - 7, L_rev);\n\n        i += 8;\n        j -= 8;\n    }\n\n    while (i < j) {\n        int16_t temp = arr[i];\n        arr[i] = arr[j];\n        arr[j] = temp;\n        i++;\n        j--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left + 14 < right) {\n        int16x8_t left_vec = vld1q_s16(arr + left);\n        int16x8_t right_vec = vld1q_s16(arr + right - 7);\n\n        int16x8_t rev_left = vrev64q_s16(left_vec);\n        rev_left = vcombine_s16(vget_high_s16(rev_left), vget_low_s16(rev_left));\n\n        int16x8_t rev_right = vrev64q_s16(right_vec);\n        rev_right = vcombine_s16(vget_high_s16(rev_right), vget_low_s16(rev_right));\n\n        vst1q_s16(arr + left, rev_right);\n        vst1q_s16(arr + right - 7, rev_left);\n\n        left += 8;\n        right -= 8;\n    }\n\n    while (left < right) {\n        int16_t temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_4_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) {\n        return;\n    }\n\n    uint64_t left = start;\n    uint64_t right = end;\n\n    while (left + 14 < right) {\n        int16x8_t front = vld1q_s16(arr + left);\n        int16x8_t back = vld1q_s16(arr + right - 7);\n\n        int16x8_t rev_front = vrev64q_s16(front);\n        rev_front = vextq_s16(rev_front, rev_front, 4);\n\n        int16x8_t rev_back = vrev64q_s16(back);\n        rev_back = vextq_s16(rev_back, rev_back, 4);\n\n        vst1q_s16(arr + left, rev_back);\n        vst1q_s16(arr + right - 7, rev_front);\n\n        left += 8;\n        right -= 8;\n    }\n\n    while (left < right) {\n        int16_t temp = arr[left];\n        arr[left] = arr[right];\n        arr[right] = temp;\n        left++;\n        right--;\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *src_base = tensor + i * dim2 * dim3 + slice_idx;\n        uint8_t *dst_base = slice + i * dim2;\n        size_t j = 0;\n\n        for (; j + 16 <= dim2; j += 16) {\n            uint8_t values[16];\n            const uint8_t *p = src_base + j * dim3;\n            for (int k = 0; k < 16; k++) {\n                values[k] = *p;\n                p += dim3;\n            }\n            uint8x16_t vec = vld1q_u8(values);\n            vst1q_u8(dst_base + j, vec);\n        }\n\n        const uint8_t *p_rem = src_base + j * dim3;\n        for (; j < dim2; j++) {\n            dst_base[j] = *p_rem;\n            p_rem += dim3;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *base = tensor + i * dim2 * dim3 + slice_idx;\n        uint8_t *out_row = slice + i * dim2;\n        const uint8_t *p = base;\n        size_t j = 0;\n\n        for (; j + 15 < dim2; j += 16, p += 16 * dim3) {\n            uint64_t part0 = (uint64_t)p[0] \n                | (uint64_t)p[dim3] << 8 \n                | (uint64_t)p[2*dim3] << 16 \n                | (uint64_t)p[3*dim3] << 24 \n                | (uint64_t)p[4*dim3] << 32 \n                | (uint64_t)p[5*dim3] << 40 \n                | (uint64_t)p[6*dim3] << 48 \n                | (uint64_t)p[7*dim3] << 56;\n\n            uint64_t part1 = (uint64_t)p[8*dim3] \n                | (uint64_t)p[9*dim3] << 8 \n                | (uint64_t)p[10*dim3] << 16 \n                | (uint64_t)p[11*dim3] << 24 \n                | (uint64_t)p[12*dim3] << 32 \n                | (uint64_t)p[13*dim3] << 40 \n                | (uint64_t)p[14*dim3] << 48 \n                | (uint64_t)p[15*dim3] << 56;\n\n            uint64x1_t a = vmov_n_u64(part0);\n            uint64x1_t b = vmov_n_u64(part1);\n            uint64x2_t combined = vcombine_u64(a, b);\n            uint8x16_t vec = vreinterpretq_u8_u64(combined);\n            vst1q_u8(out_row + j, vec);\n        }\n\n        for (; j < dim2; j++, p += dim3) {\n            out_row[j] = *p;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *base_i = tensor + i * dim2 * dim3;\n        uint8_t *slice_row = slice + i * dim2;\n        size_t j = 0;\n\n        for (; j + 15 < dim2; j += 16) {\n            uint8x16_t vec;\n            vec = vsetq_lane_u8(base_i[j * dim3 + slice_idx], vec, 0);\n            vec = vsetq_lane_u8(base_i[(j+1) * dim3 + slice_idx], vec, 1);\n            vec = vsetq_lane_u8(base_i[(j+2) * dim3 + slice_idx], vec, 2);\n            vec = vsetq_lane_u8(base_i[(j+3) * dim3 + slice_idx], vec, 3);\n            vec = vsetq_lane_u8(base_i[(j+4) * dim3 + slice_idx], vec, 4);\n            vec = vsetq_lane_u8(base_i[(j+5) * dim3 + slice_idx], vec, 5);\n            vec = vsetq_lane_u8(base_i[(j+6) * dim3 + slice_idx], vec, 6);\n            vec = vsetq_lane_u8(base_i[(j+7) * dim3 + slice_idx], vec, 7);\n            vec = vsetq_lane_u8(base_i[(j+8) * dim3 + slice_idx], vec, 8);\n            vec = vsetq_lane_u8(base_i[(j+9) * dim3 + slice_idx], vec, 9);\n            vec = vsetq_lane_u8(base_i[(j+10) * dim3 + slice_idx], vec, 10);\n            vec = vsetq_lane_u8(base_i[(j+11) * dim3 + slice_idx], vec, 11);\n            vec = vsetq_lane_u8(base_i[(j+12) * dim3 + slice_idx], vec, 12);\n            vec = vsetq_lane_u8(base_i[(j+13) * dim3 + slice_idx], vec, 13);\n            vec = vsetq_lane_u8(base_i[(j+14) * dim3 + slice_idx], vec, 14);\n            vec = vsetq_lane_u8(base_i[(j+15) * dim3 + slice_idx], vec, 15);\n            vst1q_u8(slice_row + j, vec);\n        }\n\n        for (; j < dim2; j++) {\n            slice_row[j] = base_i[j * dim3 + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *base_ptr = tensor + i * (dim2 * dim3) + slice_idx;\n        uint8_t *slice_ptr = slice + i * dim2;\n        size_t j = 0;\n\n        for (; j + 15 < dim2; j += 16) {\n            uint8x16_t v = vdupq_n_u8(0);\n            v = vld1q_lane_u8(base_ptr + (j + 0) * dim3, v, 0);\n            v = vld1q_lane_u8(base_ptr + (j + 1) * dim3, v, 1);\n            v = vld1q_lane_u8(base_ptr + (j + 2) * dim3, v, 2);\n            v = vld1q_lane_u8(base_ptr + (j + 3) * dim3, v, 3);\n            v = vld1q_lane_u8(base_ptr + (j + 4) * dim3, v, 4);\n            v = vld1q_lane_u8(base_ptr + (j + 5) * dim3, v, 5);\n            v = vld1q_lane_u8(base_ptr + (j + 6) * dim3, v, 6);\n            v = vld1q_lane_u8(base_ptr + (j + 7) * dim3, v, 7);\n            v = vld1q_lane_u8(base_ptr + (j + 8) * dim3, v, 8);\n            v = vld1q_lane_u8(base_ptr + (j + 9) * dim3, v, 9);\n            v = vld1q_lane_u8(base_ptr + (j + 10) * dim3, v, 10);\n            v = vld1q_lane_u8(base_ptr + (j + 11) * dim3, v, 11);\n            v = vld1q_lane_u8(base_ptr + (j + 12) * dim3, v, 12);\n            v = vld1q_lane_u8(base_ptr + (j + 13) * dim3, v, 13);\n            v = vld1q_lane_u8(base_ptr + (j + 14) * dim3, v, 14);\n            v = vld1q_lane_u8(base_ptr + (j + 15) * dim3, v, 15);\n            vst1q_u8(slice_ptr + j, v);\n        }\n\n        for (; j + 7 < dim2; j += 8) {\n            uint8x8_t v = vdup_n_u8(0);\n            v = vld1_lane_u8(base_ptr + (j + 0) * dim3, v, 0);\n            v = vld1_lane_u8(base_ptr + (j + 1) * dim3, v, 1);\n            v = vld1_lane_u8(base_ptr + (j + 2) * dim3, v, 2);\n            v = vld1_lane_u8(base_ptr + (j + 3) * dim3, v, 3);\n            v = vld1_lane_u8(base_ptr + (j + 4) * dim3, v, 4);\n            v = vld1_lane_u8(base_ptr + (j + 5) * dim3, v, 5);\n            v = vld1_lane_u8(base_ptr + (j + 6) * dim3, v, 6);\n            v = vld1_lane_u8(base_ptr + (j + 7) * dim3, v, 7);\n            vst1_u8(slice_ptr + j, v);\n        }\n\n        for (; j < dim2; j++) {\n            slice_ptr[j] = base_ptr[j * dim3];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *src_row = tensor + i * dim2 * dim3 + slice_idx;\n        uint8_t *dst_row = slice + i * dim2;\n        size_t j = 0;\n\n        for (; j + 16 <= dim2; j += 16) {\n            uint8x16_t vec = vdupq_n_u8(0);\n            vec = vld1q_lane_u8(src_row + j * dim3, vec, 0);\n            vec = vld1q_lane_u8(src_row + (j + 1) * dim3, vec, 1);\n            vec = vld1q_lane_u8(src_row + (j + 2) * dim3, vec, 2);\n            vec = vld1q_lane_u8(src_row + (j + 3) * dim3, vec, 3);\n            vec = vld1q_lane_u8(src_row + (j + 4) * dim3, vec, 4);\n            vec = vld1q_lane_u8(src_row + (j + 5) * dim3, vec, 5);\n            vec = vld1q_lane_u8(src_row + (j + 6) * dim3, vec, 6);\n            vec = vld1q_lane_u8(src_row + (j + 7) * dim3, vec, 7);\n            vec = vld1q_lane_u8(src_row + (j + 8) * dim3, vec, 8);\n            vec = vld1q_lane_u8(src_row + (j + 9) * dim3, vec, 9);\n            vec = vld1q_lane_u8(src_row + (j + 10) * dim3, vec, 10);\n            vec = vld1q_lane_u8(src_row + (j + 11) * dim3, vec, 11);\n            vec = vld1q_lane_u8(src_row + (j + 12) * dim3, vec, 12);\n            vec = vld1q_lane_u8(src_row + (j + 13) * dim3, vec, 13);\n            vec = vld1q_lane_u8(src_row + (j + 14) * dim3, vec, 14);\n            vec = vld1q_lane_u8(src_row + (j + 15) * dim3, vec, 15);\n            vst1q_u8(dst_row + j, vec);\n        }\n\n        for (; j < dim2; j++) {\n            dst_row[j] = src_row[j * dim3];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_end = (i + block_size) < rows ? (i + block_size) : rows;\n        size_t block_height = i_end - i;\n\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_end = (j + block_size) < cols ? (j + block_size) : cols;\n            size_t block_width = j_end - j;\n\n            for (size_t jj = 0; jj < block_width; jj += 8) {\n                size_t chunk_width = (block_width - jj) > 8 ? 8 : block_width - jj;\n\n                for (size_t ii = 0; ii < block_height; ii += 8) {\n                    size_t chunk_height = (block_height - ii) > 8 ? 8 : block_height - ii;\n\n                    if (chunk_width == 8 && chunk_height == 8) {\n                        int16x8_t row0 = vld1q_s16(src + (i + ii) * cols + j + jj);\n                        int16x8_t row1 = vld1q_s16(src + (i + ii + 1) * cols + j + jj);\n                        int16x8_t row2 = vld1q_s16(src + (i + ii + 2) * cols + j + jj);\n                        int16x8_t row3 = vld1q_s16(src + (i + ii + 3) * cols + j + jj);\n                        int16x8_t row4 = vld1q_s16(src + (i + ii + 4) * cols + j + jj);\n                        int16x8_t row5 = vld1q_s16(src + (i + ii + 5) * cols + j + jj);\n                        int16x8_t row6 = vld1q_s16(src + (i + ii + 6) * cols + j + jj);\n                        int16x8_t row7 = vld1q_s16(src + (i + ii + 7) * cols + j + jj);\n\n                        int16x8x2_t b0 = vtrnq_s16(row0, row1);\n                        int16x8x2_t b1 = vtrnq_s16(row2, row3);\n                        int16x8x2_t b2 = vtrnq_s16(row4, row5);\n                        int16x8x2_t b3 = vtrnq_s16(row6, row7);\n\n                        int32x4x2_t c0 = vtrnq_s32(vreinterpretq_s32_s16(b0.val[0]), vreinterpretq_s32_s16(b1.val[0]));\n                        int32x4x2_t c1 = vtrnq_s32(vreinterpretq_s32_s16(b0.val[1]), vreinterpretq_s32_s16(b1.val[1]));\n                        int32x4x2_t c2 = vtrnq_s32(vreinterpretq_s32_s16(b2.val[0]), vreinterpretq_s32_s16(b3.val[0]));\n                        int32x4x2_t c3 = vtrnq_s32(vreinterpretq_s32_s16(b2.val[1]), vreinterpretq_s32_s16(b3.val[1]));\n\n                        int16x8_t a0 = vreinterpretq_s16_s32(c0.val[0]);\n                        int16x8_t a1 = vreinterpretq_s16_s32(c2.val[0]);\n                        int16x8_t a2 = vreinterpretq_s16_s32(c0.val[1]);\n                        int16x8_t a3 = vreinterpretq_s16_s32(c2.val[1]);\n                        int16x8_t a4 = vreinterpretq_s16_s32(c1.val[0]);\n                        int16x8_t a5 = vreinterpretq_s16_s32(c3.val[0]);\n                        int16x8_t a6 = vreinterpretq_s16_s32(c1.val[1]);\n                        int16x8_t a7 = vreinterpretq_s16_s32(c3.val[1]);\n\n                        vst1q_s16(dst + (j + jj) * rows + i + ii, a0);\n                        vst1q_s16(dst + (j + jj + 1) * rows + i + ii, a1);\n                        vst1q_s16(dst + (j + jj + 2) * rows + i + ii, a2);\n                        vst1q_s16(dst + (j + jj + 3) * rows + i + ii, a3);\n                        vst1q_s16(dst + (j + jj + 4) * rows + i + ii, a4);\n                        vst1q_s16(dst + (j + jj + 5) * rows + i + ii, a5);\n                        vst1q_s16(dst + (j + jj + 6) * rows + i + ii, a6);\n                        vst1q_s16(dst + (j + jj + 7) * rows + i + ii, a7);\n                    } else {\n                        for (size_t y = 0; y < chunk_height; y++) {\n                            for (size_t x = 0; x < chunk_width; x++) {\n                                dst[(j + jj + x) * rows + (i + ii + y)] = src[(i + ii + y) * cols + (j + jj + x)];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_block_end = i + block_size;\n        if (i_block_end > rows) i_block_end = rows;\n        \n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_block_end = j + block_size;\n            if (j_block_end > cols) j_block_end = cols;\n            \n            for (size_t bi = i; bi < i_block_end; bi += 8) {\n                size_t micro_i = bi;\n                size_t micro_i_end = (bi + 8 < i_block_end) ? bi + 8 : i_block_end;\n                size_t micro_rows = micro_i_end - micro_i;\n                \n                for (size_t bj = j; bj < j_block_end; bj += 8) {\n                    size_t micro_j = bj;\n                    size_t micro_j_end = (bj + 8 < j_block_end) ? bj + 8 : j_block_end;\n                    size_t micro_cols = micro_j_end - micro_j;\n                    \n                    if (micro_rows == 8 && micro_cols == 8) {\n                        const int16_t *src_row0 = src + micro_i * cols + micro_j;\n                        const int16_t *src_row1 = src_row0 + cols;\n                        const int16_t *src_row2 = src_row1 + cols;\n                        const int16_t *src_row3 = src_row2 + cols;\n                        const int16_t *src_row4 = src_row3 + cols;\n                        const int16_t *src_row5 = src_row4 + cols;\n                        const int16_t *src_row6 = src_row5 + cols;\n                        const int16_t *src_row7 = src_row6 + cols;\n                        \n                        int16x8_t row0 = vld1q_s16(src_row0);\n                        int16x8_t row1 = vld1q_s16(src_row1);\n                        int16x8_t row2 = vld1q_s16(src_row2);\n                        int16x8_t row3 = vld1q_s16(src_row3);\n                        int16x8_t row4 = vld1q_s16(src_row4);\n                        int16x8_t row5 = vld1q_s16(src_row5);\n                        int16x8_t row6 = vld1q_s16(src_row6);\n                        int16x8_t row7 = vld1q_s16(src_row7);\n                        \n                        int16x8x2_t tmp0 = vtrnq_s16(row0, row1);\n                        int16x8x2_t tmp1 = vtrnq_s16(row2, row3);\n                        int16x8x2_t tmp2 = vtrnq_s16(row4, row5);\n                        int16x8x2_t tmp3 = vtrnq_s16(row6, row7);\n                        \n                        int32x4x2_t u0 = vtrnq_s32(vreinterpretq_s32_s16(tmp0.val[0]), vreinterpretq_s32_s16(tmp1.val[0]));\n                        int32x4x2_t u1 = vtrnq_s32(vreinterpretq_s32_s16(tmp0.val[1]), vreinterpretq_s32_s16(tmp1.val[1]));\n                        int32x4x2_t u2 = vtrnq_s32(vreinterpretq_s32_s16(tmp2.val[0]), vreinterpretq_s32_s16(tmp3.val[0]));\n                        int32x4x2_t u3 = vtrnq_s32(vreinterpretq_s32_s16(tmp2.val[1]), vreinterpretq_s32_s16(tmp3.val[1]));\n                        \n                        int64x2x2_t v0 = vtrnq_s64(vreinterpretq_s64_s32(u0.val[0]), vreinterpretq_s64_s32(u2.val[0]));\n                        int64x2x2_t v1 = vtrnq_s64(vreinterpretq_s64_s32(u0.val[1]), vreinterpretq_s64_s32(u2.val[1]));\n                        int64x2x2_t v2 = vtrnq_s64(vreinterpretq_s64_s32(u1.val[0]), vreinterpretq_s64_s32(u3.val[0]));\n                        int64x2x2_t v3 = vtrnq_s64(vreinterpretq_s64_s32(u1.val[1]), vreinterpretq_s64_s32(u3.val[1]));\n                        \n                        int16x8_t out0 = vreinterpretq_s16_s64(v0.val[0]);\n                        int16x8_t out1 = vreinterpretq_s16_s64(v2.val[0]);\n                        int16x8_t out2 = vreinterpretq_s16_s64(v0.val[1]);\n                        int16x8_t out3 = vreinterpretq_s16_s64(v2.val[1]);\n                        int16x8_t out4 = vreinterpretq_s16_s64(v1.val[0]);\n                        int16x8_t out5 = vreinterpretq_s16_s64(v3.val[0]);\n                        int16x8_t out6 = vreinterpretq_s16_s64(v1.val[1]);\n                        int16x8_t out7 = vreinterpretq_s16_s64(v3.val[1]);\n                        \n                        vst1q_s16(dst + micro_j * rows + micro_i, out0);\n                        vst1q_s16(dst + (micro_j + 1) * rows + micro_i, out1);\n                        vst1q_s16(dst + (micro_j + 2) * rows + micro_i, out2);\n                        vst1q_s16(dst + (micro_j + 3) * rows + micro_i, out3);\n                        vst1q_s16(dst + (micro_j + 4) * rows + micro_i, out4);\n                        vst1q_s16(dst + (micro_j + 5) * rows + micro_i, out5);\n                        vst1q_s16(dst + (micro_j + 6) * rows + micro_i, out6);\n                        vst1q_s16(dst + (micro_j + 7) * rows + micro_i, out7);\n                    } else {\n                        for (size_t r = 0; r < micro_rows; r++) {\n                            for (size_t c = 0; c < micro_cols; c++) {\n                                dst[(micro_j + c) * rows + micro_i + r] = src[(micro_i + r) * cols + micro_j + c];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_end = i + block_size;\n        if (i_end > rows) i_end = rows;\n\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_end = j + block_size;\n            if (j_end > cols) j_end = cols;\n\n            for (size_t ii = i; ii < i_end; ii += 8) {\n                size_t ii8_end = ii + 8;\n                if (ii8_end > i_end) ii8_end = i_end;\n\n                for (size_t jj = j; jj < j_end; jj += 8) {\n                    size_t jj8_end = jj + 8;\n                    if (jj8_end > j_end) jj8_end = j_end;\n\n                    if ((ii8_end - ii == 8) && (jj8_end - jj == 8)) {\n                        int16x8_t row0 = vld1q_s16(src + (ii + 0) * cols + jj);\n                        int16x8_t row1 = vld1q_s16(src + (ii + 1) * cols + jj);\n                        int16x8_t row2 = vld1q_s16(src + (ii + 2) * cols + jj);\n                        int16x8_t row3 = vld1q_s16(src + (ii + 3) * cols + jj);\n                        int16x8_t row4 = vld1q_s16(src + (ii + 4) * cols + jj);\n                        int16x8_t row5 = vld1q_s16(src + (ii + 5) * cols + jj);\n                        int16x8_t row6 = vld1q_s16(src + (ii + 6) * cols + jj);\n                        int16x8_t row7 = vld1q_s16(src + (ii + 7) * cols + jj);\n\n                        int16x8x2_t tr01 = vtrnq_s16(row0, row1);\n                        int16x8x2_t tr23 = vtrnq_s16(row2, row3);\n                        int16x8x2_t tr45 = vtrnq_s16(row4, row5);\n                        int16x8x2_t tr67 = vtrnq_s16(row6, row7);\n\n                        row0 = tr01.val[0];\n                        row1 = tr01.val[1];\n                        row2 = tr23.val[0];\n                        row3 = tr23.val[1];\n                        row4 = tr45.val[0];\n                        row5 = tr45.val[1];\n                        row6 = tr67.val[0];\n                        row7 = tr67.val[1];\n\n                        int32x4x2_t tr02 = vtrnq_s32(vreinterpretq_s32_s16(row0), vreinterpretq_s32_s16(row2));\n                        int32x4x2_t tr13 = vtrnq_s32(vreinterpretq_s32_s16(row1), vreinterpretq_s32_s16(row3));\n                        int32x4x2_t tr46 = vtrnq_s32(vreinterpretq_s32_s16(row4), vreinterpretq_s32_s16(row6));\n                        int32x4x2_t tr57 = vtrnq_s32(vreinterpretq_s32_s16(row5), vreinterpretq_s32_s16(row7));\n\n                        row0 = vreinterpretq_s16_s32(tr02.val[0]);\n                        row2 = vreinterpretq_s16_s32(tr02.val[1]);\n                        row1 = vreinterpretq_s16_s32(tr13.val[0]);\n                        row3 = vreinterpretq_s16_s32(tr13.val[1]);\n                        row4 = vreinterpretq_s16_s32(tr46.val[0]);\n                        row6 = vreinterpretq_s16_s32(tr46.val[1]);\n                        row5 = vreinterpretq_s16_s32(tr57.val[0]);\n                        row7 = vreinterpretq_s16_s32(tr57.val[1]);\n\n                        int64x2x2_t tr04 = vtrnq_s64(vreinterpretq_s64_s16(row0), vreinterpretq_s64_s16(row4));\n                        int64x2x2_t tr15 = vtrnq_s64(vreinterpretq_s64_s16(row1), vreinterpretq_s64_s16(row5));\n                        int64x2x2_t tr26 = vtrnq_s64(vreinterpretq_s64_s16(row2), vreinterpretq_s64_s16(row6));\n                        int64x2x2_t tr37 = vtrnq_s64(vreinterpretq_s64_s16(row3), vreinterpretq_s64_s16(row7));\n\n                        row0 = vreinterpretq_s16_s64(tr04.val[0]);\n                        row4 = vreinterpretq_s16_s64(tr04.val[1]);\n                        row1 = vreinterpretq_s16_s64(tr15.val[0]);\n                        row5 = vreinterpretq_s16_s64(tr15.val[1]);\n                        row2 = vreinterpretq_s16_s64(tr26.val[0]);\n                        row6 = vreinterpretq_s16_s64(tr26.val[1]);\n                        row3 = vreinterpretq_s16_s64(tr37.val[0]);\n                        row7 = vreinterpretq_s16_s64(tr37.val[1]);\n\n                        vst1q_s16(dst + (jj + 0) * rows + ii, row0);\n                        vst1q_s16(dst + (jj + 1) * rows + ii, row1);\n                        vst1q_s16(dst + (jj + 2) * rows + ii, row2);\n                        vst1q_s16(dst + (jj + 3) * rows + ii, row3);\n                        vst1q_s16(dst + (jj + 4) * rows + ii, row4);\n                        vst1q_s16(dst + (jj + 5) * rows + ii, row5);\n                        vst1q_s16(dst + (jj + 6) * rows + ii, row6);\n                        vst1q_s16(dst + (jj + 7) * rows + ii, row7);\n                    } else {\n                        for (size_t k = ii; k < ii8_end; k++) {\n                            for (size_t l = jj; l < jj8_end; l++) {\n                                dst[l * rows + k] = src[k * cols + l];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_end = i + block_size;\n        if (i_end > rows) i_end = rows;\n        size_t current_block_rows = i_end - i;\n\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_end = j + block_size;\n            if (j_end > cols) j_end = cols;\n            size_t current_block_cols = j_end - j;\n\n            for (size_t inner_i = 0; inner_i < current_block_rows; inner_i += 8) {\n                size_t inner_rows = (current_block_rows - inner_i) < 8 ? current_block_rows - inner_i : 8;\n\n                for (size_t inner_j = 0; inner_j < current_block_cols; inner_j += 8) {\n                    size_t inner_cols = (current_block_cols - inner_j) < 8 ? current_block_cols - inner_j : 8;\n\n                    if (inner_rows == 8 && inner_cols == 8) {\n                        const int16_t *src_block = src + (i + inner_i) * cols + j + inner_j;\n                        int16_t *dst_block = dst + (j + inner_j) * rows + i + inner_i;\n\n                        int16x8_t row0 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row1 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row2 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row3 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row4 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row5 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row6 = vld1q_s16(src_block); src_block += cols;\n                        int16x8_t row7 = vld1q_s16(src_block);\n\n                        int16x8x2_t temp0 = vtrnq_s16(row0, row1);\n                        int16x8x2_t temp1 = vtrnq_s16(row2, row3);\n                        int16x8x2_t temp2 = vtrnq_s16(row4, row5);\n                        int16x8x2_t temp3 = vtrnq_s16(row6, row7);\n\n                        row0 = temp0.val[0]; row1 = temp0.val[1];\n                        row2 = temp1.val[0]; row3 = temp1.val[1];\n                        row4 = temp2.val[0]; row5 = temp2.val[1];\n                        row6 = temp3.val[0]; row7 = temp3.val[1];\n\n                        int32x4x2_t temp4 = vtrnq_s32(vreinterpretq_s32_s16(row0), vreinterpretq_s32_s16(row2));\n                        int32x4x2_t temp5 = vtrnq_s32(vreinterpretq_s32_s16(row1), vreinterpretq_s32_s16(row3));\n                        int32x4x2_t temp6 = vtrnq_s32(vreinterpretq_s32_s16(row4), vreinterpretq_s32_s16(row6));\n                        int32x4x2_t temp7 = vtrnq_s32(vreinterpretq_s32_s16(row5), vreinterpretq_s32_s16(row7));\n\n                        row0 = vreinterpretq_s16_s32(temp4.val[0]);\n                        row2 = vreinterpretq_s16_s32(temp4.val[1]);\n                        row1 = vreinterpretq_s16_s32(temp5.val[0]);\n                        row3 = vreinterpretq_s16_s32(temp5.val[1]);\n                        row4 = vreinterpretq_s16_s32(temp6.val[0]);\n                        row6 = vreinterpretq_s16_s32(temp6.val[1]);\n                        row5 = vreinterpretq_s16_s32(temp7.val[0]);\n                        row7 = vreinterpretq_s16_s32(temp7.val[1]);\n\n                        int64x2x2_t temp8 = vtrnq_s64(vreinterpretq_s64_s16(row0), vreinterpretq_s64_s16(row4));\n                        int64x2x2_t temp9 = vtrnq_s64(vreinterpretq_s64_s16(row1), vreinterpretq_s64_s16(row5));\n                        int64x2x2_t temp10 = vtrnq_s64(vreinterpretq_s64_s16(row2), vreinterpretq_s64_s16(row6));\n                        int64x2x2_t temp11 = vtrnq_s64(vreinterpretq_s64_s16(row3), vreinterpretq_s64_s16(row7));\n\n                        row0 = vreinterpretq_s16_s64(temp8.val[0]);\n                        row4 = vreinterpretq_s16_s64(temp8.val[1]);\n                        row1 = vreinterpretq_s16_s64(temp9.val[0]);\n                        row5 = vreinterpretq_s16_s64(temp9.val[1]);\n                        row2 = vreinterpretq_s16_s64(temp10.val[0]);\n                        row6 = vreinterpretq_s16_s64(temp10.val[1]);\n                        row3 = vreinterpretq_s16_s64(temp11.val[0]);\n                        row7 = vreinterpretq_s16_s64(temp11.val[1]);\n\n                        vst1q_s16(dst_block, row0);\n                        vst1q_s16(dst_block + rows, row1);\n                        vst1q_s16(dst_block + 2 * rows, row2);\n                        vst1q_s16(dst_block + 3 * rows, row3);\n                        vst1q_s16(dst_block + 4 * rows, row4);\n                        vst1q_s16(dst_block + 5 * rows, row5);\n                        vst1q_s16(dst_block + 6 * rows, row6);\n                        vst1q_s16(dst_block + 7 * rows, row7);\n                    } else {\n                        for (size_t ii = 0; ii < inner_rows; ii++) {\n                            for (size_t jj = 0; jj < inner_cols; jj++) {\n                                dst[(j + inner_j + jj) * rows + (i + inner_i + ii)] = \n                                    src[(i + inner_i + ii) * cols + (j + inner_j + jj)];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_end = i + block_size;\n        if (i_end > rows) i_end = rows;\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_end = j + block_size;\n            if (j_end > cols) j_end = cols;\n            size_t block_rows = i_end - i;\n            size_t block_cols = j_end - j;\n\n            size_t i_inner_end = i + (block_rows & ~7);\n            size_t j_inner_end = j + (block_cols & ~7);\n\n            for (size_t ii = i; ii < i_inner_end; ii += 8) {\n                for (size_t jj = j; jj < j_inner_end; jj += 8) {\n                    int16_t temp_in[8][8];\n                    int16_t temp_out[8][8];\n                    for (int k = 0; k < 8; k++) {\n                        vst1q_s16(temp_in[k], vld1q_s16(src + (ii + k) * cols + jj));\n                    }\n                    for (int k = 0; k < 8; k++) {\n                        for (int l = 0; l < 8; l++) {\n                            temp_out[l][k] = temp_in[k][l];\n                        }\n                    }\n                    for (int l = 0; l < 8; l++) {\n                        vst1q_s16(dst + (jj + l) * rows + ii, vld1q_s16(temp_out[l]));\n                    }\n                }\n            }\n            for (size_t ii = i; ii < i_inner_end; ii++) {\n                for (size_t jj = j_inner_end; jj < j_end; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n            for (size_t ii = i_inner_end; ii < i_end; ii++) {\n                for (size_t jj = j; jj < j_end; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    size_t step = dim * dim + dim + 1;\n    float32x4_t vacc = vdupq_n_f32(0.0f);\n    size_t i = 0;\n\n    for (; i + 4 <= dim; i += 4) {\n        float32x4_t v0 = vdupq_n_f32(0.0f);\n        v0 = vsetq_lane_f32(array[i * step], v0, 0);\n        v0 = vsetq_lane_f32(array[(i + 1) * step], v0, 1);\n        v0 = vsetq_lane_f32(array[(i + 2) * step], v0, 2);\n        v0 = vsetq_lane_f32(array[(i + 3) * step], v0, 3);\n        vacc = vaddq_f32(vacc, v0);\n    }\n\n    float32x2_t vlow = vget_low_f32(vacc);\n    float32x2_t vhigh = vget_high_f32(vacc);\n    float32x2_t vsum = vadd_f32(vlow, vhigh);\n    vsum = vpadd_f32(vsum, vsum);\n    float sum = vget_lane_f32(vsum, 0);\n\n    for (; i < dim; ++i) {\n        sum += array[i * step];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    size_t step = dim * dim + dim + 1;\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t i = 0;\n\n    for (; i + 4 <= dim; i += 4) {\n        float32x4_t v = vdupq_n_f32(0.0f);\n        v = vld1q_lane_f32(array + i * step, v, 0);\n        v = vld1q_lane_f32(array + (i + 1) * step, v, 1);\n        v = vld1q_lane_f32(array + (i + 2) * step, v, 2);\n        v = vld1q_lane_f32(array + (i + 3) * step, v, 3);\n        sum_vec = vaddq_f32(sum_vec, v);\n    }\n\n    float32x2_t low = vget_low_f32(sum_vec);\n    float32x2_t high = vget_high_f32(sum_vec);\n    float32x2_t sum2 = vadd_f32(low, high);\n    sum2 = vpadd_f32(sum2, sum2);\n    float sum = vget_lane_f32(sum2, 0);\n\n    for (; i < dim; ++i) {\n        sum += array[i * step];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    \n    size_t step = dim * dim + dim + 1;\n    float32x4_t sum_vec = vdupq_n_f32(0.0f);\n    size_t x = 0;\n\n    for (; x + 3 < dim; x += 4) {\n        float32x4_t v = vdupq_n_f32(0.0f);\n        v = vsetq_lane_f32(array[x * step], v, 0);\n        v = vsetq_lane_f32(array[(x + 1) * step], v, 1);\n        v = vsetq_lane_f32(array[(x + 2) * step], v, 2);\n        v = vsetq_lane_f32(array[(x + 3) * step], v, 3);\n        sum_vec = vaddq_f32(sum_vec, v);\n    }\n\n    float32x2_t low = vget_low_f32(sum_vec);\n    float32x2_t high = vget_high_f32(sum_vec);\n    float32x2_t sum_pair = vadd_f32(low, high);\n    sum_pair = vpadd_f32(sum_pair, sum_pair);\n    float sum = vget_lane_f32(sum_pair, 0);\n\n    for (; x < dim; x++) {\n        sum += array[x * step];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```c\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    size_t step = dim * dim + dim + 1;\n    float total = 0.0f;\n    float32x4_t accum = vdupq_n_f32(0.0f);\n    size_t i = 0;\n\n    for (; i + 3 < dim; i += 4) {\n        float32x4_t v = {\n            array[i * step],\n            array[(i + 1) * step],\n            array[(i + 2) * step],\n            array[(i + 3) * step]\n        };\n        accum = vaddq_f32(accum, v);\n    }\n\n    float32x2_t lo = vget_low_f32(accum);\n    float32x2_t hi = vget_high_f32(accum);\n    lo = vadd_f32(lo, hi);\n    lo = vpadd_f32(lo, lo);\n    total = vget_lane_f32(lo, 0);\n\n    for (; i < dim; i++) {\n        total += array[i * step];\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_7_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    size_t stride = dim * dim + dim + 1;\n    float32x4_t vsum = vdupq_n_f32(0.0f);\n    size_t i = 0;\n\n    for (; i + 4 <= dim; i += 4) {\n        float32x4_t v = {\n            array[i * stride],\n            array[(i + 1) * stride],\n            array[(i + 2) * stride],\n            array[(i + 3) * stride]\n        };\n        vsum = vaddq_f32(vsum, v);\n    }\n\n    float sum = vaddvq_f32(vsum);\n\n    for (; i < dim; i++) {\n        sum += array[i * stride];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    const float64x2_t threshold_vec = vdupq_n_f64(threshold);\n    const float64x2_t scale_vec = vdupq_n_f64(scale);\n    \n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t src_vec = vld1q_f64(src + i);\n        uint64x2_t mask = vcgtq_f64(src_vec, threshold_vec);\n        float64x2_t scaled_vec = vmulq_f64(src_vec, scale_vec);\n        float64x2_t res_vec = vbslq_f64(mask, scaled_vec, src_vec);\n        vst1q_f64(dst + i, res_vec);\n    }\n    \n    if (i < total_elements) {\n        double val = src[i];\n        dst[i] = (val > threshold) ? val * scale : val;\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n    size_t i = 0;\n\n    for (; i <= total - 2; i += 2) {\n        float64x2_t v_src = vld1q_f64(src + i);\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        float64x2_t v_dst = vbslq_f64(v_mask, v_scaled, v_src);\n        vst1q_f64(dst + i, v_dst);\n    }\n\n    for (; i < total; i++) {\n        double val = src[i];\n        dst[i] = (val > threshold) ? val * scale : val;\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    // Broadcast threshold and scale to vectors\n    float64x2_t v_threshold = vdupq_n_f64(threshold);\n    float64x2_t v_scale = vdupq_n_f64(scale);\n    \n    size_t total_elements = rows * cols;\n    size_t i = 0;\n\n    // Process two elements at a time using NEON\n    for (; i + 1 < total_elements; i += 2) {\n        // Load two doubles\n        float64x2_t v_src = vld1q_f64(src + i);\n        // Compare: greater than threshold\n        uint64x2_t v_mask = vcgtq_f64(v_src, v_threshold);\n        // Compute scaled values\n        float64x2_t v_scaled = vmulq_f64(v_src, v_scale);\n        // Select: scaled where mask is true, original otherwise\n        float64x2_t v_result = vbslq_f64(v_mask, v_scaled, v_src);\n        // Store result\n        vst1q_f64(dst + i, v_result);\n    }\n\n    // Process remaining single element (if total elements is odd)\n    if (i < total_elements) {\n        double val = src[i];\n        dst[i] = (val > threshold) ? val * scale : val;\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    float64x2_t thresh_vec = vdupq_n_f64(threshold);\n    float64x2_t scale_vec = vdupq_n_f64(scale);\n    \n    for (size_t i = 0; i < rows; i++) {\n        const double *src_row = src + i * cols;\n        double *dst_row = dst + i * cols;\n        size_t j = 0;\n        \n        for (; j + 1 < cols; j += 2) {\n            float64x2_t data = vld1q_f64(src_row + j);\n            uint64x2_t mask = vcgtq_f64(data, thresh_vec);\n            float64x2_t scaled = vmulq_f64(data, scale_vec);\n            float64x2_t res = vbslq_f64(mask, scaled, data);\n            vst1q_f64(dst_row + j, res);\n        }\n        \n        for (; j < cols; j++) {\n            double val = src_row[j];\n            dst_row[j] = (val > threshold) ? val * scale : val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t num_elements = rows * cols;\n    size_t i = 0;\n    \n    float64x2_t vthreshold = vdupq_n_f64(threshold);\n    float64x2_t vscale = vdupq_n_f64(scale);\n    \n    for (; i + 1 < num_elements; i += 2) {\n        float64x2_t vsrc = vld1q_f64(src + i);\n        uint64x2_t mask = vcgtq_f64(vsrc, vthreshold);\n        float64x2_t vscaled = vmulq_f64(vsrc, vscale);\n        float64x2_t vdst = vbslq_f64(mask, vscaled, vsrc);\n        vst1q_f64(dst + i, vdst);\n    }\n    \n    if (i < num_elements) {\n        double val = src[i];\n        dst[i] = (val > threshold) ? val * scale : val;\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        const double *src_row = src + indices[i] * cols;\n        double *dst_row = dst + i * cols;\n        size_t j = 0;\n        for (; j + 3 < cols; j += 4) {\n            float64x2_t v0 = vld1q_f64(src_row + j);\n            float64x2_t v1 = vld1q_f64(src_row + j + 2);\n            vst1q_f64(dst_row + j, v0);\n            vst1q_f64(dst_row + j + 2, v1);\n        }\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t v = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, v);\n        }\n        if (j < cols) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        const size_t src_row_idx = indices[i];\n        const double *src_row = src + src_row_idx * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        const size_t num_vec_loops = cols / 2;\n        \n        for (size_t k = 0; k < num_vec_loops; k++) {\n            float64x2_t row_data = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, row_data);\n            j += 2;\n        }\n        \n        if (cols & 1) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double *src_row = src + indices[i] * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j + 2 <= cols; j += 2) {\n            float64x2_t data = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, data);\n        }\n        if (j < cols) {\n            float64x1_t last = vld1_f64(src_row + j);\n            vst1_f64(dst_row + j, last);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        const double *src_row = src + indices[i] * cols;\n        double *dst_row = dst + i * cols;\n        size_t j = 0;\n        size_t end = cols & ~(size_t)1;\n        for (; j < end; j += 2) {\n            float64x2_t data = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, data);\n        }\n        if (j < cols) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; ++i) {\n        size_t src_row_index = indices[i];\n        const double *src_row = src + src_row_index * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t j = 0;\n        for (; j + 3 < cols; j += 4) {\n            float64x2_t vec0 = vld1q_f64(src_row + j);\n            float64x2_t vec1 = vld1q_f64(src_row + j + 2);\n            vst1q_f64(dst_row + j, vec0);\n            vst1q_f64(dst_row + j + 2, vec1);\n        }\n        \n        for (; j + 1 < cols; j += 2) {\n            float64x2_t vec = vld1q_f64(src_row + j);\n            vst1q_f64(dst_row + j, vec);\n        }\n        \n        if (j < cols) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    // Broadcast scalar to a vector\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    \n    // Calculate how many elements we can process in vectors (2 per iteration)\n    size_t i = 0;\n    size_t vec_len = length & ~1;\n    \n    for (; i < vec_len; i += 2) {\n        // Load two elements from each source array\n        int64x2_t v_src1 = vld1q_s64(src1 + i);\n        int64x2_t v_src2 = vld1q_s64(src2 + i);\n        \n        // Compute: tmp = (src1 + src2 + scalar)\n        int64x2_t v_tmp = vaddq_s64(vaddq_s64(v_src1, v_src2), v_scalar);\n        \n        // Compute adjustment mask for truncating division by 2\n        int64x2_t v_shifted = vshrq_n_s64(v_tmp, 1);\n        int64x2_t is_negative = vcltq_s64(v_tmp, vdupq_n_s64(0));\n        int64x2_t is_odd = vandq_s64(v_tmp, vdupq_n_s64(1));\n        int64x2_t adjustment = vandq_s64(is_negative, is_odd);\n        int64x2_t v_result = vaddq_s64(v_shifted, adjustment);\n        \n        // Store the result\n        vst1q_s64(dst + i, v_result);\n    }\n    \n    // Process remaining elements (if any)\n    for (; i < length; i++) {\n        int64_t tmp = src1[i] + src2[i] + scalar;\n        dst[i] = tmp / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    size_t i = 0;\n\n    for (; i + 1 < length; i += 2) {\n        int64x2_t v1 = vld1q_s64(src1 + i);\n        int64x2_t v2 = vld1q_s64(src2 + i);\n        int64x2_t v_sum = vaddq_s64(v1, v2);\n        int64x2_t v_total = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_mask = vshrq_n_s64(v_total, 63);\n        int64x2_t v_adjusted = vsubq_s64(v_total, v_mask);\n        int64x2_t v_result = vshrq_n_s64(v_adjusted, 1);\n        vst1q_s64(dst + i, v_result);\n    }\n\n    for (; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        int64_t mask = sum >> 63;\n        int64_t adjusted = sum - mask;\n        dst[i] = adjusted >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t v_scalar = vdupq_n_s64(scalar);\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        int64x2_t v1 = vld1q_s64(src1 + i);\n        int64x2_t v2 = vld1q_s64(src2 + i);\n        int64x2_t v_sum = vaddq_s64(v1, v2);\n        int64x2_t v_total = vaddq_s64(v_sum, v_scalar);\n        int64x2_t v_mask = vshrq_n_s64(v_total, 63);\n        int64x2_t v_adjusted = vsubq_s64(v_total, v_mask);\n        int64x2_t v_result = vshrq_n_s64(v_adjusted, 1);\n        vst1q_s64(dst + i, v_result);\n    }\n    for (; i < length; i++) {\n        int64_t total = src1[i] + src2[i] + scalar;\n        int64_t mask = total >> 63;\n        dst[i] = (total - mask) >> 1;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i = 0;\n    const size_t step = 2;\n\n    for (; i + step <= length; i += step) {\n        int64x2_t a = vld1q_s64(src1 + i);\n        int64x2_t b = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(a, b);\n        int64x2_t temp = vaddq_s64(sum, scalar_vec);\n\n        int64x2_t low_bits = vandq_s64(temp, vdupq_n_s64(1));\n        int64x2_t sign_mask = vshrq_n_s64(temp, 63);\n        int64x2_t adjustment = vandq_s64(low_bits, sign_mask);\n        int64x2_t shifted = vshrq_n_s64(temp, 1);\n        int64x2_t result = vaddq_s64(shifted, adjustment);\n\n        vst1q_s64(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        int64_t temp = src1[i] + src2[i] + scalar;\n        dst[i] = temp / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    int64x2_t scalar_vec = vdupq_n_s64(scalar);\n    size_t i = 0;\n    \n    for (; i + 1 < length; i += 2) {\n        int64x2_t v1 = vld1q_s64(src1 + i);\n        int64x2_t v2 = vld1q_s64(src2 + i);\n        int64x2_t sum = vaddq_s64(v1, v2);\n        int64x2_t tmp = vaddq_s64(sum, scalar_vec);\n        uint64x2_t u_tmp = vreinterpretq_u64_s64(tmp);\n        uint64x2_t sign_mask = vshrq_n_u64(u_tmp, 63);\n        int64x2_t adjusted = vaddq_s64(tmp, vreinterpretq_s64_u64(sign_mask));\n        int64x2_t res = vshrq_n_s64(adjusted, 1);\n        vst1q_s64(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        int64_t sum = src1[i] + src2[i] + scalar;\n        if (sum < 0) {\n            dst[i] = (sum + 1) / 2;\n        } else {\n            dst[i] = sum / 2;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT32_MAX);\n    size_t i = 0;\n\n    for (; i + 8 <= length; i += 8) {\n        int32x4_t a = vld1q_s32(src + i);\n        int32x4_t b = vld1q_s32(src + i + 4);\n        \n        int32x2x2_t unzipped_a = vuzp_s32(vget_low_s32(a), vget_high_s32(a));\n        int32x2x2_t unzipped_b = vuzp_s32(vget_low_s32(b), vget_high_s32(b));\n        \n        int32x4_t even_reg = vcombine_s32(unzipped_a.val[0], unzipped_b.val[0]);\n        min_vec = vminq_s32(min_vec, even_reg);\n    }\n\n    int32_t min_val;\n#if defined(__aarch64__)\n    min_val = vminvq_s32(min_vec);\n#else\n    int32x2_t low_min = vpmin_s32(vget_low_s32(min_vec), vget_high_s32(min_vec));\n    low_min = vpmin_s32(low_min, low_min);\n    min_val = vget_lane_s32(low_min, 0);\n#endif\n\n    int32_t min_remaining = INT32_MAX;\n    for (size_t j = i; j < length; j += 2) {\n        if (src[j] < min_remaining) {\n            min_remaining = src[j];\n        }\n    }\n\n    return (min_val < min_remaining) ? min_val : min_remaining;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int min_val = INT_MAX;\n    size_t i = 0;\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    \n    if (length >= 8) {\n        for (; i <= length - 8; i += 8) {\n            int32x4x2_t data = vld2q_s32(src + i);\n            min_vec = vminq_s32(min_vec, data.val[0]);\n        }\n        int32x2_t low = vget_low_s32(min_vec);\n        int32x2_t high = vget_high_s32(min_vec);\n        int32x2_t min_pair = vpmin_s32(low, high);\n        min_pair = vpmin_s32(min_pair, min_pair);\n        min_val = vget_lane_s32(min_pair, 0);\n    }\n    \n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n#include <stdint.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_vec = vdupq_n_s32(INT_MAX);\n    uint32x2_t mask_low = vcreate_u32(0x00000000FFFFFFFF);\n    uint32x4_t mask = vcombine_u32(mask_low, mask_low);\n    int32x4_t max_vec = vdupq_n_s32(INT_MAX);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t data = vld1q_s32(src + i);\n        int32x4_t selected = vbslq_s32(mask, data, max_vec);\n        min_vec = vminq_s32(min_vec, selected);\n    }\n\n    int32x2_t low = vget_low_s32(min_vec);\n    int32x2_t high = vget_high_s32(min_vec);\n    int32x2_t min2 = vpmin_s32(low, high);\n    min2 = vpmin_s32(min2, min2);\n    int min_val = vget_lane_s32(min2, 0);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    int32x2_t min_vec = vdup_n_s32(INT_MAX);\n    size_t i = 0;\n    \n    for (; i + 3 < length; i += 4) {\n        int32x4_t vec = vld1q_s32(src + i);\n        int32x2_t even = vget_low_s32(vec);\n        even = vset_lane_s32(vgetq_lane_s32(vec, 2), even, 1);\n        min_vec = vmin_s32(min_vec, even);\n    }\n    \n    int min_val = vget_lane_s32(min_vec, 0);\n    int min_val1 = vget_lane_s32(min_vec, 1);\n    if (min_val1 < min_val) {\n        min_val = min_val1;\n    }\n    \n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n\n    int32x4_t min_acc = vdupq_n_s32(INT_MAX);\n    size_t i = 0;\n\n    for (; i + 7 < length; i += 8) {\n        int32x4_t vec1 = vld1q_s32(src + i);\n        int32x4_t vec2 = vld1q_s32(src + i + 4);\n        uint32x4x2_t deinter = vuzpq_u32(vreinterpretq_u32_s32(vec1), vreinterpretq_u32_s32(vec2));\n        int32x4_t even_vec = vreinterpretq_s32_u32(deinter.val[0]);\n        min_acc = vminq_s32(min_acc, even_vec);\n    }\n\n    int32x2_t low = vget_low_s32(min_acc);\n    int32x2_t high = vget_high_s32(min_acc);\n    int32x2_t min2 = vpmin_s32(low, high);\n    min2 = vpmin_s32(min2, min2);\n    int min_val = vget_lane_s32(min2, 0);\n\n    for (; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    \n    if (length >= 4) {\n        int32x4_t neg_shift_vec = vdupq_n_s32(-(int32_t)shift);\n        for (; i <= length - 4; i += 4) {\n            int32x4_t vec = vld1q_s32(src + i);\n            int32x4_t arith = vshlq_s32(vec, neg_shift_vec);\n            uint32x4_t u_vec = vreinterpretq_u32_s32(vec);\n            uint32x4_t u_logical = vshlq_u32(u_vec, neg_shift_vec);\n            int32x4_t logical = vreinterpretq_s32_u32(u_logical);\n            int32x4_t res = vaddq_s32(arith, logical);\n            vst1q_s32(dst + i, res);\n        }\n    }\n    \n    for (; i < length; i++) {\n        int32_t val = src[i];\n        int32_t arith = (shift < 32) ? (val >> shift) : 0;\n        int32_t logical = (shift < 32) ? (int32_t)((uint32_t)val >> shift) : 0;\n        dst[i] = arith + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    if (shift == 0) {\n        for (size_t i = 0; i < length; i++) {\n            dst[i] = src[i] + src[i];\n        }\n        return;\n    }\n\n    uint8_t shift_val = shift & 31;\n    int32_t neg_shift = -(int32_t)shift_val;\n    int32x4_t shift_vec = vdupq_n_s32(neg_shift);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        int32x4_t data = vld1q_s32(src + i);\n        int32x4_t arith = vshlq_s32(data, shift_vec);\n        uint32x4_t u_data = vreinterpretq_u32_s32(data);\n        uint32x4_t u_logical = vshlq_u32(u_data, shift_vec);\n        int32x4_t logical = vreinterpretq_s32_u32(u_logical);\n        int32x4_t res = vaddq_s32(arith, logical);\n        vst1q_s32(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        int32_t val = src[i];\n        int32_t arith = val >> shift_val;\n        uint32_t u_val = (uint32_t)val;\n        uint32_t u_logical = u_val >> shift_val;\n        int32_t logical = (int32_t)u_logical;\n        dst[i] = arith + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    uint8_t safe_shift = shift & 0x1F;\n    int32_t neg_shift_val = -(int32_t)safe_shift;\n    int32x4_t neg_shift_vec = vdupq_n_s32(neg_shift_val);\n\n    size_t i = 0;\n    size_t vec_end = length & ~3;\n\n    for (; i < vec_end; i += 4) {\n        int32x4_t data = vld1q_s32(src + i);\n        int32x4_t arith = vshlq_s32(data, neg_shift_vec);\n        uint32x4_t u_data = vreinterpretq_u32_s32(data);\n        uint32x4_t u_logical = vshlq_u32(u_data, neg_shift_vec);\n        int32x4_t logical = vreinterpretq_s32_u32(u_logical);\n        int32x4_t sum = vaddq_s32(arith, logical);\n        vst1q_s32(dst + i, sum);\n    }\n\n    for (; i < length; i++) {\n        int32_t val = src[i];\n        int32_t arith = val >> safe_shift;\n        uint32_t u_val = (uint32_t)val;\n        int32_t logical = (int32_t)(u_val >> safe_shift);\n        dst[i] = arith + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    if (shift == 0) {\n        for (; i + 3 < length; i += 4) {\n            int32x4_t vec = vld1q_s32(src + i);\n            vec = vaddq_s32(vec, vec);\n            vst1q_s32(dst + i, vec);\n        }\n    } else if (shift < 32) {\n        int32x4_t shift_vec = vdupq_n_s32(-(int32_t)shift);\n        for (; i + 3 < length; i += 4) {\n            int32x4_t vec = vld1q_s32(src + i);\n            int32x4_t arith = vshlq_s32(vec, shift_vec);\n            uint32x4_t uvec = vreinterpretq_u32_s32(vec);\n            uint32x4_t ulogic = vshlq_u32(uvec, shift_vec);\n            int32x4_t logic = vreinterpretq_s32_u32(ulogic);\n            int32x4_t result = vaddq_s32(arith, logic);\n            vst1q_s32(dst + i, result);\n        }\n    } else {\n        for (; i + 3 < length; i += 4) {\n            int32x4_t vec = vld1q_s32(src + i);\n            int32x4_t arith = vshrq_n_s32(vec, 31);\n            vst1q_s32(dst + i, arith);\n        }\n    }\n    for (; i < length; i++) {\n        if (shift == 0) {\n            dst[i] = src[i] * 2;\n        } else if (shift < 32) {\n            int32_t arith = src[i] >> shift;\n            uint32_t uval = (uint32_t)src[i];\n            uint32_t lval = uval >> shift;\n            dst[i] = arith + (int32_t)lval;\n        } else {\n            dst[i] = (src[i] < 0) ? -1 : 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_12_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    const size_t neon_iters = length - (length % 4);\n\n    for (; i < neon_iters; i += 4) {\n        int32x4_t data = vld1q_s32(src + i);\n        \n        int32x4_t arith_shift = vshrq_n_s32(data, shift);\n        \n        uint32x4_t data_unsigned = vreinterpretq_u32_s32(data);\n        uint32x4_t logical_shift = vshrq_n_u32(data_unsigned, shift);\n        int32x4_t logical_shift_signed = vreinterpretq_s32_u32(logical_shift);\n        \n        int32x4_t result = vaddq_s32(arith_shift, logical_shift_signed);\n        vst1q_s32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        int32_t val = src[i];\n        int32_t arith = val >> shift;\n        int32_t logical = (uint32_t)val >> shift;\n        dst[i] = arith + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n    int64_t sum = 0;\n    int64x2_t acc = vdupq_n_s64(0);\n\n    for (; i + 3 < total; i += 4) {\n        int32x4_t v = vld1q_s32(matrix + i);\n        int32x2_t low = vget_low_s32(v);\n        int32x2_t high = vget_high_s32(v);\n        int64x2_t low64 = vmovl_s32(low);\n        int64x2_t high64 = vmovl_s32(high);\n        acc = vaddq_s64(acc, low64);\n        acc = vaddq_s64(acc, high64);\n    }\n\n    sum = vgetq_lane_s64(acc, 0) + vgetq_lane_s64(acc, 1);\n\n    for (; i < total; ++i) {\n        sum += matrix[i];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64x2_t sum64_vec = vdupq_n_s64(0);\n\n    for (; i + 3 < total_elements; i += 4) {\n        int32x4_t v = vld1q_s32(matrix + i);\n        sum64_vec = vpadalq_s32(sum64_vec, v);\n    }\n\n    int64_t vec_sum = vgetq_lane_s64(sum64_vec, 0) + vgetq_lane_s64(sum64_vec, 1);\n    int64_t tail_sum = 0;\n    for (; i < total_elements; i++) {\n        tail_sum += matrix[i];\n    }\n\n    return vec_sum + tail_sum;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    int64x2_t sum64 = vdupq_n_s64(0);\n\n    for (; i + 3 < total_elements; i += 4) {\n        int32x4_t v = vld1q_s32(matrix + i);\n        sum64 = vpadalq_s32(sum64, v);\n    }\n\n    int64_t result = vgetq_lane_s64(sum64, 0) + vgetq_lane_s64(sum64, 1);\n\n    for (; i < total_elements; ++i) {\n        result += matrix[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    if (total == 0) {\n        return 0;\n    }\n    const int *ptr = matrix;\n    int64x2_t sum64 = vdupq_n_s64(0);\n    size_t i = 0;\n\n    for (; i + 3 < total; i += 4) {\n        int32x4_t v = vld1q_s32(ptr);\n        ptr += 4;\n        int64x2_t low = vmovl_s32(vget_low_s32(v));\n        int64x2_t high = vmovl_s32(vget_high_s32(v));\n        sum64 = vaddq_s64(sum64, low);\n        sum64 = vaddq_s64(sum64, high);\n    }\n\n    int64_t result = vgetq_lane_s64(sum64, 0) + vgetq_lane_s64(sum64, 1);\n    for (; i < total; i++) {\n        result += *ptr++;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_13_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    const int32_t *data = matrix;\n    int64x2_t sum64 = vdupq_n_s64(0);\n    size_t i = 0;\n\n    for (; i + 3 < total; i += 4) {\n        int32x4_t v = vld1q_s32(data + i);\n        int64x2_t low = vmovl_s32(vget_low_s32(v));\n        int64x2_t high = vmovl_s32(vget_high_s32(v));\n        sum64 = vaddq_s64(sum64, low);\n        sum64 = vaddq_s64(sum64, high);\n    }\n\n    int64_t result = vgetq_lane_s64(sum64, 0) + vgetq_lane_s64(sum64, 1);\n\n    for (; i < total; i++) {\n        result += data[i];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    if (length < 16) {\n        int8_t max_val = src[0];\n        size_t max_index = 0;\n        for (size_t i = 1; i < length; i++) {\n            if (src[i] > max_val) {\n                max_val = src[i];\n                max_index = i;\n            }\n        }\n        return max_index;\n    }\n\n    static const uint32_t idx_init_data[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    uint32x4_t vindex_base0 = vld1q_u32(idx_init_data);\n    uint32x4_t vindex_base1 = vld1q_u32(idx_init_data + 4);\n    uint32x4_t vindex_base2 = vld1q_u32(idx_init_data + 8);\n    uint32x4_t vindex_base3 = vld1q_u32(idx_init_data + 12);\n\n    int8x16_t vmax = vld1q_s8(src);\n    uint32x4_t vidx0 = vindex_base0;\n    uint32x4_t vidx1 = vindex_base1;\n    uint32x4_t vidx2 = vindex_base2;\n    uint32x4_t vidx3 = vindex_base3;\n\n    size_t i = 16;\n    for (; i + 16 <= length; i += 16) {\n        size_t base = i;\n        int8x16_t v = vld1q_s8(src + base);\n        uint8x16_t cmp = vcgtq_s8(v, vmax);\n        vmax = vmaxq_s8(vmax, v);\n\n        uint32x4_t new_idx0 = vaddq_u32(vdupq_n_u32((uint32_t)base), vindex_base0);\n        uint32x4_t new_idx1 = vaddq_u32(vdupq_n_u32((uint32_t)base), vindex_base1);\n        uint32x4_t new_idx2 = vaddq_u32(vdupq_n_u32((uint32_t)base), vindex_base2);\n        uint32x4_t new_idx3 = vaddq_u32(vdupq_n_u32((uint32_t)base), vindex_base3);\n\n        uint8x8_t cmp_low = vget_low_u8(cmp);\n        uint8x8_t cmp_high = vget_high_u8(cmp);\n\n        uint16x8_t cmp_low16 = vmovl_u8(cmp_low);\n        uint16x8_t cmp_high16 = vmovl_u8(cmp_high);\n\n        uint32x4_t mask0 = vmovl_u16(vget_low_u16(cmp_low16));\n        uint32x4_t mask1 = vmovl_u16(vget_high_u16(cmp_low16));\n        uint32x4_t mask2 = vmovl_u16(vget_low_u16(cmp_high16));\n        uint32x4_t mask3 = vmovl_u16(vget_high_u16(cmp_high16));\n\n        vidx0 = vbslq_u32(mask0, new_idx0, vidx0);\n        vidx1 = vbslq_u32(mask1, new_idx1, vidx1);\n        vidx2 = vbslq_u32(mask2, new_idx2, vidx2);\n        vidx3 = vbslq_u32(mask3, new_idx3, vidx3);\n    }\n\n    int8_t max_arr[16];\n    uint32_t idx_arr[16];\n    vst1q_s8(max_arr, vmax);\n    vst1q_u32(idx_arr, vidx0);\n    vst1q_u32(idx_arr + 4, vidx1);\n    vst1q_u32(idx_arr + 8, vidx2);\n    vst1q_u32(idx_arr + 12, vidx3);\n\n    size_t best_index = idx_arr[0];\n    int8_t best_val = max_arr[0];\n    for (int j = 1; j < 16; j++) {\n        if (max_arr[j] > best_val) {\n            best_val = max_arr[j];\n            best_index = idx_arr[j];\n        } else if (max_arr[j] == best_val) {\n            if (idx_arr[j] < best_index) {\n                best_index = idx_arr[j];\n            }\n        }\n    }\n\n    for (size_t j = i; j < length; j++) {\n        if (src[j] > best_val) {\n            best_val = src[j];\n            best_index = j;\n        } else if (src[j] == best_val) {\n            if (j < best_index) {\n                best_index = j;\n            }\n        }\n    }\n\n    return best_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <limits.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t global_index = 0;\n    int8_t global_max = INT8_MIN;\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t vec = vld1q_s8(src + i);\n        int8_t max_in_chunk = vmaxvq_s8(vec);\n        if (max_in_chunk > global_max) {\n            global_max = max_in_chunk;\n            for (size_t j = 0; j < 16; ++j) {\n                if (src[i + j] == global_max) {\n                    global_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n    for (; i < length; ++i) {\n        if (src[i] > global_max) {\n            global_max = src[i];\n            global_index = i;\n        }\n    }\n    return global_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    int8_t global_max = INT8_MIN;\n    size_t global_idx = 0;\n    uint8_t index_arr[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    uint8x16_t vidx = vld1q_u8(index_arr);\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t chunk = vld1q_s8(src + i);\n        int8_t max_val = vmaxvq_s8(chunk);\n\n        if (max_val > global_max) {\n            global_max = max_val;\n            uint8x16_t mask = vceqq_s8(chunk, vdupq_n_s8(max_val));\n            uint8x16_t indices_masked = vbslq_u8(mask, vidx, vdupq_n_u8(16));\n            uint8_t min_index = vminvq_u8(indices_masked);\n            global_idx = i + min_index;\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > global_max) {\n            global_max = src[i];\n            global_idx = i;\n        }\n    }\n\n    return global_idx;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    size_t global_index = 0;\n    int8_t global_max = src[0];\n    static const uint8_t idx_arr[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};\n    uint8x16_t base_idx_vec = vld1q_u8(idx_arr);\n\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t data = vld1q_s8(src + i);\n        int8_t max_in_chunk = vmaxvq_s8(data);\n\n        if (max_in_chunk > global_max) {\n            global_max = max_in_chunk;\n            int8x16_t max_val_vec = vdupq_n_s8(max_in_chunk);\n            uint8x16_t mask = vceqq_s8(data, max_val_vec);\n            uint8x16_t candidate_indices = vbslq_u8(mask, base_idx_vec, vdupq_n_u8(0xFF));\n            uint8_t min_index = vminvq_u8(candidate_indices);\n            global_index = i + min_index;\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > global_max) {\n            global_max = src[i];\n            global_index = i;\n        }\n    }\n\n    return global_index;\n}\n```"}
{"task_id": "SimdBench_14_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n\n    int8_t global_max = src[0];\n    size_t global_index = 0;\n    size_t i = 0;\n\n    for (; i <= length - 16; i += 16) {\n        int8x16_t v_cur = vld1q_s8(src + i);\n        int8x16_t v_global = vdupq_n_s8(global_max);\n        uint8x16_t v_mask = vcgtq_s8(v_cur, v_global);\n\n        if (vmaxvq_u8(v_mask)) {\n            int8x8_t low = vget_low_s8(v_cur);\n            int8x8_t high = vget_high_s8(v_cur);\n            int8x8_t max8 = vmax_s8(low, high);\n            int8x8_t max4 = vpmax_s8(max8, max8);\n            int8x8_t max2 = vpmax_s8(max4, max4);\n            int8x8_t max1 = vpmax_s8(max2, max2);\n            int8_t chunk_max = vget_lane_s8(max1, 0);\n\n            global_max = chunk_max;\n\n            for (size_t j = 0; j < 16; j++) {\n                if (src[i + j] == chunk_max) {\n                    global_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    for (; i < length; i++) {\n        if (src[i] > global_max) {\n            global_max = src[i];\n            global_index = i;\n        }\n    }\n\n    return global_index;\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    uint32_t step_array[8] = {0,1,2,3,4,5,6,7};\n    uint32x4_t step_low = vld1q_u32(step_array);\n    uint32x4_t step_high = vld1q_u32(step_array + 4);\n    uint32x4_t mask_vec = vdupq_n_u32(mask);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        uint32x4_t base_vec = vdupq_n_u32(i);\n        uint32x4_t indices_low = vaddq_u32(base_vec, step_low);\n        uint32x4_t indices_high = vaddq_u32(base_vec, step_high);\n\n        uint32x4_t cond_low = vtstq_u32(indices_low, mask_vec);\n        uint32x4_t cond_high = vtstq_u32(indices_high, mask_vec);\n\n        uint16x4_t cond_low_16 = vmovn_u32(cond_low);\n        uint16x4_t cond_high_16 = vmovn_u32(cond_high);\n        uint16x8_t cond = vcombine_u16(cond_low_16, cond_high_16);\n\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n        uint16x8_t dst_vec = vbslq_u16(cond, src1_vec, src2_vec);\n        vst1q_u16(dst + i, dst_vec);\n    }\n\n    for (; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    if (length == 0) return;\n\n    uint32x4_t base_step_low = vmovq_n_u32(0);\n    base_step_low = vsetq_lane_u32(1, base_step_low, 1);\n    base_step_low = vsetq_lane_u32(2, base_step_low, 2);\n    base_step_low = vsetq_lane_u32(3, base_step_low, 3);\n    uint32x4_t base_step_high = vaddq_u32(base_step_low, vdupq_n_u32(4));\n    uint32x4_t mask_vec = vdupq_n_u32(mask);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        uint32x4_t base_vec = vdupq_n_u32((uint32_t)i);\n        uint32x4_t indices_low = vaddq_u32(base_vec, base_step_low);\n        uint32x4_t indices_high = vaddq_u32(base_vec, base_step_high);\n\n        uint32x4_t and_low = vandq_u32(indices_low, mask_vec);\n        uint32x4_t and_high = vandq_u32(indices_high, mask_vec);\n\n        uint32x4_t cond_low = vtstq_u32(and_low, and_low);\n        uint32x4_t cond_high = vtstq_u32(and_high, and_high);\n\n        uint16x4_t cond_low_16 = vmovn_u32(cond_low);\n        uint16x4_t cond_high_16 = vmovn_u32(cond_high);\n        uint16x8_t cond_all = vcombine_u16(cond_low_16, cond_high_16);\n\n        uint16x8_t src1_data = vld1q_u16(src1 + i);\n        uint16x8_t src2_data = vld1q_u16(src2 + i);\n        uint16x8_t res = vbslq_u16(cond_all, src1_data, src2_data);\n        vst1q_u16(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        if ((uint32_t)i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stddef.h>\n#include <stdint.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n\n    // Process 8 elements per iteration using NEON\n    for (; i + 8 <= length; i += 8) {\n        uint32_t base = (uint32_t)i;\n        uint32x4_t base_vec = vdupq_n_u32(base);\n\n        // Create indices [i, i+1, i+2, i+3] and [i+4, i+5, i+6, i+7]\n        uint32x4_t indices1 = vaddq_u32(base_vec, (uint32x4_t){0, 1, 2, 3});\n        uint32x4_t indices2 = vaddq_u32(base_vec, (uint32x4_t){4, 5, 6, 7});\n\n        // Compute (index & mask) and check non-zero\n        uint32x4_t mask_vec = vdupq_n_u32(mask);\n        uint32x4_t and1 = vandq_u32(indices1, mask_vec);\n        uint32x4_t and2 = vandq_u32(indices2, mask_vec);\n        uint32x4_t cond1 = vcgtq_u32(and1, vdupq_n_u32(0));\n        uint32x4_t cond2 = vcgtq_u32(and2, vdupq_n_u32(0));\n\n        // Convert conditions to 16-bit masks\n        uint16x4_t cond1_lo = vmovn_u32(cond1);\n        uint16x4_t cond2_lo = vmovn_u32(cond2);\n        uint16x8_t mask_cond = vcombine_u16(cond1_lo, cond2_lo);\n\n        // Load source vectors and blend\n        uint16x8_t src1_vec = vld1q_u16(src1 + i);\n        uint16x8_t src2_vec = vld1q_u16(src2 + i);\n        uint16x8_t dst_vec = vbslq_u16(mask_cond, src1_vec, src2_vec);\n\n        // Store result\n        vst1q_u16(dst + i, dst_vec);\n    }\n\n    // Process remaining elements\n    for (; i < length; i++) {\n        if (((uint32_t)i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint32x4_t mask_vec = vdupq_n_u32(mask);\n    uint32x4_t step_vec = vmovq_n_u32(0);\n    step_vec = vsetq_lane_u32(1, step_vec, 1);\n    step_vec = vsetq_lane_u32(2, step_vec, 2);\n    step_vec = vsetq_lane_u32(3, step_vec, 3);\n\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t indices = vaddq_u32(vdupq_n_u32(i), step_vec);\n        uint32x4_t and_result = vandq_u32(indices, mask_vec);\n        uint32x4_t cond_mask32 = vcgtq_u32(and_result, vdupq_n_u32(0));\n        uint16x4_t cond_mask16 = vmovn_u32(cond_mask32);\n\n        uint16x4_t s1 = vld1_u16(src1 + i);\n        uint16x4_t s2 = vld1_u16(src2 + i);\n        uint16x4_t res = vbsl_u16(cond_mask16, s1, s2);\n        vst1_u16(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    if (length == 0) return;\n    \n    size_t i = 0;\n    \n    // Create increment vector [0, 1, 2, 3]\n    uint32x4_t increment = vmovq_n_u32(0);\n    increment = vsetq_lane_u32(1, increment, 1);\n    increment = vsetq_lane_u32(2, increment, 2);\n    increment = vsetq_lane_u32(3, increment, 3);\n    \n    // Broadcast mask to vector\n    uint32x4_t mask_vec = vdupq_n_u32(mask);\n    \n    // Process 4 elements per iteration\n    for (; i + 4 <= length; i += 4) {\n        // Generate indices [i, i+1, i+2, i+3]\n        uint32x4_t base_vec = vdupq_n_u32(i);\n        uint32x4_t indices = vaddq_u32(base_vec, increment);\n        \n        // Compute condition: (indices & mask) != 0\n        uint32x4_t condition32 = vtstq_u32(indices, mask_vec);\n        uint16x4_t condition16 = vmovn_u32(condition32);\n        \n        // Load source data\n        uint16x4_t s1 = vld1_u16(src1 + i);\n        uint16x4_t s2 = vld1_u16(src2 + i);\n        \n        // Blend based on condition\n        uint16x4_t res = vbsl_u16(condition16, s1, s2);\n        \n        // Store result\n        vst1_u16(dst + i, res);\n    }\n    \n    // Process remaining elements\n    for (; i < length; i++) {\n        dst[i] = (i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint8x16_t bytes = vld1q_u8((const uint8_t*)(src + i));\n        uint8x16_t cnt_per_byte = vcntq_u8(bytes);\n        uint16x8_t sum16 = vpaddlq_u8(cnt_per_byte);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        vst1q_u32(dst + i, sum32);\n    }\n    for (; i < length; i++) {\n        dst[i] = __builtin_popcount(src[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint8x16_t v = vld1q_u8((const uint8_t*)(src + i));\n        uint8x16_t v_shr1 = vshrq_n_u8(v, 1);\n        v_shr1 = vandq_u8(v_shr1, vdupq_n_u8(0x55));\n        uint8x16_t v_step1 = vsubq_u8(v, v_shr1);\n        uint8x16_t v_and2 = vandq_u8(v_step1, vdupq_n_u8(0x33));\n        uint8x16_t v_shr2 = vshrq_n_u8(v_step1, 2);\n        v_shr2 = vandq_u8(v_shr2, vdupq_n_u8(0x33));\n        uint8x16_t v_step2 = vaddq_u8(v_and2, v_shr2);\n        uint8x16_t v_shr4 = vshrq_n_u8(v_step2, 4);\n        uint8x16_t v_step3 = vaddq_u8(v_step2, v_shr4);\n        v_step3 = vandq_u8(v_step3, vdupq_n_u8(0x0F));\n        uint16x8_t v16 = vpaddlq_u8(v_step3);\n        uint32x4_t v32 = vpaddlq_u16(v16);\n        vst1q_u32(dst + i, v32);\n    }\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = (x * 0x01010101) >> 24;\n        dst[i] = x;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t vec = vld1q_u32(src + i);\n        uint8x16_t as_bytes = vreinterpretq_u8_u32(vec);\n        uint8x16_t cnts = vcntq_u8(as_bytes);\n        uint16x8_t paired16 = vpaddlq_u8(cnts);\n        uint32x4_t result = vpaddlq_u16(paired16);\n        vst1q_u32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        uint32_t count = 0;\n        while (x) {\n            count++;\n            x &= x - 1;\n        }\n        dst[i] = count;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 4; // Process 4 elements per iteration\n\n    for (; i + step <= length; i += step) {\n        uint8x16_t bytes = vld1q_u8((const uint8_t*)(src + i));\n        uint8x16_t popcnt_vec = vcntq_u8(bytes);\n        uint16x8_t sum16 = vpaddlq_u8(popcnt_vec);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        vst1q_u32(dst + i, sum32);\n    }\n\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = (x * 0x01010101) >> 24;\n        dst[i] = x;\n    }\n}\n```"}
{"task_id": "SimdBench_16_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint8x16_t bytes = vreinterpretq_u8_u32(v);\n        uint8x16_t cnt_per_byte = vcntq_u8(bytes);\n        uint16x8_t sum16 = vpaddlq_u8(cnt_per_byte);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        vst1q_u32(dst + i, sum32);\n    }\n    for (; i < length; i++) {\n        uint32_t x = src[i];\n        x = (x & 0x55555555) + ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x & 0x0F0F0F0F) + ((x >> 4) & 0x0F0F0F0F);\n        x = (x & 0x00FF00FF) + ((x >> 8) & 0x00FF00FF);\n        x = (x & 0x0000FFFF) + ((x >> 16) & 0x0000FFFF);\n        dst[i] = x;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 8; // Process 8 elements per iteration (128-bit NEON registers)\n\n    for (; i + step <= length; i += step) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t res = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, res);\n    }\n\n    // Handle remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 8;\n    const size_t aligned_length = length & ~(step - 1);\n\n    for (; i < aligned_length; i += step) {\n        uint16x8_t a = vld1q_u16(src1 + i);\n        uint16x8_t b = vld1q_u16(src2 + i);\n        uint16x8_t res = vqaddq_u16(a, b);\n        vst1q_u16(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 8; // Process 8 elements per iteration (128-bit vectors)\n    const size_t neon_length = length - (length % step);\n\n    for (; i < neon_length; i += step) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t res = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, res);\n    }\n\n    for (; i < length; ++i) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    const size_t chunk_size = 8;\n\n    // Process 8 elements per iteration using NEON\n    for (; i + chunk_size <= length; i += chunk_size) {\n        uint16x8_t vec1 = vld1q_u16(src1 + i);\n        uint16x8_t vec2 = vld1q_u16(src2 + i);\n        uint16x8_t result = vqaddq_u16(vec1, vec2);\n        vst1q_u16(dst + i, result);\n    }\n\n    // Process remaining elements\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 8;\n\n    for (; i + step <= length; i += step) {\n        uint16x8_t v1 = vld1q_u16(src1 + i);\n        uint16x8_t v2 = vld1q_u16(src2 + i);\n        uint16x8_t res = vqaddq_u16(v1, v2);\n        vst1q_u16(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    // Initialize C to zero\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        for (; j + 1 < p; j += 2) {\n            vst1q_f64(C + i * p + j, vmovq_n_f64(0.0));\n        }\n        if (j < p) {\n            C[i * p + j] = 0.0;\n        }\n    }\n\n    // Matrix multiplication with range condition\n    for (size_t k = 0; k < n; k++) {\n        for (size_t i = 0; i < m; i++) {\n            double a = A[i * n + k];\n            if (a >= -100.0 && a <= 100.0) {\n                size_t j = 0;\n                for (; j + 1 < p; j += 2) {\n                    float64x2_t b_vec = vld1q_f64(B + k * p + j);\n                    \n                    float64x2_t low_bound = vdupq_n_f64(-100.0);\n                    float64x2_t high_bound = vdupq_n_f64(100.0);\n                    uint64x2_t mask_low = vcgeq_f64(b_vec, low_bound);\n                    uint64x2_t mask_high = vcleq_f64(b_vec, high_bound);\n                    uint64x2_t mask = vandq_u64(mask_low, mask_high);\n                    \n                    float64x2_t a_vec = vdupq_n_f64(a);\n                    float64x2_t prod = vmulq_f64(a_vec, b_vec);\n                    prod = vreinterpretq_f64_u64(vandq_u64(vreinterpretq_u64_f64(prod), mask));\n                    \n                    float64x2_t c_vec = vld1q_f64(C + i * p + j);\n                    c_vec = vaddq_f64(c_vec, prod);\n                    vst1q_f64(C + i * p + j, c_vec);\n                }\n                if (j < p) {\n                    double b = B[k * p + j];\n                    if (b >= -100.0 && b <= 100.0) {\n                        C[i * p + j] += a * b;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t total = m * p;\n    size_t i_total = 0;\n    float64x2_t zero_vec = vdupq_n_f64(0.0);\n    for (; i_total + 1 < total; i_total += 2) {\n        vst1q_f64(C + i_total, zero_vec);\n    }\n    if (i_total < total) {\n        C[i_total] = 0.0;\n    }\n\n    const double low_bound_val = -100.0;\n    const double high_bound_val = 100.0;\n    float64x2_t low_bound_vec = vdupq_n_f64(low_bound_val);\n    float64x2_t high_bound_vec = vdupq_n_f64(high_bound_val);\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t k = 0; k < n; k++) {\n            double a_val = A[i * n + k];\n            if (a_val >= low_bound_val && a_val <= high_bound_val) {\n                const double* B_row_k = B + k * p;\n                double* C_row_i = C + i * p;\n                size_t j = 0;\n                for (; j <= p - 2; j += 2) {\n                    float64x2_t b_vec = vld1q_f64(B_row_k + j);\n                    uint64x2_t mask_low = vcgeq_f64(b_vec, low_bound_vec);\n                    uint64x2_t mask_high = vcleq_f64(b_vec, high_bound_vec);\n                    uint64x2_t mask = vandq_u64(mask_low, mask_high);\n                    float64x2_t product = vmulq_n_f64(b_vec, a_val);\n                    float64x2_t masked_product = vbslq_f64(mask, product, zero_vec);\n                    float64x2_t c_vec = vld1q_f64(C_row_i + j);\n                    c_vec = vaddq_f64(c_vec, masked_product);\n                    vst1q_f64(C_row_i + j, c_vec);\n                }\n                if (j < p) {\n                    double b_val = B_row_k[j];\n                    if (b_val >= low_bound_val && b_val <= high_bound_val) {\n                        C_row_i[j] += a_val * b_val;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    const float64x2_t v_low = vdupq_n_f64(-100.0);\n    const float64x2_t v_high = vdupq_n_f64(100.0);\n    const float64x2_t v_zero = vdupq_n_f64(0.0);\n    const float64x2_t v_one = vdupq_n_f64(1.0);\n\n    for (size_t i = 0; i < m; i++) {\n        double* C_row = C + i * p;\n        size_t j0 = 0;\n        for (; j0 + 1 < p; j0 += 2) {\n            vst1q_f64(C_row + j0, v_zero);\n        }\n        if (j0 < p) {\n            C_row[j0] = 0.0;\n        }\n\n        for (size_t k = 0; k < n; k++) {\n            double a = A[i * n + k];\n            if (a < -100.0 || a > 100.0) {\n                continue;\n            }\n\n            const double* B_row = B + k * p;\n            const float64x2_t v_a = vdupq_n_f64(a);\n            size_t j = 0;\n\n            for (; j + 1 < p; j += 2) {\n                float64x2_t v_b = vld1q_f64(B_row + j);\n                uint64x2_t v_ge_low = vcgeq_f64(v_b, v_low);\n                uint64x2_t v_le_high = vcleq_f64(v_b, v_high);\n                uint64x2_t v_cmp = vandq_u64(v_ge_low, v_le_high);\n                float64x2_t v_mask = vbslq_f64(v_cmp, v_one, v_zero);\n                float64x2_t v_add = vmulq_f64(v_a, v_b);\n                v_add = vmulq_f64(v_add, v_mask);\n                float64x2_t v_c = vld1q_f64(C_row + j);\n                v_c = vaddq_f64(v_c, v_add);\n                vst1q_f64(C_row + j, v_c);\n            }\n\n            if (j < p) {\n                double b = B_row[j];\n                if (b >= -100.0 && b <= 100.0) {\n                    C_row[j] += a * b;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        for (; j + 1 < p; j += 2) {\n            float64x2_t c_vec = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                if (a_val < -100.0 || a_val > 100.0) {\n                    continue;\n                }\n                float64x2_t b_vec = vld1q_f64(&B[k * p + j]);\n                float64x2_t low_bound = vdupq_n_f64(-100.0);\n                float64x2_t high_bound = vdupq_n_f64(100.0);\n                uint64x2_t mask_low = vcgeq_f64(b_vec, low_bound);\n                uint64x2_t mask_high = vcleq_f64(b_vec, high_bound);\n                uint64x2_t mask = vandq_u64(mask_low, mask_high);\n                float64x2_t a_vec = vdupq_n_f64(a_val);\n                float64x2_t product = vmulq_f64(a_vec, b_vec);\n                product = vbslq_f64(mask, product, vdupq_n_f64(0.0));\n                c_vec = vaddq_f64(c_vec, product);\n            }\n            vst1q_f64(&C[i * p + j], c_vec);\n        }\n        if (j < p) {\n            double c_val = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    c_val += a_val * b_val;\n                }\n            }\n            C[i * p + j] = c_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t total_elements = m * p;\n    size_t idx = 0;\n    for (; idx + 1 < total_elements; idx += 2) {\n        vst1q_f64(C + idx, vmovq_n_f64(0.0));\n    }\n    if (idx < total_elements) {\n        C[idx] = 0.0;\n    }\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t k = 0; k < n; k++) {\n            double a_val = A[i * n + k];\n            if (a_val < -100.0 || a_val > 100.0) {\n                continue;\n            }\n            size_t j = 0;\n            for (; j + 1 < p; j += 2) {\n                float64x2_t vb = vld1q_f64(B + k * p + j);\n                float64x2_t vlow = vmovq_n_f64(-100.0);\n                float64x2_t vhigh = vmovq_n_f64(100.0);\n                uint64x2_t mask_ge = vcgeq_f64(vb, vlow);\n                uint64x2_t mask_le = vcleq_f64(vb, vhigh);\n                uint64x2_t mask = vandq_u64(mask_ge, mask_le);\n                float64x2_t a_vec = vdupq_n_f64(a_val);\n                float64x2_t prod = vmulq_f64(a_vec, vb);\n                float64x2_t vc = vld1q_f64(C + i * p + j);\n                float64x2_t res = vbslq_f64(mask, vaddq_f64(vc, prod), vc);\n                vst1q_f64(C + i * p + j, res);\n            }\n            if (j < p) {\n                double b_val = B[k * p + j];\n                if (b_val >= -100.0 && b_val <= 100.0) {\n                    C[i * p + j] += a_val * b_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    \n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a_vec = vld1q_s64(A + i);\n        int64x2_t b_vec = vld1q_s64(B + i);\n        int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n        vst1q_s64(C + i, c_vec);\n    }\n    \n    if (i < total_elements) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t num_pairs = total / 2;\n    const int64_t* a_ptr = A;\n    const int64_t* b_ptr = B;\n    int64_t* c_ptr = C;\n\n    for (size_t i = 0; i < num_pairs; ++i) {\n        int64x2_t a_vec = vld1q_s64(a_ptr);\n        int64x2_t b_vec = vld1q_s64(b_ptr);\n        int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n        vst1q_s64(c_ptr, c_vec);\n        a_ptr += 2;\n        b_ptr += 2;\n        c_ptr += 2;\n    }\n\n    if (total & 1) {\n        *c_ptr = *a_ptr + *b_ptr;\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t total_vec = total & ~(size_t)1;\n    for (size_t i = 0; i < total_vec; i += 2) {\n        int64x2_t a_vec = vld1q_s64(A + i);\n        int64x2_t b_vec = vld1q_s64(B + i);\n        int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n        vst1q_s64(C + i, c_vec);\n    }\n    if (total & 1) {\n        C[total_vec] = A[total_vec] + B[total_vec];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        int64x2_t a_vec = vld1q_s64(A + i);\n        int64x2_t b_vec = vld1q_s64(B + i);\n        int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n        vst1q_s64(C + i, c_vec);\n    }\n\n    if (i < total_elements) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 2 <= total_elements; i += 2) {\n        int64x2_t a_vec = vld1q_s64(A + i);\n        int64x2_t b_vec = vld1q_s64(B + i);\n        int64x2_t c_vec = vaddq_s64(a_vec, b_vec);\n        vst1q_s64(C + i, c_vec);\n    }\n\n    if (i < total_elements) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t a = vld1q_f32(src1 + i);\n        float32x4_t b = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(a, b);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n    for (; i < length; i++) {\n        float32x4_t vsum = vdupq_n_f32(src1[i] + src2[i]);\n        float32x4_t vrounded = vrndnq_f32(vsum);\n        vst1q_lane_f32(dst + i, vrounded, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    const size_t neon_length = length - (length % step);\n\n    for (; i < neon_length; i += step) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n\n    for (; i < length; i++) {\n        float sum = src1[i] + src2[i];\n        dst[i] = nearbyintf(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        float32x4_t a = vld1q_f32(src1 + i);\n        float32x4_t b = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(a, b);\n        float32x4_t rounded = vrndaq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n    for (; i < length; i++) {\n        float x = src1[i] + src2[i];\n        if (x >= 0.0f) {\n            dst[i] = (int)(x + 0.5f);\n        } else {\n            dst[i] = (int)(x - 0.5f);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    const size_t neon_limit = length - (length % step);\n\n    for (; i < neon_limit; i += step) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n\n    for (; i < length; i++) {\n        float sum = src1[i] + src2[i];\n        dst[i] = nearbyintf(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_20_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    for (; i + step <= length; i += step) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t sum = vaddq_f32(v1, v2);\n        float32x4_t rounded = vrndnq_f32(sum);\n        vst1q_f32(dst + i, rounded);\n    }\n    for (; i < length; ++i) {\n        float sum = src1[i] + src2[i];\n        dst[i] = (int)(sum + (sum >= 0 ? 0.5f : -0.5f));\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    static const uint32_t step_arr[4] = {0,1,2,3};\n    uint32x4_t step_vec = vld1q_u32(step_arr);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t idx_vec = vaddq_u32(vdupq_n_u32(i), step_vec);\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n\n        uint32x4_t even_mask_vec = vceqq_u32(vandq_u32(idx_vec, vdupq_n_u32(1)), vdupq_n_u32(0));\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t abs_diff = vabsq_f32(diff);\n        uint32x4_t diff_mask_vec = vcleq_f32(abs_diff, vdupq_n_f32(50.0f));\n\n        uint32x4_t combined_mask = vandq_u32(even_mask_vec, diff_mask_vec);\n        float32x4_t product = vmulq_f32(v1, v2);\n        float32x4_t rounded = vrndpq_f32(product);\n        float32x4_t result = vbslq_f32(combined_mask, rounded, vdupq_n_f32(-1.0f));\n        vst1q_f32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        float diff = src1[i] - src2[i];\n        float abs_diff = (diff < 0.0f) ? -diff : diff;\n        if ((i % 2 == 0) && (abs_diff <= 50.0f)) {\n            float product = src1[i] * src2[i];\n            float32x4_t v = vdupq_n_f32(product);\n            v = vrndpq_f32(v);\n            dst[i] = vgetq_lane_f32(v, 0);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    static const uint32_t even_mask_data[4] = {0xFFFFFFFF, 0, 0xFFFFFFFF, 0};\n    uint32x4_t even_mask = vld1q_u32(even_mask_data);\n    float32x4_t vec_50 = vdupq_n_f32(50.0f);\n    float32x4_t vec_minus_one = vdupq_n_f32(-1.0f);\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n        uint32x4_t abs_mask = vcleq_f32(diff, vec_50);\n        uint32x4_t combined_mask = vandq_u32(abs_mask, even_mask);\n        \n        float32x4_t prod = vmulq_f32(v1, v2);\n        float32x4_t rounded = vrndpq_f32(prod);\n        \n        float32x4_t res = vbslq_f32(combined_mask, rounded, vec_minus_one);\n        vst1q_f32(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            float diff = fabsf(src1[i] - src2[i]);\n            if (diff <= 50.0f) {\n                dst[i] = ceilf(src1[i] * src2[i]);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const uint32_t even_mask_arr[4] = { 0xFFFFFFFF, 0, 0xFFFFFFFF, 0 };\n    uint32x4_t even_mask = vld1q_u32(even_mask_arr);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        float32x4_t diff = vabdq_f32(v1, v2);\n        uint32x4_t cond1 = vcleq_f32(diff, vdupq_n_f32(50.0f));\n        uint32x4_t cond2 = even_mask;\n        uint32x4_t cond = vandq_u32(cond1, cond2);\n        \n        float32x4_t prod = vmulq_f32(v1, v2);\n        float32x4_t rounded = vrndpq_f32(prod);\n        float32x4_t res = vbslq_f32(cond, rounded, vdupq_n_f32(-1.0f));\n        \n        vst1q_f32(dst + i, res);\n    }\n    \n    for (; i < length; i++) {\n        if (i % 2 != 0) {\n            dst[i] = -1.0f;\n            continue;\n        }\n        float d = src1[i] - src2[i];\n        if (d < 0.0f) d = -d;\n        if (d > 50.0f) {\n            dst[i] = -1.0f;\n            continue;\n        }\n        float product = src1[i] * src2[i];\n        float truncated = (float)(int)product;\n        if (product > 0.0f && truncated < product) {\n            truncated += 1.0f;\n        }\n        dst[i] = truncated;\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    size_t i = 0;\n    const uint32_t mask_b_arr[4] = {0xFFFFFFFF, 0, 0xFFFFFFFF, 0};\n    uint32x4_t mask_cond_b = vld1q_u32(mask_b_arr);\n    float32x4_t vfifty = vdupq_n_f32(50.0f);\n    float32x4_t vnegone = vdupq_n_f32(-1.0f);\n    \n    size_t rounded_length = length & ~(size_t)3;\n    for (; i < rounded_length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        \n        float32x4_t diff = vabsq_f32(vsubq_f32(v1, v2));\n        uint32x4_t mask_cond_a = vcleq_f32(diff, vfifty);\n        uint32x4_t mask_cond = vandq_u32(mask_cond_a, mask_cond_b);\n        \n        float32x4_t prod = vmulq_f32(v1, v2);\n        float32x4_t rounded = vrndpq_f32(prod);\n        float32x4_t res = vbslq_f32(mask_cond, rounded, vnegone);\n        \n        vst1q_f32(dst + i, res);\n    }\n    \n    for (; i < length; i++) {\n        if (i % 2 == 0) {\n            float d = src1[i] - src2[i];\n            d = (d < 0) ? -d : d;\n            if (d <= 50.0f) {\n                float prod = src1[i] * src2[i];\n                float32x4_t vprod = vdupq_n_f32(prod);\n                vprod = vrndpq_f32(vprod);\n                dst[i] = vgetq_lane_f32(vprod, 0);\n            } else {\n                dst[i] = -1.0f;\n            }\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    const uint32_t mask_arr[4] = { 0xFFFFFFFF, 0, 0xFFFFFFFF, 0 };\n    uint32x4_t mask_even = vld1q_u32(mask_arr);\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v1 = vld1q_f32(src1 + i);\n        float32x4_t v2 = vld1q_f32(src2 + i);\n        float32x4_t diff = vabdq_f32(v1, v2);\n        float32x4_t cond1 = vcleq_f32(diff, vdupq_n_f32(50.0f));\n        uint32x4_t cond_combined = vandq_u32(vreinterpretq_u32_f32(cond1), mask_even);\n        float32x4_t prod = vmulq_f32(v1, v2);\n        float32x4_t rounded_prod = vrndpq_f32(prod);\n        float32x4_t res = vbslq_f32(cond_combined, rounded_prod, vdupq_n_f32(-1.0f));\n        vst1q_f32(dst + i, res);\n    }\n    for (; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t rounded_total = total & ~(size_t)1;\n    float64x2_t vscale = vdupq_n_f64(scalar);\n\n    for (size_t i = 0; i < rounded_total; i += 2) {\n        float64x2_t vmat = vld1q_f64(mat + i);\n        float64x2_t vres = vmulq_f64(vmat, vscale);\n        vst1q_f64(dst + i, vres);\n    }\n\n    if (total & 1) {\n        dst[total - 1] = mat[total - 1] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t i = 0;\n    \n    // Create a vector with [scalar, scalar]\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    \n    // Process two elements at a time\n    for (; i + 1 < total; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(mat + i);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(dst + i, result);\n    }\n    \n    // Handle any remaining element\n    if (i < total) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    if (total_elements == 0) {\n        return;\n    }\n\n    float64x2_t v_scalar = vdupq_n_f64(scalar);\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t v_mat = vld1q_f64(mat + i);\n        float64x2_t v_result = vmulq_f64(v_mat, v_scalar);\n        vst1q_f64(dst + i, v_result);\n    }\n\n    if (i < total_elements) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    float64x2_t scalar_vec = vdupq_n_f64(scalar);\n    size_t i = 0;\n\n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t mat_vec = vld1q_f64(mat + i);\n        float64x2_t result = vmulq_f64(mat_vec, scalar_vec);\n        vst1q_f64(dst + i, result);\n    }\n\n    if (i < total_elements) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t i = 0;\n    float64x2_t vscalar = vdupq_n_f64(scalar);\n\n    for (; i + 1 < total; i += 2) {\n        float64x2_t vmat = vld1q_f64(mat + i);\n        float64x2_t vres = vmulq_f64(vmat, vscalar);\n        vst1q_f64(dst + i, vres);\n    }\n\n    if (i < total) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t r = 0; r < m; r++) {\n        float* row = mat + r * n;\n        float sum_sq = 0.0f;\n        size_t i = 0;\n\n        float32x4_t vsum = vdupq_n_f32(0.0f);\n        for (; i + 4 <= n; i += 4) {\n            float32x4_t v = vld1q_f32(row + i);\n            vsum = vmlaq_f32(vsum, v, v);\n        }\n\n        sum_sq = vgetq_lane_f32(vsum, 0) + vgetq_lane_f32(vsum, 1) +\n                 vgetq_lane_f32(vsum, 2) + vgetq_lane_f32(vsum, 3);\n\n        for (; i < n; i++) {\n            float val = row[i];\n            sum_sq += val * val;\n        }\n\n        float norm = sqrtf(sum_sq);\n        if (norm == 0.0f) continue;\n\n        float inv_norm = 1.0f / norm;\n        i = 0;\n        float32x4_t v_inv_norm = vdupq_n_f32(inv_norm);\n\n        for (; i + 4 <= n; i += 4) {\n            float32x4_t v = vld1q_f32(row + i);\n            v = vmulq_f32(v, v_inv_norm);\n            vst1q_f32(row + i, v);\n        }\n\n        for (; i < n; i++) {\n            row[i] *= inv_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float32x4_t vsum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j + 3 < n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            vsum = vmlaq_f32(vsum, v, v);\n        }\n\n        float32x2_t vlow = vget_low_f32(vsum);\n        float32x2_t vhigh = vget_high_f32(vsum);\n        float32x2_t vsum_pair = vpadd_f32(vlow, vhigh);\n        float sum_squares = vget_lane_f32(vsum_pair, 0) + vget_lane_f32(vsum_pair, 1);\n\n        for (; j < n; j++) {\n            float val = row[j];\n            sum_squares += val * val;\n        }\n\n        float norm = sqrtf(sum_squares);\n        if (norm == 0.0f) {\n            continue;\n        }\n\n        float inv_norm = 1.0f / norm;\n        float32x4_t vinv_norm = vdupq_n_f32(inv_norm);\n        j = 0;\n\n        for (; j + 3 < n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, vinv_norm);\n            vst1q_f32(row + j, v);\n        }\n\n        for (; j < n; j++) {\n            row[j] *= inv_norm;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float32x4_t v_sq = vdupq_n_f32(0.0f);\n        size_t col = 0;\n        \n        // Vectorized accumulation of squared values\n        for (; col + 4 <= n; col += 4) {\n            float32x4_t v = vld1q_f32(row + col);\n            v_sq = vmlaq_f32(v_sq, v, v);\n        }\n        \n        // Reduce vector to scalar sum\n        float32x2_t low = vget_low_f32(v_sq);\n        float32x2_t high = vget_high_f32(v_sq);\n        float32x2_t sum2 = vadd_f32(low, high);\n        sum2 = vpadd_f32(sum2, sum2);\n        float sq_sum = vget_lane_f32(sum2, 0);\n        \n        // Handle tail elements\n        for (; col < n; col++) {\n            float val = row[col];\n            sq_sum += val * val;\n        }\n        \n        // Compute scaling factor\n        float norm = sqrtf(sq_sum);\n        float scale = (norm == 0.0f) ? 0.0f : 1.0f / norm;\n        float32x4_t v_scale = vdupq_n_f32(scale);\n        \n        // Apply normalization\n        col = 0;\n        for (; col + 4 <= n; col += 4) {\n            float32x4_t v = vld1q_f32(row + col);\n            v = vmulq_f32(v, v_scale);\n            vst1q_f32(row + col, v);\n        }\n        for (; col < n; col++) {\n            row[col] *= scale;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n\n        float32x2_t sum_low = vget_low_f32(sum_vec);\n        float32x2_t sum_high = vget_high_f32(sum_vec);\n        float32x2_t sum_pair = vadd_f32(sum_low, sum_high);\n        float sum = vget_lane_f32(vpadd_f32(sum_pair, sum_pair), 0);\n\n        for (; j < n; j++) {\n            float val = row[j];\n            sum += val * val;\n        }\n\n        float norm = sqrtf(sum);\n        float recip = (norm == 0.0f) ? 0.0f : (1.0f / norm);\n        float32x4_t recip_vec = vdupq_n_f32(recip);\n\n        j = 0;\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t v = vld1q_f32(row + j);\n            v = vmulq_f32(v, recip_vec);\n            vst1q_f32(row + j, v);\n        }\n\n        for (; j < n; j++) {\n            row[j] *= recip;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float32x4_t sum_vec = vdupq_n_f32(0.0f);\n        size_t col = 0;\n\n        for (; col + 4 <= n; col += 4) {\n            float32x4_t v = vld1q_f32(row + col);\n            sum_vec = vmlaq_f32(sum_vec, v, v);\n        }\n\n        float32x2_t low = vget_low_f32(sum_vec);\n        float32x2_t high = vget_high_f32(sum_vec);\n        float32x2_t sum2 = vadd_f32(low, high);\n        sum2 = vpadd_f32(sum2, sum2);\n        float total_sum = vget_lane_f32(sum2, 0);\n\n        for (; col < n; col++) {\n            total_sum += row[col] * row[col];\n        }\n\n        float norm = sqrtf(total_sum);\n        if (norm > 0.0f) {\n            float inv_norm = 1.0f / norm;\n            float32x4_t inv_norm_vec = vdupq_n_f32(inv_norm);\n            col = 0;\n            for (; col + 4 <= n; col += 4) {\n                float32x4_t v = vld1q_f32(row + col);\n                v = vmulq_f32(v, inv_norm_vec);\n                vst1q_f32(row + col, v);\n            }\n            for (; col < n; col++) {\n                row[col] = row[col] * inv_norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        for (; j + 1 < p; j += 2) {\n            float64x2_t acc0 = vdupq_n_f64(0.0);\n            float64x2_t acc1 = vdupq_n_f64(0.0);\n            size_t k = 0;\n            for (; k <= n - 2; k += 2) {\n                float64x2_t v_row = vld1q_f64(mat1 + i * n + k);\n                float64x2_t v2_k = vld1q_f64(mat2 + k * p + j);\n                float64x2_t v2_k1 = vld1q_f64(mat2 + (k + 1) * p + j);\n                float64x2x2_t mat = vtrnq_f64(v2_k, v2_k1);\n                acc0 = vmlaq_f64(acc0, v_row, mat.val[0]);\n                acc1 = vmlaq_f64(acc1, v_row, mat.val[1]);\n            }\n            double sum0 = vgetq_lane_f64(acc0, 0) + vgetq_lane_f64(acc0, 1);\n            double sum1 = vgetq_lane_f64(acc1, 0) + vgetq_lane_f64(acc1, 1);\n            if (k < n) {\n                double a0 = mat1[i * n + k];\n                sum0 += a0 * mat2[k * p + j];\n                sum1 += a0 * mat2[k * p + j + 1];\n            }\n            float64x2_t v_sums = {sum0, sum1};\n            v_sums = vrndnq_f64(v_sums);\n            vst1q_f64(dst + i * p + j, v_sums);\n        }\n        for (; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            float64x1_t v_sum = vdup_n_f64(sum);\n            v_sum = vrndn_f64(v_sum);\n            dst[i * p + j] = vget_lane_f64(v_sum, 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        for (; j < p - 1; j += 2) {\n            float64x2_t accum = vmovq_n_f64(0.0);\n            size_t k = 0;\n            for (; k + 1 < n; k += 2) {\n                float64x2_t a_vec = vld1q_f64(mat1 + i * n + k);\n                float64x2_t b0_vec = vld1q_f64(mat2 + k * p + j);\n                float64x2_t b1_vec = vld1q_f64(mat2 + (k + 1) * p + j);\n                accum = vmlaq_n_f64(accum, b0_vec, vgetq_lane_f64(a_vec, 0));\n                accum = vmlaq_n_f64(accum, b1_vec, vgetq_lane_f64(a_vec, 1));\n            }\n            if (k < n) {\n                double a = mat1[i * n + k];\n                float64x2_t b = vld1q_f64(mat2 + k * p + j);\n                accum = vaddq_f64(accum, vmulq_n_f64(b, a));\n            }\n            accum = vrndnq_f64(accum);\n            vst1q_f64(dst + i * p + j, accum);\n        }\n        if (j < p) {\n            double accum_scalar = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                accum_scalar += mat1[i * n + k] * mat2[k * p + j];\n            }\n            float64x1_t accum_vec = vld1_f64(&accum_scalar);\n            accum_vec = vrndn_f64(accum_vec);\n            dst[i * p + j] = vget_lane_f64(accum_vec, 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            if (j + 1 < p) {\n                float64x2_t v_acc = vmovq_n_f64(0.0);\n                size_t k = 0;\n                for (; k + 1 < n; k += 2) {\n                    float64x2_t v_row = vld1q_f64(mat1 + i * n + k);\n                    float64x2_t v_col0 = vld1q_f64(mat2 + k * p + j);\n                    float64x2_t v_col1 = vld1q_f64(mat2 + (k + 1) * p + j);\n                    v_acc = vfmaq_f64(v_acc, vdupq_laneq_f64(v_row, 0), v_col0);\n                    v_acc = vfmaq_f64(v_acc, vdupq_laneq_f64(v_row, 1), v_col1);\n                }\n                if (k < n) {\n                    float64x2_t v_col = vld1q_f64(mat2 + k * p + j);\n                    double a0 = mat1[i * n + k];\n                    float64x2_t v_add = vmulq_n_f64(v_col, a0);\n                    v_acc = vaddq_f64(v_acc, v_add);\n                }\n                float64x2_t v_rounded = vrndnq_f64(v_acc);\n                vst1q_f64(dst + i * p + j, v_rounded);\n            } else {\n                double sum = 0.0;\n                for (size_t k = 0; k < n; k++) {\n                    sum += mat1[i * n + k] * mat2[k * p + j];\n                }\n                float64x1_t v_sum = vdup_n_f64(sum);\n                v_sum = vrndn_f64(v_sum);\n                dst[i * p + j] = vget_lane_f64(v_sum, 0);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += 2) {\n            if (j + 1 < p) {\n                float64x2_t accum = vdupq_n_f64(0.0);\n                for (size_t k = 0; k < n; k++) {\n                    double a = mat1[i * n + k];\n                    float64x2_t b = vld1q_f64(mat2 + k * p + j);\n                    accum = vmlaq_n_f64(accum, b, a);\n                }\n                accum = vrndnq_f64(accum);\n                vst1q_f64(dst + i * p + j, accum);\n            } else {\n                double accum = 0.0;\n                for (size_t k = 0; k < n; k++) {\n                    accum += mat1[i * n + k] * mat2[k * p + j];\n                }\n                float64x1_t accum_vec = vdup_n_f64(accum);\n                accum_vec = vrndn_f64(accum_vec);\n                dst[i * p + j] = vget_lane_f64(accum_vec, 0);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        for (; j + 1 < p; j += 2) {\n            float64x2_t acc = vdupq_n_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                float64x2_t b = vld1q_f64(mat2 + k * p + j);\n                float64x2_t a = vdupq_n_f64(mat1[i * n + k]);\n                acc = vmlaq_f64(acc, a, b);\n            }\n            float64x2_t rounded = vrndnq_f64(acc);\n            vst1q_f64(dst + i * p + j, rounded);\n        }\n        if (j < p) {\n            double acc = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                acc += mat1[i * n + k] * mat2[k * p + j];\n            }\n            float64x1_t acc_vec = vdup_n_f64(acc);\n            acc_vec = vrndn_f64(acc_vec);\n            dst[i * p + j] = vget_lane_f64(acc_vec, 0);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i_end = (rows / 4) * 4;\n    size_t j_end = (cols / 4) * 4;\n    float32x4_t four = vdupq_n_f32(4.0f);\n    float32x4_t quarter = vdupq_n_f32(0.25f);\n\n    for (size_t i = 0; i < i_end; i += 4) {\n        for (size_t j = 0; j < j_end; j += 4) {\n            float32x4_t r0 = vld1q_f32(src + i * cols + j);\n            float32x4_t r1 = vld1q_f32(src + (i + 1) * cols + j);\n            float32x4_t r2 = vld1q_f32(src + (i + 2) * cols + j);\n            float32x4_t r3 = vld1q_f32(src + (i + 3) * cols + j);\n\n            r0 = vmulq_f32(r0, four);\n            r0 = vrndaq_f32(r0);\n            r0 = vmulq_f32(r0, quarter);\n\n            r1 = vmulq_f32(r1, four);\n            r1 = vrndaq_f32(r1);\n            r1 = vmulq_f32(r1, quarter);\n\n            r2 = vmulq_f32(r2, four);\n            r2 = vrndaq_f32(r2);\n            r2 = vmulq_f32(r2, quarter);\n\n            r3 = vmulq_f32(r3, four);\n            r3 = vrndaq_f32(r3);\n            r3 = vmulq_f32(r3, quarter);\n\n            float32x4x2_t r01 = vtrnq_f32(r0, r1);\n            float32x4x2_t r23 = vtrnq_f32(r2, r3);\n\n            float32x2_t r01_low = vget_low_f32(r01.val[0]);\n            float32x2_t r01_high = vget_high_f32(r01.val[0]);\n            float32x2_t r01_2_low = vget_low_f32(r01.val[1]);\n            float32x2_t r01_2_high = vget_high_f32(r01.val[1]);\n\n            float32x2_t r23_low = vget_low_f32(r23.val[0]);\n            float32x2_t r23_high = vget_high_f32(r23.val[0]);\n            float32x2_t r23_2_low = vget_low_f32(r23.val[1]);\n            float32x2_t r23_2_high = vget_high_f32(r23.val[1]);\n\n            float32x4_t t0 = vcombine_f32(r01_low, r23_low);\n            float32x4_t t1 = vcombine_f32(r01_2_low, r23_2_low);\n            float32x4_t t2 = vcombine_f32(r01_high, r23_high);\n            float32x4_t t3 = vcombine_f32(r01_2_high, r23_2_high);\n\n            vst1q_f32(dst + j * rows + i, t0);\n            vst1q_f32(dst + (j + 1) * rows + i, t1);\n            vst1q_f32(dst + (j + 2) * rows + i, t2);\n            vst1q_f32(dst + (j + 3) * rows + i, t3);\n        }\n    }\n\n    for (size_t i = 0; i < i_end; i++) {\n        for (size_t j = j_end; j < cols; j++) {\n            float val = src[i * cols + j];\n            float tmp = val * 4.0f;\n            int rounded;\n            if (tmp >= 0.0f) {\n                rounded = (int)(tmp + 0.5f);\n            } else {\n                rounded = (int)(tmp - 0.5f);\n            }\n            dst[j * rows + i] = (float)rounded * 0.25f;\n        }\n    }\n\n    for (size_t i = i_end; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            float tmp = val * 4.0f;\n            int rounded;\n            if (tmp >= 0.0f) {\n                rounded = (int)(tmp + 0.5f);\n            } else {\n                rounded = (int)(tmp - 0.5f);\n            }\n            dst[j * rows + i] = (float)rounded * 0.25f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return;\n    \n    size_t i_end_aligned = rows - (rows % 4);\n    size_t j_end_aligned = cols - (cols % 4);\n    \n    auto round_quarter_vec = [](float32x4_t x) -> float32x4_t {\n        const float32x4_t four = vdupq_n_f32(4.0f);\n        const float32x4_t quarter = vdupq_n_f32(0.25f);\n        float32x4_t scaled = vmulq_f32(x, four);\n        float32x4_t rounded = vrndnq_f32(scaled);\n        return vmulq_f32(rounded, quarter);\n    };\n    \n    for (size_t i = 0; i < i_end_aligned; i += 4) {\n        for (size_t j = 0; j < j_end_aligned; j += 4) {\n            float32x4_t v0 = vld1q_f32(src + i*cols + j);\n            float32x4_t v1 = vld1q_f32(src + (i+1)*cols + j);\n            float32x4_t v2 = vld1q_f32(src + (i+2)*cols + j);\n            float32x4_t v3 = vld1q_f32(src + (i+3)*cols + j);\n            \n            float32x4x2_t tmp0 = vtrnq_f32(v0, v1);\n            float32x4x2_t tmp1 = vtrnq_f32(v2, v3);\n            \n            float32x2_t low0 = vget_low_f32(tmp0.val[0]);\n            float32x2_t low1 = vget_low_f32(tmp0.val[1]);\n            float32x2_t low2 = vget_low_f32(tmp1.val[0]);\n            float32x2_t low3 = vget_low_f32(tmp1.val[1]);\n            \n            float32x2_t high0 = vget_high_f32(tmp0.val[0]);\n            float32x2_t high1 = vget_high_f32(tmp0.val[1]);\n            float32x2_t high2 = vget_high_f32(tmp1.val[0]);\n            float32x2_t high3 = vget_high_f32(tmp1.val[1]);\n            \n            float32x4_t col0 = vcombine_f32(low0, low2);\n            float32x4_t col1 = vcombine_f32(low1, low3);\n            float32x4_t col2 = vcombine_f32(high0, high2);\n            float32x4_t col3 = vcombine_f32(high1, high3);\n            \n            col0 = round_quarter_vec(col0);\n            col1 = round_quarter_vec(col1);\n            col2 = round_quarter_vec(col2);\n            col3 = round_quarter_vec(col3);\n            \n            vst1q_f32(dst + j * rows + i, col0);\n            vst1q_f32(dst + (j+1) * rows + i, col1);\n            vst1q_f32(dst + (j+2) * rows + i, col2);\n            vst1q_f32(dst + (j+3) * rows + i, col3);\n        }\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = j_end_aligned; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = std::round(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n    \n    for (size_t i = i_end_aligned; i < rows; i++) {\n        for (size_t j = 0; j < j_end_aligned; j++) {\n            float val = src[i * cols + j];\n            val = std::round(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    const float32x4_t vround_factor = vdupq_n_f32(4.0f);\n    const float32x4_t vscale_back = vdupq_n_f32(0.25f);\n    \n    // Process 4x4 blocks\n    for (size_t i = 0; i < rows; i += 4) {\n        for (size_t j = 0; j < cols; j += 4) {\n            size_t i_remaining = rows - i;\n            size_t j_remaining = cols - j;\n            size_t block_rows = (i_remaining < 4) ? i_remaining : 4;\n            size_t block_cols = (j_remaining < 4) ? j_remaining : 4;\n            \n            if (block_rows == 4 && block_cols == 4) {\n                // Load 4x4 block\n                const float* src0 = src + i * cols + j;\n                const float* src1 = src0 + cols;\n                const float* src2 = src1 + cols;\n                const float* src3 = src2 + cols;\n                \n                float32x4_t r0 = vld1q_f32(src0);\n                float32x4_t r1 = vld1q_f32(src1);\n                float32x4_t r2 = vld1q_f32(src2);\n                float32x4_t r3 = vld1q_f32(src3);\n                \n                // Round to nearest quarter\n                r0 = vmulq_f32(vscale_back, vrndnq_f32(vmulq_f32(r0, vround_factor)));\n                r1 = vmulq_f32(vscale_back, vrndnq_f32(vmulq_f32(r1, vround_factor)));\n                r2 = vmulq_f32(vscale_back, vrndnq_f32(vmulq_f32(r2, vround_factor)));\n                r3 = vmulq_f32(vscale_back, vrndnq_f32(vmulq_f32(r3, vround_factor)));\n                \n                // Transpose 4x4 block\n                float32x4x2_t tmp0 = vtrnq_f32(r0, r1);\n                float32x4x2_t tmp1 = vtrnq_f32(r2, r3);\n                \n                float32x4_t t0 = vcombine_f32(vget_low_f32(tmp0.val[0]), vget_low_f32(tmp1.val[0]));\n                float32x4_t t1 = vcombine_f32(vget_low_f32(tmp0.val[1]), vget_low_f32(tmp1.val[1]));\n                float32x4_t t2 = vcombine_f32(vget_high_f32(tmp0.val[0]), vget_high_f32(tmp1.val[0]));\n                float32x4_t t3 = vcombine_f32(vget_high_f32(tmp0.val[1]), vget_high_f32(tmp1.val[1]));\n                \n                // Store transposed block\n                float* dst0 = dst + j * rows + i;\n                float* dst1 = dst0 + rows;\n                float* dst2 = dst1 + rows;\n                float* dst3 = dst2 + rows;\n                \n                vst1q_f32(dst0, t0);\n                vst1q_f32(dst1, t1);\n                vst1q_f32(dst2, t2);\n                vst1q_f32(dst3, t3);\n            } else {\n                // Handle partial block with scalar\n                for (size_t ii = i; ii < i + block_rows; ii++) {\n                    for (size_t jj = j; jj < j + block_cols; jj++) {\n                        float val = src[ii * cols + jj];\n                        float scaled = val * 4.0f;\n                        int rounded_int;\n                        if (scaled >= 0.0f) {\n                            rounded_int = (int)(scaled + 0.5f);\n                        } else {\n                            rounded_int = (int)(scaled - 0.5f);\n                        }\n                        dst[jj * rows + ii] = rounded_int * 0.25f;\n                    }\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return;\n    }\n\n    const float32x4_t four = vdupq_n_f32(4.0f);\n    const float32x4_t quarter = vdupq_n_f32(0.25f);\n    size_t rows_aligned = rows & ~3;\n    size_t cols_aligned = cols & ~3;\n\n    for (size_t i = 0; i < rows_aligned; i += 4) {\n        for (size_t j = 0; j < cols_aligned; j += 4) {\n            float32x4_t row0 = vld1q_f32(src + i * cols + j);\n            float32x4_t row1 = vld1q_f32(src + (i+1) * cols + j);\n            float32x4_t row2 = vld1q_f32(src + (i+2) * cols + j);\n            float32x4_t row3 = vld1q_f32(src + (i+3) * cols + j);\n\n            row0 = vmulq_f32(vrndnq_f32(vmulq_f32(row0, four)), quarter);\n            row1 = vmulq_f32(vrndnq_f32(vmulq_f32(row1, four)), quarter);\n            row2 = vmulq_f32(vrndnq_f32(vmulq_f32(row2, four)), quarter);\n            row3 = vmulq_f32(vrndnq_f32(vmulq_f32(row3, four)), quarter);\n\n            float32x4x2_t tmp0 = vtrnq_f32(row0, row1);\n            float32x4x2_t tmp1 = vtrnq_f32(row2, row3);\n\n            float32x2_t low0 = vget_low_f32(tmp0.val[0]);\n            float32x2_t low1 = vget_low_f32(tmp0.val[1]);\n            float32x2_t high0 = vget_high_f32(tmp0.val[0]);\n            float32x2_t high1 = vget_high_f32(tmp0.val[1]);\n\n            float32x2_t low2 = vget_low_f32(tmp1.val[0]);\n            float32x2_t low3 = vget_low_f32(tmp1.val[1]);\n            float32x2_t high2 = vget_high_f32(tmp1.val[0]);\n            float32x2_t high3 = vget_high_f32(tmp1.val[1]);\n\n            float32x4_t transposed0 = vcombine_f32(low0, low2);\n            float32x4_t transposed1 = vcombine_f32(low1, low3);\n            float32x4_t transposed2 = vcombine_f32(high0, high2);\n            float32x4_t transposed3 = vcombine_f32(high1, high3);\n\n            vst1q_f32(dst + j * rows + i, transposed0);\n            vst1q_f32(dst + (j+1) * rows + i, transposed1);\n            vst1q_f32(dst + (j+2) * rows + i, transposed2);\n            vst1q_f32(dst + (j+3) * rows + i, transposed3);\n        }\n\n        for (size_t j = cols_aligned; j < cols; j++) {\n            float32x4_t vec = vdupq_n_f32(0.0f);\n            vec = vsetq_lane_f32(src[i * cols + j], vec, 0);\n            vec = vsetq_lane_f32(src[(i+1) * cols + j], vec, 1);\n            vec = vsetq_lane_f32(src[(i+2) * cols + j], vec, 2);\n            vec = vsetq_lane_f32(src[(i+3) * cols + j], vec, 3);\n\n            vec = vmulq_f32(vrndnq_f32(vmulq_f32(vec, four)), quarter);\n            vst1q_f32(dst + j * rows + i, vec);\n        }\n    }\n\n    for (size_t i = rows_aligned; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            val = roundf(val * 4.0f) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t i_end4 = rows & ~(size_t)3;\n    size_t j_end4 = cols & ~(size_t)3;\n    float32x4_t four = vdupq_n_f32(4.0f);\n    float32x4_t quarter = vdupq_n_f32(0.25f);\n\n    for (size_t i0 = 0; i0 < i_end4; i0 += 4) {\n        for (size_t j0 = 0; j0 < j_end4; j0 += 4) {\n            float32x4_t row0 = vld1q_f32(src + (i0 + 0) * cols + j0);\n            float32x4_t row1 = vld1q_f32(src + (i0 + 1) * cols + j0);\n            float32x4_t row2 = vld1q_f32(src + (i0 + 2) * cols + j0);\n            float32x4_t row3 = vld1q_f32(src + (i0 + 3) * cols + j0);\n\n            row0 = vmulq_f32(vrndaq_f32(vmulq_f32(row0, four)), quarter);\n            row1 = vmulq_f32(vrndaq_f32(vmulq_f32(row1, four)), quarter);\n            row2 = vmulq_f32(vrndaq_f32(vmulq_f32(row2, four)), quarter);\n            row3 = vmulq_f32(vrndaq_f32(vmulq_f32(row3, four)), quarter);\n\n            float32x4x2_t tmp0 = vtrnq_f32(row0, row1);\n            float32x4x2_t tmp1 = vtrnq_f32(row2, row3);\n\n            float32x4_t col0 = vcombine_f32(vget_low_f32(tmp0.val[0]), vget_low_f32(tmp1.val[0]));\n            float32x4_t col1 = vcombine_f32(vget_low_f32(tmp0.val[1]), vget_low_f32(tmp1.val[1]));\n            float32x4_t col2 = vcombine_f32(vget_high_f32(tmp0.val[0]), vget_high_f32(tmp1.val[0]));\n            float32x4_t col3 = vcombine_f32(vget_high_f32(tmp0.val[1]), vget_high_f32(tmp1.val[1]));\n\n            vst1q_f32(dst + j0 * rows + i0, col0);\n            vst1q_f32(dst + (j0 + 1) * rows + i0, col1);\n            vst1q_f32(dst + (j0 + 2) * rows + i0, col2);\n            vst1q_f32(dst + (j0 + 3) * rows + i0, col3);\n        }\n    }\n\n    for (size_t i0 = 0; i0 < i_end4; i0 += 4) {\n        for (size_t j = j_end4; j < cols; j++) {\n            float32x4_t vec = {\n                src[(i0 + 0) * cols + j],\n                src[(i0 + 1) * cols + j],\n                src[(i0 + 2) * cols + j],\n                src[(i0 + 3) * cols + j]\n            };\n            vec = vmulq_f32(vrndaq_f32(vmulq_f32(vec, four)), quarter);\n            vst1q_f32(dst + j * rows + i0, vec);\n        }\n    }\n\n    for (size_t i = i_end4; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            float32x4_t tmp = vdupq_n_f32(val * 4.0f);\n            tmp = vrndaq_f32(tmp);\n            val = vgetq_lane_f32(tmp, 0) * 0.25f;\n            dst[j * rows + i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n    \n    for (; i + 3 < total; i += 4) {\n        float32x4_t t1 = vld1q_f32(tensor1 + i);\n        float32x4_t t2 = vld1q_f32(tensor2 + i);\n        float32x4_t diff = vsubq_f32(t1, t2);\n        float32x4_t truncated = vrndiq_f32(diff);\n        vst1q_f32(dst + i, truncated);\n    }\n    \n    for (; i < total; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        if (diff >= 0.0f) {\n            dst[i] = (int)diff;\n        } else {\n            dst[i] = -((int)(-diff));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    if (total == 0) {\n        return;\n    }\n\n    size_t i = 0;\n    for (; i + 4 <= total; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndzq_f32(diff);\n        vst1q_f32(dst + i, rounded);\n    }\n\n    for (; i + 2 <= total; i += 2) {\n        float32x2_t v1 = vld1_f32(tensor1 + i);\n        float32x2_t v2 = vld1_f32(tensor2 + i);\n        float32x2_t diff = vsub_f32(v1, v2);\n        float32x2_t rounded = vrndz_f32(diff);\n        vst1_f32(dst + i, rounded);\n    }\n\n    if (i < total) {\n        float32x2_t v1 = vld1_dup_f32(tensor1 + i);\n        float32x2_t v2 = vld1_dup_f32(tensor2 + i);\n        float32x2_t diff = vsub_f32(v1, v2);\n        float32x2_t rounded = vrndz_f32(diff);\n        vst1_lane_f32(dst + i, rounded, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t diff = vsubq_f32(v1, v2);\n        float32x4_t rounded = vrndq_f32(diff);\n        vst1q_f32(dst + i, rounded);\n    }\n\n    for (; i < total; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = (diff >= 0.0f) ? (int)diff : (int)(diff - 0.0f);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    \n    for (; i + 3 < total_elements; i += 4) {\n        float32x4_t vec1 = vld1q_f32(tensor1 + i);\n        float32x4_t vec2 = vld1q_f32(tensor2 + i);\n        float32x4_t diff = vsubq_f32(vec1, vec2);\n        float32x4_t rounded = vrndzq_f32(diff);\n        vst1q_f32(dst + i, rounded);\n    }\n\n    for (; i < total_elements; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = __builtin_truncf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total_elements; i += 4) {\n        float32x4_t v1 = vld1q_f32(tensor1 + i);\n        float32x4_t v2 = vld1q_f32(tensor2 + i);\n        float32x4_t diff = vsubq_f32(v1, v2);\n        uint32x4_t mask = vcgeq_f32(diff, vdupq_n_f32(0.0f));\n        float32x4_t floor_val = vrndmq_f32(diff);\n        float32x4_t ceil_val = vrndpq_f32(diff);\n        float32x4_t result = vbslq_f32(mask, floor_val, ceil_val);\n        vst1q_f32(dst + i, result);\n    }\n\n    if (i < total_elements) {\n        size_t remaining = total_elements - i;\n        float32x4_t v1 = vdupq_n_f32(0.0f);\n        float32x4_t v2 = vdupq_n_f32(0.0f);\n\n        if (remaining >= 1) {\n            v1 = vsetq_lane_f32(tensor1[i], v1, 0);\n            v2 = vsetq_lane_f32(tensor2[i], v2, 0);\n        }\n        if (remaining >= 2) {\n            v1 = vsetq_lane_f32(tensor1[i+1], v1, 1);\n            v2 = vsetq_lane_f32(tensor2[i+1], v2, 1);\n        }\n        if (remaining >= 3) {\n            v1 = vsetq_lane_f32(tensor1[i+2], v1, 2);\n            v2 = vsetq_lane_f32(tensor2[i+2], v2, 2);\n        }\n\n        float32x4_t diff = vsubq_f32(v1, v2);\n        uint32x4_t mask = vcgeq_f32(diff, vdupq_n_f32(0.0f));\n        float32x4_t floor_val = vrndmq_f32(diff);\n        float32x4_t ceil_val = vrndpq_f32(diff);\n        float32x4_t result = vbslq_f32(mask, floor_val, ceil_val);\n\n        if (remaining >= 1) dst[i] = vgetq_lane_f32(result, 0);\n        if (remaining >= 2) dst[i+1] = vgetq_lane_f32(result, 1);\n        if (remaining >= 3) dst[i+2] = vgetq_lane_f32(result, 2);\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t num_elements = m * n;\n    if (num_elements == 0) {\n        return;\n    }\n\n    size_t vec_elements = num_elements / 2;\n    size_t rem = num_elements % 2;\n    \n    const double* p1 = mat1;\n    const double* p2 = mat2;\n    double* p_dst = dst;\n\n    for (size_t i = 0; i < vec_elements; ++i) {\n        float64x2_t v1 = vld1q_f64(p1);\n        float64x2_t v2 = vld1q_f64(p2);\n        float64x2_t v_res = vmulq_f64(v1, v2);\n        vst1q_f64(p_dst, v_res);\n        \n        p1 += 2;\n        p2 += 2;\n        p_dst += 2;\n    }\n\n    if (rem) {\n        *p_dst = *p1 * *p2;\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t i = 0;\n    \n    for (; i + 2 <= total; i += 2) {\n        float64x2_t vec1 = vld1q_f64(mat1 + i);\n        float64x2_t vec2 = vld1q_f64(mat2 + i);\n        float64x2_t res = vmulq_f64(vec1, vec2);\n        vst1q_f64(dst + i, res);\n    }\n    \n    if (i < total) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t num_pairs = total / 2;\n    size_t remainder = total % 2;\n    \n    for (size_t i = 0; i < num_pairs; i++) {\n        float64x2_t a = vld1q_f64(mat1 + 2 * i);\n        float64x2_t b = vld1q_f64(mat2 + 2 * i);\n        float64x2_t result = vmulq_f64(a, b);\n        vst1q_f64(dst + 2 * i, result);\n    }\n    \n    if (remainder) {\n        dst[total - 1] = mat1[total - 1] * mat2[total - 1];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t i = 0;\n    \n    for (; i + 1 < total; i += 2) {\n        float64x2_t vec1 = vld1q_f64(mat1 + i);\n        float64x2_t vec2 = vld1q_f64(mat2 + i);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(dst + i, result);\n    }\n    \n    if (i < total) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t i = 0;\n    \n    for (; i + 1 < total_elements; i += 2) {\n        float64x2_t vec1 = vld1q_f64(mat1 + i);\n        float64x2_t vec2 = vld1q_f64(mat2 + i);\n        float64x2_t result = vmulq_f64(vec1, vec2);\n        vst1q_f64(dst + i, result);\n    }\n    \n    if (i < total_elements) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t vsum = vmovq_n_f32(0.0f);\n        size_t j = 0;\n        const float* row_ptr = mat + i * n;\n        \n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_data = vld1q_f32(row_ptr + j);\n            float32x4_t vec_data = vld1q_f32(vec + j);\n            vsum = vmlaq_f32(vsum, mat_data, vec_data);\n        }\n        \n        float32x2_t low = vget_low_f32(vsum);\n        float32x2_t high = vget_high_f32(vsum);\n        float32x2_t sum2 = vadd_f32(low, high);\n        float total = vget_lane_f32(vpadd_f32(sum2, sum2), 0);\n        \n        for (; j < n; j++) {\n            total += row_ptr[j] * vec[j];\n        }\n        \n        dst[i] = total;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t vsum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t mat_data = vld1q_f32(mat + i * n + j);\n            float32x4_t vec_data = vld1q_f32(vec + j);\n            vsum = vmlaq_f32(vsum, mat_data, vec_data);\n        }\n\n        float32x2_t vlow = vget_low_f32(vsum);\n        float32x2_t vhigh = vget_high_f32(vsum);\n        float32x2_t vsum2 = vadd_f32(vlow, vhigh);\n        float s = vget_lane_f32(vpadd_f32(vsum2, vsum2), 0);\n\n        for (; j < n; j++) {\n            s += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = s;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float32x4_t acc0 = vdupq_n_f32(0.0f);\n        float32x4_t acc1 = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        const size_t block_size = 8;\n        size_t block_end = n - (n % block_size);\n\n        for (; j < block_end; j += block_size) {\n            float32x4_t mat0 = vld1q_f32(mat + i * n + j);\n            float32x4_t mat1 = vld1q_f32(mat + i * n + j + 4);\n            float32x4_t vec0 = vld1q_f32(vec + j);\n            float32x4_t vec1 = vld1q_f32(vec + j + 4);\n            \n            acc0 = vmlaq_f32(acc0, mat0, vec0);\n            acc1 = vmlaq_f32(acc1, mat1, vec1);\n        }\n\n        acc0 = vaddq_f32(acc0, acc1);\n        float sum = vgetq_lane_f32(acc0, 0) + vgetq_lane_f32(acc0, 1) + \n                   vgetq_lane_f32(acc0, 2) + vgetq_lane_f32(acc0, 3);\n\n        for (; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        const float* row = mat + i * n;\n        float32x4_t acc = vdupq_n_f32(0.0f);\n        size_t j = 0;\n\n        for (; j + 4 <= n; j += 4) {\n            float32x4_t mat_val = vld1q_f32(row + j);\n            float32x4_t vec_val = vld1q_f32(vec + j);\n            acc = vmlaq_f32(acc, mat_val, vec_val);\n        }\n\n        float total = 0.0f;\n        total += vgetq_lane_f32(acc, 0);\n        total += vgetq_lane_f32(acc, 1);\n        total += vgetq_lane_f32(acc, 2);\n        total += vgetq_lane_f32(acc, 3);\n\n        for (; j < n; j++) {\n            total += row[j] * vec[j];\n        }\n\n        dst[i] = total;\n    }\n}\n```"}
{"task_id": "SimdBench_28_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        const float* row_ptr = mat + i * n;\n        float32x4_t vsum = vdupq_n_f32(0.0f);\n        size_t j = 0;\n        for (; j + 3 < n; j += 4) {\n            float32x4_t mat_data = vld1q_f32(row_ptr + j);\n            float32x4_t vec_data = vld1q_f32(vec + j);\n            vsum = vmlaq_f32(vsum, mat_data, vec_data);\n        }\n        float sum_tail = 0.0f;\n        for (; j < n; j++) {\n            sum_tail += row_ptr[j] * vec[j];\n        }\n        float32x2_t low = vget_low_f32(vsum);\n        float32x2_t high = vget_high_f32(vsum);\n        float32x2_t sum2 = vadd_f32(low, high);\n        float total = vget_lane_f32(sum2, 0) + vget_lane_f32(sum2, 1) + sum_tail;\n        dst[i] = total;\n    }\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    if (total_elements == 0) {\n        return 0.0;\n    }\n    \n    const double* ptr = mat;\n    size_t num_vectors = total_elements / 2;\n    size_t remainder = total_elements % 2;\n    float64x2_t vsum = vdupq_n_f64(0.0);\n    \n    for (size_t i = 0; i < num_vectors; ++i) {\n        float64x2_t v = vld1q_f64(ptr);\n        vsum = vaddq_f64(vsum, v);\n        ptr += 2;\n    }\n    \n    double sum = vgetq_lane_f64(vsum, 0) + vgetq_lane_f64(vsum, 1);\n    \n    for (size_t i = 0; i < remainder; ++i) {\n        sum += ptr[i];\n    }\n    \n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    if (total_elements == 0) {\n        return 0.0;\n    }\n    \n    double sum = 0.0;\n    size_t i = 0;\n    \n    if (total_elements >= 4) {\n        float64x2_t vsumA = vdupq_n_f64(0.0);\n        float64x2_t vsumB = vdupq_n_f64(0.0);\n        size_t num_chunks = total_elements / 4;\n        \n        for (; i < num_chunks * 4; i += 4) {\n            float64x2_t va = vld1q_f64(mat + i);\n            float64x2_t vb = vld1q_f64(mat + i + 2);\n            vsumA = vaddq_f64(vsumA, va);\n            vsumB = vaddq_f64(vsumB, vb);\n        }\n        \n        vsumA = vaddq_f64(vsumA, vsumB);\n        sum = vgetq_lane_f64(vsumA, 0) + vgetq_lane_f64(vsumA, 1);\n    }\n    \n    if (total_elements - i >= 2) {\n        float64x2_t vtail = vld1q_f64(mat + i);\n        sum += vgetq_lane_f64(vtail, 0) + vgetq_lane_f64(vtail, 1);\n        i += 2;\n    }\n    \n    if (i < total_elements) {\n        sum += mat[i];\n    }\n    \n    return sum / total_elements;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total = m * n;\n    if (total == 0) {\n        return 0.0;\n    }\n    \n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    const double* ptr = mat;\n    size_t pairs = total / 2;\n    size_t remainder = total % 2;\n    \n    for (size_t i = 0; i < pairs; i++) {\n        float64x2_t val = vld1q_f64(ptr);\n        sum_vec = vaddq_f64(sum_vec, val);\n        ptr += 2;\n    }\n    \n    double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    \n    if (remainder) {\n        sum += *ptr;\n    }\n    \n    return sum / static_cast<double>(total);\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total = m * n;\n    if (total == 0) {\n        return 0.0;\n    }\n    \n    double sum = 0.0;\n    size_t i = 0;\n    float64x2_t v_sum1 = vdupq_n_f64(0.0);\n    float64x2_t v_sum2 = vdupq_n_f64(0.0);\n    \n    size_t vec_elems = total & ~(size_t)1;\n    size_t vec_elems_4 = vec_elems & ~(size_t)3;\n    \n    for (; i < vec_elems_4; i += 4) {\n        float64x2_t v1 = vld1q_f64(mat + i);\n        float64x2_t v2 = vld1q_f64(mat + i + 2);\n        v_sum1 = vaddq_f64(v_sum1, v1);\n        v_sum2 = vaddq_f64(v_sum2, v2);\n    }\n    \n    for (; i < vec_elems; i += 2) {\n        float64x2_t v = vld1q_f64(mat + i);\n        v_sum1 = vaddq_f64(v_sum1, v);\n    }\n    \n    v_sum1 = vaddq_f64(v_sum1, v_sum2);\n    sum = vgetq_lane_f64(v_sum1, 0) + vgetq_lane_f64(v_sum1, 1);\n    \n    if (total & 1) {\n        sum += mat[total - 1];\n    }\n    \n    return sum / (double)total;\n}\n```"}
{"task_id": "SimdBench_29_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    if (total_elements == 0) return 0.0;\n    \n    size_t vectorizable = total_elements & ~(size_t)1;\n    float64x2_t vsum = vdupq_n_f64(0.0);\n    double sum = 0.0;\n\n    for (size_t i = 0; i < vectorizable; i += 2) {\n        float64x2_t v = vld1q_f64(mat + i);\n        vsum = vaddq_f64(vsum, v);\n    }\n\n    sum = vgetq_lane_f64(vsum, 0) + vgetq_lane_f64(vsum, 1);\n\n    if (total_elements % 2 != 0) {\n        sum += mat[vectorizable];\n    }\n\n    return sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        bool d = directions[i];\n        size_t end = cols - 1;\n\n        if (cols < 2) {\n            continue;\n        }\n\n        size_t j = 0;\n        while (j + 4 <= end) {\n            int32x4_t v0 = vld1q_s32(row_ptr + j);\n            int32x4_t v1 = vld1q_s32(row_ptr + j + 1);\n\n            uint32x4_t cmp;\n            if (d) {\n                cmp = vcleq_s32(v0, v1);\n            } else {\n                cmp = vcgeq_s32(v0, v1);\n            }\n\n            uint32_t min_val = vminvq_u32(cmp);\n            if (min_val == 0) {\n                return false;\n            }\n            j += 4;\n        }\n\n        while (j < end) {\n            if (d) {\n                if (row_ptr[j] > row_ptr[j + 1]) {\n                    return false;\n                }\n            } else {\n                if (row_ptr[j] < row_ptr[j + 1]) {\n                    return false;\n                }\n            }\n            j++;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        bool d = directions[r];\n        \n        if (cols <= 1) {\n            continue;\n        }\n        \n        size_t i = 0;\n        if (cols >= 5) {\n            for (; i <= cols - 5; i += 4) {\n                int32x4_t v0 = vld1q_s32(row_ptr + i);\n                int32x4_t v1 = vld1q_s32(row_ptr + i + 1);\n                \n                uint32x4_t cmp;\n                if (d) {\n                    cmp = vcleq_s32(v0, v1);\n                } else {\n                    cmp = vcgeq_s32(v0, v1);\n                }\n                \n                uint32_t min_mask = vminvq_u32(cmp);\n                if (min_mask != 0xFFFFFFFF) {\n                    return false;\n                }\n            }\n        }\n        \n        for (; i < cols - 1; i++) {\n            if (d) {\n                if (row_ptr[i] > row_ptr[i+1]) {\n                    return false;\n                }\n            } else {\n                if (row_ptr[i] < row_ptr[i+1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stddef.h>\n#include <stdint.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return true;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        bool dir = directions[i];\n        const int* row_ptr = matrix + i * cols;\n        size_t n = cols;\n\n        if (n <= 1) {\n            continue;\n        }\n\n        const int* p = row_ptr;\n        const int* q = row_ptr + 1;\n        size_t num_pairs = n - 1;\n\n        size_t j = 0;\n        for (; j + 3 < num_pairs; j += 4) {\n            int32x4_t a = vld1q_s32(p + j);\n            int32x4_t b = vld1q_s32(q + j);\n            uint32x4_t mask;\n\n            if (dir) {\n                mask = vcgeq_s32(b, a);\n            } else {\n                mask = vcgeq_s32(a, b);\n            }\n\n            uint64x2_t mask64 = vreinterpretq_u64_u32(mask);\n            uint64_t low64 = vgetq_lane_u64(mask64, 0);\n            uint64_t high64 = vgetq_lane_u64(mask64, 1);\n\n            if (low64 != 0xFFFFFFFFFFFFFFFFULL || high64 != 0xFFFFFFFFFFFFFFFFULL) {\n                return false;\n            }\n        }\n\n        for (; j < num_pairs; j++) {\n            if (dir) {\n                if (p[j] > q[j]) {\n                    return false;\n                }\n            } else {\n                if (p[j] < q[j]) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    if (rows == 0) {\n        return true;\n    }\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        bool dir = directions[r];\n        \n        if (cols <= 1) {\n            continue;\n        }\n\n        size_t num_pairs = cols - 1;\n        size_t i = 0;\n\n        for (; i + 4 <= num_pairs; i += 4) {\n            int32x4_t current = vld1q_s32(row_ptr + i);\n            int32x4_t next = vld1q_s32(row_ptr + i + 1);\n            \n            uint32x4_t cmp;\n            if (dir) {\n                cmp = vcleq_s32(current, next);\n            } else {\n                cmp = vcgeq_s32(current, next);\n            }\n            \n            uint32x2_t low = vget_low_u32(cmp);\n            uint32x2_t high = vget_high_u32(cmp);\n            uint32_t a0 = vget_lane_u32(low, 0);\n            uint32_t a1 = vget_lane_u32(low, 1);\n            uint32_t a2 = vget_lane_u32(high, 0);\n            uint32_t a3 = vget_lane_u32(high, 1);\n            \n            if ((a0 & a1 & a2 & a3) != 0xFFFFFFFF) {\n                return false;\n            }\n        }\n\n        for (; i < num_pairs; i++) {\n            if (dir) {\n                if (row_ptr[i] > row_ptr[i+1]) {\n                    return false;\n                }\n            } else {\n                if (row_ptr[i] < row_ptr[i+1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_30_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int32_t* row = matrix + i * cols;\n        bool dir = directions[i];\n        size_t num_pairs = cols - 1;\n\n        if (num_pairs == 0) {\n            continue;\n        }\n\n        size_t j = 0;\n        while (j + 4 <= num_pairs) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            int32x4_t diff = vsubq_s32(next, current);\n\n            if (dir) {\n                uint32x4_t mask = vcltq_s32(diff, vdupq_n_s32(0));\n                if (vgetq_lane_u32(mask, 0) | vgetq_lane_u32(mask, 1) | \n                    vgetq_lane_u32(mask, 2) | vgetq_lane_u32(mask, 3)) {\n                    return false;\n                }\n            } else {\n                uint32x4_t mask = vcgtq_s32(diff, vdupq_n_s32(0));\n                if (vgetq_lane_u32(mask, 0) | vgetq_lane_u32(mask, 1) | \n                    vgetq_lane_u32(mask, 2) | vgetq_lane_u32(mask, 3)) {\n                    return false;\n                }\n            }\n            j += 4;\n        }\n\n        while (j < num_pairs) {\n            if (dir) {\n                if (row[j + 1] < row[j]) {\n                    return false;\n                }\n            } else {\n                if (row[j + 1] > row[j]) {\n                    return false;\n                }\n            }\n            j++;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16_t base16 = (int16_t)base;\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        int16x8_t v_src = vld1q_s16(src + i);\n        int16x8_t v_dst = vdupq_n_s16(0);\n        for (int j = 0; j < 8; j++) {\n            int16_t x = vgetq_lane_s16(v_src, j);\n            int16_t r = x % base16;\n            if (r < 0) r += base16;\n            int16_t y = x - r;\n            v_dst = vsetq_lane_s16(y, v_dst, j);\n        }\n        vst1q_s16(dst + i, v_dst);\n    }\n    for (; i < length; i++) {\n        int16_t x = src[i];\n        int16_t r = x % base16;\n        if (r < 0) r += base16;\n        dst[i] = x - r;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    if (base == 1) {\n        for (size_t i = 0; i < length; i++) {\n            dst[i] = src[i];\n        }\n        return;\n    }\n\n    size_t i = 0;\n    if (length >= 8) {\n        float32x4_t v_base_f = vdupq_n_f32((float)base);\n        for (; i <= length - 8; i += 8, src += 8, dst += 8) {\n            int16x8_t v_src = vld1q_s16(src);\n            int16x4_t v_src_low = vget_low_s16(v_src);\n            int16x4_t v_src_high = vget_high_s16(v_src);\n            \n            int32x4_t v_src_low_s32 = vmovl_s16(v_src_low);\n            int32x4_t v_src_high_s32 = vmovl_s16(v_src_high);\n            \n            float32x4_t v_src_low_f = vcvtq_f32_s32(v_src_low_s32);\n            float32x4_t v_src_high_f = vcvtq_f32_s32(v_src_high_s32);\n            \n            float32x4_t v_quotient_low = vdivq_f32(v_src_low_f, v_base_f);\n            float32x4_t v_quotient_high = vdivq_f32(v_src_high_f, v_base_f);\n            \n            float32x4_t v_floor_low = vrndmq_f32(v_quotient_low);\n            float32x4_t v_floor_high = vrndmq_f32(v_quotient_high);\n            \n            int32x4_t v_floor_low_s32 = vcvtq_s32_f32(v_floor_low);\n            int32x4_t v_floor_high_s32 = vcvtq_s32_f32(v_floor_high);\n            \n            int16x4_t v_floor_low_s16 = vqmovn_s32(v_floor_low_s32);\n            int16x4_t v_floor_high_s16 = vqmovn_s32(v_floor_high_s32);\n            \n            int16x8_t v_floor_s16 = vcombine_s16(v_floor_low_s16, v_floor_high_s16);\n            int16x8_t v_multiple = vmulq_s16(v_floor_s16, vdupq_n_s16((int16_t)base));\n            \n            vst1q_s16(dst, v_multiple);\n        }\n    }\n    \n    for (; i < length; i++) {\n        int16_t s = src[i];\n        int16_t r = s % (int16_t)base;\n        if (r == 0) {\n            dst[i] = s;\n        } else if (s < 0) {\n            dst[i] = s - (r + base);\n        } else {\n            dst[i] = s - r;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    if (base == 1) {\n        for (size_t i = 0; i < length; i++) {\n            dst[i] = src[i];\n        }\n        return;\n    }\n\n    int16_t base16 = (int16_t)base;\n    float base_f = (float)base16;\n    size_t i = 0;\n\n    for (; i + 7 < length; i += 8) {\n        int16x8_t v_src = vld1q_s16(src + i);\n        \n        int16x4_t v_low = vget_low_s16(v_src);\n        int16x4_t v_high = vget_high_s16(v_src);\n        \n        int32x4_t v_low_s32 = vmovl_s16(v_low);\n        int32x4_t v_high_s32 = vmovl_s16(v_high);\n        \n        float32x4_t v_low_f = vcvtq_f32_s32(v_low_s32);\n        float32x4_t v_high_f = vcvtq_f32_s32(v_high_s32);\n        \n        float32x4_t v_base = vdupq_n_f32(base_f);\n        v_low_f = vdivq_f32(v_low_f, v_base);\n        v_high_f = vdivq_f32(v_high_f, v_base);\n        \n        v_low_f = vrndmq_f32(v_low_f);\n        v_high_f = vrndmq_f32(v_high_f);\n        \n        int32x4_t v_low_i = vcvtq_s32_f32(v_low_f);\n        int32x4_t v_high_i = vcvtq_s32_f32(v_high_f);\n        \n        int16x4_t v_low_s16 = vmovn_s32(v_low_i);\n        int16x4_t v_high_s16 = vmovn_s32(v_high_i);\n        \n        int16x8_t v_floor = vcombine_s16(v_low_s16, v_high_s16);\n        int16x8_t v_res = vmulq_s16(v_floor, vdupq_n_s16(base16));\n        \n        vst1q_s16(dst + i, v_res);\n    }\n\n    for (; i < length; i++) {\n        int16_t x = src[i];\n        int16_t rem = x % base16;\n        if (rem < 0) {\n            rem += base16;\n        }\n        dst[i] = x - rem;\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nstatic inline int16_t nearest_scalar(int16_t x, uint8_t base, int16_t base16, int16_t base_minus_one) {\n    int32_t x32 = x;\n    int32_t offset = (x < 0) ? (int32_t)base_minus_one : 0;\n    int32_t t = x32 - offset;\n    int32_t q = t / base16;\n    int32_t result = q * base16;\n    return (int16_t)result;\n}\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16_t base_minus_one = base - 1;\n    const int16_t base16 = (int16_t)base;\n    const int chunk = 8;\n\n    for (; i + chunk <= length; i += chunk) {\n        int16x8_t vx = vld1q_s16(src + i);\n\n        int16_t x0 = vgetq_lane_s16(vx, 0);\n        int16_t x1 = vgetq_lane_s16(vx, 1);\n        int16_t x2 = vgetq_lane_s16(vx, 2);\n        int16_t x3 = vgetq_lane_s16(vx, 3);\n        int16_t x4 = vgetq_lane_s16(vx, 4);\n        int16_t x5 = vgetq_lane_s16(vx, 5);\n        int16_t x6 = vgetq_lane_s16(vx, 6);\n        int16_t x7 = vgetq_lane_s16(vx, 7);\n\n        int16_t r0 = nearest_scalar(x0, base, base16, base_minus_one);\n        int16_t r1 = nearest_scalar(x1, base, base16, base_minus_one);\n        int16_t r2 = nearest_scalar(x2, base, base16, base_minus_one);\n        int16_t r3 = nearest_scalar(x3, base, base16, base_minus_one);\n        int16_t r4 = nearest_scalar(x4, base, base16, base_minus_one);\n        int16_t r5 = nearest_scalar(x5, base, base16, base_minus_one);\n        int16_t r6 = nearest_scalar(x6, base, base16, base_minus_one);\n        int16_t r7 = nearest_scalar(x7, base, base16, base_minus_one);\n\n        int16x8_t vresult = {r0, r1, r2, r3, r4, r5, r6, r7};\n        vst1q_s16(dst + i, vresult);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = nearest_scalar(src[i], base, base16, base_minus_one);\n    }\n}\n```"}
{"task_id": "SimdBench_31_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    int16_t base16 = (int16_t)base;\n    \n    for (; i + 8 <= length; i += 8) {\n        int16x8_t vx = vld1q_s16(src + i);\n        int16_t values[8];\n        vst1q_s16(values, vx);\n        \n        for (int j = 0; j < 8; j++) {\n            int16_t x = values[j];\n            int16_t q = x / base16;\n            int16_t candidate = q * base16;\n            if (x < 0 && candidate > x) {\n                candidate -= base16;\n            }\n            values[j] = candidate;\n        }\n        \n        int16x8_t vresult = vld1q_s16(values);\n        vst1q_s16(dst + i, vresult);\n    }\n    \n    for (; i < length; i++) {\n        int16_t x = src[i];\n        int16_t q = x / base16;\n        int16_t candidate = q * base16;\n        if (x < 0 && candidate > x) {\n            candidate -= base16;\n        }\n        dst[i] = candidate;\n    }\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        bool match = true;\n        size_t j = 0;\n\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t row_vec = vld1q_f64(row_ptr + j);\n            float64x2_t vec_vec = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(row_vec, vec_vec);\n            \n            uint64_t lane0 = vgetq_lane_u64(cmp, 0);\n            uint64_t lane1 = vgetq_lane_u64(cmp, 1);\n            \n            if (lane0 != UINT64_MAX || lane1 != UINT64_MAX) {\n                match = false;\n                break;\n            }\n        }\n\n        if (match && (cols % 2 != 0)) {\n            if (row_ptr[cols - 1] != vector[cols - 1]) {\n                match = false;\n            }\n        }\n\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        bool match = true;\n        size_t col = 0;\n        \n        // Process two elements at a time\n        for (; col + 1 < cols; col += 2) {\n            float64x2_t v_row = vld1q_f64(row_ptr + col);\n            float64x2_t v_vec = vld1q_f64(vector + col);\n            uint64x2_t v_cmp = vceqq_f64(v_row, v_vec);\n            \n            uint64_t cmp0 = vgetq_lane_u64(v_cmp, 0);\n            uint64_t cmp1 = vgetq_lane_u64(v_cmp, 1);\n            if (cmp0 != ~0ULL || cmp1 != ~0ULL) {\n                match = false;\n                break;\n            }\n        }\n        \n        // Check last element if cols is odd\n        if (match && col < cols) {\n            if (row_ptr[col] != vector[col]) {\n                match = false;\n            }\n        }\n        \n        if (match) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        bool row_matches = true;\n        size_t j = 0;\n        \n        uint64_t all_ones = ~(uint64_t)0;\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t mat_vec = vld1q_f64(row_ptr + j);\n            float64x2_t vec_vec = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(mat_vec, vec_vec);\n            uint64_t cmp0 = vgetq_lane_u64(cmp, 0);\n            uint64_t cmp1 = vgetq_lane_u64(cmp, 1);\n            \n            if (cmp0 != all_ones || cmp1 != all_ones) {\n                row_matches = false;\n                break;\n            }\n        }\n        \n        if (row_matches && j < cols) {\n            if (row_ptr[j] != vector[j]) {\n                row_matches = false;\n            }\n        }\n        \n        if (row_matches) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        bool match = true;\n        size_t j = 0;\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t a = vld1q_f64(row_ptr + j);\n            float64x2_t b = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(a, b);\n            uint64x1_t low = vget_low_u64(cmp);\n            uint64x1_t high = vget_high_u64(cmp);\n            uint64x1_t reduced = vand_u64(low, high);\n            unsigned long long reduced_val = vget_lane_u64(reduced, 0);\n            if (reduced_val != (unsigned long long)(-1)) {\n                match = false;\n                break;\n            }\n        }\n        if (match && j < cols) {\n            if (row_ptr[j] != vector[j]) {\n                match = false;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        bool match = true;\n        size_t j = 0;\n        \n        for (; j + 1 < cols; j += 2) {\n            float64x2_t a = vld1q_f64(row_ptr + j);\n            float64x2_t b = vld1q_f64(vector + j);\n            uint64x2_t cmp = vceqq_f64(a, b);\n            uint64_t l0 = vgetq_lane_u64(cmp, 0);\n            uint64_t l1 = vgetq_lane_u64(cmp, 1);\n            \n            if (l0 != UINT64_MAX || l1 != UINT64_MAX) {\n                match = false;\n                break;\n            }\n        }\n        \n        if (match && j < cols) {\n            if (row_ptr[j] != vector[j]) {\n                match = false;\n            }\n        }\n        \n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n    \n    const uint8_t* a_ptr = A;\n    const uint8_t* b_ptr = B;\n    \n    for (; i + 15 < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(a_ptr);\n        uint8x16_t b_vec = vld1q_u8(b_ptr);\n        uint8x16_t cmp = vceqq_u8(a_vec, b_vec);\n        uint8x16_t popcnt = vcntq_u8(cmp);\n        uint32_t total_bits = vaddvq_u8(popcnt);\n        count += total_bits >> 3;\n        a_ptr += 16;\n        b_ptr += 16;\n    }\n    \n    for (; i < total_elements; i++) {\n        if (*a_ptr++ == *b_ptr++) {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t cnt = 0;\n\n    for (; i + 15 < total; i += 16) {\n        uint8x16_t vA = vld1q_u8(A + i);\n        uint8x16_t vB = vld1q_u8(B + i);\n        uint8x16_t cmp = vceqq_u8(vA, vB);\n        cmp = vshrq_n_u8(cmp, 7);\n        uint16x8_t sum16 = vpaddlq_u8(cmp);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n\n        cnt += vgetq_lane_u32(sum32, 0);\n        cnt += vgetq_lane_u32(sum32, 1);\n        cnt += vgetq_lane_u32(sum32, 2);\n        cnt += vgetq_lane_u32(sum32, 3);\n    }\n\n    for (; i < total; i++) {\n        if (A[i] == B[i]) {\n            cnt++;\n        }\n    }\n\n    return cnt;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n\n    for (; i + 15 < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t cmp = vceqq_u8(a_vec, b_vec);\n        uint8x16_t ones = vshrq_n_u8(cmp, 7);\n        count += vaddvq_u8(ones);\n    }\n\n    for (; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t count = 0;\n\n    for (; i + 15 < total_elements; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t cmp = vceqq_u8(a_vec, b_vec);\n        uint8x16_t ones = vshrq_n_u8(cmp, 7);\n\n        uint16x8_t sum16 = vpaddlq_u8(ones);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        uint32_t sum_part = 0;\n        sum_part += vgetq_lane_u32(sum32, 0);\n        sum_part += vgetq_lane_u32(sum32, 1);\n        sum_part += vgetq_lane_u32(sum32, 2);\n        sum_part += vgetq_lane_u32(sum32, 3);\n        \n        count += sum_part;\n    }\n\n    for (; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_Neon", "completion": "```c\n#include <arm_neon.h>\n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t i = 0;\n    const size_t block_size = 16;\n    const size_t vectorized_end = total_elements & ~(block_size - 1);\n\n    for (; i < vectorized_end; i += block_size) {\n        uint8x16_t a_vec = vld1q_u8(A + i);\n        uint8x16_t b_vec = vld1q_u8(B + i);\n        uint8x16_t cmp_vec = vceqq_u8(a_vec, b_vec);\n        cmp_vec = vshrq_n_u8(cmp_vec, 7);\n        count += vaddvq_u8(cmp_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t a_vec = vdupq_n_s64(a);\n    size_t end = length & ~(size_t)1;\n    for (size_t i = 0; i < end; i += 2) {\n        int64x2_t x_vec = vld1q_s64(x + i);\n        int64x2_t y_vec = vld1q_s64(y + i);\n        int64x2_t ax = vmulq_s64(a_vec, x_vec);\n        int64x2_t abs_y = vabsq_s64(y_vec);\n        int64x2_t res = vsubq_s64(ax, abs_y);\n        vst1q_s64(y + i, res);\n    }\n    if (length & 1) {\n        int64_t temp = y[end];\n        int64_t abs_y = (temp < 0) ? -temp : temp;\n        y[end] = a * x[end] - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        int64x2_t x_vec = vld1q_s64(x + i);\n        int64x2_t y_vec = vld1q_s64(y + i);\n        int64_t x0 = vgetq_lane_s64(x_vec, 0);\n        int64_t x1 = vgetq_lane_s64(x_vec, 1);\n        int64_t p0 = a * x0;\n        int64_t p1 = a * x1;\n        int64x2_t prod_vec = (int64x2_t){p0, p1};\n        y_vec = vabsq_s64(y_vec);\n        y_vec = vsubq_s64(y_vec, prod_vec);\n        vst1q_s64(y + i, y_vec);\n    }\n    if (i < length) {\n        int64_t temp = y[i];\n        y[i] = (temp < 0 ? -temp : temp) - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    int64x2_t a_vec = vdupq_n_s64(a);\n    size_t i = 0;\n    \n    for (; i + 1 < length; i += 2) {\n        int64x2_t x_vec = vld1q_s64(x + i);\n        int64x2_t y_vec = vld1q_s64(y + i);\n        int64x2_t product = vmulq_s64(a_vec, x_vec);\n        int64x2_t abs_y = vabsq_s64(y_vec);\n        int64x2_t result = vsubq_s64(abs_y, product);\n        vst1q_s64(y + i, result);\n    }\n\n    for (; i < length; ++i) {\n        int64_t abs_val = y[i] < 0 ? -y[i] : y[i];\n        y[i] = abs_val - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    const int64x2_t va = vdupq_n_s64(a);\n    const size_t simd_end = length & ~1;\n    \n    for (; i < simd_end; i += 2) {\n        int64x2_t vx = vld1q_s64(x + i);\n        int64x2_t vy = vld1q_s64(y + i);\n        int64x2_t vax = vmulq_s64(vx, va);\n        int64x2_t vabs_y = vabsq_s64(vy);\n        int64x2_t vres = vsubq_s64(vabs_y, vax);\n        vst1q_s64(y + i, vres);\n    }\n\n    for (; i < length; ++i) {\n        int64_t abs_y = y[i] < 0 ? -y[i] : y[i];\n        y[i] = abs_y - a * x[i];\n    }\n}\n```"}
{"task_id": "SimdBench_34_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    if (length == 0) {\n        return;\n    }\n\n    int64x2_t a_vec = vdupq_n_s64(a);\n    size_t pairs = length / 2;\n\n    for (size_t i = 0; i < pairs; ++i) {\n        int64x2_t x_vec = vld1q_s64(x);\n        int64x2_t y_vec = vld1q_s64(y);\n        int64x2_t ax_vec = vmulq_s64(a_vec, x_vec);\n        int64x2_t abs_y_vec = vabsq_s64(y_vec);\n        int64x2_t result = vsubq_s64(abs_y_vec, ax_vec);\n        vst1q_s64(y, result);\n        x += 2;\n        y += 2;\n    }\n\n    if (length % 2 != 0) {\n        int64_t abs_y = *y < 0 ? -*y : *y;\n        *y = abs_y - a * *x;\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t vmin = vdupq_n_s16(32767);\n    int16x8_t vmax = vdupq_n_s16(-32768);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        int16x8_t v = vld1q_s16(vec + i);\n        vmin = vminq_s16(vmin, v);\n        vmax = vmaxq_s16(vmax, v);\n    }\n\n    int16x4_t min_low = vget_low_s16(vmin);\n    int16x4_t min_high = vget_high_s16(vmin);\n    int16x4_t min_reduced = vpmin_s16(min_low, min_high);\n    min_reduced = vpmin_s16(min_reduced, min_reduced);\n    min_reduced = vpmin_s16(min_reduced, min_reduced);\n    int16_t min_val = vget_lane_s16(min_reduced, 0);\n\n    int16x4_t max_low = vget_low_s16(vmax);\n    int16x4_t max_high = vget_high_s16(vmax);\n    int16x4_t max_reduced = vpmax_s16(max_low, max_high);\n    max_reduced = vpmax_s16(max_reduced, max_reduced);\n    max_reduced = vpmax_s16(max_reduced, max_reduced);\n    int16_t max_val = vget_lane_s16(max_reduced, 0);\n\n    for (; i < length; i++) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_vals = vdupq_n_s16(INT16_MAX);\n    int16x8_t max_vals = vdupq_n_s16(INT16_MIN);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        int16x8_t chunk = vld1q_s16(vec + i);\n        min_vals = vminq_s16(min_vals, chunk);\n        max_vals = vmaxq_s16(max_vals, chunk);\n    }\n\n    if (i < length) {\n        size_t remaining = length - i;\n        int16_t buf_min[8];\n        int16_t buf_max[8];\n        size_t j;\n        for (j = 0; j < remaining; j++) {\n            int16_t val = vec[i + j];\n            buf_min[j] = val;\n            buf_max[j] = val;\n        }\n        for (; j < 8; j++) {\n            buf_min[j] = INT16_MAX;\n            buf_max[j] = INT16_MIN;\n        }\n        int16x8_t tail_min = vld1q_s16(buf_min);\n        int16x8_t tail_max = vld1q_s16(buf_max);\n        min_vals = vminq_s16(min_vals, tail_min);\n        max_vals = vmaxq_s16(max_vals, tail_max);\n    }\n\n    int16_t min_val = vminvq_s16(min_vals);\n    int16_t max_val = vmaxvq_s16(max_vals);\n\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16x8_t min_vals = vdupq_n_s16(32767);\n    int16x8_t max_vals = vdupq_n_s16(-32768);\n    size_t i = 0;\n\n    for (; i + 8 <= length; i += 8) {\n        int16x8_t chunk = vld1q_s16(vec + i);\n        min_vals = vminq_s16(min_vals, chunk);\n        max_vals = vmaxq_s16(max_vals, chunk);\n    }\n\n    int16x4_t low_min = vget_low_s16(min_vals);\n    int16x4_t high_min = vget_high_s16(min_vals);\n    int16x4_t min_reduced = vpmin_s16(low_min, high_min);\n    min_reduced = vpmin_s16(min_reduced, min_reduced);\n    min_reduced = vpmin_s16(min_reduced, min_reduced);\n    int16_t min_val = vget_lane_s16(min_reduced, 0);\n\n    int16x4_t low_max = vget_low_s16(max_vals);\n    int16x4_t high_max = vget_high_s16(max_vals);\n    int16x4_t max_reduced = vpmax_s16(low_max, high_max);\n    max_reduced = vpmax_s16(max_reduced, max_reduced);\n    max_reduced = vpmax_s16(max_reduced, max_reduced);\n    int16_t max_val = vget_lane_s16(max_reduced, 0);\n\n    for (; i < length; i++) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    return (MinMaxPair){min_val, max_val};\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    if (length < 8) {\n        int16_t min_val = vec[0];\n        int16_t max_val = vec[0];\n        for (size_t i = 1; i < length; i++) {\n            if (vec[i] < min_val) min_val = vec[i];\n            if (vec[i] > max_val) max_val = vec[i];\n        }\n        return (MinMaxPair){min_val, max_val};\n    } else {\n        int16x8_t min_vec = vld1q_s16(vec);\n        int16x8_t max_vec = min_vec;\n        size_t i = 8;\n\n        for (; i <= length - 8; i += 8) {\n            int16x8_t chunk = vld1q_s16(vec + i);\n            min_vec = vminq_s16(min_vec, chunk);\n            max_vec = vmaxq_s16(max_vec, chunk);\n        }\n\n        int16x4_t min_low = vget_low_s16(min_vec);\n        int16x4_t min_high = vget_high_s16(min_vec);\n        int16x4_t min_reduced = vpmin_s16(min_low, min_high);\n        min_reduced = vpmin_s16(min_reduced, min_reduced);\n        min_reduced = vpmin_s16(min_reduced, min_reduced);\n        int16_t min_val = vget_lane_s16(min_reduced, 0);\n\n        int16x4_t max_low = vget_low_s16(max_vec);\n        int16x4_t max_high = vget_high_s16(max_vec);\n        int16x4_t max_reduced = vpmax_s16(max_low, max_high);\n        max_reduced = vpmax_s16(max_reduced, max_reduced);\n        max_reduced = vpmax_s16(max_reduced, max_reduced);\n        int16_t max_val = vget_lane_s16(max_reduced, 0);\n\n        for (; i < length; i++) {\n            if (vec[i] < min_val) min_val = vec[i];\n            if (vec[i] > max_val) max_val = vec[i];\n        }\n\n        return (MinMaxPair){min_val, max_val};\n    }\n}\n```"}
{"task_id": "SimdBench_35_Neon", "completion": "```c\n#include <arm_neon.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    if (length < 8) {\n        int16_t min_val = vec[0];\n        int16_t max_val = vec[0];\n        for (size_t i = 1; i < length; i++) {\n            if (vec[i] < min_val) min_val = vec[i];\n            if (vec[i] > max_val) max_val = vec[i];\n        }\n        result.min_num = min_val;\n        result.max_num = max_val;\n        return result;\n    }\n\n    int16x8_t min_vec = vld1q_s16(vec);\n    int16x8_t max_vec = min_vec;\n    size_t i = 8;\n\n    while (i <= length - 8) {\n        int16x8_t chunk = vld1q_s16(vec + i);\n        min_vec = vminq_s16(min_vec, chunk);\n        max_vec = vmaxq_s16(max_vec, chunk);\n        i += 8;\n    }\n\n    int16_t min_val = vminvq_s16(min_vec);\n    int16_t max_val = vmaxvq_s16(max_vec);\n\n    for (; i < length; i++) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        if (cols == 1) {\n            continue;\n        }\n        size_t n = cols - 1;\n        size_t j = 0;\n\n        while (j + 4 <= n) {\n            int32x4_t v0 = vld1q_s32(row_ptr + j);\n            int32x4_t v1 = vld1q_s32(row_ptr + j + 1);\n            uint32x4_t cmp = vcltq_s32(v0, v1);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n            j += 4;\n        }\n\n        for (; j < n; j++) {\n            if (row_ptr[j] >= row_ptr[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        if (cols == 1) {\n            continue;\n        }\n        \n        size_t pairs = cols - 1;\n        size_t j = 0;\n        \n        while (j + 4 <= pairs) {\n            int32x4_t current = vld1q_s32(row_ptr + j);\n            int32x4_t next = vld1q_s32(row_ptr + j + 1);\n            uint32x4_t cmp = vcltq_s32(current, next);\n            uint32_t min_val = vminvq_u32(cmp);\n            if (min_val == 0) {\n                return false;\n            }\n            j += 4;\n        }\n        \n        while (j < pairs) {\n            if (row_ptr[j] >= row_ptr[j + 1]) {\n                return false;\n            }\n            j++;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        size_t num_pairs = cols - 1;\n        size_t j = 0;\n\n        size_t vec_steps = num_pairs / 4;\n        for (size_t k = 0; k < vec_steps; k++) {\n            int32x4_t current = vld1q_s32(row + j);\n            int32x4_t next = vld1q_s32(row + j + 1);\n            uint32x4_t cmp = vcltq_s32(current, next);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n            j += 4;\n        }\n\n        while (j < num_pairs) {\n            if (row[j] >= row[j + 1]) {\n                return false;\n            }\n            j++;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        size_t n = cols - 1;\n\n        if (n == 0) {\n            continue;\n        }\n\n        size_t j = 0;\n\n        while (j + 4 <= n) {\n            int32x4_t v0 = vld1q_s32(row_ptr + j);\n            int32x4_t v1 = vld1q_s32(row_ptr + j + 1);\n            uint32x4_t cmp = vcltq_s32(v0, v1);\n            if (vminvq_u32(cmp) == 0) {\n                return false;\n            }\n            j += 4;\n        }\n\n        while (j < n) {\n            if (row_ptr[j] >= row_ptr[j + 1]) {\n                return false;\n            }\n            j++;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        if (cols == 1) {\n            continue;\n        }\n\n        size_t pairs = cols - 1;\n        size_t j = 0;\n\n        for (; j + 4 <= pairs; j += 4) {\n            int32x4_t current = vld1q_s32(row_ptr + j);\n            int32x4_t next = vld1q_s32(row_ptr + j + 1);\n            uint32x4_t cmp = vcltq_s32(current, next);\n            uint32_t min_val = vminvq_u32(cmp);\n            if (min_val == 0) {\n                return false;\n            }\n        }\n\n        for (; j < pairs; j++) {\n            if (row_ptr[j] >= row_ptr[j + 1]) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    \n    size_t num_blocks_rows = rows / block_size;\n    size_t num_blocks_cols = cols / block_size;\n    \n    for (size_t block_i = 0; block_i < num_blocks_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < num_blocks_cols; ++block_j) {\n            if (block_i == 0 && block_j == 0) continue;\n            \n            for (size_t r = 0; r < block_size; ++r) {\n                const int* first_row = matrix + r * cols;\n                const int* current_row = matrix + (block_i * block_size + r) * cols + block_j * block_size;\n                \n                size_t c = 0;\n                for (; c + 4 <= block_size; c += 4) {\n                    uint32x4_t v_first = vld1q_u32((const uint32_t*)(first_row + c));\n                    uint32x4_t v_curr = vld1q_u32((const uint32_t*)(current_row + c));\n                    uint32x4_t v_cmp = vceqq_u32(v_first, v_curr);\n                    \n                    uint32x2_t low = vget_low_u32(v_cmp);\n                    uint32x2_t high = vget_high_u32(v_cmp);\n                    uint32x2_t min_vec = vpmin_u32(low, high);\n                    min_vec = vpmin_u32(min_vec, min_vec);\n                    if (vget_lane_u32(min_vec, 0) == 0) {\n                        return false;\n                    }\n                }\n                \n                for (; c < block_size; ++c) {\n                    if (first_row[c] != current_row[c]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    for (size_t i_block = 0; i_block < num_block_rows; i_block++) {\n        for (size_t j_block = 0; j_block < num_block_cols; j_block++) {\n            if (i_block == 0 && j_block == 0) {\n                continue;\n            }\n\n            for (size_t r = 0; r < block_size; r++) {\n                const int* ref_row = matrix + r * cols;\n                const int* cur_row = matrix + (i_block * block_size + r) * cols + j_block * block_size;\n                size_t c = 0;\n\n                for (; c + 4 <= block_size; c += 4) {\n                    uint32x4_t ref_vec = vld1q_u32((const uint32_t*)(ref_row + c));\n                    uint32x4_t cur_vec = vld1q_u32((const uint32_t*)(cur_row + c));\n                    uint32x4_t cmp_vec = vceqq_u32(ref_vec, cur_vec);\n                    if (vminvq_u32(cmp_vec) != 0xFFFFFFFF) {\n                        return false;\n                    }\n                }\n\n                for (; c < block_size; c++) {\n                    if (ref_row[c] != cur_row[c]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0) return false;\n    if (rows % block_size != 0 || cols % block_size != 0) return false;\n    if (rows == 0 || cols == 0) return true;\n\n    for (size_t block_i = 0; block_i < rows; block_i += block_size) {\n        for (size_t block_j = 0; block_j < cols; block_j += block_size) {\n            if (block_i == 0 && block_j == 0) continue;\n            \n            for (size_t i = 0; i < block_size; i++) {\n                const int* ref_row = matrix + i * cols;\n                const int* cur_row = matrix + (block_i + i) * cols + block_j;\n                \n                size_t j = 0;\n                for (; j + 3 < block_size; j += 4) {\n                    int32x4_t ref_vec = vld1q_s32(ref_row + j);\n                    int32x4_t cur_vec = vld1q_s32(cur_row + j);\n                    uint32x4_t cmp = vceqq_s32(ref_vec, cur_vec);\n                    if (vminvq_u32(cmp) == 0) {\n                        return false;\n                    }\n                }\n                \n                for (; j < block_size; j++) {\n                    if (ref_row[j] != cur_row[j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n\n    for (size_t i_block = 0; i_block < num_block_rows; i_block++) {\n        for (size_t j_block = 0; j_block < num_block_cols; j_block++) {\n            if (i_block == 0 && j_block == 0) {\n                continue;\n            }\n\n            for (size_t i_in_block = 0; i_in_block < block_size; i_in_block++) {\n                const int* current_row = matrix + (i_block * block_size + i_in_block) * cols + j_block * block_size;\n                const int* ref_row = matrix + i_in_block * cols;\n                size_t offset = 0;\n\n                for (; offset + 4 <= block_size; offset += 4) {\n                    int32x4_t v1 = vld1q_s32(current_row + offset);\n                    int32x4_t v2 = vld1q_s32(ref_row + offset);\n                    uint32x4_t cmp = vceqq_s32(v1, v2);\n                    if (vminvq_u32(cmp) != 0xFFFFFFFF) {\n                        return false;\n                    }\n                }\n\n                for (; offset < block_size; offset++) {\n                    if (current_row[offset] != ref_row[offset]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t n_blocks_vert = rows / block_size;\n    size_t n_blocks_horiz = cols / block_size;\n\n    for (size_t i_block = 0; i_block < n_blocks_vert; i_block++) {\n        for (size_t j_block = 0; j_block < n_blocks_horiz; j_block++) {\n            if (i_block == 0 && j_block == 0) {\n                continue;\n            }\n\n            const int* block_start = matrix + (i_block * block_size) * cols + j_block * block_size;\n\n            for (size_t r = 0; r < block_size; r++) {\n                const int* ref_row = matrix + r * cols;\n                const int* cur_row = block_start + r * cols;\n                size_t j = 0;\n\n                for (; j + 3 < block_size; j += 4) {\n                    uint32x4_t v_ref = vld1q_u32((const uint32_t*)(ref_row + j));\n                    uint32x4_t v_cur = vld1q_u32((const uint32_t*)(cur_row + j));\n                    uint32x4_t v_cmp = vceqq_u32(v_ref, v_cur);\n                    if (vminvq_u32(v_cmp) == 0) {\n                        return false;\n                    }\n                }\n\n                for (; j < block_size; j++) {\n                    if (ref_row[j] != cur_row[j]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    if (tolerance < 0.0 || tolerance != tolerance) {\n        return false;\n    }\n\n    size_t num_blocks = length / block_size;\n    if (num_blocks <= 1) {\n        return true;\n    }\n\n    const double* base_block = vec;\n\n    for (size_t i = 1; i < num_blocks; i++) {\n        const double* current_block = vec + i * block_size;\n        size_t j = 0;\n        for (; j + 1 < block_size; j += 2) {\n            float64x2_t base_vec = vld1q_f64(base_block + j);\n            float64x2_t current_vec = vld1q_f64(current_block + j);\n\n            uint64x2_t base_valid = vceqq_f64(base_vec, base_vec);\n            uint64x2_t current_valid = vceqq_f64(current_vec, current_vec);\n            uint64x2_t both_valid = vandq_u64(base_valid, current_valid);\n\n            uint64_t low_valid = vgetq_lane_u64(both_valid, 0);\n            uint64_t high_valid = vgetq_lane_u64(both_valid, 1);\n            if (low_valid != (uint64_t)-1 || high_valid != (uint64_t)-1) {\n                return false;\n            }\n\n            float64x2_t abs_diff = vabdq_f64(base_vec, current_vec);\n            float64x2_t tol_vec = vdupq_n_f64(tolerance);\n            uint64x2_t gt_mask = vcgtq_f64(abs_diff, tol_vec);\n\n            uint64_t low_gt = vgetq_lane_u64(gt_mask, 0);\n            uint64_t high_gt = vgetq_lane_u64(gt_mask, 1);\n            if (low_gt || high_gt) {\n                return false;\n            }\n        }\n\n        if (j < block_size) {\n            double a = base_block[j];\n            double b = current_block[j];\n            if (a != a || b != b) {\n                return false;\n            }\n            double diff = a - b;\n            if (diff < 0.0) {\n                diff = -diff;\n            }\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    \n    size_t n_blocks = length / block_size;\n    if (n_blocks < 2) {\n        return true;\n    }\n    \n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n    \n    for (size_t i = 1; i < n_blocks; ++i) {\n        const double* block0 = vec;\n        const double* block_i = vec + i * block_size;\n        size_t j = 0;\n        \n        for (; j + 1 < block_size; j += 2) {\n            float64x2_t b0 = vld1q_f64(block0 + j);\n            float64x2_t bi = vld1q_f64(block_i + j);\n            float64x2_t diff = vabsq_f64(vsubq_f64(b0, bi));\n            uint64x2_t cmp = vcgtq_f64(diff, tol_vec);\n            uint64_t cmp0 = vgetq_lane_u64(cmp, 0);\n            uint64_t cmp1 = vgetq_lane_u64(cmp, 1);\n            if (cmp0 || cmp1) {\n                return false;\n            }\n        }\n        \n        if (j < block_size) {\n            double a = block0[j];\n            double b = block_i[j];\n            double diff = a - b;\n            if (diff < 0) diff = -diff;\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0) {\n        return false;\n    }\n\n    size_t n_blocks = length / block_size;\n    if (n_blocks < 1) {\n        return false;\n    }\n\n    if (n_blocks == 1) {\n        return true;\n    }\n\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < n_blocks; ++i) {\n        const double* block0 = vec;\n        const double* block_i = vec + i * block_size;\n        size_t j = 0;\n\n        for (; j + 1 < block_size; j += 2) {\n            float64x2_t v0 = vld1q_f64(block0 + j);\n            float64x2_t v1 = vld1q_f64(block_i + j);\n            float64x2_t diff = vsubq_f64(v0, v1);\n            float64x2_t abs_diff = vabsq_f64(diff);\n            uint64x2_t cmp = vcgtq_f64(abs_diff, tol_vec);\n            uint64_t cmp0 = vgetq_lane_u64(cmp, 0);\n            uint64_t cmp1 = vgetq_lane_u64(cmp, 1);\n            if (cmp0 || cmp1) {\n                return false;\n            }\n        }\n\n        if (j < block_size) {\n            double a = block0[j];\n            double b = block_i[j];\n            double diff = a - b;\n            if (diff < 0) {\n                diff = -diff;\n            }\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t n_blocks = length / block_size;\n    if (n_blocks < 2) {\n        return true;\n    }\n\n    size_t vec_end = block_size & ~(size_t)1;\n    for (size_t i = 1; i < n_blocks; ++i) {\n        const double* block0 = vec;\n        const double* block_i = vec + i * block_size;\n        size_t j = 0;\n\n        for (; j < vec_end; j += 2) {\n            float64x2_t ref = vld1q_f64(block0 + j);\n            float64x2_t curr = vld1q_f64(block_i + j);\n            float64x2_t diff = vabdq_f64(ref, curr);\n            float64x2_t tol_vec = vdupq_n_f64(tolerance);\n            uint64x2_t cmp = vcgtq_f64(diff, tol_vec);\n\n            if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n                return false;\n            }\n        }\n\n        if (block_size % 2) {\n            float64x1_t ref_last = vld1_f64(block0 + j);\n            float64x1_t curr_last = vld1_f64(block_i + j);\n            float64x1_t diff_last = vabd_f64(ref_last, curr_last);\n            \n            if (vget_lane_f64(diff_last, 0) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n\n    size_t n_blocks = length / block_size;\n    if (n_blocks < 2) {\n        return true;\n    }\n\n    const double* first_block = vec;\n    float64x2_t tol_vec = vdupq_n_f64(tolerance);\n\n    for (size_t i = 1; i < n_blocks; ++i) {\n        const double* current_block = vec + i * block_size;\n        size_t j = 0;\n\n        while (j + 2 <= block_size) {\n            float64x2_t a = vld1q_f64(first_block + j);\n            float64x2_t b = vld1q_f64(current_block + j);\n            float64x2_t diff = vabdq_f64(a, b);\n            uint64x2_t cmp = vcgtq_f64(diff, tol_vec);\n            uint64_t res0 = vgetq_lane_u64(cmp, 0);\n            uint64_t res1 = vgetq_lane_u64(cmp, 1);\n            if (res0 || res1) {\n                return false;\n            }\n            j += 2;\n        }\n\n        while (j < block_size) {\n            double a = first_block[j];\n            double b = current_block[j];\n            double diff = a - b;\n            if (diff < 0) diff = -diff;\n            if (diff > tolerance) {\n                return false;\n            }\n            ++j;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        float64x2_t vsum = vdupq_n_f64(0.0);\n        size_t col = 0;\n\n        for (; col + 1 < cols; col += 2) {\n            float64x2_t v = vld1q_f64(row_ptr + col);\n            vsum = vmlaq_f64(vsum, v, v);\n        }\n\n        double sum = vgetq_lane_f64(vsum, 0) + vgetq_lane_f64(vsum, 1);\n\n        if (col < cols) {\n            double last_val = row_ptr[col];\n            sum += last_val * last_val;\n        }\n\n        double norm = std::sqrt(sum);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        size_t col = 0;\n\n        for (; col + 1 < cols; col += 2) {\n            float64x2_t data = vld1q_f64(row_ptr + col);\n            sum_vec = vmlaq_f64(sum_vec, data, data);\n        }\n\n        double total = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n\n        if (col < cols) {\n            total += row_ptr[col] * row_ptr[col];\n        }\n\n        double norm = std::sqrt(total);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        float64x2_t v_sq_sum = vdupq_n_f64(0.0);\n        size_t j = 0;\n        \n        for (; j + 1 < cols; j += 2) {\n            float64x2_t v_row = vld1q_f64(row_ptr + j);\n            float64x2_t v_sq = vmulq_f64(v_row, v_row);\n            v_sq_sum = vaddq_f64(v_sq_sum, v_sq);\n        }\n        \n        double sq_sum = vgetq_lane_f64(v_sq_sum, 0) + vgetq_lane_f64(v_sq_sum, 1);\n        \n        if (j < cols) {\n            double last_val = row_ptr[j];\n            sq_sum += last_val * last_val;\n        }\n        \n        double norm = std::sqrt(sq_sum);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_ptr = matrix + i * cols;\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        double tail_sum = 0.0;\n        size_t j = 0;\n\n        for (; j + 1 < cols; j += 2) {\n            float64x2_t data = vld1q_f64(row_ptr + j);\n            sum_vec = vmlaq_f64(sum_vec, data, data);\n        }\n\n        if (j < cols) {\n            tail_sum = row_ptr[j] * row_ptr[j];\n        }\n\n        double total_sum = vaddvq_f64(sum_vec) + tail_sum;\n        float64x1_t total_sum_scalar = vdup_n_f64(total_sum);\n        float64x1_t norm_scalar = vsqrt_f64(total_sum_scalar);\n        double norm = vget_lane_f64(norm_scalar, 0);\n\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        float64x2_t sum_vec = vdupq_n_f64(0.0);\n        size_t col = 0;\n\n        for (; col + 1 < cols; col += 2) {\n            float64x2_t data = vld1q_f64(row_ptr + col);\n            sum_vec = vmlaq_f64(sum_vec, data, data);\n        }\n\n        double sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n\n        if (cols & 1) {\n            double last = row_ptr[col];\n            sum += last * last;\n        }\n\n        double thresh = thresholds[i];\n        if (thresh < 0.0) {\n            result[i] = true;\n        } else {\n            double thresh_sq = thresh * thresh;\n            result[i] = sum > thresh_sq;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    const size_t neon_iters = length / step;\n    \n    for (; i < neon_iters * step; i += step) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t b_vec = vld1q_u32(B + i);\n        uint32x4_t c_vec = vorrq_u32(a_vec, b_vec);\n        vst1q_u32(C + i, c_vec);\n    }\n    \n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t vector_size = 4;\n    size_t end_vector = length - (length % vector_size);\n\n    for (; i < end_vector; i += vector_size) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t b_vec = vld1q_u32(B + i);\n        uint32x4_t result = vorrq_u32(a_vec, b_vec);\n        vst1q_u32(C + i, result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    size_t blocks = length / step;\n\n    for (; i < blocks * step; i += step) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t b_vec = vld1q_u32(B + i);\n        uint32x4_t c_vec = vorrq_u32(a_vec, b_vec);\n        vst1q_u32(C + i, c_vec);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    const size_t neon_iters = length / step;\n\n    for (; i < neon_iters * step; i += step) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t b_vec = vld1q_u32(B + i);\n        uint32x4_t c_vec = vorrq_u32(a_vec, b_vec);\n        vst1q_u32(C + i, c_vec);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 4;\n    const size_t neon_iters = length / step;\n\n    for (; i < neon_iters * step; i += step) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t b_vec = vld1q_u32(B + i);\n        uint32x4_t result = vorrq_u32(a_vec, b_vec);\n        vst1q_u32(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int32x4_t v_acc_sqA = vdupq_n_s32(0);\n    int32x4_t v_acc_sqB = vdupq_n_s32(0);\n    int32x4_t v_acc_AB = vdupq_n_s32(0);\n    \n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n        \n        int8x8_t va_low = vget_low_s8(va);\n        int8x8_t va_high = vget_high_s8(va);\n        int16x8_t a_sq_low = vmull_s8(va_low, va_low);\n        int16x8_t a_sq_high = vmull_s8(va_high, va_high);\n        v_acc_sqA = vpadalq_s16(v_acc_sqA, a_sq_low);\n        v_acc_sqA = vpadalq_s16(v_acc_sqA, a_sq_high);\n        \n        int8x8_t vb_low = vget_low_s8(vb);\n        int8x8_t vb_high = vget_high_s8(vb);\n        int16x8_t b_sq_low = vmull_s8(vb_low, vb_low);\n        int16x8_t b_sq_high = vmull_s8(vb_high, vb_high);\n        v_acc_sqB = vpadalq_s16(v_acc_sqB, b_sq_low);\n        v_acc_sqB = vpadalq_s16(v_acc_sqB, b_sq_high);\n        \n        int16x8_t ab_low = vmull_s8(va_low, vb_low);\n        int16x8_t ab_high = vmull_s8(va_high, vb_high);\n        v_acc_AB = vpadalq_s16(v_acc_AB, ab_low);\n        v_acc_AB = vpadalq_s16(v_acc_AB, ab_high);\n    }\n    \n    int32_t sum_sqA = vgetq_lane_s32(v_acc_sqA, 0) +\n                      vgetq_lane_s32(v_acc_sqA, 1) +\n                      vgetq_lane_s32(v_acc_sqA, 2) +\n                      vgetq_lane_s32(v_acc_sqA, 3);\n    int32_t sum_sqB = vgetq_lane_s32(v_acc_sqB, 0) +\n                      vgetq_lane_s32(v_acc_sqB, 1) +\n                      vgetq_lane_s32(v_acc_sqB, 2) +\n                      vgetq_lane_s32(v_acc_sqB, 3);\n    int32_t sum_AB = vgetq_lane_s32(v_acc_AB, 0) +\n                     vgetq_lane_s32(v_acc_AB, 1) +\n                     vgetq_lane_s32(v_acc_AB, 2) +\n                     vgetq_lane_s32(v_acc_AB, 3);\n    \n    int64_t total_sqA = sum_sqA;\n    int64_t total_sqB = sum_sqB;\n    int64_t total_AB = sum_AB;\n    \n    for (; i < length; i++) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        total_sqA += (int64_t)a * a;\n        total_sqB += (int64_t)b * b;\n        total_AB += (int64_t)a * b;\n    }\n    \n    return total_sqA + total_sqB - 2 * total_AB;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int32x4_t acc_sq = vdupq_n_s32(0);\n    int32x4_t acc_ab = vdupq_n_s32(0);\n    \n    size_t i = 0;\n    const size_t step = 16;\n    size_t full_chunks = length / step;\n    \n    for (; i < full_chunks * step; i += step) {\n        int8x16_t A_vec = vld1q_s8(A + i);\n        int8x16_t B_vec = vld1q_s8(B + i);\n        \n        int16x8_t A_low = vmovl_s8(vget_low_s8(A_vec));\n        int16x8_t A_high = vmovl_s8(vget_high_s8(A_vec));\n        int16x8_t B_low = vmovl_s8(vget_low_s8(B_vec));\n        int16x8_t B_high = vmovl_s8(vget_high_s8(B_vec));\n        \n        int16x8_t A_sq_low = vmulq_s16(A_low, A_low);\n        int16x8_t A_sq_high = vmulq_s16(A_high, A_high);\n        int16x8_t AB_low = vmulq_s16(A_low, B_low);\n        int16x8_t AB_high = vmulq_s16(A_high, B_high);\n        \n        int32x4_t sq0 = vmovl_s16(vget_low_s16(A_sq_low));\n        int32x4_t sq1 = vmovl_s16(vget_high_s16(A_sq_low));\n        int32x4_t sq2 = vmovl_s16(vget_low_s16(A_sq_high));\n        int32x4_t sq3 = vmovl_s16(vget_high_s16(A_sq_high));\n        \n        int32x4_t ab0 = vmovl_s16(vget_low_s16(AB_low));\n        int32x4_t ab1 = vmovl_s16(vget_high_s16(AB_low));\n        int32x4_t ab2 = vmovl_s16(vget_low_s16(AB_high));\n        int32x4_t ab3 = vmovl_s16(vget_high_s16(AB_high));\n        \n        sq0 = vaddq_s32(sq0, sq1);\n        sq2 = vaddq_s32(sq2, sq3);\n        sq0 = vaddq_s32(sq0, sq2);\n        acc_sq = vaddq_s32(acc_sq, sq0);\n        \n        ab0 = vaddq_s32(ab0, ab1);\n        ab2 = vaddq_s32(ab2, ab3);\n        ab0 = vaddq_s32(ab0, ab2);\n        acc_ab = vaddq_s32(acc_ab, ab0);\n    }\n    \n    int64_t total_sq = 0;\n    total_sq += (int64_t)vgetq_lane_s32(acc_sq, 0);\n    total_sq += (int64_t)vgetq_lane_s32(acc_sq, 1);\n    total_sq += (int64_t)vgetq_lane_s32(acc_sq, 2);\n    total_sq += (int64_t)vgetq_lane_s32(acc_sq, 3);\n    \n    int64_t total_ab = 0;\n    total_ab += (int64_t)vgetq_lane_s32(acc_ab, 0);\n    total_ab += (int64_t)vgetq_lane_s32(acc_ab, 1);\n    total_ab += (int64_t)vgetq_lane_s32(acc_ab, 2);\n    total_ab += (int64_t)vgetq_lane_s32(acc_ab, 3);\n    \n    for (; i < length; i++) {\n        total_sq += (int64_t)A[i] * (int64_t)A[i];\n        total_ab += (int64_t)A[i] * (int64_t)B[i];\n    }\n    \n    return total_sq - total_ab;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total_sq = 0;\n    int64_t total_prod = 0;\n    size_t i = 0;\n\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t a16 = vld1q_s8(A + i);\n        int8x16_t b16 = vld1q_s8(B + i);\n\n        int8x8_t a_low = vget_low_s8(a16);\n        int8x8_t a_high = vget_high_s8(a16);\n        int8x8_t b_low = vget_low_s8(b16);\n        int8x8_t b_high = vget_high_s8(b16);\n\n        int16x8_t sq_low = vmull_s8(a_low, a_low);\n        int16x8_t sq_high = vmull_s8(a_high, a_high);\n        int16x8_t prod_low = vmull_s8(a_low, b_low);\n        int16x8_t prod_high = vmull_s8(a_high, b_high);\n\n        total_sq += (int64_t)vaddlvq_s16(sq_low) + (int64_t)vaddlvq_s16(sq_high);\n        total_prod += (int64_t)vaddlvq_s16(prod_low) + (int64_t)vaddlvq_s16(prod_high);\n    }\n\n    for (; i < length; i++) {\n        total_sq += (int64_t)A[i] * (int64_t)A[i];\n        total_prod += (int64_t)A[i] * (int64_t)B[i];\n    }\n\n    return total_sq - total_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int32x4_t sum_sq = vdupq_n_s32(0);\n    int32x4_t sum_prod = vdupq_n_s32(0);\n    size_t i = 0;\n\n    for (; i + 15 < length; i += 16) {\n        int8x16_t a_vec = vld1q_s8(A + i);\n        int8x16_t b_vec = vld1q_s8(B + i);\n\n        int16x8_t a_low = vmovl_s8(vget_low_s8(a_vec));\n        int16x8_t a_high = vmovl_s8(vget_high_s8(a_vec));\n        int16x8_t b_low = vmovl_s8(vget_low_s8(b_vec));\n        int16x8_t b_high = vmovl_s8(vget_high_s8(b_vec));\n\n        int32x4_t sq0 = vmull_s16(vget_low_s16(a_low), vget_low_s16(a_low));\n        int32x4_t sq1 = vmull_s16(vget_high_s16(a_low), vget_high_s16(a_low));\n        int32x4_t sq2 = vmull_s16(vget_low_s16(a_high), vget_low_s16(a_high));\n        int32x4_t sq3 = vmull_s16(vget_high_s16(a_high), vget_high_s16(a_high));\n\n        int32x4_t prod0 = vmull_s16(vget_low_s16(a_low), vget_low_s16(b_low));\n        int32x4_t prod1 = vmull_s16(vget_high_s16(a_low), vget_high_s16(b_low));\n        int32x4_t prod2 = vmull_s16(vget_low_s16(a_high), vget_low_s16(b_high));\n        int32x4_t prod3 = vmull_s16(vget_high_s16(a_high), vget_high_s16(b_high));\n\n        sum_sq = vaddq_s32(sum_sq, sq0);\n        sum_sq = vaddq_s32(sum_sq, sq1);\n        sum_sq = vaddq_s32(sum_sq, sq2);\n        sum_sq = vaddq_s32(sum_sq, sq3);\n\n        sum_prod = vaddq_s32(sum_prod, prod0);\n        sum_prod = vaddq_s32(sum_prod, prod1);\n        sum_prod = vaddq_s32(sum_prod, prod2);\n        sum_prod = vaddq_s32(sum_prod, prod3);\n    }\n\n    int64x2_t sq_long = vpaddlq_s32(sum_sq);\n    int64_t total_sq = vgetq_lane_s64(sq_long, 0) + vgetq_lane_s64(sq_long, 1);\n\n    int64x2_t prod_long = vpaddlq_s32(sum_prod);\n    int64_t total_prod = vgetq_lane_s64(prod_long, 0) + vgetq_lane_s64(prod_long, 1);\n\n    for (; i < length; i++) {\n        int8_t a_val = A[i];\n        int8_t b_val = B[i];\n        total_sq += (int64_t)a_val * a_val;\n        total_prod += (int64_t)a_val * b_val;\n    }\n\n    return total_sq - total_prod;\n}\n```"}
{"task_id": "SimdBench_41_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64x2_t v_sum_sq = vdupq_n_s64(0);\n    int64x2_t v_sum_prod = vdupq_n_s64(0);\n    size_t i = 0;\n\n    for (; i + 15 < length; i += 16) {\n        int8x16_t va = vld1q_s8(A + i);\n        int8x16_t vb = vld1q_s8(B + i);\n\n        int16x8_t va_low = vmovl_s8(vget_low_s8(va));\n        int16x8_t va_high = vmovl_s8(vget_high_s8(va));\n        int16x8_t vb_low = vmovl_s8(vget_low_s8(vb));\n        int16x8_t vb_high = vmovl_s8(vget_high_s8(vb));\n\n        int16x8_t sq_low = vmulq_s16(va_low, va_low);\n        int16x8_t sq_high = vmulq_s16(va_high, va_high);\n        int16x8_t prod_low = vmulq_s16(va_low, vb_low);\n        int16x8_t prod_high = vmulq_s16(va_high, vb_high);\n\n        v_sum_sq = vpadalq_s32(v_sum_sq, vpaddlq_s16(sq_low));\n        v_sum_sq = vpadalq_s32(v_sum_sq, vpaddlq_s16(sq_high));\n        v_sum_prod = vpadalq_s32(v_sum_prod, vpaddlq_s16(prod_low));\n        v_sum_prod = vpadalq_s32(v_sum_prod, vpaddlq_s16(prod_high));\n    }\n\n    int64_t total_sq = vgetq_lane_s64(v_sum_sq, 0) + vgetq_lane_s64(v_sum_sq, 1);\n    int64_t total_prod = vgetq_lane_s64(v_sum_prod, 0) + vgetq_lane_s64(v_sum_prod, 1);\n\n    for (; i < length; ++i) {\n        int8_t a = A[i];\n        total_sq += static_cast<int64_t>(a) * a;\n        total_prod += static_cast<int64_t>(a) * B[i];\n    }\n\n    return total_sq - total_prod;\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 2;\n\n    for (; i + step <= length; i += step) {\n        uint64x2_t a_vec = vld1q_u64(A + i);\n        uint64x2_t b_vec = vld1q_u64(B + i);\n        uint64x2_t not_b_vec = vmvnq_u64(b_vec);\n        uint64x2_t result = vandq_u64(a_vec, not_b_vec);\n        vst1q_u64(C + i, result);\n    }\n\n    for (; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a_vec = vld1q_u64(A + i);\n        uint64x2_t b_vec = vld1q_u64(B + i);\n        uint64x2_t result = vbicq_u64(a_vec, b_vec);\n        vst1q_u64(C + i, result);\n    }\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 1 < length; i += 2) {\n        uint64x2_t a_vec = vld1q_u64(A + i);\n        uint64x2_t b_vec = vld1q_u64(B + i);\n        uint64x2_t result = vbicq_u64(a_vec, b_vec);\n        vst1q_u64(C + i, result);\n    }\n    if (i < length) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 2;\n    const size_t neon_limit = length / step * step;\n\n    for (; i < neon_limit; i += step) {\n        uint64x2_t a_vec = vld1q_u64(A + i);\n        uint64x2_t b_vec = vld1q_u64(B + i);\n        uint64x2_t not_b_vec = vmvnq_u64(b_vec);\n        uint64x2_t result = vandq_u64(a_vec, not_b_vec);\n        vst1q_u64(C + i, result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    const size_t step = 2;\n    const size_t neon_limit = length / step * step;\n\n    for (; i < neon_limit; i += step) {\n        uint64x2_t a_vec = vld1q_u64(A + i);\n        uint64x2_t b_vec = vld1q_u64(B + i);\n        uint64x2_t not_b_vec = vmvnq_u64(b_vec);\n        uint64x2_t result = vandq_u64(a_vec, not_b_vec);\n        vst1q_u64(C + i, result);\n    }\n\n    for (; i < length; i++) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t vecA = vld1q_s8(A + i);\n        int8x16_t vecB = vld1q_s8(B + i);\n        int8x16_t zero = vdupq_n_s8(0);\n        \n        uint8x16_t A_positive = vcgtq_s8(vecA, zero);\n        uint8x16_t A_negative = vcltq_s8(vecA, zero);\n        uint8x16_t B_positive = vcgtq_s8(vecB, zero);\n        uint8x16_t B_negative = vcltq_s8(vecB, zero);\n        \n        uint8x16_t both_positive = vandq_u8(A_positive, B_positive);\n        uint8x16_t both_negative = vandq_u8(A_negative, B_negative);\n        \n        int8x16_t result = vbslq_s8(both_positive, vdupq_n_s8(1), zero);\n        result = vbslq_s8(both_negative, vdupq_n_s8(-1), result);\n        \n        vst1q_s8(C + i, result);\n    }\n    \n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    for (; i + 15 < length; i += 16) {\n        int8x16_t A_vec = vld1q_s8(A + i);\n        int8x16_t B_vec = vld1q_s8(B + i);\n        \n        uint8x16_t A_pos = vcgtq_s8(A_vec, vdupq_n_s8(0));\n        uint8x16_t B_pos = vcgtq_s8(B_vec, vdupq_n_s8(0));\n        uint8x16_t both_pos = vandq_u8(A_pos, B_pos);\n        \n        uint8x16_t A_neg = vcltq_s8(A_vec, vdupq_n_s8(0));\n        uint8x16_t B_neg = vcltq_s8(B_vec, vdupq_n_s8(0));\n        uint8x16_t both_neg = vandq_u8(A_neg, B_neg);\n        \n        int8x16_t res = vbslq_s8(both_pos, vdupq_n_s8(1), vdupq_n_s8(0));\n        res = vbslq_s8(both_neg, vdupq_n_s8(-1), res);\n        \n        vst1q_s8(C + i, res);\n    }\n    \n    for (; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    const int8x16_t zero_vec = vdupq_n_s8(0);\n    \n    for (; i + 16 <= length; i += 16) {\n        int8x16_t a_vec = vld1q_s8(A + i);\n        int8x16_t b_vec = vld1q_s8(B + i);\n        \n        uint8x16_t a_positive = vcgtq_s8(a_vec, zero_vec);\n        uint8x16_t b_positive = vcgtq_s8(b_vec, zero_vec);\n        uint8x16_t both_positive = vandq_u8(a_positive, b_positive);\n        \n        uint8x16_t a_negative = vcltq_s8(a_vec, zero_vec);\n        uint8x16_t b_negative = vcltq_s8(b_vec, zero_vec);\n        uint8x16_t both_negative = vandq_u8(a_negative, b_negative);\n        \n        int8x16_t res = vbslq_s8(both_positive, vdupq_n_s8(1),\n                         vbslq_s8(both_negative, vdupq_n_s8(-1), zero_vec));\n        \n        vst1q_s8(C + i, res);\n    }\n    \n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    const int8x16_t zero_vec = vdupq_n_s8(0);\n    const int8x16_t one_vec = vdupq_n_s8(1);\n    const int8x16_t neg_one_vec = vdupq_n_s8(-1);\n\n    for (; i + 16 <= length; i += 16) {\n        int8x16_t A_vec = vld1q_s8(A + i);\n        int8x16_t B_vec = vld1q_s8(B + i);\n        \n        uint8x16_t A_pos_mask = vcgtq_s8(A_vec, zero_vec);\n        uint8x16_t A_neg_mask = vcltq_s8(A_vec, zero_vec);\n        uint8x16_t B_pos_mask = vcgtq_s8(B_vec, zero_vec);\n        uint8x16_t B_neg_mask = vcltq_s8(B_vec, zero_vec);\n        \n        uint8x16_t both_pos = vandq_u8(A_pos_mask, B_pos_mask);\n        uint8x16_t both_neg = vandq_u8(A_neg_mask, B_neg_mask);\n        \n        int8x16_t res_vec = vbslq_s8(both_pos, one_vec, zero_vec);\n        res_vec = vbslq_s8(both_neg, neg_one_vec, res_vec);\n        \n        vst1q_s8(C + i, res_vec);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    const int8x16_t zero = vdupq_n_s8(0);\n    const int8x16_t one_vec = vdupq_n_s8(1);\n    const int8x16_t neg_one_vec = vdupq_n_s8(-1);\n\n    for (; i + 15 < length; i += 16) {\n        int8x16_t a = vld1q_s8(A + i);\n        int8x16_t b = vld1q_s8(B + i);\n\n        uint8x16_t a_gt_zero = vcgtq_s8(a, zero);\n        uint8x16_t b_gt_zero = vcgtq_s8(b, zero);\n        uint8x16_t both_positive = vandq_u8(a_gt_zero, b_gt_zero);\n\n        uint8x16_t a_lt_zero = vcltq_s8(a, zero);\n        uint8x16_t b_lt_zero = vcltq_s8(b, zero);\n        uint8x16_t both_negative = vandq_u8(a_lt_zero, b_lt_zero);\n\n        int8x16_t pos_res = vandq_s8(vreinterpretq_s8_u8(both_positive), one_vec);\n        int8x16_t neg_res = vandq_s8(vreinterpretq_s8_u8(both_negative), neg_one_vec);\n        int8x16_t res = vaddq_s8(pos_res, neg_res);\n\n        vst1q_s8(C + i, res);\n    }\n\n    for (; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) return;\n\n    size_t mid_index = length / 2;\n    size_t i = 0;\n\n    // Process first part with XOR (elements before midpoint)\n    for (; i + 8 <= mid_index; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res_vec);\n    }\n    for (; i < mid_index; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle middle element for odd length\n    if (length % 2 == 1) {\n        C[mid_index] = A[mid_index];\n    }\n\n    // Process second part with AND (elements after midpoint)\n    size_t j = (length % 2) ? mid_index + 1 : mid_index;\n    for (; j + 8 <= length; j += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + j);\n        uint16x8_t b_vec = vld1q_u16(B + j);\n        uint16x8_t res_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + j, res_vec);\n    }\n    for (; j < length; ++j) {\n        C[j] = A[j] & B[j];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    for (; i + 8 <= mid; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t c_vec = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, c_vec);\n    }\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    if (length % 2 == 1) {\n        C[mid] = A[mid];\n        i = mid + 1;\n    } else {\n        i = mid;\n    }\n\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t c_vec = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, c_vec);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t start_and = (length % 2) ? mid + 1 : mid;\n    \n    // Part 1: XOR from 0 to mid-1\n    size_t i = 0;\n    while (i + 8 <= mid) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res);\n        i += 8;\n    }\n    while (i < mid) {\n        C[i] = A[i] ^ B[i];\n        i++;\n    }\n    \n    // Part 2: Midpoint copy if length is odd\n    if (length % 2) {\n        C[mid] = A[mid];\n    }\n    \n    // Part 3: AND from start_and to end\n    i = start_and;\n    while (i + 8 <= length) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res);\n        i += 8;\n    }\n    while (i < length) {\n        C[i] = A[i] & B[i];\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process first segment [0, mid) with XOR\n    for (; i + 8 <= mid; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res);\n    }\n    for (; i < mid; ++i) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Set midpoint element\n    C[mid] = A[mid];\n    i = mid + 1;\n\n    // Process third segment [mid+1, length) with AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res);\n    }\n    for (; i < length; ++i) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    size_t i = 0;\n\n    // Process first half with XOR\n    for (; i + 8 <= mid; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res = veorq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res);\n    }\n    for (; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n\n    // Handle midpoint for odd length\n    if (length % 2 == 1) {\n        C[mid] = A[mid];\n        i = mid + 1;\n    } else {\n        i = mid;\n    }\n\n    // Process second half with AND\n    for (; i + 8 <= length; i += 8) {\n        uint16x8_t a_vec = vld1q_u16(A + i);\n        uint16x8_t b_vec = vld1q_u16(B + i);\n        uint16x8_t res = vandq_u16(a_vec, b_vec);\n        vst1q_u16(C + i, res);\n    }\n    for (; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    const int32_t shifts_arr[4] = {0, 8, 16, 24};\n    int32x4_t shift_vec = vld1q_s32(shifts_arr);\n\n    for (; i + 4 <= total_elements; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        uint32_t c1_32, c2_32;\n        memcpy(&c1_32, cond1 + i, sizeof(uint32_t));\n        memcpy(&c2_32, cond2 + i, sizeof(uint32_t));\n\n        uint32x4_t c1_vec = vdupq_n_u32(c1_32);\n        uint32x4_t c2_vec = vdupq_n_u32(c2_32);\n\n        uint32x4_t c1_bytes = vandq_u32(vshrq_u32(c1_vec, shift_vec), vdupq_n_u32(0xFF));\n        uint32x4_t c2_bytes = vandq_u32(vshrq_u32(c2_vec, shift_vec), vdupq_n_u32(0xFF));\n\n        uint32x4_t mask1 = vandq_u32(vcgtq_u32(c1_bytes, vdupq_n_u32(0)), \n                    vcgtq_u32(c2_bytes, vdupq_n_u32(0)));\n        uint32x4_t mask2 = vandq_u32(vcgtq_u32(c1_bytes, vdupq_n_u32(0)), \n                    vceqq_u32(c2_bytes, vdupq_n_u32(0)));\n        uint32x4_t mask3 = vandq_u32(vceqq_u32(c1_bytes, vdupq_n_u32(0)), \n                    vcgtq_u32(c2_bytes, vdupq_n_u32(0)));\n        uint32x4_t mask4 = vandq_u32(vceqq_u32(c1_bytes, vdupq_n_u32(0)), \n                    vceqq_u32(c2_bytes, vdupq_n_u32(0)));\n\n        float32x4_t out_vec = vaddq_f32(\n            vaddq_f32(\n                vreinterpretq_f32_u32(vandq_u32(mask1, vreinterpretq_u32_f32(a))),\n                vreinterpretq_f32_u32(vandq_u32(mask2, vreinterpretq_u32_f32(b)))\n            ),\n            vaddq_f32(\n                vreinterpretq_f32_u32(vandq_u32(mask3, vreinterpretq_u32_f32(c))),\n                vreinterpretq_f32_u32(vandq_u32(mask4, vreinterpretq_u32_f32(d)))\n            )\n        );\n\n        vst1q_f32(out + i, out_vec);\n    }\n\n    for (; i < total_elements; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n    \n    for (; i + 4 <= total; i += 4) {\n        uint8x8_t c1_u8 = vld1_u8((const uint8_t*)(cond1 + i));\n        uint8x8_t c2_u8 = vld1_u8((const uint8_t*)(cond2 + i));\n        uint8x8_t zero = vdup_n_u8(0);\n        uint8x8_t c1_mask_u8 = vcgt_u8(c1_u8, zero);\n        uint8x8_t c2_mask_u8 = vcgt_u8(c2_u8, zero);\n        \n        int8x8_t c1_s8 = vreinterpret_s8_u8(vget_low_u8(c1_mask_u8));\n        int16x4_t c1_s16 = vmovl_s8(c1_s8);\n        int32x4_t c1_s32 = vmovl_s16(c1_s16);\n        uint32x4_t mask1 = vreinterpretq_u32_s32(c1_s32);\n        \n        int8x8_t c2_s8 = vreinterpret_s8_u8(vget_low_u8(c2_mask_u8));\n        int16x4_t c2_s16 = vmovl_s8(c2_s8);\n        int32x4_t c2_s32 = vmovl_s16(c2_s16);\n        uint32x4_t mask2 = vreinterpretq_u32_s32(c2_s32);\n        \n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t c_vec = vld1q_f32(C + i);\n        float32x4_t d_vec = vld1q_f32(D + i);\n        \n        float32x4_t temp1 = vbslq_f32(mask2, a_vec, b_vec);\n        float32x4_t temp2 = vbslq_f32(mask2, c_vec, d_vec);\n        float32x4_t out_vec = vbslq_f32(mask1, temp1, temp2);\n        \n        vst1q_f32(out + i, out_vec);\n    }\n    \n    for (; i < total; ++i) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 8 <= total; i += 8) {\n        float32x4_t A_low = vld1q_f32(A + i);\n        float32x4_t A_high = vld1q_f32(A + i + 4);\n        float32x4_t B_low = vld1q_f32(B + i);\n        float32x4_t B_high = vld1q_f32(B + i + 4);\n        float32x4_t C_low = vld1q_f32(C + i);\n        float32x4_t C_high = vld1q_f32(C + i + 4);\n        float32x4_t D_low = vld1q_f32(D + i);\n        float32x4_t D_high = vld1q_f32(D + i + 4);\n\n        uint8x8_t cond1_byte = vld1_u8((const uint8_t*)(cond1 + i));\n        uint8x8_t cond2_byte = vld1_u8((const uint8_t*)(cond2 + i));\n\n        uint8x8_t cond1_nonzero = vmvn_u8(vceq_u8(cond1_byte, vdup_n_u8(0)));\n        uint8x8_t cond2_nonzero = vmvn_u8(vceq_u8(cond2_byte, vdup_n_u8(0)));\n\n        int16x8_t cond1_s16 = vmovl_s8(vreinterpret_s8_u8(cond1_nonzero));\n        int16x8_t cond2_s16 = vmovl_s8(vreinterpret_s8_u8(cond2_nonzero));\n\n        int32x4_t cond1_mask_low = vmovl_s16(vget_low_s16(cond1_s16));\n        int32x4_t cond1_mask_high = vmovl_s16(vget_high_s16(cond1_s16));\n        int32x4_t cond2_mask_low = vmovl_s16(vget_low_s16(cond2_s16));\n        int32x4_t cond2_mask_high = vmovl_s16(vget_high_s16(cond2_s16));\n\n        uint32x4_t cond1_mask_low_u32 = vreinterpretq_u32_s32(cond1_mask_low);\n        uint32x4_t cond1_mask_high_u32 = vreinterpretq_u32_s32(cond1_mask_high);\n        uint32x4_t cond2_mask_low_u32 = vreinterpretq_u32_s32(cond2_mask_low);\n        uint32x4_t cond2_mask_high_u32 = vreinterpretq_u32_s32(cond2_mask_high);\n\n        float32x4_t temp1_low = vbslq_f32(cond1_mask_low_u32, A_low, C_low);\n        float32x4_t temp2_low = vbslq_f32(cond1_mask_low_u32, B_low, D_low);\n        float32x4_t out_low = vbslq_f32(cond2_mask_low_u32, temp1_low, temp2_low);\n\n        float32x4_t temp1_high = vbslq_f32(cond1_mask_high_u32, A_high, C_high);\n        float32x4_t temp2_high = vbslq_f32(cond1_mask_high_u32, B_high, D_high);\n        float32x4_t out_high = vbslq_f32(cond2_mask_high_u32, temp1_high, temp2_high);\n\n        vst1q_f32(out + i, out_low);\n        vst1q_f32(out + i + 4, out_high);\n    }\n\n    for (; i + 4 <= total; i += 4) {\n        float32x4_t A_vec = vld1q_f32(A + i);\n        float32x4_t B_vec = vld1q_f32(B + i);\n        float32x4_t C_vec = vld1q_f32(C + i);\n        float32x4_t D_vec = vld1q_f32(D + i);\n\n        uint32_t cond1_4bytes, cond2_4bytes;\n        __builtin_memcpy(&cond1_4bytes, cond1 + i, 4);\n        __builtin_memcpy(&cond2_4bytes, cond2 + i, 4);\n\n        uint32x2_t cond1_2 = vdup_n_u32(cond1_4bytes);\n        uint32x2_t cond2_2 = vdup_n_u32(cond2_4bytes);\n        uint8x8_t cond1_byte = vreinterpret_u8_u32(cond1_2);\n        uint8x8_t cond2_byte = vreinterpret_u8_u32(cond2_2);\n\n        uint8x8_t cond1_nonzero = vmvn_u8(vceq_u8(cond1_byte, vdup_n_u8(0)));\n        uint8x8_t cond2_nonzero = vmvn_u8(vceq_u8(cond2_byte, vdup_n_u8(0)));\n\n        int16x8_t cond1_s16 = vmovl_s8(vreinterpret_s8_u8(cond1_nonzero));\n        int16x8_t cond2_s16 = vmovl_s8(vreinterpret_s8_u8(cond2_nonzero));\n\n        int32x4_t cond1_mask = vmovl_s16(vget_low_s16(cond1_s16));\n        int32x4_t cond2_mask = vmovl_s16(vget_low_s16(cond2_s16));\n\n        uint32x4_t cond1_mask_u32 = vreinterpretq_u32_s32(cond1_mask);\n        uint32x4_t cond2_mask_u32 = vreinterpretq_u32_s32(cond2_mask);\n\n        float32x4_t temp1 = vbslq_f32(cond1_mask_u32, A_vec, C_vec);\n        float32x4_t temp2 = vbslq_f32(cond1_mask_u32, B_vec, D_vec);\n        float32x4_t out_vec = vbslq_f32(cond2_mask_u32, temp1, temp2);\n\n        vst1q_f32(out + i, out_vec);\n    }\n\n    for (; i < total; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total; i += 4) {\n        uint32_t c1_int, c2_int;\n        memcpy(&c1_int, cond1 + i, 4);\n        memcpy(&c2_int, cond2 + i, 4);\n        uint8_t* c1_bytes = (uint8_t*)&c1_int;\n        uint8_t* c2_bytes = (uint8_t*)&c2_int;\n\n        uint32_t mask_c1_arr[4] = {\n            c1_bytes[0] ? 0xFFFFFFFF : 0,\n            c1_bytes[1] ? 0xFFFFFFFF : 0,\n            c1_bytes[2] ? 0xFFFFFFFF : 0,\n            c1_bytes[3] ? 0xFFFFFFFF : 0\n        };\n        uint32_t mask_c2_arr[4] = {\n            c2_bytes[0] ? 0xFFFFFFFF : 0,\n            c2_bytes[1] ? 0xFFFFFFFF : 0,\n            c2_bytes[2] ? 0xFFFFFFFF : 0,\n            c2_bytes[3] ? 0xFFFFFFFF : 0\n        };\n\n        uint32x4_t mask_c1 = vld1q_u32(mask_c1_arr);\n        uint32x4_t mask_c2 = vld1q_u32(mask_c2_arr);\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t c = vld1q_f32(C + i);\n        float32x4_t d = vld1q_f32(D + i);\n\n        float32x4_t temp1 = vbslq_f32(mask_c2, a, b);\n        float32x4_t temp2 = vbslq_f32(mask_c2, c, d);\n        float32x4_t result = vbslq_f32(mask_c1, temp1, temp2);\n\n        vst1q_f32(out + i, result);\n    }\n\n    for (; i < total; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total; i += 4) {\n        bool c1_0 = cond1[i];\n        bool c1_1 = cond1[i+1];\n        bool c1_2 = cond1[i+2];\n        bool c1_3 = cond1[i+3];\n        bool c2_0 = cond2[i];\n        bool c2_1 = cond2[i+1];\n        bool c2_2 = cond2[i+2];\n        bool c2_3 = cond2[i+3];\n\n        uint32_t case1_mask_0 = (c1_0 && c2_0) ? 0xFFFFFFFF : 0;\n        uint32_t case1_mask_1 = (c1_1 && c2_1) ? 0xFFFFFFFF : 0;\n        uint32_t case1_mask_2 = (c1_2 && c2_2) ? 0xFFFFFFFF : 0;\n        uint32_t case1_mask_3 = (c1_3 && c2_3) ? 0xFFFFFFFF : 0;\n        uint32x4_t case1_mask = (uint32x4_t){case1_mask_0, case1_mask_1, case1_mask_2, case1_mask_3};\n\n        uint32_t case2_mask_0 = (c1_0 && !c2_0) ? 0xFFFFFFFF : 0;\n        uint32_t case2_mask_1 = (c1_1 && !c2_1) ? 0xFFFFFFFF : 0;\n        uint32_t case2_mask_2 = (c1_2 && !c2_2) ? 0xFFFFFFFF : 0;\n        uint32_t case2_mask_3 = (c1_3 && !c2_3) ? 0xFFFFFFFF : 0;\n        uint32x4_t case2_mask = (uint32x4_t){case2_mask_0, case2_mask_1, case2_mask_2, case2_mask_3};\n\n        uint32_t case3_mask_0 = (!c1_0 && c2_0) ? 0xFFFFFFFF : 0;\n        uint32_t case3_mask_1 = (!c1_1 && c2_1) ? 0xFFFFFFFF : 0;\n        uint32_t case3_mask_2 = (!c1_2 && c2_2) ? 0xFFFFFFFF : 0;\n        uint32_t case3_mask_3 = (!c1_3 && c2_3) ? 0xFFFFFFFF : 0;\n        uint32x4_t case3_mask = (uint32x4_t){case3_mask_0, case3_mask_1, case3_mask_2, case3_mask_3};\n\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t c_vec = vld1q_f32(C + i);\n        float32x4_t d_vec = vld1q_f32(D + i);\n\n        float32x4_t out_vec = d_vec;\n        out_vec = vbslq_f32(case3_mask, c_vec, out_vec);\n        out_vec = vbslq_f32(case2_mask, b_vec, out_vec);\n        out_vec = vbslq_f32(case1_mask, a_vec, out_vec);\n\n        vst1q_f32(out + i, out_vec);\n    }\n\n    for (; i < total; i++) {\n        if (cond1[i] && cond2[i]) {\n            out[i] = A[i];\n        } else if (cond1[i] && !cond2[i]) {\n            out[i] = B[i];\n        } else if (!cond1[i] && cond2[i]) {\n            out[i] = C[i];\n        } else {\n            out[i] = D[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total_elements; i += 4) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        uint8x16_t bytes = vreinterpretq_u8_u32(vec);\n        uint8x16_t cnt_bytes = vcntq_u8(bytes);\n        uint16x8_t sum8 = vpaddlq_u8(cnt_bytes);\n        uint16x4_t low = vget_low_u16(sum8);\n        uint16x4_t high = vget_high_u16(sum8);\n        uint16x4_t total16 = vpadd_u16(low, high);\n        uint8x8_t result_u8 = vmovn_u16(vcombine_u16(total16, vdup_n_u16(0)));\n        uint32x2_t result32 = vreinterpret_u32_u8(result_u8);\n        vst1_lane_u32((uint32_t*)(out + i), result32, 0);\n    }\n\n    for (; i < total_elements; i++) {\n        out[i] = __builtin_popcount(A[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 4 <= total; i += 4) {\n        uint32x4_t v = vld1q_u32(A + i);\n        uint8x16_t v8 = vreinterpretq_u8_u32(v);\n        uint8x16_t cnt8 = vcntq_u8(v8);\n        uint16x8_t sum16 = vpaddlq_u8(cnt8);\n        uint16x4_t low = vget_low_u16(sum16);\n        uint16x4_t high = vget_high_u16(sum16);\n        uint16x4_t res16 = vpadd_u16(low, high);\n        uint8x8_t res8 = vmovn_u16(vcombine_u16(res16, res16));\n        vst1_lane_u32((uint32_t*)(out + i), vreinterpret_u32_u8(res8), 0);\n    }\n\n    for (; i < total; i++) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        out[i] = (x * 0x01010101) >> 24;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint8x16_t v = vcntq_u8(vreinterpretq_u8_u32(a_vec));\n        uint16x8_t vsum0 = vpaddlq_u8(v);\n        uint16x4_t low = vget_low_u16(vsum0);\n        uint16x4_t high = vget_high_u16(vsum0);\n        uint16x4_t res_low = vpadd_u16(low, high);\n        uint16x8_t res_wide = vcombine_u16(res_low, vdup_n_u16(0));\n        uint8x8_t res8 = vmovn_u16(res_wide);\n        vst1_lane_u32((uint32_t*)(out + i), vreinterpret_u32_u8(res8), 0);\n    }\n\n    for (; i < total; i++) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        out[i] = (x * 0x01010101) >> 24;\n    }\n}\n```"}
{"task_id": "SimdBench_46_Neon", "completion": ""}
{"task_id": "SimdBench_46_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    size_t i = 0;\n\n    for (; i + 3 < total; i += 4) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        uint8x16_t bytes = vreinterpretq_u8_u32(vec);\n        uint8x16_t cnts = vcntq_u8(bytes);\n        uint16x8_t sum2 = vpaddlq_u8(cnts);\n        uint32x4_t sum4 = vpaddlq_u16(sum2);\n        uint16x4_t sum4_16 = vmovn_u32(sum4);\n        uint8x8_t res8 = vmovn_u16(vcombine_u16(sum4_16, vdup_n_u16(0)));\n        \n        vst1_lane_u8(out + i,   res8, 0);\n        vst1_lane_u8(out + i+1, res8, 1);\n        vst1_lane_u8(out + i+2, res8, 2);\n        vst1_lane_u8(out + i+3, res8, 3);\n    }\n\n    for (; i < total; i++) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        x = (x * 0x01010101) >> 24;\n        out[i] = (uint8_t)x;\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n    const uint32_t reciprocal = 0xAAAAAAAB;\n    const uint32x4_t recip_vec = vdupq_n_u32(reciprocal);\n\n    for (; i + 3 < total; i += 4) {\n        int32x4_t vec = vld1q_s32(A + i);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        uint32x4_t abs_uint = vreinterpretq_u32_s32(abs_vec);\n\n        uint32x2_t low = vget_low_u32(abs_uint);\n        uint32x2_t high = vget_high_u32(abs_uint);\n        uint64x2_t pl = vmull_u32(low, vget_low_u32(recip_vec));\n        uint64x2_t ph = vmull_u32(high, vget_high_u32(recip_vec));\n        uint64x2_t ql = vshrq_n_u64(pl, 33);\n        uint64x2_t qh = vshrq_n_u64(ph, 33);\n        uint32x2_t ql32 = vmovn_u64(ql);\n        uint32x2_t qh32 = vmovn_u64(qh);\n        uint32x4_t q = vcombine_u32(ql32, qh32);\n        uint32x4_t rem = vmlsq_n_u32(abs_uint, q, 3);\n\n        uint32x4_t mask = vceqq_u32(rem, vdupq_n_u32(0));\n        int32x4_t res = vbslq_s32(mask, abs_vec, vec);\n        vst1q_s32(B + i, res);\n    }\n\n    for (; i < total; i++) {\n        int val = A[i];\n        int abs_val = val < 0 ? -val : val;\n        if (abs_val % 3 == 0) {\n            B[i] = abs_val;\n        } else {\n            B[i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        const int* a_row = A + i * cols;\n        int* b_row = B + i * cols;\n        uint32_t three_inv = 0xAAAAAAAB;\n\n        for (; j + 4 <= cols; j += 4) {\n            int32x4_t v_a = vld1q_s32(a_row + j);\n            int32x4_t v_abs = vabsq_s32(v_a);\n            uint32x4_t v_abs_u = vreinterpretq_u32_s32(v_abs);\n            \n            uint32x2_t v_low = vget_low_u32(v_abs_u);\n            uint32x2_t v_high = vget_high_u32(v_abs_u);\n            \n            uint64x2_t v_prod_low = vmull_u32(v_low, vdup_n_u32(three_inv));\n            uint64x2_t v_prod_high = vmull_u32(v_high, vdup_n_u32(three_inv));\n            \n            uint64x2_t v_shift_low = vshrq_n_u64(v_prod_low, 33);\n            uint64x2_t v_shift_high = vshrq_n_u64(v_prod_high, 33);\n            \n            uint32x2_t v_t_low = vmovn_u64(v_shift_low);\n            uint32x2_t v_t_high = vmovn_u64(v_shift_high);\n            uint32x4_t v_t = vcombine_u32(v_t_low, v_t_high);\n            \n            uint32x4_t v_r = vmlsq_u32(v_abs_u, v_t, vdupq_n_u32(3));\n            uint32x4_t v_cond = vceqq_u32(v_r, vdupq_n_u32(0));\n            \n            int32x4_t v_b = vbslq_s32(v_cond, v_abs, v_a);\n            vst1q_s32(b_row + j, v_b);\n        }\n\n        for (; j < cols; j++) {\n            int a_val = a_row[j];\n            if (a_val % 3 == 0) {\n                b_row[j] = (a_val < 0) ? -a_val : a_val;\n            } else {\n                b_row[j] = a_val;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n    const int32_t magic = 0x55555556; // Magic number for division by 3\n\n    for (; i + 3 < total; i += 4) {\n        int32x4_t vA = vld1q_s32(A + i);\n        int32x2_t low = vget_low_s32(vA);\n        int32x2_t high = vget_high_s32(vA);\n        \n        int64x2_t plow = vmull_s32(low, vdup_n_s32(magic));\n        int64x2_t phigh = vmull_s32(high, vdup_n_s32(magic));\n        int32x2_t qlow = vshrn_n_s64(plow, 32);\n        int32x2_t qhigh = vshrn_n_s64(phigh, 32);\n        int32x4_t vq = vcombine_s32(qlow, qhigh);\n        \n        int32x4_t vr = vmlsq_s32(vA, vq, vdupq_n_s32(3));\n        uint32x4_t mask = vceqq_s32(vr, vdupq_n_s32(0));\n        int32x4_t vabs = vabsq_s32(vA);\n        int32x4_t result = vbslq_s32(mask, vabs, vA);\n        \n        vst1q_s32(B + i, result);\n    }\n\n    for (; i < total; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = (A[i] < 0) ? -A[i] : A[i];\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* a_row = A + i * cols;\n        int* b_row = B + i * cols;\n        size_t j = 0;\n\n        for (; j + 4 <= cols; j += 4) {\n            int32x4_t v = vld1q_s32(a_row + j);\n            int32x4_t v_abs = vabsq_s32(v);\n            uint32x4_t v_mod = vreinterpretq_u32_s32(v_abs);\n\n            uint32x4_t v_low16 = vandq_u32(v_mod, vdupq_n_u32(0xFFFF));\n            uint32x4_t v_high16 = vshrq_n_u32(v_mod, 16);\n            v_mod = vaddq_u32(v_low16, v_high16);\n\n            uint32x4_t v_low8 = vandq_u32(v_mod, vdupq_n_u32(0xFF));\n            uint32x4_t v_high8 = vshrq_n_u32(v_mod, 8);\n            v_mod = vaddq_u32(v_low8, v_high8);\n\n            uint32x4_t v_low4 = vandq_u32(v_mod, vdupq_n_u32(0xF));\n            uint32x4_t v_high4 = vshrq_n_u32(v_mod, 4);\n            v_mod = vaddq_u32(v_low4, v_high4);\n\n            uint32x4_t v_low2 = vandq_u32(v_mod, vdupq_n_u32(0x3));\n            uint32x4_t v_high2 = vshrq_n_u32(v_mod, 2);\n            v_mod = vaddq_u32(v_low2, v_high2);\n\n            uint32x4_t ge3 = vcgeq_u32(v_mod, vdupq_n_u32(3));\n            v_mod = vsubq_u32(v_mod, vandq_u32(ge3, vdupq_n_u32(3)));\n            ge3 = vcgeq_u32(v_mod, vdupq_n_u32(3));\n            v_mod = vsubq_u32(v_mod, vandq_u32(ge3, vdupq_n_u32(3)));\n\n            uint32x4_t mask0 = vceqq_u32(v_mod, vdupq_n_u32(0));\n            int32x4_t res = vbslq_s32(mask0, v_abs, v);\n            vst1q_s32(b_row + j, res);\n        }\n\n        for (; j < cols; j++) {\n            int a_val = a_row[j];\n            if (a_val % 3 == 0) {\n                if (a_val < 0) {\n                    b_row[j] = -a_val;\n                } else {\n                    b_row[j] = a_val;\n                }\n            } else {\n                b_row[j] = a_val;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n    \n    for (; i + 4 <= total; i += 4) {\n        int32x4_t a_vec = vld1q_s32(A + i);\n        int32x4_t a_abs = vabsq_s32(a_vec);\n        uint32x4_t x = vreinterpretq_u32_s32(a_abs);\n        \n        uint32x4_t mask1 = vdupq_n_u32(0x33333333);\n        uint32x4_t t1 = vandq_u32(x, mask1);\n        uint32x4_t t2 = vshrq_u32(x, 2);\n        t2 = vandq_u32(t2, mask1);\n        x = vaddq_u32(t1, t2);\n        \n        x = vaddq_u32(x, vshrq_u32(x, 4));\n        x = vandq_u32(x, vdupq_n_u32(0x0F0F0F0F));\n        \n        uint8x16_t x_bytes = vreinterpretq_u8_u32(x);\n        uint16x8_t temp = vpaddlq_u8(x_bytes);\n        uint32x4_t total_sum = vpaddlq_u16(temp);\n        \n        uint32x4_t three = vdupq_n_u32(3);\n        uint32x4_t a = total_sum;\n        a = vaddq_u32(vandq_u32(a, three), vshrq_n_u32(a, 2));\n        a = vaddq_u32(vandq_u32(a, three), vshrq_n_u32(a, 2));\n        a = vaddq_u32(vandq_u32(a, three), vshrq_n_u32(a, 2));\n        \n        uint32x4_t mask_cond = vorrq_u32(\n            vceqq_u32(a, vdupq_n_u32(0)),\n            vceqq_u32(a, vdupq_n_u32(3))\n        );\n        \n        int32x4_t result = vbslq_s32(mask_cond, a_abs, a_vec);\n        vst1q_s32(B + i, result);\n    }\n    \n    for (; i < total; i++) {\n        int val = A[i];\n        if (val % 3 == 0) {\n            B[i] = (val < 0) ? -val : val;\n        } else {\n            B[i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32_t rotate_mod = rotate_bits & 0x1F;\n    uint32_t left_shift_amt = (32 - rotate_mod) & 0x1F;\n\n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t v = vld1q_u32(src + i);\n        uint32x4_t low4 = vandq_u32(v, vdupq_n_u32(0xF));\n        uint32x4_t mask = vceqq_u32(low4, vdupq_n_u32(0xF));\n        uint32x4_t right_shifted = vshrq_n_u32(v, rotate_mod);\n        uint32x4_t left_shifted = vshlq_n_u32(v, left_shift_amt);\n        uint32x4_t rotated = vorrq_u32(left_shifted, right_shifted);\n        uint32x4_t negated = vmvnq_u32(v);\n        uint32x4_t result = vbslq_u32(mask, rotated, negated);\n        vst1q_u32(dst + i, result);\n    }\n\n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        if ((val & 0xF) == 0xF) {\n            dst[i] = (val >> rotate_mod) | (val << left_shift_amt);\n        } else {\n            dst[i] = ~val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32_t r = rotate_bits & 31;\n    uint32_t inv_r = 32 - r;\n    uint32x4_t shift_right = vdupq_n_u32(r);\n    uint32x4_t shift_left = vdupq_n_u32(inv_r);\n    uint32x4_t low4_mask = vdupq_n_u32(0xF);\n    uint32x4_t compare_val = vdupq_n_u32(0xF);\n\n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t data = vld1q_u32(src + i);\n        uint32x4_t low4 = vandq_u32(data, low4_mask);\n        uint32x4_t condition = vceqq_u32(low4, compare_val);\n        uint32x4_t rotated = vorrq_u32(vshrq_u32(data, shift_right), vshlq_u32(data, shift_left));\n        uint32x4_t negated = vmvnq_u32(data);\n        uint32x4_t res = vbslq_u32(condition, rotated, negated);\n        vst1q_u32(dst + i, res);\n    }\n\n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        if ((val & 0xF) == 0xF) {\n            dst[i] = (val >> r) | (val << inv_r);\n        } else {\n            dst[i] = ~val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    if (length == 0) {\n        return;\n    }\n    uint8_t rot = rotate_bits & 0x1F;\n    int32_t left_rot_val = 32 - rot;\n    int32x4_t shift_right_vec = vdupq_n_s32(-(int32_t)rot);\n    int32x4_t shift_left_vec = vdupq_n_s32(left_rot_val);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t v_src = vld1q_u32(src + i);\n        uint32x4_t v_low4 = vandq_u32(v_src, vdupq_n_u32(0xF));\n        uint32x4_t v_mask = vceqq_u32(v_low4, vdupq_n_u32(0xF));\n        uint32x4_t v_rot_right = vshlq_u32(v_src, shift_right_vec);\n        uint32x4_t v_rot_left = vshlq_u32(v_src, shift_left_vec);\n        uint32x4_t v_rot = vorrq_u32(v_rot_right, v_rot_left);\n        uint32x4_t v_not = vmvnq_u32(v_src);\n        uint32x4_t v_result = vbslq_u32(v_mask, v_rot, v_not);\n        vst1q_u32(dst + i, v_result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        if ((val & 0xF) == 0xF) {\n            uint32_t left_shift = (32 - rot) & 0x1F;\n            dst[i] = (val >> rot) | (val << left_shift);\n        } else {\n            dst[i] = ~val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint8_t rot = rotate_bits % 32;\n    int32_t left_shift_val = 32 - rot;\n    \n    int32x4_t right_shift_amt = vdupq_n_s32(-(int32_t)rot);\n    int32x4_t left_shift_amt = vdupq_n_s32(left_shift_val);\n    uint32x4_t low4_mask = vdupq_n_u32(0x0F);\n    \n    size_t i = 0;\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t low4 = vandq_u32(src_vec, low4_mask);\n        uint32x4_t mask = vceqq_u32(low4, low4_mask);\n        \n        uint32x4_t right_shifted = vshlq_u32(src_vec, right_shift_amt);\n        uint32x4_t left_shifted = vshlq_u32(src_vec, left_shift_amt);\n        uint32x4_t rotated = vorrq_u32(right_shifted, left_shifted);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        \n        uint32x4_t result = vbslq_u32(mask, rotated, negated);\n        vst1q_u32(dst + i, result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        if ((val & 0x0F) == 0x0F) {\n            dst[i] = (val >> rot) | (val << left_shift_val);\n        } else {\n            dst[i] = ~val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint8_t r = rotate_bits & 0x1F;\n    uint8_t left_shift_amt = (32 - r) & 0x1F;\n    \n    int32x4_t right_shift_vec = vdupq_n_s32(-(int32_t)r);\n    int32x4_t left_shift_vec = vdupq_n_s32(left_shift_amt);\n    uint32x4_t const_0x0F = vdupq_n_u32(0x0F);\n    \n    size_t i = 0;\n    for (; i + 4 <= length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint32x4_t low4 = vandq_u32(src_vec, const_0x0F);\n        uint32x4_t mask = vceqq_u32(low4, const_0x0F);\n        \n        uint32x4_t right_shifted = vshlq_u32(src_vec, right_shift_vec);\n        uint32x4_t left_shifted = vshlq_u32(src_vec, left_shift_vec);\n        uint32x4_t rotated = vorrq_u32(right_shifted, left_shifted);\n        uint32x4_t negated = vmvnq_u32(src_vec);\n        uint32x4_t result = vbslq_u32(mask, rotated, negated);\n        \n        vst1q_u32(dst + i, result);\n    }\n    \n    for (; i < length; i++) {\n        uint32_t val = src[i];\n        if ((val & 0x0F) == 0x0F) {\n            dst[i] = (val >> r) | (val << left_shift_amt);\n        } else {\n            dst[i] = ~val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    size_t i = 0;\n\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        float32x4_t diff = vsubq_f32(va, vb);\n\n        float32x4_t eps_pos = vdupq_n_f32(abs_epsilon);\n        float32x4_t eps_neg = vdupq_n_f32(-abs_epsilon);\n\n        uint32x4_t mask_positive = vcgtq_f32(diff, eps_pos);\n        uint32x4_t mask_negative = vcltq_f32(diff, eps_neg);\n\n        int32x4_t v_one = vdupq_n_s32(1);\n        int32x4_t v_neg_one = vdupq_n_s32(-1);\n        int32x4_t v_zero = vdupq_n_s32(0);\n\n        int32x4_t base = vbslq_s32(mask_negative, v_neg_one, v_zero);\n        int32x4_t res32 = vbslq_s32(mask_positive, v_one, base);\n\n        int16x4_t res16 = vqmovn_s32(res32);\n        int8x8_t res8 = vqmovn_s16(vcombine_s16(res16, vdup_n_s16(0)));\n        vst1_lane_s32((int32_t*)(out + i), vreinterpret_s32_s8(res8), 0);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_eps = fabsf(epsilon);\n    float neg_abs_eps = -abs_eps;\n    size_t i = 0;\n\n    float32x4_t v_abs_eps = vdupq_n_f32(abs_eps);\n    float32x4_t v_neg_abs_eps = vdupq_n_f32(neg_abs_eps);\n\n    for (; i + 4 <= length; i += 4) {\n        float32x4_t v_a = vld1q_f32(A + i);\n        float32x4_t v_b = vld1q_f32(B + i);\n        float32x4_t v_diff = vsubq_f32(v_a, v_b);\n\n        uint32x4_t mask_positive = vcgtq_f32(v_diff, v_abs_eps);\n        uint32x4_t mask_negative = vcltq_f32(v_diff, v_neg_abs_eps);\n\n        int32x4_t v_out_int32 = vsubq_s32(\n            vreinterpretq_s32_u32(mask_positive),\n            vreinterpretq_s32_u32(mask_negative)\n        );\n\n        int16x4_t v_out_int16 = vmovn_s32(v_out_int32);\n        int16x8_t v_out_int16_8 = vcombine_s16(v_out_int16, vdup_n_s16(0));\n        int8x8_t v_out_int8 = vmovn_s16(v_out_int16_8);\n\n        vst1_lane_u32((uint32_t*)(out + i), vreinterpret_u32_s8(v_out_int8), 0);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_eps) {\n            out[i] = 1;\n        } else if (diff < neg_abs_eps) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    size_t i = 0;\n\n    if (length >= 8) {\n        float32x4_t eps_vec = vdupq_n_f32(abs_epsilon);\n        float32x4_t neg_eps_vec = vnegq_f32(eps_vec);\n\n        for (; i <= length - 8; i += 8) {\n            float32x4_t va1 = vld1q_f32(A + i);\n            float32x4_t va2 = vld1q_f32(A + i + 4);\n            float32x4_t vb1 = vld1q_f32(B + i);\n            float32x4_t vb2 = vld1q_f32(B + i + 4);\n\n            float32x4_t diff1 = vsubq_f32(va1, vb1);\n            float32x4_t diff2 = vsubq_f32(va2, vb2);\n\n            uint32x4_t mask_gt1 = vcgtq_f32(diff1, eps_vec);\n            uint32x4_t mask_lt1 = vcltq_f32(diff1, neg_eps_vec);\n            int32x4_t result1 = vsubq_s32(vreinterpretq_s32_u32(mask_lt1), \n                                         vreinterpretq_s32_u32(mask_gt1));\n\n            uint32x4_t mask_gt2 = vcgtq_f32(diff2, eps_vec);\n            uint32x4_t mask_lt2 = vcltq_f32(diff2, neg_eps_vec);\n            int32x4_t result2 = vsubq_s32(vreinterpretq_s32_u32(mask_lt2), \n                                         vreinterpretq_s32_u32(mask_gt2));\n\n            int16x4_t res16_1 = vmovn_s32(result1);\n            int16x4_t res16_2 = vmovn_s32(result2);\n            int16x8_t res16 = vcombine_s16(res16_1, res16_2);\n            int8x8_t res8 = vmovn_s16(res16);\n            vst1_s8(out + i, res8);\n        }\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    if (length == 0) return;\n\n    float abs_epsilon = (epsilon < 0.0f) ? -epsilon : epsilon;\n    float neg_abs_epsilon = -abs_epsilon;\n    float32x4_t vAbsEpsilon = vdupq_n_f32(abs_epsilon);\n    float32x4_t vNegAbsEpsilon = vdupq_n_f32(neg_abs_epsilon);\n\n    size_t i = 0;\n    for (; i + 8 <= length; i += 8) {\n        float32x4_t vA0 = vld1q_f32(A + i);\n        float32x4_t vA1 = vld1q_f32(A + i + 4);\n        float32x4_t vB0 = vld1q_f32(B + i);\n        float32x4_t vB1 = vld1q_f32(B + i + 4);\n\n        float32x4_t vDiff0 = vsubq_f32(vA0, vB0);\n        float32x4_t vDiff1 = vsubq_f32(vA1, vB1);\n\n        uint32x4_t mask_gt0 = vcgtq_f32(vDiff0, vAbsEpsilon);\n        uint32x4_t mask_gt1 = vcgtq_f32(vDiff1, vAbsEpsilon);\n        uint32x4_t mask_lt0 = vcltq_f32(vDiff0, vNegAbsEpsilon);\n        uint32x4_t mask_lt1 = vcltq_f32(vDiff1, vNegAbsEpsilon);\n\n        int32x4_t vRes32_0 = vsubq_s32(vreinterpretq_s32_u32(mask_lt0), vreinterpretq_s32_u32(mask_gt0));\n        int32x4_t vRes32_1 = vsubq_s32(vreinterpretq_s32_u32(mask_lt1), vreinterpretq_s32_u32(mask_gt1));\n\n        int16x4_t vRes16_0 = vmovn_s32(vRes32_0);\n        int16x4_t vRes16_1 = vmovn_s32(vRes32_1);\n        int16x8_t vRes16 = vcombine_s16(vRes16_0, vRes16_1);\n        int8x8_t vRes8 = vmovn_s16(vRes16);\n\n        vst1_s8(out + i, vRes8);\n    }\n\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < neg_abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float epsilon_abs = (epsilon < 0.0f) ? -epsilon : epsilon;\n    size_t i = 0;\n\n    // Process 8 elements at a time\n    for (; i + 7 < length; i += 8) {\n        float32x4_t a0 = vld1q_f32(A + i);\n        float32x4_t a1 = vld1q_f32(A + i + 4);\n        float32x4_t b0 = vld1q_f32(B + i);\n        float32x4_t b1 = vld1q_f32(B + i + 4);\n\n        float32x4_t diff0 = vsubq_f32(a0, b0);\n        float32x4_t diff1 = vsubq_f32(a1, b1);\n\n        float32x4_t abs_eps_vec = vdupq_n_f32(epsilon_abs);\n        float32x4_t neg_abs_eps_vec = vnegq_f32(abs_eps_vec);\n\n        uint32x4_t mask1_0 = vcgtq_f32(diff0, abs_eps_vec);\n        uint32x4_t mask1_1 = vcgtq_f32(diff1, abs_eps_vec);\n        uint32x4_t mask2_0 = vcltq_f32(diff0, neg_abs_eps_vec);\n        uint32x4_t mask2_1 = vcltq_f32(diff1, neg_abs_eps_vec);\n\n        mask1_0 = vshrq_n_u32(mask1_0, 31);\n        mask1_1 = vshrq_n_u32(mask1_1, 31);\n        mask2_0 = vshrq_n_u32(mask2_0, 31);\n        mask2_1 = vshrq_n_u32(mask2_1, 31);\n\n        int32x4_t res0 = vsubq_s32(vreinterpretq_s32_u32(mask1_0), vreinterpretq_s32_u32(mask2_0));\n        int32x4_t res1 = vsubq_s32(vreinterpretq_s32_u32(mask1_1), vreinterpretq_s32_u32(mask2_1));\n\n        int16x4_t res0_16 = vqmovn_s32(res0);\n        int16x4_t res1_16 = vqmovn_s32(res1);\n        int16x8_t res16 = vcombine_s16(res0_16, res1_16);\n        int8x8_t res8 = vqmovn_s16(res16);\n\n        vst1_s8(out + i, res8);\n    }\n\n    // Process 4 elements at a time\n    for (; i + 3 < length; i += 4) {\n        float32x4_t a = vld1q_f32(A + i);\n        float32x4_t b = vld1q_f32(B + i);\n        float32x4_t diff = vsubq_f32(a, b);\n\n        float32x4_t abs_eps_vec = vdupq_n_f32(epsilon_abs);\n        float32x4_t neg_abs_eps_vec = vnegq_f32(abs_eps_vec);\n\n        uint32x4_t mask1 = vcgtq_f32(diff, abs_eps_vec);\n        uint32x4_t mask2 = vcltq_f32(diff, neg_abs_eps_vec);\n\n        mask1 = vshrq_n_u32(mask1, 31);\n        mask2 = vshrq_n_u32(mask2, 31);\n\n        int32x4_t res32 = vsubq_s32(vreinterpretq_s32_u32(mask1), vreinterpretq_s32_u32(mask2));\n        int16x4_t res16 = vqmovn_s32(res32);\n        int8x8_t res8 = vqmovn_s16(vcombine_s16(res16, vdup_n_s16(0)));\n\n        vst1_lane_s32((int32_t*)(out + i), vreinterpret_s32_s8(res8), 0);\n    }\n\n    // Process remaining elements (0-3) with scalar code\n    for (; i < length; i++) {\n        float diff = A[i] - B[i];\n        if (diff > epsilon_abs) {\n            out[i] = 1;\n        } else if (diff < -epsilon_abs) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const float32x4_t upper_bound = vdupq_n_f32(2147483648.0f);\n    const float32x4_t lower_bound = vdupq_n_f32((float)INT32_MIN);\n    const int32x4_t int32_max_vec = vdupq_n_s32(INT32_MAX);\n    \n    for (; i + 4 <= size; i += 4) {\n        float32x4_t vec = vld1q_f32(A + i);\n        vec = vmaxq_f32(vec, lower_bound);\n        int32x4_t int_vec = vcvtq_s32_f32(vec);\n        uint32x4_t too_large = vcgeq_f32(vec, upper_bound);\n        int_vec = vbslq_s32(too_large, int32_max_vec, int_vec);\n        vst1q_s32(B + i, int_vec);\n    }\n\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val > (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val < (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_val = vld1q_f32(A + i);\n        int32x4_t b_val = vcvtzq_s32_f32(a_val);\n        vst1q_s32(B + i, b_val);\n    }\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val >= (float)INT32_MAX) {\n            B[i] = INT32_MAX;\n        } else if (val <= (float)INT32_MIN) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n#include <cstddef>\n#include <climits>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    float32x4_t max_vec = vdupq_n_f32(static_cast<float>(INT32_MAX));\n    float32x4_t min_vec = vdupq_n_f32(static_cast<float>(INT32_MIN));\n    int32x4_t int32_max_vec = vdupq_n_s32(INT32_MAX);\n    int32x4_t int32_min_vec = vdupq_n_s32(INT32_MIN);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        float32x4_t v = vld1q_f32(A + i);\n        uint32x4_t gt_mask = vcgtq_f32(v, max_vec);\n        uint32x4_t lt_mask = vcltq_f32(v, min_vec);\n        int32x4_t converted = vcvtq_s32_f32(v);\n        int32x4_t result = vbslq_s32(gt_mask, int32_max_vec, converted);\n        result = vbslq_s32(lt_mask, int32_min_vec, result);\n        vst1q_s32(B + i, result);\n    }\n\n    for (; i < size; ++i) {\n        float val = A[i];\n        if (val > static_cast<float>(INT32_MAX)) {\n            B[i] = INT32_MAX;\n        } else if (val < static_cast<float>(INT32_MIN)) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(val);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const float float_upper_bound = (float)((int64_t)INT32_MAX + 1);\n    const float float_lower_bound = (float)INT32_MIN;\n\n    for (; i + 3 < size; i += 4) {\n        float32x4_t a_val = vld1q_f32(A + i);\n        int32x4_t b_val = vcvtq_s32_f32(a_val);\n        vst1q_s32(B + i, b_val);\n    }\n\n    for (; i < size; i++) {\n        float val = A[i];\n        if (val >= float_upper_bound) {\n            B[i] = INT32_MAX;\n        } else if (val < float_lower_bound) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t va = vld1q_f32(A + i);\n        int32x4_t vb = vcvtzq_s32_f32(va);\n        vst1q_s32(B + i, vb);\n    }\n    if (i < size) {\n        float tmp_a[4] = {0};\n        int32_t tmp_b[4];\n        size_t num_tail = size - i;\n        for (size_t j = 0; j < num_tail; j++) {\n            tmp_a[j] = A[i + j];\n        }\n        float32x4_t va = vld1q_f32(tmp_a);\n        int32x4_t vb = vcvtzq_s32_f32(va);\n        vst1q_s32(tmp_b, vb);\n        for (size_t j = 0; j < num_tail; j++) {\n            B[i + j] = tmp_b[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_factor = (float)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_factor);\n    \n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(A + i);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, scale_vec);\n        vst1q_f32(B + i, b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale_factor;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_f);\n    \n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(A + i);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, scale_vec);\n        vst1q_f32(B + i, b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale_f;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    const float scale_factor = (float)scale;\n    const float32x4_t vscale = vdupq_n_f32(scale_factor);\n    \n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(A + i);\n        float32x4_t b_vec = vcvtq_f32_s32(a_vec);\n        b_vec = vmulq_f32(b_vec, vscale);\n        vst1q_f32(B + i, b_vec);\n    }\n    \n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale_factor;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_f);\n\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_vec = vld1q_s32(A + i);\n        float32x4_t a_float = vcvtq_f32_s32(a_vec);\n        float32x4_t b_vec = vmulq_f32(a_float, scale_vec);\n        vst1q_f32(B + i, b_vec);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale_f;\n    }\n}\n```"}
{"task_id": "SimdBench_51_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    float32x4_t scale_vec = vdupq_n_f32(scale_f);\n    size_t i = 0;\n\n    for (; i + 3 < size; i += 4) {\n        int32x4_t a_val = vld1q_s32(A + i);\n        float32x4_t b_val = vcvtq_f32_s32(a_val);\n        b_val = vmulq_f32(b_val, scale_vec);\n        vst1q_f32(B + i, b_val);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (float)A[i] * scale_f;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        float32x4_t vrounded = vrndnq_f32(vdiv);\n        int32x4_t vc = vcvtq_s32_f32(vrounded);\n        vst1q_s32(C + i, vc);\n    }\n    \n    for (; i < size; i++) {\n        float32x2_t vdiv = vdup_n_f32(A[i] / B[i]);\n        float32x2_t vrounded = vrndn_f32(vdiv);\n        float rounded = vget_lane_f32(vrounded, 0);\n        C[i] = (int32_t)rounded;\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    const size_t vec_size = size - 3;\n\n    for (; i < vec_size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t div_vec = vdivq_f32(a_vec, b_vec);\n        int32x4_t res_vec = vcvtnq_s32_f32(div_vec);\n        vst1q_s32(C + i, res_vec);\n    }\n\n    for (; i < size; i++) {\n        float div = A[i] / B[i];\n        C[i] = vcvts_s32_f32(div);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t div_vec = vdivq_f32(a_vec, b_vec);\n        int32x4_t int_vec = vcvtnq_s32_f32(div_vec);\n        vst1q_s32(C + i, int_vec);\n    }\n\n    size_t rem = size - i;\n    if (rem) {\n        float32x4_t a_vec = vdupq_n_f32(0.0f);\n        float32x4_t b_vec = vdupq_n_f32(1.0f);\n\n        if (rem >= 1) {\n            a_vec = vld1q_lane_f32(A + i, a_vec, 0);\n            b_vec = vld1q_lane_f32(B + i, b_vec, 0);\n        }\n        if (rem >= 2) {\n            a_vec = vld1q_lane_f32(A + i + 1, a_vec, 1);\n            b_vec = vld1q_lane_f32(B + i + 1, b_vec, 1);\n        }\n        if (rem >= 3) {\n            a_vec = vld1q_lane_f32(A + i + 2, a_vec, 2);\n            b_vec = vld1q_lane_f32(B + i + 2, b_vec, 2);\n        }\n\n        float32x4_t div_vec = vdivq_f32(a_vec, b_vec);\n        int32x4_t int_vec = vcvtnq_s32_f32(div_vec);\n\n        if (rem == 1) {\n            vst1q_lane_s32(C + i, int_vec, 0);\n        } else if (rem == 2) {\n            vst1_s32(C + i, vget_low_s32(int_vec));\n        } else if (rem == 3) {\n            vst1_s32(C + i, vget_low_s32(int_vec));\n            vst1q_lane_s32(C + i + 2, int_vec, 2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    const size_t step = 4;\n\n    for (; i + step <= size; i += step) {\n        float32x4_t va = vld1q_f32(A + i);\n        float32x4_t vb = vld1q_f32(B + i);\n        float32x4_t vdiv = vdivq_f32(va, vb);\n        int32x4_t vres = vcvtnq_s32_f32(vdiv);\n        vst1q_s32(C + i, vres);\n    }\n\n    for (; i < size; ++i) {\n        float div = A[i] / B[i];\n        C[i] = (int32_t)lroundf(div);\n    }\n}\n```"}
{"task_id": "SimdBench_52_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        float32x4_t b_vec = vld1q_f32(B + i);\n        float32x4_t div_vec = vdivq_f32(a_vec, b_vec);\n        int32x4_t c_vec = vcvtnq_s32_f32(div_vec);\n        vst1q_s32(C + i, c_vec);\n    }\n\n    if (size - i >= 2) {\n        float32x2_t a_vec = vld1_f32(A + i);\n        float32x2_t b_vec = vld1_f32(B + i);\n        float32x2_t div_vec = vdiv_f32(a_vec, b_vec);\n        int32x2_t c_vec = vcvtn_s32_f32(div_vec);\n        vst1_s32(C + i, c_vec);\n        i += 2;\n    }\n\n    if (i < size) {\n        float32x2_t a_vec = vld1_dup_f32(A + i);\n        float32x2_t b_vec = vld1_dup_f32(B + i);\n        float32x2_t div_vec = vdiv_f32(a_vec, b_vec);\n        int32x2_t c_vec = vcvtn_s32_f32(div_vec);\n        vst1_lane_s32(C + i, c_vec, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cfloat>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const double flt_max_d = static_cast<double>(FLT_MAX);\n    const double neg_flt_max_d = static_cast<double>(-FLT_MAX);\n    const float64x2_t flt_max_vec = vdupq_n_f64(flt_max_d);\n    const float64x2_t neg_flt_max_vec = vdupq_n_f64(neg_flt_max_d);\n\n    size_t i = 0;\n    for (; i + 2 <= size; i += 2) {\n        float64x2_t a_val = vld1q_f64(A + i);\n        a_val = vminq_f64(a_val, flt_max_vec);\n        a_val = vmaxq_f64(a_val, neg_flt_max_vec);\n        float32x2_t b_val = vcvt_f32_f64(a_val);\n        vst1_f32(B + i, b_val);\n    }\n\n    if (i < size) {\n        double a0 = A[i];\n        if (a0 > flt_max_d) a0 = flt_max_d;\n        else if (a0 < neg_flt_max_d) a0 = neg_flt_max_d;\n        B[i] = static_cast<float>(a0);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cfloat>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const double max_float_d = static_cast<double>(FLT_MAX);\n    const double min_float_d = -max_float_d;\n    const float64x2_t vmax = vdupq_n_f64(max_float_d);\n    const float64x2_t vmin = vdupq_n_f64(min_float_d);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        float64x2_t a_val = vld1q_f64(A + i);\n        a_val = vminq_f64(a_val, vmax);\n        a_val = vmaxq_f64(a_val, vmin);\n        float32x2_t b_val = vcvt_f32_f64(a_val);\n        vst1_f32(B + i, b_val);\n    }\n\n    if (i < size) {\n        double a = A[i];\n        if (a > max_float_d) {\n            a = max_float_d;\n        } else if (a < min_float_d) {\n            a = min_float_d;\n        }\n        B[i] = static_cast<float>(a);\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const double max_float = (double)FLT_MAX;\n    const double min_float = (double)-FLT_MAX;\n    float64x2_t vmax = vdupq_n_f64(max_float);\n    float64x2_t vmin = vdupq_n_f64(min_float);\n    \n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        float64x2_t a_val = vld1q_f64(A + i);\n        a_val = vminq_f64(a_val, vmax);\n        a_val = vmaxq_f64(a_val, vmin);\n        float32x2_t res = vcvt_f32_f64(a_val);\n        vst1_f32(B + i, res);\n    }\n    \n    if (i < size) {\n        double last_val = A[i];\n        if (last_val > max_float) last_val = max_float;\n        else if (last_val < min_float) last_val = min_float;\n        B[i] = (float)last_val;\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const double flt_max_d = (double)FLT_MAX;\n    const double neg_flt_max_d = (double)(-FLT_MAX);\n    float64x2_t v_max = vdupq_n_f64(flt_max_d);\n    float64x2_t v_min = vdupq_n_f64(neg_flt_max_d);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        float64x2_t a_val = vld1q_f64(A + i);\n        a_val = vminq_f64(a_val, v_max);\n        a_val = vmaxq_f64(a_val, v_min);\n        float32x2_t f_val = vcvt_f32_f64(a_val);\n        vst1_f32(B + i, f_val);\n    }\n\n    if (i < size) {\n        double a_val = A[i];\n        if (a_val > flt_max_d) {\n            a_val = flt_max_d;\n        } else if (a_val < neg_flt_max_d) {\n            a_val = neg_flt_max_d;\n        }\n        B[i] = (float)a_val;\n    }\n}\n```"}
{"task_id": "SimdBench_53_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <cfloat>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    const double dbl_max = (double)FLT_MAX;\n    const double dbl_min = (double)(-FLT_MAX);\n    const float flt_max = FLT_MAX;\n    const float flt_min = -FLT_MAX;\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        float64x2_t a_vec = vld1q_f64(A + i);\n        a_vec = vmaxq_f64(a_vec, vdupq_n_f64(dbl_min));\n        a_vec = vminq_f64(a_vec, vdupq_n_f64(dbl_max));\n        float32x2_t b_vec = vcvt_f32_f64(a_vec);\n        vst1_f32(B + i, b_vec);\n    }\n\n    if (i < size) {\n        double a_val = A[i];\n        if (a_val > dbl_max) {\n            B[i] = flt_max;\n        } else if (a_val < dbl_min) {\n            B[i] = flt_min;\n        } else {\n            B[i] = (float)a_val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t a_vec = vld1q_s16(A + i);\n        int32x4_t low_vec = vmovl_s16(vget_low_s16(a_vec));\n        int32x4_t high_vec = vmovl_s16(vget_high_s16(a_vec));\n        vst1q_s32(B + i, low_vec);\n        vst1q_s32(B + i + 4, high_vec);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t a_vec = vld1q_s16(A + i);\n        int32x4_t low_part = vmovl_s16(vget_low_s16(a_vec));\n        int32x4_t high_part = vmovl_s16(vget_high_s16(a_vec));\n        vst1q_s32(B + i, low_part);\n        vst1q_s32(B + i + 4, high_part);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 7 < size; i += 8) {\n        int16x8_t a8 = vld1q_s16(A + i);\n        int32x4_t low = vmovl_s16(vget_low_s16(a8));\n        int32x4_t high = vmovl_high_s16(a8);\n        vst1q_s32(B + i, low);\n        vst1q_s32(B + i + 4, high);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n\n    for (; i + 7 < size; i += 8) {\n        int16x8_t a16 = vld1q_s16(A + i);\n        int32x4_t low = vmovl_s16(vget_low_s16(a16));\n        int32x4_t high = vmovl_s16(vget_high_s16(a16));\n        vst1q_s32(B + i, low);\n        vst1q_s32(B + i + 4, high);\n    }\n\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    for (; i + 8 <= size; i += 8) {\n        int16x8_t a16 = vld1q_s16(A + i);\n        int32x4_t low32 = vmovl_s16(vget_low_s16(a16));\n        int32x4_t high32 = vmovl_s16(vget_high_s16(a16));\n        vst1q_s32(B + i, low32);\n        vst1q_s32(B + i + 4, high32);\n    }\n    for (; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    float scale_val = (range == 0.0f) ? 0.0f : 1.0f / range;\n    \n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t scale_vec = vdupq_n_f32(scale_val);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    int32x4_t zero_control = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t ctrl_vec = vld1q_s32(control + i);\n        uint32x4_t mask = vcgtq_s32(ctrl_vec, zero_control);\n\n        float32x4_t normalized_vec = vsubq_f32(a_vec, min_val_vec);\n        normalized_vec = vmulq_f32(normalized_vec, scale_vec);\n        normalized_vec = vmaxq_f32(normalized_vec, zero_vec);\n        normalized_vec = vminq_f32(normalized_vec, one_vec);\n        \n        float32x4_t result = vbslq_f32(mask, normalized_vec, a_vec);\n        vst1q_f32(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) * scale_val;\n            if (val < 0.0f) val = 0.0f;\n            else if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    float inv_range = 1.0f / range;\n    \n    float32x4_t min_val_vec = vdupq_n_f32(min_val);\n    float32x4_t inv_range_vec = vdupq_n_f32(inv_range);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    int32x4_t zero_int = vdupq_n_s32(0);\n    \n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t ctrl_vec = vld1q_s32(control + i);\n        \n        uint32x4_t mask = vreinterpretq_u32_s32(vcgtq_s32(ctrl_vec, zero_int));\n        \n        float32x4_t normalized_vec = vsubq_f32(a_vec, min_val_vec);\n        normalized_vec = vmulq_f32(normalized_vec, inv_range_vec);\n        normalized_vec = vmaxq_f32(normalized_vec, zero_vec);\n        normalized_vec = vminq_f32(normalized_vec, one_vec);\n        \n        float32x4_t res = vbslq_f32(mask, normalized_vec, a_vec);\n        vst1q_f32(B + i, res);\n    }\n    \n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) * inv_range;\n            if (val < 0.0f) val = 0.0f;\n            else if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float denom = max_val - min_val;\n    float denom_recip = 1.0f / denom;\n    \n    float32x4_t v_min = vdupq_n_f32(min_val);\n    float32x4_t v_recip = vdupq_n_f32(denom_recip);\n    float32x4_t v_zero = vdupq_n_f32(0.0f);\n    float32x4_t v_one = vdupq_n_f32(1.0f);\n    int32x4_t v_zero_control = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t a_val = vld1q_f32(A + i);\n        int32x4_t c_val = vld1q_s32(control + i);\n        \n        uint32x4_t mask = vcgtq_s32(c_val, v_zero_control);\n        \n        float32x4_t normalized = vsubq_f32(a_val, v_min);\n        normalized = vmulq_f32(normalized, v_recip);\n        normalized = vmaxq_f32(normalized, v_zero);\n        normalized = vminq_f32(normalized, v_one);\n        \n        float32x4_t result = vbslq_f32(mask, normalized, a_val);\n        vst1q_f32(B + i, result);\n    }\n    \n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) * denom_recip;\n            val = val < 0.0f ? 0.0f : (val > 1.0f ? 1.0f : val);\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float denom = max_val - min_val;\n    float32x4_t min_vec = vdupq_n_f32(min_val);\n    float32x4_t denom_vec = vdupq_n_f32(denom);\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t one_vec = vdupq_n_f32(1.0f);\n    int32x4_t zero_control = vdupq_n_s32(0);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t ctrl_vec = vld1q_s32(control + i);\n        uint32x4_t mask = vcgtq_s32(ctrl_vec, zero_control);\n\n        float32x4_t normalized = vsubq_f32(a_vec, min_vec);\n        normalized = vdivq_f32(normalized, denom_vec);\n        normalized = vmaxq_f32(normalized, zero_vec);\n        normalized = vminq_f32(normalized, one_vec);\n\n        float32x4_t result = vbslq_f32(mask, normalized, a_vec);\n        vst1q_f32(B + i, result);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = (A[i] - min_val) / denom;\n            if (val < 0.0f) val = 0.0f;\n            else if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float denom = max_val - min_val;\n    float inv_denom = (denom == 0.0f) ? 0.0f : (1.0f / denom);\n    float factor = inv_denom;\n    float offset = -min_val * inv_denom;\n\n    size_t i = 0;\n    for (; i <= size - 4; i += 4) {\n        float32x4_t a_vec = vld1q_f32(A + i);\n        int32x4_t c_vec = vld1q_s32(control + i);\n        uint32x4_t mask = vcgtq_s32(c_vec, vdupq_n_s32(0));\n\n        float32x4_t normalized_vec = vmlaq_n_f32(vdupq_n_f32(offset), a_vec, factor);\n        normalized_vec = vmaxq_f32(normalized_vec, vdupq_n_f32(0.0f));\n        normalized_vec = vminq_f32(normalized_vec, vdupq_n_f32(1.0f));\n\n        float32x4_t res = vbslq_f32(mask, normalized_vec, a_vec);\n        vst1q_f32(B + i, res);\n    }\n\n    for (; i < size; i++) {\n        if (control[i] > 0) {\n            float val = A[i] * factor + offset;\n            if (val < 0.0f) val = 0.0f;\n            else if (val > 1.0f) val = 1.0f;\n            B[i] = val;\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        uint32x4_t va = vld1q_u32(A + i);\n        uint32x4_t va_shifted = vshrq_n_u32(va, 16);\n        float32x4_t vf = vcvtq_f32_u32(va_shifted);\n        float32x4_t vsqrt = vsqrtq_f32(vf);\n        vst1q_f32(B + i, vsqrt);\n    }\n    for (; i < size; i++) {\n        uint32_t high16 = A[i] >> 16;\n        float val = (float)high16;\n        B[i] = sqrtf(val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t step = 4;\n    for (; i + step <= size; i += step) {\n        uint32x4_t data = vld1q_u32(A + i);\n        uint32x4_t high_bits = vshrq_n_u32(data, 16);\n        float32x4_t float_data = vcvtq_f32_u32(high_bits);\n        float32x4_t sqrt_data = vsqrtq_f32(float_data);\n        vst1q_f32(B + i, sqrt_data);\n    }\n    \n    for (; i < size; i++) {\n        uint32_t val = A[i];\n        uint32_t high = val >> 16;\n        float f = (float)high;\n        B[i] = sqrtf(f);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 3 < size; i += 4) {\n        uint32x4_t va = vld1q_u32(A + i);\n        va = vshrq_n_u32(va, 16);\n        float32x4_t vf = vcvtq_f32_u32(va);\n        vf = vsqrtq_f32(vf);\n        vst1q_f32(B + i, vf);\n    }\n    for (; i < size; ++i) {\n        uint32_t val = A[i] >> 16;\n        B[i] = sqrtf((float)val);\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        uint32x4_t high_vec = vshrq_n_u32(a_vec, 16);\n        float32x4_t float_vec = vcvtq_f32_u32(high_vec);\n        float32x4_t sqrt_vec = vsqrtq_f32(float_vec);\n        vst1q_f32(B + i, sqrt_vec);\n    }\n    for (; i < size; i++) {\n        uint32_t high = A[i] >> 16;\n        float32_t f_val = (float32_t)high;\n        float32_t sqrt_val = vsqrt_f32(f_val);\n        B[i] = sqrt_val;\n    }\n}\n```"}
{"task_id": "SimdBench_56_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        uint32x4_t a_vec = vld1q_u32(A + i);\n        a_vec = vshrq_n_u32(a_vec, 16);\n        float32x4_t f_vec = vcvtq_f32_u32(a_vec);\n        float32x4_t sqrt_vec = vsqrtq_f32(f_vec);\n        vst1q_f32(B + i, sqrt_vec);\n    }\n\n    if (i + 2 <= size) {\n        uint32x2_t a_tail = vld1_u32(A + i);\n        a_tail = vshr_n_u32(a_tail, 16);\n        float32x2_t f_tail = vcvt_f32_u32(a_tail);\n        float32x2_t sqrt_tail = vsqrt_f32(f_tail);\n        vst1_f32(B + i, sqrt_tail);\n        i += 2;\n    }\n\n    if (i < size) {\n        uint32_t a_val = A[i];\n        uint32_t high16 = a_val >> 16;\n        float32x2_t single = vdup_n_f32((float)high16);\n        single = vsqrt_f32(single);\n        B[i] = vget_lane_f32(single, 0);\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t simd_elements = 4;\n    size_t num_simd_iters = size / simd_elements;\n\n    for (; i < num_simd_iters * simd_elements; i += simd_elements) {\n        uint32x4_t vec = vld1q_u32(A + i);\n        float32x4_t fvec = vreinterpretq_f32_u32(vec);\n        vst1q_f32(B + i, fvec);\n    }\n\n    for (; i < size; i++) {\n        uint32_t val = A[i];\n        B[i] = *(float*)&val;\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t vector_size = 4;\n    for (; i + vector_size - 1 < size; i += vector_size) {\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(B + i, float_vec);\n    }\n    for (; i < size; ++i) {\n        uint32_t u = A[i];\n        memcpy(B + i, &u, sizeof(u));\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    if (size == 0) return;\n\n    const uint32_t* a_ptr = A;\n    float* b_ptr = B;\n    const uint32_t* end = A + size;\n\n    while (a_ptr + 4 <= end) {\n        uint32x4_t u32_vec = vld1q_u32(a_ptr);\n        float32x4_t f32_vec = vreinterpretq_f32_u32(u32_vec);\n        vst1q_f32(b_ptr, f32_vec);\n        a_ptr += 4;\n        b_ptr += 4;\n    }\n\n    while (a_ptr < end) {\n        union { uint32_t u; float f; } pun;\n        pun.u = *a_ptr++;\n        *b_ptr++ = pun.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t num_chunks = size / 4;\n    \n    for (; i < num_chunks * 4; i += 4) {\n        uint32x4_t vec_uint = vld1q_u32(A + i);\n        float32x4_t vec_float = vreinterpretq_f32_u32(vec_uint);\n        vst1q_f32(B + i, vec_float);\n    }\n    \n    for (; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } converter;\n        converter.u = A[i];\n        B[i] = converter.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t simd_elements = 4;\n    size_t end = size / simd_elements * simd_elements;\n\n    for (; i < end; i += simd_elements) {\n        uint32x4_t int_vec = vld1q_u32(A + i);\n        float32x4_t float_vec = vreinterpretq_f32_u32(int_vec);\n        vst1q_f32(B + i, float_vec);\n    }\n\n    for (; i < size; ++i) {\n        uint32_t int_val = A[i];\n        float float_val;\n        memcpy(&float_val, &int_val, sizeof(float));\n        B[i] = float_val;\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    if (size <= 1) {\n        return;\n    }\n\n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t vA_prev = vld1q_s32(A + i - 1);\n        int32x4_t vA_curr = vld1q_s32(A + i);\n        int32x4_t vDiff_int = vsubq_s32(vA_curr, vA_prev);\n        float32x4_t vDiff_float = vcvtq_f32_s32(vDiff_int);\n\n        uint8x8_t vCond8 = vld1_u8((const uint8_t*)(cond + i));\n        uint16x8_t vCond16 = vmovl_u8(vCond8);\n        uint16x4_t vCond16_low = vget_low_u16(vCond16);\n        uint32x4_t vCond32 = vmovl_u16(vCond16_low);\n        uint32x4_t vMask32 = vcgtq_u32(vCond32, vdupq_n_u32(0));\n\n        float32x4_t vZero = vdupq_n_f32(0.0f);\n        float32x4_t vResult = vbslq_f32(vMask32, vDiff_float, vZero);\n        vst1q_f32(diff + i, vResult);\n    }\n\n    for (; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    if (size <= 1) return;\n    \n    size_t i = 1;\n    for (; i <= size - 8; i += 8) {\n        uint8x8_t cond8 = vld1_u8((const uint8_t*)(cond + i));\n        uint8x8_t mask8 = vcgt_u8(cond8, vdup_n_u8(0));\n        \n        int8x8_t mask8_s = vreinterpret_s8_u8(mask8);\n        int16x8_t mask16_s = vmovl_s8(mask8_s);\n        int32x4_t mask32_low_s = vmovl_s16(vget_low_s16(mask16_s));\n        int32x4_t mask32_high_s = vmovl_high_s16(mask16_s);\n        uint32x4_t mask32_low = vreinterpretq_u32_s32(mask32_low_s);\n        uint32x4_t mask32_high = vreinterpretq_u32_s32(mask32_high_s);\n        \n        int32x4_t cur1 = vld1q_s32(A + i);\n        int32x4_t cur2 = vld1q_s32(A + i + 4);\n        int32x4_t prev1 = vld1q_s32(A + i - 1);\n        int32x4_t prev2 = vld1q_s32(A + i + 3);\n        \n        int32x4_t diff1 = vsubq_s32(cur1, prev1);\n        int32x4_t diff2 = vsubq_s32(cur2, prev2);\n        \n        float32x4_t fdiff1 = vcvtq_f32_s32(diff1);\n        float32x4_t fdiff2 = vcvtq_f32_s32(diff2);\n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        \n        float32x4_t res1 = vbslq_f32(mask32_low, fdiff1, zeros);\n        float32x4_t res2 = vbslq_f32(mask32_high, fdiff2, zeros);\n        \n        vst1q_f32(diff + i, res1);\n        vst1q_f32(diff + i + 4, res2);\n    }\n    \n    for (; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <string.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    if (size == 1) return;\n\n    size_t i = 1;\n    if (size >= 5) {\n        for (; i <= size - 4; i += 4) {\n            uint32_t cond_scalar;\n            memcpy(&cond_scalar, cond + i, 4);\n            uint8x8_t cond8 = vreinterpret_u8_u32(vdup_n_u32(cond_scalar));\n            uint16x8_t cond16 = vmovl_u8(cond8);\n            uint16x4_t cond16_low = vget_low_u16(cond16);\n            uint32x4_t cond32 = vmovl_u16(cond16_low);\n            uint32x4_t mask32 = vcgtq_u32(cond32, vdupq_n_u32(0));\n\n            int32x4_t vecA_prev = vld1q_s32(A + i - 1);\n            int32x4_t vecA_curr = vld1q_s32(A + i);\n            int32x4_t diff_i32 = vsubq_s32(vecA_curr, vecA_prev);\n            float32x4_t diff_f32 = vcvtq_f32_s32(diff_i32);\n            float32x4_t zeros = vdupq_n_f32(0.0f);\n            float32x4_t result = vbslq_f32(mask32, diff_f32, zeros);\n            vst1q_f32(diff + i, result);\n        }\n    }\n\n    for (; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i - 1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <string.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    if (size <= 1) return;\n\n    size_t i = 1;\n    for (; i <= size - 4; i += 4) {\n        int32x4_t current = vld1q_s32(A + i);\n        int32x4_t previous = vld1q_s32(A + i - 1);\n        int32x4_t diff_int = vsubq_s32(current, previous);\n        float32x4_t diff_float = vcvtq_f32_s32(diff_int);\n\n        uint32_t cond4;\n        memcpy(&cond4, cond + i, 4);\n        uint32x2_t cond32_vec = vset_lane_u32(cond4, vmov_n_u32(0), 0);\n        uint8x8_t cond8 = vreinterpret_u8_u32(cond32_vec);\n        uint8x8_t mask8 = vtst_u8(cond8, vdup_n_u8(0xFF));\n        uint16x8_t mask16 = vmovl_u8(mask8);\n        uint32x4_t mask32 = vmovl_u16(vget_low_u16(mask16));\n        mask32 = vshrq_n_u32(mask32, 7);\n        float32x4_t cond_float = vcvtq_f32_u32(mask32);\n\n        diff_float = vmulq_f32(diff_float, cond_float);\n        vst1q_f32(diff + i, diff_float);\n    }\n\n    for (; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    if (size == 1) return;\n    \n    size_t i = 1;\n    for (; i + 3 < size; i += 4) {\n        int32x4_t cur = vld1q_s32(A + i);\n        int32x4_t prev = vld1q_s32(A + i - 1);\n        int32x4_t d_int = vsubq_s32(cur, prev);\n        float32x4_t d_float = vcvtq_f32_s32(d_int);\n        \n        uint32_t four_bools;\n        __builtin_memcpy(&four_bools, cond + i, sizeof(uint32_t));\n        uint8x8_t cond8 = vcreate_u8((uint64_t)four_bools);\n        uint16x8_t cond16 = vmovl_u8(cond8);\n        uint32x4_t cond32 = vmovl_u16(vget_low_u16(cond16));\n        uint32x4_t mask = vcgtq_u32(cond32, vdupq_n_u32(0));\n        \n        float32x4_t res = vbslq_f32(mask, d_float, vdupq_n_f32(0.0f));\n        vst1q_f32(diff + i, res);\n    }\n    \n    for (; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    const uint64x2_t pattern = vdupq_n_u64(0xFFFFFFFF00000000ULL);\n    size_t i = 0;\n    \n    for (; i + 3 < length; i += 4) {\n        uint32x4_t vec32 = vld1q_u32(src + i);\n        uint32x2_t low32 = vget_low_u32(vec32);\n        uint32x2_t high32 = vget_high_u32(vec32);\n        \n        uint64x2_t low64 = vorrq_u64(vmovl_u32(low32), pattern);\n        uint64x2_t high64 = vorrq_u64(vmovl_u32(high32), pattern);\n        \n        vst1q_u64(dst + i, low64);\n        vst1q_u64(dst + i + 2, high64);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = (0xFFFFFFFF00000000ULL) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    const uint64x2_t mask = vdupq_n_u64(0xFFFFFFFF00000000ULL);\n\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t in = vld1q_u32(src + i);\n        uint32x2_t in_low = vget_low_u32(in);\n        uint32x2_t in_high = vget_high_u32(in);\n\n        uint64x2_t out_low = vorrq_u64(vmovl_u32(in_low), mask);\n        uint64x2_t out_high = vorrq_u64(vmovl_u32(in_high), mask);\n\n        vst1q_u64(dst + i, out_low);\n        vst1q_u64(dst + i + 2, out_high);\n    }\n\n    for (; i < length; i++) {\n        dst[i] = (0xFFFFFFFF00000000ULL) | (uint64_t)src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    const uint64x2_t high_bits = vdupq_n_u64(0xFFFFFFFF00000000ULL);\n    size_t i = 0;\n    \n    for (; i + 3 < length; i += 4) {\n        uint32x4_t src_vec = vld1q_u32(src + i);\n        uint64x2_t low = vmovl_u32(vget_low_u32(src_vec));\n        uint64x2_t high = vmovl_u32(vget_high_u32(src_vec));\n        low = vorrq_u64(low, high_bits);\n        high = vorrq_u64(high, high_bits);\n        vst1q_u64(dst + i, low);\n        vst1q_u64(dst + i + 2, high);\n    }\n    \n    for (; i < length; ++i) {\n        dst[i] = 0xFFFFFFFF00000000ULL | (uint64_t)src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    const uint64_t mask_val = 0xFFFFFFFF00000000ULL;\n    uint64x2_t mask = vdupq_n_u64(mask_val);\n    size_t i = 0;\n    \n    for (; i + 3 < length; i += 4) {\n        uint32x4_t in = vld1q_u32(src + i);\n        uint32x2_t in_low = vget_low_u32(in);\n        uint32x2_t in_high = vget_high_u32(in);\n        uint64x2_t low = vorrq_u64(vmovl_u32(in_low), mask);\n        uint64x2_t high = vorrq_u64(vmovl_u32(in_high), mask);\n        vst1q_u64(dst + i, low);\n        vst1q_u64(dst + i + 2, high);\n    }\n    \n    for (; i < length; i++) {\n        dst[i] = mask_val | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    const uint64x2_t mask = vdupq_n_u64(0xFFFFFFFF00000000ULL);\n    size_t i = 0;\n\n    for (; i + 3 < length; i += 4) {\n        uint32x4_t vec32 = vld1q_u32(src + i);\n        uint64x2_t low64 = vmovl_u32(vget_low_u32(vec32));\n        uint64x2_t high64 = vmovl_u32(vget_high_u32(vec32));\n        low64 = vorrq_u64(low64, mask);\n        high64 = vorrq_u64(high64, mask);\n        vst1q_u64(dst + i, low64);\n        vst1q_u64(dst + i + 2, high64);\n    }\n\n    if (i + 1 < length) {\n        uint32x2_t vec32 = vld1_u32(src + i);\n        uint64x2_t vec64 = vmovl_u32(vec32);\n        vec64 = vorrq_u64(vec64, mask);\n        vst1q_u64(dst + i, vec64);\n        i += 2;\n    }\n\n    if (i < length) {\n        dst[i] = (0xFFFFFFFF00000000ULL) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) return 0.0;\n    \n    uint64_t i = 0;\n    double sum = 0.0;\n    float64x2_t sumv0 = vdupq_n_f64(0.0);\n    float64x2_t sumv1 = vdupq_n_f64(0.0);\n    float64x2_t sumv2 = vdupq_n_f64(0.0);\n    float64x2_t sumv3 = vdupq_n_f64(0.0);\n    \n    for (; i + 7 < length; i += 8) {\n        int16x8_t vidx16 = vld1q_s16(index + i);\n        \n        int32x4_t vidx32_low = vmovl_s16(vget_low_s16(vidx16));\n        int32x4_t vidx32_high = vmovl_s16(vget_high_s16(vidx16));\n        \n        int32x2_t vidx32_low_low = vget_low_s32(vidx32_low);\n        int32x2_t vidx32_low_high = vget_high_s32(vidx32_low);\n        int32x2_t vidx32_high_low = vget_low_s32(vidx32_high);\n        int32x2_t vidx32_high_high = vget_high_s32(vidx32_high);\n        \n        int64x2_t vidx64_ll = vmovl_s32(vidx32_low_low);\n        int64x2_t vidx64_lh = vmovl_s32(vidx32_low_high);\n        int64x2_t vidx64_hl = vmovl_s32(vidx32_high_low);\n        int64x2_t vidx64_hh = vmovl_s32(vidx32_high_high);\n        \n        double d0 = vec[vgetq_lane_s64(vidx64_ll, 0)];\n        double d1 = vec[vgetq_lane_s64(vidx64_ll, 1)];\n        double d2 = vec[vgetq_lane_s64(vidx64_lh, 0)];\n        double d3 = vec[vgetq_lane_s64(vidx64_lh, 1)];\n        double d4 = vec[vgetq_lane_s64(vidx64_hl, 0)];\n        double d5 = vec[vgetq_lane_s64(vidx64_hl, 1)];\n        double d6 = vec[vgetq_lane_s64(vidx64_hh, 0)];\n        double d7 = vec[vgetq_lane_s64(vidx64_hh, 1)];\n        \n        float64x2_t v0 = (float64x2_t){d0, d1};\n        float64x2_t v1 = (float64x2_t){d2, d3};\n        float64x2_t v2 = (float64x2_t){d4, d5};\n        float64x2_t v3 = (float64x2_t){d6, d7};\n        \n        sumv0 = vaddq_f64(sumv0, v0);\n        sumv1 = vaddq_f64(sumv1, v1);\n        sumv2 = vaddq_f64(sumv2, v2);\n        sumv3 = vaddq_f64(sumv3, v3);\n    }\n    \n    sumv0 = vaddq_f64(sumv0, sumv1);\n    sumv2 = vaddq_f64(sumv2, sumv3);\n    sumv0 = vaddq_f64(sumv0, sumv2);\n    \n    double temp[2];\n    vst1q_f64(temp, sumv0);\n    sum = temp[0] + temp[1];\n    \n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) {\n        return 0.0;\n    }\n\n    float64x2_t sum0 = vdupq_n_f64(0.0);\n    float64x2_t sum1 = vdupq_n_f64(0.0);\n    size_t i = 0;\n\n    for (; i + 3 < length; i += 4) {\n        int16x4_t idx_vec = vld1_s16(index + i);\n        \n        int idx0 = vget_lane_s16(idx_vec, 0);\n        int idx1 = vget_lane_s16(idx_vec, 1);\n        int idx2 = vget_lane_s16(idx_vec, 2);\n        int idx3 = vget_lane_s16(idx_vec, 3);\n\n        double val0 = vec[idx0];\n        double val1 = vec[idx1];\n        double val2 = vec[idx2];\n        double val3 = vec[idx3];\n\n        float64x2_t v0 = vsetq_lane_f64(val0, vdupq_n_f64(0.0), 0);\n        v0 = vsetq_lane_f64(val1, v0, 1);\n        float64x2_t v1 = vsetq_lane_f64(val2, vdupq_n_f64(0.0), 0);\n        v1 = vsetq_lane_f64(val3, v1, 1);\n\n        sum0 = vaddq_f64(sum0, v0);\n        sum1 = vaddq_f64(sum1, v1);\n    }\n\n    sum0 = vaddq_f64(sum0, sum1);\n    double result = vgetq_lane_f64(sum0, 0) + vgetq_lane_f64(sum0, 1);\n\n    for (; i < length; i++) {\n        int16_t idx_val = index[i];\n        result += vec[idx_val];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    const int16_t* index_ptr = index;\n    float64x2_t acc0 = vdupq_n_f64(0.0);\n    float64x2_t acc1 = vdupq_n_f64(0.0);\n    float64x2_t acc2 = vdupq_n_f64(0.0);\n    float64x2_t acc3 = vdupq_n_f64(0.0);\n    size_t i = 0;\n    const char* base = (const char*)vec;\n\n    for (; i + 7 < length; i += 8, index_ptr += 8) {\n        int16x8_t idx_v = vld1q_s16(index_ptr);\n        int16x4_t idx_low = vget_low_s16(idx_v);\n        int16x4_t idx_high = vget_high_s16(idx_v);\n        int32x4_t off32_low = vshlq_n_s32(vmovl_s16(idx_low), 3);\n        int32x4_t off32_high = vshlq_n_s32(vmovl_s16(idx_high), 3);\n\n        uint32_t off0 = (uint32_t)vgetq_lane_s32(off32_low, 0);\n        uint32_t off1 = (uint32_t)vgetq_lane_s32(off32_low, 1);\n        uint32_t off2 = (uint32_t)vgetq_lane_s32(off32_low, 2);\n        uint32_t off3 = (uint32_t)vgetq_lane_s32(off32_low, 3);\n        uint32_t off4 = (uint32_t)vgetq_lane_s32(off32_high, 0);\n        uint32_t off5 = (uint32_t)vgetq_lane_s32(off32_high, 1);\n        uint32_t off6 = (uint32_t)vgetq_lane_s32(off32_high, 2);\n        uint32_t off7 = (uint32_t)vgetq_lane_s32(off32_high, 3);\n\n        double val0 = *(const double*)(base + off0);\n        double val1 = *(const double*)(base + off1);\n        double val2 = *(const double*)(base + off2);\n        double val3 = *(const double*)(base + off3);\n        double val4 = *(const double*)(base + off4);\n        double val5 = *(const double*)(base + off5);\n        double val6 = *(const double*)(base + off6);\n        double val7 = *(const double*)(base + off7);\n\n        float64x2_t v0 = (float64x2_t) { val0, val1 };\n        float64x2_t v1 = (float64x2_t) { val2, val3 };\n        float64x2_t v2 = (float64x2_t) { val4, val5 };\n        float64x2_t v3 = (float64x2_t) { val6, val7 };\n\n        acc0 = vaddq_f64(acc0, v0);\n        acc1 = vaddq_f64(acc1, v1);\n        acc2 = vaddq_f64(acc2, v2);\n        acc3 = vaddq_f64(acc3, v3);\n    }\n\n    double tail_sum = 0.0;\n    for (; i < length; i++, index_ptr++) {\n        tail_sum += vec[*index_ptr];\n    }\n\n    acc0 = vaddq_f64(acc0, acc1);\n    acc2 = vaddq_f64(acc2, acc3);\n    acc0 = vaddq_f64(acc0, acc2);\n\n    double sum = vgetq_lane_f64(acc0, 0) + vgetq_lane_f64(acc0, 1);\n    sum += tail_sum;\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) {\n        return 0.0;\n    }\n    \n    uint64_t i = 0;\n    float64x2_t acc = vdupq_n_f64(0.0);\n    \n    for (; i + 7 < length; i += 8) {\n        int16x8_t idx = vld1q_s16(index + i);\n        \n        int16_t idx0 = vgetq_lane_s16(idx, 0);\n        int16_t idx1 = vgetq_lane_s16(idx, 1);\n        int16_t idx2 = vgetq_lane_s16(idx, 2);\n        int16_t idx3 = vgetq_lane_s16(idx, 3);\n        int16_t idx4 = vgetq_lane_s16(idx, 4);\n        int16_t idx5 = vgetq_lane_s16(idx, 5);\n        int16_t idx6 = vgetq_lane_s16(idx, 6);\n        int16_t idx7 = vgetq_lane_s16(idx, 7);\n        \n        double d0 = vec[idx0];\n        double d1 = vec[idx1];\n        double d2 = vec[idx2];\n        double d3 = vec[idx3];\n        double d4 = vec[idx4];\n        double d5 = vec[idx5];\n        double d6 = vec[idx6];\n        double d7 = vec[idx7];\n        \n        float64x2_t v0 = (float64x2_t) {d0, d1};\n        float64x2_t v1 = (float64x2_t) {d2, d3};\n        float64x2_t v2 = (float64x2_t) {d4, d5};\n        float64x2_t v3 = (float64x2_t) {d6, d7};\n        \n        acc = vaddq_f64(acc, v0);\n        acc = vaddq_f64(acc, v1);\n        acc = vaddq_f64(acc, v2);\n        acc = vaddq_f64(acc, v3);\n    }\n    \n    double sum = vgetq_lane_f64(acc, 0) + vgetq_lane_f64(acc, 1);\n    \n    for (; i < length; i++) {\n        int16_t idx = index[i];\n        sum += vec[idx];\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_60_Neon", "completion": "```c\n#include <arm_neon.h>\n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) return 0.0;\n\n    float64x2_t acc0 = vdupq_n_f64(0.0);\n    float64x2_t acc1 = vdupq_n_f64(0.0);\n    float64x2_t acc2 = vdupq_n_f64(0.0);\n    float64x2_t acc3 = vdupq_n_f64(0.0);\n\n    size_t i = 0;\n    const size_t step = 8;\n\n    for (; i + step <= length; i += step) {\n        int16x8_t idx = vld1q_s16(index + i);\n\n        double d0 = vec[vgetq_lane_s16(idx, 0)];\n        double d1 = vec[vgetq_lane_s16(idx, 1)];\n        double d2 = vec[vgetq_lane_s16(idx, 2)];\n        double d3 = vec[vgetq_lane_s16(idx, 3)];\n        double d4 = vec[vgetq_lane_s16(idx, 4)];\n        double d5 = vec[vgetq_lane_s16(idx, 5)];\n        double d6 = vec[vgetq_lane_s16(idx, 6)];\n        double d7 = vec[vgetq_lane_s16(idx, 7)];\n\n        float64x2_t v0 = (float64x2_t) {d0, d1};\n        float64x2_t v1 = (float64x2_t) {d2, d3};\n        float64x2_t v2 = (float64x2_t) {d4, d5};\n        float64x2_t v3 = (float64x2_t) {d6, d7};\n\n        acc0 = vaddq_f64(acc0, v0);\n        acc1 = vaddq_f64(acc1, v1);\n        acc2 = vaddq_f64(acc2, v2);\n        acc3 = vaddq_f64(acc3, v3);\n    }\n\n    acc0 = vaddq_f64(acc0, acc1);\n    acc2 = vaddq_f64(acc2, acc3);\n    acc0 = vaddq_f64(acc0, acc2);\n\n    double sum = vgetq_lane_f64(acc0, 0) + vgetq_lane_f64(acc0, 1);\n\n    for (; i < length; ++i) {\n        sum += vec[index[i]];\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        size_t j = 0;\n        for (; j < output_size - 1; j += 2) {\n            float64x2_t v_total_sum = vdupq_n_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; m++) {\n                const double* input_row_ptr = input + (i + m) * input_size + j;\n                const double* kernel_row_ptr = kernel + m * kernel_size;\n                float64x2_t v_row_sum = vdupq_n_f64(0.0);\n\n                for (size_t n = 0; n < kernel_size; n++) {\n                    float64x2_t v_kernel = vdupq_n_f64(kernel_row_ptr[n]);\n                    float64x2_t v_input = vld1q_f64(input_row_ptr + n);\n                    v_row_sum = vmlaq_f64(v_row_sum, v_kernel, v_input);\n                }\n                v_total_sum = vaddq_f64(v_total_sum, v_row_sum);\n            }\n\n            double total_sum_j0 = vgetq_lane_f64(v_total_sum, 0);\n            double total_sum_j1 = vgetq_lane_f64(v_total_sum, 1);\n\n            if (total_sum_j0 < 0.0) total_sum_j0 = 0.0;\n            if (total_sum_j1 < 0.0) total_sum_j1 = 0.0;\n\n            output[i * output_size + j] = total_sum_j0;\n            output[i * output_size + j + 1] = total_sum_j1;\n        }\n\n        if (j < output_size) {\n            double total_sum = 0.0;\n            for (size_t m = 0; m < kernel_size; m++) {\n                const double* input_row_ptr = input + (i + m) * input_size + j;\n                const double* kernel_row_ptr = kernel + m * kernel_size;\n                for (size_t n = 0; n < kernel_size; n++) {\n                    total_sum += input_row_ptr[n] * kernel_row_ptr[n];\n                }\n            }\n            output[i * output_size + j] = (total_sum > 0.0) ? total_sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t out_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < out_size; i++) {\n        for (size_t j = 0; j < out_size; j++) {\n            double sum = 0.0;\n            for (size_t kr = 0; kr < kernel_size; kr++) {\n                const double* input_row = input + (i + kr) * input_size + j;\n                const double* kernel_row = kernel + kr * kernel_size;\n                float64x2_t row_sum_vec = vdupq_n_f64(0.0);\n                size_t col = 0;\n                while (col + 2 <= kernel_size) {\n                    float64x2_t in_vec = vld1q_f64(input_row + col);\n                    float64x2_t k_vec = vld1q_f64(kernel_row + col);\n                    row_sum_vec = vmlaq_f64(row_sum_vec, in_vec, k_vec);\n                    col += 2;\n                }\n                double row_total = vgetq_lane_f64(row_sum_vec, 0) + vgetq_lane_f64(row_sum_vec, 1);\n                if (col < kernel_size) {\n                    row_total += input_row[col] * kernel_row[col];\n                }\n                sum += row_total;\n            }\n            output[i * out_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n\n            for (size_t kr = 0; kr < kernel_size; kr++) {\n                const double* input_row_ptr = input + (i + kr) * input_size + j;\n                const double* kernel_row_ptr = kernel + kr * kernel_size;\n                float64x2_t acc = vdupq_n_f64(0.0);\n                size_t kc = 0;\n\n                for (; kc + 1 < kernel_size; kc += 2) {\n                    float64x2_t in_vec = vld1q_f64(input_row_ptr + kc);\n                    float64x2_t k_vec = vld1q_f64(kernel_row_ptr + kc);\n                    acc = vmlaq_f64(acc, in_vec, k_vec);\n                }\n\n                double partial_sum = vgetq_lane_f64(acc, 0) + vgetq_lane_f64(acc, 1);\n\n                if (kc < kernel_size) {\n                    partial_sum += input_row_ptr[kc] * kernel_row_ptr[kc];\n                }\n\n                sum += partial_sum;\n            }\n\n            if (sum < 0.0) {\n                sum = 0.0;\n            }\n\n            output[i * output_size + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_dim = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_dim; i++) {\n        for (size_t j = 0; j < output_dim; ) {\n            if (j + 1 < output_dim) {\n                float64x2_t accum0 = vmovq_n_f64(0.0);\n                float64x2_t accum1 = vmovq_n_f64(0.0);\n                \n                for (size_t m = 0; m < kernel_size; m++) {\n                    size_t n = 0;\n                    for (; n <= kernel_size - 2; n += 2) {\n                        float64x2_t kernel_vec = vld1q_f64(kernel + m * kernel_size + n);\n                        float64x2_t input0 = vld1q_f64(input + (i + m) * input_size + j + n);\n                        float64x2_t input1 = vld1q_f64(input + (i + m) * input_size + j + n + 1);\n                        \n                        accum0 = vmlaq_f64(accum0, input0, kernel_vec);\n                        accum1 = vmlaq_f64(accum1, input1, kernel_vec);\n                    }\n                    \n                    if (n < kernel_size) {\n                        double k_val = kernel[m * kernel_size + n];\n                        double in0_val = input[(i + m) * input_size + j + n];\n                        double in1_val = input[(i + m) * input_size + j + n + 1];\n                        \n                        float64x2_t temp0 = vmovq_n_f64(0.0);\n                        temp0 = vsetq_lane_f64(in0_val * k_val, temp0, 0);\n                        accum0 = vaddq_f64(accum0, temp0);\n                        \n                        float64x2_t temp1 = vmovq_n_f64(0.0);\n                        temp1 = vsetq_lane_f64(in1_val * k_val, temp1, 0);\n                        accum1 = vaddq_f64(accum1, temp1);\n                    }\n                }\n                \n                double sum0 = vgetq_lane_f64(accum0, 0) + vgetq_lane_f64(accum0, 1);\n                double sum1 = vgetq_lane_f64(accum1, 0) + vgetq_lane_f64(accum1, 1);\n                \n                if (sum0 < 0.0) sum0 = 0.0;\n                if (sum1 < 0.0) sum1 = 0.0;\n                \n                output[i * output_dim + j] = sum0;\n                output[i * output_dim + j + 1] = sum1;\n                j += 2;\n            } else {\n                float64x2_t accum = vmovq_n_f64(0.0);\n                \n                for (size_t m = 0; m < kernel_size; m++) {\n                    size_t n = 0;\n                    for (; n <= kernel_size - 2; n += 2) {\n                        float64x2_t kernel_vec = vld1q_f64(kernel + m * kernel_size + n);\n                        float64x2_t input_vec = vld1q_f64(input + (i + m) * input_size + j + n);\n                        accum = vmlaq_f64(accum, input_vec, kernel_vec);\n                    }\n                    \n                    if (n < kernel_size) {\n                        double k_val = kernel[m * kernel_size + n];\n                        double in_val = input[(i + m) * input_size + j + n];\n                        float64x2_t temp = vmovq_n_f64(0.0);\n                        temp = vsetq_lane_f64(in_val * k_val, temp, 0);\n                        accum = vaddq_f64(accum, temp);\n                    }\n                }\n                \n                double sum = vgetq_lane_f64(accum, 0) + vgetq_lane_f64(accum, 1);\n                if (sum < 0.0) sum = 0.0;\n                output[i * output_dim + j] = sum;\n                j++;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_Neon", "completion": "```c\n#include <arm_neon.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_dim = input_size - kernel_size + 1;\n    \n    for (size_t i = 0; i < output_dim; i++) {\n        size_t j = 0;\n        for (; j <= output_dim - 2; j += 2) {\n            double total0 = 0.0;\n            double total1 = 0.0;\n            \n            for (size_t kh = 0; kh < kernel_size; kh++) {\n                const double* base = input + (i + kh) * input_size + j;\n                const double* kernel_row = kernel + kh * kernel_size;\n                \n                float64x2_t accum0_row = vdupq_n_f64(0.0);\n                float64x2_t accum1_row = vdupq_n_f64(0.0);\n                size_t kw = 0;\n                \n                for (; kw <= kernel_size - 2; kw += 2) {\n                    float64x2_t k_vec = vld1q_f64(kernel_row + kw);\n                    float64x2_t in0 = vld1q_f64(base + kw);\n                    float64x2_t in1 = vld1q_f64(base + 1 + kw);\n                    \n                    accum0_row = vmlaq_f64(accum0_row, in0, k_vec);\n                    accum1_row = vmlaq_f64(accum1_row, in1, k_vec);\n                }\n                \n                double row_sum0 = vaddvq_f64(accum0_row);\n                double row_sum1 = vaddvq_f64(accum1_row);\n                \n                for (; kw < kernel_size; kw++) {\n                    row_sum0 += base[kw] * kernel_row[kw];\n                    row_sum1 += base[kw + 1] * kernel_row[kw];\n                }\n                \n                total0 += row_sum0;\n                total1 += row_sum1;\n            }\n            \n            if (total0 < 0.0) total0 = 0.0;\n            if (total1 < 0.0) total1 = 0.0;\n            \n            output[i * output_dim + j] = total0;\n            output[i * output_dim + j + 1] = total1;\n        }\n        \n        if (j < output_dim) {\n            double total = 0.0;\n            \n            for (size_t kh = 0; kh < kernel_size; kh++) {\n                const double* base = input + (i + kh) * input_size + j;\n                const double* kernel_row = kernel + kh * kernel_size;\n                \n                float64x2_t accum_row = vdupq_n_f64(0.0);\n                size_t kw = 0;\n                \n                for (; kw <= kernel_size - 2; kw += 2) {\n                    float64x2_t in = vld1q_f64(base + kw);\n                    float64x2_t k = vld1q_f64(kernel_row + kw);\n                    accum_row = vmlaq_f64(accum_row, in, k);\n                }\n                \n                double row_sum = vaddvq_f64(accum_row);\n                \n                for (; kw < kernel_size; kw++) {\n                    row_sum += base[kw] * kernel_row[kw];\n                }\n                \n                total += row_sum;\n            }\n            \n            if (total < 0.0) total = 0.0;\n            output[i * output_dim + j] = total;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold){\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n    if (n == 2) {\n        if (std::fabs(numbers[0] - numbers[1]) < threshold) {\n            return true;\n        }\n        return false;\n    }\n\n    const double* data = numbers.data();\n    float64x2_t thresh_vec = vdupq_n_f64(threshold);\n\n    for (size_t i = 0; i <= n-3; i += 2) {\n        float64x2_t a = vld1q_f64(data + i);\n        float64x2_t b = vld1q_f64(data + i + 1);\n        float64x2_t diff = vabdq_f64(a, b);\n        uint64x2_t mask = vcltq_f64(diff, thresh_vec);\n\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            return true;\n        }\n    }\n\n    if ((n-1) % 2 != 0) {\n        if (std::fabs(data[n-2] - data[n-1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n    const double* data = numbers.data();\n    for (size_t i = 0; i < n - 1; i += 2) {\n        float64x2_t v0 = vld1q_f64(data + i);\n        float64x2_t abs_diff = vabdq_f64(v0, vrev64q_f64(v0));\n        if (vgetq_lane_f64(abs_diff, 0) < threshold) {\n            return true;\n        }\n    }\n    for (size_t i = 1; i < n - 1; i += 2) {\n        float64x2_t v0 = vld1q_f64(data + i);\n        float64x2_t abs_diff = vabdq_f64(v0, vrev64q_f64(v0));\n        if (vgetq_lane_f64(abs_diff, 0) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    int n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n    if (threshold <= 0.0) {\n        return false;\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        double num_i = numbers[i];\n        float64x2_t v_num_i = vdupq_n_f64(num_i);\n        float64x2_t v_thresh = vdupq_n_f64(threshold);\n        \n        int j = i + 1;\n        for (; j <= n - 2; j += 2) {\n            float64x2_t v_nums = vld1q_f64(&numbers[j]);\n            float64x2_t v_diff = vabdq_f64(v_num_i, v_nums);\n            uint64x2_t v_mask = vcltq_f64(v_diff, v_thresh);\n            \n            uint64_t mask0 = vgetq_lane_u64(v_mask, 0);\n            uint64_t mask1 = vgetq_lane_u64(v_mask, 1);\n            if (mask0 || mask1) {\n                return true;\n            }\n        }\n        \n        for (; j < n; j++) {\n            double diff = num_i - numbers[j];\n            if (diff < 0) {\n                diff = -diff;\n            }\n            if (diff < threshold) {\n                return true;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_neon.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n    std::vector<double> sorted = numbers;\n    std::sort(sorted.begin(), sorted.end());\n    const double* data = sorted.data();\n    size_t m = n - 1;\n\n    float64x2_t thresh_vec = vdupq_n_f64(threshold);\n\n    size_t i = 0;\n    if (m >= 2) {\n        for (; i <= m - 2; i += 2) {\n            float64x2_t a = vld1q_f64(data + i);\n            float64x2_t b = vld1q_f64(data + i + 1);\n            float64x2_t diff = vsubq_f64(b, a);\n            uint64x2_t mask = vcleq_f64(diff, thresh_vec);\n            uint64_t low = vgetq_lane_u64(mask, 0);\n            uint64_t high = vgetq_lane_u64(mask, 1);\n            if (low || high) {\n                return true;\n            }\n        }\n    }\n\n    if (i < m) {\n        double diff = data[i+1] - data[i];\n        if (diff <= threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n\n    float64x2_t thresh_vec = vdupq_n_f64(threshold);\n    size_t i = 0;\n\n    for (; i <= n - 3; i += 2) {\n        float64x2_t v0 = vld1q_f64(&numbers[i]);\n        float64x2_t v1 = vld1q_f64(&numbers[i+1]);\n        float64x2_t diff = vabdq_f64(v0, v1);\n        uint64x2_t mask = vcltq_f64(diff, thresh_vec);\n\n        if (vgetq_lane_u64(mask, 0) || vgetq_lane_u64(mask, 1)) {\n            return true;\n        }\n    }\n\n    for (; i < n - 1; ++i) {\n        if (std::fabs(numbers[i] - numbers[i+1]) < threshold) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) \n        return false;\n\n    const int32_t* ptr = operations.data();\n    int accum = 0;\n    int i = 0;\n\n    for (; i <= n-4; i += 4) {\n        int32x4_t v = vld1q_s32(ptr + i);\n        int32x4_t shifted1 = vextq_s32(vdupq_n_s32(0), v, 3);\n        int32x4_t temp1 = vaddq_s32(v, shifted1);\n        int32x4_t shifted2 = vextq_s32(vdupq_n_s32(0), temp1, 2);\n        int32x4_t prefix_in_chunk = vaddq_s32(temp1, shifted2);\n        int32x4_t total_prefix = vaddq_s32(prefix_in_chunk, vdupq_n_s32(accum));\n        \n        uint32x4_t mask = vcltq_s32(total_prefix, vdupq_n_s32(0));\n        if (vgetq_lane_u32(mask, 0) || vgetq_lane_u32(mask, 1) || \n            vgetq_lane_u32(mask, 2) || vgetq_lane_u32(mask, 3)) {\n            return true;\n        }\n        \n        accum = vgetq_lane_s32(total_prefix, 3);\n    }\n\n    for (; i < n; i++) {\n        accum += operations[i];\n        if (accum < 0) \n            return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n\n    int32_t acc = 0;\n    int i = 0;\n    int32x4_t v_zero = vdupq_n_s32(0);\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v0 = vld1q_s32(&operations[i]);\n        int32x4_t v_shift1 = vextq_s32(v_zero, v0, 3);\n        int32x4_t v1 = vaddq_s32(v0, v_shift1);\n        int32x4_t v_shift2 = vextq_s32(v_zero, v1, 2);\n        int32x4_t v2 = vaddq_s32(v1, v_shift2);\n        int32x4_t vacc = vdupq_n_s32(acc);\n        int32x4_t v_result = vaddq_s32(vacc, v2);\n\n        uint32x4_t v_neg_mask = vcltq_s32(v_result, v_zero);\n        uint32_t m0 = vgetq_lane_u32(v_neg_mask, 0);\n        uint32_t m1 = vgetq_lane_u32(v_neg_mask, 1);\n        uint32_t m2 = vgetq_lane_u32(v_neg_mask, 2);\n        uint32_t m3 = vgetq_lane_u32(v_neg_mask, 3);\n        if (m0 | m1 | m2 | m3) {\n            return true;\n        }\n\n        acc = vgetq_lane_s32(v_result, 3);\n    }\n\n    for (; i < n; ++i) {\n        acc += operations[i];\n        if (acc < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32_t balance = 0;\n    size_t i = 0;\n    size_t size = operations.size();\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t chunk = vld1q_s32(&operations[i]);\n        int32x4_t step1 = vaddq_s32(chunk, vextq_s32(vdupq_n_s32(0), chunk, 3));\n        int32x4_t prefix = vaddq_s32(step1, vextq_s32(vdupq_n_s32(0), step1, 2));\n        int32x4_t result = vaddq_s32(vdupq_n_s32(balance), prefix);\n        if (vminvq_s32(result) < 0) {\n            return true;\n        }\n        balance = vgetq_lane_s32(result, 3);\n    }\n    for (; i < size; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool below_zero_simd(std::vector<int> operations) {\n    if (operations.empty()) \n        return false;\n\n    int n = operations.size();\n    const int* data = operations.data();\n    int accum = 0;\n    int i = 0;\n    int32x4_t zero = vdupq_n_s32(0);\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t v0 = vld1q_s32(data + i);\n        int32x4_t v1 = vaddq_s32(v0, vextq_s32(zero, v0, 3));\n        int32x4_t v1_shift2 = vextq_s32(zero, v1, 2);\n        int32x4_t prefix = vaddq_s32(v1, v1_shift2);\n        int32x4_t chunk_sums = vaddq_s32(prefix, vdupq_n_s32(accum));\n        accum = vgetq_lane_s32(chunk_sums, 3);\n        uint32x4_t cmp = vcltq_s32(chunk_sums, zero);\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            return true;\n        }\n    }\n\n    for (; i < n; i++) {\n        accum += operations[i];\n        if (accum < 0) \n            return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) {\n        return false;\n    }\n\n    int balance = 0;\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(&operations[i]);\n        \n        int32x4_t shifted1 = vextq_s32(vdupq_n_s32(0), chunk, 3);\n        int32x4_t s1 = vaddq_s32(chunk, shifted1);\n        \n        int32x4_t shifted2 = vextq_s32(vdupq_n_s32(0), s1, 2);\n        int32x4_t cum = vaddq_s32(s1, shifted2);\n        \n        int32x2_t low = vget_low_s32(cum);\n        int32x2_t high = vget_high_s32(cum);\n        int32x2_t min2 = vpmin_s32(low, high);\n        min2 = vpmin_s32(min2, min2);\n        int32_t min_cum = vget_lane_s32(min2, 0);\n\n        if (balance + min_cum < 0) {\n            return true;\n        }\n\n        balance += vgetq_lane_s32(cum, 3);\n    }\n\n    for (; i < n; i++) {\n        balance += operations[i];\n        if (balance < 0) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```c\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t num_elements = numbers.size();\n    if (num_elements == 0) {\n        return 0.0;\n    }\n    double sum = 0.0;\n    const size_t limit = num_elements & ~static_cast<size_t>(1);\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    for (size_t i = 0; i < limit; i += 2) {\n        float64x2_t v = vld1q_f64(&numbers[i]);\n        sum_vec = vaddq_f64(sum_vec, v);\n    }\n    sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n    if (num_elements % 2 != 0) {\n        sum += numbers[limit];\n    }\n    double mean = sum / num_elements;\n    double abs_sum = 0.0;\n    float64x2_t abs_sum_vec = vdupq_n_f64(0.0);\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    for (size_t i = 0; i < limit; i += 2) {\n        float64x2_t v = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(v, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_sum_vec = vaddq_f64(abs_sum_vec, abs_diff);\n    }\n    abs_sum = vgetq_lane_f64(abs_sum_vec, 0) + vgetq_lane_f64(abs_sum_vec, 1);\n    if (num_elements % 2 != 0) {\n        double diff = numbers[limit] - mean;\n        abs_sum += (diff < 0) ? -diff : diff;\n    }\n    return abs_sum / num_elements;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <vector>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double sum = 0.0;\n    float64x2_t vsum = vdupq_n_f64(0.0);\n    size_t i = 0;\n\n    for (; i <= n - 2; i += 2) {\n        float64x2_t v = vld1q_f64(&numbers[i]);\n        vsum = vaddq_f64(vsum, v);\n    }\n    sum = vgetq_lane_f64(vsum, 0) + vgetq_lane_f64(vsum, 1);\n    for (; i < n; ++i) {\n        sum += numbers[i];\n    }\n    double mean = sum / n;\n\n    double abs_sum = 0.0;\n    float64x2_t vabs_sum = vdupq_n_f64(0.0);\n    float64x2_t vmean = vdupq_n_f64(mean);\n    i = 0;\n\n    for (; i <= n - 2; i += 2) {\n        float64x2_t v = vld1q_f64(&numbers[i]);\n        float64x2_t diff = vsubq_f64(v, vmean);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        vabs_sum = vaddq_f64(vabs_sum, abs_diff);\n    }\n    abs_sum = vgetq_lane_f64(vabs_sum, 0) + vgetq_lane_f64(vabs_sum, 1);\n    for (; i < n; ++i) {\n        abs_sum += std::fabs(numbers[i] - mean);\n    }\n\n    return abs_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    int n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double* data = numbers.data();\n    double sum = 0.0;\n    int i = 0;\n\n    // Vectorized sum calculation\n    float64x2_t sum_vec = vdupq_n_f64(0.0);\n    int vec_end = n & ~1;\n    for (; i < vec_end; i += 2) {\n        float64x2_t val = vld1q_f64(data + i);\n        sum_vec = vaddq_f64(sum_vec, val);\n    }\n    sum = vgetq_lane_f64(sum_vec, 0) + vgetq_lane_f64(sum_vec, 1);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        sum += data[i];\n    }\n\n    double mean = sum / n;\n    float64x2_t mean_vec = vdupq_n_f64(mean);\n    double abs_sum = 0.0;\n    i = 0;\n    \n    // Vectorized absolute difference sum\n    float64x2_t abs_sum_vec = vdupq_n_f64(0.0);\n    for (; i < vec_end; i += 2) {\n        float64x2_t val = vld1q_f64(data + i);\n        float64x2_t diff = vsubq_f64(val, mean_vec);\n        float64x2_t abs_diff = vabsq_f64(diff);\n        abs_sum_vec = vaddq_f64(abs_sum_vec, abs_diff);\n    }\n    abs_sum = vgetq_lane_f64(abs_sum_vec, 0) + vgetq_lane_f64(abs_sum_vec, 1);\n\n    // Handle remaining elements\n    for (; i < n; i++) {\n        abs_sum += std::fabs(data[i] - mean);\n    }\n\n    return abs_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double* data = numbers.data();\n    double sum = 0.0;\n    double abs_sum = 0.0;\n\n    // Vectorized sum for mean calculation\n    float64x2_t v_sum = vdupq_n_f64(0.0);\n    size_t i = 0;\n    for (; i <= n - 2; i += 2) {\n        float64x2_t v_data = vld1q_f64(data + i);\n        v_sum = vaddq_f64(v_sum, v_data);\n    }\n    sum = vgetq_lane_f64(v_sum, 0) + vgetq_lane_f64(v_sum, 1);\n\n    // Handle remainder elements for mean\n    for (; i < n; i++) {\n        sum += data[i];\n    }\n    double mean = sum / n;\n    float64x2_t v_mean = vdupq_n_f64(mean);\n\n    // Vectorized absolute deviation sum\n    float64x2_t v_abs_sum = vdupq_n_f64(0.0);\n    i = 0;\n    for (; i <= n - 2; i += 2) {\n        float64x2_t v_data = vld1q_f64(data + i);\n        float64x2_t v_diff = vsubq_f64(v_data, v_mean);\n        v_abs_sum = vaddq_f64(v_abs_sum, vabsq_f64(v_diff));\n    }\n    abs_sum = vgetq_lane_f64(v_abs_sum, 0) + vgetq_lane_f64(v_abs_sum, 1);\n\n    // Handle remainder elements for absolute deviations\n    for (; i < n; i++) {\n        abs_sum += std::fabs(data[i] - mean);\n    }\n\n    return abs_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t size = numbers.size();\n    if (size == 0) return 0.0;\n\n    double* data = numbers.data();\n    double sum = 0.0;\n    float64x2_t v_sum = vdupq_n_f64(0.0);\n\n    size_t i = 0;\n    for (; i + 1 < size; i += 2) {\n        float64x2_t v_data = vld1q_f64(data + i);\n        v_sum = vaddq_f64(v_sum, v_data);\n    }\n    sum = vgetq_lane_f64(v_sum, 0) + vgetq_lane_f64(v_sum, 1);\n\n    for (; i < size; ++i) {\n        sum += data[i];\n    }\n\n    double mean = sum / size;\n    float64x2_t v_mean = vdupq_n_f64(mean);\n    float64x2_t v_abs_sum = vdupq_n_f64(0.0);\n    double abs_sum = 0.0;\n\n    i = 0;\n    for (; i + 1 < size; i += 2) {\n        float64x2_t v_data = vld1q_f64(data + i);\n        float64x2_t v_diff = vsubq_f64(v_data, v_mean);\n        v_abs_sum = vaddq_f64(v_abs_sum, vabsq_f64(v_diff));\n    }\n    abs_sum = vgetq_lane_f64(v_abs_sum, 0) + vgetq_lane_f64(v_abs_sum, 1);\n\n    for (; i < size; ++i) {\n        abs_sum += std::fabs(data[i] - mean);\n    }\n\n    return abs_sum / size;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n#include <algorithm>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> result(2 * n - 1);\n    result[0] = numbers[0];\n    if (n == 1) {\n        return result;\n    }\n\n    size_t rest_count = n - 1;\n    int* rest_numbers = numbers.data() + 1;\n    int* output_ptr = result.data() + 1;\n\n    for (size_t i = 0; i < rest_count; i += 4) {\n        size_t chunk_size = std::min(rest_count - i, (size_t)4);\n        int32x4_t num_vec;\n        if (chunk_size == 4) {\n            num_vec = vld1q_s32(rest_numbers + i);\n        } else {\n            int32_t tmp[4] = {0};\n            for (size_t j = 0; j < chunk_size; j++) {\n                tmp[j] = rest_numbers[i + j];\n            }\n            num_vec = vld1q_s32(tmp);\n        }\n\n        int32x4_t delim_vec = vdupq_n_s32(delimeter);\n        int32x4x2_t interleaved = vzipq_s32(delim_vec, num_vec);\n\n        if (chunk_size == 4) {\n            vst1q_s32(output_ptr, interleaved.val[0]);\n            vst1q_s32(output_ptr + 4, interleaved.val[1]);\n            output_ptr += 8;\n        } else {\n            switch (chunk_size) {\n                case 1:\n                    vst1_s32(output_ptr, vget_low_s32(interleaved.val[0]));\n                    output_ptr += 2;\n                    break;\n                case 2:\n                    vst1q_s32(output_ptr, interleaved.val[0]);\n                    output_ptr += 4;\n                    break;\n                case 3:\n                    vst1q_s32(output_ptr, interleaved.val[0]);\n                    vst1_s32(output_ptr + 4, vget_low_s32(interleaved.val[1]));\n                    output_ptr += 6;\n                    break;\n            }\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> result(2 * n - 1);\n    result[0] = numbers[0];\n    if (n == 1) {\n        return result;\n    }\n\n    size_t even_len = n - 1;\n    size_t odd_len = n - 1;\n    int* even_dest = result.data() + 2;\n    int* odd_dest = result.data() + 1;\n\n    size_t i = 0;\n    for (; i + 4 <= even_len; i += 4) {\n        int32x4_t a = vld1q_s32(&numbers[1 + i]);\n        vst1q_lane_s32(even_dest, a, 0);\n        even_dest += 2;\n        vst1q_lane_s32(even_dest, a, 1);\n        even_dest += 2;\n        vst1q_lane_s32(even_dest, a, 2);\n        even_dest += 2;\n        vst1q_lane_s32(even_dest, a, 3);\n        even_dest += 2;\n    }\n    for (; i < even_len; i++) {\n        *even_dest = numbers[1 + i];\n        even_dest += 2;\n    }\n\n    i = 0;\n    int32x4_t vdelim = vdupq_n_s32(delimeter);\n    for (; i + 4 <= odd_len; i += 4) {\n        vst1q_lane_s32(odd_dest, vdelim, 0);\n        odd_dest += 2;\n        vst1q_lane_s32(odd_dest, vdelim, 1);\n        odd_dest += 2;\n        vst1q_lane_s32(odd_dest, vdelim, 2);\n        odd_dest += 2;\n        vst1q_lane_s32(odd_dest, vdelim, 3);\n        odd_dest += 2;\n    }\n    for (; i < odd_len; i++) {\n        *odd_dest = delimeter;\n        odd_dest += 2;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return std::vector<int>();\n    }\n    std::vector<int> output(2 * n);\n    int* src = numbers.data();\n    int* dst = output.data();\n\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v_in = vld1q_s32(src + i);\n        int32x4_t v_del = vdupq_n_s32(delimeter);\n        int32x4x2_t interleaved = vzipq_s32(v_in, v_del);\n        vst1q_s32(dst + 2 * i, interleaved.val[0]);\n        vst1q_s32(dst + 2 * i + 4, interleaved.val[1]);\n    }\n\n    for (; i < n; i++) {\n        dst[2 * i] = src[i];\n        dst[2 * i + 1] = delimeter;\n    }\n\n    output.resize(2 * n - 1);\n    return output;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return std::vector<int>();\n    }\n    std::vector<int> result(2 * n - 1);\n    result[0] = numbers[0];\n    if (n == 1) {\n        return result;\n    }\n    size_t m = n - 1;\n    size_t i = 0;\n    for (; i + 4 <= m; i += 4) {\n        int32x4_t a = vld1q_s32(&numbers[1 + i]);\n        int32x4_t b = vdupq_n_s32(delimeter);\n        int32x4x2_t z = vzipq_s32(b, a);\n        vst1q_s32(&result[1 + 2 * i], z.val[0]);\n        vst1q_s32(&result[1 + 2 * i + 4], z.val[1]);\n    }\n    for (; i < m; i++) {\n        result[1 + 2 * i] = delimeter;\n        result[1 + 2 * i + 1] = numbers[1 + i];\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> result(2 * n - 1);\n    \n    size_t m = n - 1;\n    if (m == 0) {\n        result[0] = numbers[0];\n        return result;\n    }\n    \n    int* in_ptr = numbers.data();\n    int* out_ptr = result.data();\n    \n    size_t chunks = m / 4;\n    size_t remainder = m % 4;\n    \n    for (size_t c = 0; c < chunks; ++c) {\n        int32x4_t a = vld1q_s32(in_ptr);\n        int32x4_t d = vdupq_n_s32(delimeter);\n        \n        int32x4x2_t zipped = vzipq_s32(a, d);\n        vst1q_s32(out_ptr, zipped.val[0]);\n        vst1q_s32(out_ptr + 4, zipped.val[1]);\n        \n        in_ptr += 4;\n        out_ptr += 8;\n    }\n    \n    for (size_t r = 0; r < remainder; ++r) {\n        *out_ptr++ = *in_ptr++;\n        *out_ptr++ = delimeter;\n    }\n    \n    result[2 * n - 2] = numbers[n - 1];\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    if (numbers.empty()) {\n        return {0, 1};\n    }\n\n    int64x2_t sum_acc = vdupq_n_s64(0);\n    int64x2_t prod_acc = vdupq_n_s64(1);\n\n    size_t i = 0;\n    const size_t size = numbers.size();\n    for (; i + 7 < size; i += 8) {\n        int16x8_t v = vld1q_s16(&numbers[i]);\n\n        int16x8x2_t deinter = vuzpq_s16(v, v);\n        int16x4_t even = vget_low_s16(deinter.val[0]);\n        int16x4_t odd = vget_low_s16(deinter.val[1]);\n\n        int32x4_t even_s32 = vmovl_s16(even);\n        int64x2_t even0 = vmovl_s32(vget_low_s32(even_s32));\n        int64x2_t even1 = vmovl_s32(vget_high_s32(even_s32));\n        even0 = vmulq_s64(even0, even1);\n        int64x2_t even_swap = vcombine_s64(vget_high_s64(even0), vget_low_s64(even0));\n        even0 = vmulq_s64(even0, even_swap);\n        int64_t p_even = vgetq_lane_s64(even0, 0);\n\n        int32x4_t odd_s32 = vmovl_s16(odd);\n        int64x2_t odd0 = vmovl_s32(vget_low_s32(odd_s32));\n        int64x2_t odd1 = vmovl_s32(vget_high_s32(odd_s32));\n        odd0 = vmulq_s64(odd0, odd1);\n        int64x2_t odd_swap = vcombine_s64(vget_high_s64(odd0), vget_low_s64(odd0));\n        odd0 = vmulq_s64(odd0, odd_swap);\n        int64_t p_odd = vgetq_lane_s64(odd0, 0);\n\n        int64_t acc_even = vgetq_lane_s64(prod_acc, 0);\n        int64_t acc_odd = vgetq_lane_s64(prod_acc, 1);\n        acc_even *= p_even;\n        acc_odd *= p_odd;\n        prod_acc = vsetq_lane_s64(acc_even, prod_acc, 0);\n        prod_acc = vsetq_lane_s64(acc_odd, prod_acc, 1);\n\n        int32x4_t low = vmovl_s16(vget_low_s16(v));\n        int32x4_t high = vmovl_s16(vget_high_s16(v));\n        int32x4_t sum32 = vaddq_s32(low, high);\n        int64x2_t sum_low = vmovl_s32(vget_low_s32(sum32));\n        int64x2_t sum_high = vmovl_s32(vget_high_s32(sum32));\n        int64x2_t sum_chunk = vaddq_s64(sum_low, sum_high);\n        sum_acc = vaddq_s64(sum_acc, sum_chunk);\n    }\n\n    int64_t sum_tail = 0;\n    int64_t prod_even_tail = 1;\n    int64_t prod_odd_tail = 1;\n    int even_odd_flag = 0;\n    for (; i < size; ++i) {\n        sum_tail += numbers[i];\n        if (even_odd_flag) {\n            prod_odd_tail *= numbers[i];\n        } else {\n            prod_even_tail *= numbers[i];\n        }\n        even_odd_flag = !even_odd_flag;\n    }\n\n    int64_t sum_total = vgetq_lane_s64(sum_acc, 0) + vgetq_lane_s64(sum_acc, 1) + sum_tail;\n    int64_t prod_even = vgetq_lane_s64(prod_acc, 0) * prod_even_tail;\n    int64_t prod_odd = vgetq_lane_s64(prod_acc, 1) * prod_odd_tail;\n    int64_t prod_total = prod_even * prod_odd;\n\n    return {sum_total, prod_total};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64x2_t sum_acc = vdupq_n_s64(0);\n    int64x2_t prod_acc0 = vdupq_n_s64(1);\n    int64x2_t prod_acc1 = vdupq_n_s64(1);\n\n    int i = 0;\n    for (; i + 3 < n; i += 4) {\n        int16x4_t chunk = vld1_s16(&numbers[i]);\n        int32x4_t chunk32 = vmovl_s16(chunk);\n        int32x2_t low32 = vget_low_s32(chunk32);\n        int32x2_t high32 = vget_high_s32(chunk32);\n        int64x2_t low64 = vmovl_s32(low32);\n        int64x2_t high64 = vmovl_s32(high32);\n\n        sum_acc = vaddq_s64(sum_acc, low64);\n        sum_acc = vaddq_s64(sum_acc, high64);\n        prod_acc0 = vmulq_s64(prod_acc0, low64);\n        prod_acc1 = vmulq_s64(prod_acc1, high64);\n    }\n\n    int64_t total_sum = vgetq_lane_s64(sum_acc, 0) + vgetq_lane_s64(sum_acc, 1);\n    int64_t total_prod = vgetq_lane_s64(prod_acc0, 0) * \n                         vgetq_lane_s64(prod_acc0, 1) * \n                         vgetq_lane_s64(prod_acc1, 0) * \n                         vgetq_lane_s64(prod_acc1, 1);\n\n    for (; i < n; ++i) {\n        total_sum += numbers[i];\n        total_prod *= numbers[i];\n    }\n\n    return {total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64x2_t sum_vec = vdupq_n_s64(0);\n    int64_t prod_acc0 = 1;\n    int64_t prod_acc1 = 1;\n    int i = 0;\n\n    for (; i <= n - 8; i += 8) {\n        int16x8_t v8 = vld1q_s16(&numbers[i]);\n\n        int32x4_t v32_low = vmovl_s16(vget_low_s16(v8));\n        int32x4_t v32_high = vmovl_s16(vget_high_s16(v8));\n\n        int64x2_t v64_ll = vmovl_s32(vget_low_s32(v32_low));\n        int64x2_t v64_lh = vmovl_s32(vget_high_s32(v32_low));\n        int64x2_t v64_hl = vmovl_s32(vget_low_s32(v32_high));\n        int64x2_t v64_hh = vmovl_s32(vget_high_s32(v32_high));\n\n        sum_vec = vaddq_s64(sum_vec, v64_ll);\n        sum_vec = vaddq_s64(sum_vec, v64_lh);\n        sum_vec = vaddq_s64(sum_vec, v64_hl);\n        sum_vec = vaddq_s64(sum_vec, v64_hh);\n\n        int16x4_t low4 = vget_low_s16(v8);\n        int16_t a0 = vget_lane_s16(low4, 0);\n        int16_t a1 = vget_lane_s16(low4, 1);\n        int16_t a2 = vget_lane_s16(low4, 2);\n        int16_t a3 = vget_lane_s16(low4, 3);\n        int64_t temp0 = static_cast<int64_t>(a0) * a1;\n        temp0 = temp0 * a2;\n        temp0 = temp0 * a3;\n        prod_acc0 *= temp0;\n\n        int16x4_t high4 = vget_high_s16(v8);\n        int16_t a4 = vget_lane_s16(high4, 0);\n        int16_t a5 = vget_lane_s16(high4, 1);\n        int16_t a6 = vget_lane_s16(high4, 2);\n        int16_t a7 = vget_lane_s16(high4, 3);\n        int64_t temp1 = static_cast<int64_t>(a4) * a5;\n        temp1 = temp1 * a6;\n        temp1 = temp1 * a7;\n        prod_acc1 *= temp1;\n    }\n\n    int64_t total_sum = vgetq_lane_s64(sum_vec, 0) + vgetq_lane_s64(sum_vec, 1);\n    int64_t total_product = prod_acc0 * prod_acc1;\n\n    int64_t rem_sum = 0;\n    int64_t rem_prod = 1;\n    for (; i < n; i++) {\n        rem_sum += numbers[i];\n        rem_prod *= numbers[i];\n    }\n\n    total_sum += rem_sum;\n    total_product *= rem_prod;\n\n    return {total_sum, total_product};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int64x2_t sum64 = vdupq_n_s64(0);\n    int64x2_t prod0 = vdupq_n_s64(1);\n    int64x2_t prod1 = vdupq_n_s64(1);\n    int64x2_t prod2 = vdupq_n_s64(1);\n    int64x2_t prod3 = vdupq_n_s64(1);\n\n    size_t i = 0;\n    while (i < n) {\n        if (i + 8 <= n) {\n            int16x8_t v = vld1q_s16(&numbers[i]);\n            int16x4_t low16 = vget_low_s16(v);\n            int16x4_t high16 = vget_high_s16(v);\n            int32x4_t low32 = vmovl_s16(low16);\n            int32x4_t high32 = vmovl_s16(high16);\n            int32x2_t low32_low = vget_low_s32(low32);\n            int32x2_t low32_high = vget_high_s32(low32);\n            int32x2_t high32_low = vget_low_s32(high32);\n            int32x2_t high32_high = vget_high_s32(high32);\n            int64x2_t low64_ll = vmovl_s32(low32_low);\n            int64x2_t low64_lh = vmovl_s32(low32_high);\n            int64x2_t high64_hl = vmovl_s32(high32_low);\n            int64x2_t high64_hh = vmovl_s32(high32_high);\n\n            sum64 = vaddq_s64(sum64, low64_ll);\n            sum64 = vaddq_s64(sum64, low64_lh);\n            sum64 = vaddq_s64(sum64, high64_hl);\n            sum64 = vaddq_s64(sum64, high64_hh);\n\n            prod0 = vmulq_s64(prod0, low64_ll);\n            prod1 = vmulq_s64(prod1, low64_lh);\n            prod2 = vmulq_s64(prod2, high64_hl);\n            prod3 = vmulq_s64(prod3, high64_hh);\n\n            i += 8;\n        } else if (i + 4 <= n) {\n            int16x4_t v4 = vld1_s16(&numbers[i]);\n            int32x4_t v32 = vmovl_s16(v4);\n            int32x2_t v32_low = vget_low_s32(v32);\n            int32x2_t v32_high = vget_high_s32(v32);\n            int64x2_t v64_low = vmovl_s32(v32_low);\n            int64x2_t v64_high = vmovl_s32(v32_high);\n\n            sum64 = vaddq_s64(sum64, v64_low);\n            sum64 = vaddq_s64(sum64, v64_high);\n\n            prod0 = vmulq_s64(prod0, v64_low);\n            prod1 = vmulq_s64(prod1, v64_high);\n\n            i += 4;\n        } else {\n            break;\n        }\n    }\n\n    int64_t scalar_sum = 0;\n    int64_t scalar_prod = 1;\n    for (; i < n; i++) {\n        scalar_sum += numbers[i];\n        scalar_prod *= numbers[i];\n    }\n\n    int64_t s0 = vgetq_lane_s64(sum64, 0);\n    int64_t s1 = vgetq_lane_s64(sum64, 1);\n    int64_t total_sum = s0 + s1 + scalar_sum;\n\n    int64_t total_prod = scalar_prod;\n    total_prod *= vgetq_lane_s64(prod0, 0);\n    total_prod *= vgetq_lane_s64(prod0, 1);\n    total_prod *= vgetq_lane_s64(prod1, 0);\n    total_prod *= vgetq_lane_s64(prod1, 1);\n    total_prod *= vgetq_lane_s64(prod2, 0);\n    total_prod *= vgetq_lane_s64(prod2, 1);\n    total_prod *= vgetq_lane_s64(prod3, 0);\n    total_prod *= vgetq_lane_s64(prod3, 1);\n\n    return {total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_66_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers){\n    size_t n = numbers.size();\n    if (n == 0) {\n        return std::vector<int64_t>{0, 1};\n    }\n\n    int64_t total_sum = 0;\n    int64_t total_product = 1;\n    size_t i = 0;\n\n    if (n >= 4) {\n        int64x2_t sum64 = vdupq_n_s64(0);\n\n        for (; i <= n - 4; i += 4) {\n            int16x4_t v = vld1_s16(&numbers[i]);\n            int32x4_t v32 = vmovl_s16(v);\n            \n            int64x2_t low_part = vmovl_s32(vget_low_s32(v32));\n            int64x2_t high_part = vmovl_s32(vget_high_s32(v32));\n            sum64 = vaddq_s64(sum64, low_part);\n            sum64 = vaddq_s64(sum64, high_part);\n\n            int32x2_t low32 = vget_low_s32(v32);\n            int32x2_t high32 = vget_high_s32(v32);\n            int32x2_t low_prod = vmul_s32(low32, vrev64_s32(low32));\n            int32x2_t high_prod = vmul_s32(high32, vrev64_s32(high32));\n            int32_t prod_low = vget_lane_s32(low_prod, 0);\n            int32_t prod_high = vget_lane_s32(high_prod, 0);\n            total_product *= static_cast<int64_t>(prod_low) * static_cast<int64_t>(prod_high);\n        }\n\n        total_sum = vgetq_lane_s64(sum64, 0) + vgetq_lane_s64(sum64, 1);\n    }\n\n    for (; i < n; i++) {\n        total_sum += numbers[i];\n        total_product *= numbers[i];\n    }\n\n    return std::vector<int64_t>{total_sum, total_product};\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    int current_max = std::numeric_limits<int>::min();\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t v0 = vld1q_s32(&numbers[i]);\n        int32x4_t v_prev = vdupq_n_s32(current_max);\n        \n        int32x4_t v_shift1 = vextq_s32(v_prev, v0, 3);\n        int32x4_t v1 = vmaxq_s32(v0, v_shift1);\n        \n        int32x4_t v_shift2 = vextq_s32(v_prev, v1, 2);\n        int32x4_t v2 = vmaxq_s32(v1, v_shift2);\n        \n        int32x4_t v3 = vmaxq_s32(v2, v_prev);\n        vst1q_s32(&result[i], v3);\n        \n        current_max = vgetq_lane_s32(v3, 3);\n    }\n\n    for (; i < n; i++) {\n        if (numbers[i] > current_max) {\n            current_max = numbers[i];\n        }\n        result[i] = current_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> output(n);\n    if (n == 0) {\n        return output;\n    }\n    \n    int carry = INT_MIN;\n    int i = 0;\n    \n    for (; i + 4 <= n; i += 4) {\n        int32x4_t v = vld1q_s32(&numbers[i]);\n        int32x4_t carry_vec = vdupq_n_s32(carry);\n        int32x4_t v_min = vdupq_n_s32(INT_MIN);\n        \n        int32x4_t shifted1 = vextq_s32(v_min, v, 3);\n        int32x4_t r1 = vmaxq_s32(v, shifted1);\n        \n        int32x4_t shifted2 = vextq_s32(v_min, r1, 2);\n        int32x4_t r2 = vmaxq_s32(r1, shifted2);\n        \n        int32x4_t res_vec = vmaxq_s32(r2, carry_vec);\n        vst1q_s32(&output[i], res_vec);\n        \n        carry = vgetq_lane_s32(res_vec, 3);\n    }\n    \n    for (; i < n; ++i) {\n        carry = std::max(carry, numbers[i]);\n        output[i] = carry;\n    }\n    \n    return output;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <limits>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    const int n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    int32_t prev_max = std::numeric_limits<int32_t>::min();\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v_cur = vld1q_s32(&numbers[i]);\n        \n        int32_t a0 = vgetq_lane_s32(v_cur, 0);\n        int32_t a1 = vgetq_lane_s32(v_cur, 1);\n        int32_t a2 = vgetq_lane_s32(v_cur, 2);\n        int32_t a3 = vgetq_lane_s32(v_cur, 3);\n        \n        int32_t out0 = (a0 > prev_max) ? a0 : prev_max;\n        int32_t out1 = (a1 > out0) ? a1 : out0;\n        int32_t out2 = (a2 > out1) ? a2 : out1;\n        int32_t out3 = (a3 > out2) ? a3 : out2;\n        \n        result[i] = out0;\n        result[i+1] = out1;\n        result[i+2] = out2;\n        result[i+3] = out3;\n        \n        prev_max = out3;\n    }\n\n    for (; i < n; ++i) {\n        if (numbers[i] > prev_max) {\n            prev_max = numbers[i];\n        }\n        result[i] = prev_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    size_t n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    int carry_in = numbers[0];\n    result[0] = carry_in;\n\n    size_t i = 1;\n    int* in_ptr = numbers.data();\n    int* out_ptr = result.data();\n\n    while (i <= n - 4) {\n        int32x4_t chunk = vld1q_s32(in_ptr + i);\n\n        int first = carry_in > in_ptr[i] ? carry_in : in_ptr[i];\n        int second = first > in_ptr[i+1] ? first : in_ptr[i+1];\n        int third = second > in_ptr[i+2] ? second : in_ptr[i+2];\n        int fourth = third > in_ptr[i+3] ? third : in_ptr[i+3];\n\n        int32x4_t rolling;\n        rolling = vsetq_lane_s32(first, rolling, 0);\n        rolling = vsetq_lane_s32(second, rolling, 1);\n        rolling = vsetq_lane_s32(third, rolling, 2);\n        rolling = vsetq_lane_s32(fourth, rolling, 3);\n\n        vst1q_s32(out_ptr + i, rolling);\n        carry_in = fourth;\n        i += 4;\n    }\n\n    while (i < n) {\n        carry_in = carry_in > in_ptr[i] ? carry_in : in_ptr[i];\n        out_ptr[i] = carry_in;\n        i++;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    int M = -2147483647 - 1;\n    int i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&numbers[i]);\n        int32x4_t shifted1 = vextq_s32(vdupq_n_s32(-2147483647 - 1), chunk, 3);\n        int32x4_t max1 = vmaxq_s32(chunk, shifted1);\n        int32x4_t shifted2 = vextq_s32(vdupq_n_s32(-2147483647 - 1), max1, 2);\n        int32x4_t max2 = vmaxq_s32(max1, shifted2);\n        int32x4_t res_vec = vmaxq_s32(vdupq_n_s32(M), max2);\n        vst1q_s32(&result[i], res_vec);\n        M = vgetq_lane_s32(res_vec, 3);\n    }\n\n    for (; i < n; i++) {\n        M = std::max(M, numbers[i]);\n        result[i] = M;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    if (a.size() != b.size()) {\n        return \"\";\n    }\n    size_t n = a.size();\n    std::string res(n, '\\0');\n    const uint8_t* a_data = reinterpret_cast<const uint8_t*>(a.data());\n    const uint8_t* b_data = reinterpret_cast<const uint8_t*>(b.data());\n    uint8_t* res_data = reinterpret_cast<uint8_t*>(&res[0]);\n\n    size_t i = 0;\n    const uint8x16_t zero_vec = vdupq_n_u8('0');\n    const uint8x16_t one_vec = vdupq_n_u8('1');\n    size_t end = n - (n % 16);\n\n    for (; i < end; i += 16) {\n        uint8x16_t va = vld1q_u8(a_data + i);\n        uint8x16_t vb = vld1q_u8(b_data + i);\n        uint8x16_t cmp = vceqq_u8(va, vb);\n        uint8x16_t vr = vbslq_u8(cmp, zero_vec, one_vec);\n        vst1q_u8(res_data + i, vr);\n    }\n\n    for (; i < n; ++i) {\n        res[i] = (a[i] == b[i]) ? '0' : '1';\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    if (n != b.size()) {\n        return \"\";\n    }\n\n    std::string result(n, '\\0');\n    size_t i = 0;\n    const uint8_t* a_data = reinterpret_cast<const uint8_t*>(a.data());\n    const uint8_t* b_data = reinterpret_cast<const uint8_t*>(b.data());\n    uint8_t* res_data = reinterpret_cast<uint8_t*>(&result[0]);\n    uint8x16_t zero_char = vdupq_n_u8('0');\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t a_vec = vld1q_u8(a_data + i);\n        uint8x16_t b_vec = vld1q_u8(b_data + i);\n        uint8x16_t xor_vec = veorq_u8(a_vec, b_vec);\n        uint8x16_t res_vec = vaddq_u8(xor_vec, zero_char);\n        vst1q_u8(res_data + i, res_vec);\n    }\n\n    for (; i < n; ++i) {\n        res_data[i] = (a_data[i] ^ b_data[i]) + '0';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    if (b.size() < n) {\n        n = b.size();\n    }\n    std::string res(n, '0');\n    if (n == 0) {\n        return res;\n    }\n    size_t i = 0;\n    uint8x16_t zero_char = vdupq_n_u8('0');\n    while (i + 16 <= n) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t va_num = vsubq_u8(va, zero_char);\n        uint8x16_t vb_num = vsubq_u8(vb, zero_char);\n        uint8x16_t vres_num = veorq_u8(va_num, vb_num);\n        uint8x16_t vres = vaddq_u8(vres_num, zero_char);\n        vst1q_u8(reinterpret_cast<uint8_t*>(res.data() + i), vres);\n        i += 16;\n    }\n    while (i < n) {\n        res[i] = ((a[i] - '0') ^ (b[i] - '0')) + '0';\n        i++;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    if (a.size() != b.size()) {\n        return std::string();\n    }\n    \n    std::string res(a.size(), '0');\n    size_t i = 0;\n    const size_t simd_size = 16;\n    const size_t n = a.size();\n    \n    for (; i + simd_size <= n; i += simd_size) {\n        uint8x16_t va = vld1q_u8(reinterpret_cast<const uint8_t*>(a.data() + i));\n        uint8x16_t vb = vld1q_u8(reinterpret_cast<const uint8_t*>(b.data() + i));\n        uint8x16_t vxor = veorq_u8(va, vb);\n        uint8x16_t vres = vorrq_u8(vxor, vdupq_n_u8('0'));\n        vst1q_u8(reinterpret_cast<uint8_t*>(res.data() + i), vres);\n    }\n    \n    for (; i < n; ++i) {\n        res[i] = (a[i] ^ b[i]) | '0';\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_68_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    if (a.length() != b.length()) {\n        return \"\";\n    }\n\n    size_t n = a.length();\n    std::string res(n, '\\0');\n    const uint8_t* a_ptr = reinterpret_cast<const uint8_t*>(a.data());\n    const uint8_t* b_ptr = reinterpret_cast<const uint8_t*>(b.data());\n    uint8_t* res_ptr = reinterpret_cast<uint8_t*>(&res[0]);\n    size_t i = 0;\n\n    for (; i + 15 < n; i += 16) {\n        uint8x16_t va = vld1q_u8(a_ptr + i);\n        uint8x16_t vb = vld1q_u8(b_ptr + i);\n        uint8x16_t vxor = veorq_u8(va, vb);\n        uint8x16_t vres = vaddq_u8(vxor, vdupq_n_u8('0'));\n        vst1q_u8(res_ptr + i, vres);\n    }\n\n    for (; i < n; i++) {\n        res[i] = (a[i] ^ b[i]) + '0';\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::vector<uint32_t> lens;\n    lens.reserve(strings.size());\n    for (const auto& s : strings) {\n        lens.push_back(static_cast<uint32_t>(s.size()));\n    }\n    const uint32_t* lens_ptr = lens.data();\n    size_t n = lens.size();\n    size_t i = 0;\n    uint32x4_t max_v = vdupq_n_u32(0);\n    for (; i + 4 <= n; i += 4) {\n        uint32x4_t data = vld1q_u32(lens_ptr + i);\n        max_v = vmaxq_u32(max_v, data);\n    }\n    uint32_t max_val = 0;\n    max_val = std::max(max_val, vgetq_lane_u32(max_v, 0));\n    max_val = std::max(max_val, vgetq_lane_u32(max_v, 1));\n    max_val = std::max(max_val, vgetq_lane_u32(max_v, 2));\n    max_val = std::max(max_val, vgetq_lane_u32(max_v, 3));\n    for (; i < n; i++) {\n        if (lens[i] > max_val) {\n            max_val = lens[i];\n        }\n    }\n    for (size_t j = 0; j < n; j++) {\n        if (lens[j] == max_val) {\n            return strings[j];\n        }\n    }\n    return \"\";\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return std::string();\n    }\n\n    const size_t n = strings.size();\n    std::vector<uint64_t> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = static_cast<uint64_t>(strings[i].length());\n    }\n\n    uint64_t max_value = 0;\n    size_t max_index = 0;\n    size_t i = 0;\n\n    const uint64_t* data = lengths.data();\n    for (; i + 1 < n; i += 2) {\n        uint64x2_t vec = vld1q_u64(data + i);\n        uint64x2_t max_vec = vdupq_n_u64(max_value);\n        uint64x2_t cmp = vcgtq_u64(vec, max_vec);\n\n        uint64_t cmp_arr[2];\n        uint64_t vals[2];\n        vst1q_u64(cmp_arr, cmp);\n        vst1q_u64(vals, vec);\n\n        for (int j = 0; j < 2; ++j) {\n            if (cmp_arr[j]) {\n                max_value = vals[j];\n                max_index = i + j;\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (lengths[i] > max_value) {\n            max_value = lengths[i];\n            max_index = i;\n        }\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return std::string();\n    }\n    size_t n = strings.size();\n    std::vector<int32_t> lengths(n);\n    for (size_t i = 0; i < n; i++) {\n        lengths[i] = static_cast<int32_t>(strings[i].size());\n    }\n\n    int32_t max_val = -1;\n    size_t i = 0;\n    int32x4_t max_vec = vdupq_n_s32(-1);\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t data = vld1q_s32(&lengths[i]);\n        max_vec = vmaxq_s32(max_vec, data);\n    }\n\n    int32_t max_arr[4];\n    vst1q_s32(max_arr, max_vec);\n    max_val = max_arr[0];\n    for (int j = 1; j < 4; j++) {\n        if (max_arr[j] > max_val) {\n            max_val = max_arr[j];\n        }\n    }\n\n    for (; i < n; i++) {\n        if (lengths[i] > max_val) {\n            max_val = lengths[i];\n        }\n    }\n\n    size_t index;\n    bool found = false;\n    i = 0;\n    while (i < n && !found) {\n        if (i + 4 <= n) {\n            int32x4_t data = vld1q_s32(&lengths[i]);\n            uint32x4_t mask = vceqq_s32(data, vdupq_n_s32(max_val));\n            uint32x2_t low = vget_low_u32(mask);\n            uint32x2_t high = vget_high_u32(mask);\n            uint32x2_t reduced = vorr_u32(low, high);\n            uint32_t m = vget_lane_u32(reduced, 0) | vget_lane_u32(reduced, 1);\n            if (m) {\n                for (int j = 0; j < 4; j++) {\n                    if (lengths[i+j] == max_val) {\n                        index = i+j;\n                        found = true;\n                        break;\n                    }\n                }\n            }\n            if (!found) {\n                i += 4;\n            }\n        } else {\n            if (lengths[i] == max_val) {\n                index = i;\n                found = true;\n            } else {\n                i++;\n            }\n        }\n    }\n\n    return strings[index];\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string>& strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    \n    size_t n = strings.size();\n    std::vector<size_t> lens;\n    lens.reserve(n);\n    for (const auto& s : strings) {\n        lens.push_back(s.size());\n    }\n    \n    size_t global_max = 0;\n    if (n >= 2) {\n        uint64x2_t max_vec = vdupq_n_u64(0);\n        size_t i = 0;\n        size_t n_floor = n & ~static_cast<size_t>(1);\n        \n        for (; i < n_floor; i += 2) {\n            uint64x2_t data = vld1q_u64(&lens[i]);\n            max_vec = vmaxq_u64(max_vec, data);\n        }\n        \n        uint64_t tmp[2];\n        vst1q_u64(tmp, max_vec);\n        global_max = tmp[0] > tmp[1] ? tmp[0] : tmp[1];\n        \n        for (; i < n; ++i) {\n            if (lens[i] > global_max) {\n                global_max = lens[i];\n            }\n        }\n    } else {\n        global_max = lens[0];\n    }\n    \n    for (size_t i = 0; i < n; ++i) {\n        if (lens[i] == global_max) {\n            return strings[i];\n        }\n    }\n    \n    return \"\";\n}\n```"}
{"task_id": "SimdBench_69_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return std::string();\n    }\n    size_t n = strings.size();\n    uint64_t max_val = 0;\n    uint64x2_t max_vec = vdupq_n_u64(0);\n    size_t i = 0;\n\n    for (; i + 1 < n; i += 2) {\n        uint64_t len0 = strings[i].size();\n        uint64_t len1 = strings[i+1].size();\n\n        uint64x2_t vec = vdupq_n_u64(0);\n        vec = vsetq_lane_u64(len0, vec, 0);\n        vec = vsetq_lane_u64(len1, vec, 1);\n\n        max_vec = vmaxq_u64(max_vec, vec);\n    }\n\n    uint64_t lane0 = vgetq_lane_u64(max_vec, 0);\n    uint64_t lane1 = vgetq_lane_u64(max_vec, 1);\n    if (lane0 > max_val) max_val = lane0;\n    if (lane1 > max_val) max_val = lane1;\n\n    if (i < n) {\n        uint64_t len = strings[i].size();\n        if (len > max_val) {\n            max_val = len;\n        }\n    }\n\n    for (i = 0; i < n; i++) {\n        if (static_cast<uint64_t>(strings[i].size()) == max_val) {\n            return strings[i];\n        }\n    }\n\n    return std::string();\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    uint64x2_t v = {a, b};\n    const uint64x2_t one = vdupq_n_u64(1);\n    int shift = 0;\n\n    while (true) {\n        uint64x2_t lsb = vandq_u64(v, one);\n        uint64_t lsb0 = vgetq_lane_u64(lsb, 0);\n        uint64_t lsb1 = vgetq_lane_u64(lsb, 1);\n        if (lsb0 != 0 || lsb1 != 0) break;\n        v = vshrq_n_u64(v, 1);\n        shift++;\n    }\n\n    uint64x2_t lsb = vandq_u64(v, one);\n    uint64x2_t even_mask = vceqq_u64(lsb, vdupq_n_u64(0));\n    while (vgetq_lane_u64(even_mask, 0) != 0 || vgetq_lane_u64(even_mask, 1) != 0) {\n        uint64x2_t shifted = vshrq_n_u64(v, 1);\n        v = vbslq_u64(even_mask, shifted, v);\n        lsb = vandq_u64(v, one);\n        even_mask = vceqq_u64(lsb, vdupq_n_u64(0));\n    }\n\n    while (true) {\n        uint64_t a_val = vgetq_lane_u64(v, 0);\n        uint64_t b_val = vgetq_lane_u64(v, 1);\n        if (a_val == b_val) break;\n\n        if (a_val > b_val) {\n            a_val = a_val - b_val;\n            v = vsetq_lane_u64(a_val, v, 0);\n        } else {\n            b_val = b_val - a_val;\n            v = vsetq_lane_u64(b_val, v, 1);\n        }\n\n        lsb = vandq_u64(v, one);\n        even_mask = vceqq_u64(lsb, vdupq_n_u64(0));\n        while (vgetq_lane_u64(even_mask, 0) != 0 || vgetq_lane_u64(even_mask, 1) != 0) {\n            uint64x2_t shifted = vshrq_n_u64(v, 1);\n            v = vbslq_u64(even_mask, shifted, v);\n            lsb = vandq_u64(v, one);\n            even_mask = vceqq_u64(lsb, vdupq_n_u64(0));\n        }\n    }\n\n    return vgetq_lane_u64(v, 0) << shift;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t vec = (uint64x2_t){a, b};\n\n    while (vgetq_lane_u64(vec, 1) != 0) {\n        uint64x2_t swapped = vcombine_u64(vget_high_u64(vec), vget_low_u64(vec));\n        uint64x2_t min_val = vminq_u64(vec, swapped);\n        uint64x2_t max_val = vmaxq_u64(vec, swapped);\n        uint64x2_t diff = vsubq_u64(max_val, min_val);\n        uint64_t min_scalar = vgetq_lane_u64(min_val, 0);\n        vec = vsetq_lane_u64(min_scalar, diff, 1);\n    }\n\n    return vgetq_lane_u64(vec, 0);\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64x2_t v = {a, b};\n    int shift = 0;\n\n    while (1) {\n        uint64_t lsb0 = vgetq_lane_u64(v, 0) & 1;\n        uint64_t lsb1 = vgetq_lane_u64(v, 1) & 1;\n        if (lsb0 == 0 && lsb1 == 0) {\n            v = vshrq_n_u64(v, 1);\n            shift++;\n        } else {\n            break;\n        }\n    }\n\n    uint64_t a0 = vgetq_lane_u64(v, 0);\n    uint64_t b0 = vgetq_lane_u64(v, 1);\n\n    while (a0 != b0) {\n        if ((a0 & 1) == 0) {\n            a0 >>= 1;\n        } else if ((b0 & 1) == 0) {\n            b0 >>= 1;\n        } else if (a0 > b0) {\n            a0 = (a0 - b0) >> 1;\n        } else {\n            b0 = (b0 - a0) >> 1;\n        }\n    }\n\n    return a0 << shift;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    uint64x2_t v = (uint64x2_t){a, b};\n    uint64x2_t v_lowest = vandq_u64(v, vreinterpretq_u64_s64(vnegq_s64(vreinterpretq_s64_u64(v))));\n    uint64x2_t v_clz = vclzq_u64(v_lowest);\n    uint64x2_t v_tz = vsubq_u64(vdupq_n_u64(63), v_clz);\n\n    uint64_t tz0 = vgetq_lane_u64(v_tz, 0);\n    uint64_t tz1 = vgetq_lane_u64(v_tz, 1);\n    uint64_t min_tz = tz0 < tz1 ? tz0 : tz1;\n    a >>= min_tz;\n    b >>= min_tz;\n\n    v = (uint64x2_t){a, b};\n    v_lowest = vandq_u64(v, vreinterpretq_u64_s64(vnegq_s64(vreinterpretq_s64_u64(v))));\n    v_clz = vclzq_u64(v_lowest);\n    v_tz = vsubq_u64(vdupq_n_u64(63), v_clz);\n\n    uint64x2_t zero = vdupq_n_u64(0);\n    uint64x2_t mask_zero = vceqq_u64(v, zero);\n    v_tz = vbslq_u64(mask_zero, zero, v_tz);\n\n    int64x2_t shift_amt = vnegq_s64(vreinterpretq_s64_u64(v_tz));\n    v = vshlq_u64(v, vreinterpretq_s64_u64(shift_amt));\n    a = vgetq_lane_u64(v, 0);\n    b = vgetq_lane_u64(v, 1);\n\n    while (a != b && a != 0 && b != 0) {\n        v = (uint64x2_t){a, b};\n        uint64x2_t v_high = vget_high_u64(v);\n        uint64x2_t v_low = vget_low_u64(v);\n        uint64x2_t v_rev = vcombine_u64(v_high, v_low);\n\n        uint64x2_t cmp = vcgtq_u64(v, v_rev);\n        uint64x2_t diff = vsubq_u64(v, v_rev);\n        v = vbslq_u64(cmp, diff, v);\n\n        v_lowest = vandq_u64(v, vreinterpretq_u64_s64(vnegq_s64(vreinterpretq_s64_u64(v))));\n        v_clz = vclzq_u64(v_lowest);\n        v_tz = vsubq_u64(vdupq_n_u64(63), v_clz);\n\n        mask_zero = vceqq_u64(v, zero);\n        v_tz = vbslq_u64(mask_zero, zero, v_tz);\n        shift_amt = vnegq_s64(vreinterpretq_s64_u64(v_tz));\n        v = vshlq_u64(v, vreinterpretq_s64_u64(shift_amt));\n\n        a = vgetq_lane_u64(v, 0);\n        b = vgetq_lane_u64(v, 1);\n    }\n\n    if (a == 0) return b << min_tz;\n    if (b == 0) return a << min_tz;\n    return a << min_tz;\n}\n```"}
{"task_id": "SimdBench_70_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    int shift = 0;\n    uint64x2_t v = vcombine_u64(vcreate_u64(a), vcreate_u64(b));\n    uint64x2_t one = vdupq_n_u64(1);\n\n    while (1) {\n        uint64x2_t low = vandq_u64(v, one);\n        uint64_t a_even = vgetq_lane_u64(low, 0);\n        uint64_t b_even = vgetq_lane_u64(low, 1);\n        if (a_even || b_even) {\n            break;\n        }\n        v = vshrq_n_u64(v, 1);\n        shift++;\n    }\n\n    a = vgetq_lane_u64(v, 0);\n    b = vgetq_lane_u64(v, 1);\n\n    while (a != b) {\n        uint64x2_t w = vcombine_u64(vcreate_u64(a), vcreate_u64(b));\n        uint64x2_t low = vandq_u64(w, one);\n        uint64_t a_even = vgetq_lane_u64(low, 0);\n        uint64_t b_even = vgetq_lane_u64(low, 1);\n\n        if (!a_even) {\n            a >>= 1;\n        } else if (!b_even) {\n            b >>= 1;\n        } else {\n            if (a > b) {\n                a = (a - b) >> 1;\n            } else {\n                b = (b - a) >> 1;\n            }\n        }\n    }\n\n    return a << shift;\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <cfloat>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n == 2) {\n        return {std::min(numbers[0], numbers[1]), std::max(numbers[0], numbers[1])};\n    }\n    std::sort(numbers.begin(), numbers.end());\n    if (n == 2) {\n        return numbers;\n    }\n    float current_min = FLT_MAX;\n    int min_index = -1;\n    int i = 0;\n    for (; i <= n - 5; i += 4) {\n        float32x4_t a = vld1q_f32(&numbers[i]);\n        float32x4_t b = vld1q_f32(&numbers[i + 1]);\n        float32x4_t diff = vsubq_f32(b, a);\n        float candidate_min = vminvq_f32(diff);\n        if (candidate_min < current_min) {\n            current_min = candidate_min;\n            float32x4_t candidate_min_vec = vdupq_n_f32(candidate_min);\n            uint32x4_t mask = vceqq_f32(diff, candidate_min_vec);\n            uint32_t mask_arr[4];\n            vst1q_u32(mask_arr, mask);\n            for (int j = 0; j < 4; j++) {\n                if (mask_arr[j]) {\n                    min_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n    for (int j = i; j < n - 1; j++) {\n        float diff = numbers[j + 1] - numbers[j];\n        if (diff < current_min) {\n            current_min = diff;\n            min_index = j;\n        }\n    }\n    return {numbers[min_index], numbers[min_index + 1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <algorithm>\n#include <cmath>\n#include <cfloat>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n < 2) {\n        return {};\n    }\n    if (n == 2) {\n        return {numbers[0], numbers[1]};\n    }\n\n    std::sort(numbers.begin(), numbers.end());\n\n    float global_min_diff = FLT_MAX;\n    int global_min_index = 0;\n\n    int i = 0;\n    for (; i <= n - 5; i += 4) {\n        float32x4_t v0 = vld1q_f32(&numbers[i]);\n        float32x4_t v1 = vld1q_f32(&numbers[i+1]);\n        float32x4_t vdiff = vabdq_f32(v0, v1);\n\n        float block_min = vminvq_f32(vdiff);\n\n        if (block_min < global_min_diff) {\n            float32x4_t v_block_min = vdupq_n_f32(block_min);\n            uint32x4_t mask = vceqq_f32(vdiff, v_block_min);\n\n            uint32_t mask_arr[4];\n            vst1q_u32(mask_arr, mask);\n\n            for (int j = 0; j < 4; j++) {\n                if (mask_arr[j]) {\n                    global_min_index = i + j;\n                    break;\n                }\n            }\n            global_min_diff = block_min;\n        }\n    }\n\n    for (; i < n - 1; i++) {\n        float diff = std::abs(numbers[i] - numbers[i+1]);\n        if (diff < global_min_diff) {\n            global_min_diff = diff;\n            global_min_index = i;\n        }\n    }\n\n    return {numbers[global_min_index], numbers[global_min_index+1]};\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_neon.h>\n#include <cfloat>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    if (n == 2) {\n        std::sort(numbers.begin(), numbers.end());\n        return { numbers[0], numbers[1] };\n    }\n    std::sort(numbers.begin(), numbers.end());\n    int num_diffs = n - 1;\n    float min_diff = FLT_MAX;\n    int min_index = 0;\n    int i = 0;\n    for (; i <= num_diffs - 4; i += 4) {\n        float32x4_t a = vld1q_f32(&numbers[i]);\n        float32x4_t b = vld1q_f32(&numbers[i+1]);\n        float32x4_t diff = vsubq_f32(b, a);\n        float temp[4];\n        vst1q_f32(temp, diff);\n        for (int j = 0; j < 4; j++) {\n            if (temp[j] < min_diff) {\n                min_diff = temp[j];\n                min_index = i + j;\n            }\n        }\n    }\n    for (; i < num_diffs; i++) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_index = i;\n        }\n    }\n    return { numbers[min_index], numbers[min_index+1] };\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    int n = numbers.size();\n    std::vector<float> diffs(n - 1);\n    \n    int i = 0;\n    for (; i <= n - 5; i += 4) {\n        float32x4_t vec0 = vld1q_f32(&numbers[i]);\n        float32x4_t vec1 = vld1q_f32(&numbers[i + 1]);\n        float32x4_t diff = vsubq_f32(vec1, vec0);\n        vst1q_f32(&diffs[i], diff);\n    }\n    \n    for (; i < n - 1; i++) {\n        diffs[i] = numbers[i + 1] - numbers[i];\n    }\n    \n    float min_diff = diffs[0];\n    int min_index = 0;\n    for (int j = 1; j < n - 1; j++) {\n        if (diffs[j] < min_diff) {\n            min_diff = diffs[j];\n            min_index = j;\n        }\n    }\n    \n    return { numbers[min_index], numbers[min_index + 1] };\n}\n```"}
{"task_id": "SimdBench_71_Neon", "completion": "```cpp\n#include <algorithm>\n#include <cfloat>\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    int n = numbers.size();\n    float min_diff = FLT_MAX;\n    int min_index = 0;\n\n    int i = 0;\n    for (; i <= n - 5; i += 4) {\n        float32x4_t a0 = vld1q_f32(&numbers[i]);\n        float32x4_t a1 = vld1q_f32(&numbers[i + 1]);\n        float32x4_t diff = vsubq_f32(a1, a0);\n        float diffs[4];\n        vst1q_f32(diffs, diff);\n        for (int j = 0; j < 4; j++) {\n            if (diffs[j] < min_diff) {\n                min_diff = diffs[j];\n                min_index = i + j;\n            }\n        }\n    }\n\n    for (; i < n - 1; i++) {\n        float diff = numbers[i + 1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            min_index = i;\n        }\n    }\n\n    return {numbers[min_index], numbers[min_index + 1]};\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return numbers;\n    }\n    float min_val, max_val;\n    if (n < 4) {\n        min_val = numbers[0];\n        max_val = numbers[0];\n        for (size_t i = 1; i < n; ++i) {\n            if (numbers[i] < min_val) min_val = numbers[i];\n            if (numbers[i] > max_val) max_val = numbers[i];\n        }\n    } else {\n        float32x4_t vmin = vld1q_f32(numbers.data());\n        float32x4_t vmax = vmin;\n        size_t i = 4;\n        for (; i <= n - 4; i += 4) {\n            float32x4_t chunk = vld1q_f32(numbers.data() + i);\n            vmin = vminq_f32(vmin, chunk);\n            vmax = vmaxq_f32(vmax, chunk);\n        }\n        min_val = vminvq_f32(vmin);\n        max_val = vmaxvq_f32(vmax);\n        for (size_t j = i; j < n; ++j) {\n            float val = numbers[j];\n            if (val < min_val) min_val = val;\n            if (val > max_val) max_val = val;\n        }\n    }\n    if (min_val == max_val) {\n        for (float &x : numbers) {\n            x = 0.5f;\n        }\n        return numbers;\n    }\n    float range = max_val - min_val;\n    float32x4_t vmin_vec = vdupq_n_f32(min_val);\n    float32x4_t vrange_vec = vdupq_n_f32(range);\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(numbers.data() + i);\n        float32x4_t sub = vsubq_f32(vec, vmin_vec);\n        float32x4_t res = vdivq_f32(sub, vrange_vec);\n        vst1q_f32(numbers.data() + i, res);\n    }\n    for (size_t j = i; j < n; ++j) {\n        numbers[j] = (numbers[j] - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n    if (n == 0) return result;\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, vec);\n        vmax = vmaxq_f32(vmax, vec);\n    }\n\n    float min_temp[4];\n    float max_temp[4];\n    vst1q_f32(min_temp, vmin);\n    vst1q_f32(max_temp, vmax);\n    for (int j = 0; j < 4; j++) {\n        if (min_temp[j] < min_val) min_val = min_temp[j];\n        if (max_temp[j] > max_val) max_val = max_temp[j];\n    }\n\n    for (int j = i; j < n; j++) {\n        if (numbers[j] < min_val) min_val = numbers[j];\n        if (numbers[j] > max_val) max_val = numbers[j];\n    }\n\n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        for (int j = 0; j < n; j++) {\n            result[j] = 0.5f;\n        }\n        return result;\n    }\n\n    float scale = 1.0f / range;\n    float32x4_t vmin_vec = vdupq_n_f32(min_val);\n    float32x4_t vscale_vec = vdupq_n_f32(scale);\n    i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        float32x4_t vsub = vsubq_f32(vec, vmin_vec);\n        float32x4_t vres = vmulq_f32(vsub, vscale_vec);\n        vst1q_f32(&result[i], vres);\n    }\n\n    for (int j = i; j < n; j++) {\n        result[j] = (numbers[j] - min_val) * scale;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::vector<float> result(n);\n    if (n == 0) return result;\n    if (n == 1) {\n        result[0] = 0.5f;\n        return result;\n    }\n\n    float min_val, max_val;\n    if (n < 4) {\n        min_val = numbers[0];\n        max_val = numbers[0];\n        for (int i = 1; i < n; i++) {\n            if (numbers[i] < min_val) min_val = numbers[i];\n            if (numbers[i] > max_val) max_val = numbers[i];\n        }\n    } else {\n        float32x4_t min_vec = vld1q_f32(&numbers[0]);\n        float32x4_t max_vec = min_vec;\n        int i = 4;\n        for (; i <= n - 4; i += 4) {\n            float32x4_t data = vld1q_f32(&numbers[i]);\n            min_vec = vminq_f32(min_vec, data);\n            max_vec = vmaxq_f32(max_vec, data);\n        }\n\n        float32x2_t min_low = vget_low_f32(min_vec);\n        float32x2_t min_high = vget_high_f32(min_vec);\n        float32x2_t min_reduced = vpmin_f32(min_low, min_high);\n        min_reduced = vpmin_f32(min_reduced, min_reduced);\n        min_val = vget_lane_f32(min_reduced, 0);\n\n        float32x2_t max_low = vget_low_f32(max_vec);\n        float32x2_t max_high = vget_high_f32(max_vec);\n        float32x2_t max_reduced = vpmax_f32(max_low, max_high);\n        max_reduced = vpmax_f32(max_reduced, max_reduced);\n        max_val = vget_lane_f32(max_reduced, 0);\n\n        for (; i < n; i++) {\n            if (numbers[i] < min_val) min_val = numbers[i];\n            if (numbers[i] > max_val) max_val = numbers[i];\n        }\n    }\n\n    float range = max_val - min_val;\n    if (range < 1e-9f) {\n        for (int i = 0; i < n; i++) {\n            result[i] = 0.5f;\n        }\n        return result;\n    }\n\n    float scale = 1.0f / range;\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vscale = vdupq_n_f32(scale);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t data = vld1q_f32(&numbers[i]);\n        float32x4_t temp = vsubq_f32(data, vmin);\n        temp = vmulq_f32(temp, vscale);\n        vst1q_f32(&result[i], temp);\n    }\n\n    for (; i < n; i++) {\n        result[i] = (numbers[i] - min_val) * scale;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return {};\n    if (n == 1) return {0.5f};\n\n    float* data = numbers.data();\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    size_t i = 0;\n\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t chunk = vld1q_f32(data + i);\n        vmin = vminq_f32(vmin, chunk);\n        vmax = vmaxq_f32(vmax, chunk);\n    }\n\n    float32x2_t min_reduced = vpmin_f32(vget_low_f32(vmin), vget_high_f32(vmin));\n    min_reduced = vpmin_f32(min_reduced, min_reduced);\n    min_val = vget_lane_f32(min_reduced, 0);\n\n    float32x2_t max_reduced = vpmax_f32(vget_low_f32(vmax), vget_high_f32(vmax));\n    max_reduced = vpmax_f32(max_reduced, max_reduced);\n    max_val = vget_lane_f32(max_reduced, 0);\n\n    for (; i < n; ++i) {\n        min_val = std::min(min_val, data[i]);\n        max_val = std::max(max_val, data[i]);\n    }\n\n    if (min_val == max_val) {\n        return std::vector<float>(n, 0.5f);\n    }\n\n    float range = max_val - min_val;\n    float inv_range = 1.0f / range;\n    float32x4_t vmin_broadcast = vdupq_n_f32(min_val);\n    float32x4_t vscale = vdupq_n_f32(inv_range);\n\n    std::vector<float> result(n);\n    i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t chunk = vld1q_f32(data + i);\n        float32x4_t normalized = vsubq_f32(chunk, vmin_broadcast);\n        normalized = vmulq_f32(normalized, vscale);\n        vst1q_f32(result.data() + i, normalized);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (data[i] - min_val) * inv_range;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    float32x4_t vmin = vdupq_n_f32(min_val);\n    float32x4_t vmax = vdupq_n_f32(max_val);\n    size_t i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vmin = vminq_f32(vmin, vec);\n        vmax = vmaxq_f32(vmax, vec);\n    }\n\n    float32x2_t min_reduced = vmin_f32(vget_low_f32(vmin), vget_high_f32(vmin));\n    min_reduced = vpmin_f32(min_reduced, min_reduced);\n    min_val = vget_lane_f32(min_reduced, 0);\n\n    float32x2_t max_reduced = vmax_f32(vget_low_f32(vmax), vget_high_f32(vmax));\n    max_reduced = vpmax_f32(max_reduced, max_reduced);\n    max_val = vget_lane_f32(max_reduced, 0);\n\n    for (; i < n; ++i) {\n        if (numbers[i] < min_val) min_val = numbers[i];\n        if (numbers[i] > max_val) max_val = numbers[i];\n    }\n\n    float scale = (max_val == min_val) ? 0.0f : 1.0f / (max_val - min_val);\n    std::vector<float> result(n);\n    i = 0;\n\n    float32x4_t vmin_val_vec = vdupq_n_f32(min_val);\n    float32x4_t vscale_vec = vdupq_n_f32(scale);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&numbers[i]);\n        vec = vsubq_f32(vec, vmin_val_vec);\n        vec = vmulq_f32(vec, vscale_vec);\n        vst1q_f32(&result[i], vec);\n    }\n\n    for (; i < n; ++i) {\n        result[i] = (numbers[i] - min_val) * scale;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n    for (uint64_t start = n / 2; start >= 2; start -= 2) {\n        uint64_t candidates[2] = {start, start - 1};\n        uint64x2_t v_cand = vld1q_u64(candidates);\n        uint64_t cand0 = vgetq_lane_u64(v_cand, 0);\n        if (n % cand0 == 0) {\n            return cand0;\n        }\n        uint64_t cand1 = vgetq_lane_u64(v_cand, 1);\n        if (n % cand1 == 0) {\n            return cand1;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n == 2) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n\n    uint64_t i = n / 2;\n    if (i % 2 == 0) {\n        i--;\n    }\n\n    while (i >= 3) {\n        uint64_t candidates[2] = {i, i - 2};\n        uint64x2_t cand_vec = vld1q_u64(candidates);\n        uint64_t cand0 = vgetq_lane_u64(cand_vec, 0);\n        uint64_t cand1 = vgetq_lane_u64(cand_vec, 1);\n\n        if (n % cand0 == 0) {\n            return cand0;\n        }\n        if (n % cand1 == 0) {\n            return cand1;\n        }\n\n        i -= 4;\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n <= 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n\n    uint64_t sqrt_n = (uint64_t)sqrt((double)n);\n    uint64_t base = 3;\n    uint64x2_t v_step = vdupq_n_u64(4);\n    uint64x2_t v_base = vdupq_n_u64(0);\n    v_base = vsetq_lane_u64(base, v_base, 0);\n    v_base = vsetq_lane_u64(base + 2, v_base, 1);\n\n    while (base <= sqrt_n) {\n        if (n % base == 0) {\n            return n / base;\n        }\n\n        uint64_t next = base + 2;\n        if (next <= sqrt_n) {\n            if (n % next == 0) {\n                return n / next;\n            }\n        } else {\n            break;\n        }\n\n        base += 4;\n        v_base = vaddq_u64(v_base, v_step);\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    if (n == 2) {\n        return 1;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n\n    uint64_t low = 1;\n    uint64_t high = (1ULL << 32);\n    uint64_t limit = 1;\n    while (low <= high) {\n        uint64_t mid = low + (high - low) / 2;\n        uint64_t mid_sq = mid * mid;\n        if (mid_sq <= n) {\n            limit = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    for (uint64_t i = 3; i <= limit; i += 4) {\n        uint64_t candidates[2] = {i, i+2};\n        uint64x2_t div_vec = vld1q_u64(candidates);\n        uint64_t d0 = vgetq_lane_u64(div_vec, 0);\n        if (n % d0 == 0) {\n            return n / d0;\n        }\n        uint64_t d1 = vgetq_lane_u64(div_vec, 1);\n        if (d1 > limit) {\n            break;\n        }\n        if (n % d1 == 0) {\n            return n / d1;\n        }\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n\n    uint64_t limit = (uint64_t)sqrt((double)n);\n    uint64_t d = 3;\n    uint64_t found = 0;\n\n    while (d <= limit) {\n        if (d + 2 > limit) {\n            if (n % d == 0) {\n                found = d;\n            }\n            break;\n        }\n\n        uint64_t candidates[2] = {d, d+2};\n        uint64_t q0 = n / candidates[0];\n        uint64_t q1 = n / candidates[1];\n        uint64_t quotients[2] = {q0, q1};\n\n        uint64x2_t v_cand = vld1q_u64(candidates);\n        uint64x2_t v_quot = vld1q_u64(quotients);\n        uint64x2_t v_prod = vmulq_u64(v_cand, v_quot);\n        uint64x2_t v_n = vdupq_n_u64(n);\n        uint64x2_t v_cmp = vceqq_u64(v_prod, v_n);\n\n        uint64_t cmp[2];\n        vst1q_u64(cmp, v_cmp);\n\n        if (cmp[0]) {\n            found = candidates[0];\n            break;\n        }\n        if (cmp[1]) {\n            found = candidates[1];\n            break;\n        }\n\n        d += 4;\n    }\n\n    if (found) {\n        return n / found;\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) {\n        return factors;\n    }\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    if (n == 1) {\n        return factors;\n    }\n    int f = 3;\n    while (static_cast<long long>(f) * f <= n) {\n        uint32_t candidates[4] = {static_cast<uint32_t>(f), \n                                  static_cast<uint32_t>(f + 2), \n                                  static_cast<uint32_t>(f + 4), \n                                  static_cast<uint32_t>(f + 6)};\n        uint32_t quotients[4];\n        for (int i = 0; i < 4; i++) {\n            quotients[i] = n / candidates[i];\n        }\n        uint32x4_t cand_vec = vld1q_u32(candidates);\n        uint32x4_t quot_vec = vld1q_u32(quotients);\n        uint32x4_t product = vmulq_u32(cand_vec, quot_vec);\n        uint32x4_t n_vec = vdupq_n_u32(static_cast<uint32_t>(n));\n        uint32x4_t rem_vec = vsubq_u32(n_vec, product);\n        uint32x4_t zero = vdupq_n_u32(0);\n        uint32x4_t mask = vceqq_u32(rem_vec, zero);\n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, mask);\n        bool found = false;\n        for (int i = 0; i < 4; i++) {\n            if (mask_arr[i]) {\n                factors.push_back(static_cast<int>(candidates[i]));\n                n = quotients[i];\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            continue;\n        } else {\n            f += 8;\n        }\n    }\n    if (n > 1) {\n        factors.push_back(n);\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n\n    static const std::vector<int> small_primes = []{\n        std::vector<int> primes;\n        int limit = 65536;\n        std::vector<bool> is_prime(limit + 1, true);\n        is_prime[0] = is_prime[1] = false;\n        for (int i = 2; i * i <= limit; ++i) {\n            if (is_prime[i]) {\n                for (int j = i * i; j <= limit; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        for (int i = 3; i <= limit; i += 2) {\n            if (is_prime[i]) primes.push_back(i);\n        }\n        return primes;\n    }();\n\n    int i = 0;\n    while (i < small_primes.size() && static_cast<int64_t>(small_primes[i]) * small_primes[i] <= n) {\n        if (i + 1 < small_primes.size()) {\n            uint64_t two_primes[2] = {static_cast<uint64_t>(small_primes[i]), static_cast<uint64_t>(small_primes[i + 1])};\n            uint64x2_t d_vec = vld1q_u64(two_primes);\n            float64x2_t d_f64 = vcvtq_f64_u64(d_vec);\n            float64x2_t n_vec = vdupq_n_f64(n);\n            float64x2_t recp = vrecpeq_f64(d_f64);\n            recp = vmulq_f64(recp, vsubq_f64(vdupq_n_f64(2.0), vmulq_f64(d_f64, recp)));\n            float64x2_t q_approx = vmulq_f64(n_vec, recp);\n            q_approx = vrndnq_f64(q_approx);\n            uint64x2_t q_int = vcvtq_u64_f64(q_approx);\n            uint64_t q_arr[2], d_arr[2];\n            vst1q_u64(q_arr, q_int);\n            vst1q_u64(d_arr, d_vec);\n            if (n == d_arr[0] * q_arr[0]) {\n                factors.push_back(static_cast<int>(d_arr[0]));\n                n = static_cast<int>(q_arr[0]);\n                continue;\n            }\n            if (n == d_arr[1] * q_arr[1]) {\n                factors.push_back(static_cast<int>(d_arr[1]));\n                n = static_cast<int>(q_arr[1]);\n                continue;\n            }\n            i += 2;\n        } else {\n            if (n % small_primes[i] == 0) {\n                factors.push_back(small_primes[i]);\n                n /= small_primes[i];\n            } else {\n                i++;\n            }\n        }\n    }\n\n    for (; i < small_primes.size(); ++i) {\n        while (n % small_primes[i] == 0) {\n            factors.push_back(small_primes[i]);\n            n /= small_primes[i];\n        }\n    }\n\n    if (n > 1) {\n        factors.push_back(n);\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    int d = 11;\n    while (n > 1) {\n        bool found = false;\n        uint32_t small_primes[] = {2, 3, 5, 7};\n        uint32_t small_rem[4] = {1, 1, 1, 1};\n        for (int i = 0; i < 4; i++) {\n            if (n < small_primes[i]) break;\n            small_rem[i] = n % small_primes[i];\n        }\n        uint32x4_t rem_vec = vld1q_u32(small_rem);\n        uint32x4_t zero_vec = vdupq_n_u32(0);\n        uint32x4_t mask = vceqq_u32(rem_vec, zero_vec);\n        if (vgetq_lane_u32(mask, 0) && n >= 2) {\n            factors.push_back(2);\n            n /= 2;\n            found = true;\n        } else if (vgetq_lane_u32(mask, 1) && n >= 3) {\n            factors.push_back(3);\n            n /= 3;\n            found = true;\n        } else if (vgetq_lane_u32(mask, 2) && n >= 5) {\n            factors.push_back(5);\n            n /= 5;\n            found = true;\n        } else if (vgetq_lane_u32(mask, 3) && n >= 7) {\n            factors.push_back(7);\n            n /= 7;\n            found = true;\n        }\n        if (found) continue;\n        if (n == 1) break;\n        uint32_t candidates[] = {d, d+2, d+4, d+6};\n        uint32_t crems[4] = {1, 1, 1, 1};\n        float sqrt_n = std::sqrt(n);\n        for (int i = 0; i < 4; i++) {\n            if (candidates[i] > sqrt_n) break;\n            crems[i] = n % candidates[i];\n        }\n        uint32x4_t rem_cand_vec = vld1q_u32(crems);\n        uint32x4_t mask_cand = vceqq_u32(rem_cand_vec, zero_vec);\n        if (candidates[0] <= sqrt_n && vgetq_lane_u32(mask_cand, 0)) {\n            factors.push_back(candidates[0]);\n            n /= candidates[0];\n            found = true;\n        } else if (candidates[1] <= sqrt_n && vgetq_lane_u32(mask_cand, 1)) {\n            factors.push_back(candidates[1]);\n            n /= candidates[1];\n            found = true;\n        } else if (candidates[2] <= sqrt_n && vgetq_lane_u32(mask_cand, 2)) {\n            factors.push_back(candidates[2]);\n            n /= candidates[2];\n            found = true;\n        } else if (candidates[3] <= sqrt_n && vgetq_lane_u32(mask_cand, 3)) {\n            factors.push_back(candidates[3]);\n            n /= candidates[3];\n            found = true;\n        }\n        if (found) continue;\n        d += 8;\n        if (d > sqrt_n) break;\n    }\n    if (n > 1) factors.push_back(n);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n#include <cstdint>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n < 2) {\n        return factors;\n    }\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    if (n == 1) {\n        return factors;\n    }\n\n    int d = 3;\n    while (n > 1) {\n        if (d > n / d) {\n            factors.push_back(n);\n            break;\n        }\n\n        uint32_t divisors[4] = {static_cast<uint32_t>(d), \n                                static_cast<uint32_t>(d+2), \n                                static_cast<uint32_t>(d+4), \n                                static_cast<uint32_t>(d+6)};\n        int quotients[4];\n        for (int i = 0; i < 4; i++) {\n            quotients[i] = n / divisors[i];\n        }\n\n        uint32x4_t vdiv = vld1q_u32(divisors);\n        uint32x4_t vquot = vld1q_u32(quotients);\n        uint32x4_t vn = vdupq_n_u32(static_cast<uint32_t>(n));\n        uint32x4_t vrem = vsubq_u32(vn, vmulq_u32(vdiv, vquot));\n        uint32x4_t vmask = vceqq_u32(vrem, vdupq_n_u32(0));\n\n        uint32_t mask[4];\n        vst1q_u32(mask, vmask);\n\n        int found_index = -1;\n        for (int i = 0; i < 4; i++) {\n            if (mask[i]) {\n                found_index = i;\n                break;\n            }\n        }\n\n        if (found_index != -1) {\n            factors.push_back(static_cast<int>(divisors[found_index]));\n            n = quotients[found_index];\n            continue;\n        } else {\n            d += 8;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    int k = 1;\n    while (n > 1) {\n        if (n % 2 == 0) {\n            factors.push_back(2);\n            n /= 2;\n            continue;\n        }\n        if (n % 3 == 0) {\n            factors.push_back(3);\n            n /= 3;\n            continue;\n        }\n        if (n == 1) break;\n        int d0 = 6 * k - 1;\n        if (static_cast<uint64_t>(d0) * static_cast<uint64_t>(d0) > static_cast<uint64_t>(n)) {\n            factors.push_back(n);\n            break;\n        }\n        int d1 = 6 * k + 1;\n        int d2 = 6 * k + 5;\n        int d3 = 6 * k + 7;\n        int divisors[4] = {d0, d1, d2, d3};\n        int rems[4];\n        for (int i = 0; i < 4; ++i) {\n            if (divisors[i] > n) {\n                rems[i] = 1;\n            } else {\n                rems[i] = n % divisors[i];\n            }\n        }\n        uint32x4_t rem_vec = vld1q_u32(reinterpret_cast<const uint32_t*>(rems));\n        uint32x4_t zero_vec = vdupq_n_u32(0);\n        uint32x4_t cmp_vec = vceqq_u32(rem_vec, zero_vec);\n        uint32_t cmp0 = vgetq_lane_u32(cmp_vec, 0);\n        uint32_t cmp1 = vgetq_lane_u32(cmp_vec, 1);\n        uint32_t cmp2 = vgetq_lane_u32(cmp_vec, 2);\n        uint32_t cmp3 = vgetq_lane_u32(cmp_vec, 3);\n        if (cmp0) {\n            factors.push_back(d0);\n            n /= d0;\n            k = 1;\n        } else if (cmp1) {\n            factors.push_back(d1);\n            n /= d1;\n            k = 1;\n        } else if (cmp2) {\n            factors.push_back(d2);\n            n /= d2;\n            k = 1;\n        } else if (cmp3) {\n            factors.push_back(d3);\n            n /= d3;\n            k = 1;\n        } else {\n            ++k;\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> res;\n    if (l.empty()) \n        return res;\n\n    res.reserve(l.size());\n    size_t i = 0;\n    const size_t vec_floats = 4;\n    const size_t n = l.size();\n\n    for (; i <= n - vec_floats; i += vec_floats) {\n        float32x4_t chunk = vld1q_f32(&l[i]);\n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(chunk, zeros);\n\n        uint32_t mask_lanes[4];\n        vst1q_u32(mask_lanes, mask);\n\n        if (mask_lanes[0]) res.push_back(vgetq_lane_f32(chunk, 0));\n        if (mask_lanes[1]) res.push_back(vgetq_lane_f32(chunk, 1));\n        if (mask_lanes[2]) res.push_back(vgetq_lane_f32(chunk, 2));\n        if (mask_lanes[3]) res.push_back(vgetq_lane_f32(chunk, 3));\n    }\n\n    for (; i < n; ++i) {\n        if (l[i] > 0) \n            res.push_back(l[i]);\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    size_t n = l.size();\n    if (n == 0) return result;\n    result.reserve(n);\n    const float* data = l.data();\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        float32x4_t zero = vmovq_n_f32(0.0f);\n        uint32x4_t mask = vcgtq_f32(vec, zero);\n\n        if (vgetq_lane_u32(mask, 0)) \n            result.push_back(vgetq_lane_f32(vec, 0));\n        if (vgetq_lane_u32(mask, 1)) \n            result.push_back(vgetq_lane_f32(vec, 1));\n        if (vgetq_lane_u32(mask, 2)) \n            result.push_back(vgetq_lane_f32(vec, 2));\n        if (vgetq_lane_u32(mask, 3)) \n            result.push_back(vgetq_lane_f32(vec, 3));\n    }\n\n    for (; i < n; i++) {\n        if (data[i] > 0.0f) \n            result.push_back(data[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> positive;\n    if (l.empty()) return positive;\n\n    const float* data = l.data();\n    size_t n = l.size();\n    size_t count = 0;\n    size_t i = 0;\n\n    // First pass: count positive numbers\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        uint32x4_t mask = vcgtzq_f32(vec);\n        uint32x4_t ones = vshrq_n_u32(mask, 31);\n        uint32x2_t low = vget_low_u32(ones);\n        uint32x2_t high = vget_high_u32(ones);\n        uint32x2_t sum2 = vadd_u32(low, high);\n        count += vget_lane_u32(sum2, 0) + vget_lane_u32(sum2, 1);\n    }\n\n    // Scalar tail for counting\n    for (; i < n; ++i) {\n        if (data[i] > 0.0f) ++count;\n    }\n\n    // Reserve space\n    positive.reserve(count);\n    i = 0;\n\n    // Second pass: extract positive numbers\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        uint32x4_t mask = vcgtzq_f32(vec);\n        for (int j = 0; j < 4; ++j) {\n            if (vgetq_lane_u32(mask, j)) {\n                positive.push_back(vgetq_lane_f32(vec, j));\n            }\n        }\n    }\n\n    // Scalar tail for extraction\n    for (; i < n; ++i) {\n        if (data[i] > 0.0f) {\n            positive.push_back(data[i]);\n        }\n    }\n\n    return positive;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    if (l.empty()) \n        return result;\n\n    const float* data = l.data();\n    size_t size = l.size();\n    result.reserve(size);\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t vec = vld1q_f32(data + i);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        if (vgetq_lane_u32(mask, 0)) \n            result.push_back(vgetq_lane_f32(vec, 0));\n        if (vgetq_lane_u32(mask, 1)) \n            result.push_back(vgetq_lane_f32(vec, 1));\n        if (vgetq_lane_u32(mask, 2)) \n            result.push_back(vgetq_lane_f32(vec, 2));\n        if (vgetq_lane_u32(mask, 3)) \n            result.push_back(vgetq_lane_f32(vec, 3));\n    }\n\n    for (; i < size; ++i) {\n        if (data[i] > 0.0f) \n            result.push_back(data[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> res;\n    if (l.empty()) \n        return res;\n\n    res.reserve(l.size());\n    size_t i = 0;\n    const int vector_size = 4;\n    const size_t n = l.size();\n\n    for (; i + vector_size <= n; i += vector_size) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        uint32x4_t mask = vcgtq_f32(vec, vdupq_n_f32(0.0f));\n\n        if (vgetq_lane_u32(mask, 0)) \n            res.push_back(vgetq_lane_f32(vec, 0));\n        if (vgetq_lane_u32(mask, 1)) \n            res.push_back(vgetq_lane_f32(vec, 1));\n        if (vgetq_lane_u32(mask, 2)) \n            res.push_back(vgetq_lane_f32(vec, 2));\n        if (vgetq_lane_u32(mask, 3)) \n            res.push_back(vgetq_lane_f32(vec, 3));\n    }\n\n    for (; i < n; ++i) {\n        if (l[i] > 0.0f) \n            res.push_back(l[i]);\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    uint64_t un = n;\n    if (un <= 1) return false;\n    if (un == 2) return true;\n    if (un % 2 == 0) return false;\n\n    uint64_t i = 3;\n    while (i * i <= un) {\n        uint64_t rem0 = un % i;\n        uint64_t rem1 = 1;\n        uint64_t next = i + 2;\n        if (next * next <= un) {\n            rem1 = un % next;\n        }\n\n        uint64_t rems[2] = {rem0, rem1};\n        uint64x2_t vrems = vld1q_u64(rems);\n        uint64x2_t vzero = vdupq_n_u64(0);\n        uint64x2_t vcmp = vceqq_u64(vrems, vzero);\n\n        uint64_t cmp0 = vgetq_lane_u64(vcmp, 0);\n        uint64_t cmp1 = vgetq_lane_u64(vcmp, 1);\n        if (cmp0 || cmp1) {\n            return false;\n        }\n        i += 4;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) \n        return false;\n    if (n == 2) \n        return true;\n    if (n % 2 == 0) \n        return false;\n\n    static const uint32_t small_primes[] = {\n        3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97\n    };\n    uint64_t n_unsigned = (uint64_t)n;\n    int num_small = sizeof(small_primes) / sizeof(small_primes[0]);\n\n    for (int i = 0; i < num_small; i += 4) {\n        uint32x4_t p_vec = vld1q_u32(small_primes + i);\n        uint32_t p[4];\n        vst1q_u32(p, p_vec);\n\n        for (int j = 0; j < 4; j++) {\n            if (n == p[j]) \n                return true;\n            if (n % p[j] == 0) \n                return false;\n        }\n    }\n\n    for (uint64_t d = 101; d <= n_unsigned / d; d += 2) {\n        if (n_unsigned % d == 0) \n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    uint64_t un = (uint64_t)n;\n    uint64_t limit = (uint64_t)sqrt((double)un) + 1;\n\n    uint32_t d = 3;\n    while (d <= limit) {\n        if (d + 6 > limit) {\n            for (; d <= limit; d += 2) {\n                if (un % d == 0) {\n                    return false;\n                }\n            }\n            break;\n        }\n\n        uint32_t divisors[4] = {d, d + 2, d + 4, d + 6};\n        uint32_t rems[4];\n        for (int i = 0; i < 4; i++) {\n            rems[i] = un % divisors[i];\n        }\n\n        uint32x4_t v_rem = vld1q_u32(rems);\n        uint32x4_t v_zero = vdupq_n_u32(0);\n        uint32x4_t v_cmp = vceqq_u32(v_rem, v_zero);\n        if (vmaxvq_u32(v_cmp) {\n            return false;\n        }\n        d += 8;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <math.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    uint64_t un = (uint64_t)n;\n    uint64_t sqrt_n = (uint64_t)sqrt((double)un);\n    if (sqrt_n * sqrt_n > un) sqrt_n--;\n    uint64_t init_div[2] = {3, 5};\n    uint64x2_t v_div = vld1q_u64(init_div);\n    uint64x2_t v_step = vdupq_n_u64(4);\n    while (vgetq_lane_u64(v_div, 0) <= sqrt_n) {\n        if (un % vgetq_lane_u64(v_div, 0) == 0) return false;\n        uint64_t d1 = vgetq_lane_u64(v_div, 1);\n        if (d1 <= sqrt_n && un % d1 == 0) return false;\n        v_div = vaddq_u64(v_div, v_step);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    uint64_t n_unsigned = (n < 0) ? -n : n;\n    uint32_t sqrt_n = (uint32_t)sqrt(n_unsigned);\n    while ((uint64_t)sqrt_n * sqrt_n > n_unsigned) {\n        sqrt_n--;\n    }\n\n    if (sqrt_n < 3) {\n        return true;\n    }\n\n    uint32x4_t offsets = {0, 2, 4, 6};\n    uint32_t d = 3;\n\n    while (d + 6 <= sqrt_n) {\n        uint32x4_t base_vec = vdupq_n_u32(d);\n        uint32x4_t divs = vaddq_u32(base_vec, offsets);\n\n        uint32_t d0 = vgetq_lane_u32(divs, 0);\n        uint32_t d1 = vgetq_lane_u32(divs, 1);\n        uint32_t d2 = vgetq_lane_u32(divs, 2);\n        uint32_t d3 = vgetq_lane_u32(divs, 3);\n\n        if (n_unsigned % d0 == 0) return false;\n        if (n_unsigned % d1 == 0) return false;\n        if (n_unsigned % d2 == 0) return false;\n        if (n_unsigned % d3 == 0) return false;\n\n        d += 8;\n    }\n\n    for (; d <= sqrt_n; d += 2) {\n        if (n_unsigned % d == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.length();\n    if (n == 0) {\n        return s;\n    }\n\n    bool any_letter = false;\n    std::string result = s;\n\n    size_t i = 0;\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t v_A = vdupq_n_u8('A');\n        uint8x16_t v_Z = vdupq_n_u8('Z');\n        uint8x16_t v_a = vdupq_n_u8('a');\n        uint8x16_t v_z = vdupq_n_u8('z');\n\n        uint8x16_t cmp_ge_A = vcgeq_u8(data, v_A);\n        uint8x16_t cmp_le_Z = vcleq_u8(data, v_Z);\n        uint8x16_t is_upper = vandq_u8(cmp_ge_A, cmp_le_Z);\n\n        uint8x16_t cmp_ge_a = vcgeq_u8(data, v_a);\n        uint8x16_t cmp_le_z = vcleq_u8(data, v_z);\n        uint8x16_t is_lower = vandq_u8(cmp_ge_a, cmp_le_z);\n\n        uint8x16_t is_letter = vorrq_u8(is_upper, is_lower);\n\n        uint8x16_t temp = is_letter;\n        uint8x8_t low = vget_low_u8(temp);\n        uint8x8_t high = vget_high_u8(temp);\n        uint8x8_t orred = vorr_u8(low, high);\n        orred = vorr_u8(orred, vext_u8(orred, orred, 4));\n        orred = vorr_u8(orred, vext_u8(orred, orred, 2));\n        orred = vorr_u8(orred, vext_u8(orred, orred, 1));\n        if (vget_lane_u8(orred, 0)) {\n            any_letter = true;\n        }\n\n        uint8x16_t flip_vec = vandq_u8(is_letter, vdupq_n_u8(0x20));\n        uint8x16_t flipped = veorq_u8(data, flip_vec);\n        vst1q_u8(reinterpret_cast<uint8_t*>(result.data() + i), flipped);\n    }\n\n    for (; i < n; i++) {\n        char c = s[i];\n        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n            any_letter = true;\n            c ^= 0x20;\n        }\n        result[i] = c;\n    }\n\n    if (any_letter) {\n        return result;\n    }\n\n    std::string reversed(n, '\\0');\n    char* out = reversed.data();\n    const char* in = result.data();\n\n    if (n < 16) {\n        for (size_t i = 0; i < n; i++) {\n            out[i] = in[n - 1 - i];\n        }\n    } else {\n        size_t i_simd = 0;\n        size_t j_simd = n - 16;\n\n        while (i_simd + 16 <= j_simd) {\n            uint8x16_t front = vld1q_u8(reinterpret_cast<const uint8_t*>(in + i_simd));\n            uint8x16_t back = vld1q_u8(reinterpret_cast<const uint8_t*>(in + j_simd));\n\n            front = vrev64q_u8(front);\n            back = vrev64q_u8(back);\n            front = vcombine_u8(vget_high_u8(front), vget_low_u8(front));\n            back = vcombine_u8(vget_high_u8(back), vget_low_u8(back));\n\n            vst1q_u8(reinterpret_cast<uint8_t*>(out + i_simd), back);\n            vst1q_u8(reinterpret_cast<uint8_t*>(out + j_simd), front);\n\n            i_simd += 16;\n            j_simd -= 16;\n        }\n\n        size_t start = i_simd;\n        size_t end = j_simd + 15;\n        for (size_t k = start; k <= end; k++) {\n            out[k] = in[end - (k - start)];\n        }\n    }\n\n    return reversed;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <cstring>\n#include <string>\n#include <arm_neon.h>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n    const char* src = s.data();\n    bool has_letter = false;\n    size_t i = 0;\n\n    // Check for any letter in the string\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(src + i));\n        uint8x16_t cmp_ge_A = vcgeq_u8(v, vdupq_n_u8('A'));\n        uint8x16_t cmp_le_Z = vcleq_u8(v, vdupq_n_u8('Z'));\n        uint8x16_t is_upper = vandq_u8(cmp_ge_A, cmp_le_Z);\n        uint8x16_t cmp_ge_a = vcgeq_u8(v, vdupq_n_u8('a'));\n        uint8x16_t cmp_le_z = vcleq_u8(v, vdupq_n_u8('z'));\n        uint8x16_t is_lower = vandq_u8(cmp_ge_a, cmp_le_z);\n        uint8x16_t is_letter = vorrq_u8(is_upper, is_lower);\n        if (vaddvq_u8(is_letter) != 0) {\n            has_letter = true;\n            break;\n        }\n    }\n    if (!has_letter) {\n        for (; i < n; ++i) {\n            char c = src[i];\n            if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n                has_letter = true;\n                break;\n            }\n        }\n    }\n\n    if (has_letter) {\n        std::string result = s;\n        char* dst = &result[0];\n        i = 0;\n        for (; i + 16 <= n; i += 16) {\n            uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(src + i));\n            uint8x16_t cmp_ge_A = vcgeq_u8(v, vdupq_n_u8('A'));\n            uint8x16_t cmp_le_Z = vcleq_u8(v, vdupq_n_u8('Z'));\n            uint8x16_t is_upper = vandq_u8(cmp_ge_A, cmp_le_Z);\n            uint8x16_t cmp_ge_a = vcgeq_u8(v, vdupq_n_u8('a'));\n            uint8x16_t cmp_le_z = vcleq_u8(v, vdupq_n_u8('z'));\n            uint8x16_t is_lower = vandq_u8(cmp_ge_a, cmp_le_z);\n            uint8x16_t is_letter = vorrq_u8(is_upper, is_lower);\n            uint8x16_t flip = vandq_u8(vdupq_n_u8(32), is_letter);\n            uint8x16_t flipped = veorq_u8(v, flip);\n            vst1q_u8(reinterpret_cast<uint8_t*>(dst + i), flipped);\n        }\n        for (; i < n; ++i) {\n            char c = src[i];\n            if (c >= 'A' && c <= 'Z') {\n                dst[i] = c + 32;\n            } else if (c >= 'a' && c <= 'z') {\n                dst[i] = c - 32;\n            }\n        }\n        return result;\n    } else {\n        std::string result(n, '\\0');\n        char* dst = &result[0];\n        i = 0;\n        for (; i + 16 <= n; i += 16) {\n            size_t j = n - i - 16;\n            uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(src + j));\n            uint8x16_t rev_chunk = vrev64q_u8(chunk);\n            rev_chunk = vextq_u8(rev_chunk, rev_chunk, 8);\n            vst1q_u8(reinterpret_cast<uint8_t*>(dst + i), rev_chunk);\n        }\n        for (; i < n; ++i) {\n            dst[i] = src[n - 1 - i];\n        }\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) {\n        return \"\";\n    }\n\n    std::string result(n, '\\0');\n    const char* src = s.data();\n    char* dst = &result[0];\n    bool has_letter = false;\n    size_t i = 0;\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(src + i));\n        uint8x16_t ge_a = vcgeq_u8(chunk, vdupq_n_u8('a'));\n        uint8x16_t le_z = vcleq_u8(chunk, vdupq_n_u8('z'));\n        uint8x16_t is_lower = vandq_u8(ge_a, le_z);\n\n        uint8x16_t ge_A = vcgeq_u8(chunk, vdupq_n_u8('A'));\n        uint8x16_t le_Z = vcleq_u8(chunk, vdupq_n_u8('Z'));\n        uint8x16_t is_upper = vandq_u8(ge_A, le_Z);\n\n        uint8x16_t is_letter = vorrq_u8(is_lower, is_upper);\n        uint64x2_t high_low = vreinterpretq_u64_u8(is_letter);\n        uint64_t low = vgetq_lane_u64(high_low, 0);\n        uint64_t high = vgetq_lane_u64(high_low, 1);\n        if (low || high) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        for (; i < n; i++) {\n            char c = src[i];\n            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n                has_letter = true;\n                break;\n            }\n        }\n    }\n\n    if (has_letter) {\n        i = 0;\n        for (; i + 16 <= n; i += 16) {\n            uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(src + i));\n            uint8x16_t ge_a = vcgeq_u8(chunk, vdupq_n_u8('a'));\n            uint8x16_t le_z = vcleq_u8(chunk, vdupq_n_u8('z'));\n            uint8x16_t is_lower = vandq_u8(ge_a, le_z);\n\n            uint8x16_t ge_A = vcgeq_u8(chunk, vdupq_n_u8('A'));\n            uint8x16_t le_Z = vcleq_u8(chunk, vdupq_n_u8('Z'));\n            uint8x16_t is_upper = vandq_u8(ge_A, le_Z);\n\n            uint8x16_t adjust = vdupq_n_u8(0);\n            adjust = vsubq_u8(adjust, vandq_u8(is_lower, vdupq_n_u8(32)));\n            adjust = vaddq_u8(adjust, vandq_u8(is_upper, vdupq_n_u8(32)));\n            uint8x16_t flipped = vaddq_u8(chunk, adjust);\n            vst1q_u8(reinterpret_cast<uint8_t*>(dst + i), flipped);\n        }\n        for (; i < n; i++) {\n            char c = src[i];\n            if (c >= 'a' && c <= 'z') {\n                dst[i] = c - 32;\n            } else if (c >= 'A' && c <= 'Z') {\n                dst[i] = c + 32;\n            } else {\n                dst[i] = c;\n            }\n        }\n    } else {\n        size_t num_full_chunks = n / 16;\n        size_t remainder = n % 16;\n        for (size_t j = 0; j < num_full_chunks; j++) {\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(src + j * 16));\n            uint8x16_t rev64 = vrev64q_u8(data);\n            uint8x16_t reversed = vcombine_u8(vget_high_u8(rev64), vget_low_u8(rev64));\n            vst1q_u8(reinterpret_cast<uint8_t*>(dst + n - (j + 1) * 16), reversed);\n        }\n        if (remainder) {\n            const char* src_remain = src + num_full_chunks * 16;\n            for (size_t j = 0; j < remainder; j++) {\n                dst[j] = src_remain[remainder - 1 - j];\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n    const uint8_t *p = (const uint8_t*)s.data();\n    bool has_letter = false;\n    uint8x16_t a_min = vdupq_n_u8('a');\n    uint8x16_t z_max = vdupq_n_u8('z');\n    uint8x16_t A_min = vdupq_n_u8('A');\n    uint8x16_t Z_max = vdupq_n_u8('Z');\n    uint8x16_t any_letter_vector = vdupq_n_u8(0);\n    size_t i = 0;\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t data = vld1q_u8(p + i);\n        uint8x16_t low_mask = vandq_u8(vcgeq_u8(data, a_min), vcleq_u8(data, z_max));\n        uint8x16_t up_mask = vandq_u8(vcgeq_u8(data, A_min), vcleq_u8(data, Z_max));\n        uint8x16_t letter_mask = vorrq_u8(low_mask, up_mask);\n        any_letter_vector = vorrq_u8(any_letter_vector, letter_mask);\n    }\n\n    uint64x2_t any_letter_64 = vreinterpretq_u64_u8(any_letter_vector);\n    uint64_t any_letter_low = vgetq_lane_u64(any_letter_64, 0);\n    uint64_t any_letter_high = vgetq_lane_u64(any_letter_64, 1);\n    if (any_letter_low || any_letter_high) {\n        has_letter = true;\n    } else {\n        for (; i < n; i++) {\n            uint8_t c = p[i];\n            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')) {\n                has_letter = true;\n                break;\n            }\n        }\n    }\n\n    if (has_letter) {\n        std::string result;\n        result.resize(n);\n        uint8_t *out = (uint8_t*)result.data();\n        i = 0;\n\n        for (; i + 16 <= n; i += 16) {\n            uint8x16_t data = vld1q_u8(p + i);\n            uint8x16_t low_mask = vandq_u8(vcgeq_u8(data, a_min), vcleq_u8(data, z_max));\n            uint8x16_t up_mask = vandq_u8(vcgeq_u8(data, A_min), vcleq_u8(data, Z_max));\n            uint8x16_t letter_mask = vorrq_u8(low_mask, up_mask);\n            uint8x16_t flip_vec = vandq_u8(letter_mask, vdupq_n_u8(32));\n            uint8x16_t flipped = veorq_u8(data, flip_vec);\n            vst1q_u8(out + i, flipped);\n        }\n\n        for (; i < n; i++) {\n            uint8_t c = p[i];\n            if (c >= 'a' && c <= 'z') {\n                out[i] = c - 32;\n            } else if (c >= 'A' && c <= 'Z') {\n                out[i] = c + 32;\n            } else {\n                out[i] = c;\n            }\n        }\n        return result;\n    } else {\n        std::string result;\n        result.resize(n);\n        uint8_t *out = (uint8_t*)result.data();\n        size_t r = n % 16;\n        for (size_t j = 0; j < r; j++) {\n            out[j] = p[n - 1 - j];\n        }\n        size_t write_index = r;\n        intptr_t j = static_cast<intptr_t>(n - r - 16);\n\n        while (j >= 0) {\n            uint8x16_t data = vld1q_u8(p + j);\n            uint8x16_t rev_data = vrev64q_u8(data);\n            rev_data = vextq_u8(rev_data, rev_data, 8);\n            vst1q_u8(out + write_index, rev_data);\n            write_index += 16;\n            j -= 16;\n        }\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string solve_simd(const std::string & s) {\n    const char* src = s.data();\n    int n = s.length();\n    if (n == 0) return \"\";\n\n    bool has_letter = false;\n    int i = 0;\n\n    for (; i <= n - 16; i += 16) {\n        uint8x16_t block = vld1q_u8((const uint8_t*)(src + i));\n        uint8x16_t mask1 = vandq_u8(vcgeq_u8(block, vdupq_n_u8('a')), vcleq_u8(block, vdupq_n_u8('z')));\n        uint8x16_t mask2 = vandq_u8(vcgeq_u8(block, vdupq_n_u8('A')), vcleq_u8(block, vdupq_n_u8('Z')));\n        uint8x16_t mask_letter = vorrq_u8(mask1, mask2);\n        uint8_t maxval = vmaxvq_u8(mask_letter);\n        if (maxval != 0) {\n            has_letter = true;\n            break;\n        }\n    }\n\n    if (!has_letter) {\n        for (; i < n; i++) {\n            char c = src[i];\n            if (('a' <= c && c <= 'z') || ('A' <= c && c <= 'Z')) {\n                has_letter = true;\n                break;\n            }\n        }\n    }\n\n    if (has_letter) {\n        std::string result = s;\n        char* dst = &result[0];\n        i = 0;\n        for (; i <= n - 16; i += 16) {\n            uint8x16_t block = vld1q_u8((const uint8_t*)(src + i));\n            uint8x16_t mask1 = vandq_u8(vcgeq_u8(block, vdupq_n_u8('a')), vcleq_u8(block, vdupq_n_u8('z')));\n            uint8x16_t mask2 = vandq_u8(vcgeq_u8(block, vdupq_n_u8('A')), vcleq_u8(block, vdupq_n_u8('Z')));\n            uint8x16_t mask_letter = vorrq_u8(mask1, mask2);\n            uint8x16_t flip = vandq_u8(mask_letter, vdupq_n_u8(0x20));\n            uint8x16_t flipped_block = veorq_u8(block, flip);\n            vst1q_u8((uint8_t*)(dst + i), flipped_block);\n        }\n        for (; i < n; i++) {\n            char c = dst[i];\n            if ('a' <= c && c <= 'z') {\n                dst[i] = c - 0x20;\n            } else if ('A' <= c && c <= 'Z') {\n                dst[i] = c + 0x20;\n            }\n        }\n        return result;\n    } else {\n        std::string result(n, '\\0');\n        char* dst_ptr = &result[0];\n        i = 0;\n        for (; i <= n - 16; i += 16) {\n            uint8x16_t data = vld1q_u8((const uint8_t*)(src + n - i - 16));\n            uint8x16_t rev_data = vrev64q_u8(data);\n            rev_data = vextq_u8(rev_data, rev_data, 8);\n            vst1q_u8((uint8_t*)(dst_ptr + i), rev_data);\n        }\n        int r = n - i;\n        if (r > 0) {\n            uint8_t buffer[16] = {0};\n            std::memcpy(buffer, src, r);\n            uint8x16_t data = vld1q_u8(buffer);\n            uint8x16_t rev_data = vrev64q_u8(data);\n            rev_data = vextq_u8(rev_data, rev_data, 8);\n            uint8_t temp[16];\n            vst1q_u8(temp, rev_data);\n            for (int j = 0; j < r; j++) {\n                dst_ptr[i + j] = temp[16 - r + j];\n            }\n        }\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n == 0) {\n        return l;\n    }\n    size_t m = (n + 2) / 3;\n    std::vector<int> temp0;\n    temp0.reserve(m);\n    size_t i = 0;\n    for (; i + 12 <= n; i += 12) {\n        int32x4x3_t data = vld3q_s32(l.data() + i);\n        int32_t buf[4];\n        vst1q_s32(buf, data.val[0]);\n        for (int k = 0; k < 4; k++) {\n            temp0.push_back(buf[k]);\n        }\n    }\n    for (; i < n; i += 3) {\n        temp0.push_back(l[i]);\n    }\n    std::sort(temp0.begin(), temp0.end());\n    i = 0;\n    size_t j = 0;\n    for (; i + 12 <= n; i += 12) {\n        int32x4x3_t data = vld3q_s32(l.data() + i);\n        int32_t buf[4] = { temp0[j], temp0[j+1], temp0[j+2], temp0[j+3] };\n        j += 4;\n        data.val[0] = vld1q_s32(buf);\n        vst3q_s32(l.data() + i, data);\n    }\n    for (; i < n; i += 3) {\n        l[i] = temp0[j++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) {\n        return l;\n    }\n\n    int i = 0;\n    for (; i <= n - 12; i += 12) {\n        int32x4_t v0 = vld1q_s32(&l[i]);\n        int32x4_t v1 = vld1q_s32(&l[i+4]);\n        int32x4_t v2 = vld1q_s32(&l[i+8]);\n\n        int a0 = vgetq_lane_s32(v0, 0);\n        int a3 = vgetq_lane_s32(v0, 3);\n        int a6 = vgetq_lane_s32(v1, 2);\n        int a9 = vgetq_lane_s32(v2, 1);\n\n        int arr[4] = {a0, a3, a6, a9};\n        for (int pass = 0; pass < 3; pass++) {\n            for (int j = 0; j < 3 - pass; j++) {\n                if (arr[j] > arr[j+1]) {\n                    int temp = arr[j];\n                    arr[j] = arr[j+1];\n                    arr[j+1] = temp;\n                }\n            }\n        }\n\n        v0 = vsetq_lane_s32(arr[0], v0, 0);\n        v0 = vsetq_lane_s32(arr[1], v0, 3);\n        v1 = vsetq_lane_s32(arr[2], v1, 2);\n        v2 = vsetq_lane_s32(arr[3], v2, 1);\n\n        vst1q_s32(&l[i], v0);\n        vst1q_s32(&l[i+4], v1);\n        vst1q_s32(&l[i+8], v2);\n    }\n\n    std::vector<int> temp;\n    for (int j = i; j < n; j++) {\n        if (j % 3 == 0) {\n            temp.push_back(l[j]);\n        }\n    }\n\n    int m = temp.size();\n    for (int pass = 0; pass < m - 1; pass++) {\n        for (int j = 0; j < m - 1 - pass; j++) {\n            if (temp[j] > temp[j+1]) {\n                int t = temp[j];\n                temp[j] = temp[j+1];\n                temp[j+1] = t;\n            }\n        }\n    }\n\n    int k = 0;\n    for (int j = i; j < n; j++) {\n        if (j % 3 == 0) {\n            l[j] = temp[k++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n == 0) return l;\n\n    int m = (n + 2) / 3;\n    std::vector<int> temp(m);\n    int* data = l.data();\n\n    int j = 0;\n    int i = 0;\n    for (; i <= n - 12; i += 12) {\n        int32x4x3_t triplets = vld3q_s32(data + i);\n        vst1q_s32(&temp[j], triplets.val[0]);\n        j += 4;\n    }\n    for (; i < n; i += 3) {\n        if (i < n) {\n            temp[j++] = data[i];\n        }\n    }\n\n    std::sort(temp.begin(), temp.end());\n\n    j = 0;\n    i = 0;\n    for (; i <= n - 12; i += 12) {\n        int32x4x3_t triplets = vld3q_s32(data + i);\n        triplets.val[0] = vld1q_s32(&temp[j]);\n        vst3q_s32(data + i, triplets);\n        j += 4;\n    }\n    for (; i < n; i += 3) {\n        if (i < n) {\n            data[i] = temp[j++];\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n == 0) return l;\n\n    size_t m = (n + 2) / 3;\n    std::vector<int> extracted(m);\n\n    const uint32_t mask0_arr[4] = {0xFFFFFFFF, 0, 0, 0xFFFFFFFF};\n    const uint32_t mask1_arr[4] = {0, 0, 0xFFFFFFFF, 0};\n    const uint32_t mask2_arr[4] = {0, 0xFFFFFFFF, 0, 0};\n    const uint32x4_t mask0 = vld1q_u32(mask0_arr);\n    const uint32x4_t mask1 = vld1q_u32(mask1_arr);\n    const uint32x4_t mask2 = vld1q_u32(mask2_arr);\n\n    size_t extracted_index = 0;\n    for (size_t base = 0; base + 12 <= n; base += 12) {\n        int32x4_t v0 = vld1q_s32(&l[base]);\n        int32x4_t v1 = vld1q_s32(&l[base + 4]);\n        int32x4_t v2 = vld1q_s32(&l[base + 8]);\n\n        int32x2_t v0_low = vget_low_s32(v0);\n        int32x2_t v0_high = vget_high_s32(v0);\n        int32x2_t v1_high = vget_high_s32(v1);\n        int32x2_t v2_low = vget_low_s32(v2);\n\n        int32x2_t part0 = vdup_n_s32(0);\n        part0 = vset_lane_s32(vget_lane_s32(v0_low, 0), part0, 0);\n        part0 = vset_lane_s32(vget_lane_s32(v0_high, 1), part0, 1);\n\n        int32x2_t part1 = vdup_n_s32(0);\n        part1 = vset_lane_s32(vget_lane_s32(v1_high, 0), part1, 0);\n        part1 = vset_lane_s32(vget_lane_s32(v2_low, 1), part1, 1);\n\n        int32x4_t selected = vcombine_s32(part0, part1);\n        vst1q_s32(&extracted[base / 3], selected);\n    }\n\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (i >= extracted_index * 3) {\n                extracted[extracted_index++] = l[i];\n            }\n        }\n    }\n\n    std::sort(extracted.begin(), extracted.end());\n\n    extracted_index = 0;\n    for (size_t base = 0; base + 12 <= n; base += 12) {\n        int32x4_t v0 = vld1q_s32(&l[base]);\n        int32x4_t v1 = vld1q_s32(&l[base + 4]);\n        int32x4_t v2 = vld1q_s32(&l[base + 8]);\n\n        int32x4_t sorted_block = vld1q_s32(&extracted[base / 3]);\n\n        int32x4_t new_v0 = vsetq_lane_s32(vgetq_lane_s32(sorted_block, 0), v0, 0);\n        new_v0 = vsetq_lane_s32(vgetq_lane_s32(sorted_block, 1), new_v0, 3);\n        v0 = vbslq_s32(mask0, new_v0, v0);\n\n        int32x4_t new_v1 = vsetq_lane_s32(vgetq_lane_s32(sorted_block, 2), v1, 2);\n        v1 = vbslq_s32(mask1, new_v1, v1);\n\n        int32x4_t new_v2 = vsetq_lane_s32(vgetq_lane_s32(sorted_block, 3), v2, 1);\n        v2 = vbslq_s32(mask2, new_v2, v2);\n\n        vst1q_s32(&l[base], v0);\n        vst1q_s32(&l[base + 4], v1);\n        vst1q_s32(&l[base + 8], v2);\n    }\n\n    for (size_t i = 0; i < n; i++) {\n        if (i % 3 == 0) {\n            if (i >= extracted_index * 3) {\n                l[i] = extracted[extracted_index++];\n            }\n        }\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    std::vector<int> result = l;\n    int n = result.size();\n    if (n == 0) return result;\n    \n    int m = (n + 2) / 3;\n    std::vector<int> temp(m);\n    \n    int i = 0;\n    for (; i <= m - 4; i += 4) {\n        int base = i * 3;\n        if (base + 12 <= n) {\n            uint32x4x3_t data = vld3q_u32((uint32_t*)&result[base]);\n            vst1q_u32((uint32_t*)&temp[i], data.val[0]);\n        } else {\n            break;\n        }\n    }\n    for (; i < m; i++) {\n        temp[i] = result[i * 3];\n    }\n    \n    std::sort(temp.begin(), temp.end());\n    \n    i = 0;\n    for (; i <= m - 4; i += 4) {\n        int base = i * 3;\n        if (base + 12 <= n) {\n            uint32x4_t sorted_vals = vld1q_u32((uint32_t*)&temp[i]);\n            uint32x4x3_t data = vld3q_u32((uint32_t*)&result[base]);\n            data.val[0] = sorted_vals;\n            vst3q_u32((uint32_t*)&result[base], data);\n        } else {\n            break;\n        }\n    }\n    for (; i < m; i++) {\n        result[i * 3] = temp[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) return 0.0f;\n    if (n < 4) {\n        float max_val = l[0];\n        for (size_t i = 1; i < n; ++i) {\n            if (l[i] > max_val) max_val = l[i];\n        }\n        return max_val;\n    }\n\n    float32x4_t vmax = vld1q_f32(l.data());\n    size_t i = 4;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t v = vld1q_f32(l.data() + i);\n        vmax = vmaxq_f32(vmax, v);\n    }\n\n    float32x2_t vmax_low = vget_low_f32(vmax);\n    float32x2_t vmax_high = vget_high_f32(vmax);\n    float32x2_t vmax_temp = vmax_f32(vmax_low, vmax_high);\n    vmax_temp = vpmax_f32(vmax_temp, vmax_temp);\n    float max_val = vget_lane_f32(vmax_temp, 0);\n\n    for (; i < n; ++i) {\n        if (l[i] > max_val) max_val = l[i];\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float max_val = l[0];\n    if (n < 4) {\n        for (int i = 1; i < n; i++) {\n            if (l[i] > max_val) {\n                max_val = l[i];\n            }\n        }\n        return max_val;\n    }\n\n    float32x4_t max_vec = vld1q_f32(&l[0]);\n    int i = 4;\n    while (i <= n - 4) {\n        float32x4_t chunk = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, chunk);\n        i += 4;\n    }\n\n    float32x2_t low = vget_low_f32(max_vec);\n    float32x2_t high = vget_high_f32(max_vec);\n    float32x2_t max2 = vpmax_f32(low, high);\n    max2 = vpmax_f32(max2, max2);\n    max_val = vget_lane_f32(max2, 0);\n\n    while (i < n) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n        i++;\n    }\n\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    float32x4_t vmax = vdupq_n_f32(l[0]);\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, vec);\n    }\n    float max_val = vgetq_lane_f32(vmax, 0);\n    float lane1 = vgetq_lane_f32(vmax, 1);\n    float lane2 = vgetq_lane_f32(vmax, 2);\n    float lane3 = vgetq_lane_f32(vmax, 3);\n    if (lane1 > max_val) max_val = lane1;\n    if (lane2 > max_val) max_val = lane2;\n    if (lane3 > max_val) max_val = lane3;\n    if (i == 0) i = 1;\n    for (; i < n; i++) {\n        if (l[i] > max_val) max_val = l[i];\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```cpp\n#include <cfloat>\n#include <vector>\n#include <arm_neon.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n == 0) {\n        return 0.0f;\n    }\n\n    float32x4_t vmax = vdupq_n_f32(-FLT_MAX);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t chunk = vld1q_f32(&l[i]);\n        vmax = vmaxq_f32(vmax, chunk);\n    }\n\n    if (i < n) {\n        float temp[4] = { -FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX };\n        for (int j = 0; j < n - i; j++) {\n            temp[j] = l[i + j];\n        }\n        float32x4_t tail = vld1q_f32(temp);\n        vmax = vmaxq_f32(vmax, tail);\n    }\n\n    float32x2_t low = vget_low_f32(vmax);\n    float32x2_t high = vget_high_f32(vmax);\n    float32x2_t max_pair = vpmax_f32(low, high);\n    max_pair = vpmax_f32(max_pair, max_pair);\n    float result = vget_lane_f32(max_pair, 0);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <vector>\n#include <cfloat>\n\nfloat max_element_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n == 0) {\n        return 0.0f;\n    }\n    float32x4_t max_vec;\n    int i = 0;\n    if (n >= 4) {\n        max_vec = vld1q_f32(&l[0]);\n        i = 4;\n    } else {\n        float temp_arr[4] = {-FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX};\n        for (int j = 0; j < n; j++) {\n            temp_arr[j] = l[j];\n        }\n        max_vec = vld1q_f32(temp_arr);\n        i = n;\n    }\n    for (; i <= n - 4; i += 4) {\n        float32x4_t chunk = vld1q_f32(&l[i]);\n        max_vec = vmaxq_f32(max_vec, chunk);\n    }\n    int remaining = n - i;\n    if (remaining > 0) {\n        float temp_arr[4] = {-FLT_MAX, -FLT_MAX, -FLT_MAX, -FLT_MAX};\n        for (int j = 0; j < remaining; j++) {\n            temp_arr[j] = l[i+j];\n        }\n        float32x4_t tail = vld1q_f32(temp_arr);\n        max_vec = vmaxq_f32(max_vec, tail);\n    }\n    float32x2_t max2 = vpmax_f32(vget_low_f32(max_vec), vget_high_f32(max_vec));\n    max2 = vpmax_f32(max2, max2);\n    return vget_lane_f32(max2, 0);\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdlib.h>\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n\n    // Calculate the number of multiples\n    int count11 = (n - 1) / 11 + 1;\n    int count13 = (n - 1) / 13 + 1;\n    int count143 = (n - 1) / 143 + 1;\n    int total_count = count11 + count13 - count143;\n\n    if (total_count == 0) return 0;\n\n    // Allocate memory for the multiples\n    unsigned *multiples = (unsigned *)malloc(total_count * sizeof(unsigned));\n    if (!multiples) return 0;\n\n    // Generate multiples of 11 or 13\n    int index = 0;\n    for (int i = 0; i < n; i += 11) {\n        multiples[index++] = i;\n    }\n    for (int i = 0; i < n; i += 13) {\n        if (i % 11 != 0) {\n            multiples[index++] = i;\n        }\n    }\n\n    // Pad to multiple of 4\n    int extra = (4 - total_count % 4) % 4;\n    int padded_count = total_count + extra;\n    unsigned *padded_arr = (unsigned *)malloc(padded_count * sizeof(unsigned));\n    if (!padded_arr) {\n        free(multiples);\n        return 0;\n    }\n    for (int i = 0; i < total_count; i++) {\n        padded_arr[i] = multiples[i];\n    }\n    for (int i = total_count; i < padded_count; i++) {\n        padded_arr[i] = 0; // Pad with zeros\n    }\n    free(multiples);\n\n    uint32x4_t total_count_vec = vdupq_n_u32(0);\n    for (int i = 0; i < padded_count; i += 4) {\n        // Load 4 numbers\n        uint32x4_t nums = vld1q_u32(padded_arr + i);\n        uint32_t scalar_counts[4] = {0};\n\n        // Extract each number and count digit '7' in scalar\n        uint32_t num_arr[4];\n        vst1q_u32(num_arr, nums);\n        for (int j = 0; j < 4; j++) {\n            unsigned num = num_arr[j];\n            while (num) {\n                if (num % 10 == 7) {\n                    scalar_counts[j]++;\n                }\n                num /= 10;\n            }\n        }\n\n        // Load counts into a vector and accumulate\n        uint32x4_t counts_vec = vld1q_u32(scalar_counts);\n        total_count_vec = vaddq_u32(total_count_vec, counts_vec);\n    }\n\n    // Sum the vector\n    uint32_t total_arr[4];\n    vst1q_u32(total_arr, total_count_vec);\n    unsigned total = 0;\n    for (int i = 0; i < 4; i++) {\n        total += total_arr[i];\n    }\n\n    free(padded_arr);\n    return total;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n\n    uint32_t count11 = 0;\n    int i = 0;\n    for (; i < n; i += 44) {\n        if (i + 33 >= n) break;\n        uint32_t candidates[4] = {(uint32_t)i, (uint32_t)(i + 11), (uint32_t)(i + 22), (uint32_t)(i + 33)};\n        uint32x4_t vec = vld1q_u32(candidates);\n        uint32x4_t count7_vec = vdupq_n_u32(0);\n        uint32x4_t current = vec;\n\n        for (int j = 0; j < 10; j++) {\n            if (vmaxvq_u32(current) == 0) break;\n\n            uint32x2_t low = vget_low_u32(current);\n            uint32x2_t high = vget_high_u32(current);\n            uint32x2_t magic = vdup_n_u32(0xCCCCCCCD);\n            uint64x2_t plow = vmull_u32(low, magic);\n            uint64x2_t phigh = vmull_u32(high, magic);\n            uint64x2_t shifted_low = vshrq_n_u64(plow, 35);\n            uint64x2_t shifted_high = vshrq_n_u64(phigh, 35);\n            uint32x2_t q_low = vmovn_u64(shifted_low);\n            uint32x2_t q_high = vmovn_u64(shifted_high);\n            uint32x4_t quotient = vcombine_u32(q_low, q_high);\n            uint32x4_t digit = vsubq_u32(current, vmulq_u32(quotient, vdupq_n_u32(10)));\n            uint32x4_t is_seven = vceqq_u32(digit, vdupq_n_u32(7));\n            is_seven = vshrq_n_u32(is_seven, 31);\n            count7_vec = vaddq_u32(count7_vec, is_seven);\n            current = quotient;\n        }\n\n        uint32_t tmp[4];\n        vst1q_u32(tmp, count7_vec);\n        count11 += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n    for (; i < n; i += 11) {\n        int x = i;\n        while (x) {\n            if (x % 10 == 7) count11++;\n            x /= 10;\n        }\n    }\n\n    uint32_t count13 = 0;\n    i = 0;\n    for (; i < n; i += 52) {\n        if (i + 39 >= n) break;\n        uint32_t candidates[4] = {(uint32_t)i, (uint32_t)(i + 13), (uint32_t)(i + 26), (uint32_t)(i + 39)};\n        uint32x4_t vec = vld1q_u32(candidates);\n        uint32x4_t count7_vec = vdupq_n_u32(0);\n        uint32x4_t current = vec;\n\n        for (int j = 0; j < 10; j++) {\n            if (vmaxvq_u32(current) == 0) break;\n\n            uint32x2_t low = vget_low_u32(current);\n            uint32x2_t high = vget_high_u32(current);\n            uint32x2_t magic = vdup_n_u32(0xCCCCCCCD);\n            uint64x2_t plow = vmull_u32(low, magic);\n            uint64x2_t phigh = vmull_u32(high, magic);\n            uint64x2_t shifted_low = vshrq_n_u64(plow, 35);\n            uint64x2_t shifted_high = vshrq_n_u64(phigh, 35);\n            uint32x2_t q_low = vmovn_u64(shifted_low);\n            uint32x2_t q_high = vmovn_u64(shifted_high);\n            uint32x4_t quotient = vcombine_u32(q_low, q_high);\n            uint32x4_t digit = vsubq_u32(current, vmulq_u32(quotient, vdupq_n_u32(10)));\n            uint32x4_t is_seven = vceqq_u32(digit, vdupq_n_u32(7));\n            is_seven = vshrq_n_u32(is_seven, 31);\n            count7_vec = vaddq_u32(count7_vec, is_seven);\n            current = quotient;\n        }\n\n        uint32_t tmp[4];\n        vst1q_u32(tmp, count7_vec);\n        count13 += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n    for (; i < n; i += 13) {\n        int x = i;\n        while (x) {\n            if (x % 10 == 7) count13++;\n            x /= 10;\n        }\n    }\n\n    uint32_t count143 = 0;\n    i = 0;\n    for (; i < n; i += 572) {\n        if (i + 429 >= n) break;\n        uint32_t candidates[4] = {(uint32_t)i, (uint32_t)(i + 143), (uint32_t)(i + 286), (uint32_t)(i + 429)};\n        uint32x4_t vec = vld1q_u32(candidates);\n        uint32x4_t count7_vec = vdupq_n_u32(0);\n        uint32x4_t current = vec;\n\n        for (int j = 0; j < 10; j++) {\n            if (vmaxvq_u32(current) == 0) break;\n\n            uint32x2_t low = vget_low_u32(current);\n            uint32x2_t high = vget_high_u32(current);\n            uint32x2_t magic = vdup_n_u32(0xCCCCCCCD);\n            uint64x2_t plow = vmull_u32(low, magic);\n            uint64x2_t phigh = vmull_u32(high, magic);\n            uint64x2_t shifted_low = vshrq_n_u64(plow, 35);\n            uint64x2_t shifted_high = vshrq_n_u64(phigh, 35);\n            uint32x2_t q_low = vmovn_u64(shifted_low);\n            uint32x2_t q_high = vmovn_u64(shifted_high);\n            uint32x4_t quotient = vcombine_u32(q_low, q_high);\n            uint32x4_t digit = vsubq_u32(current, vmulq_u32(quotient, vdupq_n_u32(10)));\n            uint32x4_t is_seven = vceqq_u32(digit, vdupq_n_u32(7));\n            is_seven = vshrq_n_u32(is_seven, 31);\n            count7_vec = vaddq_u32(count7_vec, is_seven);\n            current = quotient;\n        }\n\n        uint32_t tmp[4];\n        vst1q_u32(tmp, count7_vec);\n        count143 += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n    for (; i < n; i += 143) {\n        int x = i;\n        while (x) {\n            if (x % 10 == 7) count143++;\n            x /= 10;\n        }\n    }\n\n    return count11 + count13 - count143;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n    \n    static const uint32_t inc_arr[4] __attribute__((aligned(16))) = {0, 1, 2, 3};\n    const uint32x4_t inc_vec = vld1q_u32(inc_arr);\n    \n    uint32_t mod11 = 0;\n    uint32_t mod13 = 0;\n    int total = 0;\n    int i = 0;\n    \n    for (; i <= n - 4; i += 4) {\n        uint32x4_t base11 = vdupq_n_u32(mod11);\n        uint32x4_t base13 = vdupq_n_u32(mod13);\n        \n        uint32x4_t mod11_vec = vaddq_u32(base11, inc_vec);\n        uint32x4_t cmp11 = vcgeq_u32(mod11_vec, vdupq_n_u32(11));\n        mod11_vec = vsubq_u32(mod11_vec, vandq_u32(vdupq_n_u32(11), cmp11));\n        \n        uint32x4_t mod13_vec = vaddq_u32(base13, inc_vec);\n        uint32x4_t cmp13 = vcgeq_u32(mod13_vec, vdupq_n_u32(13));\n        mod13_vec = vsubq_u32(mod13_vec, vandq_u32(vdupq_n_u32(13), cmp13));\n        \n        uint32x4_t cond11 = vceqq_u32(mod11_vec, vdupq_n_u32(0));\n        uint32x4_t cond13 = vceqq_u32(mod13_vec, vdupq_n_u32(0));\n        uint32x4_t cond = vorrq_u32(cond11, cond13);\n        \n        uint32_t cond_arr[4];\n        vst1q_u32(cond_arr, cond);\n        \n        mod11 += 4;\n        if (mod11 >= 11) mod11 -= 11;\n        mod13 += 4;\n        if (mod13 >= 13) mod13 -= 13;\n        \n        for (int j = 0; j < 4; j++) {\n            if (cond_arr[j]) {\n                int num = i + j;\n                int t = num;\n                int count = 0;\n                while (t) {\n                    if (t % 10 == 7) count++;\n                    t /= 10;\n                }\n                total += count;\n            }\n        }\n    }\n    \n    for (; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int t = i;\n            int count = 0;\n            while (t) {\n                if (t % 10 == 7) count++;\n                t /= 10;\n            }\n            total += count;\n        }\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nstatic inline uint32x4_t div_by_constant(uint32x4_t v, uint32_t magic, uint32_t total_shift) {\n    uint32x2_t v_low = vget_low_u32(v);\n    uint32x2_t v_high = vget_high_u32(v);\n    uint32x2_t magic_vec = vdup_n_u32(magic);\n    uint64x2_t mul_low = vmull_u32(v_low, magic_vec);\n    uint64x2_t mul_high = vmull_u32(v_high, magic_vec);\n    mul_low = vshrq_n_u64(mul_low, total_shift);\n    mul_high = vshrq_n_u64(mul_high, total_shift);\n    uint32x2_t res_low = vmovn_u64(mul_low);\n    uint32x2_t res_high = vmovn_u64(mul_high);\n    return vcombine_u32(res_low, res_high);\n}\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n    uint32_t total_count = 0;\n    uint32_t un = (uint32_t)n;\n\n    for (uint32_t base = 0; base < un; base += 4) {\n        uint32_t arr[4] = {base, base+1, base+2, base+3};\n        uint32x4_t v = vld1q_u32(arr);\n        uint32x4_t nvec = vdupq_n_u32(un);\n        uint32x4_t active = vcltq_u32(v, nvec);\n\n        uint32x4_t q11 = div_by_constant(v, 0xBA2E8BA3, 35);\n        uint32x4_t rem11 = vsubq_u32(v, vmulq_n_u32(q11, 11));\n        uint32x4_t div11 = vceqq_u32(rem11, vdupq_n_u32(0));\n\n        uint32x4_t q13 = div_by_constant(v, 0x4EC4EC4F, 34);\n        uint32x4_t rem13 = vsubq_u32(v, vmulq_n_u32(q13, 13));\n        uint32x4_t div13 = vceqq_u32(rem13, vdupq_n_u32(0));\n\n        uint32x4_t valid = vorrq_u32(div11, div13);\n        valid = vandq_u32(valid, active);\n\n        if (vmaxvq_u32(valid) == 0) {\n            continue;\n        }\n\n        uint32x4_t digit_count = vdupq_n_u32(0);\n        uint32x4_t current = v;\n\n        for (int i = 0; i < 10; i++) {\n            if (vmaxvq_u32(current) == 0) {\n                break;\n            }\n\n            uint32x4_t q10 = div_by_constant(current, 0xCCCCCCCD, 35);\n            uint32x4_t r10 = vsubq_u32(current, vmulq_n_u32(q10, 10));\n            uint32x4_t is_seven = vceqq_u32(r10, vdupq_n_u32(7));\n            is_seven = vandq_u32(is_seven, vdupq_n_u32(1));\n            is_seven = vandq_u32(is_seven, valid);\n            digit_count = vaddq_u32(digit_count, is_seven);\n            current = q10;\n        }\n\n        uint32_t tmp[4];\n        vst1q_u32(tmp, digit_count);\n        total_count += tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_80_Neon", "completion": "```c\n#include <arm_neon.h>\n\nstatic inline uint32x4_t count_digit7_vec(uint32x4_t v) {\n    uint32x4_t vcount = vdupq_n_u32(0);\n    uint32x4_t ten = vdupq_n_u32(10);\n    uint32x4_t magic = vdupq_n_u32(0xCCCCCCCD);\n    uint32x4_t seven = vdupq_n_u32(7);\n\n    for (int i = 0; i < 10; i++) {\n        uint32x2_t v_low = vget_low_u32(v);\n        uint32x2_t v_high = vget_high_u32(v);\n        \n        uint64x2_t mul_low = vmull_u32(v_low, vget_low_u32(magic));\n        uint64x2_t mul_high = vmull_u32(v_high, vget_high_u32(magic));\n        \n        uint64x2_t q_low = vshrq_n_u64(mul_low, 35);\n        uint64x2_t q_high = vshrq_n_u64(mul_high, 35);\n        \n        uint32x2_t q32_low = vmovn_u64(q_low);\n        uint32x2_t q32_high = vmovn_u64(q_high);\n        uint32x4_t q = vcombine_u32(q32_low, q32_high);\n        \n        uint32x4_t r = vmlsq_u32(v, q, ten);\n        uint32x4_t mask = vceqq_u32(r, seven);\n        uint32x4_t inc = vshrq_n_u32(mask, 31);\n        vcount = vaddq_u32(vcount, inc);\n        \n        v = q;\n    }\n    return vcount;\n}\n\nstatic uint32_t count_multiples(int base, int n) {\n    if (n <= 0) return 0;\n    uint32_t total = 0;\n    for (uint32_t k = 0; k * base < n; k += 4) {\n        uint32_t k0 = k;\n        uint32_t k1 = k + 1;\n        uint32_t k2 = k + 2;\n        uint32_t k3 = k + 3;\n        \n        uint32_t v0 = (k0 * base < n) ? (k0 * base) : 0;\n        uint32_t v1 = (k1 * base < n) ? (k1 * base) : 0;\n        uint32_t v2 = (k2 * base < n) ? (k2 * base) : 0;\n        uint32_t v3 = (k3 * base < n) ? (k3 * base) : 0;\n        \n        uint32x4_t v_vec = (uint32x4_t){v0, v1, v2, v3};\n        uint32x4_t cnt_vec = count_digit7_vec(v_vec);\n        \n        uint32x2_t low = vget_low_u32(cnt_vec);\n        uint32x2_t high = vget_high_u32(cnt_vec);\n        uint32x2_t sum2 = vadd_u32(low, high);\n        uint32x2_t sum_final = vpadd_u32(sum2, sum2);\n        total += vget_lane_u32(sum_final, 0);\n    }\n    return total;\n}\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n    uint32_t total_11 = count_multiples(11, n);\n    uint32_t total_13 = count_multiples(13, n);\n    uint32_t total_143 = count_multiples(143, n);\n    return total_11 + total_13 - total_143;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n == 0) return {};\n\n    int even_size = (n + 1) / 2;\n    int odd_size = n / 2;\n    std::vector<float> evens(even_size);\n    std::vector<float> odds(odd_size);\n    std::vector<float> result(n);\n\n    // Extract even and odd indices using NEON\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x2_t low = vget_low_f32(vec);\n        float32x2_t high = vget_high_f32(vec);\n        float32x2x2_t unzipped = vuzp_f32(low, high);\n        vst1_f32(&evens[i/2], unzipped.val[0]);\n        vst1_f32(&odds[i/2], unzipped.val[1]);\n    }\n    // Handle remaining elements\n    for (int j = i; j < n; j++) {\n        if (j % 2 == 0) {\n            evens[j/2] = l[j];\n        } else {\n            odds[j/2] = l[j];\n        }\n    }\n\n    // Sort even indices\n    std::sort(evens.begin(), evens.end());\n\n    // Interleave sorted evens and original odds using NEON\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x2_t even_vec = vld1_f32(&evens[i/2]);\n        float32x2_t odd_vec = vld1_f32(&odds[i/2]);\n        float32x2x2_t zipped = vzip_f32(even_vec, odd_vec);\n        float32x4_t combined = vcombine_f32(zipped.val[0], zipped.val[1]);\n        vst1q_f32(&result[i], combined);\n    }\n    // Handle remaining elements\n    for (int j = i; j < n; j++) {\n        if (j % 2 == 0) {\n            result[j] = evens[j/2];\n        } else {\n            result[j] = odds[j/2];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n == 0) {\n        return l;\n    }\n\n    std::vector<float> even, odd;\n    even.reserve((n + 1) / 2);\n    odd.reserve(n / 2);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        float32x2x2_t data = vld2_f32(&l[i]);\n        float even_tmp[2];\n        float odd_tmp[2];\n        vst1_f32(even_tmp, data.val[0]);\n        vst1_f32(odd_tmp, data.val[1]);\n        even.push_back(even_tmp[0]);\n        even.push_back(even_tmp[1]);\n        odd.push_back(odd_tmp[0]);\n        odd.push_back(odd_tmp[1]);\n    }\n\n    for (; i < n; ++i) {\n        if (i % 2 == 0) {\n            even.push_back(l[i]);\n        } else {\n            odd.push_back(l[i]);\n        }\n    }\n\n    std::sort(even.begin(), even.end());\n\n    std::vector<float> result(n);\n    int even_index = 0;\n    int odd_index = 0;\n    int j = 0;\n\n    for (; j <= n - 4; j += 4) {\n        float32x2_t even_part = vld1_f32(&even[even_index]);\n        float32x2_t odd_part = vld1_f32(&odd[odd_index]);\n        even_index += 2;\n        odd_index += 2;\n\n        float32x2x2_t to_store;\n        to_store.val[0] = even_part;\n        to_store.val[1] = odd_part;\n        vst2_f32(&result[j], to_store);\n    }\n\n    for (; j < n; ++j) {\n        if (j % 2 == 0) {\n            result[j] = even[even_index++];\n        } else {\n            result[j] = odd[odd_index++];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    if (l.empty()) \n        return l;\n\n    std::vector<float> result(l.size());\n    float* in = l.data();\n    float* out = result.data();\n    size_t i = 0;\n\n    for (; i + 4 <= l.size(); i += 4) {\n        float32x4_t vec = vld1q_f32(in + i);\n        float32x2_t low = vget_low_f32(vec);\n        float32x2_t high = vget_high_f32(vec);\n        float32x2x2_t deinter = vuzp_f32(low, high);\n        float32x2_t rev = vrev64_f32(deinter.val[0]);\n        float32x2_t min_val = vmin_f32(deinter.val[0], rev);\n        float32x2_t max_val = vmax_f32(deinter.val[0], rev);\n        float32x2_t sorted_even = vset_lane_f32(vget_lane_f32(max_val, 0), min_val, 1);\n        float32x2x2_t inter = vzip_f32(sorted_even, deinter.val[1]);\n        float32x4_t res = vcombine_f32(inter.val[0], inter.val[1]);\n        vst1q_f32(out + i, res);\n    }\n\n    size_t rem = l.size() - i;\n    if (rem == 1) {\n        out[i] = in[i];\n    } else if (rem == 2) {\n        out[i] = in[i];\n        out[i+1] = in[i+1];\n    } else if (rem == 3) {\n        out[i] = in[i] < in[i+2] ? in[i] : in[i+2];\n        out[i+2] = in[i] < in[i+2] ? in[i+2] : in[i];\n        out[i+1] = in[i+1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    if (n == 0) {\n        return l;\n    }\n\n    int even_size = (n + 1) / 2;\n    int odd_size = n / 2;\n    std::vector<float> even_arr(even_size);\n    std::vector<float> odd_arr(odd_size);\n\n    int i = 0;\n    int even_index = 0;\n    int odd_index = 0;\n    for (; i <= n - 8; i += 8) {\n        float32x4_t vec1 = vld1q_f32(&l[i]);\n        float32x4_t vec2 = vld1q_f32(&l[i+4]);\n        float32x4x2_t deinter = vuzpq_f32(vec1, vec2);\n        vst1q_f32(&even_arr[even_index], deinter.val[0]);\n        even_index += 4;\n        vst1q_f32(&odd_arr[odd_index], deinter.val[1]);\n        odd_index += 4;\n    }\n\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            even_arr[even_index++] = l[i];\n        } else {\n            odd_arr[odd_index++] = l[i];\n        }\n    }\n\n    std::sort(even_arr.begin(), even_arr.end());\n\n    std::vector<float> result(n);\n    i = 0;\n    int j = 0;\n\n    for (; j <= odd_size - 4; j += 4) {\n        float32x4_t even_part = vld1q_f32(&even_arr[j]);\n        float32x4_t odd_part = vld1q_f32(&odd_arr[j]);\n        float32x4x2_t inter = vzipq_f32(even_part, odd_part);\n        vst1q_f32(&result[i], inter.val[0]);\n        i += 4;\n        vst1q_f32(&result[i], inter.val[1]);\n        i += 4;\n    }\n\n    if (j <= odd_size - 2) {\n        float32x2_t even2 = vld1_f32(&even_arr[j]);\n        float32x2_t odd2 = vld1_f32(&odd_arr[j]);\n        float32x2x2_t inter2 = vzip_f32(even2, odd2);\n        vst1_f32(&result[i], inter2.val[0]);\n        i += 2;\n        vst1_f32(&result[i], inter2.val[1]);\n        i += 2;\n        j += 2;\n    }\n\n    if (j < odd_size) {\n        result[i++] = even_arr[j];\n        result[i++] = odd_arr[j];\n        j++;\n    }\n\n    if (j < even_size) {\n        result[i] = even_arr[j];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_Neon", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    int even_count = (n + 1) / 2;\n    int odd_count = n / 2;\n    std::vector<float> even_arr(even_count);\n    std::vector<float> odd_arr(odd_count);\n\n    int even_index = 0;\n    int odd_index = 0;\n    int i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&l[i]);\n        float32x2_t low = vget_low_f32(vec);\n        float32x2_t high = vget_high_f32(vec);\n        float32x2x2_t transposed = vtrn_f32(low, high);\n        vst1_f32(&even_arr[even_index], transposed.val[0]);\n        vst1_f32(&odd_arr[odd_index], transposed.val[1]);\n        even_index += 2;\n        odd_index += 2;\n    }\n\n    for (int j = i; j < n; j++) {\n        if (j % 2 == 0) {\n            even_arr[even_index++] = l[j];\n        } else {\n            odd_arr[odd_index++] = l[j];\n        }\n    }\n\n    std::sort(even_arr.begin(), even_arr.end());\n\n    std::vector<float> result(n);\n    int j = 0;\n\n    for (; j + 1 < odd_count; j += 2) {\n        float32x2_t evens = vld1_f32(&even_arr[j]);\n        float32x2_t odds = vld1_f32(&odd_arr[j]);\n        float32x2x2_t zipped = vzip_f32(evens, odds);\n        float32x4_t res = vcombine_f32(zipped.val[0], zipped.val[1]);\n        vst1q_f32(&result[2 * j], res);\n    }\n\n    if (j < odd_count) {\n        result[2 * j] = even_arr[j];\n        result[2 * j + 1] = odd_arr[j];\n    }\n\n    if (even_count > odd_count) {\n        result[2 * odd_count] = even_arr[odd_count];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) \n        return false;\n    \n    std::sort(l.begin(), l.end());\n    \n    for (int i = 0; i < n - 2; i++) {\n        int j = i + 1;\n        int k = n - 1;\n        while (j < k) {\n            if (j + 3 < k) {\n                int32x4_t j_vec = vld1q_s32(&l[j]);\n                int32x4_t i_vec = vdupq_n_s32(l[i]);\n                int32x4_t k_vec = vdupq_n_s32(l[k]);\n                int32x4_t sum_vec = vaddq_s32(i_vec, vaddq_s32(j_vec, k_vec));\n                \n                int step = 0;\n                for (; step < 4; step++) {\n                    int sum = vgetq_lane_s32(sum_vec, step);\n                    if (sum == 0) {\n                        return true;\n                    } else if (sum > 0) {\n                        break;\n                    }\n                }\n                j += step;\n                if (step < 4) {\n                    k--;\n                }\n            } else {\n                int sum = l[i] + l[j] + l[k];\n                if (sum == 0) {\n                    return true;\n                } else if (sum < 0) {\n                    j++;\n                } else {\n                    k--;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) \n        return false;\n    \n    std::sort(l.begin(), l.end());\n    \n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = - (l[i] + l[j]);\n            int base = j + 1;\n            int len = n - base;\n            int32x4_t target_vec = vdupq_n_s32(target);\n            int offset = 0;\n            \n            for (; offset + 4 <= len; offset += 4) {\n                int32x4_t chunk = vld1q_s32(&l[base + offset]);\n                uint32x4_t cmp = vceqq_s32(chunk, target_vec);\n                if (vmaxvq_u32(cmp)) {\n                    return true;\n                }\n            }\n            \n            for (; offset < len; offset++) {\n                if (l[base + offset] == target) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = -(l[i] + l[j]);\n            if (l[j + 1] > target) break;\n            if (l[n - 1] < target) break;\n            int k = j + 1;\n            int end_index = n;\n            int32x4_t target_vec = vdupq_n_s32(target);\n            for (; k <= end_index - 4; k += 4) {\n                int32x4_t chunk = vld1q_s32(&l[k]);\n                uint32x4_t cmp = vceqq_s32(chunk, target_vec);\n                if (vmaxvq_u32(cmp)) return true;\n            }\n            for (; k < end_index; k++) {\n                if (l[k] == target) return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <algorithm>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    std::sort(l.begin(), l.end());\n    \n    for (int i = 0; i < n - 2; i++) {\n        int target = -l[i];\n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            if (left + 4 <= right) {\n                int32x4_t left_vec = vld1q_s32(&l[left]);\n                int32x4_t sum_vec = vaddq_s32(left_vec, vdupq_n_s32(l[right]));\n                int32x4_t target_vec = vdupq_n_s32(target);\n                \n                uint32x4_t eq_mask = vceqq_s32(sum_vec, target_vec);\n                if (vmaxvq_u32(eq_mask) != 0) \n                    return true;\n                \n                uint32x4_t lt_mask = vcltq_s32(sum_vec, target_vec);\n                if (vminvq_u32(lt_mask) == 0xFFFFFFFF) {\n                    left += 4;\n                } else {\n                    int sum = l[left] + l[right];\n                    if (sum == target) \n                        return true;\n                    else if (sum < target) \n                        left++;\n                    else \n                        right--;\n                }\n            } else {\n                int sum = l[left] + l[right];\n                if (sum == target) \n                    return true;\n                else if (sum < target) \n                    left++;\n                else \n                    right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_Neon", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_neon.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    std::sort(l.begin(), l.end());\n    \n    for (int i = 0; i < n - 2; i++) {\n        int target = -l[i];\n        int left = i + 1, right = n - 1;\n        \n        while (left < right) {\n            if (left + 3 < right) {\n                int32x4_t left_vec = vld1q_s32(&l[left]);\n                int32x4_t right_vec = vdupq_n_s32(l[right]);\n                int32x4_t sum_vec = vaddq_s32(left_vec, right_vec);\n                int32x4_t target_vec = vdupq_n_s32(target);\n                \n                uint32x4_t eq_mask = vceqq_s32(sum_vec, target_vec);\n                if (vmaxvq_u32(eq_mask)) {\n                    return true;\n                }\n                \n                uint32x4_t lt_mask = vcltq_s32(sum_vec, target_vec);\n                if (vminvq_u32(lt_mask) == 0xFFFFFFFF) {\n                    left += 4;\n                    continue;\n                }\n                \n                uint32x4_t gt_mask = vcgtq_s32(sum_vec, target_vec);\n                if (vminvq_u32(gt_mask) == 0xFFFFFFFF) {\n                    break;\n                }\n                \n                break;\n            }\n            \n            int sum = l[left] + l[right];\n            if (sum == target) {\n                return true;\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    int* in = l.data();\n    int* out = result.data();\n\n    const int32x4_t ones = vdupq_n_s32(1);\n    size_t i = 0;\n    for (; i + 3 < n; i += 4) {\n        int32x4_t data = vld1q_s32(in + i);\n        int32x4_t res = vaddq_s32(data, ones);\n        vst1q_s32(out + i, res);\n    }\n\n    for (; i < n; i++) {\n        out[i] = in[i] + 1;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    size_t i = 0;\n    int32_t* in = l.data();\n    int32_t* out = result.data();\n    \n    const int32x4_t ones = vdupq_n_s32(1);\n    for (; i + 3 < n; i += 4) {\n        int32x4_t data = vld1q_s32(in + i);\n        int32x4_t sum = vaddq_s32(data, ones);\n        vst1q_s32(out + i, sum);\n    }\n    \n    for (; i < n; ++i) {\n        out[i] = in[i] + 1;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int i = 0;\n    int32_t* data = l.data();\n    int chunk = size / 4;\n\n    for (; i < chunk * 4; i += 4) {\n        int32x4_t vec = vld1q_s32(data + i);\n        vec = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(data + i, vec);\n    }\n\n    for (; i < size; i++) {\n        data[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    size_t i = 0;\n    int32x4_t one = vdupq_n_s32(1);\n\n    for (; i + 3 < n; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        int32x4_t result = vaddq_s32(data, one);\n        vst1q_s32(&l[i], result);\n    }\n\n    for (; i < n; i++) {\n        l[i] += 1;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_83_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    int size = l.size();\n    int i = 0;\n    int* data = l.data();\n    \n    // Process 4 elements at a time\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(data + i);\n        int32x4_t result = vaddq_s32(vec, vdupq_n_s32(1));\n        vst1q_s32(data + i, result);\n    }\n    \n    // Process remaining elements\n    for (; i < size; i++) {\n        data[i] += 1;\n    }\n    \n    return l;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) {\n        return false;\n    }\n\n    int count_zero = 0;\n    uint32x4_t zero_count_vec = vdupq_n_u32(0);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(&l[i]);\n        uint32x4_t mask = vceqq_s32(chunk, zero_vec);\n        zero_count_vec = vaddq_u32(zero_count_vec, mask);\n    }\n    uint32_t zero_count_arr[4];\n    vst1q_u32(zero_count_arr, zero_count_vec);\n    count_zero = zero_count_arr[0] + zero_count_arr[1] + zero_count_arr[2] + zero_count_arr[3];\n    for (; i < n; i++) {\n        if (l[i] == 0) {\n            count_zero++;\n        }\n    }\n    if (count_zero >= 2) {\n        return true;\n    }\n\n    for (i = 0; i < n; i++) {\n        int a = l[i];\n        if (a == 0) {\n            continue;\n        }\n        int32x4_t neg_a_vec = vdupq_n_s32(-a);\n        int j = 0;\n        for (; j <= n - 4; j += 4) {\n            int32x4_t chunk = vld1q_s32(&l[j]);\n            uint32x4_t mask = vceqq_s32(chunk, neg_a_vec);\n            uint32_t mask_arr[4];\n            vst1q_u32(mask_arr, mask);\n            for (int k = 0; k < 4; k++) {\n                if (mask_arr[k] != 0) {\n                    int index = j + k;\n                    if (index != i) {\n                        return true;\n                    }\n                }\n            }\n        }\n        for (; j < n; j++) {\n            if (l[j] == -a && j != i) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) {\n        return false;\n    }\n\n    for (int i = 0; i < n; i++) {\n        int x = l[i];\n        int neg_x = -x;\n\n        int j = 0;\n        for (; j <= n - 4; j += 4) {\n            int32x4_t chunk = vld1q_s32(&l[j]);\n            int32x4_t negx_vec = vdupq_n_s32(neg_x);\n            uint32x4_t cmp = vceqq_s32(chunk, negx_vec);\n\n            uint32_t cmp0 = vgetq_lane_u32(cmp, 0);\n            uint32_t cmp1 = vgetq_lane_u32(cmp, 1);\n            uint32_t cmp2 = vgetq_lane_u32(cmp, 2);\n            uint32_t cmp3 = vgetq_lane_u32(cmp, 3);\n\n            if ((cmp0 && (j + 0 != i)) ||\n                (cmp1 && (j + 1 != i)) ||\n                (cmp2 && (j + 2 != i)) ||\n                (cmp3 && (j + 3 != i))) {\n                return true;\n            }\n        }\n\n        for (; j < n; j++) {\n            if (j == i) continue;\n            if (l[j] == neg_x) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) \n        return false;\n\n    for (size_t i = 0; i < n-1; i++) {\n        int32_t a = l[i];\n        int32x4_t a_vec = vdupq_n_s32(a);\n\n        size_t j = i+1;\n        for (; j + 3 < n; j += 4) {\n            int32x4_t chunk = vld1q_s32(&l[j]);\n            int32x4_t sum = vaddq_s32(a_vec, chunk);\n            uint32x4_t cmp = vceqq_s32(sum, vdupq_n_s32(0));\n            uint32x2_t low_cmp = vget_low_u32(cmp);\n            uint32x2_t high_cmp = vget_high_u32(cmp);\n            uint32x2_t or_result = vorr_u32(low_cmp, high_cmp);\n            uint32_t or_lane0 = vget_lane_u32(or_result, 0);\n            uint32_t or_lane1 = vget_lane_u32(or_result, 1);\n            if (or_lane0 || or_lane1) {\n                return true;\n            }\n        }\n\n        for (; j < n; j++) {\n            if (a + l[j] == 0) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) \n        return false;\n    \n    int32_t* data = l.data();\n    \n    for (int i = 0; i < n; i++) {\n        int target = -data[i];\n        int32x4_t target_vec = vdupq_n_s32(target);\n        int found = 0;\n        int j = 0;\n        \n        for (; j <= n - 4; j += 4) {\n            int32x4_t chunk = vld1q_s32(data + j);\n            uint32x4_t cmp = vceqq_s32(chunk, target_vec);\n            \n            uint32_t cmp0 = vgetq_lane_u32(cmp, 0);\n            uint32_t cmp1 = vgetq_lane_u32(cmp, 1);\n            uint32_t cmp2 = vgetq_lane_u32(cmp, 2);\n            uint32_t cmp3 = vgetq_lane_u32(cmp, 3);\n            \n            if (cmp0 && j != i) {\n                found = 1;\n                break;\n            }\n            if (cmp1 && j + 1 != i) {\n                found = 1;\n                break;\n            }\n            if (cmp2 && j + 2 != i) {\n                found = 1;\n                break;\n            }\n            if (cmp3 && j + 3 != i) {\n                found = 1;\n                break;\n            }\n        }\n        \n        if (found) \n            return true;\n        \n        for (; j < n; j++) {\n            if (data[j] == target && j != i) \n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) {\n        return false;\n    }\n\n    uint32_t zero_count = 0;\n    int j = 0;\n    for (; j <= n - 4; j += 4) {\n        int32x4_t chunk = vld1q_s32(&l[j]);\n        uint32x4_t cmp = vceqq_s32(chunk, vdupq_n_s32(0));\n        uint32x4_t ones = vandq_u32(cmp, vdupq_n_u32(1));\n        zero_count += vaddvq_u32(ones);\n    }\n    for (; j < n; j++) {\n        if (l[j] == 0) {\n            zero_count++;\n        }\n    }\n    if (zero_count >= 2) {\n        return true;\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (l[i] == 0) {\n            continue;\n        }\n        int32_t neg = -l[i];\n        j = 0;\n        bool found = false;\n        for (; j <= n - 4; j += 4) {\n            int32x4_t data = vld1q_s32(&l[j]);\n            uint32x4_t cmp = vceqq_s32(vdupq_n_s32(neg), data);\n            if (vmaxvq_u32(cmp) != 0) {\n                found = true;\n                break;\n            }\n        }\n        if (found) {\n            return true;\n        }\n        for (; j < n; j++) {\n            if (l[j] == neg) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    int base2 = base * base;\n    int base3 = base2 * base;\n    int base4 = base3 * base;\n\n    std::vector<uint16_t> groups;\n    while (x > 0) {\n        groups.push_back(static_cast<uint16_t>(x % base4));\n        x = x / base4;\n    }\n    std::reverse(groups.begin(), groups.end());\n\n    std::string res;\n    for (int i = 0; i < groups.size(); i++) {\n        uint16_t g = groups[i];\n        uint8_t d0 = static_cast<uint8_t>(g / base3);\n        uint16_t r0 = g % base3;\n        uint8_t d1 = static_cast<uint8_t>(r0 / base2);\n        uint16_t r1 = r0 % base2;\n        uint8_t d2 = static_cast<uint8_t>(r1 / base);\n        uint8_t d3 = static_cast<uint8_t>(r1 % base);\n\n        uint64_t packed_digits = static_cast<uint64_t>(d0) | \n                                (static_cast<uint64_t>(d1) << 8 | \n                                (static_cast<uint64_t>(d2) << 16 | \n                                (static_cast<uint64_t>(d3) << 24;\n\n        uint8x8_t digit_vec = vcreate_u8(packed_digits);\n        uint8x8_t ascii_vec = vadd_u8(digit_vec, vdup_n_u8('0'));\n        uint8_t ascii_arr[8];\n        vst1_u8(ascii_arr, ascii_vec);\n\n        if (i == 0) {\n            uint8_t digits_arr[4] = {d0, d1, d2, d3};\n            int j = 0;\n            while (j < 4 && digits_arr[j] == 0) {\n                j++;\n            }\n            if (j < 4) {\n                for (int k = j; k < 4; k++) {\n                    res += ascii_arr[k];\n                }\n            }\n        } else {\n            res.append(reinterpret_cast<char*>(ascii_arr), 4);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    int d = 0;\n    int64_t tmp = x;\n    while (tmp) {\n        d++;\n        tmp /= base;\n    }\n\n    uint8_t *arr = new uint8_t[d];\n    tmp = x;\n    for (int i = 0; i < d; i++) {\n        arr[i] = tmp % base;\n        tmp /= base;\n    }\n\n    int i = 0;\n    int j = d - 1;\n    while (j - i >= 31) {\n        uint8x16_t A = vld1q_u8(arr + i);\n        uint8x16_t B = vld1q_u8(arr + j - 15);\n\n        uint8x16_t revA = vrev64q_u8(A);\n        revA = vcombine_u8(vget_high_u8(revA), vget_low_u8(revA));\n        uint8x16_t revB = vrev64q_u8(B);\n        revB = vcombine_u8(vget_high_u8(revB), vget_low_u8(revB));\n\n        vst1q_u8(arr + i, revB);\n        vst1q_u8(arr + j - 15, revA);\n\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        uint8_t t = arr[i];\n        arr[i] = arr[j];\n        arr[j] = t;\n        i++;\n        j--;\n    }\n\n    std::string s(d, '0');\n    i = 0;\n    for (; i <= d - 16; i += 16) {\n        uint8x16_t digits = vld1q_u8(arr + i);\n        uint8x16_t chars = vaddq_u8(digits, vdupq_n_u8('0'));\n        vst1q_u8(reinterpret_cast<uint8_t*>(&s[i]), chars);\n    }\n    for (; i < d; i++) {\n        s[i] = arr[i] + '0';\n    }\n\n    delete[] arr;\n    return s;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <arm_neon.h>\n\nstd::string change_base_simd(int64_t x, int8_t base){\n    if (x == 0) {\n        return \"0\";\n    }\n    uint32_t b = static_cast<uint32_t>(base);\n    uint32_t divisor = b * b * b * b;\n    std::vector<uint8_t> digits;\n    uint64_t x_abs = static_cast<uint64_t>(x);\n    while (x_abs) {\n        uint32_t chunk = x_abs % divisor;\n        x_abs = x_abs / divisor;\n        uint32_t powers_arr[4] = {1, b, b*b, b*b*b};\n        uint32x4_t powers = vld1q_u32(powers_arr);\n        uint32x4_t v = vdupq_n_u32(chunk);\n        float32x4_t vf = vcvtq_f32_u32(v);\n        float32x4_t pf = vcvtq_f32_u32(powers);\n        float32x4_t quotf = vdivq_f32(vf, pf);\n        uint32x4_t n_i = vcvtq_u32_f32(quotf);\n        float32x4_t n_i_f = vcvtq_f32_u32(n_i);\n        float32x4_t basef = vdupq_n_f32(static_cast<float>(b));\n        float32x4_t quot_base_f = vdivq_f32(n_i_f, basef);\n        uint32x4_t quot_base_i = vcvtq_u32_f32(quot_base_f);\n        uint32x4_t product = vmulq_u32(quot_base_i, vdupq_n_u32(b));\n        uint32x4_t rem = vsubq_u32(n_i, product);\n        uint32_t rem_arr[4];\n        vst1q_u32(rem_arr, rem);\n        for (int i = 0; i < 4; i++) {\n            digits.push_back(static_cast<uint8_t>(rem_arr[i]));\n        }\n    }\n    std::reverse(digits.begin(), digits.end());\n    size_t start = 0;\n    while (start < digits.size() && digits[start] == 0) {\n        start++;\n    }\n    if (start == digits.size()) {\n        return \"0\";\n    }\n    std::string res;\n    for (size_t i = start; i < digits.size(); i++) {\n        res += ('0' + digits[i]);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n#include <cstring>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    int base_val = static_cast<int>(base);\n    uint8_t digits[64];\n    int num_digits = 0;\n    int64_t temp = x;\n\n    while (temp) {\n        digits[num_digits++] = static_cast<uint8_t>(temp % base_val);\n        temp /= base_val;\n    }\n\n    char* str = new char[num_digits + 1];\n    const int vec_size = 16;\n    int j = 0;\n\n    while (j <= num_digits - vec_size) {\n        uint8x16_t vec = vld1q_u8(digits + (num_digits - 1 - j - (vec_size - 1)));\n        uint8x16_t rev = vrev64q_u8(vec);\n        rev = vextq_u8(rev, rev, 8);\n        uint8x16_t char_vec = vaddq_u8(rev, vdupq_n_u8('0'));\n        vst1q_u8(reinterpret_cast<uint8_t*>(str + j), char_vec);\n        j += vec_size;\n    }\n\n    for (; j < num_digits; ++j) {\n        str[j] = '0' + digits[num_digits - 1 - j];\n    }\n\n    str[num_digits] = '\\0';\n    std::string result(str);\n    delete[] str;\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    uint64_t num = static_cast<uint64_t>(x);\n    uint8_t digits[64];\n    int len = 0;\n    while (num) {\n        digits[len] = num % base;\n        num /= base;\n        len++;\n    }\n    char char_array[64];\n    int i = 0;\n    uint8x16_t v_zero = vdupq_n_u8('0');\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t v_digits = vld1q_u8(digits + i);\n        uint8x16_t v_chars = vaddq_u8(v_digits, v_zero);\n        vst1q_u8(reinterpret_cast<uint8_t*>(char_array + i), v_chars);\n    }\n    for (; i < len; i++) {\n        char_array[i] = '0' + digits[i];\n    }\n    char reversed_char_array[64];\n    int j = 0;\n    int pos = len;\n    while (pos > 0) {\n        if (pos >= 16) {\n            pos -= 16;\n            uint8x16_t v_chunk = vld1q_u8(reinterpret_cast<uint8_t*>(char_array + pos));\n            uint8x16_t v_rev64 = vrev64q_u8(v_chunk);\n            uint8x16_t v_rev128 = vextq_u8(v_rev64, v_rev64, 8);\n            vst1q_u8(reinterpret_cast<uint8_t*>(reversed_char_array + j), v_rev128);\n            j += 16;\n        } else {\n            for (int k = pos - 1; k >= 0; k--) {\n                reversed_char_array[j++] = char_array[k];\n            }\n            pos = 0;\n        }\n    }\n    return std::string(reversed_char_array, len);\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    const uint8_t* left = reinterpret_cast<const uint8_t*>(text.data());\n    const uint8_t* right = left + text.size() - 1;\n    \n    if (text.empty()) {\n        return true;\n    }\n\n    while (right - left >= 31) {\n        uint8x16_t left_chunk = vld1q_u8(left);\n        uint8x16_t right_chunk = vld1q_u8(right - 15);\n        \n        uint8x16_t rev_right = vrev64q_u8(right_chunk);\n        rev_right = vcombine_u8(vget_high_u8(rev_right), vget_low_u8(rev_right));\n        \n        uint8x16_t cmp = vceqq_u8(left_chunk, rev_right);\n        uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp);\n        uint64_t a0 = vgetq_lane_u64(cmp64, 0);\n        uint64_t a1 = vgetq_lane_u64(cmp64, 1);\n        \n        if (a0 != 0xFFFFFFFFFFFFFFFF || a1 != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        \n        left += 16;\n        right -= 16;\n    }\n    \n    while (left < right) {\n        if (*left != *right) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) {\n        return true;\n    }\n\n    size_t left = 0;\n    size_t right = text.length() - 1;\n    const int vec_size = 16;\n\n    while (left + vec_size - 1 <= right) {\n        uint8x16_t left_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + left));\n        uint8x16_t right_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + right - vec_size + 1));\n\n        uint8x16_t rev_right = vrev64q_u8(right_vec);\n        rev_right = vcombine_u8(vget_high_u8(rev_right), vget_low_u8(rev_right));\n\n        uint8x16_t cmp = vceqq_u8(left_vec, rev_right);\n\n        if (vminvq_u8(cmp) != 0xFF) {\n            return false;\n        }\n\n        left += vec_size;\n        right -= vec_size;\n    }\n\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    const char* data = text.data();\n    if (n == 0) \n        return true;\n\n    size_t i = 0;\n    size_t j = n - 1;\n\n    while (i + 31 <= j) {\n        uint8x16_t left_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + i));\n        uint8x16_t right_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(data + j - 15));\n        uint8x16_t rev_right = vrev64q_u8(right_vec);\n        rev_right = vcombine_u8(vget_high_u8(rev_right), vget_low_u8(rev_right));\n        uint8x16_t cmp = vceqq_u8(left_vec, rev_right);\n        uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp);\n        uint64_t lo = vgetq_lane_u64(cmp64, 0);\n        uint64_t hi = vgetq_lane_u64(cmp64, 1);\n        if (lo != 0xFFFFFFFFFFFFFFFF || hi != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        i += 16;\n        j -= 16;\n    }\n\n    while (i < j) {\n        if (data[i] != data[j]) \n            return false;\n        i++;\n        j--;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t n = text.size();\n    if (n == 0) {\n        return true;\n    }\n    size_t half = n / 2;\n    size_t i = 0;\n\n    for (; i + 16 <= half; i += 16) {\n        uint8x16_t left_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + i));\n        uint8x16_t right_vec = vld1q_u8(reinterpret_cast<const uint8_t*>(text.data() + n - i - 16));\n        \n        uint8x16_t right_reversed = vrev64q_u8(right_vec);\n        right_reversed = vcombine_u8(vget_high_u8(right_reversed), vget_low_u8(right_reversed));\n        \n        uint8x16_t cmp = vceqq_u8(left_vec, right_reversed);\n        if (vminvq_u8(cmp) != 0xFF) {\n            return false;\n        }\n    }\n\n    for (size_t j = i; j < half; j++) {\n        if (text[j] != text[n - j - 1]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) return true;\n    \n    const uint8_t* left_ptr = (const uint8_t*)text.c_str();\n    const uint8_t* right_ptr = left_ptr + len - 1;\n    size_t num_iterations = len / 32;\n    \n    for (size_t i = 0; i < num_iterations; i++) {\n        uint8x16_t left_chunk = vld1q_u8(left_ptr);\n        uint8x16_t right_chunk = vld1q_u8(right_ptr - 15);\n        \n        uint8x16_t rev_right = vrev64q_u8(right_chunk);\n        rev_right = vextq_u8(rev_right, rev_right, 8);\n        \n        uint8x16_t cmp_result = vceqq_u8(left_chunk, rev_right);\n        uint64x2_t cmp64 = vreinterpretq_u64_u8(cmp_result);\n        uint64_t mask_low = vgetq_lane_u64(cmp64, 0);\n        uint64_t mask_high = vgetq_lane_u64(cmp64, 1);\n        \n        if (mask_low != 0xFFFFFFFFFFFFFFFF || mask_high != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        \n        left_ptr += 16;\n        right_ptr -= 16;\n    }\n    \n    while (left_ptr < right_ptr) {\n        if (*left_ptr != *right_ptr) {\n            return false;\n        }\n        left_ptr++;\n        right_ptr--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    out.resize(s.length());\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&out[0]);\n    size_t len = s.length();\n    size_t i = 0;\n\n    const uint8x16_t base_vec = vdupq_n_u8('a');\n    const uint8x16_t twenty_one = vdupq_n_u8(21);\n    const uint8x16_t twenty_six = vdupq_n_u8(26);\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t vec = vld1q_u8(src + i);\n        uint8x16_t x = vsubq_u8(vec, base_vec);\n        uint8x16_t t = vaddq_u8(x, twenty_one);\n        uint8x16_t mask = vcgeq_u8(t, twenty_six);\n        uint8x16_t adjusted = vsubq_u8(t, vandq_u8(mask, twenty_six));\n        uint8x16_t decoded = vaddq_u8(adjusted, base_vec);\n        vst1q_u8(dst + i, decoded);\n    }\n\n    for (; i < len; ++i) {\n        uint8_t c = src[i];\n        uint8_t x = c - 'a';\n        uint8_t t = x + 21;\n        if (t >= 26) {\n            t -= 26;\n        }\n        dst[i] = t + 'a';\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    if (s.empty()) return s;\n    \n    std::string out;\n    out.resize(s.length());\n    size_t i = 0;\n    const uint8_t* src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* dst = reinterpret_cast<uint8_t*>(&out[0]);\n    \n    const uint8x16_t v_five = vdupq_n_u8(5);\n    const uint8x16_t v_a = vdupq_n_u8('a');\n    const uint8x16_t v_twenty_six = vdupq_n_u8(26);\n    \n    for (; i + 16 <= s.length(); i += 16) {\n        uint8x16_t v_src = vld1q_u8(src + i);\n        uint8x16_t v_sub = vsubq_u8(v_src, v_five);\n        uint8x16_t v_mask = vcltq_u8(v_sub, v_a);\n        uint8x16_t v_corr = vandq_u8(v_mask, v_twenty_six);\n        uint8x16_t v_result = vaddq_u8(v_sub, v_corr);\n        vst1q_u8(dst + i, v_result);\n    }\n    \n    for (; i < s.length(); ++i) {\n        uint8_t c = src[i];\n        c -= 5;\n        if (c < 'a') {\n            c += 26;\n        }\n        dst[i] = c;\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t n = s.length();\n    std::string out(n, '\\0');\n    const uint8_t* src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* dst = reinterpret_cast<uint8_t*>(&out[0]);\n    \n    size_t i = 0;\n    const size_t chunk = 16;\n    \n    for (; i + chunk <= n; i += chunk) {\n        uint8x16_t vec = vld1q_u8(src + i);\n        uint8x16_t base = vdupq_n_u8('a');\n        uint8x16_t offset = vdupq_n_u8(21);\n        uint8x16_t modulus = vdupq_n_u8(26);\n        \n        uint8x16_t shifted = vsubq_u8(vec, base);\n        uint8x16_t temp = vaddq_u8(shifted, offset);\n        uint8x16_t mask = vcgeq_u8(temp, modulus);\n        uint8x16_t adjust = vandq_u8(mask, modulus);\n        uint8x16_t adjusted = vsubq_u8(temp, adjust);\n        uint8x16_t result = vaddq_u8(adjusted, base);\n        \n        vst1q_u8(dst + i, result);\n    }\n    \n    for (; i < n; i++) {\n        uint8_t c = src[i];\n        uint8_t shifted = c - 'a';\n        uint8_t temp = shifted + 21;\n        if (temp >= 26) {\n            temp -= 26;\n        }\n        dst[i] = temp + 'a';\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    out.resize(s.length());\n    const uint8_t* src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* dst = reinterpret_cast<uint8_t*>(&out[0]);\n    size_t len = s.length();\n    size_t i = 0;\n\n    const uint8x16_t five_vec = vdupq_n_u8(5);\n    const uint8x16_t a_vec = vdupq_n_u8('a');\n    const uint8x16_t twenty_six_vec = vdupq_n_u8(26);\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        uint8x16_t sub5 = vsubq_u8(data, five_vec);\n        uint8x16_t mask = vcltq_u8(sub5, a_vec);\n        uint8x16_t adjust = vandq_u8(mask, twenty_six_vec);\n        uint8x16_t result = vaddq_u8(sub5, adjust);\n        vst1q_u8(dst + i, result);\n    }\n\n    for (; i < len; ++i) {\n        uint8_t c = src[i];\n        if (c - 5 < 'a') {\n            dst[i] = c - 5 + 26;\n        } else {\n            dst[i] = c - 5;\n        }\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    std::string out;\n    out.resize(s.length());\n    const uint8_t* src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t* dst = reinterpret_cast<uint8_t*>(&out[0]);\n    int n = s.length();\n    int i = 0;\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t vec = vld1q_u8(src + i);\n        uint8x16_t added = vaddq_u8(vec, vdupq_n_u8(21));\n        uint8x16_t cmp = vcgtq_u8(added, vdupq_n_u8('z'));\n        uint8x16_t sub_val = vandq_u8(vdupq_n_u8(26), cmp);\n        uint8x16_t result = vsubq_u8(added, sub_val);\n        vst1q_u8(dst + i, result);\n    }\n\n    for (; i < n; ++i) {\n        uint8_t c = src[i];\n        c += 21;\n        if (c > 'z') {\n            c -= 26;\n        }\n        dst[i] = c;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    if (n == 0) {\n        return true;\n    }\n    int i = 0;\n    int32x4_t thresh_vec = vdupq_n_s32(t);\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcgeq_s32(data, thresh_vec);\n        if (vgetq_lane_u32(cmp, 0) || vgetq_lane_u32(cmp, 1) || \n            vgetq_lane_u32(cmp, 2) || vgetq_lane_u32(cmp, 3)) {\n            return false;\n        }\n    }\n\n    for (; i < n; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t size = l.size();\n    if (size == 0) {\n        return true;\n    }\n\n    const int* data = l.data();\n    int32x4_t t_vec = vdupq_n_s32(t);\n    size_t i = 0;\n\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t chunk = vld1q_s32(data + i);\n        uint32x4_t cmp = vcltq_s32(chunk, t_vec);\n        uint32_t mask = vgetq_lane_u32(cmp, 0);\n        mask &= vgetq_lane_u32(cmp, 1);\n        mask &= vgetq_lane_u32(cmp, 2);\n        mask &= vgetq_lane_u32(cmp, 3);\n        if (mask != 0xFFFFFFFF) {\n            return false;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    if (n == 0) {\n        return true;\n    }\n    int i = 0;\n    int32x4_t t_vec = vdupq_n_s32(t);\n    \n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&l[i]);\n        uint32x4_t cmp = vcgeq_s32(data, t_vec);\n        uint64x2_t cmp64 = vreinterpretq_u64_u32(cmp);\n        uint64_t a = vgetq_lane_u64(cmp64, 0);\n        uint64_t b = vgetq_lane_u64(cmp64, 1);\n        if (a || b) {\n            return false;\n        }\n    }\n    \n    for (; i < n; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int i = 0;\n    \n    if (n >= 4) {\n        int32x4_t t_vec = vdupq_n_s32(t);\n        \n        for (; i <= n - 4; i += 4) {\n            int32x4_t data = vld1q_s32(&l[i]);\n            uint32x4_t cmp = vcgeq_s32(data, t_vec);\n            uint64x2_t cmp64 = vreinterpretq_u64_u32(cmp);\n            uint64_t a = vgetq_lane_u64(cmp64, 0);\n            uint64_t b = vgetq_lane_u64(cmp64, 1);\n            if (a | b) {\n                return false;\n            }\n        }\n    }\n    \n    for (; i < n; i++) {\n        if (l[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    const int n = l.size();\n    const int* data = l.data();\n    int i = 0;\n    \n    if (n == 0) {\n        return true;\n    }\n    \n    const int32x4_t threshold_vec = vdupq_n_s32(t);\n    \n    for (; i <= n - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(data + i);\n        uint32x4_t cmp = vcltq_s32(chunk, threshold_vec);\n        \n        uint32x2_t low = vget_low_u32(cmp);\n        uint32x2_t high = vget_high_u32(cmp);\n        uint32x2_t min_pair = vpmin_u32(low, high);\n        min_pair = vpmin_u32(min_pair, min_pair);\n        uint32_t min_val = vget_lane_u32(min_pair, 0);\n        \n        if (min_val != 0xFFFFFFFF) {\n            return false;\n        }\n    }\n    \n    for (; i < n; ++i) {\n        if (data[i] >= t) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    size_t i = 0;\n    const size_t n = brackets.size();\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(brackets.data());\n    constexpr int chunk_size = 16;\n    \n    while (i + chunk_size <= n) {\n        uint8x16_t input = vld1q_u8(data + i);\n        uint8x16_t mask_lt = vceqq_u8(input, vdupq_n_u8('<'));\n        uint8x16_t mask_gt = vceqq_u8(input, vdupq_n_u8('>'));\n        int8x16_t values = vreinterpretq_s8_u8(vsubq_u8(mask_gt, mask_lt));\n        \n        int8_t chunk_vals[chunk_size];\n        vst1q_s8(chunk_vals, values);\n        \n        for (int j = 0; j < chunk_size; j++) {\n            balance += chunk_vals[j];\n            if (balance < 0) {\n                return false;\n            }\n        }\n        i += chunk_size;\n    }\n    \n    for (; i < n; i++) {\n        balance += (brackets[i] == '<') ? 1 : -1;\n        if (balance < 0) {\n            return false;\n        }\n    }\n    \n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstring>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t n = brackets.length();\n    int balance = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        int chunk_size = std::min(16, (int)(n - i));\n        uint8_t buffer[16] = {0};\n        std::memcpy(buffer, brackets.data() + i, chunk_size);\n        uint8x16_t input = vld1q_u8(buffer);\n\n        uint8x16_t less_than = vceqq_u8(input, vdupq_n_u8('<'));\n        uint8x16_t greater_than = vceqq_u8(input, vdupq_n_u8('>'));\n\n        int8x16_t v = vsubq_s8(vreinterpretq_s8_u8(greater_than), vreinterpretq_s8_u8(less_than));\n\n        int8_t arr[16];\n        vst1q_s8(arr, v);\n\n        int8_t cum = 0;\n        int8_t min_cum = 0;\n        for (int j = 0; j < chunk_size; j++) {\n            cum += arr[j];\n            if (cum < min_cum) {\n                min_cum = cum;\n            }\n        }\n\n        if (balance + min_cum < 0) {\n            return false;\n        }\n        balance += cum;\n        i += chunk_size;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int min_balance = 0;\n    const char* ptr = brackets.data();\n    size_t len = brackets.size();\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(ptr + i));\n        uint8x16_t mask_lt = vceqq_u8(v, vdupq_n_u8('<'));\n        uint8x16_t mask_gt = vceqq_u8(v, vdupq_n_u8('>'));\n        int8x16_t values = vsubq_s8(vreinterpretq_s8_u8(mask_gt), vreinterpretq_s8_u8(mask_lt));\n\n        int8_t values_arr[16];\n        vst1q_s8(values_arr, values);\n\n        int current = balance;\n        int chunk_min = balance;\n        for (int j = 0; j < 16; ++j) {\n            current += values_arr[j];\n            if (current < chunk_min) {\n                chunk_min = current;\n            }\n        }\n\n        if (chunk_min < min_balance) {\n            min_balance = chunk_min;\n        }\n        balance = current;\n    }\n\n    for (; i < len; ++i) {\n        if (ptr[i] == '<') {\n            ++balance;\n        } else if (ptr[i] == '>') {\n            --balance;\n        }\n        if (balance < min_balance) {\n            min_balance = balance;\n        }\n    }\n\n    return (balance == 0 && min_balance >= 0);\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* ptr = brackets.c_str();\n    size_t n = brackets.size();\n    int global_sum = 0;\n    size_t i = 0;\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(ptr + i));\n        uint8x16_t mask_lt = vceqq_u8(v, vdupq_n_u8('<'));\n        uint8x16_t mask_gt = vceqq_u8(v, vdupq_n_u8('>'));\n        uint8x16_t one = vdupq_n_u8(1);\n        uint8x16_t part_lt = vandq_u8(mask_lt, one);\n        uint8x16_t part_gt = vandq_u8(mask_gt, one);\n        int8x16_t increments = vsubq_s8(vreinterpretq_s8_u8(part_lt), vreinterpretq_s8_u8(part_gt));\n\n        int16x8_t sum1 = vpaddlq_s8(increments);\n        int32x4_t sum2 = vpaddlq_s16(sum1);\n        int64x2_t sum3 = vpaddlq_s32(sum2);\n        int64_t total64 = vgetq_lane_s64(sum3, 0) + vgetq_lane_s64(sum3, 1);\n        int total_chunk = static_cast<int>(total64);\n\n        int8_t arr[16];\n        vst1q_s8(arr, increments);\n        int8_t s = 0;\n        int8_t min_val = 0;\n        for (int j = 0; j < 16; j++) {\n            s += arr[j];\n            if (s < min_val) min_val = s;\n        }\n\n        if (global_sum + min_val < 0) return false;\n        global_sum += total_chunk;\n    }\n\n    for (; i < n; i++) {\n        if (ptr[i] == '<') global_sum++;\n        else if (ptr[i] == '>') global_sum--;\n        if (global_sum < 0) return false;\n    }\n\n    return global_sum == 0;\n}\n```"}
{"task_id": "SimdBench_89_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.size();\n    int current_balance = 0;\n    size_t i = 0;\n\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(brackets.data());\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chars = vld1q_u8(data + i);\n        uint8x16_t mask_less = vceqq_u8(chars, vdupq_n_u8('<'));\n        uint8x16_t mask_greater = vceqq_u8(chars, vdupq_n_u8('>'));\n        uint8x16_t mask_diff = vsubq_u8(mask_less, mask_greater);\n        int8x16_t values = vreinterpretq_s8_u8(mask_diff);\n\n        int8x16_t t0 = values;\n        int8x16_t shifted1 = vextq_s8(vdupq_n_s8(0), t0, 15);\n        int8x16_t t1 = vaddq_s8(t0, shifted1);\n        int8x16_t shifted2 = vextq_s8(vdupq_n_s8(0), t1, 14);\n        int8x16_t t2 = vaddq_s8(t1, shifted2);\n        int8x16_t shifted4 = vextq_s8(vdupq_n_s8(0), t2, 12);\n        int8x16_t t3 = vaddq_s8(t2, shifted4);\n        int8x16_t shifted8 = vextq_s8(vdupq_n_s8(0), t3, 8);\n        int8x16_t t4 = vaddq_s8(t3, shifted8);\n\n        int8_t min_val = vminvq_s8(t4);\n        int8_t total_change = vgetq_lane_s8(t4, 15);\n\n        if (current_balance + min_val < 0) {\n            return false;\n        }\n        current_balance += total_change;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '<') {\n            ++current_balance;\n        } else {\n            --current_balance;\n        }\n        if (current_balance < 0) {\n            return false;\n        }\n    }\n\n    return current_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const size_t len = brackets.size();\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(brackets.data());\n    int balance = 0;\n\n    for (size_t i = 0; i < len; i += 16) {\n        size_t remaining = len - i;\n        uint8x16_t chunk;\n\n        if (remaining >= 16) {\n            chunk = vld1q_u8(data + i);\n        } else {\n            uint8_t buffer[16] = {0};\n            for (size_t j = 0; j < remaining; ++j) {\n                buffer[j] = data[i + j];\n            }\n            chunk = vld1q_u8(buffer);\n        }\n\n        uint8x16_t open_mask = vceqq_u8(chunk, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(chunk, vdupq_n_u8(')'));\n        int8x16_t deltas = vreinterpretq_s8_u8(vsubq_u8(open_mask, close_mask));\n\n        int8_t delta_array[16];\n        vst1q_s8(delta_array, deltas);\n\n        int chunk_min = 0;\n        int current = 0;\n        for (int j = 0; j < 16; ++j) {\n            current += delta_array[j];\n            if (current < chunk_min) {\n                chunk_min = current;\n            }\n        }\n\n        if (balance + chunk_min < 0) {\n            return false;\n        }\n\n        balance += current;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const size_t len = brackets.length();\n    const uint8_t* ptr = (const uint8_t*)brackets.c_str();\n    int depth = 0;\n    size_t i = 0;\n\n    if (len == 0) {\n        return true;\n    }\n\n    uint8x16_t char_open = vdupq_n_u8('(');\n    uint8x16_t char_close = vdupq_n_u8(')');\n    int8x16_t zeros = vdupq_n_s8(0);\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(ptr + i);\n        uint8x16_t mask_open = vceqq_u8(input, char_open);\n        uint8x16_t mask_close = vceqq_u8(input, char_close);\n        uint8x16_t open_val = vandq_u8(mask_open, vdupq_n_u8(1));\n        uint8x16_t close_val = vandq_u8(mask_close, vdupq_n_u8(1));\n        int8x16_t values = vreinterpretq_s8_u8(vsubq_u8(open_val, close_val));\n\n        int8x16_t shifted1 = vextq_s8(zeros, values, 15);\n        int8x16_t v1 = vaddq_s8(values, shifted1);\n\n        int8x16_t shifted2 = vextq_s8(zeros, v1, 14);\n        int8x16_t v2 = vaddq_s8(v1, shifted2);\n\n        int8x16_t shifted3 = vextq_s8(zeros, v2, 12);\n        int8x16_t v3 = vaddq_s8(v2, shifted3);\n\n        int8x16_t shifted4 = vextq_s8(zeros, v3, 8);\n        int8x16_t prefix_sums = vaddq_s8(v3, shifted4);\n\n        int8x8_t low = vget_low_s8(prefix_sums);\n        int8x8_t high = vget_high_s8(prefix_sums);\n        int8x8_t min_8 = vpmin_s8(low, high);\n        min_8 = vpmin_s8(min_8, min_8);\n        min_8 = vpmin_s8(min_8, min_8);\n        min_8 = vpmin_s8(min_8, min_8);\n        int8_t min_prefix = vget_lane_s8(min_8, 0);\n\n        int8_t total = vgetq_lane_s8(prefix_sums, 15);\n\n        if (depth + min_prefix < 0) {\n            return false;\n        }\n        depth += total;\n    }\n\n    for (; i < len; ++i) {\n        if (brackets[i] == '(') {\n            depth++;\n        } else {\n            depth--;\n        }\n        if (depth < 0) {\n            return false;\n        }\n    }\n\n    return depth == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstring>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    int global_balance = 0;\n    size_t offset = 0;\n\n    while (offset < len) {\n        int chunk_size = (len - offset) >= 16 ? 16 : len - offset;\n        uint8x16_t chunk;\n        if (chunk_size == 16) {\n            chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(brackets.data() + offset));\n        } else {\n            uint8_t buffer[16] = {0};\n            std::memcpy(buffer, brackets.data() + offset, chunk_size);\n            chunk = vld1q_u8(buffer);\n        }\n        offset += chunk_size;\n\n        uint8x16_t open_mask = vceqq_u8(chunk, vdupq_n_u8('('));\n        uint8x16_t close_mask = vceqq_u8(chunk, vdupq_n_u8(')'));\n\n        int8x16_t values = vmulq_s8(\n            vreinterpretq_s8_u8(vsubq_u8(open_mask, close_mask)),\n            vdupq_n_s8(-1)\n        );\n\n        int8_t total_chunk = vaddvq_s8(values);\n\n        int8_t temp_values[16];\n        vst1q_s8(temp_values, values);\n        int8_t current = 0;\n        int8_t min_in_chunk = 0;\n        for (int i = 0; i < 16; i++) {\n            current += temp_values[i];\n            if (current < min_in_chunk) {\n                min_in_chunk = current;\n            }\n        }\n\n        if (global_balance + min_in_chunk < 0) {\n            return false;\n        }\n\n        global_balance += total_chunk;\n    }\n\n    return global_balance == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <string>\n#include <arm_neon.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    size_t len = brackets.length();\n    if (len % 2 != 0) {\n        return false;\n    }\n\n    const uint8_t* ptr = reinterpret_cast<const uint8_t*>(brackets.data());\n    int base = 0;\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(ptr + i);\n        uint8x16_t mask = vceqq_u8(chunk, vmovq_n_u8('('));\n        uint8x16_t ones = vmovq_n_u8(1);\n        uint8x16_t neg_ones = vmovq_n_u8(0xFF);\n        uint8x16_t deltas_u8 = vbslq_u8(mask, ones, neg_ones);\n        int8x16_t deltas = vreinterpretq_s8_u8(deltas_u8);\n\n        int8_t d[16];\n        vst1q_s8(d, deltas);\n\n        int8_t prefix = 0;\n        int8_t min_in_chunk = 0;\n        for (int j = 0; j < 16; j++) {\n            prefix += d[j];\n            if (prefix < min_in_chunk) {\n                min_in_chunk = prefix;\n            }\n        }\n\n        if (base + min_in_chunk < 0) {\n            return false;\n        }\n\n        base += prefix;\n    }\n\n    for (; i < len; i++) {\n        if (brackets[i] == '(') {\n            base++;\n        } else {\n            base--;\n        }\n        if (base < 0) {\n            return false;\n        }\n    }\n\n    return base == 0;\n}\n```"}
{"task_id": "SimdBench_90_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstring>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* ptr = brackets.data();\n    size_t len = brackets.length();\n    int balance = 0;\n    size_t i = 0;\n\n    static const uint8_t index_pattern[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n    uint8x16_t index_vec = vld1q_u8(index_pattern);\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(ptr + i));\n        uint8x16_t mask_open = vceqq_u8(v, vdupq_n_u8('('));\n        uint8x16_t mask_close = vceqq_u8(v, vdupq_n_u8(')'));\n        int8x16_t values = vsubq_s8(vreinterpretq_s8_u8(mask_close), vreinterpretq_s8_u8(mask_open));\n\n        int8x16_t prefix = values;\n        int8x16_t shifted1 = vextq_s8(vdupq_n_s8(0), prefix, 15);\n        prefix = vaddq_s8(prefix, shifted1);\n        int8x16_t shifted2 = vextq_s8(vdupq_n_s8(0), prefix, 14);\n        prefix = vaddq_s8(prefix, shifted2);\n        int8x16_t shifted4 = vextq_s8(vdupq_n_s8(0), prefix, 12);\n        prefix = vaddq_s8(prefix, shifted4);\n        int8x16_t shifted8 = vextq_s8(vdupq_n_s8(0), prefix, 8);\n        prefix = vaddq_s8(prefix, shifted8);\n\n        int8_t min_prefix = vminvq_s8(prefix);\n        int8_t min_relative = min_prefix < 0 ? min_prefix : 0;\n        if (balance + min_relative < 0) {\n            return false;\n        }\n\n        int8_t total_change = vgetq_lane_s8(prefix, 15);\n        balance += total_change;\n    }\n\n    if (i < len) {\n        size_t valid_count = len - i;\n        uint8_t buffer[16] = {0};\n        std::memcpy(buffer, ptr + i, valid_count);\n        uint8x16_t v = vld1q_u8(buffer);\n\n        uint8x16_t mask_open = vceqq_u8(v, vdupq_n_u8('('));\n        uint8x16_t mask_close = vceqq_u8(v, vdupq_n_u8(')'));\n        int8x16_t values = vsubq_s8(vreinterpretq_s8_u8(mask_close), vreinterpretq_s8_u8(mask_open));\n\n        uint8x16_t valid_mask = vcltq_u8(index_vec, vdupq_n_u8(valid_count));\n        values = vandq_s8(values, vreinterpretq_s8_u8(valid_mask));\n\n        int8x16_t prefix = values;\n        int8x16_t shifted1 = vextq_s8(vdupq_n_s8(0), prefix, 15);\n        prefix = vaddq_s8(prefix, shifted1);\n        int8x16_t shifted2 = vextq_s8(vdupq_n_s8(0), prefix, 14);\n        prefix = vaddq_s8(prefix, shifted2);\n        int8x16_t shifted4 = vextq_s8(vdupq_n_s8(0), prefix, 12);\n        prefix = vaddq_s8(prefix, shifted4);\n        int8x16_t shifted8 = vextq_s8(vdupq_n_s8(0), prefix, 8);\n        prefix = vaddq_s8(prefix, shifted8);\n\n        int8x16_t masked_prefix = vbslq_s8(valid_mask, prefix, vdupq_n_s8(127));\n        int8_t min_prefix = vminvq_s8(masked_prefix);\n        int8_t min_relative = min_prefix < 0 ? min_prefix : 0;\n        if (balance + min_relative < 0) {\n            return false;\n        }\n\n        int8_t total_change = 0;\n        if (valid_count > 0) {\n            total_change = vgetq_lane_s8(prefix, valid_count - 1);\n        }\n        balance += total_change;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    if (n <= 1) {\n        return std::vector<float>();\n    }\n    size_t len = n - 1;\n    std::vector<float> result(len);\n    float* in_ptr = xs.data() + 1;\n    float* out_ptr = result.data();\n    \n    const int32x4_t base_int = {0, 1, 2, 3};\n    \n    size_t i = 0;\n    for (; i + 4 <= len; i += 4) {\n        int offset = i + 1;\n        float32x4_t v_coeff = vld1q_f32(in_ptr + i);\n        int32x4_t v_idx_int = vaddq_s32(vdupq_n_s32(offset), base_int);\n        float32x4_t v_idx = vcvtq_f32_s32(v_idx_int);\n        float32x4_t v_result = vmulq_f32(v_coeff, v_idx);\n        vst1q_f32(out_ptr + i, v_result);\n    }\n    \n    for (; i < len; i++) {\n        out_ptr[i] = (i + 1) * in_ptr[i];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    size_t n = xs.size() - 1;\n    std::vector<float> result(n);\n    const int32_t step_array[4] = {0, 1, 2, 3};\n    const int32x4_t step_vec = vld1q_s32(step_array);\n    \n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        int32_t base = i + 1;\n        int32x4_t base_vec = vdupq_n_s32(base);\n        int32x4_t multiplier_int = vaddq_s32(base_vec, step_vec);\n        float32x4_t multiplier_float = vcvtq_f32_s32(multiplier_int);\n        float32x4_t data = vld1q_f32(&xs[base]);\n        float32x4_t res_vec = vmulq_f32(multiplier_float, data);\n        vst1q_f32(&result[i], res_vec);\n    }\n    \n    for (; i < n; ++i) {\n        result[i] = (i + 1) * xs[i + 1];\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    int n = xs.size();\n    int m = n - 1;\n    std::vector<float> out(m);\n    \n    float base_arr[4] = {0.0f, 1.0f, 2.0f, 3.0f};\n    float32x4_t vbase = vld1q_f32(base_arr);\n    \n    int j = 0;\n    for (; j <= m - 4; j += 4) {\n        float32x4_t vcoeff = vld1q_f32(&xs[j + 1]);\n        float32x4_t vstart = vdupq_n_f32(static_cast<float>(j + 1));\n        float32x4_t vindex = vaddq_f32(vstart, vbase);\n        float32x4_t vresult = vmulq_f32(vcoeff, vindex);\n        vst1q_f32(&out[j], vresult);\n    }\n    \n    for (; j < m; j++) {\n        out[j] = xs[j + 1] * static_cast<float>(j + 1);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n\n    size_t n = xs.size();\n    size_t n_result = n - 1;\n    std::vector<float> result(n_result);\n\n    float32x4_t step_vec = vdupq_n_f32(0.0f);\n    step_vec = vsetq_lane_f32(1.0f, step_vec, 1);\n    step_vec = vsetq_lane_f32(2.0f, step_vec, 2);\n    step_vec = vsetq_lane_f32(3.0f, step_vec, 3);\n\n    size_t i = 0;\n    for (; i + 4 <= n_result; i += 4) {\n        float base_multiplier = static_cast<float>(i + 1);\n        float32x4_t base_vec = vdupq_n_f32(base_multiplier);\n        float32x4_t multipliers = vaddq_f32(base_vec, step_vec);\n\n        float32x4_t coeffs = vld1q_f32(xs.data() + i + 1);\n        float32x4_t res_vec = vmulq_f32(multipliers, coeffs);\n        vst1q_f32(result.data() + i, res_vec);\n    }\n\n    for (; i < n_result; i++) {\n        result[i] = (i + 1) * xs[i + 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    int n = xs.size();\n    if (n <= 1) {\n        return std::vector<float>();\n    }\n    int result_size = n - 1;\n    std::vector<float> result(result_size);\n    alignas(16) static const float pattern_arr[4] = {0.0f, 1.0f, 2.0f, 3.0f};\n    const float32x4_t v_pattern = vld1q_f32(pattern_arr);\n    int i = 0;\n    for (; i <= result_size - 4; i += 4) {\n        float base = static_cast<float>(i) + 1.0f;\n        float32x4_t v_base = vdupq_n_f32(base);\n        float32x4_t v_multiplier = vaddq_f32(v_base, v_pattern);\n        float32x4_t v_xs = vld1q_f32(&xs[i + 1]);\n        float32x4_t v_res = vmulq_f32(v_xs, v_multiplier);\n        vst1q_f32(&result[i], v_res);\n    }\n    for (; i < result_size; i++) {\n        result[i] = xs[i + 1] * static_cast<float>(i + 1);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    if (len == 0) \n        return 0;\n\n    const uint8_t *str = (const uint8_t *)s.c_str();\n    int count = 0;\n    size_t i = 0;\n\n    uint8x16_t low_mask = vdupq_n_u8(0x20);\n    uint8x16_t a_vec = vdupq_n_u8('a');\n    uint8x16_t e_vec = vdupq_n_u8('e');\n    uint8x16_t i_vec = vdupq_n_u8('i');\n    uint8x16_t o_vec = vdupq_n_u8('o');\n    uint8x16_t u_vec = vdupq_n_u8('u');\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(str + i);\n        uint8x16_t low_data = vorrq_u8(data, low_mask);\n\n        uint8x16_t a_mask = vceqq_u8(low_data, a_vec);\n        uint8x16_t e_mask = vceqq_u8(low_data, e_vec);\n        uint8x16_t i_mask = vceqq_u8(low_data, i_vec);\n        uint8x16_t o_mask = vceqq_u8(low_data, o_vec);\n        uint8x16_t u_mask = vceqq_u8(low_data, u_vec);\n\n        uint8x16_t vowel_mask = vorrq_u8(a_mask, e_mask);\n        vowel_mask = vorrq_u8(vowel_mask, i_mask);\n        vowel_mask = vorrq_u8(vowel_mask, o_mask);\n        vowel_mask = vorrq_u8(vowel_mask, u_mask);\n\n        uint8x16_t ones = vshrq_n_u8(vowel_mask, 7);\n        count += vaddvq_u8(ones);\n    }\n\n    for (; i < len; i++) {\n        uint8_t c = str[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    uint8_t last_char = str[len - 1];\n    if (last_char == 'y' || last_char == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint vowels_count_simd(std::string s) {\n    int n = s.size();\n    if (n == 0) {\n        return 0;\n    }\n    const uint8_t* str = reinterpret_cast<const uint8_t*>(s.c_str());\n    int count = 0;\n    int i = 0;\n\n    // Process full 16-byte chunks\n    uint8x16_t mask_0x20 = vdupq_n_u8(0x20);\n    for (; i <= n - 16; i += 16) {\n        uint8x16_t data = vld1q_u8(str + i);\n        uint8x16_t low = vorrq_u8(data, mask_0x20);\n        uint8x16_t mask_a = vceqq_u8(low, vdupq_n_u8('a'));\n        uint8x16_t mask_e = vceqq_u8(low, vdupq_n_u8('e'));\n        uint8x16_t mask_i = vceqq_u8(low, vdupq_n_u8('i'));\n        uint8x16_t mask_o = vceqq_u8(low, vdupq_n_u8('o'));\n        uint8x16_t mask_u = vceqq_u8(low, vdupq_n_u8('u'));\n        uint8x16_t mask_combined = vorrq_u8(mask_a, mask_e);\n        mask_combined = vorrq_u8(mask_combined, mask_i);\n        mask_combined = vorrq_u8(mask_combined, mask_o);\n        mask_combined = vorrq_u8(mask_combined, mask_u);\n        uint8x16_t ones = vshrq_n_u8(mask_combined, 7);\n        count += vaddvq_u8(ones);\n    }\n\n    // Process remaining bytes with scalar loop\n    for (; i < n; i++) {\n        uint8_t c = str[i];\n        c |= 0x20;\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n\n    // Check last character for 'y' or 'Y'\n    uint8_t last_char = str[n-1];\n    if (last_char == 'y' || last_char == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int n = s.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    uint32_t count = 0;\n    int i = 0;\n    uint8x16_t mask_0x20 = vdupq_n_u8(0x20);\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t low_chunk = vorrq_u8(chunk, mask_0x20);\n\n        uint8x16_t mask_a = vceqq_u8(low_chunk, vdupq_n_u8('a'));\n        uint8x16_t mask_e = vceqq_u8(low_chunk, vdupq_n_u8('e'));\n        uint8x16_t mask_i = vceqq_u8(low_chunk, vdupq_n_u8('i'));\n        uint8x16_t mask_o = vceqq_u8(low_chunk, vdupq_n_u8('o'));\n        uint8x16_t mask_u = vceqq_u8(low_chunk, vdupq_n_u8('u'));\n\n        uint8x16_t vowel_mask = vorrq_u8(mask_a, mask_e);\n        vowel_mask = vorrq_u8(vowel_mask, mask_i);\n        vowel_mask = vorrq_u8(vowel_mask, mask_o);\n        vowel_mask = vorrq_u8(vowel_mask, mask_u);\n\n        vowel_mask = vshrq_n_u8(vowel_mask, 7);\n        count += vaddvq_u8(vowel_mask);\n    }\n\n    for (; i < n; i++) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n\n    char last = s[n - 1];\n    if (last == 'y' || last == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    if (len == 0) {\n        return 0;\n    }\n\n    const uint8_t *str = reinterpret_cast<const uint8_t*>(s.c_str());\n    int i = 0;\n    uint32x4_t total_vector = vdupq_n_u32(0);\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t input = vld1q_u8(str + i);\n        uint8x16_t lowcase = vorrq_u8(input, vdupq_n_u8(0x20));\n\n        uint8x16_t a_mask = vceqq_u8(lowcase, vdupq_n_u8('a'));\n        uint8x16_t e_mask = vceqq_u8(lowcase, vdupq_n_u8('e'));\n        uint8x16_t i_mask = vceqq_u8(lowcase, vdupq_n_u8('i'));\n        uint8x16_t o_mask = vceqq_u8(lowcase, vdupq_n_u8('o'));\n        uint8x16_t u_mask = vceqq_u8(lowcase, vdupq_n_u8('u'));\n\n        uint8x16_t any_mask = vorrq_u8(a_mask, e_mask);\n        any_mask = vorrq_u8(any_mask, i_mask);\n        any_mask = vorrq_u8(any_mask, o_mask);\n        any_mask = vorrq_u8(any_mask, u_mask);\n\n        uint8x16_t ones = vshrq_n_u8(any_mask, 7);\n        uint16x8_t sum8 = vpaddlq_u8(ones);\n        uint32x4_t sum32 = vpaddlq_u16(sum8);\n        total_vector = vaddq_u32(total_vector, sum32);\n    }\n\n    uint32_t total_count = vaddvq_u32(total_vector);\n\n    if (i < len) {\n        uint8_t buffer[16] = {0};\n        size_t remaining = len - i;\n        for (size_t j = 0; j < remaining; j++) {\n            buffer[j] = str[i+j];\n        }\n\n        uint8x16_t input = vld1q_u8(buffer);\n        uint8x16_t lowcase = vorrq_u8(input, vdupq_n_u8(0x20));\n\n        uint8x16_t a_mask = vceqq_u8(lowcase, vdupq_n_u8('a'));\n        uint8x16_t e_mask = vceqq_u8(lowcase, vdupq_n_u8('e'));\n        uint8x16_t i_mask = vceqq_u8(lowcase, vdupq_n_u8('i'));\n        uint8x16_t o_mask = vceqq_u8(lowcase, vdupq_n_u8('o'));\n        uint8x16_t u_mask = vceqq_u8(lowcase, vdupq_n_u8('u'));\n\n        uint8x16_t any_mask = vorrq_u8(a_mask, e_mask);\n        any_mask = vorrq_u8(any_mask, i_mask);\n        any_mask = vorrq_u8(any_mask, o_mask);\n        any_mask = vorrq_u8(any_mask, u_mask);\n\n        uint8x16_t ones = vshrq_n_u8(any_mask, 7);\n        uint16x8_t sum8 = vpaddlq_u8(ones);\n        uint32x4_t sum32 = vpaddlq_u16(sum8);\n        total_count += vaddvq_u32(sum32);\n    }\n\n    char last_char = s[len-1];\n    if (last_char == 'y' || last_char == 'Y') {\n        total_count++;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_92_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len = s.length();\n    if (len == 0) return 0;\n    \n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.c_str());\n    int count = 0;\n    \n    uint8x16_t lowercase_mask = vdupq_n_u8(0x20);\n    uint8x16_t vowel_a = vdupq_n_u8('a');\n    uint8x16_t vowel_e = vdupq_n_u8('e');\n    uint8x16_t vowel_i = vdupq_n_u8('i');\n    uint8x16_t vowel_o = vdupq_n_u8('o');\n    uint8x16_t vowel_u = vdupq_n_u8('u');\n    \n    size_t i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t chunk = vld1q_u8(data + i);\n        chunk = vorrq_u8(chunk, lowercase_mask);\n        \n        uint8x16_t cmp_a = vceqq_u8(chunk, vowel_a);\n        uint8x16_t cmp_e = vceqq_u8(chunk, vowel_e);\n        uint8x16_t cmp_i = vceqq_u8(chunk, vowel_i);\n        uint8x16_t cmp_o = vceqq_u8(chunk, vowel_o);\n        uint8x16_t cmp_u = vceqq_u8(chunk, vowel_u);\n        \n        uint8x16_t any_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cmp_a, cmp_e), vorrq_u8(cmp_i, cmp_o)), cmp_u);\n        any_vowel = vshrq_n_u8(any_vowel, 7);\n        \n        uint16x8_t sum16 = vpaddlq_u8(any_vowel);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        \n        uint32_t total_in_vector = vgetq_lane_u32(sum32, 0) + vgetq_lane_u32(sum32, 1) +\n                                  vgetq_lane_u32(sum32, 2) + vgetq_lane_u32(sum32, 3);\n        count += total_in_vector;\n    }\n    \n    for (; i < len; i++) {\n        uint8_t c = data[i];\n        c |= 0x20;\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n    }\n    \n    uint8_t last_char = data[len - 1];\n    if (last_char == 'y' || last_char == 'Y') {\n        count++;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t len = s.length();\n    if (len == 0) \n        return 0;\n\n    uint32x4_t accumulator = vdupq_n_u32(0);\n    size_t i = 0;\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t mask_ge_A = vcgeq_u8(vec, vdupq_n_u8('A'));\n        uint8x16_t mask_le_Z = vcleq_u8(vec, vdupq_n_u8('Z'));\n        uint8x16_t mask = vandq_u8(mask_ge_A, mask_le_Z);\n        uint8x16_t selected = vandq_u8(vec, mask);\n        uint16x8_t sum16 = vpaddlq_u8(selected);\n        uint32x4_t sum32 = vpaddlq_u16(sum16);\n        accumulator = vaddq_u32(accumulator, sum32);\n    }\n\n    uint32_t sum = vgetq_lane_u32(accumulator, 0) +\n                   vgetq_lane_u32(accumulator, 1) +\n                   vgetq_lane_u32(accumulator, 2) +\n                   vgetq_lane_u32(accumulator, 3);\n\n    for (; i < len; i++) {\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<unsigned char>(c);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    size_t n = s.size();\n    size_t i = 0;\n    uint32x4_t total_vec = vdupq_n_u32(0);\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t vec = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        uint8x16_t mask1 = vcgeq_u8(vec, vdupq_n_u8('A'));\n        uint8x16_t mask2 = vcleq_u8(vec, vdupq_n_u8('Z'));\n        uint8x16_t mask = vandq_u8(mask1, mask2);\n        uint8x16_t selected = vandq_u8(vec, mask);\n\n        uint16x8_t low16 = vmovl_u8(vget_low_u8(selected));\n        uint16x8_t high16 = vmovl_u8(vget_high_u8(selected));\n\n        total_vec = vpadalq_u16(total_vec, low16);\n        total_vec = vpadalq_u16(total_vec, high16);\n    }\n\n    uint32_t sum = 0;\n    uint32_t tmp[4];\n    vst1q_u32(tmp, total_vec);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < n; i++) {\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<unsigned char>(c);\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t len = s.length();\n    uint32_t total = 0;\n    size_t i = 0;\n\n    if (len >= 16) {\n        uint32x4_t sum_vec = vdupq_n_u32(0);\n        const uint8x16_t a_vec = vdupq_n_u8('A');\n        const uint8x16_t z_vec = vdupq_n_u8('Z');\n        \n        for (; i <= len - 16; i += 16) {\n            uint8x16_t chars = vld1q_u8(data + i);\n            uint8x16_t mask1 = vcgeq_u8(chars, a_vec);\n            uint8x16_t mask2 = vcleq_u8(chars, z_vec);\n            uint8x16_t mask = vandq_u8(mask1, mask2);\n            uint8x16_t selected = vandq_u8(chars, mask);\n            \n            uint16x8_t sum16 = vpaddlq_u8(selected);\n            uint32x4_t sum32 = vpaddlq_u16(sum16);\n            sum_vec = vaddq_u32(sum_vec, sum32);\n        }\n        \n        uint32_t tmp[4];\n        vst1q_u32(tmp, sum_vec);\n        total = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    }\n\n    for (; i < len; ++i) {\n        uint8_t c = data[i];\n        if (c >= 'A' && c <= 'Z') {\n            total += c;\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```c\nint digitSum_simd(std::string s) {\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t len = s.length();\n    uint32_t sum = 0;\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec = vld1q_u8(data + i);\n        uint8x16_t mask_ge_A = vcgeq_u8(vec, vdupq_n_u8('A'));\n        uint8x16_t mask_le_Z = vcleq_u8(vec, vdupq_n_u8('Z'));\n        uint8x16_t mask = vandq_u8(mask_ge_A, mask_le_Z);\n        uint8x16_t selected = vandq_u8(vec, mask);\n        sum += vaddlvq_u8(selected);\n    }\n\n    for (; i < len; i++) {\n        uint8_t c = data[i];\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n\n    return static_cast<int>(sum);\n}\n```"}
{"task_id": "SimdBench_93_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint digitSum_simd(std::string s) {\n    const uint8_t *str = reinterpret_cast<const uint8_t*>(s.data());\n    size_t len = s.length();\n    uint32_t total = 0;\n    size_t i = 0;\n\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t v = vld1q_u8(str + i);\n        uint8x16_t mask_ge = vcgeq_u8(v, vdupq_n_u8('A'));\n        uint8x16_t mask_le = vcleq_u8(v, vdupq_n_u8('Z'));\n        uint8x16_t mask = vandq_u8(mask_ge, mask_le);\n        uint8x16_t upper_vals = vandq_u8(v, mask);\n        total += vaddlvq_u8(upper_vals);\n    }\n\n    for (; i < len; i++) {\n        uint8_t c = str[i];\n        if (c >= 'A' && c <= 'Z') {\n            total += c;\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <vector>\n#include <climits>\n#include <arm_neon.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int global_min_value = INT_MAX;\n    int global_min_index = -1;\n\n    static const int32_t step_arr[4] = {0, 1, 2, 3};\n    int32x4_t step = vld1q_s32(step_arr);\n\n    int i = 0;\n    int n = arr.size();\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(arr.data() + i);\n\n        uint32x4_t mask_even = vceqq_u32(\n            vandq_u32(vreinterpretq_u32_s32(data), vdupq_n_u32(1)),\n            vdupq_n_u32(0)\n        );\n\n        int32x4_t candidate_values = vbslq_s32(mask_even, data, vdupq_n_s32(INT_MAX));\n        int32_t min_val_in_chunk = vminvq_s32(candidate_values);\n\n        if (min_val_in_chunk == INT_MAX) {\n            continue;\n        }\n\n        int32x4_t indices_vec = vaddq_s32(vdupq_n_s32(i), step);\n\n        if (min_val_in_chunk < global_min_value) {\n            uint32x4_t mask_min = vceqq_s32(candidate_values, vdupq_n_s32(min_val_in_chunk));\n            int32x4_t candidate_indices = vbslq_s32(mask_min, indices_vec, vdupq_n_s32(INT_MAX));\n            int32_t min_index_in_chunk = vminvq_s32(candidate_indices);\n\n            global_min_value = min_val_in_chunk;\n            global_min_index = min_index_in_chunk;\n        } else if (min_val_in_chunk == global_min_value) {\n            uint32x4_t mask_min = vceqq_s32(candidate_values, vdupq_n_s32(min_val_in_chunk));\n            int32x4_t candidate_indices = vbslq_s32(mask_min, indices_vec, vdupq_n_s32(INT_MAX));\n            int32_t min_index_in_chunk = vminvq_s32(candidate_indices);\n\n            if (min_index_in_chunk < global_min_index) {\n                global_min_index = min_index_in_chunk;\n            }\n        }\n    }\n\n    for (; i < n; i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < global_min_value) {\n                global_min_value = arr[i];\n                global_min_index = i;\n            } else if (arr[i] == global_min_value) {\n                if (i < global_min_index) {\n                    global_min_index = i;\n                }\n            }\n        }\n    }\n\n    if (global_min_index == -1) {\n        return {};\n    }\n\n    return {global_min_value, global_min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int n = arr.size();\n    int global_min = -1;\n    int global_index = -1;\n\n    for (int i = 0; i < n; i += 4) {\n        int remaining = n - i;\n        int32x4_t v_val;\n        if (remaining >= 4) {\n            v_val = vld1q_s32(arr.data() + i);\n        } else {\n            int32_t tmp[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n            for (int j = 0; j < remaining; j++) {\n                tmp[j] = arr[i + j];\n            }\n            v_val = vld1q_s32(tmp);\n        }\n\n        uint32x4_t mask = vceqq_u32(vandq_u32(vreinterpretq_u32_s32(v_val), vdupq_n_u32(1)), vdupq_n_u32(0));\n        int32x4_t candidate = vbslq_s32(mask, v_val, vdupq_n_s32(INT_MAX));\n        int32_t min_val = vminvq_s32(candidate);\n\n        if (min_val == INT_MAX) {\n            continue;\n        }\n\n        if (global_min == -1 || min_val < global_min) {\n            global_min = min_val;\n            int scan_end = (remaining < 4) ? remaining : 4;\n            for (int j = 0; j < scan_end; j++) {\n                if (arr[i + j] == min_val) {\n                    global_index = i + j;\n                    break;\n                }\n            }\n        }\n    }\n\n    if (global_min == -1) {\n        return {};\n    } else {\n        return {global_min, global_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "To solve this problem, we need to find the smallest even value in an array of non-negative integers and return its value along with its index. If multiple even values are the smallest, we return the one with the smallest index. If there are no even values or the array is empty, we return an empty vector.\n\n### Approach\n1. **Initial Checks**: If the input array is empty, return an empty vector immediately.\n2. **Initialization**: Initialize `global_min` to `INT_MAX` and `global_index` to -1 to keep track of the smallest even value found and its index.\n3. **SIMD Processing**:\n   - **Increment Vector**: Create a vector `v_incr` containing values {0, 1, 2, 3} to help compute indices for each chunk of 4 elements.\n   - **Process Chunks**: For each chunk of 4 elements:\n     - **Load Data**: Load 4 elements from the array into a SIMD register.\n     - **Even Mask**: Compute a mask identifying even numbers by checking if the least significant bit is 0.\n     - **Candidate Values**: Replace non-even values with `INT_MAX` to exclude them from consideration.\n     - **Chunk Minimum**: Find the minimum value in the current chunk. If no even numbers exist (`chunk_min` remains `INT_MAX`), skip further processing for this chunk.\n     - **Update Global Minimum**: If a new smallest even value is found in the chunk, determine the first occurrence of this value within the chunk and update `global_min` and `global_index`.\n4. **Tail Processing**: Process any remaining elements (less than 4) using a scalar loop.\n5. **Result Check**: After processing all elements, if `global_min` is still `INT_MAX`, return an empty vector; otherwise, return the smallest even value and its index.\n\n### Solution Code\n```cpp\n#include <vector>\n#include <climits>\n#include <arm_neon.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    int n = arr.size();\n    int global_min = INT_MAX;\n    int global_index = -1;\n\n    int32x4_t v_incr = vmovq_n_s32(0);\n    v_incr = vsetq_lane_s32(1, v_incr, 1);\n    v_incr = vsetq_lane_s32(2, v_incr, 2);\n    v_incr = vsetq_lane_s32(3, v_incr, 3);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(arr.data() + i);\n\n        int32x4_t mod = vandq_s32(data, vdupq_n_s32(1));\n        uint32x4_t even_mask = vceqq_s32(mod, vdupq_n_s32(0));\n\n        int32x4_t candidate_values = vbslq_s32(even_mask, data, vdupq_n_s32(INT_MAX));\n\n        int32_t chunk_min = vminvq_s32(candidate_values);\n        if (chunk_min == INT_MAX) {\n            continue;\n        }\n\n        if (chunk_min < global_min) {\n            uint32x4_t mask_min = vceqq_s32(candidate_values, vdupq_n_s32(chunk_min));\n            int32x4_t base_index = vaddq_s32(vdupq_n_s32(i), v_incr);\n            int32x4_t candidate_indices = vbslq_s32(mask_min, base_index, vdupq_n_s32(n));\n            int32_t first_index_in_chunk = vminvq_s32(candidate_indices);\n\n            global_min = chunk_min;\n            global_index = first_index_in_chunk;\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < global_min) {\n                global_min = arr[i];\n                global_index = i;\n            }\n        }\n    }\n\n    if (global_min == INT_MAX) {\n        return {};\n    } else {\n        return {global_min, global_index};\n    }\n}\n```\n\n### Explanation\n1. **Initial Checks**: The function first checks if the input array is empty and returns an empty vector if true.\n2. **Initialization**: `global_min` is initialized to `INT_MAX` to represent the largest possible integer, and `global_index` to -1 to indicate no valid index found yet.\n3. **SIMD Processing**:\n   - **Increment Vector**: The vector `v_incr` is set to {0, 1, 2, 3} to facilitate index calculations for each 4-element chunk.\n   - **Chunk Processing**: For each 4-element chunk:\n     - **Data Loading**: Loads 4 integers into a SIMD register.\n     - **Even Mask**: Computes a mask where each element is `0xFFFFFFFF` (true) if the corresponding element is even.\n     - **Candidate Values**: Uses the mask to set non-even elements to `INT_MAX`, ensuring they are ignored in subsequent min operations.\n     - **Chunk Minimum**: Computes the minimum value in the chunk. If all elements are non-even (`chunk_min` is `INT_MAX`), the chunk is skipped.\n     - **Global Update**: If a new minimum even value is found, the first occurrence of this value in the chunk is identified, and `global_min` and `global_index` are updated.\n4. **Tail Processing**: Processes any remaining elements (1 to 3) using a simple loop, updating `global_min` and `global_index` if a smaller even value is found.\n5. **Result Check**: After processing all elements, if `global_min` remains `INT_MAX`, returns an empty vector; otherwise, returns the smallest even value and its index.\n\nThis approach efficiently leverages SIMD instructions to process data in parallel, significantly speeding up the operation for large arrays while ensuring correctness through careful handling of edge cases and tail elements."}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int global_min_value = INT_MAX;\n    int global_min_index = -1;\n    int i = 0;\n    const int size = arr.size();\n\n    for (; i <= size - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(&arr[i]);\n        uint32x4_t vec_u = vreinterpretq_u32_s32(vec);\n        uint32x4_t mod = vandq_u32(vec_u, vdupq_n_u32(1));\n        uint32x4_t even_mask = vceqq_u32(mod, vdupq_n_u32(0));\n        int32x4_t candidate_vals = vbslq_s32(even_mask, vec, vdupq_n_s32(INT_MAX));\n        int32_t min_val_in_chunk = vminvq_s32(candidate_vals);\n\n        if (min_val_in_chunk == INT_MAX) {\n            continue;\n        }\n\n        uint32x4_t indices_in_chunk = {0, 1, 2, 3};\n        uint32x4_t min_mask = vceqq_s32(candidate_vals, vdupq_n_s32(min_val_in_chunk));\n        uint32x4_t candidate_indices = vbslq_u32(min_mask, indices_in_chunk, vdupq_n_u32(4));\n        uint32_t min_index_in_chunk = vminvq_u32(candidate_indices);\n\n        int candidate_index = i + min_index_in_chunk;\n        if (min_val_in_chunk < global_min_value) {\n            global_min_value = min_val_in_chunk;\n            global_min_index = candidate_index;\n        } else if (min_val_in_chunk == global_min_value && candidate_index < global_min_index) {\n            global_min_index = candidate_index;\n        }\n    }\n\n    for (; i < size; ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < global_min_value) {\n                global_min_value = arr[i];\n                global_min_index = i;\n            } else if (arr[i] == global_min_value && (global_min_index == -1 || i < global_min_index)) {\n                global_min_index = i;\n            }\n        }\n    }\n\n    if (global_min_index == -1) {\n        return {};\n    }\n    return {global_min_value, global_min_index};\n}\n```"}
{"task_id": "SimdBench_94_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n#include <climits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    size_t n = arr.size();\n    uint32_t min_val = UINT_MAX;\n\n    if (n >= 4) {\n        uint32x4_t min_vec = vdupq_n_u32(UINT_MAX);\n        size_t i = 0;\n        for (; i <= n - 4; i += 4) {\n            uint32x4_t data = vld1q_u32(reinterpret_cast<const uint32_t*>(&arr[i]));\n            uint32x4_t even_mask = vceqq_u32(vandq_u32(data, vdupq_n_u32(1)), vdupq_n_u32(0));\n            uint32x4_t candidate = vbslq_u32(even_mask, data, vdupq_n_u32(UINT_MAX));\n            min_vec = vminq_u32(min_vec, candidate);\n        }\n        min_val = vminvq_u32(min_vec);\n        for (; i < n; ++i) {\n            if (arr[i] % 2 == 0) {\n                uint32_t a = static_cast<uint32_t>(arr[i]);\n                if (a < min_val) {\n                    min_val = a;\n                }\n            }\n        }\n    } else {\n        for (size_t i = 0; i < n; ++i) {\n            if (arr[i] % 2 == 0) {\n                uint32_t a = static_cast<uint32_t>(arr[i]);\n                if (a < min_val) {\n                    min_val = a;\n                }\n            }\n        }\n    }\n\n    if (min_val == UINT_MAX) {\n        return {};\n    }\n\n    size_t i = 0;\n    for (; i <= n - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(reinterpret_cast<const uint32_t*>(&arr[i]));\n        uint32x4_t cmp = vceqq_u32(data, vdupq_n_u32(min_val));\n        uint32_t cmp0 = vgetq_lane_u32(cmp, 0);\n        uint32_t cmp1 = vgetq_lane_u32(cmp, 1);\n        uint32_t cmp2 = vgetq_lane_u32(cmp, 2);\n        uint32_t cmp3 = vgetq_lane_u32(cmp, 3);\n\n        if (cmp0) {\n            return {static_cast<int>(min_val), static_cast<int>(i)};\n        }\n        if (cmp1) {\n            return {static_cast<int>(min_val), static_cast<int>(i+1)};\n        }\n        if (cmp2) {\n            return {static_cast<int>(min_val), static_cast<int>(i+2)};\n        }\n        if (cmp3) {\n            return {static_cast<int>(min_val), static_cast<int>(i+3)};\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] == static_cast<int>(min_val)) {\n            return {static_cast<int>(min_val), static_cast<int>(i)};\n        }\n    }\n\n    return {};\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    int max_val = 0;\n    int i = 0;\n    int n = lst.size();\n    int32x4_t vmax = vdupq_n_s32(0);\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        vmax = vmaxq_s32(vmax, v);\n    }\n\n    int32_t max_arr[4];\n    vst1q_s32(max_arr, vmax);\n    max_val = max_arr[0];\n    if (max_arr[1] > max_val) max_val = max_arr[1];\n    if (max_arr[2] > max_val) max_val = max_arr[2];\n    if (max_arr[3] > max_val) max_val = max_arr[3];\n\n    for (; i < n; i++) {\n        if (lst[i] > max_val) {\n            max_val = lst[i];\n        }\n    }\n\n    std::vector<int> freq(max_val + 1, 0);\n    for (i = 0; i < n; i++) {\n        if (lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n\n    int x;\n    for (x = max_val; x >= 3; x -= 4) {\n        int32x4_t freqs = vld1q_s32(&freq[x - 3]);\n        int32x4_t rev_freqs = vrev64q_s32(freqs);\n        rev_freqs = vcombine_s32(vget_high_s32(rev_freqs), vget_low_s32(rev_freqs));\n        \n        int32x4_t base = vdupq_n_s32(x);\n        int32x4_t offsets = {0, -1, -2, -3};\n        int32x4_t indices = vaddq_s32(base, offsets);\n        \n        uint32x4_t mask = vcgeq_s32(rev_freqs, indices);\n        \n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, mask);\n        \n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                return x - j;\n            }\n        }\n    }\n\n    for (; x >= 1; x--) {\n        if (freq[x] >= x) {\n            return x;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int max_val = 0;\n    int i = 0;\n    int32x4_t vmax = vdupq_n_s32(0);\n    for (; i <= n-4; i += 4) {\n        int32x4_t vi = vld1q_s32(&lst[i]);\n        vmax = vmaxq_s32(vmax, vi);\n    }\n    int32x2_t vmax_low = vget_low_s32(vmax);\n    int32x2_t vmax_high = vget_high_s32(vmax);\n    int32x2_t vmax_temp = vpmax_s32(vmax_low, vmax_high);\n    vmax_temp = vpmax_s32(vmax_temp, vmax_temp);\n    max_val = vget_lane_s32(vmax_temp, 0);\n    for (; i < n; i++) {\n        if (lst[i] > max_val) max_val = lst[i];\n    }\n\n    if (max_val <= 0) return -1;\n\n    std::vector<int> freq0(max_val+1, 0);\n    std::vector<int> freq1(max_val+1, 0);\n    std::vector<int> freq2(max_val+1, 0);\n    std::vector<int> freq3(max_val+1, 0);\n\n    i = 0;\n    for (; i <= n-4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        int d0 = vgetq_lane_s32(data, 0);\n        int d1 = vgetq_lane_s32(data, 1);\n        int d2 = vgetq_lane_s32(data, 2);\n        int d3 = vgetq_lane_s32(data, 3);\n        freq0[d0]++;\n        freq1[d1]++;\n        freq2[d2]++;\n        freq3[d3]++;\n    }\n    for (; i < n; i++) {\n        freq0[lst[i]]++;\n    }\n\n    std::vector<int> freq(max_val+1, 0);\n    int j = 0;\n    for (; j <= max_val - 3; j += 4) {\n        int32x4_t v0 = vld1q_s32(&freq0[j]);\n        int32x4_t v1 = vld1q_s32(&freq1[j]);\n        int32x4_t v2 = vld1q_s32(&freq2[j]);\n        int32x4_t v3 = vld1q_s32(&freq3[j]);\n        int32x4_t sum = vaddq_s32(v0, v1);\n        sum = vaddq_s32(sum, v2);\n        sum = vaddq_s32(sum, v3);\n        vst1q_s32(&freq[j], sum);\n    }\n    for (; j <= max_val; j++) {\n        freq[j] = freq0[j] + freq1[j] + freq2[j] + freq3[j];\n    }\n\n    int candidate = -1;\n    i = max_val;\n    for (; i >= 4; i -= 4) {\n        int32x4_t v_freq = vld1q_s32(&freq[i-3]);\n        v_freq = vrev64q_s32(v_freq);\n        v_freq = vextq_s32(v_freq, v_freq, 2);\n        int32_t idx_arr[4] = {i, i-1, i-2, i-3};\n        int32x4_t v_idx = vld1q_s32(idx_arr);\n        uint32x4_t mask = vcgeq_s32(v_freq, v_idx);\n        if (vmaxvq_u32(mask) {\n            if (vgetq_lane_u32(mask, 0)) {\n                candidate = i;\n                break;\n            } else if (vgetq_lane_u32(mask, 1)) {\n                candidate = i-1;\n                break;\n            } else if (vgetq_lane_u32(mask, 2)) {\n                candidate = i-2;\n                break;\n            } else if (vgetq_lane_u32(mask, 3)) {\n                candidate = i-3;\n                break;\n            }\n        }\n    }\n    if (candidate == -1) {\n        for (int j = i; j >= 1; j--) {\n            if (freq[j] >= j) {\n                candidate = j;\n                break;\n            }\n        }\n    }\n    return candidate;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    if (n == 0) {\n        return -1;\n    }\n\n    uint32_t max_val = 0;\n    uint32x4_t max_vec = vdupq_n_u32(0);\n    size_t i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        max_vec = vmaxq_u32(max_vec, data);\n    }\n\n    uint32_t tmp[4];\n    vst1q_u32(tmp, max_vec);\n    for (int j = 0; j < 4; j++) {\n        if (tmp[j] > max_val) max_val = tmp[j];\n    }\n\n    for (; i < n; i++) {\n        uint32_t val = lst[i];\n        if (val > max_val) max_val = val;\n    }\n\n    if (max_val == 0) {\n        return -1;\n    }\n\n    std::vector<uint32_t> freq0(max_val + 1, 0);\n    std::vector<uint32_t> freq1(max_val + 1, 0);\n    std::vector<uint32_t> freq2(max_val + 1, 0);\n    std::vector<uint32_t> freq3(max_val + 1, 0);\n\n    i = 0;\n    for (; i <= n - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        uint32_t d0 = vgetq_lane_u32(data, 0);\n        uint32_t d1 = vgetq_lane_u32(data, 1);\n        uint32_t d2 = vgetq_lane_u32(data, 2);\n        uint32_t d3 = vgetq_lane_u32(data, 3);\n\n        if (d0 <= max_val) freq0[d0]++;\n        if (d1 <= max_val) freq1[d1]++;\n        if (d2 <= max_val) freq2[d2]++;\n        if (d3 <= max_val) freq3[d3]++;\n    }\n\n    for (; i < n; i++) {\n        uint32_t d = lst[i];\n        if (d <= max_val) {\n            freq0[d]++;\n        }\n    }\n\n    std::vector<uint32_t> total_freq(max_val + 1, 0);\n    size_t j = 0;\n    for (; j <= max_val - 3; j += 4) {\n        uint32x4_t v0 = vld1q_u32(&freq0[j]);\n        uint32x4_t v1 = vld1q_u32(&freq1[j]);\n        uint32x4_t v2 = vld1q_u32(&freq2[j]);\n        uint32x4_t v3 = vld1q_u32(&freq3[j]);\n\n        uint32x4_t sum = vaddq_u32(v0, v1);\n        sum = vaddq_u32(sum, v2);\n        sum = vaddq_u32(sum, v3);\n\n        vst1q_u32(&total_freq[j], sum);\n    }\n\n    for (; j <= max_val; j++) {\n        total_freq[j] = freq0[j] + freq1[j] + freq2[j] + freq3[j];\n    }\n\n    for (uint32_t x = max_val; x >= 1; x--) {\n        if (total_freq[x] >= x) {\n            return x;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n    int n = lst.size();\n    int max_val = lst[0];\n    int i = 0;\n\n    if (n >= 4) {\n        int32x4_t max_vec = vld1q_s32(&lst[0]);\n        i = 4;\n        for (; i <= n - 4; i += 4) {\n            int32x4_t chunk = vld1q_s32(&lst[i]);\n            max_vec = vmaxq_s32(max_vec, chunk);\n        }\n        int32x2_t low = vget_low_s32(max_vec);\n        int32x2_t high = vget_high_s32(max_vec);\n        int32x2_t max2 = vpmax_s32(low, high);\n        max2 = vpmax_s32(max2, max2);\n        max_val = vget_lane_s32(max2, 0);\n    }\n\n    for (; i < n; i++) {\n        if (lst[i] > max_val) {\n            max_val = lst[i];\n        }\n    }\n\n    std::vector<int> freq(max_val + 1, 0);\n    for (int i = 0; i < n; i++) {\n        if (lst[i] <= max_val) {\n            freq[lst[i]]++;\n        }\n    }\n\n    int j = max_val;\n    for (; j >= 3; j -= 4) {\n        int base_index = j - 3;\n        int32x4_t freq_vec = vld1q_s32(&freq[base_index]);\n        int32x4_t base_vec = vdupq_n_s32(base_index);\n        int32x4_t inc = {0, 1, 2, 3};\n        int32x4_t idx_vec = vaddq_s32(base_vec, inc);\n        uint32x4_t mask = vcgeq_s32(freq_vec, idx_vec);\n\n        if (vgetq_lane_u32(mask, 3)) return base_index + 3;\n        if (vgetq_lane_u32(mask, 2)) return base_index + 2;\n        if (vgetq_lane_u32(mask, 1)) return base_index + 1;\n        if (vgetq_lane_u32(mask, 0)) return base_index;\n    }\n\n    for (; j >= 1; j--) {\n        if (freq[j] >= j) {\n            return j;\n        }\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    uint32_t max_val = 0;\n    int i = 0;\n    uint32x4_t max_vec = vdupq_n_u32(0);\n    \n    for (; i <= n - 4; i += 4) {\n        uint32x4_t data = vld1q_u32(reinterpret_cast<const uint32_t*>(&lst[i]));\n        max_vec = vmaxq_u32(max_vec, data);\n    }\n    max_val = vmaxvq_u32(max_vec);\n    \n    for (; i < n; i++) {\n        if (static_cast<uint32_t>(lst[i]) > max_val) {\n            max_val = lst[i];\n        }\n    }\n    \n    if (max_val == 0) {\n        return -1;\n    }\n    \n    std::vector<uint32_t> freq(max_val + 1, 0);\n    for (int num : lst) {\n        if (static_cast<uint32_t>(num) <= max_val) {\n            freq[num]++;\n        }\n    }\n    \n    int candidate = -1;\n    uint32_t step_arr[4] = {0, 1, 2, 3};\n    uint32x4_t step = vld1q_u32(step_arr);\n    i = max_val;\n    \n    for (; i >= 4; i -= 4) {\n        uint32x4_t f = vld1q_u32(&freq[i - 3]);\n        uint32x4_t base = vdupq_n_u32(i - 3);\n        uint32x4_t idx = vaddq_u32(base, step);\n        uint32x4_t cmp = vcgeq_u32(f, idx);\n        uint32_t cmp_arr[4];\n        vst1q_u32(cmp_arr, cmp);\n        \n        if (cmp_arr[3]) {\n            candidate = i;\n            break;\n        } else if (cmp_arr[2]) {\n            candidate = i - 1;\n            break;\n        } else if (cmp_arr[1]) {\n            candidate = i - 2;\n            break;\n        } else if (cmp_arr[0]) {\n            candidate = i - 3;\n            break;\n        }\n    }\n    \n    if (candidate == -1) {\n        for (int j = i; j >= 1; j--) {\n            if (freq[j] >= static_cast<uint32_t>(j)) {\n                candidate = j;\n                break;\n            }\n        }\n    }\n    \n    return candidate;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int half = n / 2;\n    int i = 0;\n    int j = n - 1;\n\n    for (; i + 3 < half; i += 4, j -= 4) {\n        int32x4_t left_vec = vld1q_s32(q.data() + i);\n        int32x4_t right_vec = vld1q_s32(q.data() + j - 3);\n        int32x2_t low = vget_low_s32(right_vec);\n        int32x2_t high = vget_high_s32(right_vec);\n        int32x2_t rev_low = vrev64_s32(low);\n        int32x2_t rev_high = vrev64_s32(high);\n        int32x4_t rev_right = vcombine_s32(rev_high, rev_low);\n        uint32x4_t cmp = vceqq_s32(left_vec, rev_right);\n        uint32_t mask0 = vgetq_lane_u32(cmp, 0);\n        uint32_t mask1 = vgetq_lane_u32(cmp, 1);\n        uint32_t mask2 = vgetq_lane_u32(cmp, 2);\n        uint32_t mask3 = vgetq_lane_u32(cmp, 3);\n        if ((mask0 & mask1 & mask2 & mask3) != 0xFFFFFFFF) {\n            return false;\n        }\n    }\n\n    for (; i < half; i++, j--) {\n        if (q[i] != q[j]) {\n            return false;\n        }\n    }\n\n    int64_t total = 0;\n    int k = 0;\n    int64x2_t total_vec = vdupq_n_s64(0);\n\n    for (; k + 3 < n; k += 4) {\n        int32x4_t data = vld1q_s32(q.data() + k);\n        int64x2_t low = vmovl_s32(vget_low_s32(data));\n        int64x2_t high = vmovl_s32(vget_high_s32(data));\n        total_vec = vaddq_s64(total_vec, low);\n        total_vec = vaddq_s64(total_vec, high);\n    }\n    total = vgetq_lane_s64(total_vec, 0) + vgetq_lane_s64(total_vec, 1);\n\n    for (; k < n; k++) {\n        total += q[k];\n    }\n\n    if (total > static_cast<int64_t>(w)) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int *data = q.data();\n    int32_t total = 0;\n    int i = 0;\n    int32x4_t vsum = vmovq_n_s32(0);\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(data + i);\n        vsum = vaddq_s32(vsum, v);\n    }\n    int32_t sum_arr[4];\n    vst1q_s32(sum_arr, vsum);\n    total = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n    for (; i < n; i++) {\n        total += data[i];\n    }\n    if (total > w) {\n        return false;\n    }\n    int left = 0;\n    int right = n - 1;\n    while (left + 3 <= right) {\n        int32x4_t left_vec = vld1q_s32(data + left);\n        int32x4_t right_vec = vld1q_s32(data + right - 3);\n        int32x4_t rev64 = vrev64q_s32(right_vec);\n        int32x4_t reversed_right_vec = vcombine_s32(vget_high_s32(rev64), vget_low_s32(rev64));\n        uint32x4_t cmp = vceqq_s32(left_vec, reversed_right_vec);\n        uint64x2_t cmp64 = vreinterpretq_u64_u32(cmp);\n        uint64_t cmp_arr[2];\n        vst1q_u64(cmp_arr, cmp64);\n        if (cmp_arr[0] != 0xFFFFFFFFFFFFFFFF || cmp_arr[1] != 0xFFFFFFFFFFFFFFFF) {\n            return false;\n        }\n        left += 4;\n        right -= 4;\n    }\n    while (left < right) {\n        if (data[left] != data[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "To solve this problem, we need to determine if a given non-empty vector will \"fly\" based on two conditions: it must be palindromic (balanced), and the sum of its elements must be less than or equal to a given maximum weight `w`. The solution leverages ARM Neon intrinsics for parallel processing to efficiently check these conditions.\n\n### Approach\n1. **Check for Palindrome**: \n   - The vector is palindromic if it reads the same forwards and backwards. \n   - We use two pointers, `i` starting at the beginning and `j` starting at the end of the vector.\n   - For large segments (8 or more elements), we process 4 elements at a time from both ends using Neon SIMD instructions. The elements from the end are loaded and reversed to compare with the front elements.\n   - Any mismatch during this comparison immediately returns `false`.\n   - Remaining elements (if any) are checked using a scalar loop.\n\n2. **Calculate Sum**:\n   - The sum of all elements in the vector is computed using Neon SIMD for parallel addition of 4 elements at a time.\n   - The accumulated sum from the SIMD registers is then combined with the sum of any remaining elements (if the vector length is not a multiple of 4).\n\n3. **Check Sum Condition**:\n   - If the vector is palindromic, the total sum is compared against `w`. If the sum is less than or equal to `w`, the function returns `true`; otherwise, it returns `false`.\n\n### Solution Code\n```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int i = 0;\n    int j = n - 1;\n\n    while (j - i >= 7) {\n        int32x4_t front = vld1q_s32(q.data() + i);\n        int32x4_t back = vld1q_s32(q.data() + (j - 3));\n        int32x4_t rev_back = vrev64q_s32(back);\n        rev_back = vcombine_s32(vget_high_s32(rev_back), vget_low_s32(rev_back));\n        uint32x4_t cmp = vceqq_s32(front, rev_back);\n        uint32_t cmp0 = vgetq_lane_u32(cmp, 0);\n        uint32_t cmp1 = vgetq_lane_u32(cmp, 1);\n        uint32_t cmp2 = vgetq_lane_u32(cmp, 2);\n        uint32_t cmp3 = vgetq_lane_u32(cmp, 3);\n        if (cmp0 != 0xFFFFFFFF || cmp1 != 0xFFFFFFFF || cmp2 != 0xFFFFFFFF || cmp3 != 0xFFFFFFFF) {\n            return false;\n        }\n        i += 4;\n        j -= 4;\n    }\n\n    while (i < j) {\n        if (q[i] != q[j]) {\n            return false;\n        }\n        i++;\n        j--;\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    int index = 0;\n    for (; index <= n - 4; index += 4) {\n        int32x4_t data = vld1q_s32(q.data() + index);\n        sum_vec = vaddq_s32(sum_vec, data);\n    }\n    int32_t total = 0;\n    total += vgetq_lane_s32(sum_vec, 0);\n    total += vgetq_lane_s32(sum_vec, 1);\n    total += vgetq_lane_s32(sum_vec, 2);\n    total += vgetq_lane_s32(sum_vec, 3);\n    for (; index < n; index++) {\n        total += q[index];\n    }\n\n    return (total <= w);\n}\n```\n\n### Explanation\n1. **Palindrome Check**:\n   - The loop `while (j - i >= 7)` processes 4 pairs of elements (8 elements total) at a time. The front elements are loaded directly, while the back elements are loaded and reversed to align with the front elements for comparison.\n   - The comparison uses `vceqq_s32` to check for equality across all 4 lanes. If any lane mismatches, the function returns `false`.\n   - The remaining elements (if any) are checked using a simple scalar loop.\n\n2. **Sum Calculation**:\n   - The sum is computed by loading 4 elements at a time into a SIMD register and accumulating their values. The accumulated values from the SIMD register are then extracted and combined.\n   - Any remaining elements (if the vector length isn't a multiple of 4) are summed in a scalar loop.\n\n3. **Final Check**:\n   - After confirming the vector is palindromic, the total sum is compared against `w`. The function returns `true` only if the sum is within the allowed weight; otherwise, it returns `false`.\n\nThis approach efficiently leverages SIMD parallelism for both the palindrome check and sum computation, optimizing performance for larger vectors."}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int i = 0, j = n - 1;\n\n    const int vec_width = 4;\n    for (; i <= j - (vec_width - 1); i += vec_width, j -= vec_width) {\n        int32x4_t left_vec = vld1q_s32(&q[i]);\n        int32x4_t right_vec = vld1q_s32(&q[j - 3]);\n        int32x2_t low_part = vget_low_s32(right_vec);\n        int32x2_t high_part = vget_high_s32(right_vec);\n        int32x2_t rev_low = vrev64_s32(high_part);\n        int32x2_t rev_high = vrev64_s32(low_part);\n        int32x4_t right_vec_reversed = vcombine_s32(rev_low, rev_high);\n        uint32x4_t cmp = vceqq_s32(left_vec, right_vec_reversed);\n        uint32_t min_val = vminvq_u32(cmp);\n        if (min_val != 0xFFFFFFFF) {\n            return false;\n        }\n    }\n\n    for (; i < j; i++, j--) {\n        if (q[i] != q[j]) {\n            return false;\n        }\n    }\n\n    int32x4_t sum_vec = vdupq_n_s32(0);\n    i = 0;\n    int end = n & ~(vec_width - 1);\n    for (; i < end; i += vec_width) {\n        int32x4_t data = vld1q_s32(&q[i]);\n        sum_vec = vaddq_s32(sum_vec, data);\n    }\n    int total_sum = vaddvq_s32(sum_vec);\n    for (; i < n; i++) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int i = 0, j = n - 1;\n    int32x4_t left_sum_vec = vdupq_n_s32(0);\n    int32x4_t right_sum_vec = vdupq_n_s32(0);\n    bool is_palindrome = true;\n\n    while (j - i >= 7) {\n        int32x4_t left_chunk = vld1q_s32(q.data() + i);\n        int32x4_t right_chunk = vld1q_s32(q.data() + j - 3);\n\n        left_sum_vec = vaddq_s32(left_sum_vec, left_chunk);\n        right_sum_vec = vaddq_s32(right_sum_vec, right_chunk);\n\n        int32x4_t rev_right = vrev64q_s32(right_chunk);\n        rev_right = vcombine_s32(vget_high_s32(rev_right), vget_low_s32(rev_right));\n\n        uint32x4_t cmp = vceqq_s32(left_chunk, rev_right);\n        if (vminvq_u32(cmp) == 0) {\n            is_palindrome = false;\n            break;\n        }\n\n        i += 4;\n        j -= 4;\n    }\n\n    if (!is_palindrome) {\n        return false;\n    }\n\n    int total_sum = 0;\n    int32_t left_arr[4], right_arr[4];\n    vst1q_s32(left_arr, left_sum_vec);\n    vst1q_s32(right_arr, right_sum_vec);\n    for (int k = 0; k < 4; k++) {\n        total_sum += left_arr[k] + right_arr[k];\n    }\n\n    while (i < j) {\n        if (q[i] != q[j]) {\n            return false;\n        }\n        total_sum += q[i] + q[j];\n        i++;\n        j--;\n    }\n    if (i == j) {\n        total_sum += q[i];\n    }\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int half = n / 2;\n    int i = 0;\n    int mismatches = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    for (; i <= half - 4; i += 4) {\n        uint32x4_t front_vec = vld1q_u32((uint32_t*)(arr.data() + i));\n        int j0 = n - 1 - i;\n        uint32x4_t back_vec = vld1q_u32((uint32_t*)(arr.data() + j0 - 3));\n        uint32x4_t rev64 = vrev64q_u32(back_vec);\n        uint32x4_t back_reversed = vcombine_u32(vget_high_u32(rev64), vget_low_u32(rev64));\n        uint32x4_t cmp = vceqq_u32(front_vec, back_reversed);\n        uint32x4_t match_bits = vshrq_n_u32(cmp, 31);\n        uint32_t matches4 = \n            vgetq_lane_u32(match_bits, 0) +\n            vgetq_lane_u32(match_bits, 1) +\n            vgetq_lane_u32(match_bits, 2) +\n            vgetq_lane_u32(match_bits, 3);\n        mismatches += (4 - matches4);\n    }\n\n    for (; i < half; i++) {\n        if (arr[i] != arr[n-1-i]) {\n            mismatches++;\n        }\n    }\n\n    return mismatches;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int mismatch_count = 0;\n    size_t n = arr.size();\n    size_t pairs = n / 2;\n    int32_t* start_ptr = arr.data();\n    int32_t* end_ptr = arr.data() + n - 1;\n    size_t i = 0;\n\n    for (; i + 3 < pairs; i += 4) {\n        int32x4_t front_vec = vld1q_s32(start_ptr);\n        int32x4_t back_vec = vld1q_s32(end_ptr - 3);\n        int32x4_t rev_temp = vrev64q_s32(back_vec);\n        int32x4_t rev_back = vcombine_s32(vget_high_s32(rev_temp), vget_low_s32(rev_temp));\n        uint32x4_t cmp = vceqq_s32(front_vec, rev_back);\n        uint32x4_t mask = vshrq_n_u32(cmp, 31);\n        uint32_t sum = vaddvq_u32(mask);\n        mismatch_count += (4 - sum);\n        start_ptr += 4;\n        end_ptr -= 4;\n    }\n\n    for (; i < pairs; i++) {\n        if (*start_ptr != *end_ptr) {\n            mismatch_count++;\n        }\n        start_ptr++;\n        end_ptr--;\n    }\n\n    return mismatch_count;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int i = 0;\n    int j = n - 1;\n    int change = 0;\n\n    while (j - i >= 7) {\n        int32x4_t front_vec = vld1q_s32(&arr[i]);\n        int32x4_t back_vec = vld1q_s32(&arr[j - 3]);\n\n        int32x2_t back_lo = vget_low_s32(back_vec);\n        int32x2_t back_hi = vget_high_s32(back_vec);\n        int32x2_t rev_back_lo = vrev64_s32(back_lo);\n        int32x2_t rev_back_hi = vrev64_s32(back_hi);\n        int32x4_t rev_back_vec = vcombine_s32(rev_back_hi, rev_back_lo);\n\n        uint32x4_t cmp = vceqq_s32(front_vec, rev_back_vec);\n        uint32x4_t mismatch_mask = vmvnq_u32(cmp);\n        uint32x4_t ones = vdupq_n_u32(1);\n        uint32x4_t mismatch_count_vec = vandq_u32(mismatch_mask, ones);\n\n        uint32x2_t lo = vget_low_u32(mismatch_count_vec);\n        uint32x2_t hi = vget_high_u32(mismatch_count_vec);\n        uint32x2_t sum2 = vadd_u32(lo, hi);\n        uint32x2_t sum = vpadd_u32(sum2, sum2);\n        change += vget_lane_u32(sum, 0);\n\n        i += 4;\n        j -= 4;\n    }\n\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            change++;\n        }\n        i++;\n        j--;\n    }\n\n    return change;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int i = 0, j = n - 1;\n    int changes = 0;\n\n    for (; j - i > 6; i += 4, j -= 4) {\n        int32x4_t front_vec = vld1q_s32(&arr[i]);\n        int32x4_t back_vec = vld1q_s32(&arr[j - 3]);\n        int32x4_t rev_back = vrev64q_s32(back_vec);\n        rev_back = vextq_s32(rev_back, rev_back, 2);\n        uint32x4_t cmp_mask = vceqq_s32(front_vec, rev_back);\n        int32x4_t tmp = vreinterpretq_s32_u32(cmp_mask);\n        int32x2_t low = vget_low_s32(tmp);\n        int32x2_t high = vget_high_s32(tmp);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int32x2_t sum_all = vpadd_s32(sum2, sum2);\n        int32_t sum_tmp = vget_lane_s32(sum_all, 0);\n        changes += (4 + sum_tmp);\n    }\n\n    while (i < j) {\n        if (arr[i] != arr[j]) {\n            changes++;\n        }\n        i++;\n        j--;\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    int i = 0;\n    int j = n - 1;\n    int changes = 0;\n\n    while (i < j) {\n        if (j - i + 1 >= 8) {\n            int32x4_t front = vld1q_s32(&arr[i]);\n            int32x4_t back = vld1q_s32(&arr[j - 3]);\n\n            uint8x16_t tmp_back = vreinterpretq_u8_s32(back);\n            tmp_back = vrev64q_u8(tmp_back);\n            tmp_back = vcombine_u8(vget_high_u8(tmp_back), vget_low_u8(tmp_back));\n            int32x4_t reversed_back = vreinterpretq_s32_u8(tmp_back);\n\n            uint32x4_t cmp = vreinterpretq_u32_s32(vceqq_s32(front, reversed_back));\n            uint32x4_t is_neq = vmvnq_u32(cmp);\n            is_neq = vshrq_n_u32(is_neq, 31);\n            changes += vaddvq_u32(is_neq);\n\n            i += 4;\n            j -= 4;\n        } else {\n            if (arr[i] != arr[j]) {\n                changes++;\n            }\n            i++;\n            j--;\n        }\n    }\n\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    uint64_t total1 = 0;\n    uint64_t total2 = 0;\n    size_t i;\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    uint64x2_t vsum1 = vdupq_n_u64(0);\n    uint64x2_t vsum2 = vdupq_n_u64(0);\n\n    for (i = 0; i + 1 < n1; i += 2) {\n        uint64_t len0 = lst1[i].length();\n        uint64_t len1_val = lst1[i+1].length();\n        uint64x2_t v = { len0, len1_val };\n        vsum1 = vaddq_u64(vsum1, v);\n    }\n    total1 = vgetq_lane_u64(vsum1, 0) + vgetq_lane_u64(vsum1, 1);\n    for (; i < n1; i++) {\n        total1 += lst1[i].length();\n    }\n\n    for (i = 0; i + 1 < n2; i += 2) {\n        uint64_t len0 = lst2[i].length();\n        uint64_t len1_val = lst2[i+1].length();\n        uint64x2_t v = { len0, len1_val };\n        vsum2 = vaddq_u64(vsum2, v);\n    }\n    total2 = vgetq_lane_u64(vsum2, 0) + vgetq_lane_u64(vsum2, 1);\n    for (; i < n2; i++) {\n        total2 += lst2[i].length();\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto compute_total = [](const std::vector<std::string>& lst) -> uint64_t {\n        size_t n = lst.size();\n        uint64_t total = 0;\n        if (n == 0) \n            return 0;\n        \n        uint64x2_t acc = vdupq_n_u64(0);\n        size_t i = 0;\n        for (; i + 1 < n; i += 2) {\n            uint64_t len0 = lst[i].size();\n            uint64_t len1 = lst[i+1].size();\n            uint64x2_t v = { len0, len1 };\n            acc = vaddq_u64(acc, v);\n        }\n        total = vgetq_lane_u64(acc, 0) + vgetq_lane_u64(acc, 1);\n        if (i < n) {\n            total += lst[i].size();\n        }\n        return total;\n    };\n\n    uint64_t total1 = compute_total(lst1);\n    uint64_t total2 = compute_total(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_length = [](const std::vector<std::string>& vec) -> uint64_t {\n        size_t n = vec.size();\n        if (n == 0) {\n            return 0;\n        }\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        size_t i = 0;\n        for (; i + 1 < n; i += 2) {\n            uint64_t len0 = vec[i].size();\n            uint64_t len1 = vec[i+1].size();\n            uint64x2_t v = vdupq_n_u64(0);\n            v = vsetq_lane_u64(len0, v, 0);\n            v = vsetq_lane_u64(len1, v, 1);\n            sum_vec = vaddq_u64(sum_vec, v);\n        }\n        uint64_t total = vgetq_lane_u64(sum_vec, 0) + vgetq_lane_u64(sum_vec, 1);\n        if (i < n) {\n            total += vec[i].size();\n        }\n        return total;\n    };\n\n    uint64_t total1 = total_length(lst1);\n    uint64_t total2 = total_length(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_chars = [](const std::vector<std::string>& lst) -> uint64_t {\n        size_t n = lst.size();\n        if (n == 0) \n            return 0;\n        uint64x2_t sum_vec = vdupq_n_u64(0);\n        size_t i = 0;\n        for (; i + 1 < n; i += 2) {\n            uint64_t len0 = lst[i].size();\n            uint64_t len1 = lst[i+1].size();\n            uint64_t temp[2] = {len0, len1};\n            uint64x2_t len_vec = vld1q_u64(temp);\n            sum_vec = vaddq_u64(sum_vec, len_vec);\n        }\n        uint64_t sum = vgetq_lane_u64(sum_vec, 0) + vgetq_lane_u64(sum_vec, 1);\n        if (i < n) {\n            sum += lst[i].size();\n        }\n        return sum;\n    };\n    uint64_t total1 = total_chars(lst1);\n    uint64_t total2 = total_chars(lst2);\n    return total1 <= total2 ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_98_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_length = [](const std::vector<std::string>& lst) -> size_t {\n        size_t total = 0;\n        const size_t len = lst.size();\n        size_t i = 0;\n\n        if (len >= 4) {\n            uint64x2_t vsum0 = vdupq_n_u64(0);\n            uint64x2_t vsum1 = vdupq_n_u64(0);\n            for (; i <= len - 4; i += 4) {\n                uint64_t lens0[2] = { static_cast<uint64_t>(lst[i].size()), \n                                     static_cast<uint64_t>(lst[i+1].size()) };\n                uint64_t lens1[2] = { static_cast<uint64_t>(lst[i+2].size()), \n                                     static_cast<uint64_t>(lst[i+3].size()) };\n                vsum0 = vaddq_u64(vsum0, vld1q_u64(lens0));\n                vsum1 = vaddq_u64(vsum1, vld1q_u64(lens1));\n            }\n            vsum0 = vaddq_u64(vsum0, vsum1);\n            total += vgetq_lane_u64(vsum0, 0) + vgetq_lane_u64(vsum0, 1);\n        }\n\n        for (; i < len; ++i) {\n            total += lst[i].size();\n        }\n\n        return total;\n    };\n\n    size_t total1 = total_length(lst1);\n    size_t total2 = total_length(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return (x == 0);\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 1) {\n        return false;\n    }\n\n    uint64_t base = 1;\n    for (int k0 = 1; k0 <= 64; k0 += 2) {\n        uint64_t p0 = base * n;\n        uint64_t p1 = p0 * n;\n\n        uint64x2_t v_power = {p0, p1};\n        uint64x2_t v_x = vdupq_n_u64(x);\n        uint64x2_t v_eq = vceqq_u64(v_power, v_x);\n\n        uint64_t eq[2];\n        vst1q_u64(eq, v_eq);\n\n        if (eq[0] || eq[1]) {\n            return true;\n        }\n\n        base = p1;\n\n        if (p1 == 0 || p1 > x) {\n            break;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 1) {\n        return true;\n    }\n    if (n == 1) {\n        return false;\n    }\n    \n    uint64_t current = 1;\n    for (uint64_t k = 1; k <= 64; k += 4) {\n        if (current > UINT64_MAX / n) {\n            break;\n        }\n        uint64_t base_chunk = current * n;\n        if (base_chunk > x) {\n            break;\n        }\n        \n        uint64_t p0 = base_chunk;\n        uint64_t p1 = (base_chunk <= UINT64_MAX / n) ? base_chunk * n : 0;\n        uint64_t p2 = 0;\n        uint64_t p3 = 0;\n        if (p1 != 0) {\n            if (p1 <= UINT64_MAX / n) {\n                p2 = p1 * n;\n            }\n        }\n        if (p2 != 0) {\n            if (p2 <= UINT64_MAX / n) {\n                p3 = p2 * n;\n            }\n        }\n        \n        uint64x2_t vec0 = {p0, p1};\n        uint64x2_t vec1 = {p2, p3};\n        uint64x2_t cmp0 = vceqq_u64(vec0, vdupq_n_u64(x));\n        uint64x2_t cmp1 = vceqq_u64(vec1, vdupq_n_u64(x));\n        uint64x2_t or_vec = vorrq_u64(cmp0, cmp1);\n        uint64_t or_low = vgetq_lane_u64(or_vec, 0);\n        uint64_t or_high = vgetq_lane_u64(or_vec, 1);\n        \n        if (or_low || or_high) {\n            return true;\n        }\n        \n        if (p1 == 0 || p2 == 0 || p3 == 0) {\n            break;\n        }\n        current = p3;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) {\n        return (n == 0);\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 0) {\n        return false;\n    }\n    if (n == 1) {\n        return false;\n    }\n\n    uint64_t n2 = n * n;\n    uint64x2_t v_power = vdupq_n_u64(0);\n    v_power = vsetq_lane_u64(n, v_power, 0);\n    v_power = vsetq_lane_u64(n2, v_power, 1);\n\n    for (int i = 0; i < 32; i++) {\n        uint64x2_t v_x = vdupq_n_u64(x);\n        uint64x2_t v_cmp = vceqq_u64(v_power, v_x);\n        uint64_t cmp0 = vgetq_lane_u64(v_cmp, 0);\n        uint64_t cmp1 = vgetq_lane_u64(v_cmp, 1);\n        if (cmp0 || cmp1) {\n            return true;\n        }\n\n        uint64_t power0 = vgetq_lane_u64(v_power, 0);\n        if (power0 == 0 || power0 > x) {\n            break;\n        }\n\n        v_power = vmulq_u64(v_power, vdupq_n_u64(n2));\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return (x == 0);\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 1) {\n        return false;\n    }\n    \n    uint64_t powers[4] = {0};\n    int count = 0;\n    uint64_t current = 1;\n    \n    for (int exp = 1; exp <= 64; exp++) {\n        uint64_t next = current * n;\n        if (next < current) {\n            break;\n        }\n        current = next;\n        powers[count] = current;\n        count++;\n        \n        if (count == 4) {\n            uint64x2_t v_pow1 = vld1q_u64(powers);\n            uint64x2_t v_pow2 = vld1q_u64(powers + 2);\n            uint64x2_t v_x = vdupq_n_u64(x);\n            \n            uint64x2_t v_cmp1 = vceqq_u64(v_pow1, v_x);\n            uint64x2_t v_cmp2 = vceqq_u64(v_pow2, v_x);\n            \n            uint64_t cmp1[2], cmp2[2];\n            vst1q_u64(cmp1, v_cmp1);\n            vst1q_u64(cmp2, v_cmp2);\n            \n            if (cmp1[0] || cmp1[1] || cmp2[0] || cmp2[1]) {\n                return true;\n            }\n            count = 0;\n        }\n    }\n    \n    for (int i = 0; i < count; i++) {\n        if (powers[i] == x) {\n            return true;\n        }\n    }\n    \n    return false;\n}\n```"}
{"task_id": "SimdBench_99_Neon", "completion": "```c\n#include <arm_neon.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) {\n        return n == 0;\n    }\n    if (n == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 1) {\n        return false;\n    }\n    \n    uint64_t max_exponent = 64;\n    uint64x2_t bases = vcombine_u64(vcreate_u64(1), vcreate_u64(n));\n    uint64_t n_squared = n * n;\n    uint64x2_t n_squared_vec = vdupq_n_u64(n_squared);\n\n    for (int i = 0; i <= max_exponent; i += 2) {\n        uint64x2_t current_bases = bases;\n        bases = vmulq_u64(bases, n_squared_vec);\n\n        uint64x2_t x_vec = vdupq_n_u64(x);\n        uint64x2_t cmp = vceqq_u64(current_bases, x_vec);\n        if (vgetq_lane_u64(cmp, 0) || vgetq_lane_u64(cmp, 1)) {\n            return true;\n        }\n\n        uint64x2_t gt = vcgtq_u64(current_bases, x_vec);\n        if (vgetq_lane_u64(gt, 0) && vgetq_lane_u64(gt, 1)) {\n            return false;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) return 0;\n    \n    const uint8_t *str = reinterpret_cast<const uint8_t*>(num.data());\n    size_t len = num.size();\n    size_t i = 0;\n    int total = 0;\n    \n    static const uint8_t prime_table_arr[16] = {\n        0, 0, 1, 1, 0, 1, 0, 1, \n        0, 0, 0, 1, 0, 1, 0, 0\n    };\n    uint8x16_t table = vld1q_u8(prime_table_arr);\n    uint8x16_t char0 = vdupq_n_u8('0');\n    uint8x16_t nine = vdupq_n_u8(9);\n    uint8x16_t seven = vdupq_n_u8(7);\n    \n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(str + i);\n        uint8x16_t step1 = vsubq_u8(input, char0);\n        uint8x16_t mask = vcgtq_u8(step1, nine);\n        uint8x16_t adjust = vandq_u8(seven, mask);\n        uint8x16_t index = vsubq_u8(step1, adjust);\n        uint8x16_t prime_flag = vqtbl1q_u8(table, index);\n        total += vaddvq_u8(prime_flag);\n    }\n    \n    for (; i < len; ++i) {\n        char c = num[i];\n        int idx;\n        if (c >= '0' && c <= '9') \n            idx = c - '0';\n        else \n            idx = c - 'A' + 10;\n        if (idx >= 0 && idx < 16 && prime_table_arr[idx]) \n            total++;\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint hex_key_simd(const std::string & num) {\n    int len = num.length();\n    if (len == 0) return 0;\n    const char* str = num.c_str();\n    int i = 0;\n    int count = 0;\n\n    const uint8x16_t v2 = vdupq_n_u8('2');\n    const uint8x16_t v3 = vdupq_n_u8('3');\n    const uint8x16_t v5 = vdupq_n_u8('5');\n    const uint8x16_t v7 = vdupq_n_u8('7');\n    const uint8x16_t vB = vdupq_n_u8('B');\n    const uint8x16_t vD = vdupq_n_u8('D');\n    const uint8x16_t v1 = vdupq_n_u8(1);\n\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n\n        uint8x16_t cmp2 = vceqq_u8(v, v2);\n        uint8x16_t cmp3 = vceqq_u8(v, v3);\n        uint8x16_t any = vorrq_u8(cmp2, cmp3);\n\n        uint8x16_t cmp5 = vceqq_u8(v, v5);\n        any = vorrq_u8(any, cmp5);\n\n        uint8x16_t cmp7 = vceqq_u8(v, v7);\n        any = vorrq_u8(any, cmp7);\n\n        uint8x16_t cmpB = vceqq_u8(v, vB);\n        any = vorrq_u8(any, cmpB);\n\n        uint8x16_t cmpD = vceqq_u8(v, vD);\n        any = vorrq_u8(any, cmpD);\n\n        any = vandq_u8(any, v1);\n        count += vaddvq_u8(any);\n    }\n\n    for (; i < len; i++) {\n        char c = str[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint hex_key_simd(const std::string & num){\n    int len = num.length();\n    if (len == 0) \n        return 0;\n    \n    const char* str = num.c_str();\n    int i = 0;\n    int count = 0;\n    \n    // Process 16 characters at a time\n    for (; i <= len - 16; i += 16) {\n        uint8x16_t v = vld1q_u8(reinterpret_cast<const uint8_t*>(str + i));\n        \n        // Compare with each prime digit and combine results\n        uint8x16_t mask = vceqq_u8(v, vdupq_n_u8('2'));\n        mask = vorrq_u8(mask, vceqq_u8(v, vdupq_n_u8('3')));\n        mask = vorrq_u8(mask, vceqq_u8(v, vdupq_n_u8('5')));\n        mask = vorrq_u8(mask, vceqq_u8(v, vdupq_n_u8('7')));\n        mask = vorrq_u8(mask, vceqq_u8(v, vdupq_n_u8('B')));\n        mask = vorrq_u8(mask, vceqq_u8(v, vdupq_n_u8('D')));\n        \n        // Convert 0xFF to 1, 0x00 to 0\n        mask = vshrq_n_u8(mask, 7);\n        \n        // Sum all 1s in the vector\n        count += vaddvq_u8(mask);\n    }\n    \n    // Process remaining characters\n    for (; i < len; i++) {\n        char c = str[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint hex_key_simd(const std::string & num){\n    const int len = num.length();\n    if (len == 0) {\n        return 0;\n    }\n    \n    uint64_t total_count = 0;\n    int i = 0;\n    \n    if (len >= 16) {\n        for (; i <= len - 16; i += 16) {\n            uint8x16_t v = vld1q_u8((const uint8_t*)&num[i]);\n            \n            uint8x16_t cmp2 = vceqq_u8(v, vdupq_n_u8('2'));\n            uint8x16_t cmp3 = vceqq_u8(v, vdupq_n_u8('3'));\n            uint8x16_t cmp5 = vceqq_u8(v, vdupq_n_u8('5'));\n            uint8x16_t cmp7 = vceqq_u8(v, vdupq_n_u8('7'));\n            uint8x16_t cmpB = vceqq_u8(v, vdupq_n_u8('B'));\n            uint8x16_t cmpD = vceqq_u8(v, vdupq_n_u8('D'));\n            \n            uint8x16_t any = vorrq_u8(cmp2, cmp3);\n            any = vorrq_u8(any, cmp5);\n            any = vorrq_u8(any, cmp7);\n            any = vorrq_u8(any, cmpB);\n            any = vorrq_u8(any, cmpD);\n            \n            any = vshrq_n_u8(any, 7);\n            \n            uint16x8_t low = vmovl_u8(vget_low_u8(any));\n            uint16x8_t high = vmovl_u8(vget_high_u8(any));\n            uint16x8_t sum8 = vaddq_u16(low, high);\n            \n            uint32x4_t sum32 = vpaddlq_u16(sum8);\n            uint64x2_t sum64 = vpaddlq_u32(sum32);\n            total_count += vgetq_lane_u64(sum64, 0) + vgetq_lane_u64(sum64, 1);\n        }\n    }\n    \n    for (; i < len; i++) {\n        char c = num[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            total_count++;\n        }\n    }\n    \n    return (int)total_count;\n}\n```"}
{"task_id": "SimdBench_100_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint hex_key_simd(const std::string & num){\n    const char* p = num.data();\n    int n = num.size();\n    int total = 0;\n    int i = 0;\n\n    if (n == 0) \n        return 0;\n\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t v = vld1q_u8((const uint8_t*)(p + i));\n\n        uint8x16_t cmp2 = vceqq_u8(v, vdupq_n_u8('2'));\n        uint8x16_t cmp3 = vceqq_u8(v, vdupq_n_u8('3'));\n        uint8x16_t cmp5 = vceqq_u8(v, vdupq_n_u8('5'));\n        uint8x16_t cmp7 = vceqq_u8(v, vdupq_n_u8('7'));\n        uint8x16_t cmpB = vceqq_u8(v, vdupq_n_u8('B'));\n        uint8x16_t cmpD = vceqq_u8(v, vdupq_n_u8('D'));\n\n        uint8x16_t any = vorrq_u8(cmp2, cmp3);\n        any = vorrq_u8(any, cmp5);\n        any = vorrq_u8(any, cmp7);\n        any = vorrq_u8(any, cmpB);\n        any = vorrq_u8(any, cmpD);\n\n        uint8x16_t t = vshrq_n_u8(any, 7);\n        uint16x8_t t0 = vpaddlq_u8(t);\n        uint32x4_t t1 = vpaddlq_u16(t0);\n        uint64x2_t t2 = vpaddlq_u32(t1);\n\n        total += vgetq_lane_u64(t2, 0) + vgetq_lane_u64(t2, 1);\n    }\n\n    for (; i < n; i++) {\n        char c = p[i];\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            total++;\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s){\n    size_t len = s.length();\n    if (len < 3) {\n        return false;\n    }\n    \n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t i = 0;\n    \n    while (i + 17 < len) {\n        uint8x16_t v0 = vld1q_u8(data + i);\n        uint8x16_t v1 = vld1q_u8(data + i + 1);\n        uint8x16_t v2 = vld1q_u8(data + i + 2);\n        \n        uint8x16_t eq01 = vceqq_u8(v0, v1);\n        uint8x16_t eq02 = vceqq_u8(v0, v2);\n        uint8x16_t eq12 = vceqq_u8(v1, v2);\n        \n        uint8x16_t orr = vorrq_u8(eq01, vorrq_u8(eq02, eq12));\n        if (vmaxvq_u8(orr) != 0) {\n            return false;\n        }\n        \n        i += 16;\n    }\n    \n    for (; i <= len - 3; i++) {\n        if (data[i] == data[i+1] || data[i] == data[i+2] || data[i+1] == data[i+2]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s) {\n    const size_t n = s.size();\n    if (n < 3) \n        return false;\n\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t i = 0;\n\n    for (; i + 17 < n; i += 16) {\n        uint8x16_t v0 = vld1q_u8(data + i);\n        uint8x16_t v1 = vld1q_u8(data + i + 1);\n        uint8x16_t v2 = vld1q_u8(data + i + 2);\n\n        uint8x16_t eq1 = vceqq_u8(v0, v1);\n        uint8x16_t eq2 = vceqq_u8(v0, v2);\n        uint8x16_t eq3 = vceqq_u8(v1, v2);\n\n        uint8x16_t eq_any = vorrq_u8(vorrq_u8(eq1, eq2), eq3);\n\n        if (vmaxvq_u8(eq_any) != 0) {\n            return false;\n        }\n    }\n\n    for (; i <= n - 3; ++i) {\n        if (data[i] == data[i+1] || data[i] == data[i+2] || data[i+1] == data[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) \n        return false;\n\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    size_t i = 0;\n\n    for (; i + 17 < n; i += 16) {\n        uint8x16_t v0 = vld1q_u8(data + i);\n        uint8x16_t v1 = vld1q_u8(data + i + 1);\n        uint8x16_t v2 = vld1q_u8(data + i + 2);\n\n        uint8x16_t eq01 = vceqq_u8(v0, v1);\n        uint8x16_t eq02 = vceqq_u8(v0, v2);\n        uint8x16_t eq12 = vceqq_u8(v1, v2);\n\n        uint8x16_t eq_any = vorrq_u8(eq01, vorrq_u8(eq02, eq12));\n\n        if (vmaxvq_u8(eq_any) != 0) {\n            return false;\n        }\n    }\n\n    for (; i <= n - 3; ++i) {\n        if (data[i] == data[i+1] || data[i] == data[i+2] || data[i+1] == data[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    int n = s.size();\n    if (n < 3) {\n        return false;\n    }\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    int i = 0;\n\n    for (; i <= n - 18; i += 16) {\n        uint8x16_t v0 = vld1q_u8(data + i);\n        uint8x16_t v1 = vld1q_u8(data + i + 1);\n        uint8x16_t v2 = vld1q_u8(data + i + 2);\n\n        uint8x16_t eq01 = vceqq_u8(v0, v1);\n        uint8x16_t eq02 = vceqq_u8(v0, v2);\n        uint8x16_t eq12 = vceqq_u8(v1, v2);\n        uint8x16_t or_result = vorrq_u8(vorrq_u8(eq01, eq02), eq12);\n\n        if (vmaxvq_u8(or_result) != 0) {\n            return false;\n        }\n    }\n\n    for (; i <= n - 3; ++i) {\n        if (data[i] == data[i+1] || data[i] == data[i+2] || data[i+1] == data[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.length();\n    if (n < 3) {\n        return false;\n    }\n\n    size_t i = 0;\n    if (n >= 18) {\n        for (; i <= n - 18; i += 16) {\n            uint8x16_t v0 = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n            uint8x16_t v1 = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i + 1));\n            uint8x16_t v2 = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i + 2));\n\n            uint8x16_t cmp1 = vceqq_u8(v0, v1);\n            uint8x16_t cmp2 = vceqq_u8(v0, v2);\n            uint8x16_t cmp3 = vceqq_u8(v1, v2);\n\n            uint8x16_t any_fail = vorrq_u8(cmp1, vorrq_u8(cmp2, cmp3));\n\n            uint64x2_t pairwise = vreinterpretq_u64_u8(any_fail);\n            uint64_t low = vgetq_lane_u64(pairwise, 0);\n            uint64_t high = vgetq_lane_u64(pairwise, 1);\n\n            if (low || high) {\n                return false;\n            }\n        }\n    }\n\n    for (; i <= n - 3; i++) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cstdint>\n\nbool prime_length_simd(const std::string & str){\n    size_t n = str.size();\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    if (n <= UINT32_MAX) {\n        uint32_t n32 = static_cast<uint32_t>(n);\n        uint32_t d = 3;\n        while (true) {\n            uint32_t divisors_arr[4] = {d, d+2, d+4, d+6};\n            uint32x4_t divs = vld1q_u32(divisors_arr);\n            uint32x4_t squares = vmulq_u32(divs, divs);\n            uint32x4_t n_vec = vdupq_n_u32(n32);\n            uint32x4_t cmp = vcleq_u32(squares, n_vec);\n\n            uint32x2_t cmp_low = vget_low_u32(cmp);\n            uint32x2_t cmp_high = vget_high_u32(cmp);\n            uint32x2_t cmp_or = vorr_u32(cmp_low, cmp_high);\n            uint32_t any = vget_lane_u32(vpmax_u32(cmp_or, cmp_or), 0);\n            if (any == 0) {\n                break;\n            }\n\n            uint32_t cmp_arr[4];\n            vst1q_u32(cmp_arr, cmp);\n            for (int i = 0; i < 4; ++i) {\n                if (cmp_arr[i]) {\n                    if (n % divisors_arr[i] == 0) {\n                        return false;\n                    }\n                }\n            }\n            d += 8;\n        }\n    } else {\n        uint64_t d = 3;\n        while (true) {\n            uint64_t divisors_arr[2] = {d, d+2};\n            uint64x2_t divs = vld1q_u64(divisors_arr);\n            uint64x2_t squares = vmulq_u64(divs, divs);\n            uint64x2_t n_vec = vdupq_n_u64(n);\n            uint64x2_t cmp = vcleq_u64(squares, n_vec);\n\n            uint64_t cmp0 = vgetq_lane_u64(cmp, 0);\n            uint64_t cmp1 = vgetq_lane_u64(cmp, 1);\n            if (!cmp0 && !cmp1) {\n                break;\n            }\n\n            if (cmp0) {\n                if (n % d == 0) {\n                    return false;\n                }\n            }\n            if (cmp1) {\n                if (n % (d+2) == 0) {\n                    return false;\n                }\n            }\n            d += 4;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool prime_length_simd(const std::string & str){\n    size_t len = str.length();\n    if (len <= 1) {\n        return false;\n    }\n    if (len == 2) {\n        return true;\n    }\n    if (len % 2 == 0) {\n        return false;\n    }\n\n    uint32_t n = static_cast<uint32_t>(len);\n    uint32_t lo = 1;\n    uint32_t hi = n;\n    uint32_t max_div = 0;\n    while (lo <= hi) {\n        uint32_t mid = lo + (hi - lo) / 2;\n        if (mid <= n / mid) {\n            max_div = mid;\n            lo = mid + 1;\n        } else {\n            hi = mid - 1;\n        }\n    }\n\n    if (max_div < 3) {\n        return true;\n    }\n\n    for (uint32_t base = 3; base <= max_div; base += 8) {\n        uint32_t d[4] = {base, base+2, base+4, base+6};\n        uint32_t r[4];\n        for (int i = 0; i < 4; i++) {\n            if (d[i] <= max_div) {\n                r[i] = n % d[i];\n            } else {\n                r[i] = 1;\n            }\n        }\n\n        uint32x4_t rems = vld1q_u32(r);\n        uint32x4_t zeros = vdupq_n_u32(0);\n        uint32x4_t cmp = vceqq_u32(rems, zeros);\n        \n        uint32x2_t low = vget_low_u32(cmp);\n        uint32x2_t high = vget_high_u32(cmp);\n        uint32x2_t reduced = vorr_u32(low, high);\n        uint32_t result = vget_lane_u32(reduced, 0) | vget_lane_u32(reduced, 1);\n\n        if (result != 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <cstdint>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len == 0) {\n        return false;\n    }\n    if (len > UINT32_MAX) {\n        if (len < 2) return false;\n        if (len == 2) return true;\n        if (len % 2 == 0) return false;\n        for (uint64_t d = 3; d * d <= len; d += 2) {\n            if (len % d == 0) return false;\n        }\n        return true;\n    }\n    uint32_t n = static_cast<uint32_t>(len);\n    if (n < 2) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    uint32_t root = static_cast<uint32_t>(std::sqrt(n));\n    uint32_t i = 3;\n    while (i <= root) {\n        uint32_t divisors[4] = {i, i+2, i+4, i+6};\n        uint32x4_t v_d = vld1q_u32(divisors);\n        uint32x4_t v_bound = vdupq_n_u32(root);\n        uint32x4_t v_mask = vcleq_u32(v_d, v_bound);\n        uint32x4_t v_d_clamped = vbslq_u32(v_mask, v_d, vdupq_n_u32(1));\n        uint32_t rem[4];\n        for (int j = 0; j < 4; ++j) {\n            uint32_t d = vgetq_lane_u32(v_d_clamped, j);\n            rem[j] = (d == 1) ? 1 : n % d;\n        }\n        uint32x4_t v_rem = vld1q_u32(rem);\n        uint32x4_t v_zero = vdupq_n_u32(0);\n        uint32x4_t v_cmp = vceqq_u32(v_rem, v_zero);\n        if (vmaxvq_u32(v_cmp) != 0) {\n            return false;\n        }\n        i += 8;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t n = str.size();\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    uint32_t un = static_cast<uint32_t>(n);\n    uint32_t limit = static_cast<uint32_t>(std::sqrt(un));\n\n    for (uint32_t d = 3; d <= limit; d += 8) {\n        uint32_t divs[4] = {d, d+2, d+4, d+6};\n        uint32_t rems[4] = {1, 1, 1, 1};\n\n        for (int i = 0; i < 4; i++) {\n            if (divs[i] <= limit) {\n                rems[i] = un % divs[i];\n            }\n        }\n\n        uint32x4_t rem_vec = vld1q_u32(rems);\n        uint32x4_t zero = vdupq_n_u32(0);\n        uint32x4_t cmp = vceqq_u32(rem_vec, zero);\n        uint32_t any_div = vmaxvq_u32(cmp);\n\n        if (any_div) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <cstdint>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t len = str.length();\n    if (len <= 1) {\n        return false;\n    }\n    if (len == 2) {\n        return true;\n    }\n    if (len % 2 == 0) {\n        return false;\n    }\n\n    if (len > UINT32_MAX) {\n        return false;\n    }\n    uint32_t n = static_cast<uint32_t>(len);\n    uint32_t limit = static_cast<uint32_t>(std::sqrt(n));\n\n    uint32_t base = 3;\n    while (base <= limit) {\n        uint32_t divisors[4] = {base, base + 2, base + 4, base + 6};\n        uint32_t mods[4] = {1, 1, 1, 1};\n\n        for (int i = 0; i < 4; ++i) {\n            if (divisors[i] <= limit) {\n                mods[i] = n % divisors[i];\n            }\n        }\n\n        uint32x4_t mod_vec = vld1q_u32(mods);\n        uint32x4_t zero_vec = vdupq_n_u32(0);\n        uint32x4_t cmp_vec = vceqq_u32(mod_vec, zero_vec);\n        if (vmaxvq_u32(cmp_vec) != 0) {\n            return false;\n        }\n\n        base += 8;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <string>\n#include <cstring>\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N) {\n    std::string s = std::to_string(N);\n    int len = s.length();\n    uint32_t total_sum = 0;\n\n    for (int i = 0; i < len; i += 16) {\n        int chunk_size = (len - i) < 16 ? (len - i) : 16;\n        uint8_t buffer[16] = {0};\n        for (int j = 0; j < chunk_size; j++) {\n            buffer[j] = s[i + j];\n        }\n\n        uint8x16_t v_chars = vld1q_u8(buffer);\n        uint8x16_t v_zeros = vdupq_n_u8('0');\n        uint8x16_t digits = vsubq_u8(v_chars, v_zeros);\n        total_sum += vaddlvq_u8(digits);\n    }\n\n    if (total_sum == 0) {\n        return \"0\";\n    }\n\n    std::string bin;\n    while (total_sum) {\n        bin = char('0' + (total_sum & 1)) + bin;\n        total_sum >>= 1;\n    }\n    return bin;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(uint64_t N) {\n    if (N == 0) {\n        return \"0\";\n    }\n\n    uint8_t digits[20];\n    int count = 0;\n    uint64_t temp = N;\n    while (temp) {\n        digits[count++] = temp % 10;\n        temp /= 10;\n    }\n\n    uint32_t total = 0;\n    int i = 0;\n    while (i < count) {\n        int remaining = count - i;\n        if (remaining >= 16) {\n            uint8x16_t v = vld1q_u8(digits + i);\n            total += vaddlvq_u8(v);\n            i += 16;\n        } else {\n            uint8_t buffer[16] = {0};\n            for (int j = 0; j < remaining; j++) {\n                buffer[j] = digits[i + j];\n            }\n            uint8x16_t v = vld1q_u8(buffer);\n            total += vaddlvq_u8(v);\n            i = count;\n        }\n    }\n\n    if (total == 0) {\n        return \"0\";\n    }\n    std::string res;\n    uint32_t num = total;\n    while (num) {\n        res = char('0' + (num & 1)) + res;\n        num >>= 1;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <string>\n#include <cstdint>\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N) {\n    std::string digits = std::to_string(N);\n    int len = digits.length();\n    if (len == 0) {\n        return \"0\";\n    }\n\n    const int block_size = 16;\n    uint32x4_t sum_vec = vdupq_n_u32(0);\n    int i = 0;\n\n    for (; i <= len - block_size; i += block_size) {\n        uint8x16_t in = vld1q_u8(reinterpret_cast<const uint8_t*>(digits.data() + i));\n        uint8x16_t digits_vec = vsubq_u8(in, vdupq_n_u8('0'));\n        uint16x8_t temp = vpaddlq_u8(digits_vec);\n        uint32x4_t temp2 = vpaddlq_u16(temp);\n        sum_vec = vaddq_u32(sum_vec, temp2);\n    }\n\n    uint32_t total_arr[4];\n    vst1q_u32(total_arr, sum_vec);\n    uint32_t total = total_arr[0] + total_arr[1] + total_arr[2] + total_arr[3];\n\n    for (; i < len; i++) {\n        total += (digits[i] - '0');\n    }\n\n    if (total == 0) {\n        return \"0\";\n    }\n\n    std::string bin_str;\n    while (total) {\n        bin_str = static_cast<char>('0' + (total & 1)) + bin_str;\n        total >>= 1;\n    }\n    return bin_str;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(uint64_t N) {\n    if (N == 0) {\n        return \"0\";\n    }\n\n    uint8_t digits[20] = {0};\n    int num_digits = 0;\n    uint64_t num = N;\n    while (num) {\n        digits[num_digits++] = num % 10;\n        num /= 10;\n    }\n\n    uint8x16_t sum_vec = vdupq_n_u8(0);\n    int i = 0;\n\n    while (i + 16 <= num_digits) {\n        uint8x16_t chunk = vld1q_u8(digits + i);\n        sum_vec = vaddq_u8(sum_vec, chunk);\n        i += 16;\n    }\n\n    if (i < num_digits) {\n        uint8_t buffer[16] = {0};\n        for (int j = 0; j < num_digits - i; ++j) {\n            buffer[j] = digits[i + j];\n        }\n        uint8x16_t chunk = vld1q_u8(buffer);\n        sum_vec = vaddq_u8(sum_vec, chunk);\n    }\n\n    uint32_t total = vaddlvq_u8(sum_vec);\n\n    if (total == 0) {\n        return \"0\";\n    }\n\n    std::string bin_str;\n    while (total) {\n        bin_str = static_cast<char>('0' + (total & 1)) + bin_str;\n        total >>= 1;\n    }\n\n    return bin_str;\n}\n```"}
{"task_id": "SimdBench_103_Neon", "completion": "```cpp\n#include <string>\n#include <arm_neon.h>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t tempN = N;\n    uint8_t digits[20] = {0};\n    int i = 0;\n\n    if (tempN == 0) {\n        digits[i++] = 0;\n    } else {\n        while (tempN) {\n            digits[i++] = tempN % 10;\n            tempN /= 10;\n        }\n    }\n\n    uint8x16_t vsum = vdupq_n_u8(0);\n    int j = 0;\n    for (; j + 16 <= i; j += 16) {\n        uint8x16_t v = vld1q_u8(digits + j);\n        vsum = vaddq_u8(vsum, v);\n    }\n\n    if (j < i) {\n        uint8_t tail[16] = {0};\n        for (int k = 0; k < i - j; k++) {\n            tail[k] = digits[j + k];\n        }\n        uint8x16_t vtail = vld1q_u8(tail);\n        vsum = vaddq_u8(vsum, vtail);\n    }\n\n    uint16x8_t vsum16 = vpaddlq_u8(vsum);\n    uint32x4_t vsum32 = vpaddlq_u16(vsum16);\n    uint32_t total = vaddvq_u32(vsum32);\n\n    if (total == 0) {\n        return \"0\";\n    }\n\n    std::string bin;\n    while (total) {\n        bin = char('0' + (total & 1)) + bin;\n        total >>= 1;\n    }\n    return bin;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    int sum = 0;\n    int i = 0;\n    \n    const uint32_t pattern_arr[4] = {0, 1, 0, 1};\n    uint32x4_t pattern = vld1q_u32(pattern_arr);\n    \n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        \n        uint32_t base_parity = i & 1;\n        uint32x4_t base_parity_vec = vdupq_n_u32(base_parity);\n        uint32x4_t parity_vec = veorq_u32(base_parity_vec, pattern);\n        uint32x4_t odd_index_mask = vceqq_u32(parity_vec, vdupq_n_u32(1));\n        \n        int32x4_t ones = vdupq_n_s32(1);\n        int32x4_t lsb = vandq_s32(data, ones);\n        uint32x4_t even_element_mask = vceqq_s32(lsb, vdupq_n_s32(0));\n        \n        uint32x4_t combined_mask = vandq_u32(odd_index_mask, even_element_mask);\n        int32x4_t selected = vandq_s32(data, vreinterpretq_s32_u32(combined_mask));\n        \n        int32x2_t low = vget_low_s32(selected);\n        int32x2_t high = vget_high_s32(selected);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int32x2_t sum2_final = vpadd_s32(sum2, sum2);\n        sum += vget_lane_s32(sum2_final, 0);\n    }\n    \n    for (; i < n; i++) {\n        if (i % 2 == 1 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    const int* data = lst.data();\n    int32x2_t acc = vdup_n_s32(0);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(data + i);\n        int32x2_t low = vget_low_s32(chunk);\n        int32x2_t high = vget_high_s32(chunk);\n        int32x2x2_t deinter = vuzp_s32(low, high);\n        int32x2_t odd_vec = deinter.val[1];\n        int32x2_t mod2 = vand_s32(odd_vec, vdup_n_s32(1));\n        uint32x2_t mask = vceq_s32(mod2, vdup_n_s32(0));\n        int32x2_t even_vals = vand_s32(odd_vec, vreinterpret_s32_u32(mask));\n        acc = vadd_s32(acc, even_vals);\n    }\n\n    int sum = vget_lane_s32(acc, 0) + vget_lane_s32(acc, 1);\n\n    for (int j = i + 1; j < n; j += 2) {\n        if ((data[j] & 1) == 0) {\n            sum += data[j];\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n    int32_t *p = lst.data();\n    int i = 0;\n    int32x4_t vsum = vdupq_n_s32(0);\n\n    for (; i <= n - 8; i += 8, p += 8) {\n        int32x4x2_t v = vld2q_s32(p);\n        int32x4_t odd_vec = v.val[1];\n        int32x4_t lsb = vandq_s32(odd_vec, vdupq_n_s32(1));\n        uint32x4_t mask = vceqq_s32(lsb, vdupq_n_s32(0));\n        int32x4_t masked = vandq_s32(odd_vec, vreinterpretq_s32_u32(mask));\n        vsum = vaddq_s32(vsum, masked);\n    }\n\n    int32_t sum_arr[4];\n    vst1q_s32(sum_arr, vsum);\n    int sum = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n\n    p = lst.data() + i;\n    int remaining = n - i;\n    for (int j = 1; j < remaining; j += 2) {\n        int val = p[j];\n        if ((val & 1) == 0) {\n            sum += val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    int i = 0;\n    int32x2_t acc = vdup_n_s32(0);\n    for (; i + 3 < n; i += 4) {\n        int32x2x2_t deint = vld2_s32(reinterpret_cast<const int32_t*>(&lst[i]));\n        int32x2_t ones = vdup_n_s32(1);\n        int32x2_t anded = vand_s32(deint.val[1], ones);\n        uint32x2_t mask = vceq_s32(anded, vdup_n_s32(0));\n        int32x2_t vals = vand_s32(deint.val[1], vreinterpret_s32_u32(mask));\n        acc = vadd_s32(acc, vals);\n    }\n    int sum = vget_lane_s32(acc, 0) + vget_lane_s32(acc, 1);\n    for (int j = i + 1; j < n; j += 2) {\n        if ((lst[j] & 1) == 0) {\n            sum += lst[j];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    int sum = 0;\n    int i = 0;\n\n    uint32x4_t pos_mask = vmovq_n_u32(0);\n    pos_mask = vsetq_lane_u32(0xFFFFFFFF, pos_mask, 1);\n    pos_mask = vsetq_lane_u32(0xFFFFFFFF, pos_mask, 3);\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t chunk = vld1q_s32(&lst[i]);\n        int32x4_t ones = vdupq_n_s32(1);\n        int32x4_t lsb = vandq_s32(chunk, ones);\n        uint32x4_t even_mask = vceqq_s32(lsb, vdupq_n_s32(0));\n        uint32x4_t combined_mask = vandq_u32(even_mask, pos_mask);\n        int32x4_t selected = vandq_s32(chunk, (int32x4_t)combined_mask);\n\n        int32x2_t low = vget_low_s32(selected);\n        int32x2_t high = vget_high_s32(selected);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int s = vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n        sum += s;\n    }\n\n    for (; i < n; i++) {\n        if (i & 1) {\n            if ((lst[i] & 1) == 0) {\n                sum += lst[i];\n            }\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s){\n    std::string result(s.length(), '\\0');\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&result[0]);\n    size_t len = s.length();\n    size_t i = 0;\n\n    uint8x16_t base = vdupq_n_u8('a');\n    uint8x16_t mod_val = vdupq_n_u8(26);\n    uint8x16_t four = vdupq_n_u8(4);\n    uint8x16_t a_char = vdupq_n_u8('a');\n    uint8x16_t z_char = vdupq_n_u8('z');\n\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t vec = vld1q_u8(src + i);\n        uint8x16_t mask_letter = vandq_u8(\n            vcgeq_u8(vec, a_char),\n            vcleq_u8(vec, z_char)\n        );\n        uint8x16_t temp = vsubq_u8(vec, base);\n        uint8x16_t temp_plus4 = vaddq_u8(temp, four);\n        uint8x16_t mask_overflow = vcgeq_u8(temp_plus4, mod_val);\n        uint8x16_t correction = vandq_u8(mask_overflow, mod_val);\n        uint8x16_t temp_final = vsubq_u8(temp_plus4, correction);\n        uint8x16_t rotated = vaddq_u8(temp_final, base);\n        uint8x16_t res = vbslq_u8(mask_letter, rotated, vec);\n        vst1q_u8(dst + i, res);\n    }\n\n    for (; i < len; i++) {\n        uint8_t c = src[i];\n        if (c >= 'a' && c <= 'z') {\n            uint8_t rotated = c + 4;\n            if (rotated > 'z') {\n                rotated -= 26;\n            }\n            dst[i] = rotated;\n        } else {\n            dst[i] = c;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <string>\n#include <arm_neon.h>\n\nstd::string encrypt_simd(const std::string & s) {\n    if (s.empty()) return s;\n    std::string result(s.size(), '\\0');\n    size_t i = 0;\n    const uint8_t mod_val = 26;\n    const uint8x16_t a_vec = vdupq_n_u8('a');\n    const uint8x16_t shift_vec = vdupq_n_u8(4);\n    const uint8x16_t mod_vec = vdupq_n_u8(mod_val);\n\n    for (; i + 16 <= s.size(); i += 16) {\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(&s[i]));\n        data = vsubq_u8(data, a_vec);\n        data = vaddq_u8(data, shift_vec);\n        uint8x16_t mask = vcgeq_u8(data, mod_vec);\n        uint8x16_t adjust = vandq_u8(mask, mod_vec);\n        data = vsubq_u8(data, adjust);\n        data = vaddq_u8(data, a_vec);\n        vst1q_u8(reinterpret_cast<uint8_t*>(&result[i]), data);\n    }\n\n    for (; i < s.size(); ++i) {\n        uint8_t c = s[i] - 'a';\n        c += 4;\n        if (c >= mod_val) c -= mod_val;\n        result[i] = c + 'a';\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string result(s.length(), ' ');\n    const size_t len = s.length();\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&result[0]);\n\n    const uint8x16_t four = vdupq_n_u8(4);\n    const uint8x16_t z_char = vdupq_n_u8('z');\n    const uint8x16_t twenty_six = vdupq_n_u8(26);\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        uint8x16_t shifted = vaddq_u8(data, four);\n        uint8x16_t mask = vcgtq_u8(shifted, z_char);\n        uint8x16_t adjustment = vandq_u8(mask, twenty_six);\n        shifted = vsubq_u8(shifted, adjustment);\n        vst1q_u8(dst + i, shifted);\n    }\n\n    for (; i < len; ++i) {\n        uint8_t c = src[i];\n        c += 4;\n        if (c > 'z') {\n            c -= 26;\n        }\n        dst[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    std::string res(s.length(), ' ');\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&res[0]);\n    \n    size_t len = s.length();\n    size_t i = 0;\n    \n    // Process 16 bytes at a time\n    for (; i + 16 <= len; i += 16) {\n        // Load 16 characters\n        uint8x16_t vec = vld1q_u8(src + i);\n        // Add 4 to each character\n        vec = vaddq_u8(vec, vdupq_n_u8(4));\n        // Check which characters exceed 'z' (122)\n        uint8x16_t mask = vcgtq_u8(vec, vdupq_n_u8('z'));\n        // Subtract 26 where mask is true (wrapping the alphabet)\n        vec = vsubq_u8(vec, vandq_u8(mask, vdupq_n_u8(26)));\n        // Store the result\n        vst1q_u8(dst + i, vec);\n    }\n    \n    // Process remaining bytes\n    for (; i < len; ++i) {\n        uint8_t c = src[i] + 4;\n        if (c > 'z') {\n            c -= 26;\n        }\n        dst[i] = c;\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_105_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    if (s.empty()) {\n        return \"\";\n    }\n    \n    std::string res(s.length(), '\\0');\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&res[0]);\n    size_t i = 0;\n    const size_t chunk_size = 16;\n    size_t n = s.length();\n    \n    for (; i + chunk_size <= n; i += chunk_size) {\n        uint8x16_t data = vld1q_u8(src + i);\n        uint8x16_t mask_a = vcgeq_u8(data, vdupq_n_u8('a'));\n        uint8x16_t mask_z = vcleq_u8(data, vdupq_n_u8('z'));\n        uint8x16_t mask_letter = vandq_u8(mask_a, mask_z);\n        uint8x16_t transformed = vaddq_u8(data, vandq_u8(mask_letter, vdupq_n_u8(4)));\n        uint8x16_t mask_sub = vandq_u8(vcgtq_u8(transformed, vdupq_n_u8('z')), mask_letter);\n        transformed = vsubq_u8(transformed, vandq_u8(mask_sub, vdupq_n_u8(26)));\n        vst1q_u8(dst + i, transformed);\n    }\n    \n    for (; i < n; i++) {\n        uint8_t c = src[i];\n        if (c >= 'a' && c <= 'z') {\n            c += 4;\n            if (c > 'z') {\n                c -= 26;\n            }\n        }\n        dst[i] = c;\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    if (message.empty()) return \"\";\n    \n    std::string result;\n    result.resize(message.size());\n    \n    const uint8_t *data = reinterpret_cast<const uint8_t*>(message.data());\n    uint8_t *out = reinterpret_cast<uint8_t*>(&result[0]);\n    size_t i = 0;\n    size_t len = message.size();\n    \n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input_vec = vld1q_u8(data + i);\n        \n        uint8x16_t ge_A = vcgeq_u8(input_vec, vdupq_n_u8('A'));\n        uint8x16_t le_Z = vcleq_u8(input_vec, vdupq_n_u8('Z'));\n        uint8x16_t is_upper = vandq_u8(ge_A, le_Z);\n        \n        uint8x16_t ge_a = vcgeq_u8(input_vec, vdupq_n_u8('a'));\n        uint8x16_t le_z = vcleq_u8(input_vec, vdupq_n_u8('z'));\n        uint8x16_t is_lower = vandq_u8(ge_a, le_z);\n        \n        uint8x16_t is_letter = vorrq_u8(is_upper, is_lower);\n        uint8x16_t swap_mask = vandq_u8(vdupq_n_u8(0x20), is_letter);\n        uint8x16_t swapped_vec = veorq_u8(input_vec, swap_mask);\n        \n        uint8x16_t swapped_low = vorrq_u8(swapped_vec, vdupq_n_u8(0x20));\n        uint8x16_t is_a = vceqq_u8(swapped_low, vdupq_n_u8('a'));\n        uint8x16_t is_e = vceqq_u8(swapped_low, vdupq_n_u8('e'));\n        uint8x16_t is_i = vceqq_u8(swapped_low, vdupq_n_u8('i'));\n        uint8x16_t is_o = vceqq_u8(swapped_low, vdupq_n_u8('o'));\n        uint8x16_t is_u = vceqq_u8(swapped_low, vdupq_n_u8('u'));\n        \n        uint8x16_t is_vowel = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(is_a, is_e), is_i), vorrq_u8(is_o, is_u));\n        is_vowel = vandq_u8(is_vowel, is_letter);\n        uint8x16_t result_vec = vaddq_u8(swapped_vec, vandq_u8(vdupq_n_u8(2), is_vowel));\n        \n        vst1q_u8(out + i, result_vec);\n    }\n    \n    for (; i < len; ++i) {\n        uint8_t c = data[i];\n        if (('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z')) {\n            uint8_t swapped = c ^ 0x20;\n            uint8_t low = swapped | 0x20;\n            if (low == 'a' || low == 'e' || low == 'i' || low == 'o' || low == 'u') {\n                out[i] = swapped + 2;\n            } else {\n                out[i] = swapped;\n            }\n        } else {\n            out[i] = c;\n        }\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result(message.size(), '\\0');\n    size_t i = 0;\n    const uint8_t* src = reinterpret_cast<const uint8_t*>(message.data());\n    uint8_t* dst = reinterpret_cast<uint8_t*>(&result[0]);\n\n    for (; i + 16 <= message.size(); i += 16) {\n        uint8x16_t data = vld1q_u8(src + i);\n        uint8x16_t swapped = veorq_u8(data, vdupq_n_u8(0x20));\n        uint8x16_t base = vandq_u8(swapped, vdupq_n_u8(0xDF));\n        \n        uint8x16_t mask = vceqq_u8(base, vdupq_n_u8('A'));\n        mask = vorrq_u8(mask, vceqq_u8(base, vdupq_n_u8('E')));\n        mask = vorrq_u8(mask, vceqq_u8(base, vdupq_n_u8('I')));\n        mask = vorrq_u8(mask, vceqq_u8(base, vdupq_n_u8('O')));\n        mask = vorrq_u8(mask, vceqq_u8(base, vdupq_n_u8('U')));\n        \n        uint8x16_t add_mask = vandq_u8(mask, vdupq_n_u8(2));\n        uint8x16_t result_vec = vaddq_u8(swapped, add_mask);\n        vst1q_u8(dst + i, result_vec);\n    }\n\n    for (; i < message.size(); ++i) {\n        uint8_t c = src[i];\n        uint8_t swapped = c ^ 0x20;\n        uint8_t base = swapped & 0xDF;\n        if (base == 'A' || base == 'E' || base == 'I' || base == 'O' || base == 'U') {\n            dst[i] = swapped + 2;\n        } else {\n            dst[i] = swapped;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.size();\n    std::string result(len, '\\0');\n    const uint8_t* in = reinterpret_cast<const uint8_t*>(message.data());\n    uint8_t* out = reinterpret_cast<uint8_t*>(&result[0]);\n\n    size_t i = 0;\n    const int vec_size = 16;\n    for (; i + vec_size <= len; i += vec_size) {\n        uint8x16_t vec = vld1q_u8(in + i);\n        uint8x16_t swapped = veorq_u8(vec, vdupq_n_u8(32));\n        uint8x16_t lowcase = vorrq_u8(swapped, vdupq_n_u8(32));\n        \n        uint8x16_t mask_a = vceqq_u8(lowcase, vdupq_n_u8('a'));\n        uint8x16_t mask_e = vceqq_u8(lowcase, vdupq_n_u8('e'));\n        uint8x16_t mask_i = vceqq_u8(lowcase, vdupq_n_u8('i'));\n        uint8x16_t mask_o = vceqq_u8(lowcase, vdupq_n_u8('o'));\n        uint8x16_t mask_u = vceqq_u8(lowcase, vdupq_n_u8('u'));\n        \n        uint8x16_t vowel_mask = vorrq_u8(mask_a, vorrq_u8(mask_e, vorrq_u8(mask_i, vorrq_u8(mask_o, mask_u))));\n        uint8x16_t res = vaddq_u8(swapped, vandq_u8(vdupq_n_u8(2), vowel_mask));\n        \n        vst1q_u8(out + i, res);\n    }\n\n    for (; i < len; ++i) {\n        uint8_t c = in[i];\n        c ^= 32;\n        uint8_t low = c | 32;\n        if (low == 'a' || low == 'e' || low == 'i' || low == 'o' || low == 'u') {\n            c += 2;\n        }\n        out[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    if (message.empty()) {\n        return message;\n    }\n    std::string output(message.size(), '\\0');\n    const uint8_t* in_data = reinterpret_cast<const uint8_t*>(message.data());\n    uint8_t* out_data = reinterpret_cast<uint8_t*>(&output[0]);\n    size_t i = 0;\n    for (; i + 16 <= message.size(); i += 16) {\n        uint8x16_t input_vec = vld1q_u8(in_data + i);\n        uint8x16_t mask_upper = vandq_u8(\n            vcgeq_u8(input_vec, vdupq_n_u8('A')),\n            vcleq_u8(input_vec, vdupq_n_u8('Z'))\n        );\n        uint8x16_t mask_lower = vandq_u8(\n            vcgeq_u8(input_vec, vdupq_n_u8('a')),\n            vcleq_u8(input_vec, vdupq_n_u8('z'))\n        );\n        uint8x16_t mask_letter = vorrq_u8(mask_upper, mask_lower);\n        uint8x16_t flip_vector = vandq_u8(mask_letter, vdupq_n_u8(0x20));\n        uint8x16_t swapped = veorq_u8(input_vec, flip_vector);\n        uint8x16_t vowel_mask = vceqq_u8(swapped, vdupq_n_u8('a'));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('e')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('i')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('o')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('u')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('A')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('E')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('I')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('O')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('U')));\n        uint8x16_t result_vec = vaddq_u8(swapped, vandq_u8(vowel_mask, vdupq_n_u8(2)));\n        uint8x16_t final_vec = vbslq_u8(mask_letter, result_vec, input_vec);\n        vst1q_u8(out_data + i, final_vec);\n    }\n    if (i < message.size()) {\n        size_t remaining = message.size() - i;\n        uint8_t buffer[16] = {0};\n        uint8_t out_buffer[16] = {0};\n        for (size_t j = 0; j < remaining; j++) {\n            buffer[j] = in_data[i + j];\n        }\n        uint8x16_t input_vec = vld1q_u8(buffer);\n        uint8x16_t mask_upper = vandq_u8(\n            vcgeq_u8(input_vec, vdupq_n_u8('A')),\n            vcleq_u8(input_vec, vdupq_n_u8('Z'))\n        );\n        uint8x16_t mask_lower = vandq_u8(\n            vcgeq_u8(input_vec, vdupq_n_u8('a')),\n            vcleq_u8(input_vec, vdupq_n_u8('z'))\n        );\n        uint8x16_t mask_letter = vorrq_u8(mask_upper, mask_lower);\n        uint8x16_t flip_vector = vandq_u8(mask_letter, vdupq_n_u8(0x20));\n        uint8x16_t swapped = veorq_u8(input_vec, flip_vector);\n        uint8x16_t vowel_mask = vceqq_u8(swapped, vdupq_n_u8('a'));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('e')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('i')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('o')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('u')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('A')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('E')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('I')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('O')));\n        vowel_mask = vorrq_u8(vowel_mask, vceqq_u8(swapped, vdupq_n_u8('U')));\n        uint8x16_t result_vec = vaddq_u8(swapped, vandq_u8(vowel_mask, vdupq_n_u8(2)));\n        uint8x16_t final_vec = vbslq_u8(mask_letter, result_vec, input_vec);\n        vst1q_u8(out_buffer, final_vec);\n        for (size_t j = 0; j < remaining; j++) {\n            out_data[i + j] = out_buffer[j];\n        }\n    }\n    return output;\n}\n```"}
{"task_id": "SimdBench_106_Neon", "completion": "```cpp\n#include <string>\n#include <cstdint>\n#include <arm_neon.h>\n\nstd::string encode_simd(const std::string & message) {\n    std::string result(message.size(), 0);\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(message.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&result[0]);\n    size_t i = 0;\n    const uint8x16_t a_val = vdupq_n_u8('a');\n    const uint8x16_t e_val = vdupq_n_u8('e');\n    const uint8x16_t i_val = vdupq_n_u8('i');\n    const uint8x16_t o_val = vdupq_n_u8('o');\n    const uint8x16_t u_val = vdupq_n_u8('u');\n    const uint8x16_t A_val = vdupq_n_u8('A');\n    const uint8x16_t E_val = vdupq_n_u8('E');\n    const uint8x16_t I_val = vdupq_n_u8('I');\n    const uint8x16_t O_val = vdupq_n_u8('O');\n    const uint8x16_t U_val = vdupq_n_u8('U');\n    const uint8x16_t flip_mask = vdupq_n_u8(0x20);\n    const uint8x16_t add_val = vdupq_n_u8(2);\n    const uint8x16_t A = vdupq_n_u8('A');\n    const uint8x16_t Z = vdupq_n_u8('Z');\n    const uint8x16_t a = vdupq_n_u8('a');\n    const uint8x16_t z = vdupq_n_u8('z');\n\n    for (; i + 15 < message.size(); i += 16) {\n        uint8x16_t v = vld1q_u8(src + i);\n        uint8x16_t mask_upper = vandq_u8(vcgeq_u8(v, A), vcleq_u8(v, Z));\n        uint8x16_t mask_lower = vandq_u8(vcgeq_u8(v, a), vcleq_u8(v, z));\n        uint8x16_t mask_letter = vorrq_u8(mask_upper, mask_lower);\n        uint8x16_t swapped = veorq_u8(v, vandq_u8(mask_letter, flip_mask));\n        uint8x16_t mask_vowel = vceqq_u8(swapped, a_val);\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, e_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, i_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, o_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, u_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, A_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, E_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, I_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, O_val));\n        mask_vowel = vorrq_u8(mask_vowel, vceqq_u8(swapped, U_val));\n        uint8x16_t res = vaddq_u8(swapped, vandq_u8(mask_vowel, add_val));\n        vst1q_u8(dst + i, res);\n    }\n\n    for (; i < message.size(); i++) {\n        uint8_t c = src[i];\n        if ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z')) {\n            c ^= 0x20;\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || \n                c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2;\n            }\n        }\n        dst[i] = c;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool hasLowerGlobal = false;\n    bool hasUpperGlobal = false;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        size_t len = key.size();\n        if (len == 0) {\n            return false;\n        }\n        const unsigned char* data = reinterpret_cast<const unsigned char*>(key.c_str());\n        size_t i = 0;\n\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t v = vld1q_u8(data + i);\n\n            uint8x16_t mask_ge_A = vcgeq_u8(v, vdupq_n_u8('A'));\n            uint8x16_t mask_le_Z = vcleq_u8(v, vdupq_n_u8('Z'));\n            uint8x16_t mask_ge_a = vcgeq_u8(v, vdupq_n_u8('a'));\n            uint8x16_t mask_le_z = vcleq_u8(v, vdupq_n_u8('z'));\n\n            uint8x16_t mask_upper = vandq_u8(mask_ge_A, mask_le_Z);\n            uint8x16_t mask_lower = vandq_u8(mask_ge_a, mask_le_z);\n            uint8x16_t mask_letter = vorrq_u8(mask_upper, mask_lower);\n\n            uint8x16_t mask_non_letter = vmvnq_u8(mask_letter);\n            if (vmaxvq_u8(mask_non_letter) {\n                return false;\n            }\n\n            if (vmaxvq_u8(mask_upper)) {\n                hasUpperGlobal = true;\n            }\n            if (vmaxvq_u8(mask_lower)) {\n                hasLowerGlobal = true;\n            }\n        }\n\n        for (; i < len; ++i) {\n            unsigned char c = data[i];\n            bool is_upper = (c >= 'A' && c <= 'Z');\n            bool is_lower = (c >= 'a' && c <= 'z');\n            if (!(is_upper || is_lower)) {\n                return false;\n            }\n            if (is_lower) {\n                hasLowerGlobal = true;\n            } else {\n                hasUpperGlobal = true;\n            }\n        }\n    }\n\n    if (hasLowerGlobal && hasUpperGlobal) {\n        return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool allLower = true;\n    bool allUpper = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(key.data());\n        size_t len = key.size();\n        size_t i = 0;\n\n        bool is_alpha_key = true;\n        bool has_upper_key = false;\n        bool has_lower_key = false;\n\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t chunk = vld1q_u8(data + i);\n            \n            uint8x16_t is_upper = vandq_u8(\n                vcgeq_u8(chunk, vdupq_n_u8('A')),\n                vcleq_u8(chunk, vdupq_n_u8('Z'))\n            );\n            uint8x16_t is_lower = vandq_u8(\n                vcgeq_u8(chunk, vdupq_n_u8('a')),\n                vcleq_u8(chunk, vdupq_n_u8('z'))\n            );\n            uint8x16_t is_alpha = vorrq_u8(is_upper, is_lower);\n            uint8x16_t non_alpha = vmvnq_u8(is_alpha);\n\n            if (vmaxvq_u8(non_alpha) != 0) {\n                is_alpha_key = false;\n                break;\n            }\n\n            if (vmaxvq_u8(is_upper) != 0) {\n                has_upper_key = true;\n            }\n            if (vmaxvq_u8(is_lower) != 0) {\n                has_lower_key = true;\n            }\n        }\n\n        if (is_alpha_key && i < len) {\n            for (; i < len; i++) {\n                uint8_t c = data[i];\n                if (c >= 'A' && c <= 'Z') {\n                    has_upper_key = true;\n                } else if (c >= 'a' && c <= 'z') {\n                    has_lower_key = true;\n                } else {\n                    is_alpha_key = false;\n                    break;\n                }\n            }\n        }\n\n        if (!is_alpha_key) {\n            allLower = false;\n            allUpper = false;\n        } else {\n            if (has_upper_key) {\n                allLower = false;\n            }\n            if (has_lower_key) {\n                allUpper = false;\n            }\n        }\n\n        if (!allLower && !allUpper) {\n            break;\n        }\n    }\n\n    return (allLower || allUpper);\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n#include <cstring>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    int expected_case = -1;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        if (key.empty()) {\n            return false;\n        }\n\n        size_t len = key.length();\n        size_t i = 0;\n        bool key_has_non_letter = false;\n        bool key_has_upper = false;\n        bool key_has_lower = false;\n\n        for (i = 0; i < len; i += 16) {\n            size_t remaining = len - i;\n            size_t chunk_size = (remaining < 16) ? remaining : 16;\n\n            uint8x16_t data;\n            uint8x16_t mask;\n\n            if (chunk_size == 16) {\n                data = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n                mask = vdupq_n_u8(0xFF);\n            } else {\n                uint8_t buffer[16] = {0};\n                uint8_t mask_arr[16] = {0};\n                memcpy(buffer, key.data() + i, chunk_size);\n                for (size_t j = 0; j < chunk_size; ++j) {\n                    mask_arr[j] = 0xFF;\n                }\n                data = vld1q_u8(buffer);\n                mask = vld1q_u8(mask_arr);\n            }\n\n            uint8x16_t ge_A = vcgeq_u8(data, vdupq_n_u8('A'));\n            uint8x16_t le_Z = vcleq_u8(data, vdupq_n_u8('Z'));\n            uint8x16_t is_upper = vandq_u8(ge_A, le_Z);\n\n            uint8x16_t ge_a = vcgeq_u8(data, vdupq_n_u8('a'));\n            uint8x16_t le_z = vcleq_u8(data, vdupq_n_u8('z'));\n            uint8x16_t is_lower = vandq_u8(ge_a, le_z);\n\n            is_upper = vandq_u8(is_upper, mask);\n            is_lower = vandq_u8(is_lower, mask);\n\n            uint8x16_t is_letter = vorrq_u8(is_upper, is_lower);\n            uint8x16_t not_mask = vmvnq_u8(mask);\n            is_letter = vorrq_u8(is_letter, not_mask);\n\n            if (vminvq_u8(is_letter) == 0) {\n                key_has_non_letter = true;\n                break;\n            }\n\n            if (vmaxvq_u8(is_upper) != 0) {\n                key_has_upper = true;\n            }\n            if (vmaxvq_u8(is_lower) != 0) {\n                key_has_lower = true;\n            }\n        }\n\n        if (key_has_non_letter) {\n            return false;\n        }\n\n        if (key_has_upper && key_has_lower) {\n            return false;\n        }\n\n        if (!key_has_upper && !key_has_lower) {\n            return false;\n        }\n\n        int key_case = key_has_upper ? 1 : 0;\n\n        if (expected_case == -1) {\n            expected_case = key_case;\n        } else if (expected_case != key_case) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool global_lower = true;\n    bool global_upper = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        size_t len = key.length();\n        size_t offset = 0;\n\n        bool key_lower = true;\n        bool key_upper = true;\n\n        if (len >= 16) {\n            uint8x16_t a_vec = vdupq_n_u8('a');\n            uint8x16_t z_vec = vdupq_n_u8('z');\n            uint8x16_t A_vec = vdupq_n_u8('A');\n            uint8x16_t Z_vec = vdupq_n_u8('Z');\n\n            for (; offset <= len - 16; offset += 16) {\n                uint8x16_t chunk = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + offset));\n\n                uint8x16_t ge_a = vcgeq_u8(chunk, a_vec);\n                uint8x16_t le_z = vcleq_u8(chunk, z_vec);\n                uint8x16_t in_lower = vandq_u8(ge_a, le_z);\n\n                uint8x16_t ge_A = vcgeq_u8(chunk, A_vec);\n                uint8x16_t le_Z = vcleq_u8(chunk, Z_vec);\n                uint8x16_t in_upper = vandq_u8(ge_A, le_Z);\n\n                uint8x16_t is_alpha = vorrq_u8(in_lower, in_upper);\n\n                if (vminvq_u8(is_alpha) != 0xFF) {\n                    return false;\n                }\n\n                if (vmaxvq_u8(in_upper) != 0) {\n                    key_lower = false;\n                }\n                if (vmaxvq_u8(in_lower) != 0) {\n                    key_upper = false;\n                }\n\n                if (!key_lower && !key_upper) {\n                    break;\n                }\n            }\n        }\n\n        for (; offset < len; offset++) {\n            unsigned char c = key[offset];\n            if ((c < 'A') || (c > 'Z' && c < 'a') || (c > 'z')) {\n                return false;\n            }\n            if (key_lower && (c >= 'A' && c <= 'Z')) {\n                key_lower = false;\n            }\n            if (key_upper && (c >= 'a' && c <= 'z')) {\n                key_upper = false;\n            }\n            if (!key_lower && !key_upper) {\n                break;\n            }\n        }\n\n        global_lower = global_lower && key_lower;\n        global_upper = global_upper && key_upper;\n\n        if (!global_lower && !global_upper) {\n            break;\n        }\n    }\n\n    return (global_lower || global_upper);\n}\n```"}
{"task_id": "SimdBench_107_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_upper = true;\n    bool all_lower = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        if (key.empty()) {\n            all_upper = false;\n            all_lower = false;\n            break;\n        }\n\n        bool is_upper = true;\n        bool is_lower = true;\n        size_t len = key.length();\n        size_t i = 0;\n\n        while (i < len) {\n            if (!is_upper && !is_lower) {\n                break;\n            }\n\n            size_t remaining = len - i;\n            uint8x16_t v;\n            if (remaining >= 16) {\n                v = vld1q_u8(reinterpret_cast<const uint8_t*>(key.data() + i));\n                i += 16;\n            } else {\n                uint8_t buffer[16] = {0};\n                for (size_t j = 0; j < remaining; j++) {\n                    buffer[j] = key[i + j];\n                }\n                v = vld1q_u8(buffer);\n                i = len;\n            }\n\n            if (is_upper) {\n                uint8x16_t ltA = vcltq_u8(v, vdupq_n_u8('A'));\n                uint8x16_t gtZ = vcgtq_u8(v, vdupq_n_u8('Z'));\n                uint8x16_t outside_upper = vorrq_u8(ltA, gtZ);\n                if (vmaxvq_u8(outside_upper) != 0) {\n                    is_upper = false;\n                }\n            }\n\n            if (is_lower) {\n                uint8x16_t lta = vcltq_u8(v, vdupq_n_u8('a'));\n                uint8x16_t gtz = vcgtq_u8(v, vdupq_n_u8('z'));\n                uint8x16_t outside_lower = vorrq_u8(lta, gtz);\n                if (vmaxvq_u8(outside_lower) != 0) {\n                    is_lower = false;\n                }\n            }\n        }\n\n        if (!is_upper && !is_lower) {\n            all_upper = false;\n            all_lower = false;\n            break;\n        } else {\n            all_upper = all_upper && is_upper;\n            all_lower = all_lower && is_lower;\n            if (!all_upper && !all_lower) {\n                break;\n            }\n        }\n    }\n\n    return all_upper || all_lower;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstring>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) {\n        return {};\n    }\n    \n    uint8_t* sieve = new uint8_t[n];\n    uint8x16_t ones = vdupq_n_u8(1);\n    int i = 0;\n    for (; i + 16 <= n; i += 16) {\n        vst1q_u8(sieve + i, ones);\n    }\n    for (; i < n; i++) {\n        sieve[i] = 1;\n    }\n    sieve[0] = 0;\n    sieve[1] = 0;\n\n    static uint8x16_t small_patterns[17][16];\n    static bool patterns_precomputed = false;\n    if (!patterns_precomputed) {\n        patterns_precomputed = true;\n        for (int p = 3; p <= 16; p++) {\n            for (int r = 0; r < p; r++) {\n                uint8_t temp[16];\n                for (int i = 0; i < 16; i++) {\n                    if ((r + i) % p == 0) {\n                        temp[i] = 0;\n                    } else {\n                        temp[i] = 0xFF;\n                    }\n                }\n                small_patterns[p][r] = vld1q_u8(temp);\n            }\n        }\n    }\n\n    uint8_t even_temp[16] = {0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF};\n    uint8x16_t even_pattern = vld1q_u8(even_temp);\n\n    for (int p_val = 2; p_val < n; p_val++) {\n        if (p_val * p_val >= n) {\n            break;\n        }\n        if (!sieve[p_val]) {\n            continue;\n        }\n\n        if (p_val == 2) {\n            for (int j = 4; j < n; j += 16) {\n                if (j + 16 <= n) {\n                    uint8x16_t data = vld1q_u8(sieve + j);\n                    data = vandq_u8(data, even_pattern);\n                    vst1q_u8(sieve + j, data);\n                } else {\n                    for (int k = j; k < n; k++) {\n                        if (k % 2 == 0) {\n                            sieve[k] = 0;\n                        }\n                    }\n                }\n            }\n        } else if (p_val >= 3 && p_val <= 16) {\n            int start = p_val * p_val;\n            if (start >= n) {\n                continue;\n            }\n            int current_r = start % p_val;\n            for (int j = start; j < n; j += 16) {\n                if (j + 16 > n) {\n                    for (int k = j; k < n; k++) {\n                        if (k % p_val == 0) {\n                            sieve[k] = 0;\n                        }\n                    }\n                    break;\n                }\n                uint8x16_t data = vld1q_u8(sieve + j);\n                data = vandq_u8(data, small_patterns[p_val][current_r]);\n                vst1q_u8(sieve + j, data);\n                current_r = (current_r + 16) % p_val;\n            }\n        } else {\n            for (int j = p_val * p_val; j < n; j += p_val) {\n                sieve[j] = 0;\n            }\n        }\n    }\n\n    std::vector<int> result;\n    for (i = 0; i < n; i += 16) {\n        int chunk_size = (i + 16 <= n) ? 16 : n - i;\n        uint8x16_t chunk = vld1q_u8(sieve + i);\n        uint8x16_t mask = vceqq_u8(chunk, vdupq_n_u8(1));\n        uint8_t mask_array[16];\n        vst1q_u8(mask_array, mask);\n        for (int j = 0; j < chunk_size; j++) {\n            if (mask_array[j]) {\n                result.push_back(i + j);\n            }\n        }\n    }\n\n    delete[] sieve;\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstring>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return std::vector<int>();\n    }\n\n    std::vector<int> result;\n    result.push_back(2);\n\n    uint8_t *sieve = new uint8_t[n];\n    sieve[0] = 0;\n    sieve[1] = 0;\n    sieve[2] = 1;\n\n    uint8x16_t ones = vdupq_n_u8(1);\n    int i = 3;\n    for (; i + 16 <= n; i += 16) {\n        vst1q_u8(sieve + i, ones);\n    }\n    for (; i < n; ++i) {\n        sieve[i] = 1;\n    }\n\n    const uint8_t even_mask_data[16] = {0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF};\n    const uint8_t odd_mask_data[16] = {0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0};\n    uint8x16_t even_mask = vld1q_u8(even_mask_data);\n    uint8x16_t odd_mask = vld1q_u8(odd_mask_data);\n\n    i = 4;\n    for (; i + 16 <= n; i += 16) {\n        uint8x16_t data = vld1q_u8(sieve + i);\n        if (i % 2 == 0) {\n            data = vandq_u8(data, even_mask);\n        } else {\n            data = vandq_u8(data, odd_mask);\n        }\n        vst1q_u8(sieve + i, data);\n    }\n    for (; i < n; ++i) {\n        if (i % 2 == 0) {\n            sieve[i] = 0;\n        }\n    }\n\n    for (int p = 3; p * p < n; p += 2) {\n        if (sieve[p]) {\n            for (int j = p * p; j < n; j += p) {\n                sieve[j] = 0;\n            }\n        }\n    }\n\n    for (int i = 3; i < n; i += 2) {\n        if (sieve[i]) {\n            result.push_back(i);\n        }\n    }\n\n    delete[] sieve;\n    return result;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n#include <algorithm>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return {};\n    }\n\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    int sqrt_n = std::sqrt(n) + 1;\n    constexpr int vec_width = 16;\n    static const uint16_t indices_array[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n\n    for (int p = 2; p < sqrt_n; ++p) {\n        if (is_prime[p]) {\n            if (static_cast<long>(p) * p >= n) {\n                continue;\n            }\n\n            for (int base = p * p; base < n; base += vec_width) {\n                int segment_end = base + vec_width;\n                if (segment_end > n) {\n                    for (int i = base; i < n; ++i) {\n                        if (i % p == 0) {\n                            is_prime[i] = 0;\n                        }\n                    }\n                    break;\n                }\n\n                int rem_base = base % p;\n                uint16x8_t v_rem_base = vdupq_n_u16(rem_base);\n                uint16x8_t indices_low = vld1q_u16(indices_array);\n                uint16x8_t indices_high = vld1q_u16(indices_array + 8);\n\n                uint16x8_t vec_low = vaddq_u16(v_rem_base, indices_low);\n                uint16x8_t vec_high = vaddq_u16(v_rem_base, indices_high);\n                uint16x8_t p_vec = vdupq_n_u16(p);\n\n                uint16x8_t mask1_low = vcgeq_u16(vec_low, p_vec);\n                vec_low = vsubq_u16(vec_low, vandq_u16(mask1_low, p_vec));\n                mask1_low = vcgeq_u16(vec_low, p_vec);\n                vec_low = vsubq_u16(vec_low, vandq_u16(mask1_low, p_vec));\n\n                uint16x8_t mask1_high = vcgeq_u16(vec_high, p_vec);\n                vec_high = vsubq_u16(vec_high, vandq_u16(mask1_high, p_vec));\n                mask1_high = vcgeq_u16(vec_high, p_vec);\n                vec_high = vsubq_u16(vec_high, vandq_u16(mask1_high, p_vec));\n\n                uint16x8_t zero = vdupq_n_u16(0);\n                uint16x8_t mask_low = vceqq_u16(vec_low, zero);\n                uint16x8_t mask_high = vceqq_u16(vec_high, zero);\n\n                uint8x8_t mask_low8 = vmovn_u16(mask_low);\n                uint8x8_t mask_high8 = vmovn_u16(mask_high);\n                uint8x16_t full_mask = vcombine_u8(mask_low8, mask_high8);\n\n                uint8x16_t data = vld1q_u8(&is_prime[base]);\n                data = vbicq_u8(data, full_mask);\n                vst1q_u8(&is_prime[base], data);\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    uint8x16_t mask_table[16][16];\n    for (int p = 2; p < 16; p++) {\n        for (int r0 = 0; r0 < 16; r0++) {\n            uint8_t mask_arr[16];\n            for (int j = 0; j < 16; j++) {\n                if (r0 < p && (r0 + j) % p == 0) {\n                    mask_arr[j] = 0;\n                } else {\n                    mask_arr[j] = 0xFF;\n                }\n            }\n            mask_table[p][r0] = vld1q_u8(mask_arr);\n        }\n    }\n\n    int sqrt_n = static_cast<int>(std::sqrt(n)) + 1;\n    if (sqrt_n > n) sqrt_n = n;\n\n    for (int p = 2; p < sqrt_n; p++) {\n        if (is_prime[p]) {\n            if (p < 16) {\n                uint32_t base = static_cast<uint32_t>(p) * static_cast<uint32_t>(p);\n                if (base >= static_cast<uint32_t>(n)) {\n                    continue;\n                }\n                uint32_t aligned_start = (base + 15) & ~15;\n                for (uint32_t j = base; j < aligned_start && j < static_cast<uint32_t>(n); j += p) {\n                    is_prime[j] = 0;\n                }\n                if (aligned_start >= static_cast<uint32_t>(n)) {\n                    continue;\n                }\n                uint32_t r0 = aligned_start % p;\n                uint8x16_t mask = mask_table[p][r0];\n                for (uint32_t j = aligned_start; j < static_cast<uint32_t>(n); j += 16) {\n                    if (j + 16 > static_cast<uint32_t>(n)) {\n                        break;\n                    }\n                    uint8_t* addr = &is_prime[j];\n                    uint8x16_t data = vld1q_u8(addr);\n                    data = vandq_u8(data, mask);\n                    vst1q_u8(addr, data);\n                    r0 = (r0 + 16) % p;\n                    mask = mask_table[p][r0];\n                }\n                uint32_t j0 = aligned_start + ((static_cast<uint32_t>(n) - aligned_start) / 16) * 16;\n                uint32_t r0_tail = j0 % p;\n                for (uint32_t i = 0; i < static_cast<uint32_t>(n) - j0; i++) {\n                    if ((r0_tail + i) % p == 0) {\n                        is_prime[j0 + i] = 0;\n                    }\n                }\n            } else {\n                for (uint32_t j = static_cast<uint32_t>(p) * static_cast<uint32_t>(p); j < static_cast<uint32_t>(n); j += p) {\n                    is_prime[j] = 0;\n                }\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return {};\n    }\n\n    uint8_t pattern_table[17][16][16];\n    for (int p = 2; p <= 16; p++) {\n        for (int r0 = 0; r0 < p; r0++) {\n            for (int k = 0; k < 16; k++) {\n                if ((r0 + k) % p == 0) {\n                    pattern_table[p][r0][k] = 0x00;\n                } else {\n                    pattern_table[p][r0][k] = 0xFF;\n                }\n            }\n        }\n    }\n\n    std::vector<uint8_t> sieve(n, 1);\n    sieve[0] = 0;\n    sieve[1] = 0;\n\n    int sqrt_n = static_cast<int>(std::sqrt(n)) + 1;\n    if (sqrt_n > n) {\n        sqrt_n = n;\n    }\n\n    for (int p = 2; p < sqrt_n; p++) {\n        if (!sieve[p]) {\n            continue;\n        }\n\n        uint64_t base = static_cast<uint64_t>(p) * p;\n        if (base >= n) {\n            continue;\n        }\n\n        if (p <= 16) {\n            int residue = base % p;\n            int j = base;\n            while (j < n) {\n                if (j + 16 > n) {\n                    for (int k = j; k < n; k++) {\n                        if (k % p == 0) {\n                            sieve[k] = 0;\n                        }\n                    }\n                    break;\n                }\n\n                uint8x16_t data = vld1q_u8(&sieve[j]);\n                uint8x16_t mask = vld1q_u8(pattern_table[p][residue]);\n                data = vandq_u8(data, mask);\n                vst1q_u8(&sieve[j], data);\n\n                j += 16;\n                residue = (residue + 16) % p;\n            }\n        } else {\n            for (int j = base; j < n; j += p) {\n                sieve[j] = 0;\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (sieve[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    if (len == 0) return 0;\n    \n    const uint8_t *ptr = (const uint8_t*)s.data();\n    size_t i = 0;\n    int count = 0;\n    \n    static const uint8_t base_mask_array[16] = {0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1};\n    uint8x16_t base_mask = vld1q_u8(base_mask_array);\n    \n    for (; i + 16 <= len; i += 16, ptr += 16) {\n        uint8x16_t data = vld1q_u8(ptr);\n        uint8_t base_parity = i & 1;\n        uint8x16_t mask = vceqq_u8(base_mask, vdupq_n_u8(base_parity));\n        \n        uint8x16_t vowel_match = vceqq_u8(data, vdupq_n_u8('A'));\n        vowel_match = vorrq_u8(vowel_match, vceqq_u8(data, vdupq_n_u8('E')));\n        vowel_match = vorrq_u8(vowel_match, vceqq_u8(data, vdupq_n_u8('I')));\n        vowel_match = vorrq_u8(vowel_match, vceqq_u8(data, vdupq_n_u8('O')));\n        vowel_match = vorrq_u8(vowel_match, vceqq_u8(data, vdupq_n_u8('U')));\n        \n        vowel_match = vandq_u8(vowel_match, mask);\n        uint32_t total = vaddlvq_u8(vowel_match);\n        count += total / 255;\n    }\n    \n    for (; i < len; i++) {\n        if (i % 2 == 0) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int count = 0;\n    int len = s.length();\n    const uint8_t *ptr = reinterpret_cast<const uint8_t*>(s.c_str());\n    \n    static const uint8_t mask_arr[16] = {0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0};\n    uint8x16_t mask = vld1q_u8(mask_arr);\n    \n    int i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t v = vld1q_u8(ptr + i);\n        uint8x16_t masked = vandq_u8(v, mask);\n        \n        uint8x16_t cmpA = vceqq_u8(masked, vdupq_n_u8('A'));\n        uint8x16_t cmpE = vceqq_u8(masked, vdupq_n_u8('E'));\n        uint8x16_t cmpI = vceqq_u8(masked, vdupq_n_u8('I'));\n        uint8x16_t cmpO = vceqq_u8(masked, vdupq_n_u8('O'));\n        uint8x16_t cmpU = vceqq_u8(masked, vdupq_n_u8('U'));\n        \n        uint8x16_t cmpAny = vorrq_u8(cmpA, cmpE);\n        cmpAny = vorrq_u8(cmpAny, cmpI);\n        cmpAny = vorrq_u8(cmpAny, cmpO);\n        cmpAny = vorrq_u8(cmpAny, cmpU);\n        \n        int8x16_t s8 = vreinterpretq_s8_u8(cmpAny);\n        int16x8_t s16 = vpaddlq_s8(s8);\n        int32x4_t s32 = vpaddlq_s16(s16);\n        int64x2_t s64 = vpaddlq_s32(s32);\n        \n        int64_t total = vgetq_lane_s64(s64, 0) + vgetq_lane_s64(s64, 1);\n        count += (-total);\n    }\n    \n    for (int j = i; j < len; j += 2) {\n        char c = s[j];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    size_t len = s.size();\n    if (len == 0) return 0;\n\n    uint32_t total = 0;\n    static const uint8_t mask_arr[16] = {1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0};\n    const uint8x16_t mask_even = vld1q_u8(mask_arr);\n\n    const uint8x16_t vA = vmovq_n_u8('A');\n    const uint8x16_t vE = vmovq_n_u8('E');\n    const uint8x16_t vI = vmovq_n_u8('I');\n    const uint8x16_t vO = vmovq_n_u8('O');\n    const uint8x16_t vU = vmovq_n_u8('U');\n\n    size_t i = 0;\n    for (; i + 16 <= len; i += 16) {\n        uint8x16_t input = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        uint8x16_t cmpA = vceqq_u8(input, vA);\n        uint8x16_t cmpE = vceqq_u8(input, vE);\n        uint8x16_t cmpI = vceqq_u8(input, vI);\n        uint8x16_t cmpO = vceqq_u8(input, vO);\n        uint8x16_t cmpU = vceqq_u8(input, vU);\n\n        uint8x16_t vowel_mask = vorrq_u8(cmpA, cmpE);\n        vowel_mask = vorrq_u8(vowel_mask, cmpI);\n        vowel_mask = vorrq_u8(vowel_mask, cmpO);\n        vowel_mask = vorrq_u8(vowel_mask, cmpU);\n\n        uint8x16_t result = vandq_u8(vowel_mask, mask_even);\n        total += vaddvq_u8(result);\n    }\n\n    for (size_t j = i; j < len; j += 2) {\n        char c = s[j];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            total++;\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int len = s.length();\n    int i = 0;\n    uint32_t total = 0;\n    \n    // Handle strings shorter than 16 bytes with scalar processing\n    if (len < 16) {\n        for (; i < len; i++) {\n            if (i % 2 == 0) {\n                char c = s[i];\n                if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                    total++;\n                }\n            }\n        }\n        return total;\n    }\n\n    // Create mask for even indices: 1 at even positions, 0 at odd\n    const uint8_t even_mask_arr[16] = {1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0};\n    const uint8x16_t even_mask = vld1q_u8(even_mask_arr);\n\n    for (; i <= len - 16; i += 16) {\n        // Load 16 bytes of the string\n        uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        // Check for each vowel\n        uint8x16_t maskA = vceqq_u8(data, vdupq_n_u8('A'));\n        uint8x16_t maskE = vceqq_u8(data, vdupq_n_u8('E'));\n        uint8x16_t maskI = vceqq_u8(data, vdupq_n_u8('I'));\n        uint8x16_t maskO = vceqq_u8(data, vdupq_n_u8('O'));\n        uint8x16_t maskU = vceqq_u8(data, vdupq_n_u8('U'));\n        \n        // Combine vowel masks\n        uint8x16_t vowel_mask = vorrq_u8(maskA, maskE);\n        vowel_mask = vorrq_u8(vowel_mask, maskI);\n        vowel_mask = vorrq_u8(vowel_mask, maskO);\n        vowel_mask = vorrq_u8(vowel_mask, maskU);\n        \n        // Apply even index mask\n        uint8x16_t matches = vandq_u8(vowel_mask, even_mask);\n        \n        // Sum the matches\n        uint16x8_t sum1 = vpaddlq_u8(matches);\n        uint32x4_t sum2 = vpaddlq_u16(sum1);\n        \n        // Extract and accumulate partial sums\n        uint32_t chunk_count = 0;\n        chunk_count += vgetq_lane_u32(sum2, 0);\n        chunk_count += vgetq_lane_u32(sum2, 1);\n        chunk_count += vgetq_lane_u32(sum2, 2);\n        chunk_count += vgetq_lane_u32(sum2, 3);\n        \n        total += chunk_count;\n    }\n    \n    // Process remaining bytes with scalar\n    for (; i < len; i++) {\n        if (i % 2 == 0) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                total++;\n            }\n        }\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_109_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint count_upper_simd(const std::string & s){\n    const uint8_t *ptr = (const uint8_t*)s.data();\n    size_t len = s.length();\n    int count = 0;\n    \n    if (len == 0) \n        return 0;\n\n    static const uint8_t even_mask_arr[16] = {0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0, 0xFF, 0};\n    uint8x16_t even_mask = vld1q_u8(even_mask_arr);\n\n    uint8x16_t vA = vdupq_n_u8('A');\n    uint8x16_t vE = vdupq_n_u8('E');\n    uint8x16_t vI = vdupq_n_u8('I');\n    uint8x16_t vO = vdupq_n_u8('O');\n    uint8x16_t vU = vdupq_n_u8('U');\n\n    size_t i = 0;\n    for (; i + 15 < len; i += 16) {\n        uint8x16_t data = vld1q_u8(ptr + i);\n\n        uint8x16_t cA = vceqq_u8(data, vA);\n        uint8x16_t cE = vceqq_u8(data, vE);\n        uint8x16_t cI = vceqq_u8(data, vI);\n        uint8x16_t cO = vceqq_u8(data, vO);\n        uint8x16_t cU = vceqq_u8(data, vU);\n\n        uint8x16_t vowel_match = vorrq_u8(vorrq_u8(vorrq_u8(vorrq_u8(cA, cE), cI), vorrq_u8(cO, cU));\n        vowel_match = vandq_u8(vowel_match, even_mask);\n        vowel_match = vshrq_n_u8(vowel_match, 7);\n\n        uint16x8_t sum1 = vpaddlq_u8(vowel_match);\n        uint32x4_t sum2 = vpaddlq_u16(sum1);\n        uint32_t total = vgetq_lane_u32(sum2, 0) + vgetq_lane_u32(sum2, 1) + vgetq_lane_u32(sum2, 2) + vgetq_lane_u32(sum2, 3);\n        count += total;\n    }\n\n    for (; i < len; i++) {\n        if (i % 2 == 0) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> res(n);\n    if (n <= 0) {\n        return res;\n    }\n\n    int32x4_t step_vec_const = vmovq_n_s32(0);\n    step_vec_const = vsetq_lane_s32(2, step_vec_const, 1);\n    step_vec_const = vsetq_lane_s32(4, step_vec_const, 2);\n    step_vec_const = vsetq_lane_s32(6, step_vec_const, 3);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int base_val = n + 2 * i;\n        int32x4_t base_vec = vdupq_n_s32(base_val);\n        int32x4_t chunk = vaddq_s32(base_vec, step_vec_const);\n        vst1q_s32(&res[i], chunk);\n    }\n\n    for (; i < n; i++) {\n        res[i] = n + 2 * i;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> res(n);\n    if (n <= 0) {\n        return res;\n    }\n\n    int32x4_t inc = {0, 2, 4, 6};\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int base_val = n + 2 * i;\n        int32x4_t base_vec = vdupq_n_s32(base_val);\n        int32x4_t val_vec = vaddq_s32(base_vec, inc);\n        vst1q_s32(&res[i], val_vec);\n    }\n\n    for (; i < n; i++) {\n        res[i] = n + 2 * i;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> arr(n);\n    if (n <= 0) {\n        return arr;\n    }\n\n    int32x4_t v_two = vdupq_n_s32(2);\n    static const int32_t inc_arr[4] = {0, 1, 2, 3};\n    int32x4_t v_increments = vld1q_s32(inc_arr);\n    int32x4_t v_offsets = vmulq_s32(v_increments, v_two);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int base_val = n + 2 * i;\n        int32x4_t v_base = vdupq_n_s32(base_val);\n        int32x4_t v_res = vaddq_s32(v_base, v_offsets);\n        vst1q_s32(&arr[i], v_res);\n    }\n\n    for (; i < n; ++i) {\n        arr[i] = n + 2 * i;\n    }\n\n    return arr;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> result;\n    if (n <= 0) {\n        return result;\n    }\n    result.resize(n);\n\n    int i = 0;\n    int32_t idx_arr[4] = {0, 1, 2, 3};\n    int32x4_t indices = vld1q_s32(idx_arr);\n\n    for (; i <= n - 4; i += 4) {\n        int base = n + 2 * i;\n        int32x4_t base_vec = vdupq_n_s32(base);\n        int32x4_t res_vec = vmlaq_n_s32(base_vec, indices, 2);\n        vst1q_s32(result.data() + i, res_vec);\n    }\n\n    for (; i < n; i++) {\n        result[i] = n + 2 * i;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_Neon", "completion": "```c\n#include <arm_neon.h>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    std::vector<int> res(n);\n    if (n == 0) {\n        return res;\n    }\n\n    const int32_t init_inc[4] = {0, 1, 2, 3};\n    int32x4_t increment = vld1q_s32(init_inc);\n    int32x4_t step_vec = vdupq_n_s32(2);\n    int32x4_t n_vec = vdupq_n_s32(n);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t base_index = vdupq_n_s32(i);\n        int32x4_t indices = vaddq_s32(base_index, increment);\n        int32x4_t values = vmlaq_s32(n_vec, step_vec, indices);\n        vst1q_s32(&res[i], values);\n    }\n\n    for (; i < n; ++i) {\n        res[i] = n + 2 * i;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    uint64_t total = static_cast<uint64_t>(n) + static_cast<uint64_t>(m);\n    uint64_t u_avg = total / 2;\n    if (u_avg == 0) {\n        return \"0\";\n    }\n    uint8x8_t bytes = vrev64_u8(vcreate_u8(u_avg));\n    const uint64_t mask_val = 0x0102040810204080;\n    uint8x8_t bit_mask = vcreate_u8(mask_val);\n    uint8x8_t rows[8];\n    for (int i = 0; i < 8; i++) {\n        uint8x8_t byte_vec = vdup_n_u8(vget_lane_u8(bytes, i));\n        uint8x8_t bits = vtst_u8(byte_vec, bit_mask);\n        bits = vand_u8(bits, vdup_n_u8(1));\n        bits = vadd_u8(bits, vdup_n_u8('0'));\n        rows[i] = bits;\n    }\n    char buffer[64];\n    for (int i = 0; i < 8; i++) {\n        vst1_u8(reinterpret_cast<uint8_t*>(buffer + 8*i), rows[i]);\n    }\n    int start = 0;\n    while (start < 64 && buffer[start] == '0') {\n        start++;\n    }\n    if (start == 64) {\n        return \"0\";\n    }\n    return std::string(buffer + start, 64 - start);\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```c++\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m){\n    if (n > m) {\n        return \"-1\";\n    }\n    int64x2_t vec = {n, m};\n    int64x2_t sum_vec = vpaddq_s64(vec, vec);\n    int64x2_t avg_vec = vshrq_n_s64(sum_vec, 1);\n    int64_t avg = vgetq_lane_s64(avg_vec, 0);\n    \n    std::string res;\n    int64_t num = avg;\n    while (num) {\n        res = char('0' + (num & 1)) + res;\n        num >>= 1;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstring>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    uint64_t total = (uint64_t)n + (uint64_t)m;\n    uint64_t avg = total / 2;\n\n    if (avg == 0) {\n        return \"0\";\n    }\n\n    uint8x8_t v = vcreate_u8(avg);\n    uint8x8_t v_big = vrev64_u8(v);\n\n    const uint8_t mask_arr[8] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n    uint8x8_t mask = vld1_u8(mask_arr);\n\n    uint8x8_t ascii_vec[8];\n    for (int i = 0; i < 8; i++) {\n        uint8_t byte = v_big[i];\n        uint8x8_t v_byte = vdup_n_u8(byte);\n        uint8x8_t masked = vand_u8(v_byte, mask);\n        uint8x8_t bits = vceq_u8(masked, mask);\n        uint8x8_t ascii = vadd_u8(vshr_n_u8(bits, 7), vdup_n_u8('0'));\n        ascii_vec[i] = ascii;\n    }\n\n    uint8_t all_bits[64];\n    for (int i = 0; i < 8; i++) {\n        vst1_u8(all_bits + i * 8, ascii_vec[i]);\n    }\n\n    std::string res_str(reinterpret_cast<const char*>(all_bits), 64);\n    size_t start = res_str.find_first_not_of('0');\n    if (start == std::string::npos) {\n        return \"0\";\n    }\n    return res_str.substr(start);\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n#include <cstdint>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    uint64_t un = static_cast<uint64_t>(n);\n    uint64_t um = static_cast<uint64_t>(m);\n    uint64_t uavg = (un + um) >> 1;\n\n    if (uavg == 0) {\n        return \"0\";\n    }\n\n    uint8x8_t v_bytes = vld1_u8(reinterpret_cast<const uint8_t*>(&uavg));\n    v_bytes = vrev64_u8(v_bytes);\n\n    const uint8x8_t bit_mask = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};\n    char buffer[64];\n\n    for (int i = 0; i < 8; i++) {\n        uint8_t byte = vget_lane_u8(v_bytes, i);\n        uint8x8_t byte_vec = vdup_n_u8(byte);\n        uint8x8_t and_result = vand_u8(byte_vec, bit_mask);\n        uint8x8_t bits_set = vceq_u8(and_result, bit_mask);\n        uint8x8_t ascii_chars = vbsl_u8(bits_set, \n                                        vdup_n_u8('1'), \n                                        vdup_n_u8('0'));\n        vst1_u8(reinterpret_cast<uint8_t*>(buffer + i*8), ascii_chars);\n    }\n\n    int start_index = 0;\n    while (start_index < 64 && buffer[start_index] == '0') {\n        start_index++;\n    }\n\n    if (start_index == 64) {\n        return \"0\";\n    }\n\n    return std::string(buffer + start_index, 64 - start_index);\n}\n```"}
{"task_id": "SimdBench_111_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64x1_t n_vec = vdup_n_s64(n);\n    int64x1_t m_vec = vdup_n_s64(m);\n    int64x1_t and_part = vand_s64(n_vec, m_vec);\n    int64x1_t xor_part = veor_s64(n_vec, m_vec);\n    int64x1_t shifted_xor = vshr_n_s64(xor_part, 1);\n    int64x1_t res_vec = vadd_s64(and_part, shifted_xor);\n    int64_t avg = vget_lane_s64(res_vec, 0);\n\n    if (avg == 0) {\n        return \"0\";\n    }\n    std::string binary;\n    int64_t num = avg;\n    while (num != 0) {\n        binary = (num & 1 ? '1' : '0') + binary;\n        num >>= 1;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    if (n <= 0) {\n        return std::vector<int>();\n    }\n    int m_odd = (n + 1) / 2;\n    int m_even = n / 2;\n    std::vector<int> tri(m_odd);\n    std::vector<int> fact(m_even);\n    std::vector<int> result(n);\n\n    int32_t step_arr[4] = {0, 1, 2, 3};\n    int32x4_t step_vec = vld1q_s32(step_arr);\n    int j = 0;\n    for (; j <= m_odd - 4; j += 4) {\n        int32x4_t base = vdupq_n_s32(j);\n        int32x4_t j_vec = vaddq_s32(base, step_vec);\n        int32x4_t i_val = vaddq_s32(vshlq_n_s32(j_vec, 1), vdupq_n_s32(1));\n        int32x4_t i_plus1 = vaddq_s32(i_val, vdupq_n_s32(1));\n        int32x4_t prod = vmulq_s32(i_val, i_plus1);\n        int32x4_t tri_val = vshrq_n_s32(prod, 1);\n        vst1q_s32(&tri[j], tri_val);\n    }\n    for (; j < m_odd; j++) {\n        int i_val = 2 * j + 1;\n        tri[j] = (i_val * (i_val + 1)) / 2;\n    }\n\n    int current_fact = 1;\n    const int mod = 10000;\n    int count = 0;\n    for (int k = 1; count < m_even; k++) {\n        current_fact = (static_cast<long>(current_fact) * k) % mod;\n        if (k % 2 == 0) {\n            fact[count] = current_fact;\n            count++;\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        if (i % 2 == 0) {\n            result[i] = tri[i / 2];\n        } else {\n            result[i] = fact[i / 2];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> res(n);\n    if (n <= 0) return res;\n\n    if (n >= 1) {\n        res[0] = 1;\n    }\n    if (n >= 2) {\n        res[1] = 2;\n    }\n    if (n <= 2) {\n        return res;\n    }\n\n    for (int j = 2; j < n; j += 8) {\n        const uint32x4_t v_offsets = {0, 2, 4, 6};\n        uint32x4_t v_base = vaddq_u32(vdupq_n_u32(j), v_offsets);\n        uint32x4_t v1 = vaddq_u32(v_base, vdupq_n_u32(1));\n        uint32x4_t v2 = vaddq_u32(v_base, vdupq_n_u32(2));\n        uint32x4_t v_prod = vmulq_u32(v1, v2);\n        uint32x4_t v_value = vshrq_n_u32(v_prod, 1);\n\n        uint32_t values[4];\n        vst1q_u32(values, v_value);\n        for (int i = 0; i < 4; i++) {\n            int idx = j + 2 * i;\n            if (idx < n) {\n                res[idx] = values[i];\n            }\n        }\n    }\n\n    for (int j = 3; j < n; j += 2) {\n        int coef = ((j % 10000) * ((j + 1) % 10000)) % 10000;\n        res[j] = (res[j - 2] * coef) % 10000;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> res(n);\n    if (n == 0) return res;\n\n    int num_triangular = (n + 1) / 2;\n    std::vector<int> temp_tri(num_triangular);\n    \n    if (num_triangular > 0) {\n        int32x4_t inc_vector = vmovq_n_s32(0);\n        inc_vector = vsetq_lane_s32(1, inc_vector, 1);\n        inc_vector = vsetq_lane_s32(2, inc_vector, 2);\n        inc_vector = vsetq_lane_s32(3, inc_vector, 3);\n        \n        int j = 0;\n        for (; j <= num_triangular - 4; j += 4) {\n            int32x4_t base_vec = vdupq_n_s32(j);\n            int32x4_t j_vec = vaddq_s32(base_vec, inc_vector);\n            \n            int32x4_t j_sq = vmulq_s32(j_vec, j_vec);\n            int32x4_t term1 = vmulq_s32(vdupq_n_s32(2), j_sq);\n            int32x4_t term2 = vmulq_s32(vdupq_n_s32(3), j_vec);\n            int32x4_t T = vaddq_s32(term1, term2);\n            T = vaddq_s32(T, vdupq_n_s32(1));\n            \n            vst1q_s32(&temp_tri[j], T);\n        }\n        \n        for (; j < num_triangular; j++) {\n            temp_tri[j] = (2 * j + 1) * (j + 1);\n        }\n        \n        for (int i = 0; i < num_triangular; i++) {\n            res[2 * i] = temp_tri[i];\n        }\n    }\n    \n    int num_factorials = n / 2;\n    if (num_factorials > 0) {\n        int current = 2;\n        res[1] = current;\n        for (int j = 1; j < num_factorials; j++) {\n            long long product = (long long)current * (2 * j + 1);\n            product %= 10000;\n            product = product * (2 * j + 2);\n            product %= 10000;\n            current = (int)product;\n            res[2 * j + 1] = current;\n        }\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    int even_count = n / 2;\n    int odd_count = (n + 1) / 2;\n    std::vector<int> result(n);\n    std::vector<int> even_arr(even_count, 0);\n    std::vector<int> odd_arr(odd_count, 0);\n\n    if (even_count > 0) {\n        even_arr[0] = 2;\n        for (int j = 1; j < even_count; j++) {\n            long long temp = static_cast<long long>(even_arr[j - 1]) * (2 * j + 1);\n            temp %= 10000;\n            temp = temp * (2 * j + 2);\n            temp %= 10000;\n            even_arr[j] = static_cast<int>(temp);\n        }\n    }\n\n    int j_base = 0;\n    for (; j_base <= odd_count - 4; j_base += 4) {\n        uint32x4_t base_vec = vdupq_n_u32(j_base);\n        uint32x4_t inc = {0, 1, 2, 3};\n        uint32x4_t j = vaddq_u32(base_vec, inc);\n        uint32x4_t a = vmlaq_u32(vdupq_n_u32(1), vdupq_n_u32(2), j);\n        uint32x4_t b = vaddq_u32(j, vdupq_n_u32(1));\n        uint32x4_t res = vmulq_u32(a, b);\n        vst1q_u32(reinterpret_cast<uint32_t*>(&odd_arr[j_base]), res);\n    }\n    for (; j_base < odd_count; j_base++) {\n        odd_arr[j_base] = (2 * j_base + 1) * (j_base + 1);\n    }\n\n    uint32_t* result_ptr = reinterpret_cast<uint32_t*>(result.data());\n    int k = 0;\n    for (; k + 4 <= even_count; k += 4) {\n        uint32x4_t a = vld1q_u32(reinterpret_cast<uint32_t*>(&odd_arr[k]));\n        uint32x4_t b = vld1q_u32(reinterpret_cast<uint32_t*>(&even_arr[k]));\n        uint32x4x2_t zipped = {a, b};\n        vst2q_u32(result_ptr + 2 * k, zipped);\n    }\n    for (; k < even_count; k++) {\n        result[2 * k] = odd_arr[k];\n        result[2 * k + 1] = even_arr[k];\n    }\n    if (n % 2 == 1) {\n        result[2 * even_count] = odd_arr[even_count];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> res(n);\n    if (n <= 0) return res;\n\n    int m1 = (n + 1) / 2;\n    int m2 = n / 2;\n\n    uint32_t k = 0;\n    for (; k + 3 < m1; k += 4) {\n        uint32_t k_arr[4] = {k, k + 1, k + 2, k + 3};\n        uint32x4_t vk = vld1q_u32(k_arr);\n        uint32x4_t two = vdupq_n_u32(2);\n        uint32x4_t va = vmlaq_u32(vdupq_n_u32(1), two, vk);\n        uint32x4_t vb = vaddq_u32(vk, vdupq_n_u32(1));\n        uint32x4_t vres = vmulq_u32(va, vb);\n        uint32_t res_arr[4];\n        vst1q_u32(res_arr, vres);\n        res[2 * k] = res_arr[0];\n        res[2 * (k + 1)] = res_arr[1];\n        res[2 * (k + 2)] = res_arr[2];\n        res[2 * (k + 3)] = res_arr[3];\n    }\n    for (; k < m1; k++) {\n        res[2 * k] = (2 * k + 1) * (k + 1);\n    }\n\n    if (m2 > 0) {\n        std::vector<int> factors(m2);\n        int k_fact = 0;\n        for (; k_fact + 3 < m2; k_fact += 4) {\n            uint32_t k_arr[4] = {static_cast<uint32_t>(k_fact), static_cast<uint32_t>(k_fact + 1), static_cast<uint32_t>(k_fact + 2), static_cast<uint32_t>(k_fact + 3)};\n            uint32x4_t vk = vld1q_u32(k_arr);\n            uint32x4_t two = vdupq_n_u32(2);\n            uint32x4_t va = vmlaq_u32(vdupq_n_u32(1), two, vk);\n            uint32x4_t vb = vaddq_u32(va, vdupq_n_u32(1));\n            uint32x4_t vprod = vmulq_u32(va, vb);\n            uint32_t prod_arr[4];\n            vst1q_u32(prod_arr, vprod);\n            factors[k_fact] = prod_arr[0] % 10000;\n            factors[k_fact + 1] = prod_arr[1] % 10000;\n            factors[k_fact + 2] = prod_arr[2] % 10000;\n            factors[k_fact + 3] = prod_arr[3] % 10000;\n        }\n        for (; k_fact < m2; k_fact++) {\n            uint32_t a = 2 * k_fact + 1;\n            uint32_t b = a + 1;\n            factors[k_fact] = (a * b) % 10000;\n        }\n\n        int current = 1;\n        for (int i = 0; i < m2; i++) {\n            current = (current * factors[i]) % 10000;\n            res[2 * i + 1] = current;\n        }\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    if (n < 1) {\n        return {0, 0};\n    }\n    \n    auto is_palindrome_scalar = [](int x) -> bool {\n        if (x < 10) {\n            return true;\n        }\n        int rev = 0, temp = x;\n        while (temp) {\n            rev = rev * 10 + temp % 10;\n            temp /= 10;\n        }\n        return rev == x;\n    };\n    \n    uint32x4_t even_counts = vdupq_n_u32(0);\n    uint32x4_t odd_counts = vdupq_n_u32(0);\n    \n    for (int i = 1; i <= n; i += 4) {\n        int numbers_arr[4] = {0, 0, 0, 0};\n        uint32_t even_inc[4] = {0, 0, 0, 0};\n        uint32_t odd_inc[4] = {0, 0, 0, 0};\n        \n        for (int j = 0; j < 4; ++j) {\n            if (i + j <= n) {\n                numbers_arr[j] = i + j;\n            }\n        }\n        \n        for (int j = 0; j < 4; ++j) {\n            int x = numbers_arr[j];\n            if (x >= 1 && x <= n && is_palindrome_scalar(x)) {\n                if (x % 2 == 0) {\n                    even_inc[j] = 1;\n                } else {\n                    odd_inc[j] = 1;\n                }\n            }\n        }\n        \n        uint32x4_t even_inc_vec = vld1q_u32(even_inc);\n        uint32x4_t odd_inc_vec = vld1q_u32(odd_inc);\n        even_counts = vaddq_u32(even_counts, even_inc_vec);\n        odd_counts = vaddq_u32(odd_counts, odd_inc_vec);\n    }\n    \n    uint32_t even_total = vgetq_lane_u32(even_counts, 0)\n                        + vgetq_lane_u32(even_counts, 1)\n                        + vgetq_lane_u32(even_counts, 2)\n                        + vgetq_lane_u32(even_counts, 3);\n    uint32_t odd_total = vgetq_lane_u32(odd_counts, 0)\n                       + vgetq_lane_u32(odd_counts, 1)\n                       + vgetq_lane_u32(odd_counts, 2)\n                       + vgetq_lane_u32(odd_counts, 3);\n    \n    return {static_cast<int>(even_total), static_cast<int>(odd_total)};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> even_odd_palindrome_simd(int n){\n    static std::vector<int> rev_table(1025, 0);\n    static bool initialized = false;\n    if (!initialized) {\n        for (int i = 1; i <= 1024; i++) {\n            int rev = 0;\n            int temp = i;\n            while (temp) {\n                rev = rev * 10 + temp % 10;\n                temp /= 10;\n            }\n            rev_table[i] = rev;\n        }\n        initialized = true;\n    }\n\n    uint32x4_t even_v = vdupq_n_u32(0);\n    uint32x4_t odd_v = vdupq_n_u32(0);\n    int i = 1;\n\n    for (; i + 3 <= n; i += 4) {\n        uint32_t indices_arr[4] = {static_cast<uint32_t>(i), static_cast<uint32_t>(i+1), \n                                   static_cast<uint32_t>(i+2), static_cast<uint32_t>(i+3)};\n        uint32x4_t indices = vld1q_u32(indices_arr);\n\n        uint32_t rev_arr[4] = {static_cast<uint32_t>(rev_table[i]), \n                               static_cast<uint32_t>(rev_table[i+1]),\n                               static_cast<uint32_t>(rev_table[i+2]),\n                               static_cast<uint32_t>(rev_table[i+3])};\n        uint32x4_t rev = vld1q_u32(rev_arr);\n\n        uint32x4_t cmp = vceqq_u32(indices, rev);\n        uint32x4_t low_bit = vandq_u32(indices, vdupq_n_u32(1));\n        uint32x4_t even_mask = vceqq_u32(low_bit, vdupq_n_u32(0));\n\n        uint32x4_t even_inc = vandq_u32(cmp, even_mask);\n        even_inc = vandq_u32(even_inc, vdupq_n_u32(1));\n        even_v = vaddq_u32(even_v, even_inc);\n\n        uint32x4_t odd_inc = vandq_u32(cmp, vmvnq_u32(even_mask));\n        odd_inc = vandq_u32(odd_inc, vdupq_n_u32(1));\n        odd_v = vaddq_u32(odd_v, odd_inc);\n    }\n\n    uint32_t even_arr[4], odd_arr[4];\n    vst1q_u32(even_arr, even_v);\n    vst1q_u32(odd_arr, odd_v);\n    int even_count = 0, odd_count = 0;\n    for (int j = 0; j < 4; j++) {\n        even_count += even_arr[j];\n        odd_count += odd_arr[j];\n    }\n\n    for (int j = i; j <= n; j++) {\n        if (j == rev_table[j]) {\n            if (j % 2 == 0) {\n                even_count++;\n            } else {\n                odd_count++;\n            }\n        }\n    }\n\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <stdint.h>\n\nstatic inline uint32x4_t div10_u32(uint32x4_t v) {\n    uint32x2_t v_low = vget_low_u32(v);\n    uint32x2_t v_high = vget_high_u32(v);\n    uint64x2_t low_prod = vmull_u32(v_low, vdup_n_u32(0xCCCCCCCD));\n    uint64x2_t high_prod = vmull_u32(v_high, vdup_n_u32(0xCCCCCCCD));\n    low_prod = vshrq_n_u64(low_prod, 35);\n    high_prod = vshrq_n_u64(high_prod, 35);\n    uint32x2_t low_res = vmovn_u64(low_prod);\n    uint32x2_t high_res = vmovn_u64(high_prod);\n    return vcombine_u32(low_res, high_res);\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32_t total_even = 0;\n    uint32_t total_odd = 0;\n    for (uint32_t i = 1; i <= (uint32_t)n; i += 4) {\n        uint32_t data[4] = {i, i+1, i+2, i+3};\n        uint32x4_t v = vld1q_u32(data);\n        uint32x4_t mask_valid = vcleq_u32(v, vdupq_n_u32(n));\n        uint32x4_t v1 = div10_u32(v);\n        uint32x4_t d0 = vsubq_u32(v, vmulq_u32(v1, vdupq_n_u32(10)));\n        uint32x4_t v2 = div10_u32(v1);\n        uint32x4_t d1 = vsubq_u32(v1, vmulq_u32(v2, vdupq_n_u32(10)));\n        uint32x4_t v3 = div10_u32(v2);\n        uint32x4_t d2 = vsubq_u32(v2, vmulq_u32(v3, vdupq_n_u32(10)));\n        uint32x4_t d3 = v3;\n        uint32x4_t k = vdupq_n_u32(1);\n        k = vaddq_u32(k, vcgeq_u32(v, vdupq_n_u32(10)));\n        k = vaddq_u32(k, vcgeq_u32(v, vdupq_n_u32(100)));\n        k = vaddq_u32(k, vcgeq_u32(v, vdupq_n_u32(1000)));\n        uint32x4_t mask1 = vandq_u32(vceqq_u32(k, vdupq_n_u32(1)), mask_valid);\n        uint32x4_t mask2 = vandq_u32(vandq_u32(vceqq_u32(k, vdupq_n_u32(2)), vceqq_u32(d0, d1)), mask_valid);\n        uint32x4_t mask3 = vandq_u32(vandq_u32(vceqq_u32(k, vdupq_n_u32(3)), vceqq_u32(d0, d2)), mask_valid);\n        uint32x4_t mask4_cond = vandq_u32(vceqq_u32(d0, d3), vceqq_u32(d1, d2));\n        uint32x4_t mask4 = vandq_u32(vandq_u32(vceqq_u32(k, vdupq_n_u32(4)), mask4_cond), mask_valid);\n        uint32x4_t mask_pal = vorrq_u32(vorrq_u32(mask1, mask2), vorrq_u32(mask3, mask4));\n        uint32x4_t mask_even = vceqq_u32(vandq_u32(v, vdupq_n_u32(1)), vdupq_n_u32(0));\n        uint32x4_t mask_odd = vmvnq_u32(mask_even);\n        uint32x4_t even_pal = vandq_u32(mask_pal, mask_even);\n        even_pal = vshrq_n_u32(even_pal, 31);\n        uint32x4_t odd_pal = vandq_u32(mask_pal, mask_odd);\n        odd_pal = vshrq_n_u32(odd_pal, 31);\n        uint32x2_t low_even = vget_low_u32(even_pal);\n        uint32x2_t high_even = vget_high_u32(even_pal);\n        uint32x2_t sum_even = vadd_u32(low_even, high_even);\n        sum_even = vpadd_u32(sum_even, sum_even);\n        total_even += vget_lane_u32(sum_even, 0);\n        uint32x2_t low_odd = vget_low_u32(odd_pal);\n        uint32x2_t high_odd = vget_high_u32(odd_pal);\n        uint32x2_t sum_odd = vadd_u32(low_odd, high_odd);\n        sum_odd = vpadd_u32(sum_odd, sum_odd);\n        total_odd += vget_lane_u32(sum_odd, 0);\n    }\n    return {(int)total_even, (int)total_odd};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32x4_t even_total = vdupq_n_u32(0);\n    uint32x4_t odd_total = vdupq_n_u32(0);\n    uint16_t n16 = static_cast<uint16_t>(n);\n\n    for (uint32_t i = 1; i <= n; i += 4) {\n        uint16_t data[4] = {\n            static_cast<uint16_t>(i),\n            static_cast<uint16_t>(i + 1),\n            static_cast<uint16_t>(i + 2),\n            static_cast<uint16_t>(i + 3)\n        };\n        uint16x4_t v = vld1_u16(data);\n        uint16x4_t valid_mask = vcle_u16(v, vdup_n_u16(n16));\n        v = vand_u16(v, valid_mask);\n\n        uint32x4_t v32 = vmovl_u16(v);\n        uint32x4_t prod1 = vmulq_n_u32(v32, 52429);\n        uint32x4_t q1_32 = vshrq_n_u32(prod1, 19);\n        uint16x4_t v1 = vmovn_u32(q1_32);\n        uint16x4_t d0 = vmls_u16(v, v1, vdup_n_u16(10));\n\n        uint32x4_t v1_32 = vmovl_u16(v1);\n        uint32x4_t prod2 = vmulq_n_u32(v1_32, 52429);\n        uint32x4_t q2_32 = vshrq_n_u32(prod2, 19);\n        uint16x4_t v2 = vmovn_u32(q2_32);\n        uint16x4_t d1 = vmls_u16(v1, v2, vdup_n_u16(10));\n\n        uint32x4_t v2_32 = vmovl_u16(v2);\n        uint32x4_t prod3 = vmulq_n_u32(v2_32, 52429);\n        uint32x4_t q3_32 = vshrq_n_u32(prod3, 19);\n        uint16x4_t v3 = vmovn_u32(q3_32);\n        uint16x4_t d2 = vmls_u16(v2, v3, vdup_n_u16(10));\n        uint16x4_t d3 = v3;\n\n        uint16x4_t len = vdup_n_u16(1);\n        uint16x4_t mask10 = vcge_u16(v, vdup_n_u16(10));\n        len = vadd_u16(len, vand_u16(mask10, vdup_n_u16(1)));\n        uint16x4_t mask100 = vcge_u16(v, vdup_n_u16(100));\n        len = vadd_u16(len, vand_u16(mask100, vdup_n_u16(1)));\n        uint16x4_t mask1000 = vcge_u16(v, vdup_n_u16(1000));\n        len = vadd_u16(len, vand_u16(mask1000, vdup_n_u16(1)));\n\n        uint16x4_t cond = vdup_n_u16(0);\n        uint16x4_t maskL1 = vceq_u16(len, vdup_n_u16(1));\n        cond = vorr_u16(cond, maskL1);\n        uint16x4_t maskL2 = vceq_u16(len, vdup_n_u16(2));\n        uint16x4_t cond2 = vceq_u16(d0, d1);\n        cond = vorr_u16(cond, vand_u16(maskL2, cond2));\n        uint16x4_t maskL3 = vceq_u16(len, vdup_n_u16(3));\n        uint16x4_t cond3 = vceq_u16(d0, d2);\n        cond = vorr_u16(cond, vand_u16(maskL3, cond3));\n        uint16x4_t maskL4 = vceq_u16(len, vdup_n_u16(4));\n        uint16x4_t cond4a = vceq_u16(d0, d3);\n        uint16x4_t cond4b = vceq_u16(d1, d2);\n        uint16x4_t cond4 = vand_u16(cond4a, cond4b);\n        cond = vorr_u16(cond, vand_u16(maskL4, cond4));\n        cond = vand_u16(cond, valid_mask);\n\n        uint16x4_t even_mask = vceq_u16(vand_u16(v, vdup_n_u16(1)), vdup_n_u16(0));\n        uint16x4_t odd_mask = vmvn_u16(even_mask);\n        uint16x4_t even_cond = vand_u16(cond, even_mask);\n        uint16x4_t odd_cond = vand_u16(cond, odd_mask);\n        even_cond = vand_u16(even_cond, vdup_n_u16(1));\n        odd_cond = vand_u16(odd_cond, vdup_n_u16(1));\n\n        even_total = vaddq_u32(even_total, vmovl_u16(even_cond));\n        odd_total = vaddq_u32(odd_total, vmovl_u16(odd_cond));\n    }\n\n    uint32_t even_arr[4], odd_arr[4];\n    vst1q_u32(even_arr, even_total);\n    vst1q_u32(odd_arr, odd_total);\n    uint32_t even_count = even_arr[0] + even_arr[1] + even_arr[2] + even_arr[3];\n    uint32_t odd_count = odd_arr[0] + odd_arr[1] + odd_arr[2] + odd_arr[3];\n\n    return {static_cast<int>(even_count), static_cast<int>(odd_count)};\n}\n```"}
{"task_id": "SimdBench_113_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstatic int reverse_digits(int num) {\n    int rev = 0;\n    int n = num;\n    while (n != 0) {\n        rev = rev * 10 + n % 10;\n        n /= 10;\n    }\n    return rev;\n}\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    int even_count = 0;\n    int odd_count = 0;\n    for (int i = 1; i <= n; i += 4) {\n        int orig[4];\n        int rev_arr[4] = {0};\n        for (int j = 0; j < 4; j++) {\n            int num = i + j;\n            orig[j] = num;\n            if (num <= n) {\n                rev_arr[j] = reverse_digits(num);\n            }\n        }\n        uint32x4_t v_orig = vld1q_u32((const uint32_t*)orig);\n        uint32x4_t v_rev = vld1q_u32((const uint32_t*)rev_arr);\n        uint32x4_t v_cmp = vceqq_u32(v_orig, v_rev);\n        uint32x4_t v_parity = vandq_u32(v_orig, vdupq_n_u32(1));\n        uint32x4_t v_even_flag = vceqq_u32(v_parity, vdupq_n_u32(0));\n        uint32x4_t v_odd_flag = vceqq_u32(v_parity, vdupq_n_u32(1));\n        uint32x4_t v_even_mask = vandq_u32(v_cmp, v_even_flag);\n        uint32x4_t v_odd_mask = vandq_u32(v_cmp, v_odd_flag);\n        v_even_mask = vshrq_n_u32(v_even_mask, 31);\n        v_odd_mask = vshrq_n_u32(v_odd_mask, 31);\n        even_count += vaddvq_u32(v_even_mask);\n        odd_count += vaddvq_u32(v_odd_mask);\n    }\n    return {even_count, odd_count};\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int len = n.size();\n    int count = 0;\n    int i = 0;\n\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t sign_mask = vcltq_s32(v, zero);\n        int32x4_t abs_v = vabsq_s32(v);\n        uint32x4_t abs_v_u32 = vreinterpretq_u32_s32(abs_v);\n\n        uint32_t abs_arr[4];\n        uint32_t sign_arr[4];\n        vst1q_u32(abs_arr, abs_v_u32);\n        vst1q_u32(sign_arr, sign_mask);\n\n        uint32_t digits[10][4] = {{0}};\n        for (int j = 0; j < 4; j++) {\n            uint32_t num = abs_arr[j];\n            for (int d = 0; d < 10; d++) {\n                digits[d][j] = num % 10;\n                num /= 10;\n            }\n        }\n\n        uint32_t cond[10][4] = {{0}};\n        for (int j = 0; j < 4; j++) {\n            cond[9][j] = 0;\n        }\n        for (int d = 8; d >= 0; d--) {\n            for (int j = 0; j < 4; j++) {\n                cond[d][j] = (digits[d+1][j] != 0) || cond[d+1][j];\n            }\n        }\n\n        int32_t signs[4];\n        for (int j = 0; j < 4; j++) {\n            signs[j] = (sign_arr[j] != 0) ? -1 : 1;\n        }\n\n        int32x4_t total_vec = vdupq_n_s32(0);\n        for (int d = 9; d >= 0; d--) {\n            int32_t mult[4];\n            for (int j = 0; j < 4; j++) {\n                mult[j] = cond[d][j] ? 1 : signs[j];\n            }\n\n            int32_t digit_vals[4];\n            for (int j = 0; j < 4; j++) {\n                digit_vals[j] = digits[d][j];\n            }\n\n            int32x4_t mult_vec = vld1q_s32(mult);\n            int32x4_t digit_vec = vld1q_s32(digit_vals);\n            total_vec = vmlaq_s32(total_vec, mult_vec, digit_vec);\n        }\n\n        uint32x4_t mask = vcgtq_s32(total_vec, zero);\n        uint32x2_t low = vget_low_u32(mask);\n        uint32x2_t high = vget_high_u32(mask);\n        uint32x2_t sum2 = vadd_u32(low, high);\n        uint32x2_t sum = vpadd_u32(sum2, sum2);\n        count += vget_lane_u32(sum, 0);\n    }\n\n    for (; i < len; i++) {\n        int x = n[i];\n        int sign_val = (x < 0) ? -1 : 1;\n        uint32_t num = (x == INT_MIN) ? (uint32_t)INT_MIN : (uint32_t)std::abs(x);\n        uint32_t digits[10] = {0};\n        for (int d = 0; d < 10; d++) {\n            digits[d] = num % 10;\n            num /= 10;\n        }\n\n        uint32_t cond[10] = {0};\n        cond[9] = 0;\n        for (int d = 8; d >= 0; d--) {\n            cond[d] = (digits[d+1] != 0) || cond[d+1];\n        }\n\n        int total = 0;\n        for (int d = 9; d >= 0; d--) {\n            if (cond[d]) {\n                total += digits[d];\n            } else {\n                total += sign_val * digits[d];\n            }\n        }\n\n        if (total > 0) {\n            count++;\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    for (; i + 4 <= n.size(); i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t zero = vdupq_n_s32(0);\n        uint32x4_t positive_mask = vcgtq_s32(v, zero);\n        uint32x4_t negative_mask = vcltq_s32(v, zero);\n        uint32x4_t positive_count_vec = vandq_u32(positive_mask, vdupq_n_u32(1));\n        count += vaddvq_u32(positive_count_vec);\n        int32_t values[4];\n        vst1q_s32(values, v);\n        uint32_t negative_flags[4];\n        vst1q_u32(negative_flags, negative_mask);\n        for (int j = 0; j < 4; j++) {\n            if (negative_flags[j]) {\n                int32_t num = values[j];\n                if (num == 0) continue;\n                uint32_t abs_n = (num == INT_MIN) ? 2147483648u : static_cast<uint32_t>(-num);\n                uint32_t msd = 0;\n                uint32_t total_positive = 0;\n                uint32_t current = abs_n;\n                uint32_t divisor = 1000000000;\n                for (int k = 0; k < 10; k++) {\n                    if (divisor == 0) break;\n                    uint32_t digit = current / divisor;\n                    current %= divisor;\n                    if (digit != 0 && msd == 0) {\n                        msd = digit;\n                    }\n                    total_positive += digit;\n                    divisor /= 10;\n                }\n                int32_t total_signed = static_cast<int32_t>(total_positive) - 2 * msd;\n                if (total_signed > 0) {\n                    count++;\n                }\n            }\n        }\n    }\n    for (; i < n.size(); i++) {\n        int32_t num = n[i];\n        if (num > 0) {\n            count++;\n        } else if (num < 0) {\n            if (num == 0) continue;\n            uint32_t abs_n = (num == INT_MIN) ? 2147483648u : static_cast<uint32_t>(-num);\n            uint32_t msd = 0;\n            uint32_t total_positive = 0;\n            uint32_t current = abs_n;\n            uint32_t divisor = 1000000000;\n            for (int k = 0; k < 10; k++) {\n                if (divisor == 0) break;\n                uint32_t digit = current / divisor;\n                current %= divisor;\n                if (digit != 0 && msd == 0) {\n                    msd = digit;\n                }\n                total_positive += digit;\n                divisor /= 10;\n            }\n            int32_t total_signed = static_cast<int32_t>(total_positive) - 2 * msd;\n            if (total_signed > 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <climits>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    size_t len = n.size();\n    for (; i + 3 < len; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32_t values[4];\n        vst1q_s32(values, v);\n        uint32x4_t v_sign = vcltq_s32(v, vdupq_n_s32(0));\n        uint32_t signs[4];\n        vst1q_u32(signs, v_sign);\n        int32_t digit_sums[4] = {0};\n\n        for (int j = 0; j < 4; j++) {\n            int x = values[j];\n            if (x == 0) continue;\n            bool is_negative = (signs[j] != 0);\n            unsigned int u;\n            if (is_negative) {\n                if (x == INT_MIN) u = 2147483648U;\n                else u = -x;\n            } else {\n                u = x;\n            }\n            unsigned int temp = u;\n            while (temp >= 10) temp /= 10;\n            unsigned int first_digit = temp;\n            unsigned int num = u;\n            unsigned int digit_sum = 0;\n            while (num) {\n                digit_sum += num % 10;\n                num /= 10;\n            }\n            if (is_negative) digit_sum -= 2 * first_digit;\n            digit_sums[j] = digit_sum;\n        }\n\n        uint32x4_t v_cond = vdupq_n_u32(0);\n        for (int j = 0; j < 4; j++) {\n            if (digit_sums[j] > 0) v_cond = vsetq_lane_u32(1, v_cond, j);\n        }\n        uint32x2_t low = vget_low_u32(v_cond);\n        uint32x2_t high = vget_high_u32(v_cond);\n        uint32x2_t sum2 = vadd_u32(low, high);\n        count += vget_lane_u32(sum2, 0) + vget_lane_u32(sum2, 1);\n    }\n\n    for (; i < len; i++) {\n        int x = n[i];\n        if (x == 0) continue;\n        bool is_negative = (x < 0);\n        unsigned int u;\n        if (is_negative) {\n            if (x == INT_MIN) u = 2147483648U;\n            else u = -x;\n        } else {\n            u = x;\n        }\n        unsigned int temp = u;\n        while (temp >= 10) temp /= 10;\n        unsigned int first_digit = temp;\n        unsigned int num = u;\n        unsigned int digit_sum = 0;\n        while (num) {\n            digit_sum += num % 10;\n            num /= 10;\n        }\n        if (is_negative) digit_sum -= 2 * first_digit;\n        if (digit_sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int total_count = 0;\n    int len = n.size();\n    int i = 0;\n    const uint32_t div10_constant = 0xCCCCCCCD;\n\n    for (; i + 4 <= len; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t abs_v = vabsq_s32(v);\n        uint32x4_t sign_mask = vcltq_s32(v, vdupq_n_s32(0));\n        uint32x4_t u = vreinterpretq_u32_s32(abs_v);\n        uint32x4_t sum = vmovq_n_u32(0);\n        uint32x4_t msd = vmovq_n_u32(0);\n\n        for (int j = 0; j < 10; j++) {\n            uint32x2_t u_low = vget_low_u32(u);\n            uint32x2_t u_high = vget_high_u32(u);\n            uint64x2_t mul_low = vmull_u32(u_low, vdup_n_u32(div10_constant));\n            uint64x2_t mul_high = vmull_u32(u_high, vdup_n_u32(div10_constant));\n            mul_low = vshrq_n_u64(mul_low, 35);\n            mul_high = vshrq_n_u64(mul_high, 35);\n            uint32x2_t q_low = vmovn_u64(mul_low);\n            uint32x2_t q_high = vmovn_u64(mul_high);\n            uint32x4_t q = vcombine_u32(q_low, q_high);\n            uint32x4_t r = vmlsq_u32(u, q, vdupq_n_u32(10));\n            sum = vaddq_u32(sum, r);\n            uint32x4_t mask = vmvnq_u32(vceqq_u32(u, vmovq_n_u32(0)));\n            msd = vbslq_u32(mask, r, msd);\n            u = q;\n        }\n\n        int32x4_t s_sum = vreinterpretq_s32_u32(sum);\n        int32x4_t s_msd = vreinterpretq_s32_u32(msd);\n        int32x4_t adjustment = vandq_s32(vmulq_s32(s_msd, vdupq_n_s32(2)), vreinterpretq_s32_u32(sign_mask));\n        int32x4_t total_vec = vsubq_s32(s_sum, adjustment);\n        uint32x4_t cmp = vcgtq_s32(total_vec, vdupq_n_s32(0));\n        uint32x4_t cmp_bits = vshrq_n_u32(cmp, 31);\n        total_count += vaddvq_u32(cmp_bits);\n    }\n\n    for (; i < len; i++) {\n        int num = n[i];\n        int t = (num < 0) ? -num : num;\n        int s = 0;\n        int last_nonzero = 0;\n        for (int j = 0; j < 10; j++) {\n            int digit = t % 10;\n            s += digit;\n            if (t != 0) {\n                last_nonzero = digit;\n            }\n            t /= 10;\n        }\n        if (num < 0) {\n            s -= 2 * last_nonzero;\n        }\n        if (s > 0) {\n            total_count++;\n        }\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_114_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int i = 0;\n    const int size = n.size();\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t v = vld1q_s32(&n[i]);\n        int32x4_t abs_v = vabsq_s32(v);\n        uint32x4_t sign_mask = vcltzq_s32(v);\n\n        int32_t values[4];\n        int32_t signs[4];\n        vst1q_s32(values, abs_v);\n        vst1q_s32(signs, vreinterpretq_s32_u32(sign_mask));\n\n        int32_t digit_sums[4] = {0};\n        int32_t msds[4] = {0};\n\n        for (int j = 0; j < 4; j++) {\n            int t = values[j];\n            if (t == 0) continue;\n            int digit_sum = 0;\n            int msd = 0;\n            while (t) {\n                int digit = t % 10;\n                digit_sum += digit;\n                if (t < 10) msd = t;\n                t /= 10;\n            }\n            digit_sums[j] = digit_sum;\n            msds[j] = msd;\n        }\n\n        int32_t signed_digit_sums[4];\n        for (int j = 0; j < 4; j++) {\n            if (signs[j]) signed_digit_sums[j] = digit_sums[j] - 2 * msds[j];\n            else signed_digit_sums[j] = digit_sums[j];\n        }\n\n        int32x4_t signed_sums_vec = vld1q_s32(signed_digit_sums);\n        uint32x4_t mask = vcgtq_s32(signed_sums_vec, vdupq_n_s32(0));\n        count += vaddvq_u32(mask);\n    }\n\n    for (; i < size; i++) {\n        int x = n[i];\n        int sign = (x < 0);\n        int abs_x = abs(x);\n        int digit_sum = 0;\n        int msd = 0;\n        int t = abs_x;\n        if (t != 0) {\n            while (t) {\n                int digit = t % 10;\n                digit_sum += digit;\n                if (t < 10) msd = t;\n                t /= 10;\n            }\n        }\n        int signed_digit_sum = sign ? (digit_sum - 2 * msd) : digit_sum;\n        if (signed_digit_sum > 0) count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    int drops = 0;\n    if (arr[n - 1] > arr[0]) {\n        drops++;\n    }\n\n    size_t i = 0;\n    const size_t stride = 4;\n\n    if (n - 1 >= stride) {\n        for (; i <= n - 5; i += stride) {\n            int32x4_t v_curr = vld1q_s32(&arr[i]);\n            int32x4_t v_next = vld1q_s32(&arr[i + 1]);\n            uint32x4_t vcmp = vcgtq_s32(v_curr, v_next);\n            uint32x4_t v_ones = vshrq_n_u32(vcmp, 31);\n            uint32x2_t low = vget_low_u32(v_ones);\n            uint32x2_t high = vget_high_u32(v_ones);\n            uint32x2_t sum2 = vadd_u32(low, high);\n            sum2 = vpadd_u32(sum2, sum2);\n            drops += vget_lane_u32(sum2, 0);\n        }\n    }\n\n    for (; i < n - 1; i++) {\n        if (arr[i] > arr[i + 1]) {\n            drops++;\n        }\n    }\n\n    return drops <= 1;\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) \n        return true;\n\n    const int *data = arr.data();\n    int linear_end = n - 1;\n    int drops = 0;\n    int i = 0;\n\n    for (; i <= linear_end - 4; i += 4) {\n        int32x4_t v_current = vld1q_s32(data + i);\n        int32x4_t v_next = vld1q_s32(data + i + 1);\n\n        uint32x4_t vmask = vcgtq_s32(v_current, v_next);\n        vmask = vshrq_n_u32(vmask, 31);\n        drops += vaddvq_u32(vmask);\n    }\n\n    for (; i < linear_end; i++) {\n        if (data[i] > data[i+1])\n            drops++;\n    }\n\n    if (data[n-1] > data[0])\n        drops++;\n\n    return (drops <= 1);\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0 || n == 1) \n        return true;\n\n    int count = 0;\n    int i = 0;\n    const int* data = arr.data();\n    int n_minus_one = n - 1;\n\n    for (; i <= n_minus_one - 4; i += 4) {\n        int32x4_t a = vld1q_s32(data + i);\n        int32x4_t b = vld1q_s32(data + i + 1);\n        uint32x4_t cmp = vcgtq_s32(a, b);\n        uint32x4_t ones = vshrq_n_u32(cmp, 31);\n        count += vaddvq_u32(ones);\n    }\n\n    for (; i < n_minus_one; i++) {\n        if (data[i] > data[i+1])\n            count++;\n    }\n\n    if (data[n_minus_one] > data[0])\n        count++;\n\n    return (count <= 1);\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    int count = 0;\n    int i = 0;\n    const int step = 4;\n\n    for (; i <= n - 1 - step; i += step) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i+1]);\n        uint32x4_t cmp = vcgtq_s32(current, next);\n        int32x4_t signed_cmp = vreinterpretq_s32_u32(cmp);\n        int32_t sum = vaddvq_s32(signed_cmp);\n        count += (-sum);\n    }\n\n    for (; i < n - 1; i++) {\n        if (arr[i] > arr[i+1]) {\n            count++;\n        }\n    }\n\n    if (arr[n-1] > arr[0]) {\n        count++;\n    }\n\n    return (count <= 1);\n}\n```"}
{"task_id": "SimdBench_115_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n    \n    int count = 0;\n    int i = 0;\n    \n    for (; i <= n - 5; i += 4) {\n        int32x4_t current = vld1q_s32(&arr[i]);\n        int32x4_t next = vld1q_s32(&arr[i + 1]);\n        \n        uint32x4_t mask = vcgtq_s32(current, next);\n        uint32x4_t ones = vdupq_n_u32(1);\n        uint32x4_t and_result = vandq_u32(mask, ones);\n        \n        uint32x2_t low = vget_low_u32(and_result);\n        uint32x2_t high = vget_high_u32(and_result);\n        uint32x2_t sum2 = vadd_u32(low, high);\n        uint32_t s = vget_lane_u32(sum2, 0) + vget_lane_u32(sum2, 1);\n        count += s;\n    }\n    \n    for (; i < n - 1; ++i) {\n        if (arr[i] > arr[i + 1]) {\n            count++;\n        }\n    }\n    \n    if (count == 0) {\n        return true;\n    } else if (count == 1) {\n        return (arr[n - 1] <= arr[0]);\n    } else {\n        return false;\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    auto count_evens = [](const std::vector<int>& vec) -> int {\n        int n = vec.size();\n        if (n == 0) return 0;\n        const int32_t* data = vec.data();\n        int32x4_t ones = vdupq_n_s32(1);\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        int i = 0;\n\n        for (; i <= n - 4; i += 4) {\n            int32x4_t chunk = vld1q_s32(data + i);\n            int32x4_t t = vandq_s32(chunk, ones);\n            int32x4_t even_flags = vsubq_s32(ones, t);\n            sum_vec = vaddq_s32(sum_vec, even_flags);\n        }\n\n        int32x2_t low = vget_low_s32(sum_vec);\n        int32x2_t high = vget_high_s32(sum_vec);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int total = vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n\n        for (; i < n; i++) {\n            if ((vec[i] & 1) == 0) {\n                total++;\n            }\n        }\n        return total;\n    };\n\n    int total_evens = count_evens(lst1) + count_evens(lst2);\n    if (total_evens >= lst1.size()) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    const int* data1 = lst1.data();\n    const int* data2 = lst2.data();\n    uint32_t cnt1 = 0, cnt2 = 0;\n    size_t i = 0;\n\n    uint32x4_t v_cnt1 = vdupq_n_u32(0);\n    for (; i + 4 <= n1; i += 4) {\n        int32x4_t v = vld1q_s32(data1 + i);\n        uint32x4_t lsb = vandq_u32(vreinterpretq_u32_s32(v), vdupq_n_u32(1));\n        uint32x4_t even_flags = veorq_u32(lsb, vdupq_n_u32(1));\n        v_cnt1 = vaddq_u32(v_cnt1, even_flags);\n    }\n    uint32x2_t low1 = vget_low_u32(v_cnt1);\n    uint32x2_t high1 = vget_high_u32(v_cnt1);\n    uint32x2_t sum1 = vadd_u32(low1, high1);\n    cnt1 = vget_lane_u32(sum1, 0) + vget_lane_u32(sum1, 1);\n    for (; i < n1; i++) {\n        if (data1[i] % 2 == 0) cnt1++;\n    }\n\n    i = 0;\n    uint32x4_t v_cnt2 = vdupq_n_u32(0);\n    for (; i + 4 <= n2; i += 4) {\n        int32x4_t v = vld1q_s32(data2 + i);\n        uint32x4_t lsb = vandq_u32(vreinterpretq_u32_s32(v), vdupq_n_u32(1));\n        uint32x4_t even_flags = veorq_u32(lsb, vdupq_n_u32(1));\n        v_cnt2 = vaddq_u32(v_cnt2, even_flags);\n    }\n    uint32x2_t low2 = vget_low_u32(v_cnt2);\n    uint32x2_t high2 = vget_high_u32(v_cnt2);\n    uint32x2_t sum2 = vadd_u32(low2, high2);\n    cnt2 = vget_lane_u32(sum2, 0) + vget_lane_u32(sum2, 1);\n    for (; i < n2; i++) {\n        if (data2[i] % 2 == 0) cnt2++;\n    }\n\n    if (cnt1 + cnt2 >= n1) return \"YES\";\n    else return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    auto count_evens = [](const std::vector<int>& arr) -> unsigned int {\n        if (arr.empty()) return 0;\n        unsigned int sum = 0;\n        int i = 0;\n        int size = arr.size();\n        const uint32_t* data = reinterpret_cast<const uint32_t*>(arr.data());\n\n        for (; i <= size - 4; i += 4) {\n            uint32x4_t vec = vld1q_u32(data + i);\n            uint32x4_t lsb = vandq_u32(vec, vdupq_n_u32(1));\n            uint32x4_t mask = vceqq_u32(lsb, vdupq_n_u32(0));\n            uint32x4_t even_flags = vshrq_n_u32(mask, 31);\n            sum += vaddvq_u32(even_flags);\n        }\n\n        for (; i < size; i++) {\n            if ((arr[i] & 1) == 0) {\n                sum++;\n            }\n        }\n        return sum;\n    };\n\n    unsigned int total_evens = count_evens(lst1) + count_evens(lst2);\n    if (total_evens >= lst1.size()) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int32x4_t ones = vdupq_n_s32(1);\n    int total_odd1 = 0;\n    int n1 = lst1.size();\n    int i = 0;\n    for (; i <= n1 - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst1[i]);\n        int32x4_t lsb = vandq_s32(data, ones);\n        int32x2_t low = vget_low_s32(lsb);\n        int32x2_t high = vget_high_s32(lsb);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int32x2_t sum_total = vpadd_s32(sum2, sum2);\n        total_odd1 += vget_lane_s32(sum_total, 0);\n    }\n    for (; i < n1; i++) {\n        total_odd1 += (lst1[i] & 1);\n    }\n\n    int total_odd2 = 0;\n    int n2 = lst2.size();\n    i = 0;\n    for (; i <= n2 - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst2[i]);\n        int32x4_t lsb = vandq_s32(data, ones);\n        int32x2_t low = vget_low_s32(lsb);\n        int32x2_t high = vget_high_s32(lsb);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int32x2_t sum_total = vpadd_s32(sum2, sum2);\n        total_odd2 += vget_lane_s32(sum_total, 0);\n    }\n    for (; i < n2; i++) {\n        total_odd2 += (lst2[i] & 1);\n    }\n\n    if (total_odd1 + total_odd2 <= n2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    uint32_t count_total = 0;\n    size_t size1 = lst1.size();\n    size_t size2 = lst2.size();\n    const int* data1 = lst1.data();\n    const int* data2 = lst2.data();\n\n    // Count evens in lst1\n    size_t i = 0;\n    for (; i + 4 <= size1; i += 4) {\n        int32x4_t vec = vld1q_s32(data1 + i);\n        int32x4_t lsb = vandq_s32(vec, vdupq_n_s32(1));\n        uint32x4_t mask = vceqq_s32(lsb, vdupq_n_s32(0));\n        uint32x4_t ones = vshrq_n_u32(mask, 31);\n        count_total += vaddvq_u32(ones);\n    }\n    for (; i < size1; ++i) {\n        count_total += (data1[i] % 2 == 0);\n    }\n\n    // Count evens in lst2\n    i = 0;\n    for (; i + 4 <= size2; i += 4) {\n        int32x4_t vec = vld1q_s32(data2 + i);\n        int32x4_t lsb = vandq_s32(vec, vdupq_n_s32(1));\n        uint32x4_t mask = vceqq_s32(lsb, vdupq_n_s32(0));\n        uint32x4_t ones = vshrq_n_u32(mask, 31);\n        count_total += vaddvq_u32(ones);\n    }\n    for (; i < size2; ++i) {\n        count_total += (data2[i] % 2 == 0);\n    }\n\n    if (count_total >= lst1.size()) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    auto count_odd_digits = [](const std::string& s) -> int {\n        int n = s.size();\n        if (n == 0) return 0;\n        int count = 0;\n        int i = 0;\n        const uint8_t* data = (const uint8_t*)s.data();\n        \n        for (; i <= n - 16; i += 16) {\n            uint8x16_t vec = vld1q_u8(data + i);\n            uint8x16_t digits = vsubq_u8(vec, vdupq_n_u8('0'));\n            uint8x16_t mask = vandq_u8(digits, vdupq_n_u8(1));\n            uint16x8_t sum8 = vpaddlq_u8(mask);\n            uint32x4_t sum4 = vpaddlq_u16(sum8);\n            uint32_t partial = vgetq_lane_u32(sum4, 0) + vgetq_lane_u32(sum4, 1) + \n                              vgetq_lane_u32(sum4, 2) + vgetq_lane_u32(sum4, 3);\n            count += partial;\n        }\n        \n        for (; i < n; i++) {\n            uint8_t digit = s[i] - '0';\n            count += (digit & 1);\n        }\n        return count;\n    };\n    \n    std::vector<std::string> result;\n    std::string base = \"the number of odd elements in the string i of the input.\";\n    for (const auto& s : lst) {\n        int cnt = count_odd_digits(s);\n        std::string cnt_str = std::to_string(cnt);\n        std::string new_str;\n        for (char c : base) {\n            if (c == 'i') {\n                new_str += cnt_str;\n            } else {\n                new_str.push_back(c);\n            }\n        }\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result_vec;\n    for (const std::string& s : lst) {\n        size_t len = s.size();\n        const uint8_t *ptr = (const uint8_t*)s.data();\n        uint64_t total_count = 0;\n        size_t i = 0;\n\n        if (len >= 16) {\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t chunk = vld1q_u8(ptr + i);\n                uint8x16_t odd_flags = vandq_u8(chunk, vdupq_n_u8(1));\n                total_count += vaddlvq_u8(odd_flags);\n            }\n        }\n\n        for (; i < len; i++) {\n            total_count += (ptr[i] & 1);\n        }\n\n        std::string count_str = std::to_string(total_count);\n        std::string template_str = \"the number of odd elements in the string i of the input.\";\n        std::string out_str;\n        for (char c : template_str) {\n            if (c == 'i') {\n                out_str += count_str;\n            } else {\n                out_str.push_back(c);\n            }\n        }\n        result_vec.push_back(out_str);\n    }\n    return result_vec;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    result.reserve(lst.size());\n    static const uint8x16_t index_vec = []{\n        uint8_t temp[16] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15};\n        return vld1q_u8(temp);\n    }();\n    const std::string base = \"the number of odd elements in the string i of the input.\";\n\n    for (const auto& s : lst) {\n        int n = s.size();\n        uint32_t count = 0;\n        int i = 0;\n\n        for (; i <= n - 16; i += 16) {\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n            uint8x16_t odd_mask = vandq_u8(data, vdupq_n_u8(1));\n            count += vaddvq_u8(odd_mask);\n        }\n\n        int remaining = n - i;\n        if (remaining > 0) {\n            uint8x16_t mask = vcltq_u8(index_vec, vdupq_n_u8(static_cast<uint8_t>(remaining)));\n            uint8x16_t data = vld1q_u8(reinterpret_cast<const uint8_t*>(s.data() + i));\n            data = vandq_u8(data, mask);\n            uint8x16_t odd_mask = vandq_u8(data, vdupq_n_u8(1));\n            count += vaddvq_u8(odd_mask);\n        }\n\n        std::string count_str = std::to_string(count);\n        std::string output;\n        for (char c : base) {\n            if (c == 'i') {\n                output += count_str;\n            } else {\n                output += c;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cstdint>\n#include <arm_neon.h>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    const std::string base = \"the number of odd elements in the string i of the input.\";\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        uint32_t count = 0;\n        const uint8_t *ptr = reinterpret_cast<const uint8_t*>(s.data());\n        size_t len = s.size();\n        size_t i = 0;\n\n        for (; i + 16 <= len; i += 16) {\n            uint8x16_t v = vld1q_u8(ptr + i);\n            uint8x16_t v_odd = vandq_u8(v, vdupq_n_u8(1));\n            uint16x8_t vsum16 = vpaddlq_u8(v_odd);\n            uint32x4_t vsum32 = vpaddlq_u16(vsum16);\n            uint32_t sum0 = vgetq_lane_u32(vsum32, 0);\n            uint32_t sum1 = vgetq_lane_u32(vsum32, 1);\n            uint32_t sum2 = vgetq_lane_u32(vsum32, 2);\n            uint32_t sum3 = vgetq_lane_u32(vsum32, 3);\n            count += (sum0 + sum1 + sum2 + sum3);\n        }\n\n        for (; i < len; ++i) {\n            if (ptr[i] & 1) {\n                count++;\n            }\n        }\n\n        std::string count_str = std::to_string(count);\n        std::string new_string;\n        size_t start = 0;\n        size_t pos = base.find('i');\n        while (pos != std::string::npos) {\n            new_string += base.substr(start, pos - start);\n            new_string += count_str;\n            start = pos + 1;\n            pos = base.find('i', start);\n        }\n        new_string += base.substr(start);\n        result.push_back(new_string);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const std::string& s : lst) {\n        int count = 0;\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(s.data());\n        size_t len = s.size();\n        size_t i = 0;\n\n        if (len >= 16) {\n            uint8x16_t one = vdupq_n_u8(1);\n            for (; i <= len - 16; i += 16) {\n                uint8x16_t chunk = vld1q_u8(data + i);\n                uint8x16_t flags = vandq_u8(chunk, one);\n                uint16x8_t sum1 = vpaddlq_u8(flags);\n                uint32x4_t sum2 = vpaddlq_u16(sum1);\n                uint64x2_t sum3 = vpaddlq_u32(sum2);\n                count += vgetq_lane_u64(sum3, 0) + vgetq_lane_u64(sum3, 1);\n            }\n        }\n\n        for (; i < len; i++) {\n            count += (data[i] & 1);\n        }\n\n        std::string count_str = std::to_string(count);\n        std::string new_str;\n        for (char c : \"the number of odd elements in the string i of the input.\") {\n            if (c == 'i') {\n                new_str += count_str;\n            } else {\n                new_str += c;\n            }\n        }\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n#include <cstdint>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    const size_t n = nums.size();\n    if (n == 0) {\n        return 0;\n    }\n    int64_t min_sum = LLONG_MAX;\n    int64_t prefix = 0;\n    int64_t max_prefix = 0;\n\n    size_t i = 0;\n    for (; i + 1 < n; i += 2) {\n        const int64x2_t v = vld1q_s64(&nums[i]);\n        const int64x1_t low = vget_low_s64(v);\n        const int64x2_t temp = vcombine_s64(vcreate_s64(0), low);\n        const int64x2_t increments = vaddq_s64(v, temp);\n        const int64x2_t base = vaddq_s64(increments, vdupq_n_s64(prefix));\n\n        const int64_t base0 = vgetq_lane_s64(base, 0);\n        const int64_t base1 = vgetq_lane_s64(base, 1);\n\n        const int64_t candidate0 = base0 - max_prefix;\n        const int64_t new_max0 = (max_prefix > base0) ? max_prefix : base0;\n        const int64_t candidate1 = base1 - new_max0;\n        const int64_t new_max1 = (new_max0 > base1) ? new_max0 : base1;\n\n        if (candidate0 < min_sum) min_sum = candidate0;\n        if (candidate1 < min_sum) min_sum = candidate1;\n\n        prefix = base1;\n        max_prefix = new_max1;\n    }\n\n    if (i < n) {\n        prefix += nums[i];\n        const int64_t candidate = prefix - max_prefix;\n        if (candidate < min_sum) min_sum = candidate;\n        if (prefix > max_prefix) max_prefix = prefix;\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <climits>\n#include <vector>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    \n    int64_t min_sum = LLONG_MAX;\n    int64_t prefix = 0;\n    int64_t max_prefix = 0;\n    int i = 0;\n\n    for (; i <= n - 2; i += 2) {\n        int64x2_t v_nums = vld1q_s64(&nums[i]);\n        int64_t num0 = vgetq_lane_s64(v_nums, 0);\n        int64_t num1 = vgetq_lane_s64(v_nums, 1);\n        int64x2_t v_partial = vsetq_lane_s64(num0 + num1, v_nums, 1);\n        int64x2_t v_prefixes = vaddq_s64(vdupq_n_s64(prefix), v_partial);\n        int64_t prefix0 = vgetq_lane_s64(v_prefixes, 0);\n        int64_t prefix1 = vgetq_lane_s64(v_prefixes, 1);\n        \n        int64_t candidate0 = prefix0 - max_prefix;\n        int64_t max_prefix0 = std::max(max_prefix, prefix0);\n        int64_t candidate1 = prefix1 - max_prefix0;\n        \n        if (candidate0 < min_sum) min_sum = candidate0;\n        if (candidate1 < min_sum) min_sum = candidate1;\n        \n        max_prefix = std::max(max_prefix0, prefix1);\n        prefix = prefix1;\n    }\n\n    for (; i < n; ++i) {\n        prefix += nums[i];\n        int64_t candidate = prefix - max_prefix;\n        if (candidate < min_sum) min_sum = candidate;\n        if (prefix > max_prefix) max_prefix = prefix;\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n\n    int64_t state_prev = 0;\n    int64x2_t overall_min_vec = vdupq_n_s64(INT64_MAX);\n    int i = 0;\n\n    for (; i + 1 < n; i += 2) {\n        int64x2_t A = vld1q_s64(&nums[i]);\n        int64x2_t S_prev_vec = vdupq_n_s64(state_prev);\n        int64x2_t cand0 = A;\n        int64x2_t cand1 = vaddq_s64(S_prev_vec, A);\n        int64x2_t min0 = vminq_s64(cand0, cand1);\n        int64_t state0 = vgetq_lane_s64(min0, 0);\n        int64_t a1 = vgetq_lane_s64(A, 1);\n        int64x2_t cand2 = vsetq_lane_s64(state0 + a1, cand1, 1);\n        int64x2_t states = vminq_s64(cand0, cand2);\n        overall_min_vec = vminq_s64(overall_min_vec, states);\n        state_prev = vgetq_lane_s64(states, 1);\n    }\n\n    if (i < n) {\n        int64_t a = nums[i];\n        int64_t state0 = (a < state_prev + a) ? a : state_prev + a;\n        int64x2_t state_vec = vdupq_n_s64(state0);\n        overall_min_vec = vminq_s64(overall_min_vec, state_vec);\n    }\n\n    int64_t min1 = vgetq_lane_s64(overall_min_vec, 0);\n    int64_t min2 = vgetq_lane_s64(overall_min_vec, 1);\n    return (min1 < min2) ? min1 : min2;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int n = nums.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    std::vector<int64_t> P(n + 1);\n    P[0] = 0;\n    for (int i = 0; i < n; ++i) {\n        P[i + 1] = P[i] + nums[i];\n    }\n\n    int64_t global_min = INT64_MAX;\n    int64_t global_max_prefix = P[0];\n    int j = 1;\n\n    for (; j <= n - 1; j += 2) {\n        int64x2_t vP = vld1q_s64(&P[j]);\n        int64x2_t vBase0 = vdupq_n_s64(global_max_prefix);\n        int64x2_t vCand0 = vsubq_s64(vP, vBase0);\n        \n        int64_t new_base0 = global_max_prefix > P[j] ? global_max_prefix : P[j];\n        int64x2_t vBase1 = vdupq_n_s64(new_base0);\n        int64x2_t vCand1 = vsubq_s64(vP, vBase1);\n        \n        int64_t cand0 = vgetq_lane_s64(vCand0, 0);\n        int64_t cand1 = vgetq_lane_s64(vCand1, 1);\n        \n        if (cand0 < global_min) global_min = cand0;\n        if (cand1 < global_min) global_min = cand1;\n        \n        global_max_prefix = new_base0 > P[j + 1] ? new_base0 : P[j + 1];\n    }\n\n    if (j == n) {\n        int64_t cand = P[j] - global_max_prefix;\n        if (cand < global_min) global_min = cand;\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) {\n        return 0;\n    }\n    size_t n = nums.size();\n    std::vector<int64_t> prefix(n + 1);\n    prefix[0] = 0;\n\n    // Vectorized prefix sum computation\n    size_t i = 0;\n    int64_t carry = 0;\n    for (; i + 1 < n; i += 2) {\n        int64x2_t v_nums = vld1q_s64(&nums[i]);\n        int64x2_t v_scan = v_nums;\n        int64_t sum = vgetq_lane_s64(v_scan, 0) + vgetq_lane_s64(v_scan, 1);\n        v_scan = vsetq_lane_s64(sum, v_scan, 1);\n        int64x2_t v_carry = vdupq_n_s64(carry);\n        int64x2_t v_result = vaddq_s64(v_scan, v_carry);\n        vst1q_s64(&prefix[i + 1], v_result);\n        carry = vgetq_lane_s64(v_result, 1);\n    }\n    if (i < n) {\n        prefix[i + 1] = carry + nums[i];\n    }\n\n    // Find minimum subarray sum using prefix array\n    int64_t max_prefix = 0;\n    int64_t min_sum = LLONG_MAX;\n    i = 0;\n    for (; i + 1 < n; i += 2) {\n        int64x2_t v_p = vld1q_s64(&prefix[i]);\n        int64x2_t v_p_next = vld1q_s64(&prefix[i + 1]);\n\n        int64_t p0 = vgetq_lane_s64(v_p, 0);\n        int64_t p1 = vgetq_lane_s64(v_p, 1);\n        int64_t p_next0 = vgetq_lane_s64(v_p_next, 0);\n        int64_t p_next1 = vgetq_lane_s64(v_p_next, 1);\n\n        int64_t max0 = (max_prefix > p0) ? max_prefix : p0;\n        int64_t candidate0 = p_next0 - max0;\n        if (candidate0 < min_sum) min_sum = candidate0;\n\n        int64_t max1 = (max0 > p1) ? max0 : p1;\n        int64_t candidate1 = p_next1 - max1;\n        if (candidate1 < min_sum) min_sum = candidate1;\n\n        max_prefix = max1;\n    }\n    if (i < n) {\n        int64_t p0 = prefix[i];\n        int64_t candidate = prefix[i + 1] - ((max_prefix > p0) ? max_prefix : p0);\n        if (candidate < min_sum) min_sum = candidate;\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    if (capacity <= 0) {\n        return 0;\n    }\n    int total_ops = 0;\n    int rows = grid.size();\n    for (int i = 0; i < rows; i++) {\n        const std::vector<int>& row = grid[i];\n        int n = row.size();\n        if (n == 0) {\n            continue;\n        }\n        int ones_count = 0;\n        int j = 0;\n\n        if (n >= 4) {\n            int32x4_t sum_vec = vmovq_n_s32(0);\n            for (j = 0; j <= n - 4; j += 4) {\n                int32x4_t v = vld1q_s32(&row[j]);\n                sum_vec = vaddq_s32(sum_vec, v);\n            }\n            ones_count += vgetq_lane_s32(sum_vec, 0);\n            ones_count += vgetq_lane_s32(sum_vec, 1);\n            ones_count += vgetq_lane_s32(sum_vec, 2);\n            ones_count += vgetq_lane_s32(sum_vec, 3);\n        }\n\n        for (; j < n; j++) {\n            ones_count += row[j];\n        }\n\n        if (ones_count > 0) {\n            total_ops += (ones_count + capacity - 1) / capacity;\n        }\n    }\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int n_rows = grid.size();\n    if (n_rows == 0) return 0;\n    int n_cols = grid[0].size();\n\n    int total_ops = 0;\n\n    for (int r = 0; r < n_rows; r++) {\n        const std::vector<int>& row = grid[r];\n        const int* row_data = row.data();\n        int n = n_cols;\n\n        int32x4_t sum_vec = vdupq_n_s32(0);\n        int i = 0;\n\n        for (; i + 4 <= n; i += 4) {\n            int32x4_t v = vld1q_s32(row_data + i);\n            sum_vec = vaddq_s32(sum_vec, v);\n        }\n\n        int32x2_t low = vget_low_s32(sum_vec);\n        int32x2_t high = vget_high_s32(sum_vec);\n        int32x2_t sum2 = vadd_s32(low, high);\n        int row_sum = vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n\n        for (; i < n; i++) {\n            row_sum += row_data[i];\n        }\n\n        total_ops += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n#include <climits>\n#include <algorithm>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    if (grid.empty()) return 0;\n\n    uint64_t total_water = 0;\n    int max_well = 0;\n\n    for (const auto& row : grid) {\n        int n = row.size();\n        if (n == 0) continue;\n        \n        int row_sum = 0;\n        int j = 0;\n        int32x4_t vsum0 = vdupq_n_s32(0);\n        int32x4_t vsum1 = vdupq_n_s32(0);\n        int32x4_t vsum2 = vdupq_n_s32(0);\n        int32x4_t vsum3 = vdupq_n_s32(0);\n\n        for (; j + 15 < n; j += 16) {\n            int32x4_t v0 = vld1q_s32(&row[j]);\n            int32x4_t v1 = vld1q_s32(&row[j + 4]);\n            int32x4_t v2 = vld1q_s32(&row[j + 8]);\n            int32x4_t v3 = vld1q_s32(&row[j + 12]);\n\n            vsum0 = vaddq_s32(vsum0, v0);\n            vsum1 = vaddq_s32(vsum1, v1);\n            vsum2 = vaddq_s32(vsum2, v2);\n            vsum3 = vaddq_s32(vsum3, v3);\n        }\n\n        vsum0 = vaddq_s32(vsum0, vsum1);\n        vsum0 = vaddq_s32(vsum0, vsum2);\n        vsum0 = vaddq_s32(vsum0, vsum3);\n\n        int32_t temp[4];\n        vst1q_s32(temp, vsum0);\n        row_sum += temp[0] + temp[1] + temp[2] + temp[3];\n\n        for (; j < n; ++j) {\n            row_sum += row[j];\n        }\n\n        total_water += row_sum;\n        if (row_sum > max_well) {\n            max_well = row_sum;\n        }\n    }\n\n    if (total_water == 0) {\n        return 0;\n    }\n\n    uint64_t op_water = (total_water + capacity - 1) / capacity;\n    int op_by_water = (op_water > static_cast<uint64_t>(INT_MAX)) ? INT_MAX : static_cast<int>(op_water);\n    return std::max(max_well, op_by_water);\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_trips = 0;\n    int nrows = grid.size();\n    if (nrows == 0) \n        return 0;\n    int ncols = grid[0].size();\n\n    for (int i = 0; i < nrows; i++) {\n        const std::vector<int>& row = grid[i];\n        uint32_t count = 0;\n        int j = 0;\n        uint32x4_t v_sum = vmovq_n_u32(0);\n\n        for (; j <= ncols - 16; j += 16) {\n            uint32x4_t v0 = vld1q_u32((const uint32_t*)(row.data() + j));\n            uint32x4_t v1 = vld1q_u32((const uint32_t*)(row.data() + j + 4));\n            uint32x4_t v2 = vld1q_u32((const uint32_t*)(row.data() + j + 8));\n            uint32x4_t v3 = vld1q_u32((const uint32_t*)(row.data() + j + 12));\n\n            v0 = vaddq_u32(v0, v1);\n            v2 = vaddq_u32(v2, v3);\n            v0 = vaddq_u32(v0, v2);\n            v_sum = vaddq_u32(v_sum, v0);\n        }\n\n        for (; j <= ncols - 4; j += 4) {\n            uint32x4_t v = vld1q_u32((const uint32_t*)(row.data() + j));\n            v_sum = vaddq_u32(v_sum, v);\n        }\n\n        uint32_t tmp[4];\n        vst1q_u32(tmp, v_sum);\n        count = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n        for (; j < ncols; j++) {\n            count += row[j];\n        }\n\n        if (count > 0) {\n            total_trips += (count + (long long)capacity - 1) / capacity;\n        }\n    }\n\n    return (int)total_trips;\n}\n```"}
{"task_id": "SimdBench_119_Neon", "completion": "To solve this problem, we need to efficiently compute the total number of times buckets need to be lowered to empty all wells in a grid. Each well is represented by a row in the grid, and each '1' in the row represents a unit of water. The bucket capacity is given, and for each well, the number of bucket lowerings required is the ceiling of the total water in the well divided by the bucket capacity. The solution involves summing the water units in each well, computing the required bucket operations per well, and summing these operations across all wells.\n\n### Approach\n1. **Problem Analysis**: The problem requires processing each row (well) of the grid to count the number of '1's (water units). For each well, the number of bucket lowerings is calculated as `ceil(water_units / capacity)`. The total operations are the sum of these values across all wells.\n2. **Intuition**: Given the constraints (up to 10^5 rows and columns), a brute-force approach would be inefficient. Using SIMD (Single Instruction, Multiple Data) instructions allows processing multiple elements in parallel, significantly speeding up the summation of water units per well.\n3. **Algorithm Selection**: For each row, we use ARM Neon intrinsics to sum elements in chunks of 8 integers (two 128-bit registers of 4 integers each). This reduces the number of operations by leveraging parallel addition. The remaining elements (if any) are processed individually.\n4. **Optimization**: By processing elements in vectors, we minimize the number of memory accesses and arithmetic operations. The use of multiple accumulators (vsum0 and vsum1) helps in breaking dependency chains, allowing better instruction-level parallelism.\n5. **Complexity Analysis**: The approach processes each element once, leading to O(N*M) time complexity, where N is the number of rows and M is the number of columns. The Neon intrinsics reduce the constant factor, making the solution feasible for large inputs.\n\n### Solution Code\n```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    int n_rows = grid.size();\n    if (n_rows == 0) \n        return 0;\n    int n_cols = grid[0].size();\n    int total_operations = 0;\n\n    for (int i = 0; i < n_rows; i++) {\n        const std::vector<int>& row = grid[i];\n        int row_sum = 0;\n        int j = 0;\n\n        int32x4_t vsum0 = vdupq_n_s32(0);\n        int32x4_t vsum1 = vdupq_n_s32(0);\n\n        for (; j + 7 < n_cols; j += 8) {\n            int32x4_t v0 = vld1q_s32(&row[j]);\n            int32x4_t v1 = vld1q_s32(&row[j + 4]);\n            vsum0 = vaddq_s32(vsum0, v0);\n            vsum1 = vaddq_s32(vsum1, v1);\n        }\n\n        vsum0 = vaddq_s32(vsum0, vsum1);\n\n        if (j + 3 < n_cols) {\n            int32x4_t v = vld1q_s32(&row[j]);\n            vsum0 = vaddq_s32(vsum0, v);\n            j += 4;\n        }\n\n        int32_t tmp[4];\n        vst1q_s32(tmp, vsum0);\n        row_sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n        for (; j < n_cols; j++) {\n            row_sum += row[j];\n        }\n\n        total_operations += (row_sum + capacity - 1) / capacity;\n    }\n\n    return total_operations;\n}\n```\n\n### Explanation\n1. **Initialization**: The function starts by checking if the grid is empty. If so, it returns 0 immediately.\n2. **Processing Each Row**: For each row (well), the function initializes accumulators to zero. These accumulators (vsum0 and vsum1) are vector registers used to sum elements in parallel.\n3. **Vectorized Summation**: The inner loop processes eight integers at a time (two vectors of four integers each). Each pair of vectors is loaded and added to the accumulators. This reduces the number of addition operations by a factor of 8.\n4. **Combining Accumulators**: After processing chunks of eight elements, the accumulators are combined into one vector (vsum0).\n5. **Remaining Elements**: Any remaining elements (up to seven) are processed in a smaller vector chunk (four elements) or individually.\n6. **Final Summation**: The combined vector is stored into a temporary array, and the elements are summed to get the total water units in the well.\n7. **Bucket Operations Calculation**: For each well, the number of bucket operations is computed as `(water_units + capacity - 1) / capacity` (ceiling division) and added to the total operations.\n8. **Result**: The total operations across all wells are returned as the result.\n\nThis approach efficiently leverages SIMD instructions to handle large grids, ensuring optimal performance even for the upper constraint limits."}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total = 0;\n    int n = lst.size();\n    if (n == 0) \n        return 0;\n    \n    const int16_t* data_ptr = lst.data();\n    static const int16_t even_mask_array[8] = {1, 0, 1, 0, 1, 0, 1, 0};\n    const int16x8_t even_mask = vld1q_s16(even_mask_array);\n    const int16x8_t ones_vec = vdupq_n_s16(1);\n    \n    int i = 0;\n    for (; i <= n - 8; i += 8) {\n        int16x8_t vec = vld1q_s16(data_ptr + i);\n        int16x8_t odd_flag = vandq_s16(vec, ones_vec);\n        int16x8_t combined = vandq_s16(odd_flag, even_mask);\n        uint16x8_t mask_u16 = vceqq_s16(combined, ones_vec);\n        int16x8_t selected = vandq_s16(vec, vreinterpretq_s16_u16(mask_u16));\n        total += vaddlvq_s16(selected);\n    }\n    \n    for (; i < n; i++) {\n        if (i % 2 == 0 && (lst[i] & 1)) {\n            total += lst[i];\n        }\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    const int16_t* data = lst.data();\n    int n = lst.size();\n    int i = 0;\n    int64x2_t acc = vdupq_n_s64(0);\n\n    for (; i + 8 <= n; i += 8) {\n        int16x8_t vec = vld1q_s16(data + i);\n        int16x4_t low = vget_low_s16(vec);\n        int16x4_t high = vget_high_s16(vec);\n        int16x4x2_t deinter = vuzp_s16(low, high);\n        int16x4_t even_elements = deinter.val[0];\n        int16x4_t mask_odd = vand_s16(even_elements, vdup_n_s16(1));\n        int16x4_t selected = vmul_s16(even_elements, mask_odd);\n        int32x4_t selected32 = vmovl_s16(selected);\n        int32x2_t low32 = vget_low_s32(selected32);\n        int32x2_t high32 = vget_high_s32(selected32);\n        int64x2_t low64 = vmovl_s32(low32);\n        int64x2_t high64 = vmovl_s32(high32);\n        acc = vaddq_s64(acc, low64);\n        acc = vaddq_s64(acc, high64);\n    }\n\n    int64_t tail_sum = 0;\n    for (; i < n; i++) {\n        if (i % 2 == 0) {\n            if (data[i] % 2 != 0) {\n                tail_sum += data[i];\n            }\n        }\n    }\n\n    int64_t simd_sum = vgetq_lane_s64(acc, 0) + vgetq_lane_s64(acc, 1);\n    return simd_sum + tail_sum;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int n = lst.size();\n    int i = 0;\n    if (n == 0) {\n        return 0;\n    }\n\n    int64x2_t acc64 = vdupq_n_s64(0);\n    static const uint16_t even_mask_data[8] = {0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0, 0xFFFF, 0};\n    uint16x8_t even_pos_mask = vld1q_u16(even_mask_data);\n\n    for (; i + 8 <= n; i += 8) {\n        int16x8_t v0 = vld1q_s16(&lst[i]);\n        int16x8_t ones = vdupq_n_s16(1);\n        int16x8_t v_odd = vandq_s16(v0, ones);\n        uint16x8_t v_odd_mask = vceqq_s16(v_odd, ones);\n        uint16x8_t combined_mask = vandq_u16(v_odd_mask, even_pos_mask);\n        int16x8_t v_selected = vandq_s16(v0, vreinterpretq_s16_u16(combined_mask));\n        int32x4_t low32 = vmovl_s16(vget_low_s16(v_selected));\n        int32x4_t high32 = vmovl_s16(vget_high_s16(v_selected));\n        int32x4_t sum32 = vaddq_s32(low32, high32);\n        int64x2_t chunk_sum = vpaddlq_s32(sum32);\n        acc64 = vaddq_s64(acc64, chunk_sum);\n    }\n\n    int64_t total = vgetq_lane_s64(acc64, 0) + vgetq_lane_s64(acc64, 1);\n    for (; i < n; i++) {\n        if (i % 2 == 0 && (lst[i] & 1)) {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total = 0;\n    int n = lst.size();\n    int i = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    const int16x8_t v_ones = vdupq_n_s16(1);\n    const int16_t even_mask_arr[8] = { -1, 0, -1, 0, -1, 0, -1, 0 };\n    const int16x8_t v_even_mask = vld1q_s16(even_mask_arr);\n\n    for (; i <= n - 8; i += 8) {\n        int16x8_t v_lst = vld1q_s16(&lst[i]);\n        int16x8_t v_odd = vandq_s16(v_lst, v_ones);\n        int16x8_t v_odd_mask = vceqq_s16(v_odd, v_ones);\n        int16x8_t condition_mask = vandq_s16(v_odd_mask, v_even_mask);\n        int16x8_t v_selected = vandq_s16(v_lst, condition_mask);\n\n        int32x4_t sum32 = vpaddlq_s16(v_selected);\n        int64x2_t sum64 = vpaddlq_s32(sum32);\n        total += vgetq_lane_s64(sum64, 0) + vgetq_lane_s64(sum64, 1);\n    }\n\n    for (; i < n; i++) {\n        if (i % 2 == 0 && (lst[i] & 1)) {\n            total += lst[i];\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_120_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <vector>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    const uint16_t idx_arr[8] = {0, 1, 2, 3, 4, 5, 6, 7};\n    uint16x8_t idx = vld1q_u16(idx_arr);\n    uint16x8_t idx_mod2 = vandq_u16(idx, vdupq_n_u16(1));\n    uint16x8_t mask_even_base = vceqq_u16(idx_mod2, vdupq_n_u16(0));\n    uint16x8_t mask_odd_base = vceqq_u16(idx_mod2, vdupq_n_u16(1));\n\n    int64x2_t accumulator = vdupq_n_s64(0);\n    int i = 0;\n\n    for (; i <= n - 8; i += 8) {\n        int16x8_t data = vld1q_s16(lst.data() + i);\n        uint16x8_t base_vec = vdupq_n_u16(i & 1);\n        uint16x8_t even_mask = vbslq_u16(base_vec, mask_odd_base, mask_even_base);\n        int16x8_t one = vdupq_n_s16(1);\n        uint16x8_t odd_mask = vreinterpretq_u16_s16(vtstq_s16(data, one));\n        uint16x8_t final_mask = vandq_u16(even_mask, odd_mask);\n        int16x8_t selected = vandq_s16(data, vreinterpretq_s16_u16(final_mask));\n        int32x4_t sum32 = vpaddlq_s16(selected);\n        int32x2_t low32 = vget_low_s32(sum32);\n        int32x2_t high32 = vget_high_s32(sum32);\n        int64x2_t low64 = vmovl_s32(low32);\n        int64x2_t high64 = vmovl_s32(high32);\n        int64x2_t chunk_sum = vaddq_s64(low64, high64);\n        accumulator = vaddq_s64(accumulator, chunk_sum);\n    }\n\n    int64_t remainder_sum = 0;\n    for (; i < n; i++) {\n        if (i % 2 == 0 && (lst[i] & 1)) {\n            remainder_sum += lst[i];\n        }\n    }\n\n    int64_t total = vgetq_lane_s64(accumulator, 0) + vgetq_lane_s64(accumulator, 1) + remainder_sum;\n    return total;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int32_t sum = 0;\n    int i = 0;\n    int32x4_t accum = vdupq_n_s32(0);\n\n    for (; i <= k - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&arr[i]);\n        uint32x4_t mask_low = vcgeq_s32(data, vdupq_n_s32(-99));\n        uint32x4_t mask_high = vcleq_s32(data, vdupq_n_s32(99));\n        uint32x4_t mask = vandq_u32(mask_low, mask_high);\n        int32x4_t masked_data = vandq_s32(data, vreinterpretq_s32_u32(mask));\n        accum = vaddq_s32(accum, masked_data);\n    }\n\n    sum += vgetq_lane_s32(accum, 0);\n    sum += vgetq_lane_s32(accum, 1);\n    sum += vgetq_lane_s32(accum, 2);\n    sum += vgetq_lane_s32(accum, 3);\n\n    for (; i < k; i++) {\n        int val = arr[i];\n        if (val >= -99 && val <= 99) {\n            sum += val;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    const int32_t *data = arr.data();\n    int i = 0;\n    int32x4_t acc = vdupq_n_s32(0);\n\n    for (; i <= k - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(data + i);\n        int32x4_t low_bound = vdupq_n_s32(-99);\n        int32x4_t high_bound = vdupq_n_s32(99);\n        uint32x4_t mask_low = vcgeq_s32(vec, low_bound);\n        uint32x4_t mask_high = vcleq_s32(vec, high_bound);\n        uint32x4_t mask = vandq_u32(mask_low, mask_high);\n        int32x4_t selected = vandq_s32(vec, vreinterpretq_s32_u32(mask));\n        acc = vaddq_s32(acc, selected);\n    }\n\n    int32x2_t low_acc = vget_low_s32(acc);\n    int32x2_t high_acc = vget_high_s32(acc);\n    int32x2_t sum2 = vadd_s32(low_acc, high_acc);\n    int32_t sum = vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n\n    for (; i < k; i++) {\n        int32_t x = data[i];\n        if (x >= -99 && x <= 99) {\n            sum += x;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int i = 0;\n    int32x4_t v_low_bound = vdupq_n_s32(-99);\n    int32x4_t v_high_bound = vdupq_n_s32(99);\n    int32x4_t v_acc = vdupq_n_s32(0);\n\n    for (; i <= k - 4; i += 4) {\n        int32x4_t v_data = vld1q_s32(arr.data() + i);\n        uint32x4_t cmp_low = vcgeq_s32(v_data, v_low_bound);\n        uint32x4_t cmp_high = vcleq_s32(v_data, v_high_bound);\n        uint32x4_t cmp_both = vandq_u32(cmp_low, cmp_high);\n        int32x4_t v_selected = vandq_s32(v_data, vreinterpretq_s32_u32(cmp_both));\n        v_acc = vaddq_s32(v_acc, v_selected);\n    }\n\n    int32_t partial_sum[4];\n    vst1q_s32(partial_sum, v_acc);\n    int sum = partial_sum[0] + partial_sum[1] + partial_sum[2] + partial_sum[3];\n\n    for (; i < k; i++) {\n        int x = arr[i];\n        if (x >= -99 && x <= 99) {\n            sum += x;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int32x4_t vsum = vdupq_n_s32(0);\n    int i = 0;\n    const int32_t* data_ptr = arr.data();\n\n    for (; i <= k - 4; i += 4) {\n        int32x4_t data = vld1q_s32(data_ptr + i);\n        int32x4_t low_bound = vdupq_n_s32(-99);\n        int32x4_t high_bound = vdupq_n_s32(99);\n\n        uint32x4_t mask_low = vcgeq_s32(data, low_bound);\n        uint32x4_t mask_high = vcleq_s32(data, high_bound);\n        uint32x4_t mask = vandq_u32(mask_low, mask_high);\n\n        int32x4_t masked_data = vandq_s32(data, vreinterpretq_s32_u32(mask));\n        vsum = vaddq_s32(vsum, masked_data);\n    }\n\n    int32_t sum = vgetq_lane_s32(vsum, 0) + vgetq_lane_s32(vsum, 1) +\n                  vgetq_lane_s32(vsum, 2) + vgetq_lane_s32(vsum, 3);\n\n    for (; i < k; i++) {\n        int x = arr[i];\n        if (x >= -99 && x <= 99) {\n            sum += x;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_Neon", "completion": "```cpp\n#include <vector>\n#include <arm_neon.h>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int total = 0;\n    int i = 0;\n    const int32x4_t v_low = vdupq_n_s32(-99);\n    const int32x4_t v_high = vdupq_n_s32(99);\n    int32x4_t acc = vdupq_n_s32(0);\n\n    for (; i <= k - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&arr[i]);\n        uint32x4_t mask_low = vcgeq_s32(data, v_low);\n        uint32x4_t mask_high = vcleq_s32(data, v_high);\n        uint32x4_t mask = vandq_u32(mask_low, mask_high);\n        int32x4_t masked_data = vandq_s32(data, vreinterpretq_s32_u32(mask));\n        acc = vaddq_s32(acc, masked_data);\n    }\n\n    int32x2_t low = vget_low_s32(acc);\n    int32x2_t high = vget_high_s32(acc);\n    int32x2_t sum2 = vadd_s32(low, high);\n    total = vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n\n    for (; i < k; ++i) {\n        int val = arr[i];\n        if (val >= -99 && val <= 99) {\n            total += val;\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    const size_t n = lst.size();\n    if (n <= 1) {\n        return true;\n    }\n    const uint32_t* ptr = reinterpret_cast<const uint32_t*>(lst.data());\n\n    // Condition 1: Check non-decreasing order\n    size_t i1 = 0;\n    for (; i1 + 5 <= n; i1 += 4) {\n        uint32x4_t vcurrent = vld1q_u32(ptr + i1);\n        uint32x4_t vnext = vld1q_u32(ptr + i1 + 1);\n        uint32x4_t cmp = vcleq_u32(vcurrent, vnext);\n        if (vminvq_u32(cmp) == 0) {\n            return false;\n        }\n    }\n    for (; i1 < n - 1; ++i1) {\n        if (ptr[i1] > ptr[i1 + 1]) {\n            return false;\n        }\n    }\n\n    // Condition 2: Check for triple duplicates\n    size_t i2 = 0;\n    for (; i2 + 6 <= n; i2 += 4) {\n        uint32x4_t v0 = vld1q_u32(ptr + i2);\n        uint32x4_t v1 = vld1q_u32(ptr + i2 + 1);\n        uint32x4_t v2 = vld1q_u32(ptr + i2 + 2);\n        uint32x4_t eq1 = vceqq_u32(v0, v1);\n        uint32x4_t eq2 = vceqq_u32(v0, v2);\n        uint32x4_t eq3 = vandq_u32(eq1, eq2);\n        if (vmaxvq_u32(eq3) != 0) {\n            return false;\n        }\n    }\n    for (; i2 <= n - 3; ++i2) {\n        if (ptr[i2] == ptr[i2 + 1] && ptr[i2] == ptr[i2 + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    const int * ptr = lst.data();\n    size_t n = lst.size();\n    if (n <= 1) \n        return true;\n\n    size_t i = 0;\n    if (n >= 5) {\n        for (; i <= n - 5; i += 4) {\n            int32x4_t cur = vld1q_s32(ptr + i);\n            int32x4_t next = vld1q_s32(ptr + i + 1);\n            uint32x4_t cmp = vcleq_s32(cur, next);\n            if (vminvq_u32(cmp) == 0)\n                return false;\n        }\n    }\n    for (; i < n - 1; i++) {\n        if (ptr[i] > ptr[i+1])\n            return false;\n    }\n\n    if (n < 3)\n        return true;\n\n    size_t j = 0;\n    if (n >= 6) {\n        for (; j <= n - 6; j += 4) {\n            int32x4_t v0 = vld1q_s32(ptr + j);\n            int32x4_t v1 = vld1q_s32(ptr + j + 1);\n            int32x4_t v2 = vld1q_s32(ptr + j + 2);\n            uint32x4_t cmp01 = vceqq_s32(v0, v1);\n            uint32x4_t cmp12 = vceqq_s32(v1, v2);\n            uint32x4_t cmp = vandq_u32(cmp01, cmp12);\n            if (vmaxvq_u32(cmp) != 0)\n                return false;\n        }\n    }\n    for (; j < n - 2; j++) {\n        if (ptr[j] == ptr[j+1] && ptr[j] == ptr[j+2])\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) return true;\n    if (n == 2) return lst[0] <= lst[1];\n\n    size_t i = 0;\n    if (n >= 6) {\n        for (; i <= n-6; i += 4) {\n            int32x4_t v0 = vld1q_s32(&lst[i]);\n            int32x4_t v1 = vld1q_s32(&lst[i+1]);\n            int32x4_t v2 = vld1q_s32(&lst[i+2]);\n\n            uint32x4_t le = vcleq_s32(v0, v1);\n            if (vminvq_u32(le) == 0) \n                return false;\n\n            uint32x4_t eq0 = vceqq_s32(v0, v1);\n            uint32x4_t eq1 = vceqq_s32(v1, v2);\n            uint32x4_t triple_eq = vandq_u32(eq0, eq1);\n            if (vmaxvq_u32(triple_eq) != 0) \n                return false;\n        }\n    }\n\n    for (size_t j = i; j < n-1; ++j) {\n        if (lst[j] > lst[j+1]) \n            return false;\n        if (j + 2 < n) {\n            if (lst[j] == lst[j+1] && lst[j] == lst[j+2]) \n                return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    const int* data = lst.data();\n    size_t i = 0;\n\n    while (i + 5 < n) {\n        int32x4_t a = vld1q_s32(data + i);\n        int32x4_t b = vld1q_s32(data + i + 1);\n        int32x4_t c = vld1q_s32(data + i + 2);\n\n        uint32x4_t le_mask = vcleq_s32(a, b);\n        if (vminvq_u32(le_mask) == 0) {\n            return false;\n        }\n\n        uint32x4_t eq_ab = vceqq_s32(a, b);\n        uint32x4_t eq_bc = vceqq_s32(b, c);\n        uint32x4_t eq_abc = vandq_u32(eq_ab, eq_bc);\n        if (vmaxvq_u32(eq_abc) != 0) {\n            return false;\n        }\n\n        i += 4;\n    }\n\n    size_t tail_start = i;\n    for (size_t j = tail_start; j < n - 1; j++) {\n        if (data[j] > data[j + 1]) {\n            return false;\n        }\n    }\n\n    for (size_t j = tail_start; j <= n - 3; j++) {\n        if (data[j] == data[j + 1] && data[j + 1] == data[j + 2]) {\n            return false;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n == 0) \n        return true;\n    if (n == 1)\n        return true;\n    if (n == 2)\n        return lst[0] <= lst[1];\n\n    size_t i = 0;\n    for (; i <= n-5; i += 4) {\n        int32x4_t a0 = vld1q_s32(&lst[i]);\n        int32x4_t a1 = vld1q_s32(&lst[i+1]);\n        uint32x4_t cmp = vcleq_s32(a0, a1);\n        if (vminvq_u32(cmp) != 0xFFFFFFFF) {\n            return false;\n        }\n    }\n    for (; i < n-1; i++) {\n        if (lst[i] > lst[i+1])\n            return false;\n    }\n\n    if (n < 3)\n        return true;\n\n    i = 0;\n    for (; i <= n-6; i += 4) {\n        int32x4_t A = vld1q_s32(&lst[i]);\n        int32x4_t B = vld1q_s32(&lst[i+1]);\n        int32x4_t C = vld1q_s32(&lst[i+2]);\n        uint32x4_t cmp1 = vceqq_s32(A, B);\n        uint32x4_t cmp2 = vceqq_s32(A, C);\n        uint32x4_t mask = vandq_u32(cmp1, cmp2);\n        if (vmaxvq_u32(mask) != 0) {\n            return false;\n        }\n    }\n    for (; i < n-2; i++) {\n        if (lst[i] == lst[i+1] && lst[i] == lst[i+2])\n            return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int n = arr.size();\n    bool has_zero = false;\n    int32x4_t vabs_sum = vdupq_n_s32(0);\n    int32x4_t vnegative_count = vdupq_n_s32(0);\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        uint32x4_t cmp0 = vceqq_s32(v, vdupq_n_s32(0));\n        uint32x2_t reduced = vorr_u32(vget_low_u32(cmp0), vget_high_u32(cmp0));\n        uint32_t any_zero = vget_lane_u32(reduced, 0) | vget_lane_u32(reduced, 1);\n        if (any_zero) {\n            has_zero = true;\n            break;\n        }\n        int32x4_t vabs = vabsq_s32(v);\n        vabs_sum = vaddq_s32(vabs_sum, vabs);\n        uint32x4_t cmp_neg = vcltq_s32(v, vdupq_n_s32(0));\n        vnegative_count = vsubq_s32(vnegative_count, vreinterpretq_s32_u32(cmp_neg));\n    }\n\n    if (!has_zero && i < n) {\n        int32_t tail[4] = {0};\n        for (int j = 0; j < n - i; j++) {\n            tail[j] = arr[i + j];\n        }\n        int32x4_t v = vld1q_s32(tail);\n        uint32_t idx_arr[4] = {0, 1, 2, 3};\n        uint32x4_t vidx = vld1q_u32(idx_arr);\n        uint32x4_t valid_mask = vcltq_u32(vidx, vdupq_n_u32(n - i));\n        uint32x4_t cmp0 = vceqq_s32(v, vdupq_n_s32(0));\n        cmp0 = vandq_u32(cmp0, valid_mask);\n        uint32x2_t reduced = vorr_u32(vget_low_u32(cmp0), vget_high_u32(cmp0));\n        uint32_t any_zero = vget_lane_u32(reduced, 0) | vget_lane_u32(reduced, 1);\n        if (any_zero) {\n            has_zero = true;\n        } else {\n            int32x4_t vabs = vabsq_s32(v);\n            vabs_sum = vaddq_s32(vabs_sum, vabs);\n            uint32x4_t cmp_neg = vcltq_s32(v, vdupq_n_s32(0));\n            vnegative_count = vsubq_s32(vnegative_count, vreinterpretq_s32_u32(cmp_neg));\n        }\n    }\n\n    if (has_zero) {\n        return 0;\n    }\n\n    int32x2_t sum2 = vadd_s32(vget_low_s32(vabs_sum), vget_high_s32(vabs_sum));\n    int32_t total_abs = vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n\n    int32x2_t neg2 = vadd_s32(vget_low_s32(vnegative_count), vget_high_s32(vnegative_count));\n    int32_t total_neg = vget_lane_s32(neg2, 0) + vget_lane_s32(neg2, 1);\n    int sign_product = (total_neg & 1) ? -1 : 1;\n\n    return sign_product * total_abs;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int n = arr.size();\n    int i = 0;\n\n    uint32x4_t v_zero_accum = vdupq_n_u32(0);\n    uint32x4_t v_neg_accum = vdupq_n_u32(0);\n    int32x4_t v_abs_sum = vdupq_n_s32(0);\n\n    for (; i <= n-4; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        int32x4_t v_abs = vabsq_s32(v);\n        v_abs_sum = vaddq_s32(v_abs_sum, v_abs);\n\n        uint32x4_t v_zero_mask = vceqq_s32(v, vdupq_n_s32(0));\n        v_zero_accum = vorrq_u32(v_zero_accum, v_zero_mask);\n\n        uint32x4_t v_neg_mask = vcltq_s32(v, vdupq_n_s32(0));\n        v_neg_mask = vandq_u32(v_neg_mask, vdupq_n_u32(1));\n        v_neg_accum = vaddq_u32(v_neg_accum, v_neg_mask);\n    }\n\n    int32x2_t low_abs = vget_low_s32(v_abs_sum);\n    int32x2_t high_abs = vget_high_s32(v_abs_sum);\n    int32x2_t sum_abs = vadd_s32(low_abs, high_abs);\n    sum_abs = vpadd_s32(sum_abs, sum_abs);\n    int total_abs = vget_lane_s32(sum_abs, 0);\n\n    uint32x2_t low_neg = vget_low_u32(v_neg_accum);\n    uint32x2_t high_neg = vget_high_u32(v_neg_accum);\n    uint32x2_t sum_neg = vadd_u32(low_neg, high_neg);\n    sum_neg = vpadd_u32(sum_neg, sum_neg);\n    uint32_t total_neg = vget_lane_u32(sum_neg, 0);\n\n    uint32x2_t low_zero = vget_low_u32(v_zero_accum);\n    uint32x2_t high_zero = vget_high_u32(v_zero_accum);\n    uint32x2_t orred = vorr_u32(low_zero, high_zero);\n    orred = vorr_u32(orred, vrev64_u32(orred));\n    bool has_zero_simd = vget_lane_u32(orred, 0) != 0;\n\n    bool has_zero_tail = false;\n    for (; i < n; i++) {\n        int x = arr[i];\n        if (x == 0) {\n            has_zero_tail = true;\n        } else {\n            total_abs += (x < 0) ? -x : x;\n            if (x < 0) {\n                total_neg++;\n            }\n        }\n    }\n\n    if (has_zero_simd || has_zero_tail) {\n        return 0;\n    } else {\n        int sign = (total_neg % 2 == 0) ? 1 : -1;\n        return sign * total_abs;\n    }\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    size_t n = arr.size();\n    int32x4_t v_sum_abs = vdupq_n_s32(0);\n    int total_neg_count = 0;\n    bool found_zero = false;\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n        uint32x4_t zero_mask = vceqq_s32(v, vdupq_n_s32(0));\n        uint32_t any_zero = vmaxvq_u32(zero_mask);\n        if (any_zero) {\n            found_zero = true;\n            break;\n        }\n        v_sum_abs = vaddq_s32(v_sum_abs, vabsq_s32(v));\n        int32x4_t v_sign = vshrq_n_s32(v, 31);\n        int32_t sign_sum = vaddvq_s32(v_sign);\n        total_neg_count += (-sign_sum);\n    }\n\n    if (found_zero) {\n        return 0;\n    }\n\n    int tail_abs_sum = 0;\n    for (; i < n; ++i) {\n        int val = arr[i];\n        if (val == 0) {\n            found_zero = true;\n            break;\n        }\n        tail_abs_sum += std::abs(val);\n        if (val < 0) {\n            total_neg_count++;\n        }\n    }\n\n    if (found_zero) {\n        return 0;\n    }\n\n    int32_t abs_sum_vec = vaddvq_s32(v_sum_abs);\n    int total_abs = abs_sum_vec + tail_abs_sum;\n    int sign_product = (total_neg_count % 2 == 0) ? 1 : -1;\n\n    return sign_product * total_abs;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    size_t n = arr.size();\n    size_t i = 0;\n    bool has_zero = false;\n    int total_neg_count = 0;\n    int32_t sum_abs = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t v = vld1q_s32(&arr[i]);\n\n        uint32x4_t zero_mask = vceqq_s32(v, vdupq_n_s32(0));\n        uint32x2_t low_zero = vget_low_u32(zero_mask);\n        uint32x2_t high_zero = vget_high_u32(zero_mask);\n        uint32x2_t zero_reduced = vorr_u32(low_zero, high_zero);\n        if (vget_lane_u32(zero_reduced, 0) || vget_lane_u32(zero_reduced, 1)) {\n            has_zero = true;\n            break;\n        }\n\n        uint32x4_t neg_mask = vcltq_s32(v, vdupq_n_s32(0));\n        uint32x4_t neg_counts = vshrq_n_u32(neg_mask, 31);\n        uint32x2_t low_neg = vget_low_u32(neg_counts);\n        uint32x2_t high_neg = vget_high_u32(neg_counts);\n        uint32x2_t sum_neg = vadd_u32(low_neg, high_neg);\n        uint32_t count = vget_lane_u32(sum_neg, 0) + vget_lane_u32(sum_neg, 1);\n        total_neg_count += count;\n\n        int32x4_t abs_v = vabsq_s32(v);\n        int32x2_t low_abs = vget_low_s32(abs_v);\n        int32x2_t high_abs = vget_high_s32(abs_v);\n        int32x2_t sum_abs2 = vadd_s32(low_abs, high_abs);\n        int32_t chunk_sum = vget_lane_s32(sum_abs2, 0) + vget_lane_s32(sum_abs2, 1);\n        sum_abs += chunk_sum;\n    }\n\n    if (has_zero) {\n        return 0;\n    }\n\n    for (; i < n; i++) {\n        int x = arr[i];\n        if (x == 0) {\n            return 0;\n        }\n        if (x < 0) {\n            total_neg_count++;\n            sum_abs += -x;\n        } else {\n            sum_abs += x;\n        }\n    }\n\n    int sign = (total_neg_count & 1) ? -1 : 1;\n    return sign * sum_abs;\n}\n```"}
{"task_id": "SimdBench_123_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int n = arr.size();\n    const int32_t* data = arr.data();\n    uint32x4_t any_zero_acc = vdupq_n_u32(0);\n    int32x4_t neg_count_acc = vdupq_n_s32(0);\n    int32x4_t sum_abs_acc = vdupq_n_s32(0);\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t vec = vld1q_s32(data + i);\n        uint32x4_t zero_mask = vceqq_s32(vec, vdupq_n_s32(0));\n        any_zero_acc = vorrq_u32(any_zero_acc, zero_mask);\n        int32x4_t abs_vec = vabsq_s32(vec);\n        sum_abs_acc = vaddq_s32(sum_abs_acc, abs_vec);\n        uint32x4_t neg_mask = vcltq_s32(vec, vdupq_n_s32(0));\n        neg_count_acc = vsubq_s32(neg_count_acc, vreinterpretq_s32_u32(neg_mask));\n    }\n    uint32x2_t any_zero_low = vget_low_u32(any_zero_acc);\n    uint32x2_t any_zero_high = vget_high_u32(any_zero_acc);\n    uint32x2_t any_zero_reduced = vorr_u32(any_zero_low, any_zero_high);\n    uint32_t any_zero_vector = vget_lane_u32(any_zero_reduced, 0) | vget_lane_u32(any_zero_reduced, 1);\n    int32x2_t neg_low = vget_low_s32(neg_count_acc);\n    int32x2_t neg_high = vget_high_s32(neg_count_acc);\n    int32x2_t neg_sum = vadd_s32(neg_low, neg_high);\n    neg_sum = vpadd_s32(neg_sum, neg_sum);\n    int32_t neg_count_vector = vget_lane_s32(neg_sum, 0);\n    int32x2_t abs_low = vget_low_s32(sum_abs_acc);\n    int32x2_t abs_high = vget_high_s32(sum_abs_acc);\n    int32x2_t abs_sum = vadd_s32(abs_low, abs_high);\n    abs_sum = vpadd_s32(abs_sum, abs_sum);\n    int32_t sum_abs_vector = vget_lane_s32(abs_sum, 0);\n    bool any_zero_remainder = false;\n    int neg_count_remainder = 0;\n    int sum_abs_remainder = 0;\n    for (; i < n; i++) {\n        int x = arr[i];\n        if (x == 0) {\n            any_zero_remainder = true;\n        } else if (x < 0) {\n            neg_count_remainder++;\n        }\n        sum_abs_remainder += std::abs(x);\n    }\n    bool any_zero_final = (any_zero_vector != 0) || any_zero_remainder;\n    int neg_count_final = neg_count_vector + neg_count_remainder;\n    int sum_abs_final = sum_abs_vector + sum_abs_remainder;\n    int sign_prod;\n    if (any_zero_final) {\n        sign_prod = 0;\n    } else {\n        sign_prod = (neg_count_final % 2 == 0) ? 1 : -1;\n    }\n    return sign_prod * sum_abs_final;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    if (N == 0) {\n        return {};\n    }\n\n    int global_min = INT_MAX;\n    for (int i = 0; i < N; i++) {\n        const int* row = grid[i].data();\n        int j = 0;\n        int32x4_t vmin = vdupq_n_s32(global_min);\n        int remaining = N;\n        while (remaining >= 4) {\n            int32x4_t v = vld1q_s32(row + j);\n            vmin = vminq_s32(vmin, v);\n            j += 4;\n            remaining -= 4;\n        }\n        int32_t tmp[4];\n        vst1q_s32(tmp, vmin);\n        for (int t = 0; t < 4; t++) {\n            if (tmp[t] < global_min) {\n                global_min = tmp[t];\n            }\n        }\n        for (; j < N; j++) {\n            if (row[j] < global_min) {\n                global_min = row[j];\n            }\n        }\n    }\n\n    int min_i = -1, min_j = -1;\n    bool found = false;\n    for (int i = 0; i < N && !found; i++) {\n        const int* row = grid[i].data();\n        int j = 0;\n        int remaining = N;\n        while (remaining >= 4) {\n            int32x4_t v = vld1q_s32(row + j);\n            uint32x4_t mask = vceqq_s32(v, vdupq_n_s32(global_min));\n            uint32_t lane0 = vgetq_lane_u32(mask, 0);\n            uint32_t lane1 = vgetq_lane_u32(mask, 1);\n            uint32_t lane2 = vgetq_lane_u32(mask, 2);\n            uint32_t lane3 = vgetq_lane_u32(mask, 3);\n            if (lane0) {\n                min_i = i; min_j = j; found = true; break;\n            } else if (lane1) {\n                min_i = i; min_j = j+1; found = true; break;\n            } else if (lane2) {\n                min_i = i; min_j = j+2; found = true; break;\n            } else if (lane3) {\n                min_i = i; min_j = j+3; found = true; break;\n            }\n            j += 4;\n            remaining -= 4;\n        }\n        if (found) continue;\n        for (; j < N; j++) {\n            if (row[j] == global_min) {\n                min_i = i; min_j = j;\n                found = true;\n                break;\n            }\n        }\n    }\n\n    std::vector<int> path;\n    path.push_back(global_min);\n    if (k == 1) {\n        return path;\n    }\n\n    int current_i = min_i, current_j = min_j;\n    for (int step = 1; step < k; step++) {\n        int neighbors[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n        int next_i[4], next_j[4];\n\n        if (current_i > 0) {\n            next_i[0] = current_i - 1;\n            next_j[0] = current_j;\n            neighbors[0] = grid[next_i[0]][next_j[0]];\n        }\n        if (current_i < N-1) {\n            next_i[1] = current_i + 1;\n            next_j[1] = current_j;\n            neighbors[1] = grid[next_i[1]][next_j[1]];\n        }\n        if (current_j > 0) {\n            next_i[2] = current_i;\n            next_j[2] = current_j - 1;\n            neighbors[2] = grid[next_i[2]][next_j[2]];\n        }\n        if (current_j < N-1) {\n            next_i[3] = current_i;\n            next_j[3] = current_j + 1;\n            neighbors[3] = grid[next_i[3]][next_j[3]];\n        }\n\n        int32x4_t nv = vld1q_s32(neighbors);\n        int min_val_neighbor = vminvq_s32(nv);\n        uint32x4_t mask = vceqq_s32(nv, vdupq_n_s32(min_val_neighbor));\n        int index = 0;\n        if (vgetq_lane_u32(mask, 0)) {\n            index = 0;\n        } else if (vgetq_lane_u32(mask, 1)) {\n            index = 1;\n        } else if (vgetq_lane_u32(mask, 2)) {\n            index = 2;\n        } else {\n            index = 3;\n        }\n\n        current_i = next_i[index];\n        current_j = next_j[index];\n        path.push_back(min_val_neighbor);\n    }\n\n    return path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <set>\n#include <climits>\n#include <algorithm>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    if (k == 1) {\n        int min_val = INT_MAX;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] < min_val) {\n                    min_val = grid[i][j];\n                }\n            }\n        }\n        return {min_val};\n    }\n\n    int total = n * n;\n    std::vector<int> flat(total);\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            flat[i * n + j] = grid[i][j];\n        }\n    }\n\n    int a0 = INT_MAX;\n    int idx = 0;\n    while (idx <= total - 4) {\n        int32x4_t v = vld1q_s32(&flat[idx]);\n        int32x4_t vmin = vminq_s32(v, vdupq_n_s32(INT_MAX));\n        int32_t min_arr[4];\n        vst1q_s32(min_arr, vmin);\n        a0 = std::min({a0, min_arr[0], min_arr[1], min_arr[2], min_arr[3]});\n        idx += 4;\n    }\n    for (; idx < total; idx++) {\n        if (flat[idx] < a0) {\n            a0 = flat[idx];\n        }\n    }\n\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == a0) {\n                start_i = i;\n                start_j = j;\n                break;\n            }\n        }\n    }\n\n    std::vector<int> ans = {a0};\n    std::set<std::pair<int, int>> currentSet;\n    currentSet.insert({start_i, start_j});\n\n    const int dx[4] = {-1, 1, 0, 0};\n    const int dy[4] = {0, 0, -1, 1};\n\n    for (int step = 1; step < k; step++) {\n        std::vector<int> candidate_vals;\n        for (const auto &cell : currentSet) {\n            int i = cell.first;\n            int j = cell.second;\n            for (int d = 0; d < 4; d++) {\n                int ni = i + dx[d];\n                int nj = j + dy[d];\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                    candidate_vals.push_back(grid[ni][nj]);\n                }\n            }\n        }\n\n        if (candidate_vals.empty()) {\n            break;\n        }\n\n        int min_val = INT_MAX;\n        int size = candidate_vals.size();\n        idx = 0;\n        int32x4_t vmin = vdupq_n_s32(INT_MAX);\n        while (idx <= size - 4) {\n            int32x4_t v = vld1q_s32(&candidate_vals[idx]);\n            vmin = vminq_s32(vmin, v);\n            idx += 4;\n        }\n        int32_t min_arr[4];\n        vst1q_s32(min_arr, vmin);\n        min_val = std::min({min_arr[0], min_arr[1], min_arr[2], min_arr[3]});\n        for (; idx < size; idx++) {\n            if (candidate_vals[idx] < min_val) {\n                min_val = candidate_vals[idx];\n            }\n        }\n\n        ans.push_back(min_val);\n\n        std::set<std::pair<int, int>> nextSet;\n        for (const auto &cell : currentSet) {\n            int i = cell.first;\n            int j = cell.second;\n            for (int d = 0; d < 4; d++) {\n                int ni = i + dx[d];\n                int nj = j + dy[d];\n                if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                    if (grid[ni][nj] == min_val) {\n                        nextSet.insert({ni, nj});\n                    }\n                }\n            }\n        }\n\n        currentSet = nextSet;\n    }\n\n    return ans;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <climits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int start_i = 0, start_j = 0;\n    int min_val_global = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] < min_val_global) {\n                min_val_global = grid[i][j];\n                start_i = i;\n                start_j = j;\n            }\n        }\n    }\n\n    std::vector<int> path;\n    path.push_back(min_val_global);\n    if (k == 1) {\n        return path;\n    }\n\n    int current_i = start_i, current_j = start_j;\n    const int dirs[4][2] = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n\n    for (int step = 2; step <= k; step++) {\n        int32_t neighbor_vals[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n\n        for (int d = 0; d < 4; d++) {\n            int ni = current_i + dirs[d][0];\n            int nj = current_j + dirs[d][1];\n            if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                neighbor_vals[d] = grid[ni][nj];\n            }\n        }\n\n        int32x4_t vec = vld1q_s32(neighbor_vals);\n        int32x2_t low = vget_low_s32(vec);\n        int32x2_t high = vget_high_s32(vec);\n        int32x2_t min2 = vmin_s32(low, high);\n        int32x2_t min_final = vpmin_s32(min2, min2);\n        int min_val_step = vget_lane_s32(min_final, 0);\n\n        path.push_back(min_val_step);\n\n        for (int d = 0; d < 4; d++) {\n            if (neighbor_vals[d] == min_val_step) {\n                current_i = current_i + dirs[d][0];\n                current_j = current_j + dirs[d][1];\n                break;\n            }\n        }\n    }\n\n    return path;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    std::vector<int> res;\n    if (k <= 0) return res;\n    int N = grid.size();\n    int r0 = -1, c0 = -1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                r0 = i;\n                c0 = j;\n            }\n        }\n    }\n    if (r0 == -1) return res;\n    res.push_back(1);\n    int r = r0, c = c0;\n    if (k == 1) return res;\n    const int big = 1000000000;\n    const int dr[4] = {-1, 1, 0, 0};\n    const int dc[4] = {0, 0, -1, 1};\n    for (int step = 1; step < k; step++) {\n        int neighbors_val[4] = {big, big, big, big};\n        int neighbors_r[4], neighbors_c[4];\n        for (int i = 0; i < 4; i++) {\n            int nr = r + dr[i];\n            int nc = c + dc[i];\n            neighbors_r[i] = nr;\n            neighbors_c[i] = nc;\n            if (nr >= 0 && nr < N && nc >= 0 && nc < N) {\n                neighbors_val[i] = grid[nr][nc];\n            }\n        }\n        int32x4_t vec = vld1q_s32(neighbors_val);\n        int32_t min_val_scalar = vminvq_s32(vec);\n        int32x4_t min_vec = vdupq_n_s32(min_val_scalar);\n        uint32x4_t mask = vceqq_s32(vec, min_vec);\n        uint32_t mask0 = vgetq_lane_u32(mask, 0);\n        uint32_t mask1 = vgetq_lane_u32(mask, 1);\n        uint32_t mask2 = vgetq_lane_u32(mask, 2);\n        uint32_t mask3 = vgetq_lane_u32(mask, 3);\n        int index = 0;\n        if (mask0 != 0) {\n            index = 0;\n        } else if (mask1 != 0) {\n            index = 1;\n        } else if (mask2 != 0) {\n            index = 2;\n        } else if (mask3 != 0) {\n            index = 3;\n        }\n        r = neighbors_r[index];\n        c = neighbors_c[index];\n        res.push_back(min_val_scalar);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_124_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int N = grid.size();\n    int max_val = N * N;\n    int r0 = -1, c0 = -1;\n    const int one = 1;\n    int32x4_t v_one = vdupq_n_s32(one);\n\n    for (int i = 0; i < N; i++) {\n        const int* row = grid[i].data();\n        int j = 0;\n        for (; j <= N-4; j += 4) {\n            int32x4_t v = vld1q_s32(row + j);\n            uint32x4_t cmp = vceqq_s32(v, v_one);\n            uint64x2_t mask64 = vreinterpretq_u64_u32(cmp);\n            uint64_t low = vgetq_lane_u64(mask64, 0);\n            uint64_t high = vgetq_lane_u64(mask64, 1);\n            if (low) {\n                if (low & 0xFFFFFFFF) {\n                    r0 = i; \n                    c0 = j;\n                    break;\n                } else if (low & 0xFFFFFFFF00000000) {\n                    r0 = i; \n                    c0 = j+1;\n                    break;\n                }\n            }\n            if (high) {\n                if (high & 0xFFFFFFFF) {\n                    r0 = i; \n                    c0 = j+2;\n                    break;\n                } else if (high & 0xFFFFFFFF00000000) {\n                    r0 = i; \n                    c0 = j+3;\n                    break;\n                }\n            }\n        }\n        if (r0 != -1) break;\n\n        for (; j < N; j++) {\n            if (row[j] == one) {\n                r0 = i;\n                c0 = j;\n                break;\n            }\n        }\n        if (r0 != -1) break;\n    }\n\n    if (r0 == -1) {\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (grid[i][j] == 1) {\n                    r0 = i;\n                    c0 = j;\n                    break;\n                }\n            }\n            if (r0 != -1) break;\n        }\n    }\n\n    std::vector<int> res;\n    res.push_back(1);\n    int r = r0, c = c0;\n    for (int step = 1; step < k; step++) {\n        int next_val = max_val + 1;\n        int next_r = -1, next_c = -1;\n\n        if (r - 1 >= 0) {\n            int candidate = grid[r-1][c];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r-1;\n                next_c = c;\n            }\n        }\n        if (r + 1 < N) {\n            int candidate = grid[r+1][c];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r+1;\n                next_c = c;\n            }\n        }\n        if (c - 1 >= 0) {\n            int candidate = grid[r][c-1];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r;\n                next_c = c-1;\n            }\n        }\n        if (c + 1 < N) {\n            int candidate = grid[r][c+1];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r;\n                next_c = c+1;\n            }\n        }\n\n        r = next_r;\n        c = next_c;\n        res.push_back(next_val);\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <stdint.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8_t arr[20];\n    int d = 0;\n    uint64_t num = n;\n    while (num) {\n        arr[d++] = num % 10;\n        num /= 10;\n    }\n\n    uint64_t product = 1;\n    int found_odd = 0;\n\n    for (int i = 0; i < d; i += 8) {\n        int len = (d - i) < 8 ? (d - i) : 8;\n        uint8_t chunk[8] = {0};\n\n        for (int j = 0; j < len; j++) {\n            chunk[j] = arr[i + j];\n        }\n\n        uint8x8_t digit_vec = vld1_u8(chunk);\n        uint8x8_t one_vec = vdup_n_u8(1);\n        uint8x8_t mod_vec = vand_u8(digit_vec, one_vec);\n        uint8x8_t odd_mask = vceq_u8(mod_vec, one_vec);\n\n        uint64x1_t mask64 = vreinterpret_u64_u8(odd_mask);\n        if (vget_lane_u64(mask64, 0) != 0) {\n            found_odd = 1;\n        }\n\n        uint8x8_t factors = vbsl_u8(odd_mask, digit_vec, one_vec);\n        uint8_t fac_arr[8];\n        vst1_u8(fac_arr, factors);\n\n        for (int j = 0; j < 8; j++) {\n            product *= fac_arr[j];\n        }\n    }\n\n    if (!found_odd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) {\n        return 0;\n    }\n\n    uint8_t digits[20] = {0};\n    int len = 0;\n    uint64_t temp = n;\n    while (temp) {\n        digits[len++] = temp % 10;\n        temp /= 10;\n    }\n\n    uint32_t total_odd_count = 0;\n    uint64_t total_product = 1;\n\n    int i = 0;\n    while (i < len) {\n        int chunk_size = len - i;\n        if (chunk_size > 16) {\n            chunk_size = 16;\n        }\n\n        uint8_t temp_digits[16] = {0};\n        for (int j = 0; j < chunk_size; j++) {\n            temp_digits[j] = digits[i + j];\n        }\n\n        uint8x16_t v_digits = vld1q_u8(temp_digits);\n        uint8x16_t v_mask = vandq_u8(v_digits, vdupq_n_u8(1));\n        uint8x16_t v_ones = vdupq_n_u8(1);\n        uint8x16_t v_values = vbslq_u8(v_mask, v_digits, v_ones);\n\n        uint8_t mask_arr[16];\n        vst1q_u8(mask_arr, v_mask);\n        for (int j = 0; j < 16; j++) {\n            total_odd_count += mask_arr[j];\n        }\n\n        uint8_t values_arr[16];\n        vst1q_u8(values_arr, v_values);\n        uint64_t chunk_product = 1;\n        for (int j = 0; j < 16; j++) {\n            chunk_product *= values_arr[j];\n        }\n        total_product *= chunk_product;\n\n        i += chunk_size;\n    }\n\n    if (total_odd_count == 0) {\n        return 0;\n    }\n    return total_product;\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n){\n    uint8_t digits[20] = {0};\n    int count = 0;\n    uint64_t temp = n;\n    while (temp) {\n        digits[count++] = temp % 10;\n        temp /= 10;\n    }\n    \n    if (count == 0) {\n        return 0;\n    }\n    \n    uint64_t total_product = 1;\n    int any_odd_global = 0;\n    int i = 0;\n    \n    while (i < count) {\n        uint8_t chunk_arr[16] = {0};\n        int chunk_size = (count - i) < 16 ? (count - i) : 16;\n        for (int j = 0; j < chunk_size; j++) {\n            chunk_arr[j] = digits[i + j];\n        }\n        i += chunk_size;\n        \n        uint8x16_t v = vld1q_u8(chunk_arr);\n        uint8x16_t ones_vec = vdupq_n_u8(1);\n        uint8x16_t mask = vandq_u8(v, ones_vec);\n        uint8x16_t replaced = vbslq_u8(mask, v, ones_vec);\n        \n        uint8x8_t low_mask = vget_low_u8(mask);\n        uint8x8_t high_mask = vget_high_u8(mask);\n        uint8x8_t orred = vorr_u8(low_mask, high_mask);\n        orred = vorr_u8(orred, vext_u8(orred, orred, 4));\n        orred = vorr_u8(orred, vext_u8(orred, orred, 2));\n        orred = vorr_u8(orred, vext_u8(orred, orred, 1));\n        uint8_t any_odd_in_chunk = vget_lane_u8(orred, 0);\n        any_odd_global |= any_odd_in_chunk;\n        \n        uint8x8_t low8 = vget_low_u8(replaced);\n        uint8x8_t high8 = vget_high_u8(replaced);\n        uint16x8_t low16 = vmovl_u8(low8);\n        uint16x8_t high16 = vmovl_u8(high8);\n        \n        uint16_t low16_arr[8];\n        uint16_t high16_arr[8];\n        vst1q_u16(low16_arr, low16);\n        vst1q_u16(high16_arr, high16);\n        \n        uint64_t chunk_product = 1;\n        for (int j = 0; j < 8; j++) {\n            chunk_product *= low16_arr[j];\n            chunk_product *= high16_arr[j];\n        }\n        total_product *= chunk_product;\n    }\n    \n    if (any_odd_global) {\n        return total_product;\n    } else {\n        return 0;\n    }\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) {\n        return 0;\n    }\n\n    uint8_t digits[20] = {0};\n    int count = 0;\n    uint64_t num = n;\n    while (num) {\n        digits[count++] = num % 10;\n        num /= 10;\n    }\n\n    uint64_t total_prod = 1;\n    int any_odd_flag = 0;\n\n    for (int i = 0; i < count; i += 8) {\n        uint8_t chunk_digits[8] = {0};\n        int num_chunk = (count - i) < 8 ? (count - i) : 8;\n        for (int j = 0; j < num_chunk; j++) {\n            chunk_digits[j] = digits[i + j];\n        }\n\n        uint8x8_t v_digit = vld1_u8(chunk_digits);\n        uint8x8_t v_odd = vand_u8(v_digit, vdup_n_u8(1));\n        uint8x8_t v_mask = vceq_u8(v_odd, vdup_n_u8(1));\n        uint8x8_t v_trans = vbsl_u8(v_mask, v_digit, vdup_n_u8(1));\n\n        uint16x8_t v16 = vmovl_u8(v_trans);\n        uint16x4_t v_low = vget_low_u16(v16);\n        uint16x4_t v_high = vget_high_u16(v16);\n        uint16x4_t v_mul1 = vmul_u16(v_low, v_high);\n        uint16x4_t v_mul1_shift2 = vext_u16(v_mul1, v_mul1, 2);\n        uint16x4_t v_mul2 = vmul_u16(v_mul1, v_mul1_shift2);\n\n        uint32_t p0 = vget_lane_u16(v_mul2, 0);\n        uint32_t p1 = vget_lane_u16(v_mul2, 1);\n        uint32_t chunk_prod = p0 * p1;\n        total_prod *= chunk_prod;\n\n        uint8x8_t t1 = vorr_u8(v_odd, vext_u8(v_odd, v_odd, 4));\n        uint8x8_t t2 = vorr_u8(t1, vext_u8(t1, t1, 2));\n        uint8x8_t t3 = vorr_u8(t2, vext_u8(t2, t2, 1));\n        uint8_t any_odd_chunk = vget_lane_u8(t3, 0);\n        any_odd_flag |= (any_odd_chunk != 0);\n    }\n\n    if (any_odd_flag) {\n        return total_prod;\n    } else {\n        return 0;\n    }\n}\n```"}
{"task_id": "SimdBench_125_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) {\n        return 0;\n    }\n\n    uint8_t digits[20] = {0};\n    int idx = 0;\n    while (n) {\n        digits[idx++] = n % 10;\n        n /= 10;\n    }\n\n    uint8x16_t v1 = vld1q_u8(digits);\n    uint8_t last4[16] = {0};\n    if (idx > 16) {\n        for (int i = 16; i < idx; i++) {\n            last4[i - 16] = digits[i];\n        }\n    }\n    uint8x16_t v2 = vld1q_u8(last4);\n\n    uint8x16_t ones = vdupq_n_u8(1);\n    uint8x16_t v1_parity = vandq_u8(v1, ones);\n    uint8x16_t mask1 = vceqq_u8(v1_parity, vdupq_n_u8(0));\n    uint8x16_t adjusted1 = vbslq_u8(mask1, ones, v1);\n\n    uint8x16_t v2_parity = vandq_u8(v2, ones);\n    uint8x16_t mask2 = vceqq_u8(v2_parity, vdupq_n_u8(0));\n    uint8x16_t adjusted2 = vbslq_u8(mask2, ones, v2);\n\n    uint8_t any_odd1 = vmaxvq_u8(v1_parity);\n    uint8_t any_odd2 = vmaxvq_u8(v2_parity);\n    if (any_odd1 == 0 && any_odd2 == 0) {\n        return 0;\n    }\n\n    uint64_t prod = 1;\n    for (int i = 0; i < 16; i++) {\n        prod *= vgetq_lane_u8(adjusted1, i);\n    }\n    for (int i = 0; i < 4; i++) {\n        prod *= vgetq_lane_u8(adjusted2, i);\n    }\n\n    return prod;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    const size_t n = lst.size();\n    const float* data = lst.data();\n    uint64_t sum = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    int64x2_t acc = vdupq_n_s64(0);\n    size_t i = 0;\n    const size_t end4 = n - (n % 4);\n\n    for (; i < end4; i += 4) {\n        float32x4_t v = vld1q_f32(data + i);\n        float32x4_t rounded = vrndpq_f32(v);\n        int32x4_t ints = vcvtq_s32_f32(rounded);\n        int32x2_t low32 = vget_low_s32(ints);\n        int32x2_t high32 = vget_high_s32(ints);\n        int64x2_t low_sq = vmull_s32(low32, low32);\n        int64x2_t high_sq = vmull_s32(high32, high32);\n        acc = vaddq_s64(acc, low_sq);\n        acc = vaddq_s64(acc, high_sq);\n    }\n\n    int64_t temp[2];\n    vst1q_s64(temp, acc);\n    sum = temp[0] + temp[1];\n\n    const float float_int32_max_plus_1 = 2147483648.0f;\n    const float float_int32_min = -2147483648.0f;\n    for (; i < n; i++) {\n        float x = data[i];\n        int32_t int_val;\n        if (x >= 0) {\n            if (x >= float_int32_max_plus_1) {\n                int_val = 2147483647;\n            } else {\n                int32_t truncated = (int32_t)x;\n                if (x == (float)truncated) {\n                    int_val = truncated;\n                } else {\n                    if (truncated == 2147483647) {\n                        int_val = 2147483647;\n                    } else {\n                        int_val = truncated + 1;\n                    }\n                }\n            }\n        } else {\n            if (x < float_int32_min) {\n                int_val = -2147483648;\n            } else {\n                int_val = (int32_t)x;\n            }\n        }\n        int64_t sq = (int64_t)int_val * (int64_t)int_val;\n        sum += sq;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    size_t i = 0;\n    uint64_t result = 0;\n\n    if (n >= 4) {\n        uint64x2_t acc = vdupq_n_u64(0);\n\n        for (; i <= n - 4; i += 4) {\n            float32x4_t vec = vld1q_f32(&lst[i]);\n            float32x4_t ceil_vec = vceilq_f32(vec);\n            int32x4_t int_vec = vcvtq_s32_f32(ceil_vec);\n\n            int32x2_t low_int = vget_low_s32(int_vec);\n            int32x2_t high_int = vget_high_s32(int_vec);\n            int64x2_t low_long = vmovl_s32(low_int);\n            int64x2_t high_long = vmovl_s32(high_int);\n\n            int64x2_t low_sq = vmulq_s64(low_long, low_long);\n            int64x2_t high_sq = vmulq_s64(high_long, high_long);\n\n            acc = vaddq_u64(acc, vreinterpretq_u64_s64(low_sq));\n            acc = vaddq_u64(acc, vreinterpretq_u64_s64(high_sq));\n        }\n\n        uint64_t sum_lanes = vgetq_lane_u64(acc, 0) + vgetq_lane_u64(acc, 1);\n        result = sum_lanes;\n    }\n\n    for (; i < n; i++) {\n        float ceil_val = ceilf(lst[i]);\n        int64_t n_val = (int64_t)ceil_val;\n        result += (uint64_t)(n_val * n_val);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    \n    uint64_t total = 0;\n    size_t i = 0;\n    int64x2_t acc = vdupq_n_s64(0);\n\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t rounded = vrndpq_f32(vec);\n        int32x4_t int_vec = vcvtq_s32_f32(rounded);\n        \n        int32x2_t low = vget_low_s32(int_vec);\n        int32x2_t high = vget_high_s32(int_vec);\n        \n        int64x2_t sq_low = vmull_s32(low, low);\n        int64x2_t sq_high = vmull_s32(high, high);\n        \n        acc = vaddq_s64(acc, sq_low);\n        acc = vaddq_s64(acc, sq_high);\n    }\n    \n    total = (uint64_t)vgetq_lane_s64(acc, 0) + (uint64_t)vgetq_lane_s64(acc, 1);\n    \n    for (; i < n; i++) {\n        float val = lst[i];\n        int32_t int_val;\n        if (val >= 0) {\n            int_val = (int32_t)val;\n            if ((float)int_val < val) {\n                int_val++;\n            }\n        } else {\n            int_val = (int32_t)val;\n        }\n        total += (uint64_t)int_val * (uint64_t)int_val;\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t sum = 0;\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    int i = 0;\n    uint64x2_t acc0 = vdupq_n_u64(0);\n    uint64x2_t acc1 = vdupq_n_u64(0);\n\n    for (; i <= n - 4; i += 4) {\n        float32x4_t vec = vld1q_f32(&lst[i]);\n        float32x4_t ceil_vec = vceilq_f32(vec);\n        int32x4_t ivec = vcvtq_s32_f32(ceil_vec);\n        int64x2_t low_sq = vmull_s32(vget_low_s32(ivec), vget_low_s32(ivec));\n        int64x2_t high_sq = vmull_s32(vget_high_s32(ivec), vget_high_s32(ivec));\n        acc0 = vaddq_u64(acc0, vreinterpretq_u64_s64(low_sq));\n        acc1 = vaddq_u64(acc1, vreinterpretq_u64_s64(high_sq));\n    }\n\n    uint64x2_t acc_total = vaddq_u64(acc0, acc1);\n    sum = vgetq_lane_u64(acc_total, 0) + vgetq_lane_u64(acc_total, 1);\n\n    for (; i < n; i++) {\n        float f = lst[i];\n        int32_t x;\n        if (f >= 0.0f) {\n            int32_t trunc = (int32_t)f;\n            if (f > (float)trunc) {\n                x = trunc + 1;\n            } else {\n                x = trunc;\n            }\n        } else {\n            x = (int32_t)f;\n        }\n        int64_t sq = (int64_t)x * (int64_t)x;\n        sum += (uint64_t)sq;\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    uint64x2_t acc = vdupq_n_u64(0);\n    size_t i = 0;\n\n    for (; i + 3 < n; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        float32x4_t rounded = vrndpq_f32(v);\n        int32x4_t ivals = vcvtq_s32_f32(rounded);\n\n        int32x2_t low = vget_low_s32(ivals);\n        int32x2_t high = vget_high_s32(ivals);\n\n        int64x2_t sq_low = vmull_s32(low, low);\n        int64x2_t sq_high = vmull_s32(high, high);\n\n        uint64x2_t sq_vec = vaddq_u64(vreinterpretq_u64_s64(sq_low), vreinterpretq_u64_s64(sq_high));\n        acc = vaddq_u64(acc, sq_vec);\n    }\n\n    uint64_t result = vgetq_lane_u64(acc, 0) + vgetq_lane_u64(acc, 1);\n\n    for (; i < n; ++i) {\n        float x = lst[i];\n        float rounded = std::ceil(x);\n        int64_t ival = static_cast<int64_t>(rounded);\n        uint64_t square = static_cast<uint64_t>(ival) * static_cast<uint64_t>(ival);\n        result += square;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int last_index = -1;\n    int i = 1;\n    const int vl = 4;\n\n    for (; i <= n - vl; i += vl) {\n        int32x4_t prev = vld1q_s32(&arr[i-1]);\n        int32x4_t curr = vld1q_s32(&arr[i]);\n        uint32x4_t mask_vec = vcltq_s32(curr, prev);\n\n        uint32_t mask0 = vgetq_lane_u32(mask_vec, 0);\n        uint32_t mask1 = vgetq_lane_u32(mask_vec, 1);\n        uint32_t mask2 = vgetq_lane_u32(mask_vec, 2);\n        uint32_t mask3 = vgetq_lane_u32(mask_vec, 3);\n\n        int bitmask = (mask0 ? 1 : 0) | (mask1 ? 2 : 0) | (mask2 ? 4 : 0) | (mask3 ? 8 : 0);\n\n        if (bitmask) {\n            int lane_index;\n            if (bitmask & 8) {\n                lane_index = 3;\n            } else if (bitmask & 4) {\n                lane_index = 2;\n            } else if (bitmask & 2) {\n                lane_index = 1;\n            } else {\n                lane_index = 0;\n            }\n            last_index = i + lane_index;\n        }\n    }\n\n    for (int j = i; j < n; j++) {\n        if (arr[j] < arr[j-1]) {\n            last_index = j;\n        }\n    }\n\n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) {\n        return -1;\n    }\n    int num_pairs = n - 1;\n    int num_chunks = num_pairs / 4;\n    int tail = num_pairs % 4;\n    int last_index = -1;\n\n    for (int j = 0; j < num_chunks; j++) {\n        int offset = j * 4;\n        int32x4_t left_vec = vld1q_s32(arr.data() + offset);\n        int32x4_t right_vec = vld1q_s32(arr.data() + offset + 1);\n        \n        uint32x4_t mask = vcltq_s32(right_vec, left_vec);\n        \n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, mask);\n        \n        for (int k = 3; k >= 0; k--) {\n            if (mask_arr[k]) {\n                last_index = offset + k + 1;\n                break;\n            }\n        }\n    }\n\n    int tail_start = num_chunks * 4;\n    for (int i = tail_start; i < tail_start + tail; i++) {\n        if (arr[i+1] < arr[i]) {\n            last_index = i + 1;\n        }\n    }\n    \n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n    int last_index = -1;\n    int i = 1;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t prev = vld1q_s32(&arr[i-1]);\n        int32x4_t curr = vld1q_s32(&arr[i]);\n\n        uint32x4_t mask = vcleq_s32(curr, prev);\n\n        for (int j = 3; j >= 0; j--) {\n            if (vgetq_lane_u32(mask, j)) {\n                if (i + j > last_index) {\n                    last_index = i + j;\n                }\n                break;\n            }\n        }\n    }\n\n    for (int j = i; j < n; j++) {\n        if (arr[j] <= arr[j-1]) {\n            last_index = j;\n        }\n    }\n\n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int last_index = -1;\n    int i = 1;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v_prev = vld1q_s32(&arr[i - 1]);\n        int32x4_t v_curr = vld1q_s32(&arr[i]);\n\n        uint32x4_t mask = vcleq_s32(v_curr, v_prev);\n\n        uint32x4_t idx_vec = vmovq_n_u32(0);\n        idx_vec = vsetq_lane_u32(i, idx_vec, 0);\n        idx_vec = vsetq_lane_u32(i + 1, idx_vec, 1);\n        idx_vec = vsetq_lane_u32(i + 2, idx_vec, 2);\n        idx_vec = vsetq_lane_u32(i + 3, idx_vec, 3);\n\n        uint32x4_t candidate = vandq_u32(mask, idx_vec);\n        uint32_t max_index_in_chunk = vmaxvq_u32(candidate);\n\n        if (max_index_in_chunk) {\n            if ((int)max_index_in_chunk > last_index) {\n                last_index = (int)max_index_in_chunk;\n            }\n        }\n    }\n\n    for (; i < n; ++i) {\n        if (arr[i] <= arr[i - 1]) {\n            last_index = i;\n        }\n    }\n\n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n    const int* data = arr.data();\n    int max_index = -1;\n\n    int i = 0;\n    for (; i <= n - 5; i += 4) {\n        int32x4_t current = vld1q_s32(data + i);\n        int32x4_t next = vld1q_s32(data + i + 1);\n        uint32x4_t mask = vcleq_s32(next, current);\n        \n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, mask);\n        \n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                int candidate = i + j + 1;\n                if (candidate > max_index) {\n                    max_index = candidate;\n                }\n            }\n        }\n    }\n\n    for (int j = i; j < n - 1; j++) {\n        if (data[j+1] <= data[j]) {\n            if (j+1 > max_index) {\n                max_index = j+1;\n            }\n        }\n    }\n\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    size_t n = lst.size();\n    const int* data_ptr = lst.data();\n    int32x4_t simd_neg_max = vdupq_n_s32(INT_MIN);\n    int32x4_t simd_pos_min = vdupq_n_s32(INT_MAX);\n    uint32x4_t simd_neg_exists = vdupq_n_u32(0);\n    uint32x4_t simd_pos_exists = vdupq_n_u32(0);\n\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t chunk = vld1q_s32(data_ptr + i);\n        uint32x4_t neg_mask = vcltq_s32(chunk, vdupq_n_s32(0));\n        int32x4_t chunk_neg = vbslq_s32(neg_mask, chunk, vdupq_n_s32(INT_MIN));\n        simd_neg_max = vmaxq_s32(simd_neg_max, chunk_neg);\n        simd_neg_exists = vorrq_u32(simd_neg_exists, neg_mask);\n\n        uint32x4_t pos_mask = vcgtq_s32(chunk, vdupq_n_s32(0));\n        int32x4_t chunk_pos = vbslq_s32(pos_mask, chunk, vdupq_n_s32(INT_MAX));\n        simd_pos_min = vminq_s32(simd_pos_min, chunk_pos);\n        simd_pos_exists = vorrq_u32(simd_pos_exists, pos_mask);\n    }\n\n    int32x2_t low_neg = vget_low_s32(simd_neg_max);\n    int32x2_t high_neg = vget_high_s32(simd_neg_max);\n    int32x2_t max2 = vpmax_s32(low_neg, high_neg);\n    max2 = vpmax_s32(max2, max2);\n    int simd_neg_max_val = vget_lane_s32(max2, 0);\n\n    int32x2_t low_pos = vget_low_s32(simd_pos_min);\n    int32x2_t high_pos = vget_high_s32(simd_pos_min);\n    int32x2_t min2 = vpmin_s32(low_pos, high_pos);\n    min2 = vpmin_s32(min2, min2);\n    int simd_pos_min_val = vget_lane_s32(min2, 0);\n\n    uint32x2_t low_neg_ex = vget_low_u32(simd_neg_exists);\n    uint32x2_t high_neg_ex = vget_high_u32(simd_neg_exists);\n    uint32x2_t or_neg_ex = vorr_u32(low_neg_ex, high_neg_ex);\n    uint32_t or_neg = vget_lane_u32(or_neg_ex, 0) | vget_lane_u32(or_neg_ex, 1);\n    bool simd_neg_exists_bool = (or_neg != 0);\n\n    uint32x2_t low_pos_ex = vget_low_u32(simd_pos_exists);\n    uint32x2_t high_pos_ex = vget_high_u32(simd_pos_exists);\n    uint32x2_t or_pos_ex = vorr_u32(low_pos_ex, high_pos_ex);\n    uint32_t or_pos = vget_lane_u32(or_pos_ex, 0) | vget_lane_u32(or_pos_ex, 1);\n    bool simd_pos_exists_bool = (or_pos != 0);\n\n    int neg_max_candidate = INT_MIN;\n    int pos_min_candidate = INT_MAX;\n    bool any_negative = false;\n    bool any_positive = false;\n\n    if (simd_neg_exists_bool) {\n        any_negative = true;\n        neg_max_candidate = simd_neg_max_val;\n    }\n    if (simd_pos_exists_bool) {\n        any_positive = true;\n        pos_min_candidate = simd_pos_min_val;\n    }\n\n    for (; i < n; ++i) {\n        int x = lst[i];\n        if (x < 0) {\n            any_negative = true;\n            if (x > neg_max_candidate) {\n                neg_max_candidate = x;\n            }\n        } else if (x > 0) {\n            any_positive = true;\n            if (x < pos_min_candidate) {\n                pos_min_candidate = x;\n            }\n        }\n    }\n\n    int a = any_negative ? neg_max_candidate : 0;\n    int b = any_positive ? pos_min_candidate : 0;\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <climits>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return {0, 0};\n    }\n\n    int32x4_t neg_max_vec = vdupq_n_s32(INT_MIN);\n    int32x4_t pos_min_vec = vdupq_n_s32(INT_MAX);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        uint32x4_t neg_mask = vcltq_s32(data, zero_vec);\n        int32x4_t neg_candidate = vbslq_s32(neg_mask, data, vdupq_n_s32(INT_MIN));\n        neg_max_vec = vmaxq_s32(neg_max_vec, neg_candidate);\n\n        uint32x4_t pos_mask = vcgtq_s32(data, zero_vec);\n        int32x4_t pos_candidate = vbslq_s32(pos_mask, data, vdupq_n_s32(INT_MAX));\n        pos_min_vec = vminq_s32(pos_min_vec, pos_candidate);\n    }\n\n    int32x2_t low_neg = vget_low_s32(neg_max_vec);\n    int32x2_t high_neg = vget_high_s32(neg_max_vec);\n    int32x2_t max_neg_reduced = vpmax_s32(low_neg, high_neg);\n    max_neg_reduced = vpmax_s32(max_neg_reduced, max_neg_reduced);\n    int max_neg = vget_lane_s32(max_neg_reduced, 0);\n\n    int32x2_t low_pos = vget_low_s32(pos_min_vec);\n    int32x2_t high_pos = vget_high_s32(pos_min_vec);\n    int32x2_t min_pos_reduced = vpmin_s32(low_pos, high_pos);\n    min_pos_reduced = vpmin_s32(min_pos_reduced, min_pos_reduced);\n    int min_pos = vget_lane_s32(min_pos_reduced, 0);\n\n    for (; i < n; i++) {\n        int x = lst[i];\n        if (x < 0) {\n            if (x > max_neg) max_neg = x;\n        } else if (x > 0) {\n            if (x < min_pos) min_pos = x;\n        }\n    }\n\n    if (max_neg == INT_MIN) max_neg = 0;\n    if (min_pos == INT_MAX) min_pos = 0;\n\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <vector>\n#include <climits>\n#include <algorithm>\n#include <arm_neon.h>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return {0, 0};\n    }\n\n    int32x4_t neg_max_vec = vdupq_n_s32(INT_MIN);\n    int32x4_t pos_min_vec = vdupq_n_s32(INT_MAX);\n\n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n\n        uint32x4_t mask_neg = vcltq_s32(data, vdupq_n_s32(0));\n        int32x4_t neg_data = vbslq_s32(mask_neg, data, vdupq_n_s32(INT_MIN));\n        neg_max_vec = vmaxq_s32(neg_max_vec, neg_data);\n\n        uint32x4_t mask_pos = vcgtq_s32(data, vdupq_n_s32(0));\n        int32x4_t pos_data = vbslq_s32(mask_pos, data, vdupq_n_s32(INT_MAX));\n        pos_min_vec = vminq_s32(pos_min_vec, pos_data);\n    }\n\n    int32_t neg_max_scalar = INT_MIN;\n    int32_t pos_min_scalar = INT_MAX;\n    for (; i < n; i++) {\n        int32_t x = lst[i];\n        if (x < 0) {\n            if (x > neg_max_scalar) {\n                neg_max_scalar = x;\n            }\n        } else if (x > 0) {\n            if (x < pos_min_scalar) {\n                pos_min_scalar = x;\n            }\n        }\n    }\n\n    int32x2_t low_neg = vget_low_s32(neg_max_vec);\n    int32x2_t high_neg = vget_high_s32(neg_max_vec);\n    int32x2_t max_neg_tmp = vmax_s32(low_neg, high_neg);\n    max_neg_tmp = vpmax_s32(max_neg_tmp, max_neg_tmp);\n    int32_t neg_max_vec_val = vget_lane_s32(max_neg_tmp, 0);\n\n    int32x2_t low_pos = vget_low_s32(pos_min_vec);\n    int32x2_t high_pos = vget_high_s32(pos_min_vec);\n    int32x2_t min_pos_tmp = vmin_s32(low_pos, high_pos);\n    min_pos_tmp = vpmin_s32(min_pos_tmp, min_pos_tmp);\n    int32_t pos_min_vec_val = vget_lane_s32(min_pos_tmp, 0);\n\n    int32_t neg_max = std::max(neg_max_vec_val, neg_max_scalar);\n    int32_t pos_min = std::min(pos_min_vec_val, pos_min_scalar);\n\n    if (neg_max == INT_MIN) {\n        neg_max = 0;\n    }\n    if (pos_min == INT_MAX) {\n        pos_min = 0;\n    }\n\n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <climits>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32x4_t neg_max_vec = vdupq_n_s32(INT_MIN);\n    int32x4_t pos_min_vec = vdupq_n_s32(INT_MAX);\n    uint32x4_t neg_exist_vec = vdupq_n_u32(0);\n    uint32x4_t pos_exist_vec = vdupq_n_u32(0);\n    int32x4_t zero_vec = vdupq_n_s32(0);\n\n    size_t i = 0;\n    const size_t simd_size = 4;\n    size_t n = lst.size();\n\n    for (; i + simd_size <= n; i += simd_size) {\n        int32x4_t chunk = vld1q_s32(&lst[i]);\n        uint32x4_t mask_neg = vcltq_s32(chunk, zero_vec);\n        uint32x4_t mask_pos = vcgtq_s32(chunk, zero_vec);\n\n        neg_exist_vec = vorrq_u32(neg_exist_vec, mask_neg);\n        pos_exist_vec = vorrq_u32(pos_exist_vec, mask_pos);\n\n        int32x4_t candidate_neg = vbslq_s32(mask_neg, chunk, vdupq_n_s32(INT_MIN));\n        neg_max_vec = vmaxq_s32(neg_max_vec, candidate_neg);\n\n        int32x4_t candidate_pos = vbslq_s32(mask_pos, chunk, vdupq_n_s32(INT_MAX));\n        pos_min_vec = vminq_s32(pos_min_vec, candidate_pos);\n    }\n\n    int32_t neg_max_arr[4];\n    vst1q_s32(neg_max_arr, neg_max_vec);\n    int max_neg_simd = neg_max_arr[0];\n    for (int j = 1; j < 4; j++) {\n        if (neg_max_arr[j] > max_neg_simd) {\n            max_neg_simd = neg_max_arr[j];\n        }\n    }\n\n    int32_t pos_min_arr[4];\n    vst1q_s32(pos_min_arr, pos_min_vec);\n    int min_pos_simd = pos_min_arr[0];\n    for (int j = 1; j < 4; j++) {\n        if (pos_min_arr[j] < min_pos_simd) {\n            min_pos_simd = pos_min_arr[j];\n        }\n    }\n\n    uint32_t neg_exist_arr[4];\n    vst1q_u32(neg_exist_arr, neg_exist_vec);\n    bool has_neg_simd = false;\n    for (int j = 0; j < 4; j++) {\n        if (neg_exist_arr[j]) {\n            has_neg_simd = true;\n            break;\n        }\n    }\n\n    uint32_t pos_exist_arr[4];\n    vst1q_u32(pos_exist_arr, pos_exist_vec);\n    bool has_pos_simd = false;\n    for (int j = 0; j < 4; j++) {\n        if (pos_exist_arr[j]) {\n            has_pos_simd = true;\n            break;\n        }\n    }\n\n    int max_neg_tail = INT_MIN;\n    int min_pos_tail = INT_MAX;\n    bool has_neg_tail = false;\n    bool has_pos_tail = false;\n\n    for (; i < n; i++) {\n        int x = lst[i];\n        if (x < 0) {\n            has_neg_tail = true;\n            if (x > max_neg_tail) {\n                max_neg_tail = x;\n            }\n        } else if (x > 0) {\n            has_pos_tail = true;\n            if (x < min_pos_tail) {\n                min_pos_tail = x;\n            }\n        }\n    }\n\n    int max_neg_final = INT_MIN;\n    if (has_neg_simd && has_neg_tail) {\n        max_neg_final = (max_neg_simd > max_neg_tail) ? max_neg_simd : max_neg_tail;\n    } else if (has_neg_simd) {\n        max_neg_final = max_neg_simd;\n    } else if (has_neg_tail) {\n        max_neg_final = max_neg_tail;\n    }\n\n    int min_pos_final = INT_MAX;\n    if (has_pos_simd && has_pos_tail) {\n        min_pos_final = (min_pos_simd < min_pos_tail) ? min_pos_simd : min_pos_tail;\n    } else if (has_pos_simd) {\n        min_pos_final = min_pos_simd;\n    } else if (has_pos_tail) {\n        min_pos_final = min_pos_tail;\n    }\n\n    bool has_neg_any = has_neg_simd || has_neg_tail;\n    bool has_pos_any = has_pos_simd || has_pos_tail;\n\n    int a = has_neg_any ? max_neg_final : 0;\n    int b = has_pos_any ? min_pos_final : 0;\n\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int n = lst.size();\n    int32x4_t neg_acc = vdupq_n_s32(INT_MIN);\n    int32x4_t pos_acc = vdupq_n_s32(INT_MAX);\n    uint32x4_t global_neg_mask = vdupq_n_u32(0);\n    uint32x4_t global_pos_mask = vdupq_n_u32(0);\n    \n    int i = 0;\n    for (; i <= n - 4; i += 4) {\n        int32x4_t chunk = vld1q_s32(&lst[i]);\n        \n        uint32x4_t neg_mask = vcltq_s32(chunk, vdupq_n_s32(0));\n        global_neg_mask = vorrq_u32(global_neg_mask, neg_mask);\n        int32x4_t neg_chunk = vbslq_s32(neg_mask, chunk, vdupq_n_s32(INT_MIN));\n        neg_acc = vmaxq_s32(neg_acc, neg_chunk);\n        \n        uint32x4_t pos_mask = vcgtq_s32(chunk, vdupq_n_s32(0));\n        global_pos_mask = vorrq_u32(global_pos_mask, pos_mask);\n        int32x4_t pos_chunk = vbslq_s32(pos_mask, chunk, vdupq_n_s32(INT_MAX));\n        pos_acc = vminq_s32(pos_acc, pos_chunk);\n    }\n    \n    int max_neg = vmaxvq_s32(neg_acc);\n    int min_pos = vminvq_s32(pos_acc);\n    bool any_neg = (vmaxvq_u32(global_neg_mask) != 0;\n    bool any_pos = (vmaxvq_u32(global_pos_mask) != 0;\n    \n    for (; i < n; i++) {\n        int val = lst[i];\n        if (val < 0) {\n            if (!any_neg || val > max_neg) {\n                max_neg = val;\n            }\n            any_neg = true;\n        } else if (val > 0) {\n            if (!any_pos || val < min_pos) {\n                min_pos = val;\n            }\n            any_pos = true;\n        }\n    }\n    \n    if (!any_neg) max_neg = 0;\n    if (!any_pos) min_pos = 0;\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t T = n * (n + 1) / 2;\n    uint64_t arr[36];\n    int index = 0;\n    for (uint64_t i = 1; i <= n; i++) {\n        uint64_t count = n - i + 1;\n        for (uint64_t j = 0; j < count; j++) {\n            arr[index++] = i;\n        }\n    }\n\n    uint64x2_t acc = vdupq_n_u64(1);\n    uint64_t carry = 1;\n    int i;\n    for (i = 0; i + 1 < T; i += 2) {\n        uint64x2_t vec = vld1q_u64(arr + i);\n        uint64_t a0 = vgetq_lane_u64(acc, 0) * vgetq_lane_u64(vec, 0);\n        uint64_t a1 = vgetq_lane_u64(acc, 1) * vgetq_lane_u64(vec, 1);\n        acc = vsetq_lane_u64(a0, acc, 0);\n        acc = vsetq_lane_u64(a1, acc, 1);\n    }\n    if (i < T) {\n        carry = arr[i];\n    }\n    uint64_t lane0 = vgetq_lane_u64(acc, 0);\n    uint64_t lane1 = vgetq_lane_u64(acc, 1);\n    return lane0 * lane1 * carry;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint32_t un = (uint32_t) n;\n    uint64_t result = 1;\n    uint32_t j = 1;\n\n    for (; j <= un - 1; j += 2) {\n        uint32_t exp1 = un - j + 1;\n        uint32_t exp2 = un - j;\n\n        uint32x2_t base = vdup_n_u32(0);\n        base = vset_lane_u32(j, base, 0);\n        base = vset_lane_u32(j + 1, base, 1);\n\n        uint32x2_t exp_vec = vdup_n_u32(0);\n        exp_vec = vset_lane_u32(exp1, exp_vec, 0);\n        exp_vec = vset_lane_u32(exp2, exp_vec, 1);\n\n        uint32_t max_exp = (exp1 > exp2) ? exp1 : exp2;\n        uint32x2_t acc = vdup_n_u32(1);\n\n        for (uint32_t k = 0; k < max_exp; k++) {\n            uint32x2_t k_vec = vdup_n_u32(k);\n            uint32x2_t mask = vclt_u32(k_vec, exp_vec);\n            uint32x2_t multiplier = vbsl_u32(mask, base, vdup_n_u32(1));\n            acc = vmul_u32(acc, multiplier);\n        }\n\n        result *= vget_lane_u32(acc, 0);\n        result *= vget_lane_u32(acc, 1);\n    }\n\n    if (j == un) {\n        result *= j;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t term_arr[64];\n    for (uint64_t j = 1; j <= n; j++) {\n        uint64_t exp = n - j + 1;\n        uint64_t base = j;\n        uint64_t t = 1;\n        while (exp) {\n            if (exp & 1) {\n                t *= base;\n            }\n            base *= base;\n            exp >>= 1;\n        }\n        term_arr[j-1] = t;\n    }\n\n    uint64x2_t acc = vdupq_n_u64(1);\n    uint64_t i;\n    for (i = 0; i + 1 < n; i += 2) {\n        uint64x2_t vec = vld1q_u64(term_arr + i);\n        acc = vmulq_u64(acc, vec);\n    }\n\n    uint64_t lane[2];\n    vst1q_u64(lane, acc);\n    uint64_t total = lane[0] * lane[1];\n\n    if (n & 1) {\n        total *= term_arr[n-1];\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n > 8) {\n        return 0;\n    }\n    uint32_t facts[8] = {1, 1, 1, 1, 1, 1, 1, 1};\n    uint32_t current = 1;\n    for (uint32_t i = 1, idx = 0; i <= (uint32_t)n; i++, idx++) {\n        current *= i;\n        facts[idx] = current;\n    }\n    uint32x4_t v0 = vld1q_u32(facts);\n    uint32x4_t v1 = vld1q_u32(facts + 4);\n    uint32x4_t prod_vec = vmulq_u32(v0, v1);\n    uint32x2_t low = vget_low_u32(prod_vec);\n    uint32x2_t high = vget_high_u32(prod_vec);\n    uint32x2_t rev_low = vrev64_u32(low);\n    uint32x2_t rev_high = vrev64_u32(high);\n    uint32x2_t prod_low = vmul_u32(low, rev_low);\n    uint32x2_t prod_high = vmul_u32(high, rev_high);\n    uint32_t t = vget_lane_u32(prod_low, 0);\n    uint32_t u = vget_lane_u32(prod_high, 0);\n    uint32_t result = t * u;\n    return (uint64_t)result;\n}\n```"}
{"task_id": "SimdBench_129_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t special_factorial_simd(uint64_t n){\n    uint64_t arr[8] = {1,1,1,1,1,1,1,1};\n    \n    for (uint64_t m = 1; m <= n; m++) {\n        uint64_t exponent = n - m + 1;\n        arr[m-1] = 1;\n        for (uint64_t i = 0; i < exponent; i++) {\n            arr[m-1] *= m;\n        }\n    }\n    \n    int size = 8;\n    uint64_t *ptr = arr;\n    while (size > 1) {\n        int new_size = size / 2;\n        for (int i = 0; i < new_size; i++) {\n            uint64x2_t v = vld1q_u64(ptr + 2*i);\n            uint64_t a = vgetq_lane_u64(v, 0);\n            uint64_t b = vgetq_lane_u64(v, 1);\n            ptr[i] = a * b;\n        }\n        size = new_size;\n    }\n    return ptr[0];\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int total = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    static const uint32x4_t mask_square0 = { 0xFFFFFFFF, 0, 0, 0xFFFFFFFF };\n    static const uint32x4_t mask_cube0   = { 0, 0, 0, 0 };\n    static const uint32x4_t mask_square1 = { 0, 0, 0xFFFFFFFF, 0 };\n    static const uint32x4_t mask_cube1   = { 0xFFFFFFFF, 0, 0, 0 };\n    static const uint32x4_t mask_square2 = { 0, 0xFFFFFFFF, 0, 0 };\n    static const uint32x4_t mask_cube2   = { 0xFFFFFFFF, 0, 0, 0 };\n\n    for (; i + 12 <= n; i += 12) {\n        int32x4_t v0 = vld1q_s32(&lst[i]);\n        int32x4_t v1 = vld1q_s32(&lst[i+4]);\n        int32x4_t v2 = vld1q_s32(&lst[i+8]);\n\n        int32x4_t sq0 = vmulq_s32(v0, v0);\n        int32x4_t cb0 = vmulq_s32(sq0, v0);\n        int32x4_t temp0 = vbslq_s32(mask_square0, sq0, v0);\n        int32x4_t res0 = vbslq_s32(mask_cube0, cb0, temp0);\n\n        int32x4_t sq1 = vmulq_s32(v1, v1);\n        int32x4_t cb1 = vmulq_s32(sq1, v1);\n        int32x4_t temp1 = vbslq_s32(mask_square1, sq1, v1);\n        int32x4_t res1 = vbslq_s32(mask_cube1, cb1, temp1);\n\n        int32x4_t sq2 = vmulq_s32(v2, v2);\n        int32x4_t cb2 = vmulq_s32(sq2, v2);\n        int32x4_t temp2 = vbslq_s32(mask_square2, sq2, v2);\n        int32x4_t res2 = vbslq_s32(mask_cube2, cb2, temp2);\n\n        int32x4_t sum4 = vaddq_s32(res0, res1);\n        sum4 = vaddq_s32(sum4, res2);\n\n        int32x2_t low = vget_low_s32(sum4);\n        int32x2_t high = vget_high_s32(sum4);\n        int32x2_t sum2 = vadd_s32(low, high);\n        total += vget_lane_s32(sum2, 0) + vget_lane_s32(sum2, 1);\n    }\n\n    for (; i < n; i++) {\n        if (i % 3 == 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int total = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n\n    static const int cond3_table[12] = {-1,0,0,-1,0,0,-1,0,0,-1,0,0};\n    static const int cond4_table[12] = {0,0,0,0,-1,0,0,0,-1,0,0,0};\n\n    for (; i + 3 < n; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        size_t base_mod12 = i % 12;\n        int r0 = base_mod12;\n        int r1 = (base_mod12 + 1) % 12;\n        int r2 = (base_mod12 + 2) % 12;\n        int r3 = (base_mod12 + 3) % 12;\n\n        int32x4_t cond3_vec = {cond3_table[r0], cond3_table[r1], cond3_table[r2], cond3_table[r3]};\n        int32x4_t cond4_vec = {cond4_table[r0], cond4_table[r1], cond4_table[r2], cond4_table[r3]};\n        uint32x4_t cond3_mask = vreinterpretq_u32_s32(cond3_vec);\n        uint32x4_t cond4_mask = vreinterpretq_u32_s32(cond4_vec);\n\n        int32x4_t square = vmulq_s32(data, data);\n        int32x4_t cube = vmulq_s32(square, data);\n\n        int32x4_t part = vbslq_s32(cond4_mask, cube, data);\n        int32x4_t result = vbslq_s32(cond3_mask, square, part);\n\n        int32x2_t low = vget_low_s32(result);\n        int32x2_t high = vget_high_s32(result);\n        int32x2_t sum_low_high = vadd_s32(low, high);\n        int32x2_t sum_pair = vpadd_s32(sum_low_high, sum_low_high);\n        total += vget_lane_s32(sum_pair, 0);\n    }\n\n    for (; i < n; ++i) {\n        int x = lst[i];\n        if (i % 3 == 0) {\n            x = x * x;\n        } else if (i % 4 == 0) {\n            x = x * x * x;\n        }\n        total += x;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    static const uint32_t mask3_array[12][4] = {\n        { 0xFFFFFFFF, 0, 0, 0xFFFFFFFF },\n        { 0, 0, 0xFFFFFFFF, 0 },\n        { 0, 0xFFFFFFFF, 0, 0 },\n        { 0xFFFFFFFF, 0, 0, 0xFFFFFFFF },\n        { 0, 0, 0xFFFFFFFF, 0 },\n        { 0, 0xFFFFFFFF, 0, 0 },\n        { 0xFFFFFFFF, 0, 0, 0xFFFFFFFF },\n        { 0, 0, 0xFFFFFFFF, 0 },\n        { 0, 0xFFFFFFFF, 0, 0 },\n        { 0xFFFFFFFF, 0, 0, 0xFFFFFFFF },\n        { 0, 0, 0xFFFFFFFF, 0 },\n        { 0, 0xFFFFFFFF, 0, 0 }\n    };\n\n    static const uint32_t mask4_array[12][4] = {\n        { 0, 0, 0, 0 },\n        { 0, 0, 0, 0xFFFFFFFF },\n        { 0, 0, 0xFFFFFFFF, 0 },\n        { 0, 0xFFFFFFFF, 0, 0 },\n        { 0xFFFFFFFF, 0, 0, 0 },\n        { 0, 0, 0, 0xFFFFFFFF },\n        { 0, 0, 0xFFFFFFFF, 0 },\n        { 0, 0xFFFFFFFF, 0, 0 },\n        { 0xFFFFFFFF, 0, 0, 0 },\n        { 0, 0, 0, 0 },\n        { 0, 0, 0, 0 },\n        { 0, 0, 0, 0 }\n    };\n\n    int32x4_t vsum = vdupq_n_s32(0);\n    int offset = 0;\n    int i = 0;\n\n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&lst[i]);\n        uint32x4_t mask3 = vld1q_u32(mask3_array[offset]);\n        uint32x4_t mask4 = vld1q_u32(mask4_array[offset]);\n        offset = (offset + 4) % 12;\n\n        int32x4_t squared = vmulq_s32(v, v);\n        int32x4_t cubed = vmulq_s32(squared, v);\n        int32x4_t res = vbslq_s32(mask3, squared, v);\n        res = vbslq_s32(mask4, cubed, res);\n        vsum = vaddq_s32(vsum, res);\n    }\n\n    int32_t tmp[4];\n    vst1q_s32(tmp, vsum);\n    int sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n\n    for (; i < n; i++) {\n        int x = lst[i];\n        if (i % 3 == 0) {\n            sum += x * x;\n        } else if (i % 4 == 0) {\n            sum += x * x * x;\n        } else {\n            sum += x;\n        }\n    }\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) \n        return 0;\n    \n    int base_mod = 0;\n    int32x4_t vsum = vmovq_n_s32(0);\n    int i = 0;\n    \n    for (; i <= n - 4; i += 4) {\n        int32x4_t data = vld1q_s32(&lst[i]);\n        \n        uint32_t mods[4];\n        for (int j = 0; j < 4; ++j) {\n            mods[j] = (base_mod + j) % 12;\n        }\n        uint32x4_t vmod = vld1q_u32(mods);\n        \n        uint32x4_t mask_square = \n            vorrq_u32(\n                vorrq_u32(\n                    vceqq_u32(vmod, vdupq_n_u32(0)),\n                    vceqq_u32(vmod, vdupq_n_u32(3))\n                ),\n                vorrq_u32(\n                    vceqq_u32(vmod, vdupq_n_u32(6)),\n                    vceqq_u32(vmod, vdupq_n_u32(9))\n                )\n            );\n        \n        uint32x4_t mask_cube = \n            vorrq_u32(\n                vceqq_u32(vmod, vdupq_n_u32(4)),\n                vceqq_u32(vmod, vdupq_n_u32(8))\n            );\n        \n        int32x4_t square = vmulq_s32(data, data);\n        int32x4_t cube = vmulq_s32(square, data);\n        \n        int32x4_t blended = vbslq_s32(mask_cube, cube, data);\n        blended = vbslq_s32(mask_square, square, blended);\n        \n        vsum = vaddq_s32(vsum, blended);\n        base_mod = (base_mod + 4) % 12;\n    }\n    \n    int32_t sum_arr[4];\n    vst1q_s32(sum_arr, vsum);\n    int sum = sum_arr[0] + sum_arr[1] + sum_arr[2] + sum_arr[3];\n    \n    for (int j = i; j < n; ++j) {\n        int mod = (base_mod + (j - i)) % 12;\n        int value = lst[j];\n        if (mod == 0 || mod == 3 || mod == 6 || mod == 9) {\n            value = value * value;\n        } else if (mod == 4 || mod == 8) {\n            value = value * value * value;\n        }\n        sum += value;\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_130_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    static const int cond3[12] = {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0};\n    static const int cond4[12] = {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0};\n    const int* data = lst.data();\n    size_t n = lst.size();\n    int total = 0;\n    size_t i = 0;\n\n    for (; i + 12 <= n; i += 12) {\n        uint32_t base_res = i % 12;\n        uint32_t mask3_arr[12], mask4_arr[12];\n        for (int j = 0; j < 12; ++j) {\n            uint32_t r = (base_res + j) % 12;\n            mask3_arr[j] = cond3[r] ? 0xFFFFFFFF : 0;\n            mask4_arr[j] = cond4[r] ? 0xFFFFFFFF : 0;\n        }\n\n        uint32x4_t mask3_0 = vld1q_u32(mask3_arr);\n        uint32x4_t mask3_1 = vld1q_u32(mask3_arr + 4);\n        uint32x4_t mask3_2 = vld1q_u32(mask3_arr + 8);\n        uint32x4_t mask4_0 = vld1q_u32(mask4_arr);\n        uint32x4_t mask4_1 = vld1q_u32(mask4_arr + 4);\n        uint32x4_t mask4_2 = vld1q_u32(mask4_arr + 8);\n\n        int32x4_t v0 = vld1q_s32(data + i);\n        int32x4_t v1 = vld1q_s32(data + i + 4);\n        int32x4_t v2 = vld1q_s32(data + i + 8);\n\n        int32x4_t sq0 = vmulq_s32(v0, v0);\n        int32x4_t sq1 = vmulq_s32(v1, v1);\n        int32x4_t sq2 = vmulq_s32(v2, v2);\n\n        int32x4_t cube0 = vmulq_s32(sq0, v0);\n        int32x4_t cube1 = vmulq_s32(sq1, v1);\n        int32x4_t cube2 = vmulq_s32(sq2, v2);\n\n        int32x4_t step0 = vbslq_s32(mask4_0, cube0, v0);\n        int32x4_t res0 = vbslq_s32(mask3_0, sq0, step0);\n        int32x4_t step1 = vbslq_s32(mask4_1, cube1, v1);\n        int32x4_t res1 = vbslq_s32(mask3_1, sq1, step1);\n        int32x4_t step2 = vbslq_s32(mask4_2, cube2, v2);\n        int32x4_t res2 = vbslq_s32(mask3_2, sq2, step2);\n\n        int32x4_t sum01 = vaddq_s32(res0, res1);\n        int32x4_t sum012 = vaddq_s32(sum01, res2);\n        total += vgetq_lane_s32(sum012, 0) + vgetq_lane_s32(sum012, 1) + vgetq_lane_s32(sum012, 2) + vgetq_lane_s32(sum012, 3);\n    }\n\n    for (; i < n; ++i) {\n        if (i % 3 == 0) {\n            total += data[i] * data[i];\n        } else if (i % 4 == 0) {\n            total += data[i] * data[i] * data[i];\n        } else {\n            total += data[i];\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int n = nums.size();\n    if (n == 0) \n        return 0;\n\n    int count = 0;\n    int i = 0;\n\n    const int32x4_t ten = vdupq_n_s32(10);\n    const uint32x4_t magic = vdupq_n_u32(0xCCCCCCCD);\n    const int32x4_t one_vec = vdupq_n_s32(1);\n    const uint32x4_t one_u32 = vdupq_n_u32(1);\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t v_val = vld1q_s32(&nums[i]);\n        uint32x4_t mask_gt10 = vcgtq_s32(v_val, ten);\n        int32x4_t u = vabsq_s32(v_val);\n        uint32x4_t u_abs = vreinterpretq_u32_s32(u);\n        uint32x4_t quotient = vshrq_n_u32(vmulq_u32(u_abs, magic), 35);\n        uint32x4_t last_digit = vsubq_u32(u_abs, vmulq_u32(quotient, vdupq_n_u32(10)));\n        int32x4_t last_digit_s32 = vreinterpretq_s32_u32(last_digit);\n        int32x4_t last_odd = vandq_s32(last_digit_s32, one_vec);\n        uint32x4_t mask_last = vceqq_s32(last_odd, one_vec);\n        uint32x4_t first = u_abs;\n        for (int j = 0; j < 10; j++) {\n            uint32x4_t mask_step = vcgeq_u32(first, vdupq_n_u32(10));\n            uint32x4_t quotient_step = vshrq_n_u32(vmulq_u32(first, magic), 35);\n            first = vbslq_u32(mask_step, quotient_step, first);\n        }\n        int32x4_t first_digit_s32 = vreinterpretq_s32_u32(first);\n        int32x4_t first_odd = vandq_s32(first_digit_s32, one_vec);\n        uint32x4_t mask_first = vceqq_s32(first_odd, one_vec);\n        uint32x4_t mask_total = vandq_u32(mask_gt10, vandq_u32(mask_last, mask_first));\n        count += vaddvq_u32(vandq_u32(mask_total, one_u32));\n    }\n\n    for (; i < n; i++) {\n        int val = nums[i];\n        if (val <= 10) \n            continue;\n        int u = std::abs(val);\n        int last_digit = u % 10;\n        if (last_digit % 2 == 0) \n            continue;\n        int first_digit = u;\n        while (first_digit >= 10) \n            first_digit /= 10;\n        if (first_digit % 2 == 1) \n            count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int i = 0;\n    const int size = nums.size();\n    \n    for (; i <= size - 4; i += 4) {\n        int32x4_t v_orig = vld1q_s32(&nums[i]);\n        int32x4_t ten = vdupq_n_s32(10);\n        uint32x4_t mask_a = vcgtq_s32(v_orig, ten);\n        int32x4_t v_abs = vabsq_s32(v_orig);\n        \n        int32_t abs_arr[4];\n        uint32_t mask_arr[4];\n        vst1q_s32(abs_arr, v_abs);\n        vst1q_u32(mask_arr, mask_a);\n        \n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                int n = abs_arr[j];\n                int last_digit = n % 10;\n                while (n >= 10) {\n                    n /= 10;\n                }\n                int first_digit = n;\n                if ((last_digit % 2 == 1) && (first_digit % 2 == 1)) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    for (; i < size; i++) {\n        int n_orig = nums[i];\n        if (n_orig > 10) {\n            int n = (n_orig < 0) ? -n_orig : n_orig;\n            int last_digit = n % 10;\n            while (n >= 10) {\n                n /= 10;\n            }\n            int first_digit = n;\n            if ((last_digit % 2 == 1) && (first_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int i = 0;\n    const int n = nums.size();\n    \n    for (; i <= n - 4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n        \n        int32x4_t cmp_gt10 = vcgtq_s32(v, vdupq_n_s32(10));\n        uint32x4_t va = vreinterpretq_u32_s32(v);\n        \n        uint32x2_t va_low = vget_low_u32(va);\n        uint32x2_t va_high = vget_high_u32(va);\n        \n        uint64x2_t low_prod = vmull_u32(va_low, vdup_n_u32(0xCCCCCCCD));\n        uint64x2_t high_prod = vmull_u32(va_high, vdup_n_u32(0xCCCCCCCD));\n        \n        low_prod = vshrq_n_u64(low_prod, 35);\n        high_prod = vshrq_n_u64(high_prod, 35);\n        \n        uint32x2_t low_quot = vmovn_u64(low_prod);\n        uint32x2_t high_quot = vmovn_u64(high_prod);\n        uint32x4_t quotient = vcombine_u32(low_quot, high_quot);\n        \n        uint32x4_t rem = vsubq_u32(va, vmulq_u32(quotient, vdupq_n_u32(10)));\n        uint32x4_t mask2 = vceqq_u32(vandq_u32(rem, vdupq_n_u32(1)), vdupq_n_u32(1));\n        \n        uint32x4_t candidate_mask = vandq_u32(vreinterpretq_u32_s32(cmp_gt10), mask2);\n        \n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, candidate_mask);\n        \n        int32_t values_arr[4];\n        vst1q_s32(values_arr, v);\n        \n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                int num = values_arr[j];\n                int n = num;\n                while (n >= 10) {\n                    n /= 10;\n                }\n                if (n & 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    for (; i < n; i++) {\n        int num = nums[i];\n        if (num > 10) {\n            int last_digit = num % 10;\n            if (last_digit & 1) {\n                int n = num;\n                while (n >= 10) {\n                    n /= 10;\n                }\n                if (n & 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int i = 0;\n    int n = nums.size();\n    const int32_t* data = nums.data();\n\n    // Process chunks of 4 with SIMD\n    for (; i <= n - 4; i += 4) {\n        // Load 4 integers\n        int32x4_t v = vld1q_s32(data + i);\n        // Check if numbers > 10\n        uint32x4_t gt10_mask = vcgtq_s32(v, vdupq_n_s32(10));\n        // Get absolute values for digit processing\n        int32x4_t abs_v = vabsq_s32(v);\n        int32_t abs_arr[4];\n        vst1q_s32(abs_arr, abs_v);\n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, gt10_mask);\n\n        // Process each element in the chunk\n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                int num = abs_arr[j];\n                // Get last digit\n                int last_digit = num % 10;\n                // Get first digit\n                while (num >= 10) {\n                    num /= 10;\n                }\n                int first_digit = num;\n                // Check if both digits are odd\n                if ((last_digit % 2 == 1) && (first_digit % 2 == 1)) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    // Process remaining elements\n    for (; i < n; i++) {\n        int val = data[i];\n        if (val > 10) {\n            int num = val < 0 ? -val : val;\n            int last_digit = num % 10;\n            while (num >= 10) {\n                num /= 10;\n            }\n            int first_digit = num;\n            if ((last_digit % 2 == 1) && (first_digit % 2 == 1)) {\n                count++;\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    int i = 0;\n    const int size = nums.size();\n\n    for (; i <= size-4; i += 4) {\n        int32x4_t v = vld1q_s32(&nums[i]);\n        uint32x4_t mask = vcgtq_s32(v, vdupq_n_s32(10));\n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, mask);\n\n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                int num_val = nums[i+j];\n                int last_digit = num_val % 10;\n                if (last_digit % 2 != 0) {\n                    int n = num_val;\n                    while (n >= 10) {\n                        n /= 10;\n                    }\n                    if (n % 2 != 0) {\n                        count++;\n                    }\n                }\n            }\n        }\n    }\n\n    for (; i < size; i++) {\n        int num_val = nums[i];\n        if (num_val > 10) {\n            int last_digit = num_val % 10;\n            if (last_digit % 2 != 0) {\n                int n = num_val;\n                while (n >= 10) {\n                    n /= 10;\n                }\n                if (n % 2 != 0) {\n                    count++;\n                }\n            }\n        }\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n > 0xFFFFFFFF) {\n        uint64_t count0 = (n + 1) / 3;\n        uint64_t count1 = n - count0;\n        uint64_t ans = 0;\n        if (count0 >= 3) {\n            ans += count0 * (count0 - 1) * (count0 - 2) / 6;\n        }\n        if (count1 >= 3) {\n            ans += count1 * (count1 - 1) * (count1 - 2) / 6;\n        }\n        return ans;\n    }\n\n    uint32_t un = (uint32_t)n;\n    uint32_t count0 = 0;\n    uint32_t i = 1;\n    uint32_t idx_arr[4] = {0, 1, 2, 3};\n    uint32x4_t indices = vld1q_u32(idx_arr);\n\n    while (i <= un) {\n        uint32_t base = i % 3;\n        uint32_t r1 = (base + 1) % 3;\n        uint32_t r2 = (base + 2) % 3;\n        uint32_t residues_arr[4] = {base, r1, r2, base};\n        uint32x4_t residues = vld1q_u32(residues_arr);\n\n        uint32_t remain = un - i + 1;\n        uint32x4_t valid = vcltq_u32(indices, vdupq_n_u32(remain));\n        uint32x4_t cmp = vceqq_u32(residues, vdupq_n_u32(2));\n        cmp = vandq_u32(cmp, valid);\n        cmp = vshrq_n_u32(cmp, 31);\n        count0 += vaddvq_u32(cmp);\n\n        i += 4;\n    }\n\n    uint64_t count1 = un - count0;\n    uint64_t ans = 0;\n    if (count0 >= 3) {\n        ans = (uint64_t)count0 * (count0 - 1) * (count0 - 2) / 6;\n    }\n    if (count1 >= 3) {\n        ans += (uint64_t)count1 * (count1 - 1) * (count1 - 2) / 6;\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count0 = (n + 1) / 3;\n    uint64_t count1 = n - count0;\n    uint64_t counts[2] = {count0, count1};\n    uint64x2_t v = vld1q_u64(counts);\n    uint64x2_t one = vdupq_n_u64(1);\n    uint64x2_t two = vdupq_n_u64(2);\n    uint64x2_t v_minus1 = vsubq_u64(v, one);\n    uint64x2_t v_minus2 = vsubq_u64(v, two);\n    uint64x2_t prod = vmulq_u64(v, v_minus1);\n    prod = vmulq_u64(prod, v_minus2);\n    uint64_t arr[2];\n    vst1q_u64(arr, prod);\n    arr[0] /= 6;\n    arr[1] /= 6;\n    return arr[0] + arr[1];\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count0 = (n + 1) / 3;\n    uint64_t count1 = n - count0;\n\n    uint64x2_t v = {count0, count1};\n    uint64x2_t ones = vdupq_n_u64(1);\n    uint64x2_t twos = vdupq_n_u64(2);\n\n    uint64x2_t v_minus1 = vsubq_u64(v, ones);\n    uint64x2_t v_minus2 = vsubq_u64(v, twos);\n\n    uint64x2_t prod = vmulq_u64(v, v_minus1);\n    prod = vmulq_u64(prod, v_minus2);\n\n    uint64_t prod0 = vgetq_lane_u64(prod, 0);\n    uint64_t prod1 = vgetq_lane_u64(prod, 1);\n\n    prod0 /= 6;\n    prod1 /= 6;\n\n    return prod0 + prod1;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t count0 = (n + 1) / 3;\n    uint64_t count1 = n - count0;\n    uint64x2_t v_count0 = vcombine_u64(vcreate_u64(count0), vcreate_u64(0));\n    uint64x2_t v_count1 = vcombine_u64(vcreate_u64(count1), vcreate_u64(0));\n    uint64x2_t v_one = vdupq_n_u64(1);\n    uint64x2_t v_two = vdupq_n_u64(2);\n\n    uint64x2_t v_c0_minus1 = vsubq_u64(v_count0, v_one);\n    uint64x2_t v_c0_minus2 = vsubq_u64(v_count0, v_two);\n    uint64x2_t v_term0 = vmulq_u64(v_count0, v_c0_minus1);\n    v_term0 = vmulq_u64(v_term0, v_c0_minus2);\n\n    uint64x2_t v_c1_minus1 = vsubq_u64(v_count1, v_one);\n    uint64x2_t v_c1_minus2 = vsubq_u64(v_count1, v_two);\n    uint64x2_t v_term1 = vmulq_u64(v_count1, v_c1_minus1);\n    v_term1 = vmulq_u64(v_term1, v_c1_minus2);\n\n    uint64_t term0 = vgetq_lane_u64(v_term0, 0) / 6;\n    uint64_t term1 = vgetq_lane_u64(v_term1, 0) / 6;\n    return term0 + term1;\n}\n```"}
{"task_id": "SimdBench_132_Neon", "completion": "```c\n#include <arm_neon.h>\n\nuint64_t get_max_triples_simd(uint64_t n){\n    if (n < 3) {\n        return 0;\n    }\n    uint64_t count0 = (n + 1) / 3;\n    uint64_t count1 = n - count0;\n\n    auto comb = [](uint64_t x) -> uint64_t {\n        if (x < 3) {\n            return 0;\n        }\n        __uint128_t x128 = x;\n        __uint128_t prod = x128 * (x128 - 1) * (x128 - 2);\n        return static_cast<uint64_t>(prod / 6);\n    };\n\n    uint64_t c0 = comb(count0);\n    uint64_t c1 = comb(count1);\n\n    uint64_t arr[2] = {c0, c1};\n    uint64x2_t v = vld1q_u64(arr);\n    uint64x2_t v_sum = vaddq_u64(v, v);\n    uint64x1_t low = vget_low_u64(v_sum);\n    uint64x1_t high = vget_high_u64(v_sum);\n    uint64x1_t v_result = vadd_u64(low, high);\n    return vget_lane_u64(v_result, 0);\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <math.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n\n    int sqrt_n = (int)sqrt((double)n);\n    uint32_t step_arr[4] = {0, 2, 4, 6};\n    uint32x4_t v_step = vld1q_u32(step_arr);\n\n    for (uint32_t base = 3; base <= (uint32_t)sqrt_n; base += 8) {\n        uint32x4_t v_base = vdupq_n_u32(base);\n        uint32x4_t v_div = vaddq_u32(v_base, v_step);\n\n        uint32_t divisors[4];\n        vst1q_u32(divisors, v_div);\n\n        for (int j = 0; j < 4; j++) {\n            if (divisors[j] > (uint32_t)sqrt_n) {\n                break;\n            }\n            if (n % divisors[j] == 0) {\n                return y;\n            }\n        }\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y){\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n\n    int limit = 2;\n    while (limit * limit <= n) {\n        limit++;\n    }\n    limit--;\n\n    unsigned int un = (unsigned int)n;\n    unsigned int d = 3;\n    static const unsigned int offsets_arr[4] = {0, 2, 4, 6};\n    uint32x4_t v_offsets = vld1q_u32(offsets_arr);\n\n    while (d <= (unsigned int)limit) {\n        uint32x4_t v_base = vdupq_n_u32(d);\n        uint32x4_t v_div = vaddq_u32(v_base, v_offsets);\n        uint32x4_t v_lim_vec = vdupq_n_u32(limit);\n        uint32x4_t v_mask = vcleq_u32(v_div, v_lim_vec);\n\n        for (int i = 0; i < 4; i++) {\n            if (vgetq_lane_u32(v_mask, i)) {\n                unsigned int divisor = vgetq_lane_u32(v_div, i);\n                if (un % divisor == 0) {\n                    return y;\n                }\n            }\n        }\n        d += 8;\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n\n    int d = 3;\n    while (d <= n / d) {\n        int divisors[4] = {d, d + 2, d + 4, d + 6};\n\n        int32x4_t vdivs = vld1q_s32(divisors);\n        int32x4_t vsq = vmulq_s32(vdivs, vdivs);\n        uint32x4_t vsq_u = vreinterpretq_u32_s32(vsq);\n        uint32x4_t vn_u = vdupq_n_u32(n);\n        uint32x4_t vmask = vcleq_u32(vsq_u, vn_u);\n\n        uint32_t mask_arr[4];\n        vst1q_u32(mask_arr, vmask);\n\n        for (int i = 0; i < 4; i++) {\n            if (mask_arr[i]) {\n                if (n % divisors[i] == 0) {\n                    return y;\n                }\n            }\n        }\n\n        d += 8;\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n\n    uint32_t un = (uint32_t)n;\n    uint32_t d = 3;\n\n    while (d <= un / d) {\n        uint32_t divisors[4] = {d, d+2, d+4, d+6};\n        uint32x4_t v_div = vld1q_u32(divisors);\n        uint32x4_t v_sq = vmulq_u32(v_div, v_div);\n        uint32x4_t v_active = vcleq_u32(v_sq, vdupq_n_u32(un));\n        \n        if (vmaxvq_u32(v_active) == 0) {\n            break;\n        }\n\n        float32x4_t v_div_f = vcvtq_f32_u32(v_div);\n        float32x4_t v_recip = vrecpeq_f32(v_div_f);\n        v_recip = vmulq_f32(v_recip, vrecpsq_f32(v_div_f, v_recip));\n        v_recip = vmulq_f32(v_recip, vrecpsq_f32(v_div_f, v_recip));\n        float32x4_t v_n_f = vdupq_n_f32((float)un);\n        float32x4_t v_quot_f = vmulq_f32(v_n_f, v_recip);\n        uint32x4_t v_quot = vcvtq_u32_f32(v_quot_f);\n        uint32x4_t v_prod = vmulq_u32(v_div, v_quot);\n        uint32x4_t v_rem = vsubq_u32(vdupq_n_u32(un), v_prod);\n        uint32x4_t v_overflow = vcgtq_u32(v_prod, vdupq_n_u32(un));\n        uint32x4_t v_underflow = vcgeq_u32(v_rem, v_div);\n        uint32x4_t v_rem_adj = v_rem;\n        v_rem_adj = vbslq_u32(v_overflow, vaddq_u32(v_rem, v_div), v_rem_adj);\n        uint32x4_t v_underflow_no_overflow = vbicq_u32(v_underflow, v_overflow);\n        v_rem_adj = vbslq_u32(v_underflow_no_overflow, vsubq_u32(v_rem, v_div), v_rem_adj);\n        uint32x4_t v_zero = vdupq_n_u32(0);\n        uint32x4_t v_cmp_zero = vceqq_u32(v_rem_adj, v_zero);\n        v_cmp_zero = vandq_u32(v_cmp_zero, v_active);\n        uint32_t cmp_arr[4];\n        vst1q_u32(cmp_arr, v_cmp_zero);\n        if (cmp_arr[0] || cmp_arr[1] || cmp_arr[2] || cmp_arr[3]) {\n            return y;\n        }\n        d += 8;\n    }\n\n    while (d <= un / d) {\n        if (un % d == 0) {\n            return y;\n        }\n        d += 2;\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_Neon", "completion": "```c\n#include <arm_neon.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n\n    unsigned int un = (unsigned int)n;\n    unsigned int inc_arr[4] = {0, 2, 4, 6};\n    uint32x4_t v_increments = vld1q_u32(inc_arr);\n    uint32x4_t v_step = vdupq_n_u32(8);\n    uint32x4_t v_div = vdupq_n_u32(3);\n    v_div = vaddq_u32(v_div, v_increments);\n\n    while (1) {\n        unsigned int divisors[4];\n        vst1q_u32(divisors, v_div);\n\n        if ((unsigned long long)divisors[0] * divisors[0] > un) {\n            break;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            unsigned long long d_sq = (unsigned long long)divisors[i] * divisors[i];\n            if (d_sq > un) {\n                break;\n            }\n            if (un % divisors[i] == 0) {\n                return y;\n            }\n        }\n\n        v_div = vaddq_u32(v_div, v_step);\n    }\n\n    return x;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n\n    uint64x2_t acc_low = vdupq_n_u64(0);\n    uint64x2_t acc_high = vdupq_n_u64(0);\n    const int len = lst.size();\n    int i = 0;\n\n    for (; i <= len - 4; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t mask_positive = vcgeq_f32(v, zeros);\n        float32x4_t rounded = vrndq_f32(v);\n        uint32x4_t mask_integer = vceqq_f32(v, rounded);\n        uint32x4_t mask_condition = vandq_u32(mask_positive, mask_integer);\n        uint32x4_t int_val = vcvtq_u32_f32(rounded);\n        uint32x4_t odd_mask = vandq_u32(int_val, vdupq_n_u32(1));\n        uint32x4_t mask_odd = vceqq_u32(odd_mask, vdupq_n_u32(1));\n        uint32x4_t mask = vandq_u32(mask_condition, mask_odd);\n        uint32x4_t masked_int_val = vandq_u32(int_val, mask);\n        uint32x2_t low_val = vget_low_u32(masked_int_val);\n        uint32x2_t high_val = vget_high_u32(masked_int_val);\n        uint64x2_t low_sq = vmull_u32(low_val, low_val);\n        uint64x2_t high_sq = vmull_u32(high_val, high_val);\n        acc_low = vaddq_u64(acc_low, low_sq);\n        acc_high = vaddq_u64(acc_high, high_sq);\n    }\n\n    if (i < len) {\n        float temp[4] = {0};\n        for (int j = 0; j < len - i; j++) {\n            temp[j] = lst[i + j];\n        }\n        float32x4_t v = vld1q_f32(temp);\n        float32x4_t zeros = vdupq_n_f32(0.0f);\n        uint32x4_t mask_positive = vcgeq_f32(v, zeros);\n        float32x4_t rounded = vrndq_f32(v);\n        uint32x4_t mask_integer = vceqq_f32(v, rounded);\n        uint32x4_t mask_condition = vandq_u32(mask_positive, mask_integer);\n        uint32x4_t int_val = vcvtq_u32_f32(rounded);\n        uint32x4_t odd_mask = vandq_u32(int_val, vdupq_n_u32(1));\n        uint32x4_t mask_odd = vceqq_u32(odd_mask, vdupq_n_u32(1));\n        uint32x4_t mask = vandq_u32(mask_condition, mask_odd);\n        uint32x4_t masked_int_val = vandq_u32(int_val, mask);\n        uint32x2_t low_val = vget_low_u32(masked_int_val);\n        uint32x2_t high_val = vget_high_u32(masked_int_val);\n        uint64x2_t low_sq = vmull_u32(low_val, low_val);\n        uint64x2_t high_sq = vmull_u32(high_val, high_val);\n        acc_low = vaddq_u64(acc_low, low_sq);\n        acc_high = vaddq_u64(acc_high, high_sq);\n    }\n\n    acc_low = vaddq_u64(acc_low, acc_high);\n    uint64_t total = vgetq_lane_u64(acc_low, 0) + vgetq_lane_u64(acc_low, 1);\n    return total;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <stdint.h>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t total = 0;\n    size_t i = 0;\n    const size_t len = lst.size();\n    const float* data = lst.data();\n\n    for (; i + 4 <= len; i += 4) {\n        float32x4_t v = vld1q_f32(data + i);\n        uint32x4_t mask_positive = vcgeq_f32(v, vdupq_n_f32(0.0f));\n        int32x4_t int_part = vcvtq_s32_f32(v);\n        float32x4_t trunc = vcvtq_f32_s32(int_part);\n        uint32x4_t mask_integer = vceqq_f32(v, trunc);\n        int32x4_t low_bit = vandq_s32(int_part, vdupq_n_s32(1));\n        uint32x4_t mask_odd = vceqq_s32(low_bit, vdupq_n_s32(1));\n        uint32x4_t mask = vandq_u32(mask_positive, vandq_u32(mask_integer, mask_odd));\n\n        uint32_t mask_arr[4];\n        int32_t int_arr[4];\n        vst1q_u32(mask_arr, mask);\n        vst1q_s32(int_arr, int_part);\n\n        for (int j = 0; j < 4; j++) {\n            if (mask_arr[j]) {\n                int32_t val = int_arr[j];\n                total += static_cast<uint64_t>(val) * static_cast<uint64_t>(val);\n            }\n        }\n    }\n\n    for (; i < len; i++) {\n        float x = data[i];\n        if (x >= 0.0f) {\n            float trunc = static_cast<float>(static_cast<int32_t>(x));\n            if (trunc == x) {\n                int32_t val = static_cast<int32_t>(x);\n                if (val & 1) {\n                    total += static_cast<uint64_t>(val) * static_cast<uint64_t>(val);\n                }\n            }\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t total = 0;\n    size_t i = 0;\n    const size_t size = lst.size();\n    const float32x4_t zero = vdupq_n_f32(0.0f);\n    const float32x4_t max_val = vdupq_n_f32(4294967296.0f);\n\n    for (; i + 4 <= size; i += 4) {\n        float32x4_t v = vld1q_f32(&lst[i]);\n\n        uint32x4_t mask_non_neg = vcgeq_f32(v, zero);\n        float32x4_t truncated = vrndmq_f32(v);\n        uint32x4_t mask_int = vceqq_f32(v, truncated);\n        uint32x4_t mask_less_than_max = vcltq_f32(v, max_val);\n        uint32x4_t candidate_mask = vandq_u32(mask_non_neg, vandq_u32(mask_int, mask_less_than_max));\n\n        uint32x4_t v_uint = vcvtq_u32_f32(v);\n        uint32x4_t mask_odd = vtstq_u32(v_uint, vdupq_n_u32(1));\n        candidate_mask = vandq_u32(candidate_mask, mask_odd);\n\n        for (int j = 0; j < 4; j++) {\n            if (vgetq_lane_u32(candidate_mask, j)) {\n                uint32_t x = vgetq_lane_u32(v_uint, j);\n                total += static_cast<uint64_t>(x) * x;\n            }\n        }\n    }\n\n    for (; i < size; i++) {\n        float x = lst[i];\n        if (x >= 0.0f && x < 4294967296.0f) {\n            uint32_t x_uint = static_cast<uint32_t>(x);\n            float reconverted = static_cast<float>(x_uint);\n            if (x == reconverted && (x_uint & 1)) {\n                total += static_cast<uint64_t>(x_uint) * x_uint;\n            }\n        }\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```c\n#include <arm_neon.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    const float* ptr = lst.data();\n    uint64x2_t acc = vdupq_n_u64(0);\n    int i = 0;\n    \n    float32x4_t zero = vdupq_n_f32(0.0f);\n    int32x4_t one = vdupq_n_s32(1);\n    \n    for (; i + 4 <= n; i += 4) {\n        float32x4_t x = vld1q_f32(ptr + i);\n        uint32x4_t mask1 = vcgeq_f32(x, zero);\n        int32x4_t int_val = vcvtq_s32_f32(x);\n        float32x4_t x_int = vcvtq_f32_s32(int_val);\n        uint32x4_t mask2 = vceqq_f32(x, x_int);\n        int32x4_t lsb = vandq_s32(int_val, one);\n        uint32x4_t odd_mask = vceqq_s32(lsb, one);\n        uint32x4_t mask = vandq_u32(vandq_u32(mask1, mask2), odd_mask);\n        \n        uint32x4_t uval = vreinterpretq_u32_s32(int_val);\n        uint32x2_t uval_low = vget_low_u32(uval);\n        uint32x2_t uval_high = vget_high_u32(uval);\n        uint64x2_t square_low = vmull_u32(uval_low, uval_low);\n        uint64x2_t square_high = vmull_u32(uval_high, uval_high);\n        \n        uint32x2_t mask_low = vget_low_u32(mask);\n        uint32x2_t mask_high = vget_high_u32(mask);\n        int32x2_t mask_low_s32 = vreinterpret_s32_u32(mask_low);\n        int32x2_t mask_high_s32 = vreinterpret_s32_u32(mask_high);\n        int64x2_t mask_low64 = vmovl_s32(mask_low_s32);\n        int64x2_t mask_high64 = vmovl_s32(mask_high_s32);\n        square_low = vandq_u64(square_low, vreinterpretq_u64_s64(mask_low64));\n        square_high = vandq_u64(square_high, vreinterpretq_u64_s64(mask_high64));\n        \n        acc = vaddq_u64(acc, square_low);\n        acc = vaddq_u64(acc, square_high);\n    }\n    \n    uint64_t total = vgetq_lane_u64(acc, 0) + vgetq_lane_u64(acc, 1);\n    \n    for (; i < n; i++) {\n        float val = ptr[i];\n        if (val < 0) continue;\n        int ival = static_cast<int>(val);\n        if (static_cast<float>(ival) != val) continue;\n        if (ival % 2 == 1) {\n            total += static_cast<uint64_t>(ival) * ival;\n        }\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_134_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) \n        return 0;\n\n    const float *data = lst.data();\n    size_t n = lst.size();\n    const float max_odd = 16777216.0f;\n\n    float32x4_t zero_vec = vdupq_n_f32(0.0f);\n    float32x4_t max_odd_vec = vdupq_n_f32(max_odd);\n    uint32x4_t one_mask = vdupq_n_u32(1);\n    float64x2_t total_vec = vdupq_n_f64(0.0);\n\n    size_t i = 0;\n    for (; i + 4 <= n; i += 4) {\n        float32x4_t x = vld1q_f32(data + i);\n        uint32x4_t mask_positive = vcgtq_f32(x, zero_vec);\n        float32x4_t floor_x = vrndmq_f32(x);\n        float32x4_t fractional = vsubq_f32(x, floor_x);\n        uint32x4_t mask_integer = vceqq_f32(fractional, zero_vec);\n        uint32x4_t mask_small = vcleq_f32(floor_x, max_odd_vec);\n        int32x4_t int_val = vcvtq_s32_f32(floor_x);\n        uint32x4_t lsb = vandq_u32(vreinterpretq_u32_s32(int_val), one_mask);\n        uint32x4_t mask_odd = vceqq_u32(lsb, one_mask);\n        uint32x4_t mask = vandq_u32(mask_positive, vandq_u32(mask_integer, vandq_u32(mask_small, mask_odd)));\n        float32x4_t squares = vmulq_f32(x, x);\n        float32x4_t selected = vbslq_f32(mask, squares, zero_vec);\n        float64x2_t low = vcvt_f64_f32(vget_low_f32(selected));\n        float64x2_t high = vcvt_f64_f32(vget_high_f32(selected));\n        total_vec = vaddq_f64(total_vec, low);\n        total_vec = vaddq_f64(total_vec, high);\n    }\n\n    double total_double = vgetq_lane_f64(total_vec, 0) + vgetq_lane_f64(total_vec, 1);\n    for (; i < n; i++) {\n        float val = data[i];\n        if (val > 0.0f) {\n            float floor_val = floorf(val);\n            if (val == floor_val && floor_val <= max_odd) {\n                int32_t int_val = static_cast<int32_t>(floor_val);\n                if (int_val % 2 == 1) {\n                    total_double += static_cast<double>(val) * static_cast<double>(val);\n                }\n            }\n        }\n    }\n\n    return static_cast<uint64_t>(total_double);\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <climits>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> res(game.size());\n    size_t i = 0;\n    const size_t size = game.size();\n    \n    for (; i + 4 <= size; i += 4) {\n        int32x4_t a = vld1q_s32(&game[i]);\n        int32x4_t b = vld1q_s32(&guess[i]);\n        int32x4_t diff = vsubq_s32(a, b);\n        int32x4_t abs_diff = vabsq_s32(diff);\n        vst1q_s32(&res[i], abs_diff);\n    }\n    \n    for (; i < size; ++i) {\n        int diff = game[i] - guess[i];\n        if (diff == INT_MIN) {\n            res[i] = INT_MAX;\n        } else {\n            res[i] = std::abs(diff);\n        }\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    size_t i = 0;\n\n    for (; i + 4 <= n; i += 4) {\n        int32x4_t a = vld1q_s32(&game[i]);\n        int32x4_t b = vld1q_s32(&guess[i]);\n        int32x4_t res = vabdq_s32(a, b);\n        vst1q_s32(&result[i], res);\n    }\n\n    for (; i < n; ++i) {\n        int diff = game[i] - guess[i];\n        result[i] = diff < 0 ? -diff : diff;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    size_t i = 0;\n    const size_t size = game.size();\n\n    for (; i + 3 < size; i += 4) {\n        int32x4_t game_vec = vld1q_s32(&game[i]);\n        int32x4_t guess_vec = vld1q_s32(&guess[i]);\n        int32x4_t diff = vsubq_s32(game_vec, guess_vec);\n        int32x4_t abs_diff = vabsq_s32(diff);\n        vst1q_s32(&result[i], abs_diff);\n    }\n\n    for (; i < size; ++i) {\n        result[i] = std::abs(game[i] - guess[i]);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> res(n);\n    const int32_t* game_data = game.data();\n    const int32_t* guess_data = guess.data();\n    int32_t* res_data = res.data();\n\n    size_t i = 0;\n    size_t aligned_size = n - (n % 4);\n    for (; i < aligned_size; i += 4) {\n        int32x4_t g_vec = vld1q_s32(game_data + i);\n        int32x4_t u_vec = vld1q_s32(guess_data + i);\n        int32x4_t diff_vec = vabdq_s32(g_vec, u_vec);\n        vst1q_s32(res_data + i, diff_vec);\n    }\n\n    for (; i < n; i++) {\n        res[i] = abs(game_data[i] - guess_data[i]);\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_135_Neon", "completion": "```cpp\n#include <arm_neon.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t size = game.size();\n    std::vector<int> out(size);\n    const int* game_ptr = game.data();\n    const int* guess_ptr = guess.data();\n    int* out_ptr = out.data();\n\n    size_t i = 0;\n    for (; i + 4 <= size; i += 4) {\n        int32x4_t g_vec = vld1q_s32(game_ptr + i);\n        int32x4_t u_vec = vld1q_s32(guess_ptr + i);\n        int32x4_t diff = vabdq_s32(g_vec, u_vec);\n        vst1q_s32(out_ptr + i, diff);\n    }\n\n    for (; i < size; i++) {\n        int g_val = game_ptr[i];\n        int u_val = guess_ptr[i];\n        if (g_val > u_val) {\n            out_ptr[i] = g_val - u_val;\n        } else {\n            out_ptr[i] = u_val - g_val;\n        }\n    }\n\n    return out;\n}\n```"}

{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    size_t vl = svcntd();\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svuint64_t mask_vec = svld1ub_u64(pg, (const uint8_t*)(mask + i));\n        svbool_t mask_pred = svcmpne(pg, mask_vec, 0);\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svint64_t dst_vec = svld1_s64(pg, dst + i);\n        svint64_t res = svsel_s64(mask_pred, src_vec, dst_vec);\n        svst1_s64(pg, dst + i, res);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t mask_vec = svld1ub_u64(pg, (const uint8_t*)(mask + i));\n        svbool_t pg_mask = svcmpne(pg, mask_vec, 0);\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svint64_t dst_vec = svld1_s64(pg, dst + i);\n        svint64_t res = svsel(pg_mask, src_vec, dst_vec);\n        svst1_s64(pg, dst + i, res);\n        i += svcntp_b64(pg, pg);\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        uint64_t vl = svcntp_b64(pg, pg);\n        svint64_t src_vec = svld1(pg, src + i);\n        svint64_t dst_vec = svld1(pg, dst + i);\n        \n        uint8_t temp_mask[vl];\n        for (size_t j = 0; j < vl; j++) {\n            temp_mask[j] = mask[i + j] ? 0xFF : 0x00;\n        }\n        \n        svbool_t pg_byte = svwhilelt_b8(0, vl);\n        svuint8_t temp_mask_vec = svld1(pg_byte, temp_mask);\n        svbool_t mask_pred = svcmpne(pg_byte, temp_mask_vec, 0);\n        \n        svint64_t res = svsel(mask_pred, src_vec, dst_vec);\n        svst1(pg, dst + i, res);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        uint64_t n = svcntp_b64(pg, pg);\n        if (n == 0) break;\n\n        svuint64_t mask_vec = svld1ub_u64(pg, (const uint8_t*)(mask + i));\n        svbool_t mask_pred = svcmpne(pg, mask_vec, 0);\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svint64_t dst_vec = svld1_s64(pg, dst + i);\n        svint64_t res = svsel_s64(mask_pred, src_vec, dst_vec);\n        svst1_s64(pg, dst + i, res);\n\n        i += n;\n    }\n}\n```"}
{"task_id": "SimdBench_0_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid conditional_move_simd(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    size_t vl = svcntd();\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svuint64_t mask_vec = svld1ub_u64(pg, (const uint8_t*)(mask + i));\n        svbool_t pg_mask = svcmpne(pg, mask_vec, 0);\n        svint64_t src_vec = svld1_s64(pg, src + i);\n        svint64_t dst_vec = svld1_s64(pg, dst + i);\n        svint64_t res_vec = svsel_s64(pg_mask, src_vec, dst_vec);\n        svst1_s64(pg, dst + i, res_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t prod_vec = svmul_n_s32_z(pg, vec, scale);\n        svint32_t tmp1_vec = svshr_n_s32_z(pg, prod_vec, 3);\n        svint32_t tmp2_vec = svshl_n_s32_z(pg, prod_vec, 3);\n        svint32_t tmp_product_vec = svmul_s32_z(pg, tmp1_vec, tmp2_vec);\n        svint32_t sum_vec = svadd_s32_z(pg, prod_vec, tmp_product_vec);\n        svint32_t result_vec = svdiv_n_s32_z(pg, sum_vec, 7);\n        svst1_s32(pg, dst + i, result_vec);\n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    const int64_t magic_constant = 0x24924925;\n    do {\n        svbool_t pg = svwhilelt_b32(i, length);\n        uint64_t n = svcntp_b32(pg, pg);\n        if (n == 0) break;\n        \n        svint32_t data = svld1_s32(pg, src + i);\n        svint32_t scaled = svmul_n_s32_z(pg, data, scale);\n        svint32_t tmp1 = svqshl_n_s32(scaled, -3);\n        svint32_t tmp2 = svlsl_n_s32(scaled, 3);\n        svint32_t term2 = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t sum = svadd_s32_z(pg, scaled, term2);\n        svint64_t sum64 = svsxtw_s64(sum);\n        svint64_t magic_vec = svdup_n_s64(magic_constant);\n        svint64_t product = svmul_s64_z(svptrue_b64(), sum64, magic_vec);\n        svint32_t high32 = svqshrnb_n_s64(product, 32);\n        svint32_t temp = svadd_s32_z(pg, high32, sum);\n        svint32_t result = svqshl_n_s32(temp, -3);\n        svst1_s32(pg, dst + i, result);\n        \n        i += n;\n    } while (1);\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t i = 0;\n    svint32_t vscale = svdup_n_s32(scale);\n    svint32_t vseven = svdup_n_s32(7);\n    svbool_t all_true = svptrue_b32();\n    unsigned int vl = svcntw();\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t data = svld1_s32(pg, src + i);\n        svint32_t x = svmul_s32_z(pg, data, vscale);\n        svint32_t tmp1 = svasr_n_s32_z(pg, x, 3);\n        svint32_t tmp2 = svlsl_n_s32_z(pg, x, 3);\n        svint32_t product = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t term = svadd_s32_z(pg, x, product);\n        svint32_t result = svdiv_s32_z(pg, term, vseven);\n        svst1_s32(pg, dst + i, result);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    size_t vl = svcntw();\n    svint32_t divisor_vec = svdup_n_s32(7);\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t data = svld1_s32(pg, src + i);\n        svint32_t x = svmul_n_s32_z(pg, data, scale);\n        svint32_t tmp1 = svsr_s32_z(pg, x, 3);\n        svint32_t tmp2 = svlsl_n_s32_z(pg, x, 3);\n        svint32_t prod = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t total = svadd_s32_z(pg, x, prod);\n        svint32_t result = svdiv_s32_z(pg, total, divisor_vec);\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_1_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid load_modify_store_simd(const int *src, int *dst, int scale, size_t length) {\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    svint32_t magic_const = svdup_n_s32(0x92492493);\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t src_vec = svld1_s32(pg, src + i);\n        svint32_t svmul = svmul_s32_z(pg, src_vec, svdup_n_s32(scale));\n        svint32_t tmp1 = svasr_n_s32_z(pg, svmul, 3);\n        svint32_t tmp2 = svlsl_n_s32_z(pg, svmul, 3);\n        svint32_t tmp_prod = svmul_s32_z(pg, tmp1, tmp2);\n        svint32_t term = svadd_s32_z(pg, svmul, tmp_prod);\n        svint32_t q0 = svmulh_s32_z(pg, term, magic_const);\n        svint32_t q1 = svadd_s32_z(pg, term, q0);\n        svint32_t result_vec = svasr_n_s32_z(pg, q1, 2);\n        svst1_s32(pg, dst + i, result_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    if (rows == 0) {\n        return;\n    }\n    uint64_t vl = svcntd();\n    size_t r0 = 0;\n\n    while (r0 < rows) {\n        svbool_t pg = svwhilelt_b64_u64(r0, rows);\n        svuint64_t row_vec = svindex_u64(r0, 1);\n        svuint64_t index_vec = svmad_n_u64_z(pg, row_vec, cols, stride);\n        svfloat64_t data = svld1_gather_u64index(pg, src, index_vec);\n        svst1_f64(pg, dst + r0, data);\n        r0 += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    size_t vl = svcntd();\n    size_t r = 0;\n    while (r < rows) {\n        svbool_t pg = svwhilelt_b64(r, rows);\n        uint64_t base = r * cols + stride;\n        svuint64_t indices = svindex_u64(base, cols);\n        svfloat64_t data = svld1_gather_u64index_f64(pg, src, indices);\n        svst1_f64(pg, dst + r, data);\n        r += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    if (rows == 0) {\n        return;\n    }\n    uint64_t vl = svcntd();\n    uint64_t r = 0;\n    svbool_t pg;\n\n    while (r + vl <= rows) {\n        int64_t base_val = (int64_t)(r * cols + stride);\n        int64_t step_val = (int64_t)cols;\n        svint64_t indices = svindex_s64(base_val, step_val);\n        svfloat64_t data = svld1_gather_s64index_f64(svptrue_b64(), src, indices);\n        svst1_f64(svptrue_b64(), dst + r, data);\n        r += vl;\n    }\n\n    if (r < rows) {\n        pg = svwhilelt_b64(r, rows);\n        int64_t base_val = (int64_t)(r * cols + stride);\n        int64_t step_val = (int64_t)cols;\n        svint64_t indices = svindex_s64(base_val, step_val);\n        svfloat64_t data = svld1_gather_s64index_f64(pg, src, indices);\n        svst1_f64(pg, dst + r, data);\n    }\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    if (rows == 0) \n        return;\n    \n    uint64_t step_bytes = (uint64_t)cols * sizeof(double);\n    size_t vl = svcntd();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, rows);\n    \n    do {\n        const double *base_ptr = src + i * cols + stride;\n        svuint64_t offsets = svindex_u64(0, step_bytes);\n        svfloat64_t data = svld1_gather_offset_f64(pg, base_ptr, offsets);\n        svst1_f64(pg, dst + i, data);\n        i += vl;\n        pg = svwhilelt_b64(i, rows);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_2_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid strided_load_store_simd(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    uint64_t vl = svcntd();\n    for (size_t i = 0; i < rows; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, rows);\n        const double *base_ptr = src + stride + i * cols;\n        svuint64_t offsets = svindex_u64(0, cols);\n        svfloat64_t data = svld1_gather_u64index_f64(pg, base_ptr, offsets);\n        svst1_f64(pg, dst + i, data);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    unsigned int vl;\n\n    // Gather operation: dst[i] = src[indices[i]]\n    i = 0;\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        vl = svcntw();\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, gathered);\n        i += vl;\n    }\n\n    // Scatter operation: dst[indices[i]] = src[i]\n    i = 0;\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        vl = svcntw();\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t src_vals = svld1_f32(pg, src + i);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, src_vals);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t vl;\n    svbool_t pg;\n    size_t i = 0;\n\n    // Gather loop: dst[i] = src[indices[i]]\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        vl = svcntw();\n        svint32_t idx = svld1_s32(pg, &indices[i]);\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx);\n        svst1_f32(pg, &dst[i], gathered);\n        i += vl;\n    }\n\n    i = 0;\n    // Scatter loop: dst[indices[i]] = src[i]\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        vl = svcntw();\n        svint32_t idx = svld1_s32(pg, &indices[i]);\n        svfloat32_t vals = svld1_f32(pg, &src[i]);\n        svst1_scatter_s32index_f32(pg, dst, idx, vals);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg;\n    // Gather pass: dst[i] = src[indices[i]]\n    i = 0;\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t indices_vec = svld1_u32(pg, (const uint32_t*)(indices + i));\n        svfloat32_t gathered = svld1_gather_u32index_f32(pg, src, indices_vec);\n        svst1_f32(pg, dst + i, gathered);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n    \n    // Scatter pass: dst[indices[i]] = src[i]\n    i = 0;\n    while (i < length) {\n        pg = svwhilelt_b32(i, length);\n        svuint32_t indices_vec = svld1_u32(pg, (const uint32_t*)(indices + i));\n        svfloat32_t src_vec = svld1_f32(pg, src + i);\n        svst1_scatter_u32index_f32(pg, dst, indices_vec, src_vec);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    size_t i = 0;\n    unsigned int vl = svcntw();\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t gathered = svld1_gather_s32index_f32(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, gathered);\n        i += vl;\n    }\n    \n    i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t data = svld1_f32(pg, src + i);\n        svst1_scatter_s32index_f32(pg, dst, idx_vec, data);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_3_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid indexed_access_simd(const float *src, const int *indices, float *dst, size_t length) {\n    svbool_t all_true = svptrue_b32();\n    size_t vl = svcntw();\n    size_t i = 0;\n\n    // Gather loop: dst[i] = src[indices[i]]\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t gathered = svld1_gather_index(pg, src, idx_vec);\n        svst1_f32(pg, dst + i, gathered);\n        i += vl;\n    }\n\n    i = 0;\n    // Scatter loop: dst[indices[i]] = src[i]\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t idx_vec = svld1_s32(pg, indices + i);\n        svfloat32_t src_vals = svld1_f32(pg, src + i);\n        svst1_scatter_index(pg, dst, idx_vec, src_vals);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) {\n        return;\n    }\n    uint64_t left = start;\n    uint64_t right = end;\n    uint64_t vl = svcnth();\n\n    while (left < right) {\n        uint64_t n_elems = right - left + 1;\n        uint64_t k = n_elems / 2;\n        if (k == 0) {\n            break;\n        }\n        if (k > vl) {\n            k = vl;\n        }\n\n        svbool_t pg = svwhilelt_b16(0, k);\n        svint16_t left_vec = svld1(pg, arr + left);\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t right_elem_indices = svsub_u64_z(pg, svdup_u64(right), indices);\n        svuint64_t right_byte_offsets = svlsl_n_u64_z(pg, right_elem_indices, 1);\n        svint16_t right_vec = svld1_gather_offset(pg, arr, right_byte_offsets);\n\n        svst1_scatter_offset(pg, arr, right_byte_offsets, left_vec);\n        svst1(pg, arr + left, right_vec);\n\n        left += k;\n        right -= k;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) {\n        return;\n    }\n    uint64_t left = start;\n    uint64_t right = end;\n    uint64_t max_vl = svcnth();\n\n    while (left < right) {\n        uint64_t remaining = right - left + 1;\n        uint64_t cur_vl = max_vl;\n        if (cur_vl > remaining / 2) {\n            cur_vl = remaining / 2;\n        }\n        if (cur_vl == 0) {\n            break;\n        }\n\n        svbool_t pg = svwhilelt_b16(0, cur_vl);\n        svint16_t left_vec = svld1_s16(pg, arr + left);\n        svint16_t right_vec = svld1_s16(pg, arr + (right - cur_vl + 1));\n\n        svint16_t reversed_left = svrev_s16(left_vec);\n        svint16_t reversed_right = svrev_s16(right_vec);\n\n        svst1_s16(pg, arr + left, reversed_right);\n        svst1_s16(pg, arr + (right - cur_vl + 1), reversed_left);\n\n        left += cur_vl;\n        right -= cur_vl;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) return;\n    \n    int16_t *left = arr + start;\n    int16_t *right = arr + end;\n    uint64_t max_vl = svcnth();\n\n    while (left < right) {\n        uint64_t n = (right - left) + 1;\n        uint64_t chunk_size = max_vl;\n        if (chunk_size > n / 2) \n            chunk_size = n / 2;\n        if (chunk_size == 0) break;\n\n        svbool_t pg = svwhilelt_b16(0, chunk_size);\n        svint16_t left_vec = svld1_s16(pg, left);\n        svint16_t right_vec = svld1_s16(pg, right - chunk_size + 1);\n        \n        svint16_t rev_left = svrevh_s16_x(pg, left_vec);\n        svint16_t rev_right = svrevh_s16_x(pg, right_vec);\n        \n        svst1_s16(pg, left, rev_right);\n        svst1_s16(pg, right - chunk_size + 1, rev_left);\n        \n        left += chunk_size;\n        right -= chunk_size;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    uint64_t left = start;\n    uint64_t right = end;\n    uint64_t vl = svcnth();\n\n    while (left < right) {\n        uint64_t n_remaining = right - left + 1;\n        if (n_remaining < 2) break;\n\n        uint64_t count = n_remaining / 2;\n        if (count > vl) count = vl;\n\n        svbool_t pg = svwhilelt_b16_u64(0, count);\n        svint16_t left_vec = svld1(pg, arr + left);\n        svint16_t right_vec = svld1(pg, arr + right - count + 1);\n\n        svint16_t rev_left = svrev(pg, left_vec);\n        svint16_t rev_right = svrev(pg, right_vec);\n\n        svst1(pg, arr + left, rev_right);\n        svst1(pg, arr + right - count + 1, rev_left);\n\n        left += count;\n        right -= count;\n    }\n}\n```"}
{"task_id": "SimdBench_4_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_reverse_simd(int16_t *arr, uint64_t start, uint64_t end) {\n    if (start >= end) \n        return;\n    \n    uint64_t left = start;\n    uint64_t right = end;\n    uint64_t vl = svcnth();\n\n    while (left < right) {\n        uint64_t n_remaining = right - left + 1;\n        uint64_t pairs_remaining = n_remaining / 2;\n        if (pairs_remaining == 0) \n            break;\n        \n        uint64_t chunk_size = (pairs_remaining < vl) ? pairs_remaining : vl;\n        svbool_t pg = svwhilelt_b16(0, chunk_size);\n        \n        svint16_t left_vec = svld1(pg, arr + left);\n        svint16_t right_vec = svld1(pg, arr + (right - chunk_size + 1));\n        \n        svint16_t left_rev = svrev_s16(left_vec);\n        svint16_t right_rev = svrev_s16(right_vec);\n        \n        svst1(pg, arr + left, right_rev);\n        svst1(pg, arr + (right - chunk_size + 1), left_rev);\n        \n        left += chunk_size;\n        right -= chunk_size;\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t vl = svcntb();\n    for (size_t i = 0; i < dim1; i++) {\n        size_t base_i = i * dim2 * dim3 + slice_idx;\n        size_t base_slice_i = i * dim2;\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b8(j, dim2);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint64_t offsets = svindex_u64(0, (int64_t)dim3);\n            const uint8_t* tensor_ptr = tensor + base_i + j * dim3;\n            svuint8_t data = svld1_gather_u64offset(pg, tensor_ptr, offsets);\n            svst1(pg, slice + base_slice_i + j, data);\n            j += vl;\n            pg = svwhilelt_b8(j, dim2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *base_src = tensor + i * dim2 * dim3 + slice_idx;\n        uint8_t *base_dst = slice + i * dim2;\n        size_t j = 0;\n        svbool_t pg64 = svwhilelt_b64(j, dim2);\n        while (svptest_any(svptrue_b64(), pg64)) {\n            svuint64_t indices = svindex_u64(j, 1);\n            svuint64_t byte_offsets = svmul_n_u64_z(pg64, indices, dim3);\n            svuint8_t data = svld1_gather_u64offset_u8(pg64, base_src, byte_offsets);\n            uint64_t n = svcntp_b64(svptrue_b64(), pg64);\n            svbool_t pg8 = svwhilelt_b8(0, n);\n            svst1_u8(pg8, base_dst + j, data);\n            j += n;\n            pg64 = svwhilelt_b64(j, dim2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    uint64_t vl_bytes = svcntb();\n    svuint64_t indices = svindex_u64(0, dim3);\n\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *base_ptr = tensor + i * (dim2 * dim3) + slice_idx;\n        uint8_t *output_ptr = slice + i * dim2;\n\n        const uint8_t *base_ptr_current = base_ptr;\n        size_t j = 0;\n        while (j < dim2) {\n            svbool_t pg = svwhilelt_b8(j, dim2);\n            svuint8_t data = svld1_gather_u64index_u8(pg, base_ptr_current, indices);\n            svst1_u8(pg, output_ptr + j, data);\n            uint64_t num_processed = svcntp_b8(svptrue_b8(), pg);\n            base_ptr_current += num_processed * dim3;\n            j += num_processed;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *base_src = tensor + i * (dim2 * dim3) + slice_idx;\n        uint8_t *base_dst = slice + i * dim2;\n        size_t j = 0;\n        \n        while (j < dim2) {\n            svbool_t pg = svwhilelt_b32(j, dim2);\n            svuint32_t j_vec = svindex_u32(j, 1);\n            svuint32_t byte_offsets = svmul_n_u32_z(pg, j_vec, dim3);\n            svuint8_t data = svld1_gather_u32offset_u8(pg, base_src, byte_offsets);\n            svst1_u8(pg, base_dst + j, data);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid extract_tensor_slice_simd(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *row_src = tensor + i * (dim2 * dim3) + slice_idx;\n        uint8_t *row_dst = slice + i * dim2;\n\n        size_t j = 0;\n        svbool_t pg64 = svwhilelt_b64(j, dim2);\n        while (svptest_any(svptrue_b64(), pg64)) {\n            svuint64_t indices = svindex_u64(j, 1);\n            svuint64_t offsets = svmul_n_u64_z(pg64, indices, dim3);\n            svuint8_t data = svld1_gather_u64index_u8(pg64, row_src, offsets);\n            \n            uint64_t vl = svcntp_b64(pg64, pg64);\n            svbool_t pg8 = svwhilelt_b8(0, vl);\n            svst1_u8(pg8, row_dst + j, data);\n            \n            j += vl;\n            pg64 = svwhilelt_b64(j, dim2);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t start_row = 0; start_row < rows; start_row += block_size) {\n        size_t end_row = start_row + block_size;\n        if (end_row > rows) end_row = rows;\n        size_t actual_block_rows = end_row - start_row;\n\n        for (size_t start_col = 0; start_col < cols; start_col += block_size) {\n            size_t end_col = start_col + block_size;\n            if (end_col > cols) end_col = cols;\n            size_t actual_block_cols = end_col - start_col;\n\n            for (size_t j = 0; j < actual_block_cols; ) {\n                svbool_t pg = svwhilelt_b16(j, actual_block_cols);\n                size_t vl = svcnth();\n\n                for (size_t i = 0; i < actual_block_rows; i++) {\n                    const int16_t *src_ptr = src + (start_row + i) * cols + start_col + j;\n                    svint16_t data = svld1(pg, src_ptr);\n\n                    int16_t *dst_block_base = dst + start_col * rows + start_row;\n                    uint64_t base_offset = (j * rows + i) * sizeof(int16_t);\n                    uint64_t step = rows * sizeof(int16_t);\n                    svuint64_t indices = svindex_u64(0, 1);\n                    svuint64_t byte_offsets = svmla_n_u64_z(pg, svdup_u64(base_offset), indices, step);\n\n                    svst1_scatter_offset(pg, dst_block_base, byte_offsets, data);\n                }\n                j += vl;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t r0 = 0; r0 < rows; r0 += block_size) {\n        size_t block_rows = (r0 + block_size <= rows) ? block_size : rows - r0;\n        for (size_t c0 = 0; c0 < cols; c0 += block_size) {\n            size_t block_cols = (c0 + block_size <= cols) ? block_size : cols - c0;\n            for (size_t i = 0; i < block_rows; i++) {\n                uint64_t base_addr = (uint64_t)dst + ((c0 * rows + r0 + i) * sizeof(int16_t));\n                uint64_t stride_bytes = rows * sizeof(int16_t);\n                size_t j = 0;\n                while (j < block_cols) {\n                    svbool_t pg = svwhilelt_b16(j, block_cols);\n                    svuint16_t j_vec = svindex_u16(j, 1);\n                    svuint64_t j_idx = svcvt_u64_z(pg, j_vec);\n                    svuint64_t offsets = svmul_n_u64_z(pg, j_idx, stride_bytes);\n                    svuint64_t addr = svadd_u64_z(pg, svdup_u64_z(pg, base_addr), offsets);\n                    svint16_t data = svld1(pg, src + (r0 + i) * cols + c0 + j);\n                    svst1_scatter_u64base_s16(pg, addr, data);\n                    j += svcntp_b16(pg, pg);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    size_t vl = svcnth();\n\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t M = (i + block_size <= rows) ? block_size : rows - i;\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t N = (j + block_size <= cols) ? block_size : cols - j;\n\n            for (size_t n = 0; n < N; n += vl) {\n                size_t this_stripe = (n + vl <= N) ? vl : N - n;\n                svbool_t pg = svwhilelt_b16(0, this_stripe);\n                svuint32_t offsets = svindex_u32(0, rows * sizeof(int16_t));\n\n                for (size_t m = 0; m < M; m++) {\n                    svint16_t vec = svld1(pg, src + (i + m) * cols + j + n);\n                    svst1_scatter_offset(pg, dst + (j + n) * rows + i + m, offsets, vec);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i0 = 0; i0 < rows; i0 += block_size) {\n        size_t i_end = i0 + block_size;\n        if (i_end > rows) i_end = rows;\n        size_t block_height = i_end - i0;\n\n        for (size_t j0 = 0; j0 < cols; j0 += block_size) {\n            size_t j_end = j0 + block_size;\n            if (j_end > cols) j_end = cols;\n            size_t block_width = j_end - j0;\n\n            for (size_t r = 0; r < block_height; r++) {\n                size_t c = 0;\n                while (c < block_width) {\n                    svbool_t pg = svwhilelt_b16(c, block_width);\n                    svint16_t data = svld1(pg, src + (i0 + r) * cols + j0 + c);\n                    int16_t *base_ptr = dst + (j0 * rows) + (i0 + r) + c * rows;\n                    svuint64_t offsets = svmul_n_u64_z(pg, svindex_u64(0, 1), rows * sizeof(int16_t));\n                    svst1_scatter_u64offset_s16(pg, base_ptr, offsets, data);\n                    c += svcnth();\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid blocked_matrix_transpose_simd(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i_block = 0; i_block < rows; i_block += block_size) {\n        size_t i_block_end = i_block + block_size;\n        if (i_block_end > rows) {\n            i_block_end = rows;\n        }\n        size_t block_rows = i_block_end - i_block;\n\n        for (size_t j_block = 0; j_block < cols; j_block += block_size) {\n            size_t j_block_end = j_block + block_size;\n            if (j_block_end > cols) {\n                j_block_end = cols;\n            }\n            size_t block_cols = j_block_end - j_block;\n\n            size_t vl_rows = svcntw();\n            for (size_t i_in_block = 0; i_in_block < block_rows; i_in_block += vl_rows) {\n                size_t current_vl_i = block_rows - i_in_block;\n                if (current_vl_i > vl_rows) {\n                    current_vl_i = vl_rows;\n                }\n                svbool_t pg_i = svwhilelt_b16_u32(0, current_vl_i);\n                svint32_t gather_offsets = svindex_s32(0, cols * sizeof(int16_t));\n\n                for (size_t j_in_block = 0; j_in_block < block_cols; j_in_block++) {\n                    const int16_t *src_ptr = src + (i_block + i_in_block) * cols + j_block + j_in_block;\n                    svint16_t data = svld1_gather_index(pg_i, src_ptr, gather_offsets);\n                    int16_t *dst_ptr = dst + (j_block + j_in_block) * rows + i_block + i_in_block;\n                    svst1(pg_i, dst_ptr, data);\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    uint64_t stride = (uint64_t)dim * dim + dim + 1;\n    uint64_t i = 0;\n    float sum = 0.0f;\n    while (i < dim) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        svuint64_t indices = svindex_u64(i * stride, stride);\n        svfloat32_t values = svld1_gather_u64index_f32(pg, array, indices);\n        float segment_sum = svaddv_f32(pg, values);\n        sum += segment_sum;\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    uint64_t stride_elems = (uint64_t)dim * dim + dim + 1;\n    uint64_t stride_bytes = stride_elems * sizeof(float);\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, dim);\n    svfloat32_t sum_vec = svdup_f32(0.0f);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t i_vec = svindex_s64(i, 1);\n        svint64_t byte_offsets = svmul_n_s64_z(pg, i_vec, stride_bytes);\n        svfloat32_t values = svld1_gather_s64index_f32(pg, array, byte_offsets);\n        sum_vec = svadd_f32_m(pg, sum_vec, values);\n        i += svcntd();\n        pg = svwhilelt_b64(i, dim);\n    }\n\n    float sum = svaddv_f32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    float sum = 0.0f;\n    size_t step = dim * dim + dim + 1;\n    size_t i = 0;\n\n    while (i < dim) {\n        svbool_t pg = svwhilelt_b64(i, dim);\n        uint64_t n = svcntp_b64(pg);\n        if (n == 0) break;\n\n        svint64_t j = svindex_s64(i, 1);\n        svint64_t offsets = svmul_n_s64_x(pg, j, step);\n        svfloat32_t values = svld1_gather_s64index_f32(pg, array, offsets);\n        float sum_part = svaddv_f32(pg, values);\n        sum += sum_part;\n\n        i += n;\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n\n    size_t step = dim * dim + dim + 1;\n    size_t stride_bytes = step * sizeof(float);\n    uint64_t i = 0;\n    svfloat32_t acc = svdup_f32(0.0f);\n\n    while (i < dim) {\n        svbool_t pg = svwhilelt_b32(i, dim);\n        svint64_t i_vec = svindex_s64(i, 1);\n        svint64_t byte_offsets = svmul_n_s64_z(pg, i_vec, stride_bytes);\n        svfloat32_t values = svld1_gather_s64index_f32(pg, array, byte_offsets);\n        acc = svadd_f32_m(svptrue_b32(), acc, values);\n        uint64_t n = svcntp_b32(svptrue_b32(), pg);\n        i += n;\n    }\n\n    float sum = svaddv_f32(svptrue_b32(), acc);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7_SVE", "completion": "```c\n#include <arm_sve.h> \n\nfloat diagonal_sum_3d_simd(const float *array, size_t dim) {\n    if (dim == 0) {\n        return 0.0f;\n    }\n    \n    uint64_t dim64 = (uint64_t)dim;\n    uint64_t step = dim64 * dim64 + dim64 + 1;\n    uint64_t i = 0;\n    float total_sum = 0.0f;\n    \n    while (i < dim64) {\n        svbool_t pg = svwhilelt_b64(i, dim64);\n        uint64_t base = i * step;\n        svuint64_t indices = svindex_u64(base, step);\n        svfloat32_t gathered = svld1_gather_u64index(pg, array, indices);\n        float partial = svaddv(pg, gathered);\n        total_sum += partial;\n        i += svcntd();\n    }\n    \n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    uint64_t total_elements = rows * cols;\n    if (total_elements == 0) {\n        return;\n    }\n    \n    uint64_t vl = svcntd();\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t v = svld1(pg, src + i);\n        svfloat64_t thresh_vec = svdup_f64(threshold);\n        svbool_t mask = svcmpgt(pg, v, thresh_vec);\n        svfloat64_t scale_vec = svdup_f64(scale);\n        svfloat64_t scaled_v = svmul_m(mask, v, v, scale_vec);\n        svst1(pg, dst + i, scaled_v);\n\n        i += vl;\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    if (total_elements == 0) return;\n\n    uint64_t vl = svcntd();\n    uint64_t i = 0;\n    svbool_t all_true = svptrue_b64();\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t src_vec = svld1(pg, src + i);\n        svfloat64_t thresh_vec = svdup_f64(threshold);\n        svbool_t mask = svcmpgt(pg, src_vec, thresh_vec);\n        svfloat64_t scaled_vec = svmul_z(pg, src_vec, svdup_f64(scale));\n        svfloat64_t res_vec = svsel(mask, scaled_vec, src_vec);\n        svst1(pg, dst + i, res_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = svcntd();\n    svbool_t all_mask = svptrue_b64();\n\n    size_t i = 0;\n    for (; i + vl <= total_elements; i += vl) {\n        svfloat64_t data = svld1(all_mask, src + i);\n        svbool_t cmp_mask = svcmpgt(all_mask, data, svdup_f64(threshold));\n        svfloat64_t scaled = svmul_m(cmp_mask, data, data, scale);\n        svst1(all_mask, dst + i, scaled);\n    }\n\n    if (i < total_elements) {\n        svbool_t tail_mask = svwhilelt_b64(i, total_elements);\n        svfloat64_t data = svld1(tail_mask, src + i);\n        svbool_t cmp_mask = svcmpgt(tail_mask, data, svdup_f64(threshold));\n        svfloat64_t scaled = svmul_m(cmp_mask, data, data, scale);\n        svst1(tail_mask, dst + i, scaled);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t v_src = svld1(pg, src + i);\n        svbool_t mask = svcmpgt(pg, v_src, threshold);\n        svfloat64_t v_dst = svmul_x(mask, v_src, scale);\n        svst1(pg, dst + i, v_dst);\n        i += svcntd();\n        pg = svwhilelt_b64(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_8_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_scale_simd(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total_elements = rows * cols;\n    size_t vl = svcntd();\n    svbool_t pg = svptrue_b64();\n    svfloat64_t v_threshold = svdup_f64(threshold);\n    svfloat64_t v_scale = svdup_f64(scale);\n\n    size_t i = 0;\n    for (; i + vl <= total_elements; i += vl) {\n        svfloat64_t v_src = svld1(pg, src + i);\n        svbool_t p_gt = svcmpgt(pg, v_src, v_threshold);\n        svfloat64_t v_dst = svmul_f64_m(p_gt, v_src, v_scale);\n        svst1(pg, dst + i, v_dst);\n    }\n\n    if (i < total_elements) {\n        svbool_t pg_tail = svwhilelt_b64(i, total_elements);\n        svfloat64_t v_src = svld1(pg_tail, src + i);\n        svbool_t p_gt = svcmpgt(pg_tail, v_src, v_threshold);\n        svfloat64_t v_dst = svmul_f64_m(p_gt, v_src, v_scale);\n        svst1(pg_tail, dst + i, v_dst);\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        const double *src_row_ptr = src + src_row * cols;\n        double *dst_row_ptr = dst + i * cols;\n\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64_u64(j, cols);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t data = svld1_f64(pg, src_row_ptr + j);\n            svst1_f64(pg, dst_row_ptr + j, data);\n            j += svcntp_b64(pg, pg);\n            pg = svwhilelt_b64_u64(j, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    uint64_t vl = svcntd();\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        const double *src_ptr = src + src_row * cols;\n        double *dst_ptr = dst + i * cols;\n        for (size_t j = 0; j < cols; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t data = svld1(pg, src_ptr + j);\n            svst1(pg, dst_ptr + j, data);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; i++) {\n        const double *src_row = src + indices[i] * cols;\n        double *dst_row = dst + i * cols;\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t data = svld1(pg, src_row + j);\n            svst1(pg, dst_row + j, data);\n            j += vl;\n            pg = svwhilelt_b64(j, cols);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row_index = indices[i];\n        const double *src_row = src + src_row_index * cols;\n        double *dst_row = dst + i * cols;\n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t data = svld1(pg, src_row + j);\n            svst1(pg, dst_row + j, data);\n            j += svcntd();\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid reorder_matrix_rows_simd(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    if (rows == 0 || cols == 0) {\n        return;\n    }\n    \n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < rows; i++) {\n        size_t row_index = indices[i];\n        const double *src_row = src + row_index * cols;\n        double *dst_row = dst + i * cols;\n        \n        size_t k = 0;\n        while (k < cols) {\n            svbool_t pg = svwhilelt_b64(k, cols);\n            svfloat64_t data = svld1(pg, src_row + k);\n            svst1(pg, dst_row + k, data);\n            k += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    svint64_t scalar_vec = svdup_n_s64(scalar);\n    size_t vl = svcntd();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        svint64_t v1 = svld1_s64(pg, src1 + i);\n        svint64_t v2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_x(pg, v1, v2);\n        svint64_t temp = svadd_s64_x(pg, sum, scalar_vec);\n        svbool_t p_neg = svcmplt_s64(pg, temp, 0);\n        svint64_t correction = svdup_n_s64(0);\n        correction = svsel_s64(p_neg, svdup_n_s64(1), correction);\n        svint64_t adjusted = svadd_s64_x(pg, temp, correction);\n        svint64_t res = svasr_n_s64_x(pg, adjusted, 1);\n        svst1_s64(pg, dst + i, res);\n        i += vl;\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    size_t i = 0;\n    const size_t vl = svcntd();\n    svint64_t vscalar = svdup_s64(scalar);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t va = svld1_s64(pg, src1 + i);\n        svint64_t vb = svld1_s64(pg, src2 + i);\n        svint64_t vsum = svadd_s64_z(pg, va, vb);\n        vsum = svadd_s64_z(pg, vsum, vscalar);\n        svbool_t mask_neg = svcmplt_s64(pg, vsum, 0);\n        svint64_t adjust = svdup_s64(0);\n        adjust = svsel_s64(mask_neg, svdup_s64(1), adjust);\n        vsum = svadd_s64_z(pg, vsum, adjust);\n        svint64_t result = svashr_s64_z(pg, vsum, 1);\n        svst1_s64(pg, dst + i, result);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    const uint64_t vl = svcntd();\n    svint64_t vec_scalar = svdup_s64(scalar);\n    size_t i = 0;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t v1 = svld1_s64(pg, src1 + i);\n        svint64_t v2 = svld1_s64(pg, src2 + i);\n        svint64_t sum = svadd_s64_x(pg, v1, v2);\n        svint64_t total = svadd_s64_x(pg, sum, vec_scalar);\n        svint64_t sign = svasr_n_s64_x(pg, total, 63);\n        svint64_t adjusted = svsub_s64_x(pg, total, sign);\n        svint64_t result = svasr_n_s64_x(pg, adjusted, 1);\n        svst1_s64(pg, dst + i, result);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    uint64_t vl = svcntd();\n    svint64_t scalar_vec = svdup_s64(scalar);\n    for (size_t index = 0; index < length; index += vl) {\n        svbool_t pg = svwhilelt_b64(index, length);\n        svint64_t s1 = svld1(pg, src1 + index);\n        svint64_t s2 = svld1(pg, src2 + index);\n        svint64_t sum = svadd_x(pg, svadd_x(pg, s1, s2), scalar_vec);\n        svint64_t sign = svasr_x(pg, sum, 63);\n        svint64_t adjusted = svsub_x(pg, sum, sign);\n        svint64_t res = svasr_x(pg, adjusted, 1);\n        svst1(pg, dst + index, res);\n    }\n}\n```"}
{"task_id": "SimdBench_10_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_vector_add_simd(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    uint64_t vl = svcntd();\n    svint64_t scalar_vec = svdup_s64(scalar);\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t v1 = svld1(pg, src1 + i);\n        svint64_t v2 = svld1(pg, src2 + i);\n        svint64_t tmp = svadd_x(pg, v1, v2);\n        tmp = svadd_x(pg, tmp, scalar_vec);\n        svbool_t negative_mask = svcmplt(pg, tmp, 0);\n        svint64_t adjust = svsel(negative_mask, svdup_s64(1), svdup_s64(0));\n        tmp = svadd_x(pg, tmp, adjust);\n        svint64_t result = svashr_x(pg, tmp, 1);\n        svst1(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <climits>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    uint64_t vl = svcntw();\n    uint64_t base = 0;\n    int min_val = INT_MAX;\n\n    while (base < length) {\n        svint32_t indices = svindex_s32(base, 2);\n        svbool_t pg = svcmplt_s32(svptrue_b32(), indices, svdup_s32(length));\n        \n        if (svptest_any(svptrue_b32(), pg)) {\n            svint32_t values = svld1_gather_s32index_s32(pg, src, indices);\n            int segment_min = svminv_s32(pg, values);\n            if (segment_min < min_val) {\n                min_val = segment_min;\n            }\n        }\n        \n        base += 2 * vl;\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    unsigned int vl = svcntw();\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    svint32_t min_vec = svdup_s32(INT_MAX);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t indices = svindex_s32(i, 1);\n        svbool_t even_pg = svcmpeq(svptrue_b32(), svand_z(svptrue_b32(), indices, 1), 0);\n        even_pg = svand_z(svptrue_b32(), even_pg, pg);\n\n        svint32_t values = svld1(even_pg, src + i);\n        min_vec = svmin_m(even_pg, min_vec, values);\n\n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n\n    int result = svminv(svptrue_b32(), min_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    size_t num_even = (length + 1) / 2;\n    size_t i = 0;\n    svint32_t min_vec = svdup_s32(0x7FFFFFFF);\n    while (i < num_even) {\n        svbool_t pg = svwhilelt_b32(i, num_even);\n        svint32_t indices = svindex_s32(2*i, 2);\n        svint32_t data = svld1_gather_s32index_s32(pg, src, indices);\n        min_vec = svmin_s32_m(pg, min_vec, data);\n        i += svcntw();\n    }\n    int min_val = svminv_s32(svptrue_b32(), min_vec);\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h>\n#include <stdint.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    \n    uint64_t vl = svcntw();\n    svint32_t offset_vec = svindex_s32(0, 1);\n    svint32_t offset_mod2_pattern = svand_s32_x(svptrue_b32(), offset_vec, svdup_s32(1));\n    int min_val = INT_MAX;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, src + i);\n        svint32_t i_mod2 = svdup_s32(i % 2);\n        svbool_t even_mask_full = svcmpeq_s32(svptrue_b32(), offset_mod2_pattern, i_mod2);\n        svbool_t even_mask = svand_b_z(pg, even_mask_full);\n        \n        if (svptest_any(svptrue_b32(), even_mask)) {\n            int current_min = svminv_s32(even_mask, data);\n            if (current_min < min_val) {\n                min_val = current_min;\n            }\n        }\n        \n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n    \n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <limits.h>\n\nint vector_even_min_simd(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    uint64_t vl = svcntw();\n    uint64_t base_index = 0;\n    svint32_t min_vec = svdup_n_s32(INT_MAX);\n\n    while (base_index < length) {\n        svint32_t indices = svindex_s32(base_index, 2);\n        svbool_t pg = svcmplt_s32(svptrue_b32(), indices, svdup_n_s32(length));\n        svint32_t values = svld1_gather_s32index_s32(pg, src, indices);\n        min_vec = svmin_s32_m(pg, min_vec, values);\n        base_index += 2 * vl;\n    }\n    return svminv_s32(svptrue_b32(), min_vec);\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    svint32_t shift_vec_s = svdup_n_s32((int32_t)shift);\n    svuint32_t shift_vec_u = svdup_n_u32((uint32_t)shift);\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, src + i);\n        svint32_t arith_shifted = svashr_s32_z(pg, data, shift_vec_s);\n        svuint32_t data_u = svreinterpret_u32_s32(data);\n        svuint32_t logical_shifted_u = svlsr_u32_z(pg, data_u, shift_vec_u);\n        svint32_t logical_shifted = svreinterpret_s32_u32(logical_shifted_u);\n        svint32_t result = svadd_s32_z(pg, arith_shifted, logical_shifted);\n        svst1_s32(pg, dst + i, result);\n        i += svcntp_b32(svptrue_b32(), pg);\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    if (length == 0) {\n        return;\n    }\n    \n    svint32_t shift_vec = svdup_n_s32((int32_t)shift);\n    svuint32_t shift_vec_u = svdup_n_u32(shift);\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, src + i);\n        svint32_t arith_shifted = svashr_s32_x(pg, data, shift_vec);\n        svuint32_t data_u = svreinterpret_u32_s32(data);\n        svuint32_t logical_shifted_u = svlsr_u32_x(pg, data_u, shift_vec_u);\n        svint32_t logical_shifted = svreinterpret_s32_u32(logical_shifted_u);\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logical_shifted);\n        svst1_s32(pg, dst + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    uint32_t i = 0;\n    svint32_t shift_vec = svdup_n_s32((int32_t)shift);\n    svuint32_t shift_vec_u = svdup_n_u32((uint32_t)shift);\n    svbool_t pg = svwhilelt_b32(i, length);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t arith_shifted = svasr_s32_x(pg, vec, shift_vec);\n        svuint32_t vec_u = svreinterpret_u32_s32(vec);\n        svuint32_t logical_shifted_u = svlsr_u32_x(pg, vec_u, shift_vec_u);\n        svint32_t logical_shifted = svreinterpret_s32_u32(logical_shifted_u);\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logical_shifted);\n        svst1_s32(pg, dst + i, result);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t i = 0;\n    svuint32_t shift_vec = svdup_n_u32(shift);\n    svbool_t all_mask = svptrue_b32();\n    do {\n        svbool_t pg = svwhilelt_b32(i, length);\n        if (!svptest_any(all_mask, pg)) \n            break;\n        \n        svint32_t data = svld1_s32(pg, &src[i]);\n        svint32_t arith_shifted = svasr_s32_x(pg, data, shift_vec);\n        svuint32_t unsigned_data = svreinterpret_u32_s32(data);\n        svuint32_t logical_shifted = svlsr_u32_x(pg, unsigned_data, shift_vec);\n        svint32_t logical_cast = svreinterpret_s32_u32(logical_shifted);\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logical_cast);\n        svst1_s32(pg, &dst[i], result);\n        \n        i += svcntw();\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_12_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid mixed_right_shift_simd(const int *src, int *dst, uint8_t shift, size_t length) {\n    size_t vl = svcntw();\n    svint32_t shift_vec = svdup_n_s32((int32_t)shift);\n    svuint32_t shift_vec_u = svdup_n_u32((uint32_t)shift);\n    \n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svint32_t vec = svld1_s32(pg, src + i);\n        svint32_t arith_shifted = svashr_s32_x(pg, vec, shift_vec);\n        svuint32_t vec_u = svreinterpret_u32_s32(vec);\n        svuint32_t logical_shifted_u = svlsr_u32_x(pg, vec_u, shift_vec_u);\n        svint32_t logical_shifted = svreinterpret_s32_u32(logical_shifted_u);\n        svint32_t result = svadd_s32_x(pg, arith_shifted, logical_shifted);\n        svst1_s32(pg, dst + i, result);\n    }\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t len = rows * cols;\n    if (len == 0) {\n        return 0;\n    }\n    size_t i = 0;\n    svint64_t acc = svdup_n_s64(0);\n    svbool_t pg32 = svwhilelt_b32(i, len);\n    while (svptest_any(svptrue_b32(), pg32)) {\n        svint32_t vec = svld1_s32(pg32, matrix + i);\n        svint64_t lo = svmovlb_s32(vec);\n        svint64_t hi = svmovlt_s32(vec);\n        acc = svadd_s64_z(svptrue_b64(), acc, lo);\n        acc = svadd_s64_z(svptrue_b64(), acc, hi);\n        i += svcntw();\n        pg32 = svwhilelt_b32(i, len);\n    }\n    return svaddv_s64(svptrue_b64(), acc);\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    uint64_t i = 0;\n    svint64_t vsum = svdup_s64(0);\n\n    while (i < num_elements) {\n        svbool_t pg = svwhilelt_b32(i, num_elements);\n        svint32_t input32 = svld1_s32(pg, matrix + i);\n        svint64_t input64 = svsxtw_s64_z(pg, input32);\n        vsum = svadd_m(pg, vsum, input64);\n        i += svcntp_b32(pg, pg);\n    }\n\n    svbool_t pg_all = svptrue_b64();\n    int64_t total = svaddv_s64(pg_all, vsum);\n    return total;\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    if (total_elements == 0) {\n        return 0;\n    }\n\n    size_t index = 0;\n    svint64_t sum_vec = svdup_s64(0);\n    svbool_t alltrue = svptrue_b64();\n    svbool_t pg = svwhilelt_b64(index, total_elements);\n\n    while (svptest_any(alltrue, pg)) {\n        svint64_t input = svld1sw_s64(pg, (const int32_t *)matrix + index);\n        sum_vec = svadd_s64_m(pg, sum_vec, input);\n        index += svcntd();\n        pg = svwhilelt_b64(index, total_elements);\n    }\n\n    return svaddv_s64(alltrue, sum_vec);\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    uint64_t vl = svcntd();\n    svint64_t acc = svdup_n_s64(0);\n\n    for (size_t i = 0; i < num_elements; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, num_elements);\n        svint64_t input_vec = svld1sw_s64(pg, matrix + i);\n        acc = svadd_s64_m(pg, acc, input_vec);\n    }\n\n    return svaddv_s64(svptrue_b64(), acc);\n}\n```"}
{"task_id": "SimdBench_13_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t matrix_sum_simd(const int *matrix, size_t rows, size_t cols) {\n    size_t num_elements = rows * cols;\n    if (num_elements == 0) {\n        return 0;\n    }\n\n    uint64_t i = 0;\n    svint64_t sum_vec = svdup_n_s64(0);\n    svbool_t pg32 = svwhilelt_b32(i, num_elements);\n    while (svptest_any(svptrue_b32(), pg32)) {\n        svint32_t data = svld1_s32_z(pg32, matrix + i);\n        svint64_t lo = svunpklo_s32(data);\n        svint64_t hi = svunpkhi_s32(data);\n        sum_vec = svadd_s64_z(svptrue_b64(), sum_vec, lo);\n        sum_vec = svadd_s64_z(svptrue_b64(), sum_vec, hi);\n        i += svcntw();\n        pg32 = svwhilelt_b32(i, num_elements);\n    }\n\n    return svaddv_s64(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    uint64_t i = 0;\n    uint64_t vl = svcntb();\n    svint8_t vec_max = svdup_s8(INT8_MIN);\n    svuint64_t vec_idx = svdup_u64(0);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t data = svld1_s8(pg, src + i);\n        svuint64_t indices = svindex_u64(i, 1);\n        svbool_t p_gt = svcmpgt(pg, data, vec_max);\n        vec_max = svsel(p_gt, data, vec_max);\n        vec_idx = svsel(p_gt, indices, vec_idx);\n        i += vl;\n    }\n    int8_t max_val = svmaxv_s8(svptrue_b8(), vec_max);\n    svbool_t p_match = svcmpeq(svptrue_b8(), vec_max, svdup_s8(max_val));\n    uint64_t min_index = svminv_u64(p_match, vec_idx);\n    return min_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    \n    int8_t global_max = INT8_MIN;\n    size_t global_index = 0;\n    size_t base_index = 0;\n    svbool_t pg = svwhilelt_b8(base_index, length);\n    \n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t data = svld1_s8(pg, src + base_index);\n        int8_t max_in_vec = svmaxv_s8(pg, data);\n        \n        if (max_in_vec > global_max) {\n            global_max = max_in_vec;\n            svbool_t max_mask = svcmpeq_s8(pg, data, svdup_s8(max_in_vec));\n            int first_index = svpfirst_b8(svptrue_b8(), max_mask);\n            if (first_index >= 0) {\n                global_index = base_index + first_index;\n            }\n        }\n        \n        base_index += svcntb();\n        pg = svwhilelt_b8(base_index, length);\n    }\n    \n    return global_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t vl = svcntb();\n    size_t i = 0;\n    size_t global_idx = 0;\n    int8_t global_max = -128;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t v = svld1_s8(pg, src + i);\n        int8_t max_in_vec = svmaxv_s8(pg, v);\n\n        if (max_in_vec > global_max) {\n            global_max = max_in_vec;\n            svbool_t mask = svcmpeq_s8(pg, v, svdup_n_s8(max_in_vec));\n            int pos = svpfirst_b(pg, mask);\n            global_idx = i + (size_t)pos;\n        }\n        i += vl;\n    }\n    return global_idx;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    uint64_t i = 0;\n    svbool_t ever_active = svpfalse();\n    svint8_t max_val_vec = svdup_n_s8(-128);\n    svuint64_t max_idx_vec = svdup_n_u64(0);\n    svuint64_t base = svindex_u64(0, 1);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t new_vals = svld1_s8(pg, src + i);\n        svuint64_t current_indices = svadd_n_u64_z(pg, base, i);\n        svbool_t pgt = svcmpgt_s8(pg, new_vals, max_val_vec);\n        max_val_vec = svsel_s8(pgt, new_vals, max_val_vec);\n        max_idx_vec = svsel_u64(pgt, current_indices, max_idx_vec);\n        ever_active = svorr_b_z(svptrue_b8(), ever_active, pg);\n        i += svcntb();\n    }\n\n    int8_t global_max = svmaxv_s8(ever_active, max_val_vec);\n    svbool_t p_max = svcmpeq_s8(ever_active, max_val_vec, global_max);\n    uint64_t min_index = svminv_u64(p_max, max_idx_vec);\n    return min_index;\n}\n```"}
{"task_id": "SimdBench_14_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h>\n\nsize_t argmax_simd(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t global_index = 0;\n    int8_t global_max = INT8_MIN;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t data = svld1_s8(pg, src + i);\n        int8_t max_in_vec = svmaxv_s8(pg, data);\n        if (max_in_vec > global_max) {\n            global_max = max_in_vec;\n            svbool_t p_match = svcmpeq_s8(pg, data, svdup_n_s8(max_in_vec));\n            size_t offset = svpfirst_b8(svptrue_b8(), p_match);\n            global_index = i + offset;\n        }\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n    return global_index;\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint32_t vl32 = svcntw();\n    uint32_t chunk_size = 2 * vl32;\n\n    while (i + chunk_size <= length) {\n        svbool_t all_true16 = svptrue_b16();\n        svuint16_t v1 = svld1_u16(all_true16, src1 + i);\n        svuint16_t v2 = svld1_u16(all_true16, src2 + i);\n\n        svuint32_t even_indices = svindex_u32(i, 2);\n        svuint32_t mask_vec = svdup_u32(mask);\n        svbool_t even_cond = svcmpne_u32(svptrue_b32(), svand_u32_z(svptrue_b32(), even_indices, mask_vec), 0);\n        svuint32_t odd_indices = svadd_u32_z(svptrue_b32(), even_indices, 1);\n        svbool_t odd_cond = svcmpne_u32(svptrue_b32(), svand_u32_z(svptrue_b32(), odd_indices, mask_vec), 0);\n\n        svuint16_t v1_even = svuzp1(v1, v1);\n        svuint16_t v1_odd = svuzp2(v1, v1);\n        svuint16_t v2_even = svuzp1(v2, v2);\n        svuint16_t v2_odd = svuzp2(v2, v2);\n\n        svuint16_t res_even = svsel(even_cond, v1_even, v2_even);\n        svuint16_t res_odd = svsel(odd_cond, v1_odd, v2_odd);\n        svuint16_t res = svzip1(res_even, res_odd);\n\n        svst1_u16(all_true16, dst + i, res);\n        i += chunk_size;\n    }\n\n    for (; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    uint32_t vl = svcntw();\n    size_t chunk_size = 2 * vl;\n\n    while (i + chunk_size <= length) {\n        svbool_t pg = svptrue_b32();\n        svuint32_t index_vec = svmad_u32_z(pg, svindex_u32(0, 1), 2, i);\n        svuint32_t even_indices = index_vec;\n        svuint32_t odd_indices = svadd_n_u32_z(pg, index_vec, 1);\n\n        svuint32_t s1 = svld1_u32(pg, (const uint32_t*)(src1 + i));\n        svuint32_t s2 = svld1_u32(pg, (const uint32_t*)(src2 + i));\n\n        svuint32_t even_cond_val = svand_u32_z(pg, even_indices, mask);\n        svbool_t even_cond = svcmpne_n_u32(pg, even_cond_val, 0);\n        svuint32_t odd_cond_val = svand_u32_z(pg, odd_indices, mask);\n        svbool_t odd_cond = svcmpne_n_u32(pg, odd_cond_val, 0);\n\n        svuint32_t s1_even = svlsr_n_u32_z(pg, s1, 16);\n        svuint32_t s1_odd = svand_u32_z(pg, s1, 0xFFFF);\n        svuint32_t s2_even = svlsr_n_u32_z(pg, s2, 16);\n        svuint32_t s2_odd = svand_u32_z(pg, s2, 0xFFFF);\n\n        svuint32_t res_even = svsel(even_cond, s1_even, s2_even);\n        svuint32_t res_odd = svsel(odd_cond, s1_odd, s2_odd);\n        svuint32_t result = svorr_u32_z(pg, svlsl_n_u32_z(pg, res_even, 16), res_odd);\n\n        svst1_u32(pg, (uint32_t*)(dst + i), result);\n        i += chunk_size;\n    }\n\n    while (i < length) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n        i++;\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    const uint16_t all_true = 0xFFFF;\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        uint64_t vl = svcntp_b16(pg, pg);\n        \n        svuint16_t in1 = svld1(pg, src1 + i);\n        svuint16_t in2 = svld1(pg, src2 + i);\n        \n        uint16_t conditions[vl];\n        for (uint64_t j = 0; j < vl; j++) {\n            conditions[j] = (((i + j) & mask) != 0) ? all_true : 0;\n        }\n        \n        svuint16_t cond_vec = svld1(pg, conditions);\n        svbool_t p = svcmpeq_n_u16(pg, cond_vec, all_true);\n        svuint16_t out = svsel(p, in1, in2);\n        \n        svst1(pg, dst + i, out);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    uint16_t mask16 = mask & 0xFFFF;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t indices = svadd_u16_z(pg, svdup_u16(i), svindex_u16(0, 1));\n        svuint16_t mask_vec = svdup_u16(mask16);\n        svuint16_t and_result = svand_u16_z(pg, indices, mask_vec);\n        svbool_t cond = svcmpne_u16(pg, and_result, svdup_u16(0));\n        svuint16_t in1 = svld1_u16(pg, src1 + i);\n        svuint16_t in2 = svld1_u16(pg, src2 + i);\n        svuint16_t res = svsel_u16(cond, in1, in2);\n        svst1_u16(pg, dst + i, res);\n        i += svcnth();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_15_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_blend_simd(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    if (length == 0) {\n        return;\n    }\n    \n    uint32_t* src1_32 = (uint32_t*)src1;\n    uint32_t* src2_32 = (uint32_t*)src2;\n    uint32_t* dst_32 = (uint32_t*)dst;\n    size_t length_32 = length / 2;\n    size_t i32 = 0;\n    \n    while (i32 < length_32) {\n        svbool_t pg32 = svwhilelt_b32(i32, length_32);\n        svuint32_t i32_vec = svadd_n_u32_z(pg32, svindex_u32(0, 1), i32);\n        svuint32_t i0_vec = svmul_n_u32_z(pg32, i32_vec, 2);\n        svuint32_t i1_vec = svadd_n_u32_z(pg32, i0_vec, 1);\n        \n        svuint32_t masked0 = svand_n_u32_z(pg32, i0_vec, mask);\n        svuint32_t masked1 = svand_n_u32_z(pg32, i1_vec, mask);\n        svbool_t cond0 = svcmpne_n_u32(pg32, masked0, 0);\n        svbool_t cond1 = svcmpne_n_u32(pg32, masked1, 0);\n        \n        svuint32_t val1 = svld1_u32(pg32, &src1_32[i32]);\n        svuint32_t val2 = svld1_u32(pg32, &src2_32[i32]);\n        \n        svuint32_t low_mask = svdup_n_u32(0x0000FFFF);\n        svuint32_t high_mask = svdup_n_u32(0xFFFF0000);\n        svuint32_t mask_val = svorr_u32_z(pg32, \n            svand_u32_z(cond0, low_mask),\n            svand_u32_z(cond1, high_mask)\n        );\n        \n        svuint32_t not_mask_val = svnot_u32_z(pg32, mask_val);\n        svuint32_t part1 = svand_u32_z(pg32, val1, mask_val);\n        svuint32_t part2 = svand_u32_z(pg32, val2, not_mask_val);\n        svuint32_t res = svorr_u32_z(pg32, part1, part2);\n        \n        svst1_u32(pg32, &dst_32[i32], res);\n        i32 += svcntw();\n    }\n    \n    if (length & 1) {\n        size_t index = length - 1;\n        if (index & mask) {\n            dst[index] = src1[index];\n        } else {\n            dst[index] = src2[index];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t data = svld1_u32(pg, src + i);\n        svuint8_t bytes = svreinterpret_u8_u32(data);\n        svuint32_t popcnt = svdot_u32(svdup_u32(0), bytes, svdup_u8(1));\n        svst1_u32(pg, dst + i, popcnt);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t vl = svcntw();\n    size_t i = 0;\n    for (; i < length; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t x = svld1_u32(pg, src + i);\n\n        svuint32_t t0 = svlsr_u32_x(pg, x, 1);\n        t0 = svand_u32_x(pg, t0, svdup_u32(0x55555555));\n        t0 = svsub_u32_x(pg, x, t0);\n\n        svuint32_t t1 = svand_u32_x(pg, t0, svdup_u32(0x33333333));\n        svuint32_t t2 = svlsr_u32_x(pg, t0, 2);\n        t2 = svand_u32_x(pg, t2, svdup_u32(0x33333333));\n        svuint32_t t3 = svadd_u32_x(pg, t1, t2);\n\n        svuint32_t t4 = svadd_u32_x(pg, t3, svlsr_u32_x(pg, t3, 4));\n        t4 = svand_u32_x(pg, t4, svdup_u32(0x0F0F0F0F));\n\n        svuint32_t t5 = svmul_u32_x(pg, t4, svdup_u32(0x01010101));\n        svuint32_t res = svlsr_u32_x(pg, t5, 24);\n\n        svst1_u32(pg, dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    uint64_t vl = svcntw();\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t input = svld1_u32(pg, &src[i]);\n        svuint32_t popcount = svcnt_u32_z(pg, input);\n        svst1_u32(pg, &dst[i], popcount);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svuint32_t input = svld1_u32(pg, src + i);\n        svuint32_t popcount_vec = svcnt_u32_z(pg, input);\n        svst1_u32(pg, dst + i, popcount_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_16_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid population_count_simd(const uint32_t* src, uint32_t* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint8_t bytes = svreinterpret_u8_u32(vec);\n        svuint8_t byte_counts = svcnt_u8_z(svptrue_b8(), bytes);\n        svuint16_t low16 = svmovlb_u16(byte_counts);\n        svuint16_t high16 = svmovlt_u16(byte_counts);\n        svuint16_t sum16 = svadd_u16_z(svptrue_b16(), low16, high16);\n        svuint32_t low32 = svmovlb_u32(sum16);\n        svuint32_t high32 = svmovlt_u32(sum16);\n        svuint32_t total = svadd_u32_z(svptrue_b32(), low32, high32);\n        svst1_u32(pg, dst + i, total);\n        i += svcntw(pg);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    const uint64_t vl = svcntw() * 2;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t res = svqadd_u16(v1, v2);\n        svst1_u16(pg, dst + i, res);\n        i += vl;\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t res = svqadd_u16(v1, v2);\n        svst1_u16(pg, dst + i, res);\n        i += svcntp_b16(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t res = svqadd_u16_x(pg, v1, v2);\n        svst1_u16(pg, dst + i, res);\n        i += svcnth();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    uint64_t vl = svcnth();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16_u64(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t vres = svqadd_u16(v1, v2);\n        svst1_u16(pg, dst + i, vres);\n        i += vl;\n        pg = svwhilelt_b16_u64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_17_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid saturating_add_simd(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svuint16_t v1 = svld1_u16(pg, src1 + i);\n        svuint16_t v2 = svld1_u16(pg, src2 + i);\n        svuint16_t res = svqadd_u16_x(pg, v1, v2);\n        svst1_u16(pg, dst + i, res);\n        i += svcntp_b16(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    const double low_bound = -100.0;\n    const double high_bound = 100.0;\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; ) {\n            size_t current_vl = vl;\n            if (j + vl > p) {\n                current_vl = p - j;\n            }\n            svbool_t pg = svwhilelt_b64(j, p);\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                if (a_val >= low_bound && a_val <= high_bound) {\n                    svfloat64_t vb = svld1(pg, &B[k * p + j]);\n                    svbool_t pg_b = svand_z(pg, \n                                          svcmpge(pg, vb, low_bound),\n                                          svcmple(pg, vb, high_bound));\n                    acc = svmla_m(pg_b, acc, vb, a_val);\n                }\n            }\n            svst1(pg, &C[i * p + j], acc);\n            j += current_vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, p);\n            svfloat64_t acc = svdup_n_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                if (a_val >= -100.0 && a_val <= 100.0) {\n                    svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                    svbool_t b_in_range = svand_b_z(pg, \n                        svcmpge(pg, b_vec, -100.0),\n                        svcmple(pg, b_vec, 100.0)\n                    );\n                    acc = svmla_m(b_in_range, acc, b_vec, a_val);\n                }\n            }\n            svst1(pg, &C[i * p + j], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j_base = 0; j_base < p; j_base += vl) {\n            svbool_t pg = svwhilelt_b64(j_base, p);\n            svfloat64_t c_acc = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                if (a_val >= -100.0 && a_val <= 100.0) {\n                    svfloat64_t b_vec = svld1(pg, &B[k * p + j_base]);\n                    svbool_t in_range_b = svand_z(pg, \n                                        svcmpge(pg, b_vec, -100.0),\n                                        svcmple(pg, b_vec, 100.0));\n                    c_acc = svmla_f64_m(in_range_b, c_acc, svdup_f64(a_val), b_vec);\n                }\n            }\n            svst1(pg, &C[i * p + j_base], c_acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t total = m * p;\n    size_t i_total = 0;\n    unsigned int vl = svcntd();\n    svbool_t pg = svwhilelt_b64(i_total, total);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svst1(pg, C + i_total, svdup_f64(0.0));\n        i_total += vl;\n        pg = svwhilelt_b64(i_total, total);\n    }\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t k = 0; k < n; k++) {\n            double a_val = A[i * n + k];\n            if (a_val < -100.0 || a_val > 100.0) {\n                continue;\n            }\n            size_t j = 0;\n            pg = svwhilelt_b64(j, p);\n            while (svptest_any(svptrue_b64(), pg)) {\n                svfloat64_t b_vec = svld1(pg, B + k * p + j);\n                svbool_t cond_low = svcmpge(pg, b_vec, -100.0);\n                svbool_t cond_high = svcmple(pg, b_vec, 100.0);\n                svbool_t in_range = svand_b_z(pg, cond_low, cond_high);\n                svfloat64_t a_vec = svdup_f64(a_val);\n                svfloat64_t product = svmul_z(in_range, a_vec, b_vec);\n                svfloat64_t c_vec = svld1(pg, C + i * p + j);\n                c_vec = svadd_m(pg, c_vec, product);\n                svst1(pg, C + i * p + j, c_vec);\n                j += vl;\n                pg = svwhilelt_b64(j, p);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid range_matrix_mul_simd(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, p);\n            svfloat64_t acc = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                if (a_val >= -100.0 && a_val <= 100.0) {\n                    svfloat64_t b_vec = svld1(pg, &B[k * p + j]);\n                    svbool_t in_range = svand(svcmpge(pg, b_vec, -100.0), svcmple(pg, b_vec, 100.0));\n                    acc = svmla_m(in_range, acc, a_val, b_vec);\n                }\n            }\n            svst1(pg, &C[i * p + j], acc);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntd();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1_s64(pg, &A[i]);\n        svint64_t b_vec = svld1_s64(pg, &B[i]);\n        svint64_t c_vec = svadd_s64_z(pg, a_vec, b_vec);\n        svst1_s64(pg, &C[i], c_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntd();\n    for (size_t i = 0; i < total_elements; ) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t va = svld1(pg, &A[i]);\n        svint64_t vb = svld1(pg, &B[i]);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, &C[i], vc);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntd();\n    size_t i = 0;\n    \n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svint64_t a_vec = svld1(pg, A + i);\n        svint64_t b_vec = svld1(pg, B + i);\n        svint64_t c_vec = svadd_x(pg, a_vec, b_vec);\n        svst1(pg, C + i, c_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b64(index, total_elements);\n        svint64_t va = svld1_s64(pg, &A[index]);\n        svint64_t vb = svld1_s64(pg, &B[index]);\n        svint64_t vc = svadd_s64_x(pg, va, vb);\n        svst1_s64(pg, &C[index], vc);\n        index += svcntd();\n    }\n}\n```"}
{"task_id": "SimdBench_19_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_add_3d_simd(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    if (total == 0) {\n        return;\n    }\n    size_t vl = svcntd();\n    for (size_t i = 0; i < total; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, total);\n        svint64_t va = svld1(pg, A + i);\n        svint64_t vb = svld1(pg, B + i);\n        svint64_t vc = svadd_x(pg, va, vb);\n        svst1(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl = svcntw();\n    size_t index = 0;\n    while (index < length) {\n        svbool_t pg = svwhilelt_b32(index, length);\n        svfloat32_t v1 = svld1_f32(pg, src1 + index);\n        svfloat32_t v2 = svld1_f32(pg, src2 + index);\n        svfloat32_t sum = svadd_f32(v1, v2);\n        svfloat32_t res = svrintn_f32(sum);\n        svst1_f32(pg, dst + index, res);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t rounded = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, dst + i, rounded);\n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        svfloat32_t res = svadd_f32_z(pg, vec1, vec2);\n        res = svrintn_f32_z(pg, res);\n        svst1_f32(pg, dst + i, res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    uint64_t vl = svcntw();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_z(pg, v1, v2);\n        svfloat32_t res = svrintn_f32_z(pg, sum);\n        svst1_f32(pg, dst + i, res);\n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_20_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_add_round_nearest_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t i = 0;\n    const unsigned int vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, src1 + i);\n        svfloat32_t vec2 = svld1_f32(pg, src2 + i);\n        svfloat32_t sum = svadd_f32_x(pg, vec1, vec2);\n        svfloat32_t res = svrintn_f32_x(pg, sum);\n        svst1_f32(pg, dst + i, res);\n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    size_t vl;\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, length);\n    svfloat32_t neg_one = svdup_n_f32(-1.0f);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t indices = svindex_s32(index, 1);\n        svint32_t mod2 = svand_s32_z(pg, indices, 1);\n        svbool_t cond2 = svcmpeq_n_s32(pg, mod2, 0);\n        \n        svfloat32_t v1 = svld1_f32(pg, src1 + index);\n        svfloat32_t v2 = svld1_f32(pg, src2 + index);\n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_z(pg, diff);\n        svbool_t cond1 = svcmple_f32(pg, abs_diff, 50.0f);\n        \n        svbool_t cond = svand_b_z(pg, cond1, cond2);\n        svfloat32_t product = svmul_f32_z(pg, v1, v2);\n        svfloat32_t ceil_product = svrintp_f32_z(cond, product);\n        \n        svfloat32_t result = svsel_f32(cond, ceil_product, neg_one);\n        svst1_f32(pg, dst + index, result);\n        \n        index += svcntw();\n        pg = svwhilelt_b32(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    uint64_t i = 0;\n    const uint64_t vl = svcntw();\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, v1, v2));\n        svbool_t cond1 = svcmple_f32(pg, diff, svdup_n_f32(50.0f));\n        \n        uint32_t base_mod = i % 2;\n        svuint32_t step = svindex_u32(0, 1);\n        svuint32_t mod_vec = svand_u32_x(pg, svadd_n_u32_x(pg, step, base_mod), svdup_n_u32(1));\n        svbool_t cond2 = svcmpeq_u32(pg, mod_vec, svdup_n_u32(0));\n        \n        svbool_t cond = svand_b_z(pg, cond1, cond2);\n        \n        svfloat32_t prod = svmul_f32_x(pg, v1, v2);\n        svfloat32_t rounded = svrintp_f32_x(pg, prod);\n        svfloat32_t res = svsel_f32(cond, rounded, svdup_n_f32(-1.0f));\n        \n        svst1_f32(pg, dst + i, res);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svuint32_t base = svdup_u32(i);\n        svuint32_t indices = svadd_u32_x(pg, base, svindex_u32(0, 1));\n        svuint32_t mod = svand_u32_x(pg, indices, svdup_u32(1));\n        svbool_t even_mask = svcmpeq_u32(pg, mod, svdup_u32(0));\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, v1, v2));\n        svbool_t diff_mask = svcmple_f32(pg, diff, svdup_f32(50.0f));\n        svbool_t cond_mask = svand_b_z(pg, even_mask, diff_mask);\n        svfloat32_t prod = svmul_f32_x(pg, v1, v2);\n        svfloat32_t rounded = svrintp_f32_x(pg, prod);\n        svfloat32_t result = svsel_f32(cond_mask, rounded, svdup_f32(-1.0f));\n        svst1_f32(pg, dst + i, result);\n        uint64_t n = svcntp_b32(svptrue_b8(), pg);\n        i += n;\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length){\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        \n        svfloat32_t diff = svsub_f32_z(pg, v1, v2);\n        svfloat32_t abs_diff = svabs_f32_z(pg, diff);\n        svbool_t cond1 = svcmple_f32(pg, abs_diff, 50.0f);\n        \n        svuint32_t base_vec = svdup_u32(i);\n        svuint32_t step_vec = svindex_u32(0, 1);\n        svuint32_t global_indices = svadd_u32_z(pg, base_vec, step_vec);\n        svbool_t cond2 = svcmpeq_u32(pg, svand_u32_z(pg, global_indices, 1), 0);\n        \n        svbool_t combined_cond = svand_b_z(pg, cond1, cond2);\n        \n        svfloat32_t product = svmul_f32_z(combined_cond, v1, v2);\n        svfloat32_t rounded_product = svrintp_f32_z(combined_cond, product);\n        svfloat32_t default_val = svdup_n_f32(-1.0f);\n        svfloat32_t res = svsel_f32(combined_cond, rounded_product, default_val);\n        \n        svst1_f32(pg, dst + i, res);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_21_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid vector_mul_round_up_simd(const float* src1, const float* src2, float* dst, size_t length) {\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1_f32(pg, src1 + i);\n        svfloat32_t v2 = svld1_f32(pg, src2 + i);\n        svfloat32_t diff = svabs_f32_x(pg, svsub_f32_x(pg, v1, v2));\n        svint32_t vidx = svindex_s32(i, 1);\n        svint32_t vidx_low = svand_s32_x(pg, vidx, 1);\n        svbool_t even_mask = svcmpeq_s32(pg, vidx_low, 0);\n        svbool_t diff_mask = svcmple_f32(pg, diff, 50.0f);\n        svbool_t cond_mask = svand_b_z(pg, even_mask, diff_mask);\n        svfloat32_t prod = svmul_f32_x(cond_mask, v1, v2);\n        svfloat32_t rounded = svrintp_f32_x(cond_mask, prod);\n        svfloat32_t def = svdup_n_f32(-1.0f);\n        svfloat32_t res = svsel_f32(cond_mask, rounded, def);\n        svst1_f32(pg, dst + i, res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vl = svcntd();\n    svfloat64_t scalar_vec = svdup_n_f64(scalar);\n    \n    for (size_t i = 0; i < total; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, total);\n        svfloat64_t mat_vec = svld1_f64(pg, mat + i);\n        svfloat64_t res_vec = svmul_f64_z(pg, mat_vec, scalar_vec);\n        svst1_f64(pg, dst + i, res_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    size_t vl = svcntd();\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b64(index, total_elements);\n        svfloat64_t vec = svld1_f64(pg, &mat[index]);\n        svfloat64_t result = svmul_n_f64_x(pg, vec, scalar);\n        svst1_f64(pg, &dst[index], result);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = svcntd();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t mat_vec = svld1_f64(pg, mat + i);\n        svfloat64_t res_vec = svmul_n_f64_x(pg, mat_vec, scalar);\n        svst1_f64(pg, dst + i, res_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    uint64_t total_elements = (uint64_t)m * n;\n    uint64_t vl = svcntd();\n    for (uint64_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vec = svld1_f64(pg, mat + i);\n        svfloat64_t res = svmul_n_f64_z(pg, vec, scalar);\n        svst1_f64(pg, dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_22_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_scalar_mul_simd(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    svbool_t all_true = svptrue_b64();\n    svfloat64_t scalar_vec = svdup_n_f64(scalar);\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b64(index, total_elements);\n        svfloat64_t data = svld1(pg, mat + index);\n        svfloat64_t result = svmul_f64_z(pg, data, scalar_vec);\n        svst1(pg, dst + index, result);\n        index += svcntp_b64(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < m; i++) {\n        float* row_ptr = mat + i * n;\n        float sum = 0.0f;\n        size_t k = 0;\n        \n        while (k < n) {\n            svbool_t pg = svwhilelt_b32(k, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + k);\n            svfloat32_t vec_sq = svmul_f32_z(pg, vec, vec);\n            sum += svaddv_f32(pg, vec_sq);\n            k += vl;\n        }\n        \n        if (sum == 0.0f) {\n            continue;\n        }\n        \n        svfloat32_t sum_vec = svdup_n_f32(sum);\n        svfloat32_t norm_vec = svsqrt_f32_z(svptrue_b32(), sum_vec);\n        float norm = svlasta_f32(svptrue_b32(), norm_vec);\n        float inv_norm = 1.0f / norm;\n        svfloat32_t inv_norm_vec = svdup_n_f32(inv_norm);\n        \n        k = 0;\n        while (k < n) {\n            svbool_t pg = svwhilelt_b32(k, n);\n            svfloat32_t vec = svld1_f32(pg, row_ptr + k);\n            vec = svmul_f32_z(pg, vec, inv_norm_vec);\n            svst1_f32(pg, row_ptr + k, vec);\n            k += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row_ptr = mat + i * n;\n        float sq_sum = 0.0f;\n\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1_f32(pg, row_ptr + j);\n            svfloat32_t squared = svmul_f32_z(pg, data, data);\n            sq_sum += svaddv_f32(pg, squared);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        float norm = sq_sum == 0.0f ? 0.0f : sqrtf(sq_sum);\n        float inv_norm = norm == 0.0f ? 0.0f : 1.0f / norm;\n\n        j = 0;\n        pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1_f32(pg, row_ptr + j);\n            svfloat32_t normalized = svmul_f32_z(pg, data, svdup_f32(inv_norm));\n            svst1_f32(pg, row_ptr + j, normalized);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float row_sum = 0.0f;\n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n        \n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1_f32(pg, row + j);\n            svfloat32_t squared = svmul_f32_z(pg, data, data);\n            sum_vec = svadd_f32_m(pg, sum_vec, squared);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n        \n        row_sum = svaddv_f32(svptrue_b32(), sum_vec);\n        float norm = (row_sum == 0.0f) ? 1.0f : sqrtf(row_sum);\n        \n        j = 0;\n        pg = svwhilelt_b32(0, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1_f32(pg, row + j);\n            svfloat32_t norm_vec = svdup_f32(norm);\n            svfloat32_t result = svdiv_f32_z(pg, data, norm_vec);\n            svst1_f32(pg, row + j, result);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    uint64_t vl = svcntw();\n    for (size_t i = 0; i < m; i++) {\n        float *row_ptr = mat + i * n;\n        uint64_t base = 0;\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        while (base < n) {\n            svbool_t pg = svwhilelt_b32_u64(base, n);\n            svfloat32_t data = svld1(pg, row_ptr + base);\n            sum_vec = svmla_m(pg, sum_vec, data, data);\n            base += vl;\n        }\n        float total_sum = svaddv(svptrue_b32(), sum_vec);\n        float norm = sqrtf(total_sum);\n        float inv_norm = (norm == 0.0f) ? 0.0f : (1.0f / norm);\n        \n        base = 0;\n        while (base < n) {\n            svbool_t pg = svwhilelt_b32_u64(base, n);\n            svfloat32_t data = svld1(pg, row_ptr + base);\n            data = svmul_z(pg, data, svdup_f32(inv_norm));\n            svst1(pg, row_ptr + base, data);\n            base += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid matrix_normalize_rows_simd(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float sq_sum = 0.0f;\n        svbool_t pg = svwhilelt_b32(0, n);\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t vec = svld1_f32(pg, row + j);\n            svfloat32_t squared = svmul_f32_z(pg, vec, vec);\n            sum_vec = svadd_f32_m(pg, sum_vec, squared);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n\n        sq_sum = svaddv_f32(svptrue_b32(), sum_vec);\n        float norm = sqrtf(sq_sum);\n\n        if (norm != 0.0f) {\n            float inv_norm = 1.0f / norm;\n            svfloat32_t inv_norm_vec = svdup_f32(inv_norm);\n            j = 0;\n            pg = svwhilelt_b32(j, n);\n\n            while (svptest_any(svptrue_b32(), pg)) {\n                svfloat32_t vec = svld1_f32(pg, row + j);\n                svfloat32_t normalized = svmul_f32_z(pg, vec, inv_norm_vec);\n                svst1_f32(pg, row + j, normalized);\n                j += svcntw();\n                pg = svwhilelt_b32(j, n);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        while (j < p) {\n            svbool_t pg = svwhilelt_b64(j, p);\n            svfloat64_t acc = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < n; k++) {\n                double a_val = mat1[i * n + k];\n                svfloat64_t b_vec = svld1(pg, mat2 + k * p + j);\n                acc = svmla_f64_m(pg, acc, svdup_f64(a_val), b_vec);\n            }\n            \n            svfloat64_t rounded = svrintn_f64(acc);\n            svst1(pg, dst + i * p + j, rounded);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        svbool_t all_mask = svptrue_b64();\n        while (svptest_any(all_mask, svwhilelt_b64(j, p))) {\n            svbool_t pg = svwhilelt_b64(j, p);\n            svfloat64_t acc = svdup_n_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                double a_val = mat1[i * n + k];\n                svfloat64_t b_vec = svld1(pg, &mat2[k * p + j]);\n                acc = svmla_f64_m(pg, acc, svdup_n_f64(a_val), b_vec);\n            }\n            svfloat64_t rounded = svrinta_f64_z(pg, acc);\n            svst1(pg, &dst[i * p + j], rounded);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd(); // Get the number of double elements in an SVE vector\n    \n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, p); // Predicate for active lanes\n            svfloat64_t acc = svdup_f64_z(pg, 0.0); // Initialize accumulator to zero for active lanes\n            \n            for (size_t k = 0; k < n; k++) {\n                double a_val = mat1[i * n + k]; // Element from mat1 row i\n                svfloat64_t a_vec = svdup_f64(a_val); // Broadcast scalar to vector\n                svfloat64_t b_vec = svld1(pg, mat2 + k * p + j); // Load segment from mat2 row k\n                acc = svmla_f64_x(pg, acc, a_vec, b_vec); // Multiply-accumulate\n            }\n            \n            svfloat64_t rounded = svrinta_f64_x(pg, acc); // Round to nearest integer\n            svst1(pg, dst + i * p + j, rounded); // Store result to destination\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, p);\n            svfloat64_t acc0 = svdup_f64(0.0);\n            svfloat64_t acc1 = svdup_f64(0.0);\n            svfloat64_t acc2 = svdup_f64(0.0);\n            svfloat64_t acc3 = svdup_f64(0.0);\n\n            size_t k = 0;\n            for (; k + 3 < n; k += 4) {\n                double mat1_ik0 = mat1[i * n + k];\n                double mat1_ik1 = mat1[i * n + k + 1];\n                double mat1_ik2 = mat1[i * n + k + 2];\n                double mat1_ik3 = mat1[i * n + k + 3];\n\n                svfloat64_t b_vec0 = svdup_f64(mat1_ik0);\n                svfloat64_t b_vec1 = svdup_f64(mat1_ik1);\n                svfloat64_t b_vec2 = svdup_f64(mat1_ik2);\n                svfloat64_t b_vec3 = svdup_f64(mat1_ik3);\n\n                svfloat64_t a_vec0 = svld1(pg, mat2 + k * p + j);\n                svfloat64_t a_vec1 = svld1(pg, mat2 + (k + 1) * p + j);\n                svfloat64_t a_vec2 = svld1(pg, mat2 + (k + 2) * p + j);\n                svfloat64_t a_vec3 = svld1(pg, mat2 + (k + 3) * p + j);\n\n                acc0 = svmla_f64_m(pg, acc0, b_vec0, a_vec0);\n                acc1 = svmla_f64_m(pg, acc1, b_vec1, a_vec1);\n                acc2 = svmla_f64_m(pg, acc2, b_vec2, a_vec2);\n                acc3 = svmla_f64_m(pg, acc3, b_vec3, a_vec3);\n            }\n\n            acc0 = svadd_f64_m(pg, acc0, acc1);\n            acc2 = svadd_f64_m(pg, acc2, acc3);\n            acc0 = svadd_f64_m(pg, acc0, acc2);\n\n            for (; k < n; k++) {\n                double mat1_ik = mat1[i * n + k];\n                svfloat64_t b_vec = svdup_f64(mat1_ik);\n                svfloat64_t a_vec = svld1(pg, mat2 + k * p + j);\n                acc0 = svmla_f64_m(pg, acc0, b_vec, a_vec);\n            }\n\n            svfloat64_t rounded = svrinta_f64_x(pg, acc0);\n            svst1(pg, dst + i * p + j, rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_mul_round_int_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < m; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, p);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t acc = svdup_f64(0.0);\n            for (size_t k = 0; k < n; k++) {\n                double a_val = mat1[i * n + k];\n                svfloat64_t b_vec = svld1_f64(pg, mat2 + k * p + j);\n                acc = svmla_n_f64_m(pg, acc, b_vec, a_val);\n            }\n            svfloat64_t rounded = svrintn_f64_x(pg, acc);\n            svst1_f64(pg, dst + i * p + j, rounded);\n            j += vl;\n            pg = svwhilelt_b64(j, p);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    uint64_t vl = svcntw();\n    for (size_t j = 0; j < cols; j++) {\n        size_t i = 0;\n        while (i < rows) {\n            svbool_t pg = svwhilelt_b32(i, rows);\n            uint64_t active_vl = svcntp_b32(pg, pg);\n            uint64_t base_offset = (j + i * (uint64_t)cols) * sizeof(float);\n            uint64_t step = (uint64_t)cols * sizeof(float);\n            svuint64_t offsets = svindex_u64(base_offset, step);\n            svfloat32_t data = svld1_gather_u64index_f32(pg, src, offsets);\n            data = svmul_n_f32_x(pg, data, 4.0f);\n            data = svrinta_f32_x(pg, data);\n            data = svmul_n_f32_x(pg, data, 0.25f);\n            svst1_f32(pg, dst + j * rows + i, data);\n            i += active_vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl = svcntw();\n    const float four = 4.0f;\n    const float quarter = 0.25f;\n\n    for (size_t j = 0; j < cols; j++) {\n        size_t i = 0;\n        while (i < rows) {\n            svbool_t pg = svwhilelt_b32(i, rows);\n            svuint32_t row_indices = svindex_u32(i, 1);\n            svuint32_t offsets = svmul_n_u32_z(pg, row_indices, cols * sizeof(float));\n            svfloat32_t vec = svld1_gather_offset(pg, src + j, offsets);\n            \n            vec = svmul_n_f32_x(pg, vec, four);\n            vec = svrinta_f32_x(pg, vec);\n            vec = svmul_n_f32_x(pg, vec, quarter);\n            \n            svst1(pg, dst + j * rows + i, vec);\n            i += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    uint64_t vl = svcntw();\n    for (size_t j = 0; j < cols; j++) {\n        size_t i = 0;\n        while (i < rows) {\n            svbool_t pg = svwhilelt_b32(i, rows);\n            const uint8_t *src_base = (const uint8_t*)src;\n            size_t start_offset = (i * cols + j) * sizeof(float);\n            svuint32_t byte_offsets = svindex_u32(start_offset, cols * sizeof(float));\n            svfloat32_t vec = svld1_gather_u32index_f32(pg, (const float*)src_base, byte_offsets);\n            vec = svmul_n_f32_x(pg, vec, 4.0f);\n            vec = svrinta_f32_x(pg, vec);\n            vec = svmul_n_f32_x(pg, vec, 0.25f);\n            svst1_f32(pg, dst + j * rows + i, vec);\n            i += svcntp_b32(pg, pg);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < rows; i++) {\n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b32(j, cols);\n            svfloat32_t data = svld1(pg, src + i * cols + j);\n            svfloat32_t mul = svmul_f32_z(pg, data, svdup_n_f32(4.0f));\n            svfloat32_t rounded = svrintn_f32_z(pg, mul);\n            svfloat32_t result = svmul_f32_z(pg, rounded, svdup_n_f32(0.25f));\n            \n            svuint32_t col_vec = svindex_u32(j, 1);\n            svuint64_t col_vec64 = svcvt_u64_u32_z(pg, col_vec);\n            svuint64_t offsets = svmul_n_u64_z(pg, col_vec64, rows * sizeof(float));\n            offsets = svadd_n_u64_z(pg, offsets, i * sizeof(float));\n            svst1_scatter_u64index_f32(pg, dst, offsets, result);\n            j += vl;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_transpose_round_quarter_simd(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t j = 0; j < cols; j++) {\n        size_t i = 0;\n        while (i < rows) {\n            svbool_t pg = svwhilelt_b32(i, rows);\n            uint64_t n = svcntp_b32(pg, pg);\n            const float* base_src = src + i * cols + j;\n            svuint32_t indices = svindex_u32(0, 1);\n            svuint32_t byte_offsets = svmul_u32_z(pg, indices, svdup_u32(cols * sizeof(float)));\n            svfloat32_t data = svld1_gather_u32offset_f32(pg, base_src, byte_offsets);\n            svfloat32_t four_vec = svdup_f32(4.0f);\n            svfloat32_t quarter_vec = svdup_f32(0.25f);\n            data = svmul_f32_m(pg, data, four_vec);\n            data = svrinta_f32_m(pg, data);\n            data = svmul_f32_m(pg, data, quarter_vec);\n            float* base_dst = dst + j * rows + i;\n            svst1_f32(pg, base_dst, data);\n            i += n;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    uint64_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec1 = svld1_f32(pg, tensor1 + index);\n        svfloat32_t vec2 = svld1_f32(pg, tensor2 + index);\n        svfloat32_t diff = svsub_f32_x(pg, vec1, vec2);\n        svfloat32_t res = svrintz_f32_x(pg, diff);\n        svst1_f32(pg, dst + index, res);\n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    const size_t vl = svcntw();\n    \n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svfloat32_t vec1 = svld1(pg, tensor1 + i);\n        svfloat32_t vec2 = svld1(pg, tensor2 + i);\n        svfloat32_t diff = svsub_z(pg, vec1, vec2);\n        svfloat32_t res = svrintz_f32_z(pg, diff);\n        svst1(pg, dst + i, res);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t t1 = svld1(pg, tensor1 + index);\n        svfloat32_t t2 = svld1(pg, tensor2 + index);\n        svfloat32_t diff = svsub_x(pg, t1, t2);\n        svfloat32_t result = svrintz_f32_x(pg, diff);\n        svst1(pg, dst + index, result);\n        index += vl;\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1_f32(pg, tensor1 + index);\n        svfloat32_t v2 = svld1_f32(pg, tensor2 + index);\n        svfloat32_t diff = svsub_f32_x(pg, v1, v2);\n        svfloat32_t res = svrintz_f32_x(pg, diff);\n        svst1_f32(pg, dst + index, res);\n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_26_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor3d_sub_round_zero_simd(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    if (total == 0) {\n        return;\n    }\n    size_t vl = svcntw();\n    for (size_t i = 0; i < total; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total);\n        svfloat32_t v1 = svld1_f32(pg, tensor1 + i);\n        svfloat32_t v2 = svld1_f32(pg, tensor2 + i);\n        svfloat32_t diff = svsub_f32_x(pg, v1, v2);\n        svfloat32_t res = svrintz_f32_x(pg, diff);\n        svst1_f32(pg, dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = svcntd();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t v1 = svld1(pg, mat1 + i);\n        svfloat64_t v2 = svld1(pg, mat2 + i);\n        svfloat64_t res = svmul_f64_z(pg, v1, v2);\n        svst1(pg, dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t i = 0;\n    while (i < total) {\n        svbool_t pg = svwhilelt_b64(i, total);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[i]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[i]);\n        svfloat64_t res = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[i], res);\n        i += svcntp_b64(svptrue_b64(), pg);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t vl = svcntd();\n    size_t index = 0;\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b64(index, total_elements);\n        svfloat64_t v1 = svld1_f64(pg, &mat1[index]);\n        svfloat64_t v2 = svld1_f64(pg, &mat2[index]);\n        svfloat64_t res = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, &dst[index], res);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b64(index, total_elements);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec1 = svld1_f64(pg, &mat1[index]);\n        svfloat64_t vec2 = svld1_f64(pg, &mat2[index]);\n        svfloat64_t res = svmul_f64_z(pg, vec1, vec2);\n        svst1_f64(pg, &dst[index], res);\n        index += svcntd();\n        pg = svwhilelt_b64(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_27_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_hadamard_product_simd(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    size_t vl = svcntd();\n    size_t i = 0;\n\n    while (i + vl <= total) {\n        svfloat64_t v1 = svld1_f64(svptrue_b64(), mat1 + i);\n        svfloat64_t v2 = svld1_f64(svptrue_b64(), mat2 + i);\n        svfloat64_t res = svmul_f64_z(svptrue_b64(), v1, v2);\n        svst1_f64(svptrue_b64(), dst + i, res);\n        i += vl;\n    }\n\n    if (i < total) {\n        svbool_t pg = svwhilelt_b64(i, total);\n        svfloat64_t v1 = svld1_f64(pg, mat1 + i);\n        svfloat64_t v2 = svld1_f64(pg, mat2 + i);\n        svfloat64_t res = svmul_f64_z(pg, v1, v2);\n        svst1_f64(pg, dst + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svcntw();\n    svbool_t all_true = svptrue_b32();\n\n    for (size_t i = 0; i < m; i++) {\n        const float* row_start = mat + i * n;\n        svfloat32_t sum_vec = svdup_f32(0.0f);\n        size_t j = 0;\n\n        for (; j + vl <= n; j += vl) {\n            svfloat32_t row_segment = svld1(all_true, row_start + j);\n            svfloat32_t vec_segment = svld1(all_true, vec + j);\n            sum_vec = svmla_f32_x(all_true, sum_vec, row_segment, vec_segment);\n        }\n\n        if (j < n) {\n            svbool_t partial_pred = svwhilelt_b32(j, n);\n            svfloat32_t row_segment = svld1(partial_pred, row_start + j);\n            svfloat32_t vec_segment = svld1(partial_pred, vec + j);\n            sum_vec = svmla_f32_x(partial_pred, sum_vec, row_segment, vec_segment);\n        }\n\n        dst[i] = svaddv(all_true, sum_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < m; i++) {\n        const float* row_ptr = mat + i * n;\n        svfloat32_t sum_vec = svdup_n_f32(0.0f);\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t row_segment = svld1(pg, row_ptr + j);\n            svfloat32_t vec_segment = svld1(pg, vec + j);\n            sum_vec = svmla_m(pg, sum_vec, row_segment, vec_segment);\n            j += vl;\n            pg = svwhilelt_b32(j, n);\n        }\n        dst[i] = svaddv(svptrue_b32(), sum_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svcntw();\n    svbool_t all_true = svptrue_b32();\n\n    for (size_t i = 0; i < m; i++) {\n        const float* row_ptr = mat + i * n;\n        svfloat32_t acc = svdup_n_f32(0.0f);\n\n        for (size_t j = 0; j < n; j += vl) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t mat_seg = svld1(pg, row_ptr + j);\n            svfloat32_t vec_seg = svld1(pg, vec + j);\n            svfloat32_t prod = svmul_z(pg, mat_seg, vec_seg);\n            acc = svadd_m(pg, acc, prod);\n        }\n\n        dst[i] = svaddv(all_true, acc);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t acc = svdup_n_f32(0.0f);\n        size_t j = 0;\n        while (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svfloat32_t mat_vec = svld1(pg, mat + i * n + j);\n            svfloat32_t vec_vec = svld1(pg, vec + j);\n            acc = svmla_m(pg, acc, mat_vec, vec_vec);\n            j += vl;\n        }\n        dst[i] = svaddv(svptrue_b32(), acc);\n    }\n}\n```"}
{"task_id": "SimdBench_28_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_vector_mul_simd(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < m; i++) {\n        svfloat32_t acc = svdup_n_f32(0.0f);\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        do {\n            svfloat32_t mat_vec = svld1_f32(pg, &mat[i * n + j]);\n            svfloat32_t vec_vec = svld1_f32(pg, &vec[j]);\n            acc = svmla_f32_m(pg, acc, mat_vec, vec_vec);\n            j += vl;\n            pg = svwhilelt_b32(j, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        dst[i] = svaddv_f32(svptrue_b32(), acc);\n    }\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    if (total_elements == 0) {\n        return 0.0;\n    }\n    \n    size_t vl = svcntd();\n    svfloat64_t vsum = svdup_f64(0.0);\n    size_t index = 0;\n    \n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b64(index, total_elements);\n        svfloat64_t input = svld1(pg, mat + index);\n        vsum = svadd_m(pg, vsum, input);\n        index += vl;\n    }\n    \n    double total_sum = svaddv(svptrue_b64(), vsum);\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    double total_sum = 0.0;\n    uint64_t index = 0;\n    svfloat64_t vec_sum = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(index, total_elements);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1_f64(pg, &mat[index]);\n        vec_sum = svadd_f64_m(pg, vec_sum, vec);\n        index += svcntd();\n        pg = svwhilelt_b64(index, total_elements);\n    }\n    \n    total_sum = svaddv_f64(svptrue_b64(), vec_sum);\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    uint64_t total_elements = m * n;\n    if (total_elements == 0) {\n        return 0.0;\n    }\n\n    uint64_t i = 0;\n    svbool_t all_true = svptrue_b64();\n    svfloat64_t vsum = svdup_f64(0.0);\n    size_t vl = svcntd();\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b64(i, total_elements);\n        svfloat64_t vdata = svld1_f64(pg, mat + i);\n        vsum = svadd_f64_m(pg, vsum, vdata);\n        i += vl;\n    }\n\n    double total_sum = svaddv_f64(all_true, vsum);\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    uint64_t total_elements = m * n;\n    if (total_elements == 0) {\n        return 0.0;\n    }\n\n    uint64_t vl = svcntd();\n    uint64_t i = 0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(i, total_elements);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t data = svld1(pg, mat + i);\n        sum_vec = svadd_m(pg, sum_vec, sum_vec, data);\n        i += vl;\n        pg = svwhilelt_b64(i, total_elements);\n    }\n\n    double total_sum = svaddv(svptrue_b64(), sum_vec);\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_29_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble matrix_average_simd(const double* mat, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    if (total_elements == 0) {\n        return 0.0;\n    }\n    size_t len = total_elements;\n    size_t i = 0;\n    size_t vl = svcntd();\n    svbool_t pg = svwhilelt_b64(i, len);\n    svfloat64_t accum = svdup_f64(0.0);\n\n    while (i < len) {\n        svfloat64_t vec = svld1(pg, mat + i);\n        accum = svadd_m(pg, accum, vec);\n        i += vl;\n        pg = svwhilelt_b64(i, len);\n    }\n\n    double total_sum = svaddv(svptrue_b64(), accum);\n    return total_sum / (double)total_elements;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    if (cols == 0) \n        return true;\n\n    uint64_t vl = svcntw();\n\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        bool asc = directions[i];\n\n        if (cols == 1) \n            continue;\n\n        uint64_t n_pairs = cols - 1;\n        uint64_t index = 0;\n\n        while (index < n_pairs) {\n            svbool_t pg = svwhilelt_b32(index, n_pairs);\n            svint32_t v1 = svld1(pg, row_ptr + index);\n            svint32_t v2 = svld1(pg, row_ptr + index + 1);\n\n            svbool_t fail;\n            if (asc) {\n                fail = svcmpgt(pg, v1, v2);\n            } else {\n                fail = svcmplt(pg, v1, v2);\n            }\n\n            if (svptest_any(pg, fail)) {\n                return false;\n            }\n\n            index += vl;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        bool dir = directions[i];\n        \n        if (cols <= 1) \n            continue;\n        \n        size_t j = 0;\n        size_t limit = cols - 1;\n        \n        while (j < limit) {\n            svbool_t pg = svwhilelt_b32(j, limit);\n            uint64_t n = svcntp_b32(pg, pg);\n            if (n == 0) break;\n            \n            svint32_t current = svld1(pg, row_ptr + j);\n            svint32_t next = svld1(pg, row_ptr + j + 1);\n            \n            svbool_t cmp;\n            if (dir) {\n                cmp = svcmplt(pg, next, current);\n            } else {\n                cmp = svcmplt(pg, current, next);\n            }\n            \n            if (svcntp_b32(svptrue_b32(), cmp) != 0) {\n                return false;\n            }\n            \n            j += n;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_ptr = matrix + i * cols;\n        bool dir = directions[i];\n        size_t num_pairs = cols - 1;\n        \n        if (num_pairs == 0) \n            continue;\n\n        size_t j = 0;\n        while (j < num_pairs) {\n            svbool_t pg = svwhilelt_b32(j, num_pairs);\n            svint32_t vec1 = svld1(pg, row_ptr + j);\n            svint32_t vec2 = svld1(pg, row_ptr + j + 1);\n            \n            svbool_t mask;\n            if (dir) {\n                mask = svcmple_s32(pg, vec1, vec2);\n            } else {\n                mask = svcmpge_s32(pg, vec1, vec2);\n            }\n            \n            if (svptest_any(svptrue_b8(), svbic_b_z(svptrue_b8(), pg, mask))) {\n                return false;\n            }\n            \n            j += svcntw();\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row_start = matrix + i * cols;\n        bool dir = directions[i];\n        size_t num_pairs = cols - 1;\n        \n        if (num_pairs == 0) \n            continue;\n\n        if (dir) {\n            size_t j = 0;\n            while (j < num_pairs) {\n                svbool_t pg = svwhilelt_b32(j, num_pairs);\n                svint32_t v1 = svld1(pg, row_start + j);\n                svint32_t v2 = svld1(pg, row_start + j + 1);\n                svbool_t cmp = svcmple(pg, v1, v2);\n                if (svptest_any(pg, svnot_b_z(pg, cmp))) \n                    return false;\n                j += svcntp_b32(pg, pg);\n            }\n        } else {\n            size_t j = 0;\n            while (j < num_pairs) {\n                svbool_t pg = svwhilelt_b32(j, num_pairs);\n                svint32_t v1 = svld1(pg, row_start + j);\n                svint32_t v2 = svld1(pg, row_start + j + 1);\n                svbool_t cmp = svcmpge(pg, v1, v2);\n                if (svptest_any(pg, svnot_b_z(pg, cmp))) \n                    return false;\n                j += svcntp_b32(pg, pg);\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_sorted_verify_simd(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    if (cols == 0 || rows == 0) \n        return true;\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_ptr = matrix + i * cols;\n        bool dir = directions[i];\n\n        if (cols == 1) \n            continue;\n\n        size_t j = 0;\n        svbool_t all_true = svptrue_b32();\n        if (dir) {\n            while (j < cols - 1) {\n                svbool_t pg = svwhilelt_b32(j, cols - 1);\n                svint32_t current = svld1(pg, row_ptr + j);\n                svint32_t next = svld1(pg, row_ptr + j + 1);\n                svbool_t cmp = svcmple(pg, current, next);\n                if (svptest_any(pg, svnot_b_z(pg, cmp))) \n                    return false;\n                j += svcntw();\n            }\n        } else {\n            while (j < cols - 1) {\n                svbool_t pg = svwhilelt_b32(j, cols - 1);\n                svint32_t current = svld1(pg, row_ptr + j);\n                svint32_t next = svld1(pg, row_ptr + j + 1);\n                svbool_t cmp = svcmpge(pg, current, next);\n                if (svptest_any(pg, svnot_b_z(pg, cmp))) \n                    return false;\n                j += svcntw();\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    float base_float = (float)base;\n    int32_t base_int32 = (int32_t)base;\n    \n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t vsrc = svld1_s16(pg, src + i);\n        svfloat32_t vsrc_f32 = svcvt_f32_s16_z(pg, vsrc);\n        svfloat32_t vbase_f32 = svdup_n_f32(base_float);\n        svfloat32_t vquotient_f32 = svdiv_f32_z(pg, vsrc_f32, vbase_f32);\n        svfloat32_t vfloor_f32 = svfloor_f32_z(pg, vquotient_f32);\n        svint32_t vfloor_s32 = svcvt_s32_f32_z(pg, vfloor_f32);\n        svint32_t vresult_s32 = svmul_s32_z(pg, vfloor_s32, svdup_n_s32(base_int32));\n        svint16_t vresult = svcvt_s16_s32_z(pg, vresult_s32);\n        svst1_s16(pg, dst + i, vresult);\n        \n        i += svcnth();\n        pg = svwhilelt_b16(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    if (length == 0) return;\n    float base_f = (float)base;\n    svint16_t base_vec = svdup_n_s16((int16_t)base);\n    uint64_t vl = svcnth();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    do {\n        svint16_t src_vec = svld1_s16(pg, src + i);\n        svfloat32_t src_f32 = svcvt_f32_s16_z(pg, src_vec);\n        svfloat32_t base_f32 = svdup_f32_z(pg, base_f);\n        svfloat32_t quot_f32 = svdiv_f32_z(pg, src_f32, base_f32);\n        svfloat32_t floor_f32 = svrintm_f32_z(pg, quot_f32);\n        svint32_t floor_i32 = svcvt_s32_f32_z(pg, floor_f32);\n        svint16_t floor_i16 = svqxtnb_s32(floor_i32);\n        svint16_t res_vec = svmul_s16_z(pg, floor_i16, base_vec);\n        svst1_s16(pg, dst + i, res_vec);\n        i += vl;\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    float base_f = (float)base;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svint16_t x_vec = svld1_s16(pg, src + i);\n        svfloat32_t x_f32 = svcvt_f32_s16_x(pg, x_vec);\n        svfloat32_t base_vec_f32 = svdup_n_f32(base_f);\n        svfloat32_t quot_f32 = svdiv_f32_x(pg, x_f32, base_vec_f32);\n        svfloat32_t floor_quot_f32 = svrintm_f32_x(pg, quot_f32);\n        svint32_t floor_quot_i32 = svcvt_s32_f32_x(pg, floor_quot_f32);\n        svint32_t multiple_i32 = svmul_s32_x(pg, floor_quot_i32, svdup_n_s32((int32_t)base));\n        svint16_t multiple_i16 = svcvt_s16_s32_x(pg, multiple_i32);\n        svst1_s16(pg, dst + i, multiple_i16);\n        i += svcnth();\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    size_t i = 0;\n    float base_f = (float)base;\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svint16_t data = svld1_s16(pg, &src[i]);\n        \n        svint32_t data_even = svunpklo_s32(data);\n        svint32_t data_odd = svunpkhi_s32(data);\n        \n        svbool_t pg_even = svunpklo_b16(pg);\n        svbool_t pg_odd = svunpkhi_b16(pg);\n        \n        svfloat32_t data_even_f32 = svcvt_f32_s32_z(pg_even, data_even);\n        svfloat32_t data_odd_f32 = svcvt_f32_s32_z(pg_odd, data_odd);\n        \n        svfloat32_t base_vec_even = svdup_n_f32_z(pg_even, base_f);\n        svfloat32_t base_vec_odd = svdup_n_f32_z(pg_odd, base_f);\n        \n        svfloat32_t quotient_even = svrintm_f32(svdiv_f32_z(pg_even, data_even_f32, base_vec_even));\n        svfloat32_t quotient_odd = svrintm_f32(svdiv_f32_z(pg_odd, data_odd_f32, base_vec_odd));\n        \n        svfloat32_t res_even_f32 = svmul_f32_z(pg_even, quotient_even, base_vec_even);\n        svfloat32_t res_odd_f32 = svmul_f32_z(pg_odd, quotient_odd, base_vec_odd);\n        \n        svint32_t res_even_i32 = svcvt_s32_f32_z(pg_even, res_even_f32);\n        svint32_t res_odd_i32 = svcvt_s32_f32_z(pg_odd, res_odd_f32);\n        \n        svint16_t res_narrow = svqxtnb_s32(res_even_i32);\n        res_narrow = svqxtnt_s32(res_narrow, res_odd_i32);\n        \n        svst1_s16(pg, &dst[i], res_narrow);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_31_SVE", "completion": "To solve this problem, we need to compute, for each element in a source array, the nearest integer that is a multiple of a given base and is no greater than the element itself. The solution must leverage Arm's Scalable Vector Extension (SVE) intrinsics for parallelism.\n\n### Approach\n1. **Problem Analysis**: For each element in the source array, we need to find the largest multiple of the base that is less than or equal to the element. This involves:\n   - Handling both positive and negative numbers correctly. For negative numbers, standard integer division truncates towards zero, which might not yield the correct result. Instead, we need floor division.\n   - Efficiently processing the array in parallel using SVE intrinsics.\n\n2. **Key Insight**: The floor division can be achieved by adjusting negative numbers before division. Specifically:\n   - For negative numbers, subtract `(base - 1)` before division to ensure the result is rounded towards negative infinity.\n   - For non-negative numbers, no adjustment is needed.\n\n3. **Algorithm Selection**:\n   - **Adjustment**: For each element, if it is negative, adjust it by subtracting `(base - 1)`.\n   - **Division and Multiplication**: Perform integer division by the base on the adjusted value, then multiply the quotient by the base to get the nearest multiple.\n\n4. **SVE Implementation**:\n   - **Vector Processing**: Process the array in chunks using SVE vectors. For each chunk:\n     - Load elements into a vector.\n     - Split the vector into two parts (low and high) to handle 16-bit elements by promoting them to 32-bit for division (since SVE supports 32-bit integer division).\n     - Adjust negative elements in both parts.\n     - Perform division and multiplication to compute the result.\n     - Narrow the results back to 16-bit and store them.\n\n### Solution Code\n```c\n#include <arm_sve.h>\n\nvoid nearest_multiple_simd(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    if (length == 0) {\n        return;\n    }\n\n    int32_t base32_scalar = (int32_t)base;\n    size_t i = 0;\n    size_t vl = svcntb() / 2;\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b16(i, length);\n        svint16_t x16 = svld1_s16(pg, src + i);\n\n        svint32_t x32_lo = svsxtw_s32_z(svunpklo_b16(pg), svunpklo_s16(x16));\n        svint32_t x32_hi = svsxtw_s32_z(svunpkhi_b16(pg), svunpkhi_s16(x16));\n\n        svbool_t pg_lo = svunpklo_b16(pg);\n        svbool_t pg_hi = svunpkhi_b16(pg);\n\n        svint32_t base_vec = svdup_n_s32(base32_scalar);\n        svint32_t base_minus_one = svsub_n_s32_x(svptrue_b32(), base_vec, 1);\n\n        svbool_t neg_lo = svcmplt_s32(pg_lo, x32_lo, 0);\n        svint32_t adj_lo = svsel_s32(neg_lo, base_minus_one, svdup_n_s32(0));\n        svint32_t adjusted_lo = svsub_s32_x(pg_lo, x32_lo, adj_lo);\n\n        svbool_t neg_hi = svcmplt_s32(pg_hi, x32_hi, 0);\n        svint32_t adj_hi = svsel_s32(neg_hi, base_minus_one, svdup_n_s32(0));\n        svint32_t adjusted_hi = svsub_s32_x(pg_hi, x32_hi, adj_hi);\n\n        svint32_t q_lo = svdiv_s32_x(pg_lo, adjusted_lo, base_vec);\n        svint32_t res_lo = svmul_s32_x(pg_lo, q_lo, base_vec);\n\n        svint32_t q_hi = svdiv_s32_x(pg_hi, adjusted_hi, base_vec);\n        svint32_t res_hi = svmul_s32_x(pg_hi, q_hi, base_vec);\n\n        svint16_t res16 = svqxtnt_s32(svqxtnb_s32(res_lo), res_hi);\n\n        svst1_s16(pg, dst + i, res16);\n\n        i += vl;\n    }\n}\n```\n\n### Explanation\n1. **Initialization**: The function starts by checking if the input array is empty. If not, it initializes the base value as a 32-bit scalar and sets up the loop to process the array in chunks.\n2. **Vector Processing**:\n   - **Predicate Setup**: For each iteration, a predicate (`pg`) is created to handle active elements within the current chunk.\n   - **Loading Data**: The source data is loaded into a 16-bit vector (`x16`).\n   - **Splitting and Promotion**: The 16-bit vector is split into two 32-bit vectors (`x32_lo` and `x32_hi`), each handling half of the elements.\n3. **Adjustment and Calculation**:\n   - **Adjustment for Negatives**: For elements in both low and high parts, if an element is negative, it is adjusted by subtracting `(base - 1)` to ensure correct floor division.\n   - **Division and Multiplication**: The adjusted values are divided by the base, and the quotient is multiplied by the base to get the nearest multiple.\n4. **Result Handling**:\n   - **Narrowing Results**: The results from the 32-bit vectors are narrowed back to 16-bit and combined into a single vector (`res16`).\n   - **Storing Results**: The result vector is stored back into the destination array.\n5. **Loop Update**: The loop index is incremented by the number of elements processed in each iteration (determined by the hardware's vector length).\n\nThis approach efficiently processes the array in parallel using SVE intrinsics, handling both positive and negative values correctly to compute the required nearest multiples."}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        const double* row_ptr = matrix + r * cols;\n        size_t j = 0;\n        bool match = true;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t row_data = svld1(pg, row_ptr + j);\n            svfloat64_t vec_data = svld1(pg, vector + j);\n            svbool_t cmp = svcmpeq(pg, row_data, vec_data);\n            uint64_t n_lanes = svcntp_b64(pg, pg);\n            uint64_t n_matches = svcntp_b64(pg, cmp);\n            if (n_lanes != n_matches) {\n                match = false;\n                break;\n            }\n            j += n_lanes;\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = svcntd();\n    for (size_t r = 0; r < rows; r++) {\n        const double* row_ptr = matrix + r * cols;\n        size_t j = 0;\n        bool match = true;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t row_vec = svld1(pg, row_ptr + j);\n            svfloat64_t vec_vec = svld1(pg, vector + j);\n            svbool_t mismatch = svcmpne(pg, row_vec, vec_vec);\n            if (svptest_any(pg, mismatch)) {\n                match = false;\n                break;\n            }\n            j += vl;\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        size_t base = 0;\n        bool match = true;\n        svbool_t pg = svwhilelt_b64(base, cols);\n        \n        do {\n            svfloat64_t row_vec = svld1(pg, row_ptr + base);\n            svfloat64_t vec_vec = svld1(pg, vector + base);\n            svbool_t neq = svcmpne(pg, row_vec, vec_vec);\n            \n            if (svptest_any(pg, neq)) {\n                match = false;\n                break;\n            }\n            \n            base += vl;\n            pg = svwhilelt_b64(base, cols);\n        } while (svptest_any(svptrue_b64(), pg));\n        \n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    if (cols == 0) {\n        return false;\n    }\n\n    size_t row_stride = cols;\n    uint64_t vl = svcntd();\n    svbool_t all_true = svptrue_b64();\n\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * row_stride;\n        size_t col_index = 0;\n        bool row_match = true;\n\n        while (col_index < cols) {\n            svbool_t pg = svwhilelt_b64(col_index, cols);\n            svfloat64_t row_vec = svld1(pg, row_ptr + col_index);\n            svfloat64_t vec_vec = svld1(pg, vector + col_index);\n            svbool_t cmp = svcmpeq(pg, row_vec, vec_vec);\n            if (svptest_any(all_true, svnot_b_z(all_true, cmp))) {\n                row_match = false;\n                break;\n            }\n            col_index += vl;\n        }\n\n        if (row_match) {\n            return true;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_32_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_has_row_simd(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t r = 0; r < rows; r++) {\n        const double* row_ptr = matrix + r * cols;\n        size_t j = 0;\n        bool match = true;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t row_vec = svld1(pg, row_ptr + j);\n            svfloat64_t vec_vec = svld1(pg, vector + j);\n            svbool_t mismatch = svcmpne(pg, row_vec, vec_vec);\n            \n            if (svptest_any(pg, mismatch)) {\n                match = false;\n                break;\n            }\n            j += svcntd();\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```c\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t count = 0;\n\n    while (i < total) {\n        svbool_t pg = svwhilelt_b8(i, total);\n        svuint8_t a_vec = svld1_u8(pg, A + i);\n        svuint8_t b_vec = svld1_u8(pg, B + i);\n        svbool_t cmp = svcmpeq_u8(pg, a_vec, b_vec);\n        count += svcntp_b8(pg, cmp);\n        i += svcntp_b8(pg, pg);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t total_count = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n        svuint8_t a_vec = svld1(pg, A + i);\n        svuint8_t b_vec = svld1(pg, B + i);\n        svbool_t cmp = svcmpeq(pg, a_vec, b_vec);\n        total_count += svcntp_b8(pg, cmp);\n        i += svcntb();\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    if (total_elements == 0) \n        return 0;\n\n    uint64_t vl = svcntb();\n    size_t i = 0;\n    size_t count = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n        svuint8_t va = svld1(pg, A + i);\n        svuint8_t vb = svld1(pg, B + i);\n        svbool_t cmp = svcmpeq(pg, va, vb);\n        count += svcntp_b8(pg, cmp);\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    size_t index = 0;\n    \n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b8(index, total_elements);\n        svuint8_t a_vec = svld1_u8(pg, A + index);\n        svuint8_t b_vec = svld1_u8(pg, B + index);\n        svbool_t cmp = svcmpeq_u8(pg, a_vec, b_vec);\n        count += svcntp_b8(pg, cmp);\n        index += svcntb();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_33_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nsize_t tensor_4d_equal_count_simd(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t i = 0;\n    size_t count = 0;\n\n    while (i < total_elements) {\n        svbool_t pg = svwhilelt_b8(i, total_elements);\n        svuint8_t va = svld1_u8(pg, A + i);\n        svuint8_t vb = svld1_u8(pg, B + i);\n        svbool_t cmp = svcmpeq_u8(pg, va, vb);\n        count += svcntp_b8(pg, cmp);\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    unsigned long vl = svcntd();\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        svint64_t x_vec = svld1_s64(pg, &x[i]);\n        svint64_t y_vec = svld1_s64(pg, &y[i]);\n        svint64_t mul_vec = svmul_n_s64_x(pg, x_vec, a);\n        svint64_t abs_vec = svabs_s64_x(pg, y_vec);\n        svint64_t res = svsub_s64_x(pg, abs_vec, mul_vec);\n        svst1_s64(pg, &y[i], res);\n        i += vl;\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t x_vec = svld1_s64(pg, &x[i]);\n        svint64_t y_vec = svld1_s64(pg, &y[i]);\n        svint64_t ax = svmul_n_s64_z(pg, x_vec, a);\n        svint64_t abs_y = svabs_s64_z(pg, y_vec);\n        svint64_t res = svsub_s64_z(pg, abs_y, ax);\n        svst1_s64(pg, &y[i], res);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    size_t vl = svcntd();\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t x_vec = svld1_s64(pg, x + i);\n        svint64_t y_vec = svld1_s64(pg, y + i);\n        svint64_t product = svmul_n_s64_z(pg, x_vec, a);\n        svint64_t abs_y = svabs_s64_z(pg, y_vec);\n        svint64_t result = svsub_s64_z(pg, abs_y, product);\n        svst1_s64(pg, y + i, result);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t vl = svcntd();\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b64(index, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svint64_t x_vec = svld1_s64(pg, x + index);\n        svint64_t y_vec = svld1_s64(pg, y + index);\n        svint64_t a_vec = svdup_s64(a);\n        svint64_t prod_vec = svmul_s64_z(pg, a_vec, x_vec);\n        svint64_t abs_vec = svabs_s64_z(pg, y_vec);\n        svint64_t res_vec = svsub_s64_z(pg, abs_vec, prod_vec);\n        svst1_s64(pg, y + index, res_vec);\n        index += vl;\n        pg = svwhilelt_b64(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_34_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid axm_abs_simd(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        svint64_t x_vec = svld1_s64(pg, &x[i]);\n        svint64_t y_vec = svld1_s64(pg, &y[i]);\n        svint64_t abs_y = svabs_s64_z(pg, y_vec);\n        svint64_t ax = svmul_n_s64_z(pg, x_vec, a);\n        svint64_t res = svsub_s64_z(pg, abs_y, ax);\n        svst1_s64(pg, &y[i], res);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    int16_t first = vec[0];\n    svint16_t min_vec = svdup_n_s16(first);\n    svint16_t max_vec = svdup_n_s16(first);\n    \n    size_t index = 0;\n    svbool_t pg = svwhilelt_b16(index, length);\n    \n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1(pg, vec + index);\n        min_vec = svmin_m(pg, min_vec, data);\n        max_vec = svmax_m(pg, max_vec, data);\n        index += svcnth();\n        pg = svwhilelt_b16(index, length);\n    }\n    \n    result.min_num = svminv(svptrue_b16(), min_vec);\n    result.max_num = svmaxv(svptrue_b16(), max_vec);\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    uint64_t vl = svcntb() / sizeof(int16_t);\n    svint16_t minv = svdup_n_s16(SHRT_MAX);\n    svint16_t maxv = svdup_n_s16(SHRT_MIN);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    do {\n        svint16_t data = svld1_s16(pg, vec + i);\n        minv = svmin_m(pg, minv, data);\n        maxv = svmax_m(pg, maxv, data);\n        i += vl;\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n\n    int16_t min_val = svminv_s16(svptrue_b16(), minv);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), maxv);\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    svint16_t min_vec = svdup_n_s16(INT16_MAX);\n    svint16_t max_vec = svdup_n_s16(INT16_MIN);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    do {\n        svint16_t data = svld1_s16(pg, vec + i);\n        min_vec = svmin_s16_m(pg, min_vec, data);\n        max_vec = svmax_s16_m(pg, max_vec, data);\n        i += svcntp_b16(pg, pg);\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n    \n    int16_t min_val = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), max_vec);\n    \n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stddef.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    int16_t first = vec[0];\n    svint16_t min_vec = svdup_n_s16(first);\n    svint16_t max_vec = svdup_n_s16(first);\n    \n    uint64_t i = 0;\n    uint64_t vl = svcnth();\n    svbool_t pg = svwhilelt_b16(i, length);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t current_vec = svld1_s16(pg, vec + i);\n        min_vec = svmin_m(pg, min_vec, min_vec, current_vec);\n        max_vec = svmax_m(pg, max_vec, max_vec, current_vec);\n        i += vl;\n        pg = svwhilelt_b16(i, length);\n    }\n    \n    int16_t min_val = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), max_vec);\n    \n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <limits.h>\n\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair_simd(const int16_t* vec, size_t length) {\n    uint64_t vl = svcntb() / sizeof(int16_t);\n    svint16_t min_vec = svdup_s16(SHRT_MAX);\n    svint16_t max_vec = svdup_s16(SHRT_MIN);\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, length);\n    do {\n        svint16_t data = svld1_s16(pg, vec + i);\n        min_vec = svmin_s16_x(pg, min_vec, data);\n        max_vec = svmax_s16_x(pg, max_vec, data);\n        i += vl;\n        pg = svwhilelt_b16(i, length);\n    } while (svptest_any(svptrue_b16(), pg));\n\n    int16_t min_val = svminv_s16(svptrue_b16(), min_vec);\n    int16_t max_val = svmaxv_s16(svptrue_b16(), max_vec);\n\n    MinMaxPair result;\n    result.min_num = min_val;\n    result.max_num = max_val;\n    return result;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    if (cols == 1) {\n        return true;\n    }\n    \n    uint64_t vl = svcntw();\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        size_t j = 0;\n        bool row_ok = true;\n        while (j < cols - 1) {\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n            svint32_t current = svld1(pg, row_ptr + j);\n            svint32_t next = svld1(pg, row_ptr + j + 1);\n            svbool_t cmp = svcmplt(pg, current, next);\n            svbool_t fail = svnot_b_z(pg, cmp);\n            if (svptest_any(pg, fail)) {\n                row_ok = false;\n                break;\n            }\n            j += vl;\n        }\n        if (!row_ok) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    size_t num_pairs = cols - 1;\n    if (num_pairs == 0) {\n        return true;\n    }\n\n    for (size_t r = 0; r < rows; r++) {\n        const int* row_start = matrix + r * cols;\n        size_t i = 0;\n        bool row_valid = true;\n\n        while (i < num_pairs) {\n            svbool_t pg = svwhilelt_b32(i, num_pairs);\n            svint32_t current_vec = svld1(pg, row_start + i);\n            svint32_t next_vec = svld1(pg, row_start + i + 1);\n            \n            svbool_t cmp_ge = svcmpge(pg, current_vec, next_vec);\n            if (svptest_any(pg, cmp_ge)) {\n                row_valid = false;\n                break;\n            }\n            i += svcntw();\n        }\n\n        if (!row_valid) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    size_t vl = svcntw();\n    \n    for (size_t r = 0; r < rows; r++) {\n        const int* row_ptr = matrix + r * cols;\n        size_t n_pairs = cols - 1;\n        \n        if (n_pairs == 0) {\n            continue;\n        }\n        \n        size_t j = 0;\n        while (j < n_pairs) {\n            svbool_t pg = svwhilelt_b32(j, n_pairs);\n            svint32_t v1 = svld1(pg, row_ptr + j);\n            svint32_t v2 = svld1(pg, row_ptr + j + 1);\n            svbool_t fail_pg = svcmpge(pg, v1, v2);\n            \n            if (svptest_any(pg, fail_pg)) {\n                return false;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_ptr = matrix + i * cols;\n        if (cols == 1) {\n            continue;\n        }\n\n        size_t j = 0;\n        while (j < cols - 1) {\n            svbool_t pg = svwhilelt_b32(j, cols - 1);\n            svint32_t current_vec = svld1(pg, row_ptr + j);\n            svint32_t next_vec = svld1(pg, row_ptr + j + 1);\n            svbool_t cmp = svcmplt_s32(pg, current_vec, next_vec);\n            svbool_t fail = svnot_b_z(pg, cmp);\n            if (svptest_any(pg, fail)) {\n                return false;\n            }\n            j += svcntw();\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_36_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_rows_strictly_increasing_simd(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    \n    for (size_t i = 0; i < rows; i++) {\n        const int* row_ptr = matrix + i * cols;\n        size_t j = 0;\n        size_t num_comparisons = cols - 1;\n        \n        while (j < num_comparisons) {\n            svbool_t pg = svwhilelt_b32(j, num_comparisons);\n            size_t n = svcntp_b32(pg, pg);\n            if (n == 0) break;\n            \n            svint32_t current = svld1(pg, row_ptr + j);\n            svint32_t next = svld1(pg, row_ptr + j + 1);\n            svbool_t fail = svcmpge(pg, current, next);\n            \n            if (svptest_any(pg, fail)) {\n                break;\n            }\n            \n            j += n;\n        }\n        \n        if (j < num_comparisons) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    \n    size_t vl = svcntw();\n    \n    for (size_t block_i = 0; block_i < rows; block_i += block_size) {\n        for (size_t block_j = 0; block_j < cols; block_j += block_size) {\n            if (block_i == 0 && block_j == 0) {\n                continue;\n            }\n            \n            for (size_t r = 0; r < block_size; r++) {\n                const int* ref_row = matrix + r * cols;\n                const int* cur_row = matrix + (block_i + r) * cols + block_j;\n                \n                size_t k = 0;\n                while (k < block_size) {\n                    svbool_t pg = svwhilelt_b32(k, block_size);\n                    svint32_t v_ref = svld1(pg, ref_row + k);\n                    svint32_t v_cur = svld1(pg, cur_row + k);\n                    \n                    if (svptest_any(pg, svcmpne(pg, v_ref, v_cur))) {\n                        return false;\n                    }\n                    \n                    k += vl;\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0) \n        return false;\n    if (rows % block_size != 0 || cols % block_size != 0) \n        return false;\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n\n    for (size_t block_i = 0; block_i < block_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < block_cols; ++block_j) {\n            if (block_i == 0 && block_j == 0) \n                continue;\n\n            for (size_t r = 0; r < block_size; ++r) {\n                const int* ref_row = matrix + r * cols;\n                const int* cur_row = matrix + (block_i * block_size + r) * cols + block_j * block_size;\n\n                size_t i = 0;\n                svbool_t pg = svwhilelt_b32(i, block_size);\n                do {\n                    svint32_t v_ref = svld1_s32(pg, ref_row + i);\n                    svint32_t v_cur = svld1_s32(pg, cur_row + i);\n                    svbool_t cmp = svcmpne_s32(pg, v_ref, v_cur);\n                    if (svptest_any(svptrue_b32(), cmp)) {\n                        return false;\n                    }\n                    i += svcntw();\n                    pg = svwhilelt_b32(i, block_size);\n                } while (svptest_any(svptrue_b32(), pg));\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n    size_t total_blocks = block_rows * block_cols;\n\n    if (total_blocks <= 1) {\n        return true;\n    }\n\n    for (size_t k = 0; k < block_size; k++) {\n        const int* ref_row = matrix + k * cols;\n\n        for (size_t i = 0; i < block_rows; i++) {\n            for (size_t j = 0; j < block_cols; j++) {\n                if (i == 0 && j == 0) continue;\n\n                const int* current_row = matrix + (i * block_size + k) * cols + j * block_size;\n                size_t index = 0;\n                svbool_t pg = svwhilelt_b32(index, block_size);\n\n                while (svptest_any(svptrue_b32(), pg)) {\n                    svint32_t ref_vec = svld1(pg, ref_row + index);\n                    svint32_t curr_vec = svld1(pg, current_row + index);\n                    svbool_t mismatch = svcmpne(pg, ref_vec, curr_vec);\n\n                    if (svptest_any(pg, mismatch)) {\n                        return false;\n                    }\n\n                    index += svcntw();\n                    pg = svwhilelt_b32(index, block_size);\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_rows = rows / block_size;\n    size_t num_blocks_cols = cols / block_size;\n    if (num_blocks_rows * num_blocks_cols <= 1) {\n        return true;\n    }\n\n    uint64_t vl = svcntw();\n    for (size_t i_block = 0; i_block < num_blocks_rows; i_block++) {\n        for (size_t j_block = 0; j_block < num_blocks_cols; j_block++) {\n            if (i_block == 0 && j_block == 0) continue;\n\n            for (size_t i = 0; i < block_size; i++) {\n                const int* ref_row = matrix + i * cols;\n                const int* cur_row = matrix + (i_block * block_size + i) * cols + j_block * block_size;\n\n                size_t j = 0;\n                svbool_t pg = svwhilelt_b32(j, block_size);\n                while (svptest_any(svptrue_b32(), pg)) {\n                    svint32_t ref_vec = svld1(pg, ref_row + j);\n                    svint32_t cur_vec = svld1(pg, cur_row + j);\n                    svbool_t cmp = svcmpeq(pg, ref_vec, cur_vec);\n\n                    if (!svptest_all(pg, cmp)) {\n                        return false;\n                    }\n\n                    j += vl;\n                    pg = svwhilelt_b32(j, block_size);\n                }\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_37_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool matrix_blocks_equal_simd(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    \n    size_t num_blocks_i = rows / block_size;\n    size_t num_blocks_j = cols / block_size;\n    size_t vl = svcntw();\n\n    for (size_t block_i = 0; block_i < num_blocks_i; block_i++) {\n        for (size_t block_j = 0; block_j < num_blocks_j; block_j++) {\n            if (block_i == 0 && block_j == 0) {\n                continue;\n            }\n            \n            for (size_t r = 0; r < block_size; r++) {\n                const int* first_row = matrix + r * cols;\n                const int* curr_row = matrix + (block_i * block_size + r) * cols + block_j * block_size;\n                \n                size_t c = 0;\n                svbool_t pg = svwhilelt_b32(c, block_size);\n                while (svptest_any(svptrue_b32(), pg)) {\n                    svint32_t first_vec = svld1(pg, first_row + c);\n                    svint32_t curr_vec = svld1(pg, curr_row + c);\n                    \n                    if (svptest_any(svptrue_b32(), svcmpne(pg, first_vec, curr_vec))) {\n                        return false;\n                    }\n                    \n                    c += vl;\n                    pg = svwhilelt_b32(c, block_size);\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || tolerance < 0.0) {\n        return false;\n    }\n    \n    size_t num_blocks = length / block_size;\n    if (num_blocks < 1) {\n        return false;\n    }\n    \n    if (num_blocks < 2) {\n        return true;\n    }\n    \n    size_t vl = svcntd();\n    \n    for (size_t i = 1; i < num_blocks; i++) {\n        size_t j = 0;\n        while (j < block_size) {\n            svbool_t pg = svwhilelt_b64(j, block_size);\n            svfloat64_t base_vec = svld1(pg, vec + j);\n            svfloat64_t curr_vec = svld1(pg, vec + i * block_size + j);\n            svfloat64_t diff = svabd(pg, base_vec, curr_vec);\n            svbool_t cmp = svcmple(pg, diff, tolerance);\n            \n            if (!svptest_all(pg, cmp)) {\n                return false;\n            }\n            \n            j += vl;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return true;\n    }\n\n    for (size_t j = 1; j < num_blocks; j++) {\n        size_t k = 0;\n        svbool_t pg = svwhilelt_b64(k, block_size);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t ref_vec = svld1(pg, vec + k);\n            svfloat64_t curr_vec = svld1(pg, vec + j * block_size + k);\n            svfloat64_t diff_vec = svabs_f64_z(pg, svsub_f64_z(pg, curr_vec, ref_vec));\n            svbool_t cmp = svcmpgt_f64(pg, diff_vec, svdup_f64(tolerance));\n            if (svptest_any(pg, cmp)) {\n                return false;\n            }\n            k += svcntd();\n            pg = svwhilelt_b64(k, block_size);\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    \n    size_t n_blocks = length / block_size;\n    if (n_blocks < 2) {\n        return true;\n    }\n\n    const double* ref_block = vec;\n    for (size_t block_index = 1; block_index < n_blocks; block_index++) {\n        const double* current_block = vec + block_index * block_size;\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b64(i, block_size);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t v_ref = svld1(pg, ref_block + i);\n            svfloat64_t v_cur = svld1(pg, current_block + i);\n            svfloat64_t diff = svabs_z(pg, svsub_z(pg, v_ref, v_cur));\n            svfloat64_t tol_vec = svdup_f64(tolerance);\n            svbool_t within_tol = svcmple(pg, diff, tol_vec);\n            svbool_t not_within_tol = svnot_b_z(pg, within_tol);\n            if (svptest_any(pg, not_within_tol)) {\n                return false;\n            }\n            i += svcntd();\n            pg = svwhilelt_b64(i, block_size);\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    size_t n_blocks = length / block_size;\n    if (n_blocks < 2) {\n        return true;\n    }\n    uint64_t vl = svcntd();\n\n    for (size_t i = 1; i < n_blocks; i++) {\n        for (size_t offset = 0; offset < block_size; offset += vl) {\n            svbool_t pg = svwhilelt_b64(offset, block_size);\n            svfloat64_t first_seg = svld1(pg, vec + offset);\n            svfloat64_t curr_seg = svld1(pg, vec + i * block_size + offset);\n            svfloat64_t diff = svabd_f64_z(pg, first_seg, curr_seg);\n            svbool_t gt_tol = svcmpgt_f64(pg, diff, svdup_f64(tolerance));\n            if (svptest_any(pg, gt_tol)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stddef.h>\n\nbool vector_block_equal_simd(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || length < block_size) {\n        return false;\n    }\n    \n    size_t num_blocks = length / block_size;\n    if (num_blocks < 2) {\n        return true;\n    }\n    \n    for (size_t block_idx = 1; block_idx < num_blocks; block_idx++) {\n        size_t offset = 0;\n        while (offset < block_size) {\n            svbool_t pg = svwhilelt_b64(offset, block_size);\n            svfloat64_t ref = svld1(pg, vec + offset);\n            svfloat64_t cur = svld1(pg, vec + block_idx * block_size + offset);\n            svfloat64_t diff = svabd_f64_z(pg, ref, cur);\n            svbool_t cmp = svcmple_f64(pg, diff, svdup_f64(tolerance));\n            svbool_t fail = svnot_z(pg, cmp);\n            if (svptest_any(pg, fail)) {\n                return false;\n            }\n            offset += svcntd();\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    size_t vl = svcntd();\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svfloat64_t accum = svdup_f64(0.0);\n        svbool_t p_all = svptrue_b64();\n        \n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t data = svld1_f64(pg, row_ptr + j);\n            svfloat64_t squared = svmul_f64_z(pg, data, data);\n            accum = svadd_f64_m(pg, accum, accum, squared);\n            j += vl;\n        }\n        \n        double total_sq = svaddv_f64(p_all, accum);\n        double thr = thresholds[i];\n        result[i] = (total_sq > thr * thr);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <math.h>\n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        size_t col_index = 0;\n        while (col_index < cols) {\n            svbool_t pg = svwhilelt_b64(col_index, cols);\n            svfloat64_t row_data = svld1(pg, row_ptr + col_index);\n            svfloat64_t squared = svmul_f64_z(pg, row_data, row_data);\n            sum_vec = svadd_f64_m(pg, sum_vec, squared);\n            col_index += svcntp_b64(svptrue_b64(), pg);\n        }\n        double total_sum = svaddv_f64(svptrue_b64(), sum_vec);\n        double norm_val = sqrt(total_sum);\n        result[i] = (norm_val > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svfloat64_t acc = svdup_f64(0.0);\n        size_t j = 0;\n        while (j < cols) {\n            svbool_t pg = svwhilelt_b64(j, cols);\n            svfloat64_t vec = svld1_f64(pg, row_ptr + j);\n            vec = svmul_f64_x(pg, vec, vec);\n            acc = svadd_f64_x(pg, acc, vec);\n            j += svcntd();\n        }\n        double sum_squares = svaddv_f64(svptrue_b64(), acc);\n        double norm = sqrt(sum_squares);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svfloat64_t sum_vec = svdup_n_f64(0.0);\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, cols);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t data = svld1_f64(pg, row_ptr + j);\n            svfloat64_t squared = svmul_f64_z(pg, data, data);\n            sum_vec = svadd_f64_m(pg, sum_vec, squared);\n            j += svcntd();\n            pg = svwhilelt_b64(j, cols);\n        }\n        double total = svaddv_f64(svptrue_b64(), sum_vec);\n        double norm = __builtin_sqrt(total);\n        result[i] = norm > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_row_norm_compare_simd(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    uint64_t vl = svcntd();\n    for (size_t i = 0; i < rows; i++) {\n        const double* row_ptr = matrix + i * cols;\n        svfloat64_t sum_vec = svdup_f64(0.0);\n        uint64_t index = 0;\n        svbool_t pg = svwhilelt_b64_u64(index, (uint64_t)cols);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t data = svld1_f64(pg, row_ptr + index);\n            svfloat64_t squared = svmul_f64_z(pg, data, data);\n            sum_vec = svadd_f64_m(pg, sum_vec, squared);\n            index += vl;\n            pg = svwhilelt_b64_u64(index, (uint64_t)cols);\n        }\n        double total = svaddv_f64(svptrue_b64(), sum_vec);\n        double norm = sqrt(total);\n        result[i] = (norm > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t va = svld1(pg, A + i);\n        svuint32_t vb = svld1(pg, B + i);\n        svuint32_t vc = svorr_x(pg, va, vb);\n        svst1(pg, C + i, vc);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svuint32_t a_vec = svld1(pg, &A[i]);\n        svuint32_t b_vec = svld1(pg, &B[i]);\n        svuint32_t c_vec = svorr_x(pg, a_vec, b_vec);\n        svst1(pg, &C[i], c_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t i = 0;\n    const unsigned int vl = svcntw();\n    if (length == 0) return;\n\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svuint32_t va = svld1_u32(pg, A + i);\n        svuint32_t vb = svld1_u32(pg, B + i);\n        svuint32_t vc = svorr_u32_x(pg, va, vb);\n        svst1_u32(pg, C + i, vc);\n\n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    if (length == 0) {\n        return;\n    }\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t va = svld1(pg, A + i);\n        svuint32_t vb = svld1(pg, B + i);\n        svuint32_t vc = svorr_u32_x(pg, va, vb);\n        svst1(pg, C + i, vc);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_40_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bitwise_or_simd(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, length);\n    do {\n        svuint32_t va = svld1(pg, A + index);\n        svuint32_t vb = svld1(pg, B + index);\n        svuint32_t vc = svorr_z(pg, va, vb);\n        svst1(pg, C + index, vc);\n        index += svcntw();\n        pg = svwhilelt_b32(index, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    svint64_t squares_acc_vec = svdup_s64(0);\n    svint64_t products_acc_vec = svdup_s64(0);\n    size_t vl = svcntb();\n\n    while (length > 0) {\n        svbool_t pg = svwhilelt_b8(0, (uint64_t)length);\n        svint8_t a_vec = svld1_s8(pg, A);\n        svint8_t b_vec = svld1_s8(pg, B);\n\n        svint16_t a_low = svmovlb_s16(a_vec);\n        svint16_t a_high = svmovlt_s16(a_vec);\n        svint16_t b_low = svmovlb_s16(b_vec);\n        svint16_t b_high = svmovlt_s16(b_vec);\n\n        squares_acc_vec = svmlalb_s32(squares_acc_vec, a_low, a_low);\n        squares_acc_vec = svmlalt_s32(squares_acc_vec, a_high, a_high);\n        products_acc_vec = svmlalb_s32(products_acc_vec, a_low, b_low);\n        products_acc_vec = svmlalt_s32(products_acc_vec, a_high, b_high);\n\n        A += vl;\n        B += vl;\n        length -= vl;\n    }\n\n    int64_t total_squares = svaddv_s64(svptrue_b64(), squares_acc_vec);\n    int64_t total_products = svaddv_s64(svptrue_b64(), products_acc_vec);\n    return total_squares - total_products;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    uint64_t vl = svcntb();\n    size_t i = 0;\n    svint32_t sum_vec = svdup_s32(0);\n    svbool_t all = svptrue_b8();\n\n    while (i + vl <= length) {\n        svint8_t va = svld1_s8(all, A + i);\n        svint8_t vb = svld1_s8(all, B + i);\n        svint8_t vdiff = svsub_s8(all, va, vb);\n        sum_vec = svdot_s32(all, sum_vec, vdiff, vdiff);\n        i += vl;\n    }\n\n    svint64_t sum64 = svsxtw_s64(sum_vec);\n    int64_t total = svaddv_s64(svptrue_b64(), sum64);\n\n    for (; i < length; i++) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        int8_t diff = a - b;\n        total += (int64_t)diff * diff;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t i = 0;\n    int64_t acc_scalar = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t va8 = svld1_s8(pg, A + i);\n        svint8_t vb8 = svld1_s8(pg, B + i);\n        svint8_t diff8 = svsub_s8(va8, vb8);\n        \n        svint16_t diff16_lo = svmovlb_s8(diff8);\n        svint16_t diff16_hi = svmovlt_s8(diff8);\n        \n        svint32_t dot_lo = svdot_s32(svdup_n_s32(0), diff16_lo, diff16_lo);\n        svint32_t dot_hi = svdot_s32(svdup_n_s32(0), diff16_hi, diff16_hi);\n        \n        int32_t sum_lo = svaddv_s32(svptrue_b32(), dot_lo);\n        int32_t sum_hi = svaddv_s32(svptrue_b32(), dot_hi);\n        \n        acc_scalar += (int64_t)sum_lo + (int64_t)sum_hi;\n        i += svcntb();\n    }\n    return acc_scalar;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    uint64_t vl = svcntb();\n    size_t i = 0;\n    int64_t total_sq = 0;\n    int64_t total_prod = 0;\n\n    for (; i + vl <= length; i += vl) {\n        svint8_t va = svld1_s8(svptrue_b8(), A + i);\n        svint8_t vb = svld1_s8(svptrue_b8(), B + i);\n\n        svint32_t acc_sq = svdup_n_s32(0);\n        svint32_t acc_prod = svdup_n_s32(0);\n\n        acc_sq = svdot_s32(acc_sq, va, va);\n        acc_prod = svdot_s32(acc_prod, va, vb);\n\n        int32_t sum_sq = svaddv_s32(svptrue_b32(), acc_sq);\n        int32_t sum_prod = svaddv_s32(svptrue_b32(), acc_prod);\n\n        total_sq += (int64_t)sum_sq;\n        total_prod += (int64_t)sum_prod;\n    }\n\n    for (; i < length; i++) {\n        int64_t a_val = A[i];\n        total_sq += a_val * a_val;\n        total_prod += a_val * B[i];\n    }\n\n    return total_sq - total_prod;\n}\n```"}
{"task_id": "SimdBench_41_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint64_t squarediff_simd(const int8_t * A, const int8_t * B, size_t length) {\n    uint64_t vl = svcntb();\n    uint64_t i = 0;\n    svint64_t sq_acc = svdup_n_s64(0);\n    svint64_t prod_acc = svdup_n_s64(0);\n    svbool_t pg = svwhilelt_b8(i, length);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t a_vec = svld1_s8(pg, A + i);\n        svint8_t b_vec = svld1_s8(pg, B + i);\n        sq_acc = svdot_s64(sq_acc, a_vec, a_vec);\n        prod_acc = svdot_s64(prod_acc, a_vec, b_vec);\n        i += vl;\n        pg = svwhilelt_b8(i, length);\n    }\n    int64_t sum_sq = svaddv_s64(svptrue_b64(), sq_acc);\n    int64_t sum_prod = svaddv_s64(svptrue_b64(), prod_acc);\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t va = svld1(pg, A + i);\n        svuint64_t vb = svld1(pg, B + i);\n        svuint64_t vc = svand_x(pg, va, svnot_x(pg, vb));\n        svst1(pg, C + i, vc);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svuint64_t vec_a, vec_b, vec_result;\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        vec_a = svld1_u64(pg, A + i);\n        vec_b = svld1_u64(pg, B + i);\n        vec_result = svand_u64_z(pg, vec_a, svnot_u64_z(pg, vec_b));\n        svst1_u64(pg, C + i, vec_result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    const size_t vl = svcntd();\n    svbool_t all_true = svptrue_b64();\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svuint64_t va = svld1_u64(pg, A + i);\n        svuint64_t vb = svld1_u64(pg, B + i);\n        svuint64_t vnotb = svnot_u64_x(all_true, vb);\n        svuint64_t vc = svand_u64_x(all_true, va, vnotb);\n        svst1_u64(pg, C + i, vc);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svuint64_t vec_a, vec_b, vec_not_b, vec_result;\n    svbool_t pg = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg)) {\n        vec_a = svld1_u64(pg, &A[i]);\n        vec_b = svld1_u64(pg, &B[i]);\n        vec_not_b = svnot_u64_z(pg, vec_b);\n        vec_result = svand_u64_z(pg, vec_a, vec_not_b);\n        svst1_u64(pg, &C[i], vec_result);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_42_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_clear_simd(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        svuint64_t va = svld1_u64(pg, &A[i]);\n        svuint64_t vb = svld1_u64(pg, &B[i]);\n        svuint64_t vc = svand_u64_x(pg, va, svnot_u64_x(pg, vb));\n        svst1_u64(pg, &C[i], vc);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    const size_t vl = svcntb();\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t va = svld1_s8(pg, A + i);\n        svint8_t vb = svld1_s8(pg, B + i);\n\n        svbool_t a_pos = svcmpgt(pg, va, 0);\n        svbool_t a_neg = svcmplt(pg, va, 0);\n        svbool_t b_pos = svcmpgt(pg, vb, 0);\n        svbool_t b_neg = svcmplt(pg, vb, 0);\n\n        svbool_t both_pos = svand_z(pg, a_pos, b_pos);\n        svbool_t both_neg = svand_z(pg, a_neg, b_neg);\n\n        svint8_t vc = svdup_s8(0);\n        vc = svsel_s8(both_pos, svdup_s8(1), vc);\n        vc = svsel_s8(both_neg, svdup_s8(-1), vc);\n\n        svst1_s8(pg, C + i, vc);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    uint64_t vl = svcntb();\n    uint64_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg, A + i);\n        svint8_t b_vec = svld1_s8(pg, B + i);\n        svint8_t zeros = svdup_n_s8(0);\n\n        svbool_t a_positive = svcmpgt(pg, a_vec, zeros);\n        svbool_t b_positive = svcmpgt(pg, b_vec, zeros);\n        svbool_t both_positive = svand_b_z(pg, a_positive, b_positive);\n\n        svbool_t a_negative = svcmplt(pg, a_vec, zeros);\n        svbool_t b_negative = svcmplt(pg, b_vec, zeros);\n        svbool_t both_negative = svand_b_z(pg, a_negative, b_negative);\n\n        svint8_t c_vec = svdup_n_s8(0);\n        c_vec = svsel_s8(both_positive, svdup_n_s8(1), c_vec);\n        c_vec = svsel_s8(both_negative, svdup_n_s8(-1), c_vec);\n\n        svst1_s8(pg, C + i, c_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, length);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint8_t a_vec = svld1_s8(pg, A + i);\n        svint8_t b_vec = svld1_s8(pg, B + i);\n\n        svbool_t a_pos = svcmpgt(pg, a_vec, 0);\n        svbool_t a_neg = svcmplt(pg, a_vec, 0);\n        svbool_t b_pos = svcmpgt(pg, b_vec, 0);\n        svbool_t b_neg = svcmplt(pg, b_vec, 0);\n\n        svbool_t both_pos = svand_b_z(pg, a_pos, b_pos);\n        svbool_t both_neg = svand_b_z(pg, a_neg, b_neg);\n\n        svint8_t c_vec = svdup_n_s8(0);\n        c_vec = svsel_s8(both_pos, svdup_n_s8(1), c_vec);\n        c_vec = svsel_s8(both_neg, svdup_n_s8(-1), c_vec);\n\n        svst1_s8(pg, C + i, c_vec);\n\n        i += svcntb();\n        pg = svwhilelt_b8(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t i = 0;\n    const unsigned int vl = svcntb();\n    svint8_t zero_vec = svdup_s8(0);\n    svint8_t one_vec = svdup_s8(1);\n    svint8_t neg_one_vec = svdup_s8(-1);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg, A + i);\n        svint8_t b_vec = svld1_s8(pg, B + i);\n\n        svbool_t a_pos = svcmpgt(pg, a_vec, 0);\n        svbool_t a_neg = svcmplt(pg, a_vec, 0);\n        svbool_t b_pos = svcmpgt(pg, b_vec, 0);\n        svbool_t b_neg = svcmplt(pg, b_vec, 0);\n\n        svbool_t both_pos = svand_b_z(pg, a_pos, b_pos);\n        svbool_t both_neg = svand_b_z(pg, a_neg, b_neg);\n\n        svint8_t c_vec = zero_vec;\n        c_vec = svsel_s8(both_pos, one_vec, c_vec);\n        c_vec = svsel_s8(both_neg, neg_one_vec, c_vec);\n\n        svst1_s8(pg, C + i, c_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_43_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_three_valued_logic_simd(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    size_t vl = svcntb();\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b8(i, length);\n        svint8_t a_vec = svld1_s8(pg, &A[i]);\n        svint8_t b_vec = svld1_s8(pg, &B[i]);\n        \n        svbool_t a_pos = svcmpgt_s8(pg, a_vec, 0);\n        svbool_t a_neg = svcmplt_s8(pg, a_vec, 0);\n        svbool_t b_pos = svcmpgt_s8(pg, b_vec, 0);\n        svbool_t b_neg = svcmplt_s8(pg, b_vec, 0);\n        \n        svbool_t both_pos = svand_b_z(pg, a_pos, b_pos);\n        svbool_t both_neg = svand_b_z(pg, a_neg, b_neg);\n        \n        svint8_t res = svdup_n_s8(0);\n        res = svsel_s8(both_pos, svdup_n_s8(1), res);\n        res = svsel_s8(both_neg, svdup_n_s8(-1), res);\n        \n        svst1_s8(pg, &C[i], res);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) return;\n\n    size_t mid = length / 2;\n    size_t first_part_end = mid;\n    size_t second_part_start = (length % 2 == 1) ? mid + 1 : mid;\n    uint64_t vl = svcnth();\n\n    size_t index = 0;\n    while (index < first_part_end) {\n        svbool_t pg = svwhilelt_b16_u64(index, first_part_end);\n        svuint16_t va = svld1_u16(pg, A + index);\n        svuint16_t vb = svld1_u16(pg, B + index);\n        svuint16_t vc = sveor_u16_z(pg, va, vb);\n        svst1_u16(pg, C + index, vc);\n        index += vl;\n    }\n\n    if (length % 2 == 1) {\n        C[mid] = A[mid];\n    }\n\n    index = second_part_start;\n    while (index < length) {\n        svbool_t pg = svwhilelt_b16_u64(index, length);\n        svuint16_t va = svld1_u16(pg, A + index);\n        svuint16_t vb = svld1_u16(pg, B + index);\n        svuint16_t vc = svand_u16_z(pg, va, vb);\n        svst1_u16(pg, C + index, vc);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) return;\n    \n    size_t mid = length / 2;\n    size_t i = 0;\n    size_t vl;\n    \n    while (i < mid) {\n        svbool_t pg = svwhilelt_b16(i, mid);\n        svuint16_t va = svld1(pg, A + i);\n        svuint16_t vb = svld1(pg, B + i);\n        svuint16_t vc = sveor_u16_x(pg, va, vb);\n        svst1(pg, C + i, vc);\n        vl = svcnth();\n        i += vl;\n    }\n    \n    C[mid] = A[mid];\n    \n    size_t j = mid + 1;\n    while (j < length) {\n        svbool_t pg = svwhilelt_b16(j, length);\n        svuint16_t va = svld1(pg, A + j);\n        svuint16_t vb = svld1(pg, B + j);\n        svuint16_t vc = svand_u16_x(pg, va, vb);\n        svst1(pg, C + j, vc);\n        vl = svcnth();\n        j += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) return;\n    \n    size_t mid_index = length / 2;\n    size_t is_odd = length & 1;\n    size_t index = 0;\n\n    while (index < mid_index) {\n        svbool_t pg = svwhilelt_b16(index, mid_index);\n        svuint16_t a_vec = svld1(pg, A + index);\n        svuint16_t b_vec = svld1(pg, B + index);\n        svuint16_t res = sveor_u16_z(pg, a_vec, b_vec);\n        svst1(pg, C + index, res);\n        index += svcnth();\n    }\n\n    if (is_odd) {\n        C[mid_index] = A[mid_index];\n    }\n\n    size_t start_after = mid_index + is_odd;\n    index = start_after;\n    while (index < length) {\n        svbool_t pg = svwhilelt_b16(index, length);\n        svuint16_t a_vec = svld1(pg, A + index);\n        svuint16_t b_vec = svld1(pg, B + index);\n        svuint16_t res = svand_u16_z(pg, a_vec, b_vec);\n        svst1(pg, C + index, res);\n        index += svcnth();\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) return;\n    size_t mid = length / 2;\n    size_t i = 0;\n    while (i < mid) {\n        svbool_t pg = svwhilelt_b16(i, mid);\n        uint64_t n = svcntp_b16(pg, pg);\n        if (n == 0) break;\n        svuint16_t a_vec = svld1(pg, A + i);\n        svuint16_t b_vec = svld1(pg, B + i);\n        svuint16_t res = sveor_u16_z(pg, a_vec, b_vec);\n        svst1(pg, C + i, res);\n        i += n;\n    }\n    C[mid] = A[mid];\n    size_t j = mid + 1;\n    while (j < length) {\n        svbool_t pg = svwhilelt_b16(j, length);\n        uint64_t n = svcntp_b16(pg, pg);\n        if (n == 0) break;\n        svuint16_t a_vec = svld1(pg, A + j);\n        svuint16_t b_vec = svld1(pg, B + j);\n        svuint16_t res = svand_u16_z(pg, a_vec, b_vec);\n        svst1(pg, C + j, res);\n        j += n;\n    }\n}\n```"}
{"task_id": "SimdBench_44_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_bit_op_simd(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length == 0) {\n        return;\n    }\n    \n    uint64_t n1 = length / 2;\n    uint64_t start3 = n1;\n    \n    uint64_t i = 0;\n    while (i < n1) {\n        svbool_t pg = svwhilelt_b16(i, n1);\n        svuint16_t va = svld1(pg, A + i);\n        svuint16_t vb = svld1(pg, B + i);\n        svuint16_t vc = sveor_u16_z(pg, va, vb);\n        svst1(pg, C + i, vc);\n        i += svcntp_b16(pg, pg);\n    }\n    \n    if (length % 2 == 1) {\n        C[n1] = A[n1];\n        start3 = n1 + 1;\n    }\n    \n    uint64_t end3 = start3 + n1;\n    i = start3;\n    while (i < end3) {\n        svbool_t pg = svwhilelt_b16(i, end3);\n        svuint16_t va = svld1(pg, A + i);\n        svuint16_t vb = svld1(pg, B + i);\n        svuint16_t vc = svand_u16_z(pg, va, vb);\n        svst1(pg, C + i, vc);\n        i += svcntp_b16(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    svbool_t pg32 = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg32)) {\n        svint32_t c1_vec = svld1sb_s32(pg32, (const int8_t*)(cond1 + index));\n        svint32_t c2_vec = svld1sb_s32(pg32, (const int8_t*)(cond2 + index));\n        svbool_t P1 = svcmpne(pg32, c1_vec, 0);\n        svbool_t P2 = svcmpne(pg32, c2_vec, 0);\n        svfloat32_t A_vec = svld1(pg32, A + index);\n        svfloat32_t B_vec = svld1(pg32, B + index);\n        svfloat32_t C_vec = svld1(pg32, C + index);\n        svfloat32_t D_vec = svld1(pg32, D + index);\n        svfloat32_t then_part = svsel_f32(P2, A_vec, B_vec);\n        svfloat32_t else_part = svsel_f32(P2, C_vec, D_vec);\n        svfloat32_t out_vec = svsel_f32(P1, then_part, else_part);\n        svst1(pg32, out + index, out_vec);\n        uint64_t vl = svcntp_b32(svptrue_b32(), pg32);\n        index += vl;\n        pg32 = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    uint64_t vl = svcntw();\n\n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n        size_t n = svcntp_b32(pg, pg);\n\n        svuint8_t c1_u8 = svld1_u8(pg, (const uint8_t*)(cond1 + index));\n        svuint8_t c2_u8 = svld1_u8(pg, (const uint8_t*)(cond2 + index));\n\n        svbool_t c1_pred = svcmpne(pg, c1_u8, svdup_n_u8(0));\n        svbool_t c2_pred = svcmpne(pg, c2_u8, svdup_n_u8(0));\n\n        svbool_t case1 = svand_z(pg, c1_pred, c2_pred);\n        svbool_t case2 = svand_z(pg, c1_pred, svnot_b_z(pg, c2_pred));\n        svbool_t case3 = svand_z(pg, svnot_b_z(pg, c1_pred), c2_pred);\n\n        svfloat32_t a_vec = svld1_f32(pg, A + index);\n        svfloat32_t b_vec = svld1_f32(pg, B + index);\n        svfloat32_t c_vec = svld1_f32(pg, C + index);\n        svfloat32_t d_vec = svld1_f32(pg, D + index);\n\n        svfloat32_t result = d_vec;\n        result = svsel_f32(case3, c_vec, result);\n        result = svsel_f32(case2, b_vec, result);\n        result = svsel_f32(case1, a_vec, result);\n\n        svst1_f32(pg, out + index, result);\n\n        index += n;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    unsigned int vl = svcntw();\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    do {\n        svuint8_t cond1_vec = svld1_u8(pg, (const uint8_t*)(cond1 + index));\n        svuint8_t cond2_vec = svld1_u8(pg, (const uint8_t*)(cond2 + index));\n        svbool_t p_cond1 = svcmpne(pg, cond1_vec, svdup_n_u8(0));\n        svbool_t p_cond2 = svcmpne(pg, cond2_vec, svdup_n_u8(0));\n        svbool_t p1 = svand_b_z(pg, p_cond1, p_cond2);\n        svbool_t p2 = svand_b_z(pg, p_cond1, svnot_b_z(pg, p_cond2));\n        svbool_t p3 = svand_b_z(pg, svnot_b_z(pg, p_cond1), p_cond2);\n        svfloat32_t a_vec = svld1(pg, A + index);\n        svfloat32_t b_vec = svld1(pg, B + index);\n        svfloat32_t c_vec = svld1(pg, C + index);\n        svfloat32_t d_vec = svld1(pg, D + index);\n        svfloat32_t out_vec = d_vec;\n        out_vec = svsel(p3, c_vec, out_vec);\n        out_vec = svsel(p2, b_vec, out_vec);\n        out_vec = svsel(p1, a_vec, out_vec);\n        svst1(pg, out + index, out_vec);\n        index += vl;\n        pg = svwhilelt_b32(index, total_elements);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    size_t vl = svcntw();\n    \n    while (index < total_elements) {\n        svbool_t pg_b8 = svwhilelt_b8(index, total_elements);\n        svbool_t pg_b32 = svwhilelt_b32(index, total_elements);\n        \n        svbool_t p1 = svld1_b8(pg_b8, (const uint8_t*)(cond1 + index));\n        svbool_t p2 = svld1_b8(pg_b8, (const uint8_t*)(cond2 + index));\n        \n        svbool_t not_p1 = svnot_b_z(pg_b8, p1);\n        svbool_t not_p2 = svnot_b_z(pg_b8, p2);\n        \n        svbool_t mask1 = svand_b_z(pg_b8, p1, p2);\n        svbool_t mask2 = svand_b_z(pg_b8, p1, not_p2);\n        svbool_t mask3 = svand_b_z(pg_b8, not_p1, p2);\n        \n        svfloat32_t a_vec = svld1(pg_b32, A + index);\n        svfloat32_t b_vec = svld1(pg_b32, B + index);\n        svfloat32_t c_vec = svld1(pg_b32, C + index);\n        svfloat32_t d_vec = svld1(pg_b32, D + index);\n        \n        svfloat32_t result = svsel_f32(mask1, a_vec, \n                                svsel_f32(mask2, b_vec, \n                                svsel_f32(mask3, c_vec, d_vec)));\n        \n        svst1(pg_b32, out + index, result);\n        \n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_45_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_multi_select_simd(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t index = 0;\n    \n    while (index < total_elements) {\n        svbool_t pg = svwhilelt_b32(index, total_elements);\n        svint32_t c1_s32 = svld1sb_s32(pg, (const int8_t*)(cond1 + index));\n        svint32_t c2_s32 = svld1sb_s32(pg, (const int8_t*)(cond2 + index));\n        svbool_t c1_true = svcmpne(pg, c1_s32, 0);\n        svbool_t c2_true = svcmpne(pg, c2_s32, 0);\n        svbool_t case1 = svand_b_z(pg, c1_true, c2_true);\n        svbool_t case2 = svand_b_z(pg, c1_true, svnot_b_z(pg, c2_true));\n        svbool_t case3 = svand_b_z(pg, svnot_b_z(pg, c1_true), c2_true);\n        svfloat32_t a_vec = svld1(pg, A + index);\n        svfloat32_t b_vec = svld1(pg, B + index);\n        svfloat32_t c_vec = svld1(pg, C + index);\n        svfloat32_t d_vec = svld1(pg, D + index);\n        svfloat32_t out_vec = svsel_f32(case1, a_vec, \n                               svsel_f32(case2, b_vec, \n                               svsel_f32(case3, c_vec, d_vec)));\n        svst1(pg, out + index, out_vec);\n        index += svcntp_b32(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n    \n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint8_t x0, x1, x2, x3;\n        svld4_u8(pg, (const uint8_t*)(A + i), &x0, &x1, &x2, &x3);\n        \n        x0 = svcnt_u8_z(pg, x0);\n        x1 = svcnt_u8_z(pg, x1);\n        x2 = svcnt_u8_z(pg, x2);\n        x3 = svcnt_u8_z(pg, x3);\n        \n        svuint8_t sum01 = svadd_u8_z(pg, x0, x1);\n        svuint8_t sum23 = svadd_u8_z(pg, x2, x3);\n        svuint8_t total = svadd_u8_z(pg, sum01, sum23);\n        \n        svst1_u8(pg, out + i, total);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    static const uint8_t popcount_table[256] = {\n        0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,\n        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n        3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8\n    };\n\n    size_t index = 0;\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, &A[index]);\n        svuint32_t sum = svdup_u32(0);\n        \n        for (int shift = 0; shift < 32; shift += 8) {\n            svuint32_t shifted = svlsr_n_u32_x(pg, input, shift);\n            svuint32_t byte_val = svand_n_u32_x(pg, shifted, 0xFF);\n            svuint32_t counts = svld1ub_gather_u32offset_u32(pg, popcount_table, byte_val);\n            sum = svadd_u32_x(pg, sum, counts);\n        }\n        \n        svst1b_u32(pg, &out[index], sum);\n        index += vl;\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t v = svld1_u32(pg, A + i);\n        svuint32_t cnt32 = svcnt_u32_x(pg, v);\n        svuint8_t all_bytes = svreinterpret_u8_u32(cnt32);\n        svuint32_t base = svindex_u32(0, 1);\n        base = svsel_u32(pg, base, svdup_n_u32(0));\n        svuint32_t byte_indices = svmul_n_u32_z(pg, base, 4);\n        svuint8_t gather_indices = svreinterpret_u8_u32(byte_indices);\n        svuint8_t result = svtbl_u8(all_bytes, gather_indices);\n        size_t vl = svcntp_b32(pg, pg);\n        svbool_t pg_store = svwhilelt_b8(i, i + vl);\n        svst1_u8(pg_store, out + i, result);\n        i += vl;\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t vl = svcntw();\n    for (size_t i = 0; i < total_elements; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, total_elements);\n        svuint32_t input = svld1_u32(pg, A + i);\n        svuint8_t bytes = svreinterpret_u8_u32(input);\n        svuint8_t byte_counts = svcnt_u8(svptrue_b8(), bytes);\n        \n        svuint8_t u0 = svuzp1_u8(byte_counts, byte_counts);\n        svuint8_t u1 = svuzp2_u8(byte_counts, byte_counts);\n        svuint8_t sum1 = svadd_u8(svptrue_b8(), u0, u1);\n        \n        svuint8_t u2 = svuzp1_u8(sum1, sum1);\n        svuint8_t u3 = svuzp2_u8(sum1, sum1);\n        svuint8_t total = svadd_u8(svptrue_b8(), u2, u3);\n        \n        svst1_u8(pg, out + i, total);\n    }\n}\n```"}
{"task_id": "SimdBench_46_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_bit_count_simd(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    size_t i = 0;\n    size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, total_elements);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t data_vec = svld1_u32(pg, A + i);\n        svuint32_t popcount_vec = svcnt_u32_z(pg, data_vec);\n        \n        uint32_t tmp[vl];\n        svst1_u32(pg, tmp, popcount_vec);\n        \n        for (size_t j = 0; j < vl; j++) {\n            if (j < svcntp_b32(svptrue_b32(), pg)) {\n                out[i + j] = (uint8_t)tmp[j];\n            }\n        }\n        \n        i += vl;\n        pg = svwhilelt_b32(i, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n    unsigned int vl = svcntw();\n    while (i < total) {\n        svbool_t pg = svwhilelt_b32(i, total);\n        svint32_t vec = svld1_s32(pg, A + i);\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svuint32_t n = svreinterpret_u32_s32(abs_vec);\n        svuint32_t magic = svdup_n_u32(0xAAAAAAAB);\n        svuint32_t high = svmulh_u32_z(pg, n, magic);\n        svuint32_t q = svlsr_x(pg, high, 1);\n        svuint32_t q3 = svmul_u32_x(pg, q, svdup_n_u32(3));\n        svuint32_t rem = svsub_u32_x(pg, n, q3);\n        svbool_t rem_is_zero = svcmpeq_u32(pg, rem, 0);\n        svint32_t result = svsel_s32(rem_is_zero, abs_vec, vec);\n        svst1_s32(pg, B + i, result);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    uint64_t index = 0;\n    svbool_t pg = svwhilelt_b32_u64(index, total_elements);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t x = svld1_s32(pg, A + index);\n        svint32_t abs_x = svabs_s32_z(pg, x);\n        svuint32_t u_abs_x = svreinterpret_u32_s32(abs_x);\n        svuint32_t high = svmulh_u32_x(pg, u_abs_x, svdup_n_u32(0xAAAAAAAB));\n        svuint32_t quotient = svlsr_n_u32_x(pg, high, 1);\n        svuint32_t modulus = svsub_u32_x(pg, u_abs_x, svmul_n_u32_x(pg, quotient, 3));\n        svbool_t condition = svcmpeq_n_u32(pg, modulus, 0);\n        svint32_t result = svsel_s32(condition, abs_x, x);\n        svst1_s32(pg, B + index, result);\n        index += svcntw();\n        pg = svwhilelt_b32_u64(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total_elements = rows * cols;\n    size_t index = 0;\n    svbool_t all_true = svptrue_b32();\n    svbool_t pg = svwhilelt_b32(index, total_elements);\n\n    while (svptest_any(all_true, pg)) {\n        svint32_t data = svld1_s32(pg, A + index);\n        svint32_t three = svdup_n_s32(3);\n        svint32_t quotient = svdiv_s32_x(pg, data, three);\n        svint32_t product = svmul_s32_x(pg, quotient, three);\n        svint32_t rem = svsub_s32_x(pg, data, product);\n        svbool_t cond = svcmpeq_s32(pg, rem, 0);\n        svint32_t abs_data = svabs_s32_x(pg, data);\n        svint32_t result = svsel_s32(cond, abs_data, data);\n        svst1_s32(pg, B + index, result);\n        \n        index += svcntw();\n        pg = svwhilelt_b32(index, total_elements);\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    uint64_t total = (uint64_t)rows * (uint64_t)cols;\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    while (i < total) {\n        svbool_t pg = svwhilelt_b32(i, total);\n        svint32_t va = svld1_s32(pg, A + i);\n        svuint32_t u_va = svreinterpret_u32_s32(va);\n        svbool_t p_neg = svcmplt_s32(pg, va, 0);\n        svuint32_t u_abs = svsel_u32(p_neg, svsub_n_u32_x(pg, svdup_n_u32(0), u_va), u_va);\n        svuint32_t const_inv = svdup_n_u32(0xAAAAAAAB);\n        svuint32_t high = svmulh_u32_x(pg, u_abs, const_inv);\n        svuint32_t q = svlsr_n_u32_x(pg, high, 1);\n        svuint32_t q3 = svmul_n_u32_x(pg, q, 3);\n        svuint32_t mod = svsub_u32_x(pg, u_abs, q3);\n        svbool_t mask = svcmpeq_n_u32(pg, mod, 0);\n        svint32_t abs_va = svreinterpret_s32_u32(u_abs);\n        svint32_t res = svsel_s32(mask, abs_va, va);\n        svst1_s32(pg, B + i, res);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_47_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_conditional_abs_simd(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, total);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t a_vec = svld1_s32(pg, &A[i]);\n        svint32_t abs_vec = svabs_s32_z(pg, a_vec);\n        svuint32_t x = svreinterpret_u32_s32(abs_vec);\n\n        svuint32_t low16 = svand_u32_x(pg, x, svdup_u32(0xFFFF));\n        svuint32_t high16 = svlsr_x(pg, x, 16);\n        svuint32_t x1 = svadd_u32_x(pg, low16, high16);\n\n        low16 = svand_u32_x(pg, x1, svdup_u32(0xFF));\n        high16 = svlsr_x(pg, x1, 8);\n        svuint32_t x2 = svadd_u32_x(pg, low16, high16);\n\n        low16 = svand_u32_x(pg, x2, svdup_u32(0xF));\n        high16 = svlsr_x(pg, x2, 4);\n        svuint32_t x3 = svadd_u32_x(pg, low16, high16);\n\n        low16 = svand_u32_x(pg, x3, svdup_u32(0x3));\n        high16 = svlsr_x(pg, x3, 2);\n        svuint32_t x4 = svadd_u32_x(pg, low16, high16);\n\n        low16 = svand_u32_x(pg, x4, svdup_u32(0x3));\n        high16 = svlsr_x(pg, x4, 2);\n        svuint32_t x5 = svadd_u32_x(pg, low16, high16);\n\n        svbool_t mask_ge3 = svcmpge_u32(pg, x5, svdup_u32(3));\n        x5 = svsub_u32_m(mask_ge3, x5, svdup_u32(3));\n\n        svbool_t divisible_mask = svcmpeq_u32(pg, x5, svdup_u32(0));\n        svint32_t result = svsel_s32(divisible_mask, abs_vec, a_vec);\n        svst1_s32(pg, &B[i], result);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, total);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    if (length == 0) {\n        return;\n    }\n    \n    size_t vl = svcntw();\n    size_t i = 0;\n    svbool_t all_true = svptrue_b32();\n    \n    do {\n        svbool_t pg = svwhilelt_b32(i, length);\n        if (!svptest_any(all_true, pg)) {\n            break;\n        }\n        \n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        svuint32_t low4 = svand_u32_z(pg, src_vec, svdup_u32(0xF));\n        svbool_t mask = svcmpeq_u32(pg, low4, svdup_u32(0xF));\n        \n        svuint32_t rot_vec = svdup_u32(rotate_bits);\n        svuint32_t rotated = svror_u32_z(pg, src_vec, rot_vec);\n        svuint32_t negated = svnot_u32_z(pg, src_vec);\n        \n        svuint32_t res = svsel_u32(mask, rotated, negated);\n        svst1_u32(pg, dst + i, res);\n        \n        i += vl;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32_t r = rotate_bits;\n    uint32_t left_shift_amt = 32 - r;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t src_vec = svld1_u32(pg, src + i);\n        svuint32_t low_bits = svand_u32_x(pg, src_vec, svdup_n_u32(0xF));\n        svbool_t pg_cond = svcmpeq_u32(pg, low_bits, svdup_n_u32(0xF));\n        svuint32_t shift_right_vec = svdup_n_u32(r);\n        svuint32_t shift_left_vec = svdup_n_u32(left_shift_amt);\n        svuint32_t shifted_right = svlsr_u32_x(pg, src_vec, shift_right_vec);\n        svuint32_t shifted_left = svlsl_u32_x(pg, src_vec, shift_left_vec);\n        svuint32_t rotated = svorr_u32_x(pg, shifted_right, shifted_left);\n        svuint32_t false_val = svnot_u32_x(pg, src_vec);\n        svuint32_t result = svsel_u32(pg_cond, rotated, false_val);\n        svst1_u32(pg, dst + i, result);\n        i += svcntp_b32(svptrue_b32(), pg);\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    uint32_t r = rotate_bits % 32;\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t vec = svld1_u32(pg, src + i);\n        svuint32_t low4 = svand_n_u32_z(pg, vec, 15);\n        svbool_t cond = svcmpeq_n_u32(pg, low4, 15);\n        svuint32_t rotated = svorr_u32_z(pg, svlsr_n_u32_z(pg, vec, r), svlsl_n_u32_z(pg, vec, 32 - r));\n        svuint32_t negated = svnot_u32_z(pg, vec);\n        svuint32_t res = svsel_u32(cond, rotated, negated);\n        svst1_u32(pg, dst + i, res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length){\n    if (length == 0) return;\n\n    uint32_t r = rotate_bits % 32;\n    size_t vl = svcntw();\n    size_t i = 0;\n    svuint32_t shift_vec = svdup_n_u32(r);\n    svbool_t pg = svwhilelt_b32(i, length);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t input = svld1_u32(pg, src + i);\n        svuint32_t low4 = svand_n_u32_z(pg, input, 0xF);\n        svbool_t cond = svcmpeq_n_u32(pg, low4, 0xF);\n        svuint32_t negated = svnot_u32_z(pg, input);\n        svuint32_t result = svror_u32_m(negated, cond, input, shift_vec);\n        svst1_u32(pg, dst + i, result);\n        \n        i += vl;\n        pg = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_48_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid matrix_conditional_bit_rotate_simd(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, length);\n    do {\n        svuint32_t vsrc = svld1_u32(pg, src + i);\n        svuint32_t low4 = svand_u32_z(pg, vsrc, svdup_n_u32(0xF));\n        svbool_t cond_mask = svcmpeq_u32(pg, low4, svdup_n_u32(0xF));\n        \n        svuint32_t rotated = svror_u32_z(cond_mask, vsrc, svdup_n_u32(rotate_bits));\n        svbool_t not_cond_mask = svnot_z(pg, cond_mask);\n        svuint32_t negated = svnot_u32_z(not_cond_mask, vsrc);\n        \n        svuint32_t res = svorr_u32_z(pg, rotated, negated);\n        svst1_u32(pg, dst + i, res);\n        \n        uint32_t n = svcntp_b32(pg, pg);\n        i += n;\n        pg = svwhilelt_b32(i, length);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    if (length == 0) \n        return;\n        \n    float abs_epsilon = fabsf(epsilon);\n    svfloat32_t abs_eps_vec = svdup_n_f32(abs_epsilon);\n    svfloat32_t neg_abs_eps_vec = svdup_n_f32(-abs_epsilon);\n    \n    size_t i = 0;\n    do {\n        svbool_t pg = svwhilelt_b32(i, length);\n        uint64_t n = svcntp_b32(svptrue_b32(), pg);\n        if (n == 0) break;\n        \n        svfloat32_t va = svld1(pg, A + i);\n        svfloat32_t vb = svld1(pg, B + i);\n        svfloat32_t diff = svsub_x(pg, va, vb);\n        \n        svbool_t mask_gt = svcmpgt(pg, diff, abs_eps_vec);\n        svbool_t mask_lt = svcmplt(pg, diff, neg_abs_eps_vec);\n        \n        svint32_t res32 = svdup_n_s32(0);\n        res32 = svsel_s32(mask_gt, svdup_n_s32(1), res32);\n        res32 = svsel_s32(mask_lt, svdup_n_s32(-1), res32);\n        \n        svst1b(pg, out + i, res32);\n        \n        i += n;\n    } while (i < length);\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_eps = fabsf(epsilon);\n    float minus_abs_eps = -abs_eps;\n    svfloat32_t abs_eps_vec = svdup_n_f32(abs_eps);\n    svfloat32_t minus_abs_eps_vec = svdup_n_f32(minus_abs_eps);\n    \n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg32 = svwhilelt_b32(i, length);\n        uint64_t vl32 = svcntp_b32(svptrue_b32(), pg32);\n        \n        svfloat32_t a_vec = svld1_f32(pg32, A + i);\n        svfloat32_t b_vec = svld1_f32(pg32, B + i);\n        svfloat32_t diff = svsub_f32_z(pg32, a_vec, b_vec);\n        \n        svbool_t p_positive = svcmpgt_f32(pg32, diff, abs_eps_vec);\n        svbool_t p_negative = svcmplt_f32(pg32, diff, minus_abs_eps_vec);\n        \n        svint32_t res32 = svdup_n_s32(0);\n        res32 = svsel_s32(p_positive, svdup_n_s32(1), res32);\n        res32 = svsel_s32(p_negative, svdup_n_s32(-1), res32);\n        \n        svint16_t res16 = svqxtnb_s32(res32);\n        svint8_t res8 = svqxtnb_s16(res16);\n        \n        svbool_t pg8 = svwhilelt_b8(i, i + vl32);\n        svst1_s8(pg8, out + i, res8);\n        \n        i += vl32;\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = (epsilon < 0) ? -epsilon : epsilon;\n    svfloat32_t v_abs_eps = svdup_n_f32(abs_epsilon);\n    svfloat32_t v_neg_abs_eps = svdup_n_f32(-abs_epsilon);\n    \n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        size_t active_elements = svcntp_b32(svptrue_b32(), pg);\n        \n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        svfloat32_t diff = svsub_f32_z(pg, va, vb);\n        \n        svbool_t mask_gt = svcmpgt_f32(pg, diff, v_abs_eps);\n        svbool_t mask_lt = svcmplt_f32(pg, diff, v_neg_abs_eps);\n        \n        svint32_t v_out32 = svsel_s32(mask_lt, svdup_n_s32(-1), \n                  svsel_s32(mask_gt, svdup_n_s32(1), svdup_n_s32(0)));\n        \n        svint16_t v_out16 = svqxtnb_s32(v_out32);\n        svint8_t v_out = svqxtnb_s16(v_out16);\n        \n        svbool_t pg_out = svwhilelt_b8(i, i + active_elements);\n        svst1_s8(pg_out, &out[i], v_out);\n        \n        i += active_elements;\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = epsilon < 0 ? -epsilon : epsilon;\n    float neg_abs_epsilon = -abs_epsilon;\n\n    size_t i = 0;\n    svbool_t all_mask = svptrue_b32();\n    svfloat32_t v_abs_eps = svdup_n_f32(abs_epsilon);\n    svfloat32_t v_neg_abs_eps = svdup_n_f32(neg_abs_epsilon);\n    svint32_t v_one = svdup_n_s32(1);\n    svint32_t v_neg_one = svdup_n_s32(-1);\n    svint32_t v_zero = svdup_n_s32(0);\n\n    while (i < length) {\n        svbool_t pg = svwhilelt_b32(i, length);\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t b_vec = svld1_f32(pg, B + i);\n        svfloat32_t diff = svsub_f32_z(pg, a_vec, b_vec);\n\n        svbool_t gt_mask = svcmpgt_f32(pg, diff, v_abs_eps);\n        svbool_t lt_mask = svcmplt_f32(pg, diff, v_neg_abs_eps);\n\n        svint32_t tmp = svsel_s32(gt_mask, v_one, v_zero);\n        svint32_t res = svsel_s32(lt_mask, v_neg_one, tmp);\n\n        svst1b_s32(pg, out + i, res);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_49_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid tensor_ternary_compare_simd(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_eps = (epsilon >= 0) ? epsilon : -epsilon;\n    float neg_abs_eps = -abs_eps;\n    size_t i = 0;\n    svbool_t pg32 = svwhilelt_b32(i, length);\n    while (svptest_any(svptrue_b32(), pg32)) {\n        uint64_t vl32 = svcntp_b32(pg32, pg32);\n        svfloat32_t va = svld1(pg32, A + i);\n        svfloat32_t vb = svld1(pg32, B + i);\n        svfloat32_t diff = svsub_x(pg32, va, vb);\n        svfloat32_t v_abs_eps = svdup_n_f32(abs_eps);\n        svfloat32_t v_neg_abs_eps = svdup_n_f32(neg_abs_eps);\n        svbool_t mask_gt = svcmpgt(pg32, diff, v_abs_eps);\n        svbool_t mask_lt = svcmplt(pg32, diff, v_neg_abs_eps);\n        svint32_t s_res = svdup_n_s32(0);\n        s_res = svsel_s32(mask_gt, svdup_n_s32(1), s_res);\n        s_res = svsel_s32(mask_lt, svdup_n_s32(-1), s_res);\n        svint16_t res16 = svqxtn_s32(s_res);\n        svint8_t res8 = svqxtn_s16(res16);\n        svbool_t pg8 = svwhilelt_b8(i, i + vl32);\n        svst1_s8(pg8, out + i, res8);\n        i += vl32;\n        pg32 = svwhilelt_b32(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n#include <stdint.h>\n#include <limits.h>\n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svfloat32_t input = svld1_f32(pg, A + i);\n        svint32_t res = svcvt_s32_x(pg, input);\n        svst1_s32(pg, B + i, res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    uint64_t i = 0;\n    const uint64_t vl = svcntw();\n    svbool_t all_mask = svptrue_b32();\n    \n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t a_vec = svld1(pg, &A[i]);\n        svint32_t b_vec = svcvt_s32_x(pg, a_vec);\n        svst1(pg, &B[i], b_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svint32_t vb = svcvt_s32_f32_x(pg, va);\n        svst1_s32(pg, B + i, vb);\n        i += svcntw();\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    uint64_t i = 0;\n    const uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t input = svld1_f32(pg, &A[i]);\n        svint32_t output = svcvt_s32_x(pg, input);\n        svst1_s32(pg, &B[i], output);\n        i += vl;\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_50_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_to_int_saturate_simd(const float* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svint32_t vb = svcvt_s32_f32_z(pg, va);\n        svst1_s32(pg, B + i, vb);\n        i += svcntw();\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scaling_factor;\n    if (scale >= 0) {\n        uint8_t u_scale = (uint8_t)scale;\n        if (u_scale > 31) u_scale = 31;\n        scaling_factor = 1.0f / (1U << u_scale);\n    } else {\n        uint8_t abs_scale = (uint8_t)(-scale);\n        if (abs_scale > 31) abs_scale = 31;\n        scaling_factor = (float)(1U << abs_scale);\n    }\n\n    if (size == 0) return;\n\n    size_t vl = svcntw();\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, &A[i]);\n        svfloat32_t float_vec = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t scaled_vec = svmul_n_f32_z(pg, float_vec, scaling_factor);\n        svst1_f32(pg, &B[i], scaled_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    size_t offset = 0;\n    size_t vl = svcntw();\n\n    while (offset < size) {\n        svbool_t pg = svwhilelt_b32(offset, size);\n        svint32_t data = svld1_s32(pg, A + offset);\n        svfloat32_t fdata = svcvt_f32_s32_z(pg, data);\n        svfloat32_t scaled_fdata = svmul_n_f32_z(pg, fdata, scale_f);\n        svst1_f32(pg, B + offset, scaled_fdata);\n        offset += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_factor = (float)scale;\n    uint64_t index = 0;\n    uint64_t size_u64 = (uint64_t)size;\n    uint64_t vl = svcntw();\n\n    while (index < size_u64) {\n        svbool_t pg = svwhilelt_b32(index, size_u64);\n        svint32_t a_vec = svld1_s32(pg, A + index);\n        svfloat32_t float_vec = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t scaled_vec = svmul_n_f32_z(pg, float_vec, scale_factor);\n        svst1_f32(pg, B + index, scaled_vec);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    svfloat32_t scale_vec = svdup_n_f32(scale_f);\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svint32_t data = svld1_s32(pg, A + i);\n        svfloat32_t fdata = svcvt_f32_s32_z(pg, data);\n        svfloat32_t scaled = svmul_f32_z(pg, fdata, scale_vec);\n        svst1_f32(pg, B + i, scaled);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_51_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_scaled_simd(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    size_t vl = svcntw();\n    for (size_t i = 0; i < size; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t a_vec = svld1_s32(pg, A + i);\n        svfloat32_t f_vec = svcvt_f32_s32_z(pg, a_vec);\n        svfloat32_t scaled_vec = svmul_f32_z(pg, f_vec, svdup_n_f32(scale_f));\n        svst1_f32(pg, B + i, scaled_vec);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t va = svld1_f32(pg, &A[i]);\n        svfloat32_t vb = svld1_f32(pg, &B[i]);\n        svfloat32_t div = svdiv_f32_x(pg, va, vb);\n        svint32_t res = svcvtas_s32_f32_x(pg, div);\n        svst1_s32(pg, &C[i], res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svfloat32_t vrounded = svrinta_f32_z(pg, vdiv);\n        svint32_t vc = svcvt_s32_f32_z(pg, vrounded);\n        svst1_s32(pg, C + i, vc);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svfloat32_t vrounded = svrintn_f32_z(pg, vdiv);\n        svint32_t vc = svcvt_s32_f32_z(pg, vrounded);\n        svst1_s32(pg, C + i, vc);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = svcntw();\n    for (size_t i = 0; i < size; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svfloat32_t vrounded = svrintn_f32_z(pg, vdiv);\n        svint32_t vc = svcvt_s32_f32_z(pg, vrounded);\n        svst1_s32(pg, C + i, vc);\n    }\n}\n```"}
{"task_id": "SimdBench_52_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid float_div_round_simd(const float* A, const float* B, int32_t* C, size_t size) {\n    size_t vl = svcntw();\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svfloat32_t va = svld1_f32(pg, A + i);\n        svfloat32_t vb = svld1_f32(pg, B + i);\n        svfloat32_t vdiv = svdiv_f32_z(pg, va, vb);\n        svfloat32_t vrounded = svrintn_f32_z(pg, vdiv);\n        svint32_t vc = svcvt_s32_f32_z(pg, vrounded);\n        svst1_s32(pg, C + i, vc);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cfloat>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    if (size == 0) return;\n    const double flt_max_d = (double)FLT_MAX;\n    const double neg_flt_max_d = (double)(-FLT_MAX);\n    size_t i = 0;\n    do {\n        svbool_t pg = svwhilelt_b64(i, size);\n        svfloat64_t va = svld1_f64(pg, &A[i]);\n        svbool_t mask_gt = svcmpgt(pg, va, flt_max_d);\n        svbool_t mask_lt = svcmplt(pg, va, neg_flt_max_d);\n        svfloat64_t clamped = svsel_f64(mask_gt, svdup_n_f64(flt_max_d), va);\n        clamped = svsel_f64(mask_lt, svdup_n_f64(neg_flt_max_d), clamped);\n        svfloat32_t vf = svcvt_f32_f64_z(pg, clamped);\n        svst1_f32(pg, &B[i], vf);\n        i += svcntd();\n    } while (i < size);\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <cfloat>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    uint64_t i = 0;\n    double flt_max = (double)FLT_MAX;\n    double neg_flt_max = (double)(-FLT_MAX);\n    \n    while (i < size) {\n        uint64_t base = i;\n        svbool_t pg64 = svwhilelt_b64(i, size);\n        uint64_t n = svcntp_b64(pg64);\n        if (n == 0) break;\n        i = base + n;\n\n        svfloat64_t vd = svld1(pg64, A + base);\n        svfloat64_t max_vec = svdup_f64(flt_max);\n        svfloat64_t min_vec = svdup_f64(neg_flt_max);\n        \n        vd = svmin_f64_x(pg64, vd, max_vec);\n        vd = svmax_f64_x(pg64, vd, min_vec);\n        \n        svfloat32_t vf = svcvt_f32_f64_x(pg64, vd);\n        svbool_t pg32 = svwhilelt_b32(base, i);\n        svst1(pg32, B + base, vf);\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    if (size == 0) {\n        return;\n    }\n    uint64_t vl = svcntd();\n    size_t i = 0;\n    while (i < size) {\n        uint64_t step = vl;\n        if (size - i < vl) {\n            step = size - i;\n        }\n        svbool_t pg_double = svwhilelt_b64(i, i + step);\n        svfloat64_t va = svld1_f64(pg_double, A + i);\n        svfloat64_t max_vec = svdup_f64(FLT_MAX);\n        svfloat64_t min_vec = svdup_f64(-FLT_MAX);\n        va = svmin_f64_x(pg_double, va, max_vec);\n        va = svmax_f64_x(pg_double, va, min_vec);\n        svfloat32_t vf = svcvt_f32_f64_z(pg_double, va);\n        svbool_t pg_float = svwhilelt_b32(i, i + step);\n        svst1_f32(pg_float, B + i, vf);\n        i += step;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <float.h>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    if (size == 0) \n        return;\n\n    uint64_t vl = svcntd();\n    double pos_bound_val = (double)FLT_MAX;\n    double neg_bound_val = (double)(-FLT_MAX);\n    svfloat64_t pos_bound = svdup_n_f64(pos_bound_val);\n    svfloat64_t neg_bound = svdup_n_f64(neg_bound_val);\n    \n    uint64_t i = 0;\n    while (i < size) {\n        uint64_t remaining = size - i;\n        uint64_t step = (remaining < vl) ? remaining : vl;\n        svbool_t pg_double = svwhilelt_b64(i, i + step);\n        \n        svfloat64_t data = svld1_f64(pg_double, A + i);\n        svfloat64_t clamped = svmin_f64_z(pg_double, data, pos_bound);\n        clamped = svmax_f64_z(pg_double, clamped, neg_bound);\n        \n        svfloat32_t converted = svcvt_f32_f64_x(pg_double, clamped);\n        svbool_t pg_float = svwhilelt_b32(i, i + step);\n        svst1_f32(pg_float, B + i, converted);\n        \n        i += step;\n    }\n}\n```"}
{"task_id": "SimdBench_53_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cfloat>\n\nvoid double_to_float_saturate_simd(const double* A, float* B, size_t size) {\n    if (size == 0) return;\n    uint64_t vl = svcntd();\n    uint64_t i = 0;\n    while (i < size) {\n        uint64_t remaining = size - i;\n        uint64_t n_d = remaining < vl ? remaining : vl;\n        svbool_t pg_d = svwhilelt_b64(i, i + n_d);\n        svbool_t pg_f32 = svwhilelt_b32(0, n_d);\n        svfloat64_t in = svld1_f64(pg_d, A + i);\n        svfloat64_t max_vec = svdup_n_f64(FLT_MAX);\n        svfloat64_t min_vec = svdup_n_f64(-FLT_MAX);\n        svfloat64_t clamped = svmin_f64_m(pg_d, in, max_vec);\n        clamped = svmax_f64_m(pg_d, clamped, min_vec);\n        svfloat32_t out = svcvt_f32_f64_z(pg_f32, clamped);\n        svst1_f32(pg_f32, B + i, out);\n        i += n_d;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b16(i, size);\n    while (svptest_any(svptrue_b16(), pg)) {\n        size_t vl = svcntp_b16(pg, pg);\n        if (vl & 1) {\n            vl--;\n            if (vl == 0) {\n                break;\n            }\n            pg = svwhilelt_b16(i, i + vl);\n        }\n        svint16_t vec16 = svld1_s16(pg, A + i);\n        svint32_t even = svmovlb_s16(vec16);\n        svint32_t odd = svmovlt_s16(vec16);\n        svint32x2_t zipped = svzip_s32(even, odd);\n        svbool_t pg_low = svwhilelt_b32(i, i + vl / 2);\n        svbool_t pg_high = svwhilelt_b32(i + vl / 2, i + vl);\n        svst1_s32(pg_low, B + i, zipped.val[0]);\n        svst1_s32(pg_high, B + i + vl / 2, zipped.val[1]);\n        i += vl;\n        pg = svwhilelt_b16(i, size);\n    }\n    if (i < size) {\n        svbool_t pg_last = svwhilelt_b16(i, i + 1);\n        svint16_t last = svld1_s16(pg_last, A + i);\n        svint32_t last32 = svmovlb_s16(last);\n        svst1_s32(svwhilelt_b32(i, i + 1), B + i, last32);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t data = svld1sh_s32(pg, &A[i]);\n        svst1_s32(pg, &B[i], data);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg;\n    while (1) {\n        pg = svwhilelt_b32_s64(i, size);\n        if (svptest_any(svptrue_b32(), pg) == 0) {\n            break;\n        }\n        svint32_t data = svld1sh_s32(pg, A + i);\n        svst1_s32(pg, B + i, data);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b16(i, size);\n        svint16_t data = svld1_s16(pg, A + i);\n        svint32_t low = svunpackl_s16(data);\n        svint32_t high = svunpackh_s16(data);\n        svbool_t pg32_low = svwhilelt_b32(i, size);\n        svbool_t pg32_high = svwhilelt_b32(i + svcntw(), size);\n        svst1_s32(pg32_low, B + i, low);\n        svst1_s32(pg32_high, B + i + svcntw(), high);\n        i += svcnth();\n    }\n}\n```"}
{"task_id": "SimdBench_54_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int16_to_int32_simd(const int16_t* A, int32_t* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    uint64_t vl = svcntp_b32(pg, pg);\n    while (vl > 0) {\n        svint32_t data = svld1sh_s32(pg, &A[i]);\n        svst1(pg, &B[i], data);\n        i += vl;\n        pg = svwhilelt_b32(i, size);\n        vl = svcntp_b32(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    if (size == 0) return;\n    \n    float range = max_val - min_val;\n    float inv_range = 1.0f / range;\n    \n    uint64_t i = 0;\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t ctrl_vec = svld1_s32(pg, control + i);\n        svbool_t pg_control = svcmpgt(pg, ctrl_vec, 0);\n        \n        svfloat32_t vec = svld1(pg, A + i);\n        vec = svsub_m(pg_control, vec, min_val);\n        vec = svmul_m(pg_control, vec, inv_range);\n        vec = svmax_m(pg_control, vec, 0.0f);\n        vec = svmin_m(pg_control, vec, 1.0f);\n        \n        svst1(pg, B + i, vec);\n        \n        i += vl;\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    if (size == 0) \n        return;\n        \n    float range_val = max_val - min_val;\n    if (range_val == 0.0f) \n        range_val = 1.0f;\n    \n    uint64_t vl = svcntw();\n    size_t i = 0;\n    svfloat32_t min_vec = svdup_n_f32(min_val);\n    svfloat32_t range_vec = svdup_n_f32(range_val);\n    svfloat32_t zero_vec = svdup_n_f32(0.0f);\n    svfloat32_t one_vec = svdup_n_f32(1.0f);\n    \n    while (i < size) {\n        svbool_t Pg = svwhilelt_b32(i, size);\n        svfloat32_t a_vec = svld1_f32(Pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(Pg, &control[i]);\n        \n        svbool_t P_cond = svcmpgt_s32(Pg, ctrl_vec, 0);\n        svfloat32_t normalized = svdiv_f32_z(P_cond, svsub_f32_z(P_cond, a_vec, min_vec), range_vec);\n        normalized = svmax_f32_m(P_cond, normalized, zero_vec);\n        normalized = svmin_f32_m(P_cond, normalized, one_vec);\n        \n        svfloat32_t res_vec = svsel_f32(P_cond, normalized, a_vec);\n        svst1_f32(Pg, &B[i], res_vec);\n        \n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float denom = max_val - min_val;\n    if (denom == 0.0f) {\n        denom = 1.0f;\n    }\n    \n    svfloat32_t min_vec = svdup_n_f32(min_val);\n    svfloat32_t denom_vec = svdup_n_f32(denom);\n    svfloat32_t zero_vec = svdup_n_f32(0.0f);\n    svfloat32_t one_vec = svdup_n_f32(1.0f);\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svint32_t ctrl = svld1_s32(pg, control + i);\n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        \n        svbool_t pg_control = svcmpgt_n_s32(pg, ctrl, 0);\n        \n        svfloat32_t normalized = svdiv_f32_m(pg_control, \n                                            svsub_f32_m(pg_control, a_vec, min_vec), \n                                            denom_vec);\n        \n        svbool_t pg_under = svcmplt_f32(pg_control, normalized, zero_vec);\n        svbool_t pg_over = svcmpgt_f32(pg_control, normalized, one_vec);\n        \n        normalized = svsel_f32(pg_under, zero_vec, normalized);\n        normalized = svsel_f32(pg_over, one_vec, normalized);\n        \n        svfloat32_t result = svsel_f32(pg_control, normalized, a_vec);\n        \n        svst1_f32(pg, B + i, result);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    float denom = max_val - min_val;\n    svfloat32_t min_vec = svdup_n_f32(min_val);\n    svfloat32_t denom_vec = svdup_n_f32(denom);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t a_vec = svld1_f32(pg, &A[i]);\n        svint32_t ctrl_vec = svld1_s32(pg, &control[i]);\n\n        svbool_t cond_pred = svcmpgt_s32(pg, ctrl_vec, 0);\n        svfloat32_t result = a_vec;\n\n        result = svsub_m(cond_pred, result, a_vec, min_vec);\n        result = svdiv_m(cond_pred, result, result, denom_vec);\n        result = svmax_n_m(cond_pred, result, result, 0.0f);\n        result = svmin_n_m(cond_pred, result, result, 1.0f);\n\n        svst1_f32(pg, &B[i], result);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_55_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid conditional_normalize_simd(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    float range = max_val - min_val;\n    float inv_range = 1.0f / range;\n    \n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t inv_range_vec = svdup_f32(inv_range);\n    svfloat32_t zero_vec = svdup_f32(0.0f);\n    svfloat32_t one_vec = svdup_f32(1.0f);\n    \n    size_t vl = svcntw();\n    for (size_t i = 0; i < size; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t ctrl_vec = svld1_s32(pg, control + i);\n        svbool_t cond_pg = svcmpgt(pg, ctrl_vec, 0);\n        \n        svfloat32_t a_vec = svld1_f32(pg, A + i);\n        svfloat32_t res = svsub_f32_m(cond_pg, a_vec, a_vec, min_vec);\n        res = svmul_f32_m(cond_pg, res, res, inv_range_vec);\n        res = svmax_f32_m(cond_pg, res, res, zero_vec);\n        res = svmin_f32_m(cond_pg, res, res, one_vec);\n        \n        svst1_f32(pg, B + i, res);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t data = svld1_u32(pg, A + i);\n        svuint32_t shifted = svlsr_n_u32_x(pg, data, 16);\n        svfloat32_t converted = svcvt_f32_u32_z(pg, shifted);\n        svfloat32_t sqrt_val = svsqrt_f32_z(pg, converted);\n        svst1_f32(pg, B + i, sqrt_val);\n        i += vl;\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t data = svld1_u32(pg, &A[i]);\n        svuint32_t high_bits = svlsr_n_u32_x(pg, data, 16);\n        svfloat32_t float_data = svcvt_f32_u32_x(pg, high_bits);\n        svfloat32_t sqrt_data = svsqrt_f32_x(pg, float_data);\n        svst1_f32(pg, &B[i], sqrt_data);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    uint64_t i = 0;\n    const uint64_t vl = svcntw();\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t data = svld1_u32(pg, A + i);\n        svuint32_t high_bits = svlsr_n_u32_x(pg, data, 16);\n        svfloat32_t fdata = svcvt_f32_u32_x(pg, high_bits);\n        svfloat32_t sqrt_data = svsqrt_f32_x(pg, fdata);\n        svst1_f32(pg, B + i, sqrt_data);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    uint64_t vl = svcntw();\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t data = svld1_u32(pg, A + i);\n        svuint32_t high_bits = svlsr_n_u32_x(pg, data, 16);\n        svfloat32_t float_vals = svcvt_f32_u32_x(pg, high_bits);\n        svfloat32_t sqrt_vals = svsqrt_f32_x(pg, float_vals);\n        svst1_f32(pg, B + i, sqrt_vals);\n        i += vl;\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_56_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_to_float_sqrt_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svuint32_t data = svld1_u32(pg, &A[i]);\n        svuint32_t high_bits = svlsr_n_u32_z(pg, data, 16);\n        svfloat32_t float_vals = svcvt_f32_u32_z(pg, high_bits);\n        svfloat32_t sqrt_vals = svsqrt_f32_z(pg, float_vals);\n        svst1_f32(pg, &B[i], sqrt_vals);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    size_t vl = svcntw();\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svuint32_t in_vec = svld1_u32(pg, A + i);\n        svfloat32_t out_vec = svreinterpret_f32_u32(in_vec);\n        svst1_f32(pg, B + i, out_vec);\n        i += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svuint32_t data = svld1_u32(pg, A + i);\n        svfloat32_t float_data = svreinterpret_f32_u32(data);\n        svst1_f32(pg, B + i, float_data);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t a_vec = svld1_u32(pg, &A[i]);\n        svfloat32_t b_vec = svreinterpret_f32_u32(a_vec);\n        svst1_f32(pg, &B[i], b_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svuint32_t in_vec = svld1_u32(pg, A + i);\n        svfloat32_t out_vec = svreinterpret_f32_u32(in_vec);\n        svst1_f32(pg, B + i, out_vec);\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b32(), pg));\n}\n```"}
{"task_id": "SimdBench_57_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid int_bits_to_float_simd(const uint32_t* A, float* B, size_t size) {\n    size_t i = 0;\n    const size_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t in_vec = svld1_u32(pg, A + i);\n        svfloat32_t out_vec = svreinterpret_f32_u32(in_vec);\n        svst1_f32(pg, B + i, out_vec);\n        i += vl;\n        pg = svwhilelt_b32(i, size);\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) \n        return;\n    \n    diff[0] = 0.0f;\n    if (size <= 1) \n        return;\n    \n    uint64_t vl = svcntw();\n    size_t index = 1;\n    while (index < size) {\n        svbool_t pg = svwhilelt_b32(index, size);\n        svuint8_t cond_vec = svld1_u8(pg, (const uint8_t*)(cond + index));\n        svbool_t cond_mask = svcmpne(pg, cond_vec, 0);\n        svint32_t a_curr = svld1(pg, A + index);\n        svint32_t a_prev = svld1(pg, A + index - 1);\n        svint32_t diff_i32 = svsub_x(pg, a_curr, a_prev);\n        svfloat32_t result = svcvt_f32_z(cond_mask, diff_i32);\n        svst1(pg, diff + index, result);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    if (size <= 1) \n        return;\n    \n    uint64_t vl = svcntw();\n    size_t index = 1;\n    \n    while (index < size) {\n        svbool_t pg = svwhilelt_b32(index, size);\n        svint32_t cond_val = svld1sb_s32(pg, cond + index);\n        svbool_t cond_active = svcmpne(pg, cond_val, 0);\n        \n        svint32_t current = svld1_s32(pg, A + index);\n        svint32_t prev = svld1_s32(pg, A + index - 1);\n        \n        svint32_t diff_val = svsub_s32_z(cond_active, current, prev);\n        svfloat32_t diff_float = svcvt_f32_s32_x(pg, diff_val);\n        \n        svst1_f32(pg, diff + index, diff_float);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    if (size <= 1) return;\n\n    uint64_t i = 1;\n    svbool_t pg = svwhilelt_b32(i, size);\n    do {\n        svint32_t cond_vec = svld1sb_s32(pg, (const int8_t*)(cond + i));\n        svbool_t pg_cond = svcmpne(pg, cond_vec, 0);\n\n        svint32_t curr_A = svld1(pg, A + i);\n        svint32_t prev_A = svld1(pg, A + i - 1);\n\n        svint32_t diff_int = svsub_z(pg_cond, curr_A, prev_A);\n        svfloat32_t diff_float = svcvt_f32_x(pg, diff_int);\n        svst1(pg, diff + i, diff_float);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    } while (svptest_any(svptrue_b8(), pg));\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n    diff[0] = 0.0f;\n    if (size <= 1) {\n        return;\n    }\n\n    size_t index = 1;\n    uint64_t vl = svcntw();\n\n    while (index < size) {\n        svbool_t pg = svwhilelt_b32(index, size);\n        svint32_t cond_vec = svld1sb_s32(pg, (const int8_t*)(cond + index));\n        svbool_t cond_pred = svcmpne(pg, cond_vec, 0);\n        svint32_t currentA = svld1_s32(pg, A + index);\n        svint32_t prevA = svld1_s32(pg, A + index - 1);\n        svint32_t diff_int = svsub_s32_z(pg, currentA, prevA);\n        svfloat32_t diff_float = svcvt_f32_s32_z(pg, diff_int);\n        svfloat32_t zeros = svdup_f32_z(pg, 0.0f);\n        svfloat32_t result = svsel_f32(cond_pred, diff_float, zeros);\n        svst1_f32(pg, diff + index, result);\n        index += vl;\n    }\n}\n```"}
{"task_id": "SimdBench_58_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid conditional_diff_simd(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) {\n        return;\n    }\n    diff[0] = 0.0f;\n    if (size == 1) {\n        return;\n    }\n\n    size_t i = 1;\n    while (i < size) {\n        svbool_t pg = svwhilelt_b32(i, size);\n        svint32_t cond_vec = svld1sb_s32(pg, (const int8_t*)(cond + i));\n        svbool_t pg_cond = svcmpne(pg, cond_vec, 0);\n        svint32_t curr = svld1(pg, A + i);\n        svint32_t prev = svld1(pg, A + i - 1);\n        svint32_t diff_int = svsub_z(pg, curr, prev);\n        svfloat32_t diff_float = svcvt_f32_x(pg, diff_int);\n        svfloat32_t zeros = svdup_n_f32(0.0f);\n        svfloat32_t res = svsel_f32(pg_cond, diff_float, zeros);\n        svst1(pg, diff + i, res);\n        uint64_t n = svcntp_b32(pg, pg);\n        i += n;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    svuint64_t mask = svdup_n_u64(0xFFFFFFFF00000000ULL);\n    size_t i = 0;\n    while (i < length) {\n        svbool_t pg64 = svwhilelt_b64(i, length);\n        uint64_t n = svcntp_b64(pg64, pg64);\n        if (n == 0) break;\n        svuint64_t data = svld1uw_u64(pg64, src + i);\n        svuint64_t result = svorr_u64_z(pg64, data, mask);\n        svst1_u64(pg64, dst + i, result);\n        i += n;\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint64_t i = 0;\n    svbool_t pg64 = svwhilelt_b64(i, length);\n    svbool_t all_true = svptrue_b64();\n    while (svptest_any(all_true, pg64)) {\n        svuint64_t vec = svld1uw_u64(pg64, src + i);\n        svuint64_t high_bits = svdup_u64(0xFFFFFFFF00000000ULL);\n        svuint64_t res = svorr_u64_x(pg64, vec, high_bits);\n        svst1_u64(pg64, dst + i, res);\n        i += svcntp_b64(all_true, pg64);\n        pg64 = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b64(index, length);\n    uint64_t pattern_val = 0xFFFFFFFF00000000ULL;\n    svuint64_t pattern_vec = svdup_u64(pattern_val);\n    size_t vl = svcntd();\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t data = svld1uw_u64(pg, &src[index]);\n        svuint64_t result = svorr_u64_z(pg, data, pattern_vec);\n        svst1_u64(pg, &dst[index], result);\n        index += vl;\n        pg = svwhilelt_b64(index, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    size_t i = 0;\n    svuint64_t pattern = svdup_n_u64(0xFFFFFFFF00000000ULL);\n    svbool_t pg64 = svwhilelt_b64(i, length);\n    while (svptest_any(svptrue_b64(), pg64)) {\n        svuint64_t vec = svld1uw_u64(pg64, src + i);\n        svuint64_t res = svorr_u64_z(pg64, vec, pattern);\n        svst1_u64(pg64, dst + i, res);\n        i += svcntd();\n        pg64 = svwhilelt_b64(i, length);\n    }\n}\n```"}
{"task_id": "SimdBench_59_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid widening_uint_simd(const uint32_t* src, uint64_t* dst, size_t length) {\n    uint64_t i = 0;\n    const uint64_t pattern = 0xFFFFFFFF00000000ULL;\n    svuint64_t pattern_vec = svdup_n_u64(pattern);\n    \n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svuint64_t data = svld1uw_u64(pg, src + i);\n        svuint64_t result = svorr_u64_x(pg, data, pattern_vec);\n        svst1_u64(pg, dst + i, result);\n        i += svcntp_b64(pg, pg);\n    }\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n    do {\n        svint64_t indices = svld1sh_s64(pg, &index[i]);\n        svfloat64_t gathered = svld1_gather_index(pg, vec, indices, 3);\n        sum_vec = svadd_m(pg, sum_vec, gathered);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(svptrue_b64(), pg));\n    \n    return svaddv(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) {\n        return 0.0;\n    }\n    uint64_t i = 0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    while (i < length) {\n        svbool_t pg = svwhilelt_b64(i, length);\n        svint64_t indices = svld1sh_s64(pg, index + i);\n        svfloat64_t data = svld1_gather_s64index_f64(pg, vec, indices);\n        sum_vec = svadd_f64_m(pg, sum_vec, data);\n        i += svcntd();\n    }\n    svbool_t pg_all = svptrue_b64();\n    return svaddv_f64(pg_all, sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) {\n        return 0.0;\n    }\n\n    svfloat64_t sum = svdup_f64(0.0);\n    uint64_t i = 0;\n    svbool_t pg64 = svwhilelt_b64(i, length);\n    svbool_t pg16 = svwhilelt_b16(i, length);\n\n    while (svptest_any(svptrue_b64(), pg64)) {\n        svint16_t index_vec = svld1_s16(pg16, index + i);\n        svint64_t index_vec_64 = svcvt_s64_s16_z(pg64, index_vec);\n        svfloat64_t gathered = svld1_gather_s64index_f64(pg64, vec, index_vec_64);\n        sum = svadd_f64_m(pg64, sum, gathered);\n        uint64_t n = svcntp_b64(svptrue_b64(), pg64);\n        i += n;\n        pg64 = svwhilelt_b64(i, length);\n        pg16 = svwhilelt_b16(i, length);\n    }\n\n    return svaddv_f64(svptrue_b64(), sum);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) \n        return 0.0;\n\n    svbool_t all_true = svptrue_b64();\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, length);\n\n    do {\n        svint64_t indices = svld1sh_s64(pg, index + i);\n        svfloat64_t values = svld1_gather_s64index_f64(pg, vec, indices);\n        sum_vec = svadd_f64_m(pg, sum_vec, values);\n        i += svcntd();\n        pg = svwhilelt_b64(i, length);\n    } while (svptest_any(all_true, pg));\n\n    return svaddv_f64(all_true, sum_vec);\n}\n```"}
{"task_id": "SimdBench_60_SVE", "completion": "```c\n#include <arm_sve.h> \n\ndouble indexed_sum_simd(const double* vec, const int16_t* index, size_t length) {\n    if (length == 0) \n        return 0.0;\n\n    size_t i = 0;\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    const size_t vec_length = svcntd();\n\n    while (i < length) {\n        size_t step = length - i;\n        if (step > vec_length) \n            step = vec_length;\n\n        svbool_t pg64 = svwhilelt_b64(i, i + step);\n        svbool_t pg16 = svwhilelt_b16(0, step);\n\n        svint16_t indices_16 = svld1_s16(pg16, index + i);\n        svint64_t indices_64 = svsxtw_s64(pg16, indices_16);\n        svfloat64_t gathered = svld1_gather_s64index_f64(pg64, vec, indices_64);\n\n        sum_vec = svadd_m(pg64, sum_vec, gathered);\n        i += step;\n    }\n\n    return svaddv(svptrue_b64(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t out_size = input_size - kernel_size + 1;\n    size_t vl = svcntd();\n\n    for (size_t i = 0; i < out_size; i++) {\n        size_t j = 0;\n        svbool_t pg = svwhilelt_b64(j, out_size);\n        while (svptest_any(svptrue_b64(), pg)) {\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t m = 0; m < kernel_size; m++) {\n                for (size_t n = 0; n < kernel_size; n++) {\n                    const double *input_ptr = input + (i + m) * input_size + j + n;\n                    svfloat64_t input_vec = svld1_f64(pg, input_ptr);\n                    double k_val = kernel[m * kernel_size + n];\n                    svfloat64_t kernel_vec = svdup_f64(k_val);\n                    acc = svmla_f64_m(pg, acc, kernel_vec, input_vec);\n                }\n            }\n\n            svbool_t negative = svcmplt_f64(pg, acc, 0.0);\n            acc = svsel_f64(negative, svdup_f64(0.0), acc);\n\n            svst1_f64(pg, output + i * out_size + j, acc);\n            j += vl;\n            pg = svwhilelt_b64(j, out_size);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h>\n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t out_size = input_size - kernel_size + 1;\n    if (out_size == 0) {\n        return;\n    }\n\n    uint64_t vl = svcntd();\n\n    for (size_t i = 0; i < out_size; i++) {\n        for (size_t j = 0; j < out_size; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, out_size);\n            svfloat64_t acc = svdup_f64(0.0);\n\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    svfloat64_t in_vec = svld1(pg, input + (i + ki) * input_size + j + kj);\n                    double k_val = kernel[ki * kernel_size + kj];\n                    acc = svmla_n_f64_m(pg, acc, in_vec, k_val);\n                }\n            }\n\n            svfloat64_t zero = svdup_f64(0.0);\n            svfloat64_t result = svmax_f64_z(pg, acc, zero);\n            svst1(pg, output + i * out_size + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            svfloat64_t accum = svdup_f64(0.0);\n            \n            for (size_t kr = 0; kr < kernel_size; kr++) {\n                for (size_t kc = 0; kc < kernel_size; kc++) {\n                    const double* input_ptr = input + (i + kr) * input_size + j + kc;\n                    svfloat64_t input_vec = svld1(pg, input_ptr);\n                    double kernel_val = kernel[kr * kernel_size + kc];\n                    svfloat64_t kernel_vec = svdup_f64(kernel_val);\n                    accum = svmla_m(pg, accum, input_vec, kernel_vec);\n                }\n            }\n            \n            svfloat64_t zero = svdup_f64(0.0);\n            accum = svmax_f64_z(pg, accum, zero);\n            \n            double* output_ptr = output + i * output_size + j;\n            svst1(pg, output_ptr, accum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t out_size = input_size - kernel_size + 1;\n    svfloat64_t zero = svdup_f64(0.0);\n    size_t vl = svcntd();\n    \n    for (size_t i = 0; i < out_size; i++) {\n        for (size_t j = 0; j < out_size; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, out_size);\n            svfloat64_t acc = svdup_f64(0.0);\n            \n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    double kernel_val = kernel[k * kernel_size + l];\n                    const double* in_ptr = input + (i + k) * input_size + j + l;\n                    svfloat64_t in_vec = svld1(pg, in_ptr);\n                    acc = svmla_f64_x(pg, acc, in_vec, svdup_f64(kernel_val));\n                }\n            }\n            \n            svbool_t positive = svcmpgt(pg, acc, zero);\n            svfloat64_t result = svsel(positive, acc, zero);\n            svst1(pg, output + i * out_size + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61_SVE", "completion": "```c\n#include <arm_sve.h> \n\nvoid simple_conv2d_simd(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    if (output_size == 0) return;\n    \n    size_t vl = svcntd();\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j += vl) {\n            svbool_t pg = svwhilelt_b64(j, output_size);\n            svfloat64_t acc = svdup_f64(0.0);\n            \n            for (size_t kr = 0; kr < kernel_size; kr++) {\n                const double* input_row = input + (i + kr) * input_size;\n                for (size_t kc = 0; kc < kernel_size; kc++) {\n                    double k_val = kernel[kr * kernel_size + kc];\n                    svfloat64_t vec = svld1(pg, input_row + j + kc);\n                    acc = svmla_n_f64_x(pg, acc, vec, k_val);\n                }\n            }\n            \n            svfloat64_t zero = svdup_f64(0.0);\n            svfloat64_t result = svmax_f64_z(pg, acc, zero);\n            svst1(pg, output + i * output_size + j, result);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2) {\n        return false;\n    }\n\n    uint64_t num_pairs = n - 1;\n    uint64_t index = 0;\n    uint64_t vl = svcntd();\n\n    while (index < num_pairs) {\n        svbool_t pg = svwhilelt_b64(index, num_pairs);\n        svfloat64_t current_vec = svld1(pg, &numbers[index]);\n        svfloat64_t next_vec = svld1(pg, &numbers[index + 1]);\n        svfloat64_t abs_diff = svabd_z(pg, current_vec, next_vec);\n        svfloat64_t thresh_vec = svdup_f64_z(pg, threshold);\n        svbool_t close_pred = svcmplt_f64(pg, abs_diff, thresh_vec);\n\n        if (svptest_any(pg, close_pred)) {\n            return true;\n        }\n\n        index += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) {\n        return false;\n    }\n\n    const double* data = numbers.data();\n    uint64_t len = n - 1;\n    uint64_t i = 0;\n    uint64_t vl = svcntd();\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        svfloat64_t vec1 = svld1(pg, data + i);\n        svfloat64_t vec2 = svld1(pg, data + i + 1);\n        svfloat64_t diff = svabs_f64_x(pg, svsub_f64_x(pg, vec1, vec2));\n        svbool_t lt = svcmplt_f64(pg, diff, thresh_vec);\n\n        if (svptest_any(pg, lt)) {\n            return true;\n        }\n        i += vl;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n <= 1) {\n        return false;\n    }\n\n    const double *base_ptr = numbers.data();\n    const double *next_ptr = base_ptr + 1;\n    size_t num_pairs = n - 1;\n    bool found = false;\n\n    svbool_t pg = svwhilelt_b64(0, num_pairs);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t current_vec = svld1(pg, base_ptr);\n        svfloat64_t next_vec = svld1(pg, next_ptr);\n        svfloat64_t diff_vec = svabd_f64_z(pg, current_vec, next_vec);\n        svbool_t close_mask = svcmplt_f64(pg, diff_vec, svdup_f64_z(pg, threshold));\n\n        if (svptest_any(pg, close_mask)) {\n            found = true;\n            break;\n        }\n\n        size_t processed = svcntp_b64(svptrue_b64(), pg);\n        base_ptr += processed;\n        next_ptr += processed;\n        num_pairs -= processed;\n        pg = svwhilelt_b64(0, num_pairs);\n    }\n\n    return found;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    std::vector<double> sorted = numbers;\n    std::sort(sorted.begin(), sorted.end());\n    uint64_t n = sorted.size();\n    uint64_t num_pairs = n - 1;\n    svbool_t all_true = svptrue_b64();\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n    uint64_t i = 0;\n    while (i < num_pairs) {\n        svbool_t pg = svwhilelt_b64(i, num_pairs);\n        uint64_t active_count = svcntp_b64(all_true, pg);\n        svfloat64_t current = svld1(pg, &sorted[i]);\n        svfloat64_t next = svld1(pg, &sorted[i+1]);\n        svfloat64_t diff = svsub_x(pg, next, current);\n        svbool_t lt = svcmplt(pg, diff, thresh_vec);\n        if (svptest_any(all_true, lt)) {\n            return true;\n        }\n        i += active_count;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62_SVE", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_sve.h>\n\nbool has_close_elements_simd(const std::vector<double> & numbers, double threshold) {\n    size_t n = numbers.size();\n    if (n < 2 || threshold <= 0.0) {\n        return false;\n    }\n\n    std::vector<double> sorted(numbers);\n    std::sort(sorted.begin(), sorted.end());\n\n    const double* data = sorted.data();\n    size_t i = 0;\n    size_t vl = svcntd();\n    svfloat64_t thresh_vec = svdup_f64(threshold);\n    svbool_t all_true = svptrue_b64();\n\n    while (i < n - 1) {\n        svbool_t pg = svwhilelt_b64(i, n - 1);\n        svfloat64_t current = svld1(pg, data + i);\n        svfloat64_t next = svld1(pg, data + i + 1);\n        svfloat64_t diff = svsub_z(pg, next, current);\n        svbool_t close = svcmplt_f64(pg, diff, thresh_vec);\n        if (svptest_any(all_true, close)) {\n            return true;\n        }\n        i += vl;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t i = 0;\n    int64_t len = operations.size();\n    int64_t base = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        uint64_t n = svcntp_b32(svptrue_b32(), pg);\n        if (n == 0) break;\n        if (base < 0) return true;\n        \n        svint32_t vec = svld1_s32(pg, &operations[i]);\n        int32_t temp[256];\n        svst1_s32(pg, temp, vec);\n        \n        for (uint64_t j = 0; j < n; j++) {\n            base += temp[j];\n            if (base < 0) {\n                return true;\n            }\n        }\n        i += n;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool below_zero_simd(std::vector<int> operations) {\n    int64_t n = operations.size();\n    if (n == 0) {\n        return false;\n    }\n    int64_t i = 0;\n    int32_t current_sum = 0;\n    const int32_t *data = operations.data();\n\n    svbool_t all_true = svptrue_b32();\n    uint64_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t chunk = svld1_s32(pg, data + i);\n        svint32_t scan = chunk;\n        svint32_t indices = svindex_s32(0, 1);\n\n        for (int stride = 1; stride < vl; stride *= 2) {\n            svbool_t mask_stride = svcmpge_s32(all_true, indices, svdup_s32(stride));\n            svbool_t mask = svand_b_z(all_true, pg, mask_stride);\n            svint32_t zeros = svdup_s32(0);\n            svint32_t shifted = svext_s32(zeros, scan, vl - stride);\n            scan = svadd_s32_m(mask, scan, shifted);\n        }\n\n        svint32_t total = svadd_s32_z(pg, svdup_s32(current_sum), scan);\n        svbool_t negative = svcmplt_s32(pg, total, svdup_s32(0));\n        if (svptest_any(all_true, negative)) {\n            return true;\n        }\n\n        current_sum += svlasta_s32(pg, scan);\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool below_zero_simd(std::vector<int> operations) {\n    uint64_t n = operations.size();\n    if (n == 0) {\n        return false;\n    }\n\n    int32_t current_balance = 0;\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &operations[i]);\n        svint32x2_t scan_result = svscan_add_s32(pg, current_balance, data);\n        \n        svbool_t negative = svcmplt_s32(pg, scan_result.v0, 0);\n        if (svptest_any(pg, negative)) {\n            return true;\n        }\n        \n        current_balance = svlastb_s32(pg, scan_result.v1);\n        i += vl;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int n = operations.size();\n    if (n == 0) return false;\n    \n    int base = 0;\n    int i = 0;\n    uint64_t vl = svcntw();\n    if (vl == 0) {\n        for (; i < n; i++) {\n            base += operations[i];\n            if (base < 0) return true;\n        }\n        return false;\n    }\n\n    for (; i + vl <= n; i += vl) {\n        svint32_t v = svld1_s32(svptrue_b32(), &operations[i]);\n        svint32_t idx = svindex_s32(0, 1);\n        svint32_t p = v;\n\n        for (int offset = 1; offset < vl; offset *= 2) {\n            svint32_t shifted_idx = svsub_s32_z(svptrue_b32(), idx, svdup_n_s32(offset));\n            svbool_t valid = svcmpge_s32(svptrue_b32(), shifted_idx, svdup_n_s32(0));\n            svuint32_t shifted_idx_u = svreinterpret_u32_s32(shifted_idx);\n            svint32_t shifted_p = svtbl_s32(p, shifted_idx_u);\n            shifted_p = svsel_s32(valid, shifted_p, svdup_n_s32(0));\n            p = svadd_s32_z(svptrue_b32(), p, shifted_p);\n        }\n\n        svint32_t base_vec = svdup_n_s32(base);\n        svint32_t chunk_prefix = svadd_s32_z(svptrue_b32(), base_vec, p);\n        svbool_t negative = svcmplt_s32(svptrue_b32(), chunk_prefix, svdup_n_s32(0));\n        if (svptest_any(svptrue_b32(), negative)) {\n            return true;\n        }\n\n        base += svaddv_s32(svptrue_b32(), v);\n    }\n\n    for (; i < n; i++) {\n        base += operations[i];\n        if (base < 0) return true;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_63_SVE", "completion": "To solve this problem, we need to determine if at any point during a series of bank transactions the account balance falls below zero. The transactions are provided as a vector of integers, where positive values represent deposits and negative values represent withdrawals. The solution must leverage the Arm Scalable Vector Extension (SVE) intrinsics to process the transactions efficiently in parallel.\n\n### Approach\n1. **Initialization**: Start with an initial balance of zero.\n2. **Vector Processing**: Process the transactions in chunks using SVE vectors. The size of each chunk is determined by the SVE vector length for 32-bit integers.\n3. **Active Lanes Handling**: For each chunk, create a predicate to handle only the active lanes (transactions within the current chunk).\n4. **Sequential Processing within Chunk**: For each active lane in the chunk:\n   - Extract the transaction value using `svfirst_s32` to get the next transaction in the chunk.\n   - Update the running balance by adding the transaction value.\n   - Immediately check if the updated balance is negative. If it is, return `true`.\n5. **Termination**: If after processing all transactions the balance never drops below zero, return `false`.\n\n### Solution Code\n```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool below_zero_simd(std::vector<int> operations) {\n    int32_t base = 0;\n    size_t i = 0;\n    size_t n = operations.size();\n    unsigned int vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &operations[i]);\n\n        svbool_t pg_remaining = pg;\n        uint64_t active_count = svcntp_b32(pg, pg);\n        for (uint64_t j = 0; j < active_count; j++) {\n            int32_t element = svfirst_s32(pg_remaining, vec);\n            base += element;\n            if (base < 0) {\n                return true;\n            }\n            pg_remaining = svnext_b32(pg_remaining);\n        }\n\n        i += vl;\n    }\n    return false;\n}\n```\n\n### Explanation\n1. **Initialization**: The variable `base` is initialized to zero, representing the starting balance of the account.\n2. **Vector Processing Loop**: The loop processes transactions in chunks of size `vl` (the SVE vector length for 32-bit integers). The loop continues until all transactions are processed.\n3. **Predicate Handling**: The predicate `pg` is created using `svwhilelt_b32` to identify active lanes within the current chunk. This ensures only valid transactions are processed.\n4. **Loading Transactions**: The `svld1_s32` function loads the transactions from memory into an SVE vector based on the active lanes specified by `pg`.\n5. **Processing Active Lanes**: For each active lane in the chunk:\n   - The first active transaction is extracted using `svfirst_s32`.\n   - The running balance (`base`) is updated by adding the transaction value.\n   - If the updated balance is negative, the function immediately returns `true`.\n   - The predicate `pg_remaining` is updated to exclude the processed transaction using `svnext_b32`.\n6. **Termination**: If all transactions are processed without the balance dropping below zero, the function returns `false`.\n\nThis approach efficiently processes transactions in parallel using SVE intrinsics while ensuring correctness by sequentially checking the balance after each transaction within the vector chunks. The solution leverages the capabilities of SVE to handle large datasets with optimal performance."}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double total = 0.0;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, n);\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    \n    do {\n        svfloat64_t data = svld1_f64(pg, &numbers[i]);\n        sum_vec = svadd_f64_z(pg, sum_vec, data);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    total = svaddv_f64(svptrue_b64(), sum_vec);\n    double mean = total / static_cast<double>(n);\n\n    double abs_dev_sum = 0.0;\n    i = 0;\n    pg = svwhilelt_b64(i, n);\n    svfloat64_t abs_sum_vec = svdup_f64(0.0);\n    svfloat64_t mean_vec = svdup_f64(mean);\n\n    do {\n        svfloat64_t data = svld1_f64(pg, &numbers[i]);\n        svfloat64_t dev = svsub_f64_z(pg, data, mean_vec);\n        svfloat64_t abs_dev = svabs_f64_z(pg, dev);\n        abs_sum_vec = svadd_f64_z(pg, abs_sum_vec, abs_dev);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    } while (svptest_any(svptrue_b64(), pg));\n\n    abs_dev_sum = svaddv_f64(svptrue_b64(), abs_sum_vec);\n    return abs_dev_sum / static_cast<double>(n);\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    if (numbers.empty()) {\n        return 0.0;\n    }\n    size_t n = numbers.size();\n    double mean = 0.0;\n    double mad = 0.0;\n    uint64_t vl = svcntd();\n    svbool_t all_true = svptrue_b64();\n\n    svfloat64_t sum_vec = svdup_f64(0.0);\n    for (uint64_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t data = svld1(pg, &numbers[i]);\n        sum_vec = svadd_m(pg, sum_vec, data);\n    }\n    double total = svaddv(all_true, sum_vec);\n    mean = total / n;\n\n    svfloat64_t mean_vec = svdup_f64(mean);\n    svfloat64_t abs_sum_vec = svdup_f64(0.0);\n    for (uint64_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svfloat64_t data = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svsub_x(pg, data, mean_vec);\n        svfloat64_t abs_diff = svabs_x(pg, diff);\n        abs_sum_vec = svadd_m(pg, abs_sum_vec, abs_diff);\n    }\n    double total_abs = svaddv(all_true, abs_sum_vec);\n    mad = total_abs / n;\n    return mad;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    uint64_t n = numbers.size();\n    if (n == 0) return 0.0;\n\n    double total = 0.0;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b64(i, n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        total = svadda_f64(pg, total, vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n    double mean = total / n;\n\n    double abs_sum = 0.0;\n    i = 0;\n    pg = svwhilelt_b64(i, n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t vec = svld1(pg, &numbers[i]);\n        svfloat64_t diff = svsub_f64_x(pg, vec, svdup_n_f64(mean));\n        svfloat64_t abs_diff = svabs_f64_x(pg, diff);\n        abs_sum = svadda_f64(pg, abs_sum, abs_diff);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n\n    return abs_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers){\n    uint64_t n = numbers.size();\n    if (n == 0) return 0.0;\n    \n    double* data_ptr = numbers.data();\n    uint64_t vl = svcntd();\n    uint64_t i = 0;\n    \n    svfloat64_t sum_vec = svdup_f64(0.0);\n    svbool_t pg = svwhilelt_b64(i, n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t data = svld1(pg, data_ptr + i);\n        sum_vec = svadd_m(pg, sum_vec, data);\n        i += vl;\n        pg = svwhilelt_b64(i, n);\n    }\n    double total_sum = svaddv(svptrue_b64(), sum_vec);\n    double mean_val = total_sum / n;\n    \n    i = 0;\n    svfloat64_t abs_sum_vec = svdup_f64(0.0);\n    svfloat64_t mean_vec = svdup_f64(mean_val);\n    pg = svwhilelt_b64(i, n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t data = svld1(pg, data_ptr + i);\n        svfloat64_t dev = svsub_z(pg, data, mean_vec);\n        dev = svabs_z(pg, dev);\n        abs_sum_vec = svadd_m(svptrue_b64(), abs_sum_vec, dev);\n        i += vl;\n        pg = svwhilelt_b64(i, n);\n    }\n    double total_abs_sum = svaddv(svptrue_b64(), abs_sum_vec);\n    return total_abs_sum / n;\n}\n```"}
{"task_id": "SimdBench_64_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation_simd(std::vector<double> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return 0.0;\n    }\n    \n    double* data = numbers.data();\n    double total_sum = 0.0;\n    double total_abs_diff = 0.0;\n    uint64_t i = 0;\n    \n    // Calculate sum of all elements\n    svbool_t pg = svwhilelt_b64(i, n);\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t input_vec = svld1(pg, data + i);\n        total_sum += svaddv(pg, input_vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n    \n    double mean = total_sum / n;\n    svfloat64_t mean_vec = svdup_f64(mean);\n    i = 0;\n    pg = svwhilelt_b64(i, n);\n    \n    // Calculate sum of absolute differences from mean\n    while (svptest_any(svptrue_b64(), pg)) {\n        svfloat64_t input_vec = svld1(pg, data + i);\n        svfloat64_t diff_vec = svsub_z(pg, input_vec, mean_vec);\n        svfloat64_t abs_vec = svabs_z(pg, diff_vec);\n        total_abs_diff += svaddv(pg, abs_vec);\n        i += svcntd();\n        pg = svwhilelt_b64(i, n);\n    }\n    \n    return total_abs_diff / n;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    std::vector<int> output;\n    if (n == 0) {\n        return output;\n    }\n    output.resize(2 * n - 1);\n    output[0] = numbers[0];\n    if (n == 1) {\n        return output;\n    }\n\n    uint64_t i = 1;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1(pg, &numbers[i]);\n        svint32_t indices = svindex_s32(2*i, 2);\n        svst1_scatter_s32index(pg, output.data(), indices, data);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    uint64_t j = 0;\n    svbool_t pg_del = svwhilelt_b32(j, n-1);\n    while (svptest_any(svptrue_b32(), pg_del)) {\n        svint32_t indices_del = svindex_s32(2*j+1, 2);\n        svint32_t del_vec = svdup_n_s32(delimeter);\n        svst1_scatter_s32index(pg_del, output.data(), indices_del, del_vec);\n        j += svcntw();\n        pg_del = svwhilelt_b32(j, n-1);\n    }\n\n    return output;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    uint64_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> result(2 * n - 1);\n    int32_t *in_ptr = numbers.data();\n    int32_t *out_ptr = result.data();\n\n    svint32_t even_indices = svindex_s32(0, 2);\n    svint32_t odd_indices = svindex_s32(1, 2);\n    svint32_t delimeter_vec = svdup_s32(delimeter);\n\n    uint64_t n_minus_one = n - 1;\n    uint64_t i = 0;\n    while (i < n_minus_one) {\n        svbool_t pg = svwhilelt_b32(i, n_minus_one);\n        svint32_t input_vec = svld1_s32(pg, in_ptr + i);\n        int32_t *base = out_ptr + 2 * i;\n        svst1_scatter_s32index_s32(pg, base, even_indices, input_vec);\n        svst1_scatter_s32index_s32(pg, base, odd_indices, delimeter_vec);\n        i += svcntw();\n    }\n    result[2 * (n - 1)] = numbers[n - 1];\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> out(2 * n - 1);\n    int* out_ptr = out.data();\n    const int* in_ptr = numbers.data();\n    int64_t len = n - 1;\n\n    if (len > 0) {\n        svint32_t delim_vec = svdup_n_s32(delimeter);\n        while (len > 0) {\n            svbool_t pg = svwhilelt_b32(0, len);\n            uint64_t vl = svcntp_b32(svptrue_b32(), pg);\n            if (vl == 0) break;\n\n            svint32_t data_vec = svld1_s32(pg, in_ptr);\n            svint32x2_t tuple = svcreate2_s32(data_vec, delim_vec);\n            svst2_s32(pg, out_ptr, tuple);\n\n            in_ptr += vl;\n            out_ptr += 2 * vl;\n            len -= vl;\n        }\n    }\n    *out_ptr = *in_ptr;\n    return out;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> result(2 * n - 1);\n    if (n == 1) {\n        result[0] = numbers[0];\n        return result;\n    }\n\n    int *in_ptr = numbers.data();\n    int *out_ptr = result.data();\n    size_t M = n - 1;\n    size_t vl = svcntw();\n    size_t j = 0;\n\n    while (j < M) {\n        size_t k = M - j;\n        if (k > vl) k = vl;\n        svbool_t pg = svwhilelt_b32(0, k);\n        svint32_t data = svld1(pg, in_ptr + j);\n        svint32_t data_offsets = svindex_s32(0, 8);\n        svint32_t delim_offsets = svindex_s32(4, 8);\n        svst1_scatter_offset(pg, out_ptr + 2 * j, data_offsets, data);\n        svst1_scatter_offset(pg, out_ptr + 2 * j, delim_offsets, svdup_n_s32(delimeter));\n        j += k;\n    }\n\n    result[2 * (n - 1)] = numbers[n - 1];\n    return result;\n}\n```"}
{"task_id": "SimdBench_65_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> intersperse_simd(std::vector<int> numbers, int delimeter) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    std::vector<int> result(2 * n - 1);\n    result[0] = numbers[0];\n\n    size_t L = n - 1;\n    if (L > 0) {\n        size_t i = 0;\n        size_t out_index = 1;\n        svint32_t delim_vec = svdup_n_s32(delimeter);\n\n        while (i < L) {\n            svbool_t pg = svwhilelt_b32(i, L);\n            size_t active_count = svcntp_b32(pg, pg);\n            svint32_t num_vec = svld1(pg, &numbers[1 + i]);\n            svint32_t offsets = svindex_s32(0, 2);\n            svst1_scatter_offset(pg, &result[out_index], offsets, delim_vec);\n            svst1_scatter_offset(pg, &result[out_index + 1], offsets, num_vec);\n            i += active_count;\n            out_index += 2 * active_count;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    uint64_t n = numbers.size();\n    if (n == 0) {\n        return std::vector<int64_t>{0, 1};\n    }\n\n    int64_t total_sum = 0;\n    int64_t total_prod = 1;\n    uint64_t max_chunk_size = svcntd();\n    int64_t buffer[32];\n\n    uint64_t i = 0;\n    while (i < n) {\n        uint64_t elements_this_iter = std::min(n - i, max_chunk_size);\n        svbool_t pg = svwhilelt_b16(i, n);\n\n        svint16_t input16 = svld1_s16(pg, &numbers[i]);\n        svint64_t input64 = svcvt_s64_s16_z(pg, input16);\n\n        total_sum += svaddv_s64(pg, input64);\n\n        svst1_s64(pg, buffer, input64);\n        for (uint64_t j = 0; j < elements_this_iter; j++) {\n            total_prod *= buffer[j];\n        }\n\n        i += elements_this_iter;\n    }\n\n    return std::vector<int64_t>{total_sum, total_prod};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int n = numbers.size();\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    int16_t *data = numbers.data();\n    svint64_t vsum = svdup_n_s64(0);\n    svint64_t vprod = svdup_n_s64(1);\n    int i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint64_t seg = svld1sh_s64(pg, data + i);\n        vsum = svadd_s64_z(pg, vsum, seg);\n        vprod = svmul_s64_z(pg, vprod, seg);\n        i += svcntp_b16(pg, pg);\n    }\n\n    int64_t total_sum = svaddv_s64(svptrue_b64(), vsum);\n    \n    uint64_t vl = svcntd();\n    int64_t total_product = 1;\n    int64_t prod_arr[vl];\n    svst1_s64(svptrue_b64(), prod_arr, vprod);\n    for (uint64_t j = 0; j < vl; j++) {\n        total_product *= prod_arr[j];\n    }\n\n    return {total_sum, total_product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum_total = 0;\n    int64_t prod_total = 1;\n    uint64_t n = numbers.size();\n    uint64_t i = 0;\n\n    while (i < n) {\n        svbool_t pg16 = svwhilelt_b16(i, n);\n        uint64_t vl = svcntp_b16(pg16, pg16);\n        svint64_t data = svld1sh_s64(pg16, &numbers[i]);\n        svbool_t pg64 = svwhilelt_b64(0, vl);\n        sum_total += svaddv(pg64, data);\n        prod_total *= svmulv(pg64, data);\n        i += vl;\n    }\n\n    return {sum_total, prod_total};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    size_t n = numbers.size();\n    size_t i = 0;\n\n    if (n == 0) {\n        return {0, 1};\n    }\n\n    svbool_t pg = svwhilelt_b16(i, n);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t input_vec = svld1_s16(pg, &numbers[i]);\n        i += svcntp_b16(pg, pg);\n\n        svint32_t wide32 = svsxtw_s32_z(pg, input_vec);\n        int32_t seg_sum = svaddv_s32(pg, wide32);\n        sum += static_cast<int64_t>(seg_sum);\n\n        uint64_t vl = svcntp_b16(pg, pg);\n        for (uint64_t j = 0; j < vl; j++) {\n            svbool_t p = svwhilelt_b16(j, j+1);\n            int16_t elem = svlasta_s16(p, input_vec);\n            product *= static_cast<int64_t>(elem);\n        }\n\n        pg = svwhilelt_b16(i, n);\n    }\n\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product_simd(std::vector<int16_t> numbers) {\n    int64_t n = numbers.size();\n    int64_t i = 0;\n    int64_t global_sum = 0;\n    int64_t global_prod = 1;\n\n    svbool_t pg = svwhilelt_b16(i, n);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t v16 = svld1_s16(pg, &numbers[i]);\n        svint64_t v_data = svsxth_s64_z(pg, v16);\n        global_sum += svaddv_s64(pg, v_data);\n        int64_t seg_prod = svreduce_s64(pg, SV_MUL, v_data, 1);\n        global_prod *= seg_prod;\n        i += svcntp_b16(pg, pg);\n        pg = svwhilelt_b16(i, n);\n    }\n\n    return {global_sum, global_prod};\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result(numbers.size());\n    int current_max = INT_MIN;\n    int i = 0;\n    while (i < numbers.size()) {\n        svbool_t pg = svwhilelt_b32(i, numbers.size());\n        svint32_t v = svld1_s32(pg, &numbers[i]);\n        uint32_t vl = svcntp_b32(pg, pg);\n\n        svint32_t scan = v;\n        svint32_t indices = svindex_s32(0, 1);\n        for (int offset = 1; offset < vl; offset *= 2) {\n            svint32_t shifted_indices = svsub_s32_z(pg, indices, offset);\n            svbool_t mask = svcmpge_s32(pg, indices, offset);\n            svint32_t shifted_scan = svdup_n_s32(INT_MIN);\n            shifted_scan = svsel_s32(mask, svtbl_s32(scan, svreinterpret_u32_s32(shifted_indices)), shifted_scan);\n            scan = svmax_s32_z(pg, scan, shifted_scan);\n        }\n\n        svint32_t carry_vec = svdup_n_s32(current_max);\n        svint32_t result_vec = svmax_s32_z(pg, scan, carry_vec);\n        svst1_s32(pg, &result[i], result_vec);\n        current_max = svlasta_s32(pg, result_vec);\n\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    int n = numbers.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    int previous_max = INT_MIN;\n    int i = 0;\n    uint64_t vl_max = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n        svbool_t p_all = svptrue_b32();\n        svint32_t prefix_chunk = svsel_s32(pg, vec, svdup_n_s32(INT_MIN));\n\n        if (vl_max == 0) break;\n\n        svint32_t indices_base = svindex_s32(0, 1);\n\n        for (int stride = 1; stride < vl_max; stride *= 2) {\n            svint32_t offsets = svsub_s32_z(p_all, indices_base, svdup_n_s32(stride));\n            svbool_t p_ge_stride = svcmpge_s32(p_all, indices_base, svdup_n_s32(stride));\n            svint32_t gather_index = svsel_s32(p_ge_stride, offsets, svdup_n_s32(0));\n            svuint32_t gather_index_u = svreinterpret_u32_s32(gather_index);\n            svint32_t candidate = svtbl_s32(prefix_chunk, gather_index_u);\n            prefix_chunk = svsel_s32(p_ge_stride, \n                                    svmax_s32_z(p_all, prefix_chunk, candidate),\n                                    prefix_chunk);\n        }\n\n        prefix_chunk = svmax_s32_z(p_all, svdup_n_s32(previous_max), prefix_chunk);\n        svst1_s32(pg, &result[i], prefix_chunk);\n        previous_max = svlasta_s32(pg, prefix_chunk);\n\n        i += vl_max;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <vector>\n#include <limits>\n#include <arm_sve.h>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return {};\n    }\n    \n    size_t n = numbers.size();\n    std::vector<int> out(n);\n    int32_t current_max = std::numeric_limits<int32_t>::min();\n    uint64_t vl = svcntw();\n    \n    int32_t* in_ptr = numbers.data();\n    int32_t* out_ptr = out.data();\n    \n    uint64_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, in_ptr + i);\n        svint32_t scan_vec = svscanmax_s32(svdup_n_s32(current_max), data, pg);\n        svst1_s32(pg, out_ptr + i, scan_vec);\n        current_max = svlasta_s32(pg, scan_vec);\n        i += svcntp_b32(pg, pg);\n    }\n    \n    return out;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    if (numbers.empty()) {\n        return numbers;\n    }\n\n    int* base = numbers.data();\n    size_t n = numbers.size();\n    size_t i = 0;\n    int prev_max = INT_MIN;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1(pg, base + i);\n\n        svint32_t indices_base = svindex_s32(0, 1);\n        svbool_t first_mask = svcmpeq_s32(svptrue_b32(), indices_base, svdup_s32(0));\n        svint32_t first_val = svdup_s32(prev_max);\n        svint32_t temp = svsel(first_mask, svmax_s32_z(first_mask, first_val, data), data);\n\n        size_t vl_act = svcntp_b32(svptrue_b32(), pg);\n        if (vl_act == 0) break;\n\n        int j = 0;\n        while ((1 << j) < vl_act) {\n            int shift = (1 << j);\n            svint32_t shifted_indices = svsub_s32_z(svptrue_b32(), indices_base, svdup_s32(shift));\n            svbool_t valid_low = svcmpge_s32(svptrue_b32(), shifted_indices, svdup_s32(0));\n            svbool_t valid_high = svcmplt_s32(svptrue_b32(), shifted_indices, svdup_s32(vl_act));\n            svbool_t valid = svand_b_z(svptrue_b32(), valid_low, valid_high);\n            svuint32_t tbl_indices = svreinterpret_u32_s32(shifted_indices);\n            svint32_t shifted_vals = svtbl(temp, tbl_indices);\n            shifted_vals = svsel(valid, shifted_vals, svdup_s32(INT_MIN));\n            temp = svmax_s32_m(pg, temp, shifted_vals);\n            j++;\n        }\n\n        svst1(pg, base + i, temp);\n        prev_max = svlasta(pg, temp);\n        i += vl_act;\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_67_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> rolling_max_simd(std::vector<int> numbers) {\n    uint64_t n = numbers.size();\n    if (n == 0) return {};\n\n    uint64_t vl_full = svcntw();\n    uint64_t i = 0;\n    int current_max = INT_MIN;\n    std::vector<int> result(n);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &numbers[i]);\n\n        svint32_t y = vec;\n        svint32_t indices = svindex_s32(0, 1);\n\n        for (int offset = 1; offset < vl_full; offset *= 2) {\n            svint32_t shifted_indices = svsub_s32_z(svptrue_b32(), indices, svdup_s32(offset));\n            svbool_t pg_shift = svcmpge(svptrue_b32(), shifted_indices, svdup_s32(0));\n            svint32_t z = svsel_s32(pg_shift, \n                                    svld1_gather_s32index(pg_shift, &y, shifted_indices), \n                                    svdup_s32(INT_MIN));\n            y = svmax_s32_z(svptrue_b32(), y, z);\n        }\n\n        y = svmax_s32_z(svptrue_b32(), y, svdup_s32(current_max));\n        svst1_s32(pg, &result[i], y);\n        current_max = svlasta_s32(pg, y);\n        i += vl_full;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.size();\n    std::string res(n, '0');\n    const char *a_ptr = a.data();\n    const char *b_ptr = b.data();\n    char *res_ptr = &res[0];\n    \n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, n);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)(a_ptr + i));\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)(b_ptr + i));\n        svuint8_t va01 = svsub_u8_z(pg, va, svdup_u8('0'));\n        svuint8_t vb01 = svsub_u8_z(pg, vb, svdup_u8('0'));\n        svuint8_t vres01 = sveor_u8_z(pg, va01, vb01);\n        svuint8_t vres_char = svadd_u8_z(pg, vres01, svdup_u8('0'));\n        svst1_u8(pg, (uint8_t*)(res_ptr + i), vres_char);\n        i += svcntb();\n        pg = svwhilelt_b8(i, n);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t len = a.size();\n    std::string res(len, '0');\n    const char* a_data = a.data();\n    const char* b_data = b.data();\n    char* res_data = res.data();\n    size_t index = 0;\n    size_t vl = svcntb();\n\n    while (index < len) {\n        svbool_t pg = svwhilelt_b8(index, len);\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)(a_data + index));\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)(b_data + index));\n        svuint8_t va_bits = svand_u8_z(pg, va, svdup_u8(1));\n        svuint8_t vb_bits = svand_u8_z(pg, vb, svdup_u8(1));\n        svuint8_t v_res_bits = sveor_u8_z(pg, va_bits, vb_bits);\n        svuint8_t v_res = svadd_u8_z(pg, svdup_u8('0'), v_res_bits);\n        svst1_u8(pg, (uint8_t*)(res_data + index), v_res);\n        index += vl;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    if (a.size() != b.size()) {\n        return \"\";\n    }\n    size_t n = a.size();\n    std::string res(n, '\\0');\n    if (n == 0) {\n        return res;\n    }\n    size_t vl = svcntb();\n    size_t i = 0;\n    for (; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)(a.data() + i));\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)(b.data() + i));\n        svuint8_t vxor = sveor_u8_x(pg, va, vb);\n        svuint8_t vres = svadd_u8_x(pg, svdup_u8('0'), vxor);\n        svst1_u8(pg, (uint8_t*)(res.data() + i), vres);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    if (a.size() != b.size()) {\n        return \"\";\n    }\n    size_t n = a.size();\n    std::string res(n, '0');\n    const char* a_ptr = a.data();\n    const char* b_ptr = b.data();\n    char* res_ptr = &res[0];\n    size_t i = 0;\n    size_t vl = svcntb();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)(a_ptr + i));\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)(b_ptr + i));\n        svbool_t mask = svcmpne(pg, va, vb);\n        svuint8_t v_res = svsel(mask, svdup_u8('1'), svdup_u8('0'));\n        svst1_u8(pg, (uint8_t*)(res_ptr + i), v_res);\n        i += vl;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_68_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string string_xor_simd(std::string a, std::string b) {\n    size_t n = a.length();\n    if (n != b.length()) {\n        return \"\";\n    }\n    std::string res(n, '\\0');\n    size_t vl = svcntb();\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t va = svld1_u8(pg, (const uint8_t*)(a.data() + i));\n        svuint8_t vb = svld1_u8(pg, (const uint8_t*)(b.data() + i));\n        svuint8_t vx = sveor_u8_z(pg, va, vb);\n        vx = svand_u8_z(pg, vx, svdup_n_u8(1));\n        svuint8_t res_vec = svadd_u8_z(pg, vx, svdup_n_u8('0'));\n        svst1_u8(pg, (uint8_t*)(res.data() + i), res_vec);\n        i += vl;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    const size_t n = strings.size();\n    std::vector<size_t> lengths(n);\n    for (size_t i = 0; i < n; ++i) {\n        lengths[i] = strings[i].size();\n    }\n    size_t global_max = 0;\n    size_t global_index = 0;\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t vec = svld1_u64(pg, &lengths[i]);\n        uint64_t block_max = svmaxv_u64(pg, vec);\n        if (block_max > global_max) {\n            global_max = block_max;\n            svuint64_t max_vec = svdup_u64(block_max);\n            svbool_t pg_max = svcmpeq_u64(pg, vec, max_vec);\n            uint64_t first_in_block = svpfirst_b64(pg, pg_max);\n            global_index = i + first_in_block;\n        }\n        i += svcntd();\n    }\n    return strings[global_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return std::string();\n    }\n    size_t n = strings.size();\n    size_t max_length = 0;\n    size_t max_index = 0;\n    uint64_t vl = svcntd();\n\n    for (size_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        uint64_t chunk_size = svcntp_b64(svptrue_b64(), pg);\n        std::vector<uint64_t> len_arr(chunk_size);\n        \n        for (uint64_t j = 0; j < chunk_size; ++j) {\n            len_arr[j] = strings[i + j].size();\n        }\n\n        svuint64_t len_vec = svld1_u64(pg, len_arr.data());\n        svuint64_t idx_vec = svindex_u64(i, 1);\n        uint64_t chunk_max = svmaxv_u64(pg, len_vec);\n\n        if (chunk_max > max_length) {\n            max_length = chunk_max;\n            svbool_t pg_max = svcmpeq_u64(pg, len_vec, chunk_max);\n            max_index = svminv_u64(pg_max, idx_vec);\n        }\n        i += chunk_size;\n    }\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::vector<size_t> lengths;\n    lengths.reserve(strings.size());\n    for (const auto& s : strings) {\n        lengths.push_back(s.size());\n    }\n\n    size_t n = lengths.size();\n    svuint64_t max_vec = svdup_u64(0);\n    uint64_t i = 0;\n    uint64_t vl = svcntd();\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t vec = svld1(pg, &lengths[i]);\n        max_vec = svmax_m(pg, max_vec, vec);\n        i += vl;\n    }\n    svbool_t pg_all = svptrue_b64();\n    size_t max_val = svmaxv(pg_all, max_vec);\n\n    i = 0;\n    size_t max_index = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t vec = svld1(pg, &lengths[i]);\n        svbool_t pg_eq = svcmpeq(pg, vec, max_val);\n        if (svptest_any(pg, pg_eq)) {\n            uint64_t first_in_chunk = svpfirst_u64(pg, pg_eq);\n            max_index = i + first_in_chunk;\n            break;\n        }\n        i += vl;\n    }\n\n    return strings[max_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return std::string();\n    }\n    size_t n = strings.size();\n    std::vector<size_t> lengths(n);\n    for (size_t i = 0; i < n; i++) {\n        lengths[i] = strings[i].size();\n    }\n\n    size_t current_max = 0;\n    size_t current_index = 0;\n    size_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        size_t num_active = svcntp_b64(svptrue_b64(), pg);\n        if (num_active == 0) break;\n\n        svuint64_t len_vec = svld1_u64(pg, &lengths[i]);\n        uint64_t max_in_chunk = svmaxv_u64(pg, len_vec);\n\n        if (max_in_chunk > current_max) {\n            current_max = max_in_chunk;\n            svuint64_t max_vec = svdup_n_u64(max_in_chunk);\n            svbool_t p_eq = svcmpeq_u64(pg, len_vec, max_vec);\n            uint64_t first_in_chunk = svpfirst_b64(pg, p_eq);\n            current_index = i + first_in_chunk;\n        }\n\n        i += num_active;\n    }\n\n    return strings[current_index];\n}\n```"}
{"task_id": "SimdBench_69_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string longest_simd(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::vector<size_t> lengths;\n    lengths.reserve(strings.size());\n    for (const auto& s : strings) {\n        lengths.push_back(s.size());\n    }\n\n    size_t max_val = 0;\n    int64_t max_idx = -1;\n    uint64_t base = 0;\n    uint64_t n = lengths.size();\n    uint64_t vl = svcntd();\n\n    while (base < n) {\n        svbool_t pg = svwhilelt_b64(base, n);\n        svuint64_t vec = svld1_u64(pg, &lengths[base]);\n        uint64_t max_in_chunk = svmaxv_u64(pg, vec);\n\n        if (max_in_chunk > max_val) {\n            svbool_t p_max = svcmpeq_n_u64(pg, vec, max_in_chunk);\n            uint64_t offset_in_chunk = svpfirst_b64(p_max);\n            max_val = max_in_chunk;\n            max_idx = base + offset_in_chunk;\n        }\n        base += vl;\n    }\n    return strings[max_idx];\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t k = 0;\n    svuint64_t u_vec = svdup_u64(a);\n    svuint64_t v_vec = svdup_u64(b);\n\n    while (1) {\n        svbool_t p_u_ne0 = svcmpne(svptrue_b64(), u_vec, 0);\n        svbool_t p_v_ne0 = svcmpne(svptrue_b64(), v_vec, 0);\n        if (!svptest_any(svptrue_b64(), p_u_ne0) || !svptest_any(svptrue_b64(), p_v_ne0)) {\n            break;\n        }\n\n        svbool_t p_even_u = svcmpeq(svptrue_b64(), svand_x(svptrue_b64(), u_vec, 1), 0);\n        svbool_t p_even_v = svcmpeq(svptrue_b64(), svand_x(svptrue_b64(), v_vec, 1), 0);\n        svbool_t p_both_even = svand_b_z(svptrue_b64(), p_even_u, p_even_v);\n\n        if (svptest_any(svptrue_b64(), p_both_even)) {\n            u_vec = svlsr_x(svptrue_b64(), u_vec, 1);\n            v_vec = svlsr_x(svptrue_b64(), v_vec, 1);\n            k++;\n            continue;\n        }\n\n        if (svptest_any(svptrue_b64(), p_even_u)) {\n            u_vec = svlsr_x(svptrue_b64(), u_vec, 1);\n            continue;\n        }\n\n        if (svptest_any(svptrue_b64(), p_even_v)) {\n            v_vec = svlsr_x(svptrue_b64(), v_vec, 1);\n            continue;\n        }\n\n        svbool_t p_ugev = svcmpge(svptrue_b64(), u_vec, v_vec);\n        svuint64_t max_vec = svmax(u_vec, v_vec);\n        svuint64_t min_vec = svmin(u_vec, v_vec);\n        svuint64_t diff = svsub_x(svptrue_b64(), max_vec, min_vec);\n        svuint64_t shifted = svlsr_x(svptrue_b64(), diff, 1);\n\n        u_vec = svsel(p_ugev, shifted, u_vec);\n        v_vec = svsel(svnot_b_z(svptrue_b64(), p_ugev), shifted, v_vec);\n    }\n\n    svuint64_t combined = svorr_x(svptrue_b64(), u_vec, v_vec);\n    svuint64_t shift_vec = svdup_u64(k);\n    svuint64_t result_vec = svlsl_u64_x(svptrue_b64(), combined, shift_vec);\n\n    uint64_t result;\n    svbool_t pg = svwhilelt_b64(0, 1);\n    svst1(pg, &result, result_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    if (a == 0) return b;\n    if (b == 0) return a;\n\n    svbool_t pg = svptrue_b64();\n    svuint64_t va = svdup_u64(a);\n    svuint64_t vb = svdup_u64(b);\n\n    while (1) {\n        uint64_t b_val = svlastb_u64(pg, vb);\n        if (b_val == 0) break;\n\n        uint64_t a_val = svlastb_u64(pg, va);\n        uint64_t remainder = a_val % b_val;\n\n        va = vb;\n        vb = svdup_u64(remainder);\n    }\n\n    return svlastb_u64(pg, va);\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        svuint64_t va = svdup_u64(a);\n        svuint64_t vb = svdup_u64(b);\n        svuint64_t vq = svdiv_u64_x(svptrue_b64(), va, vb);\n        svuint64_t vrem = svmls_u64_x(svptrue_b64(), va, vb, vq);\n        uint64_t rem = svlastb_u64(svptrue_b64(), vrem);\n        a = b;\n        b = rem;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    uint64_t shift = 0;\n    while (((a & 1) == 0) && ((b & 1) == 0)) {\n        a >>= 1;\n        b >>= 1;\n        shift++;\n    }\n\n    svbool_t pg = svwhilelt_b64_u64(0, 2);\n    svuint64_t v = svcreate2(a, b);\n\n    while (1) {\n        svuint64_t v_rev = svrev(pg, v);\n        svbool_t eq = svcmpeq(pg, v, v_rev);\n        if (svcntp_b64(pg, eq) == 2) {\n            break;\n        }\n\n        svuint64_t one = svdup_u64(1);\n        svbool_t even_mask = svcmpeq(pg, svand_x(pg, v, one), svdup_u64(0));\n        if (svptest_any(pg, even_mask)) {\n            v = svsel(even_mask, svlsr_x(pg, v, 1), v);\n            continue;\n        }\n\n        svbool_t ge_mask = svcmpge(pg, v, v_rev);\n        v = svsel(ge_mask, svlsr_x(pg, svsub_x(pg, v, v_rev), 1), v);\n    }\n\n    uint64_t res_arr[2];\n    svst1(pg, res_arr, v);\n    return res_arr[0] << shift;\n}\n```"}
{"task_id": "SimdBench_70_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t greatest_common_divisor_simd(uint64_t a, uint64_t b) {\n    svuint64_t vb = svdup_u64(b);\n    const svbool_t pg = svptrue_b64();\n    while (svaddv_u64(pg, vb) != 0) {\n        uint64_t t = b;\n        b = a % b;\n        a = t;\n        vb = svdup_u64(b);\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n#include <cfloat>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    size_t n = numbers.size();\n    size_t num_diffs = n - 1;\n\n    float min_val = FLT_MAX;\n    uint64_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, num_diffs);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1(pg, numbers.data() + index);\n        svfloat32_t v2 = svld1(pg, numbers.data() + index + 1);\n        svfloat32_t diff_vec = svabs_f32_z(pg, svsub_f32_z(pg, v2, v1));\n\n        float current_min = svminv_f32(pg, diff_vec);\n        if (current_min < min_val) {\n            min_val = current_min;\n        }\n\n        uint32_t vl = svcntp_b32(svptrue_b32(), pg);\n        index += vl;\n        pg = svwhilelt_b32(index, num_diffs);\n    }\n\n    index = 0;\n    pg = svwhilelt_b32(index, num_diffs);\n    size_t found_index = 0;\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v1 = svld1(pg, numbers.data() + index);\n        svfloat32_t v2 = svld1(pg, numbers.data() + index + 1);\n        svfloat32_t diff_vec = svabs_f32_z(pg, svsub_f32_z(pg, v2, v1));\n\n        svbool_t match = svcmpeq_f32(pg, diff_vec, min_val);\n        if (svptest_any(svptrue_b32(), match)) {\n            uint32_t first_in_seg = svpfirst_b32(svptrue_b32(), match);\n            found_index = index + first_in_seg;\n            break;\n        }\n\n        uint32_t vl = svcntp_b32(svptrue_b32(), pg);\n        index += vl;\n        pg = svwhilelt_b32(index, num_diffs);\n    }\n\n    return { numbers[found_index], numbers[found_index + 1] };\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <cfloat>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    size_t n = numbers.size();\n    if (n == 2) {\n        return {numbers[0], numbers[1]};\n    }\n\n    float min_diff = FLT_MAX;\n    int min_index = -1;\n    uint64_t base = 0;\n    uint64_t vl = svcntw();\n\n    while (base < n - 1) {\n        svbool_t pg = svwhilelt_b32(base, n - 1);\n        svfloat32_t v0 = svld1_f32(pg, &numbers[base]);\n        svfloat32_t v1 = svld1_f32(pg, &numbers[base + 1]);\n        svfloat32_t diff = svsub_f32_x(pg, v1, v0);\n        float min_seg = svminv_f32(pg, diff);\n\n        if (min_seg < min_diff) {\n            min_diff = min_seg;\n            svbool_t mask = svcmpeq_f32(pg, diff, svdup_f32(min_seg));\n            svuint32_t indices = svindex_u32(0, 1);\n            uint32_t rel_index = svfirsta_u32(mask, indices);\n            min_index = base + rel_index;\n        }\n        base += vl;\n    }\n\n    if (min_index == -1) {\n        min_index = 0;\n    }\n    return {numbers[min_index], numbers[min_index + 1]};\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n#include <cfloat>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::sort(numbers.begin(), numbers.end());\n    \n    if (n < 2) {\n        return numbers;\n    }\n    \n    float min_diff = FLT_MAX;\n    size_t min_index = 0;\n    size_t i = 0;\n    size_t total_diffs = n - 1;\n    svbool_t all_true = svptrue_b32();\n    \n    while (i < total_diffs) {\n        svbool_t pg = svwhilelt_b32(i, total_diffs);\n        uint64_t active_count = svcntp_b32(all_true, pg);\n        if (active_count == 0) break;\n        \n        svfloat32_t a = svld1(pg, &numbers[i]);\n        svfloat32_t b = svld1(pg, &numbers[i+1]);\n        svfloat32_t diff = svsub_f32_x(pg, b, a);\n        \n        float seg_min = svminv_f32(pg, diff);\n        \n        if (seg_min < min_diff) {\n            min_diff = seg_min;\n            svfloat32_t min_vec = svdup_f32(seg_min);\n            svbool_t min_mask = svcmpeq_f32(pg, diff, min_vec);\n            uint64_t first_in_seg = svpfirst_b32(min_mask, pg);\n            min_index = i + first_in_seg;\n        }\n        \n        i += active_count;\n    }\n    \n    return { numbers[min_index], numbers[min_index+1] };\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <cfloat>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    int n = numbers.size();\n    std::sort(numbers.begin(), numbers.end());\n    if (n == 2) {\n        return {numbers[0], numbers[1]};\n    }\n    float global_min_diff = FLT_MAX;\n    int global_min_index = -1;\n    uint64_t n_minus1 = n - 1;\n    int index = 0;\n    while (index < n_minus1) {\n        svbool_t pg = svwhilelt_b32(index, n_minus1);\n        svfloat32_t vec1 = svld1(pg, &numbers[index]);\n        svfloat32_t vec2 = svld1(pg, &numbers[index+1]);\n        svfloat32_t diff = svsub_x(pg, vec2, vec1);\n        float min_val = svminv_f32(pg, diff);\n        if (min_val < global_min_diff) {\n            global_min_diff = min_val;\n            svbool_t p_min = svcmpeq(pg, diff, svdup_n_f32(min_val));\n            svuint32_t abs_indices = svindex_u32(index, 1);\n            svuint32_t candidate_indices = svsel_u32(p_min, abs_indices, svdup_u32(UINT32_MAX));\n            uint32_t first_occurrence = svminv_u32(pg, candidate_indices);\n            global_min_index = first_occurrence;\n        }\n        index += svcntw();\n    }\n    return { numbers[global_min_index], numbers[global_min_index+1] };\n}\n```"}
{"task_id": "SimdBench_71_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <cfloat>\n#include <vector>\n\nstd::vector<float> find_closest_elements_simd(std::vector<float> numbers) {\n    if (numbers.size() < 2) {\n        return {};\n    }\n    std::sort(numbers.begin(), numbers.end());\n    float global_min = FLT_MAX;\n    int global_index = -1;\n    int n = numbers.size();\n    int64_t i = 0;\n    unsigned int vl = svcntw();\n\n    while (i < n-1) {\n        svbool_t pg = svwhilelt_b32(i, n-1);\n        svfloat32_t v1 = svld1(pg, &numbers[i]);\n        svfloat32_t v2 = svld1(pg, &numbers[i+1]);\n        svfloat32_t diff = svsub_f32_z(pg, v2, v1);\n        float min_in_seg = svminv_f32(pg, diff);\n\n        if (min_in_seg < global_min) {\n            global_min = min_in_seg;\n            svbool_t p_min = svcmpeq_f32(pg, diff, svdup_f32(min_in_seg));\n            int64_t first_index_in_seg = svfirst(p_min);\n            if (first_index_in_seg != -1) {\n                global_index = i + first_index_in_seg;\n            }\n        }\n        i += vl;\n    }\n\n    if (global_index == -1) {\n        return {};\n    }\n    return { numbers[global_index], numbers[global_index+1] };\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    uint64_t n = numbers.size();\n    if (n == 0) {\n        return {};\n    }\n    float *data_ptr = numbers.data();\n    float min_val = data_ptr[0];\n    float max_val = data_ptr[0];\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t data = svld1(pg, data_ptr + i);\n        float seg_min = svminv_f32(pg, data);\n        float seg_max = svmaxv_f32(pg, data);\n        if (seg_min < min_val) min_val = seg_min;\n        if (seg_max > max_val) max_val = seg_max;\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n    float range = max_val - min_val;\n    std::vector<float> result(n);\n    if (range == 0.0f) {\n        for (uint64_t j = 0; j < n; j++) {\n            result[j] = 0.5f;\n        }\n    } else {\n        svfloat32_t min_vec = svdup_f32(min_val);\n        svfloat32_t range_vec = svdup_f32(range);\n        i = 0;\n        pg = svwhilelt_b32(i, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1(pg, data_ptr + i);\n            svfloat32_t sub = svsub_x(pg, data, min_vec);\n            svfloat32_t res = svdiv_x(pg, sub, range_vec);\n            svst1(pg, result.data() + i, res);\n            i += vl;\n            pg = svwhilelt_b32(i, n);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return numbers;\n    }\n\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    svbool_t pg;\n    for (size_t i = 0; i < n; ) {\n        pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &numbers[i]);\n        float cur_min = svminv_f32(pg, vec);\n        float cur_max = svmaxv_f32(pg, vec);\n        if (cur_min < min_val) min_val = cur_min;\n        if (cur_max > max_val) max_val = cur_max;\n        i += svcntp_b32(pg, pg);\n    }\n\n    float range = max_val - min_val;\n\n    if (range == 0.0f) {\n        for (size_t i = 0; i < n; ) {\n            pg = svwhilelt_b32(i, n);\n            svst1(pg, &numbers[i], svdup_f32(0.5f));\n            i += svcntp_b32(pg, pg);\n        }\n    } else {\n        svfloat32_t min_vec = svdup_f32(min_val);\n        float inv_range = 1.0f / range;\n        svfloat32_t inv_range_vec = svdup_f32(inv_range);\n        for (size_t i = 0; i < n; ) {\n            pg = svwhilelt_b32(i, n);\n            svfloat32_t vec = svld1(pg, &numbers[i]);\n            vec = svsub_f32_z(pg, vec, min_vec);\n            vec = svmul_f32_z(pg, vec, inv_range_vec);\n            svst1(pg, &numbers[i], vec);\n            i += svcntp_b32(pg, pg);\n        }\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    std::vector<float> result(n);\n    if (n == 0) {\n        return result;\n    }\n    \n    uint64_t vl = svcntw();\n    float min_val, max_val;\n    {\n        int i = 0;\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t min_vec = svld1(pg, &numbers[i]);\n        svfloat32_t max_vec = min_vec;\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1(pg, &numbers[i]);\n            min_vec = svmin_f32_m(pg, min_vec, data);\n            max_vec = svmax_f32_m(pg, max_vec, data);\n            i += vl;\n            pg = svwhilelt_b32(i, n);\n        }\n        min_val = svminv_f32(svptrue_b32(), min_vec);\n        max_val = svmaxv_f32(svptrue_b32(), max_vec);\n    }\n    \n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        int i = 0;\n        svbool_t pg = svwhilelt_b32(i, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svst1(pg, &result[i], svdup_f32(0.0f));\n            i += vl;\n            pg = svwhilelt_b32(i, n);\n        }\n    } else {\n        float inv_range = 1.0f / range;\n        svfloat32_t vmin = svdup_f32(min_val);\n        svfloat32_t v_inv_range = svdup_f32(inv_range);\n        \n        int i = 0;\n        svbool_t pg = svwhilelt_b32(i, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svfloat32_t data = svld1(pg, &numbers[i]);\n            svfloat32_t temp = svsub_f32_x(pg, data, vmin);\n            svfloat32_t res = svmul_f32_x(pg, temp, v_inv_range);\n            svst1(pg, &result[i], res);\n            i += vl;\n            pg = svwhilelt_b32(i, n);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    uint64_t n = numbers.size();\n    if (n == 0) {\n        return numbers;\n    }\n\n    uint32_t vl = svcntw();\n    svbool_t all_true = svptrue_b32();\n    float min_val = numbers[0];\n    float max_val = numbers[0];\n    svfloat32_t min_vec = svdup_f32(min_val);\n    svfloat32_t max_vec = svdup_f32(max_val);\n\n    for (uint64_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t data = svld1_f32(pg, &numbers[i]);\n        min_vec = svmin_f32_z(pg, data, min_vec);\n        max_vec = svmax_f32_z(pg, data, max_vec);\n    }\n\n    min_val = svminv_f32(all_true, min_vec);\n    max_val = svmaxv_f32(all_true, max_vec);\n    float range = max_val - min_val;\n\n    if (range == 0.0f) {\n        for (uint64_t i = 0; i < n; ++i) {\n            numbers[i] = 0.5f;\n        }\n    } else {\n        float inv_range = 1.0f / range;\n        svfloat32_t min_broadcast = svdup_f32(min_val);\n        svfloat32_t inv_range_broadcast = svdup_f32(inv_range);\n\n        for (uint64_t i = 0; i < n; i += vl) {\n            svbool_t pg = svwhilelt_b32(i, n);\n            svfloat32_t data = svld1_f32(pg, &numbers[i]);\n            data = svsub_f32_z(pg, data, min_broadcast);\n            data = svmul_f32_z(pg, data, inv_range_broadcast);\n            svst1_f32(pg, &numbers[i], data);\n        }\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cfloat>\n#include <vector>\n\nstd::vector<float> rescale_to_unit_simd(std::vector<float> numbers) {\n    size_t n = numbers.size();\n    if (n == 0) {\n        return numbers;\n    }\n\n    float *data = numbers.data();\n    float minv, maxv;\n    svfloat32_t minv_vec = svdup_n_f32(FLT_MAX);\n    svfloat32_t maxv_vec = svdup_n_f32(-FLT_MAX);\n    size_t i = 0;\n    const size_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pg, data + i);\n        minv_vec = svmin_f32_m(pg, minv_vec, vec);\n        maxv_vec = svmax_f32_m(pg, maxv_vec, vec);\n        i += vl;\n    }\n\n    minv = svminv_f32(svptrue_b32(), minv_vec);\n    maxv = svmaxv_f32(svptrue_b32(), maxv_vec);\n    float range = maxv - minv;\n\n    if (range == 0.0f) {\n        for (size_t j = 0; j < n; j++) {\n            data[j] = 0.5f;\n        }\n    } else {\n        float inv_range = 1.0f / range;\n        svfloat32_t minv_dup = svdup_n_f32(minv);\n        svfloat32_t inv_range_dup = svdup_n_f32(inv_range);\n        i = 0;\n\n        while (i < n) {\n            svbool_t pg = svwhilelt_b32(i, n);\n            svfloat32_t vec = svld1_f32(pg, data + i);\n            svfloat32_t shifted = svsub_f32_z(pg, vec, minv_dup);\n            svfloat32_t res = svmul_f32_z(pg, shifted, inv_range_dup);\n            svst1_f32(pg, data + i, res);\n            i += vl;\n        }\n    }\n\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    uint64_t base = n - 1;\n    svbool_t pg_all = svptrue_b64();\n    uint64_t vl = svcntd();\n\n    while (base >= 1) {\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t candidates = svsub_u64_z(pg_all, svdup_u64(base), indices);\n        svbool_t pg = svcmpge_u64(pg_all, candidates, svdup_u64(1));\n\n        svuint64_t n_vec = svdup_u64(n);\n        svuint64_t quot = svdiv_u64_z(pg, n_vec, candidates);\n        svuint64_t rem = svmls_u64_z(pg, n_vec, quot, candidates);\n\n        svbool_t divisor_mask = svcmpeq_u64(pg, rem, svdup_u64(0));\n\n        if (svptest_any(pg_all, divisor_mask)) {\n            svuint64_t divisor_vec = svsel_u64(divisor_mask, candidates, svdup_u64(0));\n            uint64_t max_divisor = svmaxv_u64(pg_all, divisor_vec);\n            return max_divisor;\n        }\n\n        base = base - vl;\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n\n    uint64_t vl = svcntd();\n    uint64_t base = 3;\n\n    while (base <= n / base) {\n        svbool_t all_active = svptrue_b64();\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t steps = svmul_u64_z(all_active, indices, svdup_u64(2));\n        svuint64_t candidates = svadd_u64_z(all_active, svdup_u64(base), steps);\n\n        svuint64_t n_vec = svdup_u64(n);\n        svuint64_t quot = svdiv_u64_z(all_active, n_vec, candidates);\n        svuint64_t rem = svmls_u64_z(all_active, n_vec, quot, candidates);\n\n        svbool_t valid = svcmple_u64(all_active, candidates, quot);\n        svbool_t div_mask = svcmpeq_u64(all_active, rem, svdup_u64(0));\n        svbool_t result_mask = svand_b_z(all_active, valid, div_mask);\n\n        if (svptest_any(all_active, result_mask)) {\n            uint64_t min_factor = svminv_u64(result_mask, candidates);\n            return n / min_factor;\n        }\n\n        base += 2 * vl;\n    }\n\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t largest_divisor_simd(uint64_t n){\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n    if (n == 1) {\n        return 0;\n    }\n    \n    uint64_t low = 1;\n    uint64_t high = (1ULL << 32);\n    while (low < high) {\n        uint64_t mid = low + (high - low + 1) / 2;\n        if (mid > n / mid) {\n            high = mid - 1;\n        } else {\n            low = mid;\n        }\n    }\n    uint64_t limit = low;\n    \n    uint64_t vl = svcntd();\n    uint64_t base = 3;\n    while (base <= limit) {\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t steps = svmul_u64_z(svptrue_b64(), indices, svdup_u64(2));\n        svuint64_t candidates = svadd_u64_z(svptrue_b64(), svdup_u64(base), steps);\n        \n        uint64_t cand_arr[vl];\n        svst1_u64(svptrue_b64(), cand_arr, candidates);\n        \n        for (int i = 0; i < vl; i++) {\n            uint64_t d = cand_arr[i];\n            if (d > limit) {\n                break;\n            }\n            if (n % d == 0) {\n                return n / d;\n            }\n        }\n        base += 2 * vl;\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n    \n    if (n == 1) {\n        return 0;\n    }\n    \n    uint64_t low = 1, high = n;\n    uint64_t sqrt_n = 1;\n    while (low <= high) {\n        uint64_t mid = low + (high - low) / 2;\n        if (mid == 0) {\n            break;\n        }\n        if (mid <= n / mid) {\n            sqrt_n = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n    \n    uint64_t d_min = 0;\n    uint64_t base = 3;\n    uint64_t vl = svcntd();\n    \n    while (base <= sqrt_n) {\n        svuint64_t index = svindex_u64(0, 1);\n        svuint64_t step = svmul_u64_z(svptrue_b64(), index, svdup_u64(2));\n        svuint64_t candidates = svadd_u64_z(svptrue_b64(), svdup_u64(base), step);\n        \n        svbool_t pg_candidate = svcmple_u64(svptrue_b64(), candidates, svdup_u64(sqrt_n));\n        svuint64_t quot = svdiv_u64_z(pg_candidate, svdup_u64(n), candidates);\n        svuint64_t rem = svmls_u64_z(pg_candidate, svdup_u64(n), quot, candidates);\n        svbool_t pg_div = svcmpeq_u64(pg_candidate, rem, svdup_u64(0));\n        \n        if (svptest_any(svptrue_b64(), pg_div)) {\n            svuint64_t min_vec = svsel_u64(pg_div, candidates, svdup_u64(UINT64_MAX));\n            uint64_t min_div = svminv_u64(svptrue_b64(), min_vec);\n            d_min = min_div;\n            break;\n        }\n        \n        base += 2 * vl;\n    }\n    \n    if (d_min) {\n        return n / d_min;\n    } else {\n        return 1;\n    }\n}\n```"}
{"task_id": "SimdBench_73_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n#include <stdint.h>\n\nuint64_t largest_divisor_simd(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n\n    uint64_t low = 1;\n    uint64_t high = n;\n    uint64_t sqrt_n = 1;\n    while (low <= high) {\n        uint64_t mid = low + (high - low) / 2;\n        if (mid <= n / mid) {\n            sqrt_n = mid;\n            low = mid + 1;\n        } else {\n            high = mid - 1;\n        }\n    }\n\n    uint64_t vl = svcntd();\n    uint64_t start = 3;\n    uint64_t d_min = 0;\n\n    while (start <= sqrt_n) {\n        svuint64_t v_index = svindex_u64(0, 2);\n        svuint64_t v_candidate = svadd_u64_x(svptrue_b64(), svdup_u64(start), v_index);\n        svbool_t pg = svcmple_u64(svptrue_b64(), v_candidate, svdup_u64(sqrt_n));\n\n        if (svcntp_b64(svptrue_b64(), pg) == 0) {\n            break;\n        }\n\n        uint64_t candidates[vl];\n        svst1_u64(pg, candidates, v_candidate);\n\n        svuint64_t v_pg = svdup_u64(0);\n        v_pg = svsel_u64(pg, svdup_u64(1), v_pg);\n        uint64_t pg_mask[vl];\n        svst1_u64(svptrue_b64(), pg_mask, v_pg);\n\n        for (uint64_t i = 0; i < vl; i++) {\n            if (pg_mask[i]) {\n                uint64_t d = candidates[i];\n                if (n % d == 0) {\n                    d_min = d;\n                    break;\n                }\n            }\n        }\n\n        if (d_min != 0) {\n            break;\n        }\n        start += 2 * vl;\n    }\n\n    if (d_min != 0) {\n        return n / d_min;\n    } else {\n        return 1;\n    }\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <vector>\n#include <cstring>\n\nstd::vector<int> factorize_simd(int n) {\n    if (n <= 1) {\n        return {};\n    }\n    std::vector<int> factors;\n    int original_n = n;\n\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    if (n == 1) {\n        return factors;\n    }\n\n    int sqrt_n = std::sqrt(original_n);\n    std::vector<int> primes;\n    if (sqrt_n >= 3) {\n        std::vector<bool> is_prime(sqrt_n + 1, true);\n        is_prime[0] = false;\n        is_prime[1] = false;\n        for (int i = 2; i * i <= sqrt_n; ++i) {\n            if (is_prime[i]) {\n                for (int j = i * i; j <= sqrt_n; j += i) {\n                    is_prime[j] = false;\n                }\n            }\n        }\n        for (int i = 3; i <= sqrt_n; i += 2) {\n            if (is_prime[i]) {\n                primes.push_back(i);\n            }\n        }\n    }\n\n    uint32_t max_vl = svcntw();\n    int i = 0;\n    while (n > 1) {\n        if (i >= primes.size()) {\n            factors.push_back(n);\n            break;\n        }\n\n        uint32_t vl = max_vl;\n        if (i + vl > primes.size()) {\n            vl = primes.size() - i;\n        }\n        svbool_t pg = svwhilelt_b32(0, vl);\n\n        int remainders[max_vl];\n        for (int j = 0; j < vl; ++j) {\n            remainders[j] = n % primes[i + j];\n        }\n\n        svint32_t rem_vec = svld1_s32(pg, remainders);\n        svint32_t zero_vec = svdup_n_s32(0);\n        svbool_t cmp = svcmpeq_s32(pg, rem_vec, zero_vec);\n\n        if (svptest_any(svptrue_b32(), cmp)) {\n            int j = 0;\n            for (; j < vl; ++j) {\n                if (remainders[j] == 0) {\n                    break;\n                }\n            }\n            int p = primes[i + j];\n            factors.push_back(p);\n            n /= p;\n            i += j;\n        } else {\n            i += vl;\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    int current = n;\n    int divisor = 2;\n    uint64_t vl = svcntw();\n    svint32_t factor_vec = svdup_s32(0);\n    int count = 0;\n\n    while (current > 1) {\n        if (divisor * divisor > current) {\n            if (count == vl) {\n                int buffer[vl];\n                svst1_s32(svptrue_b32(), buffer, factor_vec);\n                for (uint64_t i = 0; i < vl; i++) {\n                    factors.push_back(buffer[i]);\n                }\n                count = 0;\n            }\n            factor_vec = svset_s32(factor_vec, count++, current);\n            break;\n        }\n        if (current % divisor == 0) {\n            if (count == vl) {\n                int buffer[vl];\n                svst1_s32(svptrue_b32(), buffer, factor_vec);\n                for (uint64_t i = 0; i < vl; i++) {\n                    factors.push_back(buffer[i]);\n                }\n                count = 0;\n            }\n            factor_vec = svset_s32(factor_vec, count++, divisor);\n            current /= divisor;\n        } else {\n            divisor++;\n        }\n    }\n\n    if (count > 0) {\n        int buffer[count];\n        svbool_t pg = svwhilelt_b32(0, count);\n        svst1_s32(pg, buffer, factor_vec);\n        for (int i = 0; i < count; i++) {\n            factors.push_back(buffer[i]);\n        }\n    }\n\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    if (n == 1) {\n        return factors;\n    }\n\n    int current = n;\n    int f = 3;\n    while (current > 1) {\n        if (static_cast<long long>(f) * f > current) {\n            factors.push_back(current);\n            break;\n        }\n\n        svbool_t pg = svptrue_b32();\n        uint64_t vl = svcntw();\n        svint32_t v_step = svdup_s32(2);\n        svint32_t v_index = svindex_s32(0, 1);\n        svint32_t v_candidate = svadd_s32_x(pg, svdup_s32(f), svmul_s32_x(pg, v_index, v_step));\n\n        int sqrt_current = std::sqrt(current);\n        int found_factor = 0;\n        for (uint64_t i = 0; i < vl; i++) {\n            svbool_t p_i = svwhilelt_b32(i, i+1);\n            int candidate = svlasta_s32(p_i, v_candidate);\n            if (candidate > sqrt_current) {\n                break;\n            }\n            if (current % candidate == 0) {\n                found_factor = candidate;\n                break;\n            }\n        }\n\n        if (found_factor) {\n            while (current % found_factor == 0) {\n                factors.push_back(found_factor);\n                current /= found_factor;\n            }\n            f = found_factor + 2;\n        } else {\n            f = f + 2 * vl;\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <alloca.h>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    if (n == 1) {\n        return factors;\n    }\n    int base = 3;\n    while (n > 1) {\n        if (base > n / base) {\n            factors.push_back(n);\n            break;\n        }\n        unsigned int vl = svcntw();\n        svint32_t v_base = svdup_s32(base);\n        svint32_t v_index = svindex_s32(0, 1);\n        svint32_t v_step = svmul_x(svptrue_b32(), v_index, svdup_s32(2));\n        svint32_t v_candidates = svadd_x(svptrue_b32(), v_base, v_step);\n        int* candidates_arr = (int*)alloca(vl * sizeof(int));\n        svst1_s32(svptrue_b32(), candidates_arr, v_candidates);\n        bool reduced = false;\n        for (unsigned int i = 0; i < vl; i++) {\n            int candidate = candidates_arr[i];\n            if (candidate > n / candidate) {\n                break;\n            }\n            while (n % candidate == 0) {\n                factors.push_back(candidate);\n                n /= candidate;\n                reduced = true;\n                if (n == 1) break;\n            }\n            if (n == 1) break;\n        }\n        if (n == 1) break;\n        base += 2 * vl;\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> factorize_simd(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    int d = 2;\n    while (n > 1) {\n        if (d > n / d) {\n            factors.push_back(n);\n            break;\n        }\n        uint64_t vl = svcntd();\n        svbool_t all64 = svptrue_b64();\n        svint64_t candidate_vec = svindex_s64(d, 1);\n        svint64_t n_vec = svdup_s64((int64_t)n);\n        svfloat64_t n_f = svcvt_f64_s64_z(all64, n_vec);\n        svfloat64_t candidate_f = svcvt_f64_s64_z(all64, candidate_vec);\n        svfloat64_t quot_f = svdiv_f64_z(all64, n_f, candidate_f);\n        svint64_t quot = svcvt_s64_f64_z(all64, quot_f);\n        svint64_t rem = svmls_s64_z(all64, n_vec, candidate_vec, quot);\n        svbool_t divisible = svcmpeq_s64(all64, rem, svdup_s64(0));\n        int first_index = svpfirst_b64(all64, divisible);\n        if (first_index >= 0) {\n            int divisor = d + first_index;\n            factors.push_back(divisor);\n            n /= divisor;\n            d = divisor;\n        } else {\n            d += vl;\n        }\n    }\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    uint64_t n = l.size();\n    if (n == 0) {\n        return {};\n    }\n    \n    uint64_t index = 0;\n    std::vector<float> res;\n    res.reserve(n);\n\n    while (index < n) {\n        svbool_t pg = svwhilelt_b32(index, n);\n        uint64_t nseg = svcntp_b32(pg, pg);\n        if (nseg == 0) break;\n\n        svfloat32_t vec = svld1_f32(pg, &l[index]);\n        svbool_t pos_pred = svcmpgt_f32(pg, vec, 0.0f);\n        uint64_t cnt = svcntp_b32(pg, pos_pred);\n\n        if (cnt > 0) {\n            svfloat32_t compacted = svcompact_f32(vec, pos_pred);\n            float buffer[64];\n            svbool_t store_pg = svwhilelt_b32(0, cnt);\n            svst1_f32(store_pg, buffer, compacted);\n            \n            for (uint64_t i = 0; i < cnt; ++i) {\n                res.push_back(buffer[i]);\n            }\n        }\n\n        index += nseg;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    std::vector<float> result;\n    uint64_t n = l.size();\n    if (n == 0) return result;\n\n    uint64_t vl = svcntw();\n    float buffer[64];\n    svbool_t pg_all = svptrue_b32();\n\n    uint64_t i = 0;\n    while (i < n) {\n        svbool_t pg_load = svwhilelt_b32(i, n);\n        svfloat32_t input_vec = svld1_f32(pg_load, &l[i]);\n        svbool_t p_positive = svcmpgt_f32(pg_load, input_vec, 0.0f);\n        uint64_t count = svcntp_b32(pg_load, p_positive);\n        svfloat32_t compressed = svcompress_f32(p_positive, input_vec);\n        svst1_f32(pg_all, buffer, compressed);\n        for (uint64_t j = 0; j < count; j++) {\n            result.push_back(buffer[j]);\n        }\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    uint64_t n = l.size();\n    if (n == 0) return {};\n\n    // First pass: count positive numbers\n    uint64_t total_positives = 0;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t data = svld1_f32(pg, &l[i]);\n        svbool_t pos_pred = svcmpgt_f32(pg, data, 0.0f);\n        total_positives += svcntp_b32(pg, pos_pred);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    // Allocate output vector\n    std::vector<float> output;\n    output.resize(total_positives);\n\n    // Second pass: extract positive numbers\n    if (total_positives == 0) \n        return output;\n\n    float* out_ptr = output.data();\n    i = 0;\n    pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t data = svld1_f32(pg, &l[i]);\n        svbool_t pos_pred = svcmpgt_f32(pg, data, 0.0f);\n        uint64_t k = svcntp_b32(pg, pos_pred);\n        if (k > 0) {\n            svfloat32_t compacted = svcompact_f32(pos_pred, data);\n            svst1_f32(svwhilelt_b32(0, k), out_ptr, compacted);\n            out_ptr += k;\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return output;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l){\n    if (l.empty()) {\n        return {};\n    }\n    std::vector<float> output(l.size());\n    float* out_ptr = output.data();\n    const float* in_ptr = l.data();\n    uint64_t i = 0;\n    uint64_t n = l.size();\n    svbool_t all_true = svptrue_b32();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t in_vec = svld1_f32(pg, in_ptr + i);\n        svbool_t pos_pred = svcmpgt_f32(pg, in_vec, 0.0f);\n        uint64_t count = svcntp_b32(pg, pos_pred);\n        svst1_f32(pos_pred, out_ptr, in_vec);\n        out_ptr += count;\n        uint64_t num_processed = svcntp_b32(all_true, pg);\n        i += num_processed;\n    }\n\n    output.resize(out_ptr - output.data());\n    return output;\n}\n```"}
{"task_id": "SimdBench_75_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> get_positive_simd(const std::vector<float> & l) {\n    if (l.empty()) {\n        return {};\n    }\n\n    uint64_t total_count = 0;\n    uint64_t i = 0;\n    svbool_t ptrue = svptrue_b32();\n    uint32_t vl = svcntw();\n\n    while (i < l.size()) {\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svbool_t p_pos = svcmpgt(pg, vec, 0.0f);\n        uint32_t n = svcntp_b32(pg, p_pos);\n        total_count += n;\n        i += svcntp_b32(ptrue, pg);\n    }\n\n    if (total_count == 0) {\n        return {};\n    }\n\n    std::vector<float> output(total_count);\n    i = 0;\n    uint64_t j = 0;\n\n    while (i < l.size()) {\n        svbool_t pg = svwhilelt_b32(i, l.size());\n        svfloat32_t vec = svld1(pg, &l[i]);\n        svbool_t p_pos = svcmpgt(pg, vec, 0.0f);\n        uint32_t n = svcntp_b32(pg, p_pos);\n\n        if (n > 0) {\n            svfloat32_t compacted = svcompact(p_pos, vec);\n            svbool_t p_store = svwhilelt_b32(0, n);\n            svst1(p_store, &output[j], compacted);\n            j += n;\n        }\n\n        i += svcntp_b32(ptrue, pg);\n    }\n\n    return output;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    int64_t limit = (int64_t)sqrt((double)n) + 1;\n    int64_t small_limit = limit < 65536 ? limit : 65536;\n    uint64_t vl = svcntd();\n    int64_t base = 3;\n\n    while (base < small_limit) {\n        svbool_t pg = svwhilelt_b64_s32(base, small_limit);\n        svint64_t indices = svindex_s64(0, 2);\n        svint64_t divisors = svadd_s64_z(pg, svdup_s64(base), indices);\n        svfloat64_t n_vec = svdup_f64((double)n);\n        svfloat64_t d_vec = svcvt_f64_s64_z(pg, divisors);\n        svfloat64_t q_vec = svdiv_f64_z(pg, n_vec, d_vec);\n        svint64_t q_int = svcvt_s64_f64_z(pg, q_vec);\n        svfloat64_t q_floor_vec = svcvt_f64_s64_z(pg, q_int);\n        svfloat64_t rem_vec = svmls_f64_z(pg, n_vec, q_floor_vec, d_vec);\n        svbool_t zero_rem = svcmpeq_n_f64(pg, rem_vec, 0.0);\n        \n        if (svptest_any(svptrue_b64(), zero_rem)) {\n            return false;\n        }\n        base += 2 * vl;\n    }\n\n    int64_t d = small_limit;\n    if (d % 2 == 0) {\n        d++;\n    }\n    for (; d < limit; d += 2) {\n        if (n % d == 0) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <cstdint>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n\n    uint64_t un = static_cast<uint64_t>(n);\n    uint64_t limit = 0;\n    if (un > 0) {\n        double dsqrt = sqrt(static_cast<double>(un));\n        uint64_t root = static_cast<uint64_t>(dsqrt);\n        if (un >= (1ULL << 53)) {\n            if (root == 0) root = un;\n            root = (root + un / root) / 2;\n        }\n        while (root > 0 && root > un / root) {\n            root--;\n        }\n        while ((root + 1) <= un / (root + 1)) {\n            root++;\n        }\n        limit = root;\n    }\n\n    uint64_t vl = svcntd();\n    uint64_t start = 3;\n    while (start <= limit) {\n        svint64_t indices = svindex_s64(0, 1);\n        svint64_t divisors = svadd_s64_z(svptrue_b64(), svmul_s64_z(svptrue_b64(), indices, 2), start);\n        svbool_t pg = svcmple_s64(svptrue_b64(), divisors, limit);\n        uint64_t num_lanes = svcntp_b64(svptrue_b64(), pg);\n        int64_t d_arr[vl];\n        svst1_s64(pg, d_arr, divisors);\n\n        for (uint64_t i = 0; i < num_lanes; i++) {\n            if (n % d_arr[i] == 0) {\n                return false;\n            }\n        }\n        start += 2 * vl;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```c\n#include <arm_sve.h>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    if (n == 3) return true;\n\n    int64_t low = 1, high = n;\n    int64_t limit = 0;\n    while (low <= high) {\n        int64_t mid = low + (high - low) / 2;\n        if (mid > 0 && mid > n / mid) {\n            high = mid - 1;\n        } else {\n            limit = mid;\n            low = mid + 1;\n        }\n    }\n\n    uint64_t total_odds = 0;\n    if (limit >= 3) {\n        total_odds = (uint64_t)((limit - 3) / 2 + 1);\n    }\n\n    uint64_t vl = svcntd();\n    uint64_t k = 0;\n    svbool_t pg;\n    while (svptest_any(svptrue_b64(), pg = svwhilelt_b64(k * vl, total_odds)) {\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t base = svdup_u64(3 + 2 * k * vl);\n        svuint64_t divisors = svadd_u64_z(pg, base, svmul_u64_z(pg, indices, svdup_u64(2)));\n\n        svuint64_t n_vec = svdup_u64((uint64_t)n);\n        svuint64_t quot = svdiv_u64_z(pg, n_vec, divisors);\n        svuint64_t rem = svsub_u64_z(pg, n_vec, svmul_u64_z(pg, quot, divisors));\n\n        svbool_t is_zero = svcmpeq_n_u64(pg, rem, 0);\n        if (svptest_any(svptrue_b64(), is_zero)) {\n            return false;\n        }\n        k++;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <cstdint>\n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    \n    uint64_t un = n;\n    double sqrt_n = std::sqrt(static_cast<double>(un));\n    uint64_t root = static_cast<uint64_t>(sqrt_n);\n    if (root * root < un) {\n        ++root;\n    }\n    uint64_t limit = root;\n    \n    uint64_t small_bound = un / (1ULL << 53);\n    if (small_bound > limit) {\n        small_bound = limit;\n    }\n    \n    for (uint64_t d = 3; d <= small_bound; d += 2) {\n        if (un % d == 0) {\n            return false;\n        }\n    }\n    \n    if (small_bound >= limit) {\n        return true;\n    }\n    \n    uint64_t start_d = small_bound + 1;\n    if (start_d < 3) {\n        start_d = 3;\n    } else if (start_d % 2 == 0) {\n        ++start_d;\n    }\n    \n    if (start_d > limit) {\n        return true;\n    }\n    \n    svbool_t pg = svptrue_b64();\n    uint64_t vl = svcntd();\n    \n    while (start_d <= limit) {\n        svint64_t indices = svindex_s64(0, 2);\n        svint64_t divisors = svadd_s64_z(pg, indices, svdup_s64(start_d));\n        svbool_t pg_active = svcmple_s64(pg, divisors, svdup_s64(limit));\n        \n        if (svptest_any(pg, pg_active) == 0) {\n            break;\n        }\n        \n        svfloat64_t v_divisors_f64 = svcvt_f64_s64_z(pg_active, divisors);\n        svfloat64_t v_n = svdup_f64_z(pg_active, static_cast<double>(un));\n        svfloat64_t v_quotient_f64 = svdiv_f64_z(pg_active, v_n, v_divisors_f64);\n        svint64_t v_quotient = svcvt_s64_f64_z(pg_active, v_quotient_f64);\n        svint64_t v_product = svmul_s64_z(pg_active, divisors, v_quotient);\n        svint64_t v_remainder = svsub_s64_z(pg_active, svdup_s64(un), v_product);\n        \n        svbool_t found = svcmpeq_n_s64(pg_active, v_remainder, 0);\n        if (svptest_any(pg, found)) {\n            return false;\n        }\n        \n        start_d += 2 * vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_76_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool is_prime_simd(int64_t n) {\n    if (n <= 1) \n        return false;\n    if (n == 2) \n        return true;\n    if (n % 2 == 0) \n        return false;\n\n    int64_t max_d;\n    if (n == 1) {\n        max_d = 1;\n    } else {\n        int64_t low = 1, high = n;\n        int64_t candidate = 1;\n        while (low <= high) {\n            int64_t mid = low + (high - low) / 2;\n            if (mid <= n / mid) {\n                candidate = mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n        max_d = candidate;\n    }\n\n    if (max_d < 3) \n        return true;\n\n    uint64_t vl = svcntd();\n    svbool_t all_true = svptrue_b64();\n    int64_t d = 3;\n\n    while (d <= max_d) {\n        svint64_t v_d = svindex_s64(d, 2);\n        svbool_t active = svcmple(all_true, v_d, svdup_s64(max_d));\n        uint64_t num_active = svcntp_b64(all_true, active);\n\n        if (num_active == 0) \n            break;\n\n        int64_t d_arr[vl];\n        svst1_s64(active, d_arr, v_d);\n\n        for (uint64_t i = 0; i < num_active; i++) {\n            if (n % d_arr[i] == 0) {\n                return false;\n            }\n        }\n        d += 2 * vl;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    const size_t n = s.size();\n    if (n == 0) {\n        return s;\n    }\n\n    const char* str = s.data();\n    bool has_letter = false;\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, n);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(str + i));\n        svbool_t is_lower = svcmpge(pg, input, 'a');\n        svbool_t is_upper = svcmpge(pg, input, 'A');\n        svbool_t is_lower_bound = svcmple(pg, input, 'z');\n        svbool_t is_upper_bound = svcmple(pg, input, 'Z');\n        svbool_t letter_lower = svand_b_z(pg, is_lower, is_lower_bound);\n        svbool_t letter_upper = svand_b_z(pg, is_upper, is_upper_bound);\n        svbool_t is_letter = svorr_b_z(pg, letter_lower, letter_upper);\n        \n        if (svptest_any(svptrue_b8(), is_letter)) {\n            has_letter = true;\n            break;\n        }\n        i += svcntp_b8(pg, pg);\n        pg = svwhilelt_b8(i, n);\n    }\n\n    if (has_letter) {\n        std::string result = s;\n        char* out = result.data();\n        i = 0;\n        pg = svwhilelt_b8(i, n);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t input = svld1_u8(pg, (const uint8_t*)(str + i));\n            svbool_t is_lower = svcmpge(pg, input, 'a');\n            svbool_t is_upper = svcmpge(pg, input, 'A');\n            svbool_t is_lower_bound = svcmple(pg, input, 'z');\n            svbool_t is_upper_bound = svcmple(pg, input, 'Z');\n            svbool_t letter_lower = svand_b_z(pg, is_lower, is_lower_bound);\n            svbool_t letter_upper = svand_b_z(pg, is_upper, is_upper_bound);\n            svbool_t is_letter = svorr_b_z(pg, letter_lower, letter_upper);\n            \n            svuint8_t flipped = sveor_u8_m(is_letter, input, svdup_u8(0x20));\n            svuint8_t output = svsel_u8(is_letter, flipped, input);\n            svst1_u8(pg, (uint8_t*)(out + i), output);\n            \n            i += svcntp_b8(pg, pg);\n            pg = svwhilelt_b8(i, n);\n        }\n        return result;\n    } else {\n        std::string result(n, '\\0');\n        char* out = result.data();\n        i = 0;\n        while (i < n) {\n            size_t count = svcntb();\n            if (i + count > n) {\n                count = n - i;\n            }\n            svbool_t pg = svwhilelt_b8(0, count);\n            svuint8_t indices = svindex_u8(count - 1, -1);\n            svuint8_t data = svld1_gather_u8index_u8(pg, (const uint8_t*)(str + n - i - count), indices);\n            svst1_u8(pg, (uint8_t*)(out + i), data);\n            i += count;\n        }\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) {\n        return s;\n    }\n\n    std::string result = s;\n    const char *data = s.data();\n    char *res_data = &result[0];\n    size_t n = s.size();\n    size_t vl = svcntb();\n\n    bool has_letter = false;\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t v = svld1(pg, (const uint8_t*)(data + i));\n\n        svbool_t pg_lower = svand_b_z(pg, \n                     svcmpge(pg, v, 'a'),\n                     svcmple(pg, v, 'z'));\n        svbool_t pg_upper = svand_b_z(pg,\n                     svcmpge(pg, v, 'A'),\n                     svcmple(pg, v, 'Z'));\n        svbool_t pg_letter = svorr_b_z(pg, pg_lower, pg_upper);\n\n        if (svptest_any(pg, pg_letter)) {\n            has_letter = true;\n            break;\n        }\n\n        i += vl;\n    }\n\n    if (has_letter) {\n        i = 0;\n        while (i < n) {\n            svbool_t pg = svwhilelt_b8(i, n);\n            svuint8_t v = svld1(pg, (const uint8_t*)(data + i));\n\n            svbool_t pg_lower = svand_b_z(pg, \n                         svcmpge(pg, v, 'a'),\n                         svcmple(pg, v, 'z'));\n            svbool_t pg_upper = svand_b_z(pg,\n                         svcmpge(pg, v, 'A'),\n                         svcmple(pg, v, 'Z'));\n            svbool_t pg_letter = svorr_b_z(pg, pg_lower, pg_upper);\n\n            svuint8_t flip = svdup_u8(0x20);\n            svuint8_t v_flipped = sveor_u8_z(pg_letter, v, flip);\n            svuint8_t res = svsel_u8(pg_letter, v_flipped, v);\n\n            svst1(pg, (uint8_t*)(res_data + i), res);\n            i += vl;\n        }\n    } else {\n        size_t left = 0;\n        size_t right = n - 1;\n\n        while (left < right) {\n            if (right - left + 1 < 2 * vl) {\n                break;\n            }\n\n            svuint8_t v_left = svld1(svptrue_b8(), (const uint8_t*)(data + left));\n            svuint8_t v_right = svld1(svptrue_b8(), (const uint8_t*)(data + right - vl + 1));\n\n            svuint8_t v_left_rev = svrev_u8(v_left);\n            svuint8_t v_right_rev = svrev_u8(v_right);\n\n            svst1(svptrue_b8(), (uint8_t*)(res_data + left), v_right_rev);\n            svst1(svptrue_b8(), (uint8_t*)(res_data + right - vl + 1), v_left_rev);\n\n            left += vl;\n            right -= vl;\n        }\n\n        while (left < right) {\n            char temp = res_data[left];\n            res_data[left] = res_data[right];\n            res_data[right] = temp;\n            left++;\n            right--;\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    if (s.empty()) {\n        return s;\n    }\n    \n    size_t n = s.size();\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    bool has_letter = false;\n    size_t i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        size_t vl = svcntp_b8(svptrue_b8(), pg);\n        svuint8_t vec = svld1(pg, src + i);\n        \n        svuint8_t v_A = svdup_u8('A');\n        svuint8_t v_Z = svdup_u8('Z');\n        svuint8_t v_a = svdup_u8('a');\n        svuint8_t v_z = svdup_u8('z');\n        \n        svbool_t is_upper = svand_b_z(pg, \n                            svcmpge(pg, vec, v_A),\n                            svcmple(pg, vec, v_Z));\n        svbool_t is_lower = svand_b_z(pg,\n                            svcmpge(pg, vec, v_a),\n                            svcmple(pg, vec, v_z));\n        svbool_t is_letter = svorr_b_z(pg, is_upper, is_lower);\n        \n        if (svptest_any(svptrue_b8(), is_letter)) {\n            has_letter = true;\n            break;\n        }\n        i += vl;\n    }\n    \n    std::string res(n, '\\0');\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&res[0]);\n    \n    if (!has_letter) {\n        i = 0;\n        while (i < n) {\n            svbool_t pg = svwhilelt_b8(i, n);\n            size_t seg_len = svcntp_b8(svptrue_b8(), pg);\n            svuint8_t vec = svld1(pg, src + n - i - seg_len);\n            \n            svuint8_t idx = svsub_u8_z(svptrue_b8(), \n                            svdup_u8(seg_len - 1), \n                            svindex_u8(0, 1));\n            svuint8_t rev_vec = svtbl(vec, idx);\n            \n            svst1(pg, dst + i, rev_vec);\n            i += seg_len;\n        }\n    } else {\n        i = 0;\n        while (i < n) {\n            svbool_t pg = svwhilelt_b8(i, n);\n            size_t vl = svcntp_b8(svptrue_b8(), pg);\n            svuint8_t vec = svld1(pg, src + i);\n            \n            svuint8_t v_A = svdup_u8('A');\n            svuint8_t v_Z = svdup_u8('Z');\n            svuint8_t v_a = svdup_u8('a');\n            svuint8_t v_z = svdup_u8('z');\n            \n            svbool_t is_upper = svand_b_z(pg, \n                                svcmpge(pg, vec, v_A),\n                                svcmple(pg, vec, v_Z));\n            svbool_t is_lower = svand_b_z(pg,\n                                svcmpge(pg, vec, v_a),\n                                svcmple(pg, vec, v_z));\n            \n            vec = svadd_u8_m(is_upper, vec, vec, svdup_u8(32));\n            vec = svsub_u8_m(is_lower, vec, vec, svdup_u8(32));\n            \n            svst1(pg, dst + i, vec);\n            i += vl;\n        }\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n#include <algorithm>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return s;\n\n    const uint8_t *p = reinterpret_cast<const uint8_t*>(s.data());\n    bool has_letter = false;\n    size_t vl_bytes = svcntb();\n\n    for (size_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t v = svld1(pg, p + i);\n        svbool_t is_lower = svand_b_z(pg, svcmpge(pg, v, 'a'), svcmple(pg, v, 'z'));\n        svbool_t is_upper = svand_b_z(pg, svcmpge(pg, v, 'A'), svcmple(pg, v, 'Z'));\n        svbool_t is_letter = svorr_b_z(pg, is_lower, is_upper);\n        if (svptest_any(pg, is_letter)) {\n            has_letter = true;\n            break;\n        }\n        i += vl_bytes;\n    }\n\n    if (has_letter) {\n        std::string result = s;\n        uint8_t *data = reinterpret_cast<uint8_t*>(&result[0]);\n        for (size_t i = 0; i < n; ) {\n            svbool_t pg = svwhilelt_b8(i, n);\n            svuint8_t v = svld1(pg, data + i);\n            svbool_t is_lower = svand_b_z(pg, svcmpge(pg, v, 'a'), svcmple(pg, v, 'z'));\n            svbool_t is_upper = svand_b_z(pg, svcmpge(pg, v, 'A'), svcmple(pg, v, 'Z'));\n            svbool_t is_letter = svorr_b_z(pg, is_lower, is_upper);\n            svuint8_t flipped = sveor_u8_z(is_letter, v, svdup_u8(0x20));\n            svst1(pg, data + i, flipped);\n            i += vl_bytes;\n        }\n        return result;\n    } else {\n        std::string result = s;\n        uint8_t *data = reinterpret_cast<uint8_t*>(&result[0]);\n        size_t i = 0;\n        size_t j = n - 1;\n        size_t vl = vl_bytes;\n        while (i < j) {\n            size_t remaining = j - i + 1;\n            size_t k = std::min(vl, remaining / 2);\n            if (k == 0) break;\n            svbool_t pg = svwhilelt_b8(0, k);\n            svint8_t indices = svindex_s8(0, 1);\n            svint8_t off = svneg_s8_z(pg, indices);\n            uint8_t *base_start = data + i + k - 1;\n            uint8_t *base_end = data + j;\n            svuint8_t rev_start = svld1_gather_s8_offset_u8(pg, base_start, off);\n            svuint8_t rev_end = svld1_gather_s8_offset_u8(pg, base_end, off);\n            svst1(pg, data + i, rev_end);\n            svst1(pg, data + j - k + 1, rev_start);\n            i += k;\n            j -= k;\n        }\n        return result;\n    }\n}\n```"}
{"task_id": "SimdBench_77_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n == 0) return \"\";\n    \n    bool found_letter = false;\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        svbool_t is_upper = svand_b_z(pg, \n                            svcmpge_u8(pg, input, 'A'),\n                            svcmple_u8(pg, input, 'Z'));\n        svbool_t is_lower = svand_b_z(pg,\n                            svcmpge_u8(pg, input, 'a'),\n                            svcmple_u8(pg, input, 'z'));\n        svbool_t is_letter = svorr_b_z(pg, is_upper, is_lower);\n        if (svptest_any(svptrue_b8(), is_letter)) {\n            found_letter = true;\n            break;\n        }\n        i += svcntb();\n    }\n\n    std::string result(n, '\\0');\n    if (found_letter) {\n        i = 0;\n        while (i < n) {\n            svbool_t pg = svwhilelt_b8(i, n);\n            svuint8_t input = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n            svbool_t is_upper = svand_b_z(pg, \n                                svcmpge_u8(pg, input, 'A'),\n                                svcmple_u8(pg, input, 'Z'));\n            svbool_t is_lower = svand_b_z(pg,\n                                svcmpge_u8(pg, input, 'a'),\n                                svcmple_u8(pg, input, 'z'));\n            svbool_t is_letter = svorr_b_z(pg, is_upper, is_lower);\n            svuint8_t toggled = sveor_u8_m(is_letter, input, svdup_u8(0x20));\n            svst1_u8(pg, (uint8_t*)(result.data() + i), toggled);\n            i += svcntb();\n        }\n    } else {\n        size_t vl = svcntb();\n        svuint8_t rev_indices = svindex_u8(vl - 1, -1);\n        i = 0;\n        while (i < n) {\n            size_t remaining = n - i;\n            size_t this_vl = (remaining > vl) ? vl : remaining;\n            svbool_t pg = svwhilelt_b8(i, n);\n            const uint8_t* load_ptr = (const uint8_t*)(s.data() + n - i - this_vl);\n            svuint8_t chunk = svld1_u8(pg, load_ptr);\n            svuint8_t reversed = svrev_u8(chunk);\n            svuint8_t store_vec = (this_vl < vl) ? svtbl(reversed, rev_indices) : reversed;\n            svst1_u8(pg, (uint8_t*)(result.data() + i), store_vec);\n            i += vl;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <arm_sve.h>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    if (l.empty()) {\n        return l;\n    }\n\n    uint64_t n_tri = (l.size() + 2) / 3;\n    std::vector<uint64_t> indices_vec(n_tri);\n    for (uint64_t i = 0; i < n_tri; ++i) {\n        indices_vec[i] = i * 3;\n    }\n\n    std::vector<int> temp(n_tri);\n    uint64_t vl = svcntd();\n    uint64_t i = 0;\n\n    while (i < n_tri) {\n        svbool_t pg = svwhilelt_b64(i, n_tri);\n        svuint64_t indices_reg = svld1_u64(pg, &indices_vec[i]);\n        svint32_t values = svld1_gather_u64index_s32(pg, l.data(), indices_reg);\n        svst1_s32(pg, &temp[i], values);\n        i += vl;\n    }\n\n    std::sort(temp.begin(), temp.end());\n\n    i = 0;\n    while (i < n_tri) {\n        svbool_t pg = svwhilelt_b64(i, n_tri);\n        svuint64_t indices_reg = svld1_u64(pg, &indices_vec[i]);\n        svint32_t sorted_vals = svld1_s32(pg, &temp[i]);\n        svst1_scatter_u64index_s32(pg, l.data(), indices_reg, sorted_vals);\n        i += vl;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n == 0) {\n        return l;\n    }\n    size_t m = (n + 2) / 3;\n    std::vector<int> result = l;\n    if (m == 0) {\n        return result;\n    }\n    std::vector<int> extracted(m);\n\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, m);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t oidx = svindex_s32(i * 3, 3);\n        svint32_t vals = svld1_gather_s32index_s32(pg, l.data(), oidx);\n        svst1_s32(pg, extracted.data() + i, vals);\n        uint64_t num = svcntp_b32(pg, pg);\n        i += num;\n        pg = svwhilelt_b32(i, m);\n    }\n\n    std::sort(extracted.begin(), extracted.end());\n\n    i = 0;\n    pg = svwhilelt_b32(i, m);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t oidx = svindex_s32(i * 3, 3);\n        svint32_t sorted_vals = svld1_s32(pg, extracted.data() + i);\n        svst1_scatter_s32index_s32(pg, result.data(), oidx, sorted_vals);\n        uint64_t num = svcntp_b32(pg, pg);\n        i += num;\n        pg = svwhilelt_b32(i, m);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n == 0) \n        return l;\n\n    int m = (n + 2) / 3;\n    std::vector<int> to_sort(m);\n    uint64_t vl = svcntw();\n\n    for (uint64_t i = 0; i < m; ) {\n        svbool_t pg = svwhilelt_b32(i, m);\n        svint32_t indices = svindex_s32(i * 3, 3);\n        svint32_t gathered = svld1_gather_index(pg, &l[0], indices);\n        svst1(pg, &to_sort[i], gathered);\n        i += vl;\n    }\n\n    std::sort(to_sort.begin(), to_sort.end());\n\n    for (uint64_t i = 0; i < m; ) {\n        svbool_t pg = svwhilelt_b32(i, m);\n        svint32_t indices = svindex_s32(i * 3, 3);\n        svint32_t sorted_segment = svld1(pg, &to_sort[i]);\n        svst1_scatter_index(pg, &l[0], indices, sorted_segment);\n        i += vl;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    uint64_t n = l.size();\n    if (n == 0) return l;\n    \n    uint64_t n_elems = (n + 2) / 3;\n    if (n_elems == 0) return l;\n    \n    std::vector<int> to_sort(n_elems);\n    int* ptr = l.data();\n    int* to_sort_ptr = to_sort.data();\n\n    for (uint64_t i = 0; i < n_elems; ) {\n        svbool_t pg = svwhilelt_b32(i, n_elems);\n        svint32_t indices = svindex_s32(i * 3, 3);\n        svint32_t data = svld1_gather_s32index(pg, ptr, indices);\n        svst1(pg, to_sort_ptr + i, data);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n\n    std::sort(to_sort.begin(), to_sort.end());\n\n    for (uint64_t i = 0; i < n_elems; ) {\n        svbool_t pg = svwhilelt_b32(i, n_elems);\n        svint32_t indices = svindex_s32(i * 3, 3);\n        svint32_t data = svld1(pg, to_sort_ptr + i);\n        svst1_scatter_s32index(pg, ptr, indices, data);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_78_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> sort_third_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n == 0) return l;\n    \n    size_t m = (n + 2) / 3;\n    std::vector<int> temp(m);\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    svbool_t pg;\n\n    while (i < m) {\n        pg = svwhilelt_b32(i, m);\n        svint32_t j_vec = svindex_s32(i, 1);\n        svint32_t indices = svmul_x(pg, j_vec, 3);\n        svint32_t values = svld1_gather_s32index(pg, l.data(), indices);\n        svst1(pg, &temp[i], values);\n        i += vl;\n    }\n\n    std::sort(temp.begin(), temp.end());\n\n    i = 0;\n    while (i < m) {\n        pg = svwhilelt_b32(i, m);\n        svint32_t j_vec = svindex_s32(i, 1);\n        svint32_t indices = svmul_x(pg, j_vec, 3);\n        svint32_t values = svld1(pg, &temp[i]);\n        svst1_scatter_s32index(pg, l.data(), indices, values);\n        i += vl;\n    }\n\n    return l;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <cfloat>\n\nfloat max_element_simd(std::vector<float> l) {\n    if (l.empty()) {\n        return 0.0f;\n    }\n    float *data = l.data();\n    uint64_t n = l.size();\n    svfloat32_t max_vec = svdup_n_f32(-FLT_MAX);\n    uint64_t i = 0;\n    uint64_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, data + i);\n        max_vec = svmax_m(pg, max_vec, vec);\n        i += vl;\n    }\n\n    float res = svmaxv(svptrue_b32(), max_vec);\n    return res;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float first = l[0];\n    svfloat32_t max_vec = svdup_n_f32(first);\n    size_t vl = svcntw();\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1_f32(pg, l.data() + i);\n        max_vec = svmax_f32_x(pg, max_vec, vec);\n        i += vl;\n    }\n    float result = svmaxv_f32(svptrue_b32(), max_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cfloat>\n#include <vector>\n\nfloat max_element_simd(std::vector<float> l) {\n    uint64_t n = l.size();\n    if (n == 0) {\n        return -FLT_MAX;\n    }\n    svfloat32_t v_max = svdup_n_f32(-FLT_MAX);\n    uint64_t base = 0;\n    svbool_t pg = svwhilelt_b32(base, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t v_current = svld1_f32(pg, l.data() + base);\n        v_max = svmax_f32_m(pg, v_max, v_current, v_max);\n        base += svcntw();\n        pg = svwhilelt_b32(base, n);\n    }\n    float res = svmaxv_f32(svptrue_b32(), v_max);\n    return res;\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nfloat max_element_simd(std::vector<float> l){\n    size_t n = l.size();\n    if (n == 0) {\n        return 0.0f;\n    }\n    float *data = l.data();\n    uint64_t index = 0;\n    svbool_t pg = svwhilelt_b32(index, (uint64_t)n);\n    svfloat32_t max_vec = svld1_f32(pg, data);\n    index = svcntw();\n\n    while (index < n) {\n        pg = svwhilelt_b32(index, (uint64_t)n);\n        svfloat32_t data_vec = svld1_f32(pg, data + index);\n        max_vec = svmax_f32_m(pg, max_vec, data_vec);\n        index += svcntw();\n    }\n\n    return svmaxv_f32(svptrue_b32(), max_vec);\n}\n```"}
{"task_id": "SimdBench_79_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nfloat max_element_simd(std::vector<float> l) {\n    size_t n = l.size();\n    float max_val = l[0];\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t vec = svld1(pg, &l[i]);\n        float current_max = svmaxv_f32(pg, vec);\n        if (current_max > max_val) {\n            max_val = current_max;\n        }\n        i += svcntw();\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n    uint64_t total_count = 0;\n    const int vl = svcntw();\n\n    for (int base = 0; base < n; base += 11 * vl) {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t numbers = svadd_s32_x(svptrue_b32(), svdup_n_s32(base), svmul_n_s32_x(svptrue_b32(), indices, 11));\n        svbool_t pg = svcmplt_s32(svptrue_b32(), numbers, svdup_n_s32(n));\n        svuint32_t uvec = svreinterpret_u32(numbers);\n        svuint32_t count_vec = svdup_n_u32(0);\n        svuint32_t current = uvec;\n        svuint64_t magic = svdup_n_u64(0xCCCCCCCD);\n\n        for (int d = 0; d < 10; d++) {\n            svuint64_t current64 = svcvt_u64_x(pg, current);\n            svuint64_t product = svmul_u64_x(pg, current64, magic);\n            svuint64_t shifted = svlsr_n_u64_x(pg, product, 35);\n            svuint32_t quotient = svqxtnb_u32(shifted);\n            svuint32_t digit = svsub_u32_x(pg, current, svmla_n_u32_x(pg, svdup_n_u32(0), quotient, 10));\n            svbool_t is_seven = svcmpeq_n_u32(pg, digit, 7);\n            count_vec = svadd_u32_m(is_seven, count_vec, svdup_n_u32(1));\n            current = quotient;\n        }\n        total_count += svaddv_u32(pg, count_vec);\n    }\n\n    for (int base = 0; base < n; base += 13 * vl) {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t numbers = svadd_s32_x(svptrue_b32(), svdup_n_s32(base), svmul_n_s32_x(svptrue_b32(), indices, 13));\n        svbool_t pg = svcmplt_s32(svptrue_b32(), numbers, svdup_n_s32(n));\n        int32_t buffer[vl];\n        svst1_s32(pg, buffer, numbers);\n        int count_active = svcntp_b32(svptrue_b32(), pg);\n\n        for (int i = 0; i < count_active; i++) {\n            int32_t num = buffer[i];\n            if (num % 11 == 0) continue;\n            int count7 = 0;\n            while (num) {\n                if (num % 10 == 7) count7++;\n                num /= 10;\n            }\n            total_count += count7;\n        }\n    }\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n\n    uint64_t vl = svcntw();\n    svbool_t p_all = svptrue_b32();\n    const double inv11 = 1.0 / 11.0;\n    const double inv13 = 1.0 / 13.0;\n    const double inv10 = 0.1;\n    int total_count = 0;\n\n    for (int i = 0; i < n; i += vl) {\n        svint32_t v = svadd_s32_x(p_all, svindex_s32(i, 1), svdup_n_s32(0));\n        svbool_t p_loop = svcmplt_s32(p_all, v, svdup_n_s32(n));\n        if (svptest_any(p_all, p_loop) == 0) break;\n\n        svfloat64_t v_f = svcvt_f64_s32_x(p_loop, v);\n        svint32_t quot11 = svcvt_s32_f64_x(p_loop, svmul_f64_x(p_loop, v_f, svdup_n_f64(inv11)));\n        svint32_t rem11 = svsub_s32_x(p_loop, v, svmul_s32_x(p_loop, quot11, svdup_n_s32(11)));\n        svint32_t quot13 = svcvt_s32_f64_x(p_loop, svmul_f64_x(p_loop, v_f, svdup_n_f64(inv13)));\n        svint32_t rem13 = svsub_s32_x(p_loop, v, svmul_s32_x(p_loop, quot13, svdup_n_s32(13)));\n\n        svbool_t p_div11 = svcmpeq_s32(p_loop, rem11, svdup_n_s32(0));\n        svbool_t p_div13 = svcmpeq_s32(p_loop, rem13, svdup_n_s32(0));\n        svbool_t p_cond = svorr_z(p_loop, p_div11, p_div13);\n\n        svint32_t vcount = svdup_n_s32(0);\n        svint32_t num = v;\n        svbool_t p_nonzero = p_cond;\n\n        for (int j = 0; j < 10; j++) {\n            if (svptest_any(p_loop, p_nonzero) == 0) break;\n            svfloat64_t num_f = svcvt_f64_s32_x(p_nonzero, num);\n            svfloat64_t quotient_f = svmul_f64_x(p_nonzero, num_f, svdup_n_f64(inv10));\n            svint32_t q = svcvt_s32_f64_x(p_nonzero, quotient_f);\n            svint32_t r = svsub_s32_x(p_nonzero, num, svmul_s32_x(p_nonzero, q, svdup_n_s32(10)));\n            svbool_t p_seven = svcmpeq_s32(p_nonzero, r, svdup_n_s32(7));\n            vcount = svadd_s32_m(p_nonzero, vcount, svsel_s32(p_seven, svdup_n_s32(1), svdup_n_s32(0)));\n            num = q;\n            p_nonzero = svand_s32(p_nonzero, svcmpne_s32(p_nonzero, num, svdup_n_s32(0)));\n        }\n\n        int32_t segment_sum = svaddv_s32(p_loop, vcount);\n        total_count += segment_sum;\n    }\n\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n    uint32_t un = (uint32_t)n;\n    uint32_t vl = svcntw();\n    const svuint32_t vten = svdup_u32(10);\n    const svuint32_t vseven = svdup_u32(7);\n    const svuint32_t vzero = svdup_u32(0);\n    svbool_t all_mask = svptrue_b32();\n\n    uint32_t total_count_11 = 0;\n    uint32_t base11 = 0;\n    uint32_t step11 = 11;\n    while (base11 < un) {\n        svuint32_t v = svindex_u32(base11, step11);\n        svbool_t pg = svcmplt_u32(all_mask, v, svdup_u32(un));\n        svuint32_t count_vec = svdup_u32(0);\n        svuint32_t temp = v;\n        svbool_t active = pg;\n\n        for (int i = 0; i < 10; i++) {\n            if (svcntp_b32(all_mask, active) == 0) break;\n            svuint32_t digit = svmod_u32_x(active, temp, vten);\n            svbool_t is_seven = svcmpeq_u32(active, digit, vseven);\n            count_vec = svadd_u32_m(active, count_vec, svsel_u32(is_seven, svdup_u32(1), svdup_u32(0)));\n            temp = svdiv_u32_x(active, temp, vten);\n            active = svand_b_z(all_mask, active, svcmpne_u32(active, temp, vzero));\n        }\n        total_count_11 += svaddv_u32(all_mask, count_vec);\n        base11 += step11 * vl;\n    }\n\n    uint32_t total_count_13 = 0;\n    uint32_t base13 = 0;\n    uint32_t step13 = 13;\n    while (base13 < un) {\n        svuint32_t v = svindex_u32(base13, step13);\n        svbool_t pg = svcmplt_u32(all_mask, v, svdup_u32(un));\n        svuint32_t count_vec = svdup_u32(0);\n        svuint32_t temp = v;\n        svbool_t active = pg;\n\n        for (int i = 0; i < 10; i++) {\n            if (svcntp_b32(all_mask, active) == 0) break;\n            svuint32_t digit = svmod_u32_x(active, temp, vten);\n            svbool_t is_seven = svcmpeq_u32(active, digit, vseven);\n            count_vec = svadd_u32_m(active, count_vec, svsel_u32(is_seven, svdup_u32(1), svdup_u32(0)));\n            temp = svdiv_u32_x(active, temp, vten);\n            active = svand_b_z(all_mask, active, svcmpne_u32(active, temp, vzero));\n        }\n        total_count_13 += svaddv_u32(all_mask, count_vec);\n        base13 += step13 * vl;\n    }\n\n    uint32_t total_count_143 = 0;\n    uint32_t base143 = 0;\n    uint32_t step143 = 143;\n    while (base143 < un) {\n        svuint32_t v = svindex_u32(base143, step143);\n        svbool_t pg = svcmplt_u32(all_mask, v, svdup_u32(un));\n        svuint32_t count_vec = svdup_u32(0);\n        svuint32_t temp = v;\n        svbool_t active = pg;\n\n        for (int i = 0; i < 10; i++) {\n            if (svcntp_b32(all_mask, active) == 0) break;\n            svuint32_t digit = svmod_u32_x(active, temp, vten);\n            svbool_t is_seven = svcmpeq_u32(active, digit, vseven);\n            count_vec = svadd_u32_m(active, count_vec, svsel_u32(is_seven, svdup_u32(1), svdup_u32(0)));\n            temp = svdiv_u32_x(active, temp, vten);\n            active = svand_b_z(all_mask, active, svcmpne_u32(active, temp, vzero));\n        }\n        total_count_143 += svaddv_u32(all_mask, count_vec);\n        base143 += step143 * vl;\n    }\n\n    return total_count_11 + total_count_13 - total_count_143;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint fizz_buzz_simd(int n) {\n    if (n <= 0) return 0;\n    int total = 0;\n    int i = 0;\n    const uint64_t div10_constant = 0xCCCCCCCD;\n    const uint32_t m_11 = 390451572;\n    const uint32_t m_13 = 330382099;\n    uint32_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t v_base = svindex_s32(i, 1);\n        i += vl;\n\n        svuint32_t v_base_u = svreinterpret_u32(v_base);\n\n        svuint64_t v_prod11 = svmul_u32_u32(pg, v_base_u, svdup_u32(m_11));\n        svuint32_t v_hi11 = svcvt_u32_u64_z(pg, svlsr_n_u64_z(pg, v_prod11, 32));\n        svuint32_t v_rem11 = svsub_u32_z(pg, v_base_u, svmul_u32_z(pg, v_hi11, 11));\n        svbool_t p_adj11 = svcmpge_u32(pg, v_rem11, 11);\n        v_rem11 = svsub_u32_m(p_adj11, v_rem11, svdup_u32(11));\n        svbool_t mask11 = svcmpeq(pg, v_rem11, 0);\n\n        svuint64_t v_prod13 = svmul_u32_u32(pg, v_base_u, svdup_u32(m_13));\n        svuint32_t v_hi13 = svcvt_u32_u64_z(pg, svlsr_n_u64_z(pg, v_prod13, 32));\n        svuint32_t v_rem13 = svsub_u32_z(pg, v_base_u, svmul_u32_z(pg, v_hi13, 13));\n        svbool_t p_adj13 = svcmpge_u32(pg, v_rem13, 13);\n        v_rem13 = svsub_u32_m(p_adj13, v_rem13, svdup_u32(13));\n        svbool_t mask13 = svcmpeq(pg, v_rem13, 0);\n\n        svbool_t mask_cond = svorr_z(pg, mask11, mask13);\n        svint32_t v_current = svsel_s32(mask_cond, v_base, svdup_s32(0));\n        svint32_t v_count = svdup_s32(0);\n\n        for (int d = 0; d < 10; d++) {\n            svuint32_t v_u = svreinterpret_u32(v_current);\n            svuint64_t v_u64 = svcvt_u64_u32_z(pg, v_u);\n            svuint64_t v_prod = svmul_u64_z(pg, v_u64, svdup_u64(div10_constant));\n            svuint64_t v_shifted = svlsr_n_u64_z(pg, v_prod, 35);\n            svuint32_t v_hi_u32 = svcvt_u32_u64_z(pg, v_shifted);\n            svuint32_t v_rem = svsub_u32_z(pg, v_u, svmul_u32_z(pg, v_hi_u32, 10));\n            svint32_t v_digit = svreinterpret_s32(v_rem);\n            svbool_t mask_digit7 = svcmpeq(pg, v_digit, 7);\n            v_count = svadd_s32_m(pg, v_count, svsel_s32(mask_digit7, svdup_s32(1), svdup_s32(0)));\n            v_current = svreinterpret_s32(v_hi_u32);\n        }\n\n        total += svaddv_s32(pg, v_count);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_80_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint fizz_buzz_simd(int n){\n    if (n <= 0) return 0;\n    uint64_t total = 0;\n    const uint64_t vl = svcntw();\n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n        svuint32_t u_indices = svreinterpret_u32(indices);\n        \n        svuint64_t indices64 = svcvt_u64_x(pg, indices);\n        svuint64_t product64_11 = svmul_u64_x(pg, indices64, svdup_u64(3123612580ULL));\n        svuint64_t shifted64_11 = svlsr_u64_x(pg, product64_11, 35);\n        svuint32_t q11 = svcvt_u32_x(pg, shifted64_11);\n        svuint32_t product32_11 = svmul_u32_x(pg, q11, svdup_u32(11));\n        svbool_t cond11 = svcmpeq_u32(pg, u_indices, product32_11);\n        \n        svuint64_t product64_13 = svmul_u64_x(pg, indices64, svdup_u64(2643056798ULL));\n        svuint64_t shifted64_13 = svlsr_u64_x(pg, product64_13, 35);\n        svuint32_t q13 = svcvt_u32_x(pg, shifted64_13);\n        svuint32_t product32_13 = svmul_u32_x(pg, q13, svdup_u32(13));\n        svbool_t cond13 = svcmpeq_u32(pg, u_indices, product32_13);\n        \n        svbool_t cond_mask = svorr_b_z(pg, cond11, cond13);\n        uint64_t num_active = svcntp_b32(pg, cond_mask);\n        if (num_active > 0) {\n            svuint32_t compact = svcompact_u32(cond_mask, u_indices);\n            uint32_t buffer[num_active];\n            svst1_u32(svwhilelt_b32(0, num_active), buffer, compact);\n            \n            for (uint64_t j = 0; j < num_active; j++) {\n                uint32_t num = buffer[j];\n                int count = 0;\n                while (num) {\n                    if (num % 10 == 7) count++;\n                    num /= 10;\n                }\n                total += count;\n            }\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    uint64_t n = l.size();\n    if (n == 0) return l;\n\n    uint64_t even_size = (n + 1) / 2;\n    uint64_t odd_size = n / 2;\n    std::vector<float> even_vals(even_size);\n    std::vector<float> odd_vals(odd_size);\n\n    uint64_t even_count = 0;\n    uint64_t odd_count = 0;\n    uint64_t i = 0;\n    uint64_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t base = svdup_u32(i);\n        svuint32_t indices = svadd_u32_x(pg, base, svindex_u32(0, 1));\n\n        svuint32_t mod2 = svand_u32_x(pg, indices, svdup_u32(1));\n        svbool_t even_mask = svcmpeq_u32(pg, mod2, svdup_u32(0));\n        svbool_t odd_mask = svcmpne_u32(pg, mod2, svdup_u32(0));\n\n        uint64_t count_even = svcntp_b32(pg, even_mask);\n        uint64_t count_odd = svcntp_b32(pg, odd_mask);\n\n        svfloat32_t data = svld1_f32(pg, &l[i]);\n\n        if (count_even > 0) {\n            svuint32_t even_offsets = svindex_u32(0, 1);\n            even_offsets = svadd_u32_x(svptrue_b32(), even_offsets, svdup_u32(even_count));\n            svscatter_f32(even_mask, even_vals.data(), even_offsets, data);\n            even_count += count_even;\n        }\n\n        if (count_odd > 0) {\n            svuint32_t odd_offsets = svindex_u32(0, 1);\n            odd_offsets = svadd_u32_x(svptrue_b32(), odd_offsets, svdup_u32(odd_count));\n            svscatter_f32(odd_mask, odd_vals.data(), odd_offsets, data);\n            odd_count += count_odd;\n        }\n\n        i += vl;\n    }\n\n    std::sort(even_vals.begin(), even_vals.end());\n\n    std::vector<float> result(n);\n    for (uint64_t k = 0; k < even_vals.size(); k++) {\n        result[2 * k] = even_vals[k];\n        if (2 * k + 1 < n) {\n            result[2 * k + 1] = odd_vals[k];\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    uint64_t n = l.size();\n    if (n == 0) {\n        return l;\n    }\n    uint64_t m_even = (n + 1) >> 1;\n    uint64_t m_odd = n - m_even;\n    std::vector<float> result(n, 0);\n    std::vector<float> even_arr(m_even);\n\n    float *base = l.data();\n    float *result_base = result.data();\n    float *even_arr_base = even_arr.data();\n\n    uint64_t j = 0;\n    while (j < m_even) {\n        svbool_t pg64 = svwhilelt_b64(j, m_even);\n        uint64_t k = svcntp_b64(svptrue_b64(), pg64);\n        svint64_t indices = svindex_s64(2 * j, 2);\n        svfloat32_t data = svld1_gather_index(pg64, base, indices);\n        svbool_t pg32 = svwhilelt_b32(0, k);\n        svst1(pg32, even_arr_base + j, data);\n        j += k;\n    }\n\n    std::sort(even_arr.begin(), even_arr.end());\n\n    j = 0;\n    while (j < m_even) {\n        svbool_t pg64 = svwhilelt_b64(j, m_even);\n        uint64_t k = svcntp_b64(svptrue_b64(), pg64);\n        svint64_t indices = svindex_s64(2 * j, 2);\n        svbool_t pg32 = svwhilelt_b32(0, k);\n        svfloat32_t data = svld1(pg32, even_arr_base + j);\n        svst1_scatter_index(pg64, result_base, indices, data);\n        j += k;\n    }\n\n    j = 0;\n    while (j < m_odd) {\n        svbool_t pg64 = svwhilelt_b64(j, m_odd);\n        uint64_t k = svcntp_b64(svptrue_b64(), pg64);\n        svint64_t indices = svindex_s64(1 + 2 * j, 2);\n        svfloat32_t data = svld1_gather_index(pg64, base, indices);\n        svst1_scatter_index(pg64, result_base, indices, data);\n        j += k;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    if (n == 0) {\n        return l;\n    }\n\n    std::vector<float> result = l;\n    size_t even_count = (n + 1) / 2;\n    std::vector<float> even_vec(even_count);\n\n    float *in_ptr = l.data();\n    float *even_ptr = even_vec.data();\n    float *out_ptr = result.data();\n\n    uint64_t vl = svcntw();\n    svbool_t all_true = svptrue_b32();\n    uint64_t i = 0;\n\n    svbool_t pg = svwhilelt_b32(i, even_count);\n    while (svptest_any(all_true, pg)) {\n        svint32_t indices = svadd_n_s32_x(pg, svindex_s32(0, 2), 2*i);\n        svfloat32_t data = svld1_gather_s32index_f32(pg, in_ptr, indices);\n        svst1_f32(pg, even_ptr + i, data);\n\n        i += vl;\n        pg = svwhilelt_b32(i, even_count);\n    }\n\n    std::sort(even_vec.begin(), even_vec.end());\n\n    i = 0;\n    pg = svwhilelt_b32(i, even_count);\n    while (svptest_any(all_true, pg)) {\n        svint32_t indices = svadd_n_s32_x(pg, svindex_s32(0, 2), 2*i);\n        svfloat32_t sorted_data = svld1_f32(pg, even_ptr + i);\n        svst1_scatter_s32index_f32(pg, out_ptr, indices, sorted_data);\n\n        i += vl;\n        pg = svwhilelt_b32(i, even_count);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    int n = l.size();\n    int m = (n + 1) / 2;\n    int k = n - m;\n    std::vector<float> result(n);\n    if (n == 0) return result;\n    std::vector<float> evens(m);\n    std::vector<float> odds(k);\n    float *base_ptr = l.data();\n    float *result_ptr = result.data();\n    float *evens_ptr = evens.data();\n    float *odds_ptr = odds.data();\n\n    {\n        uint32_t i = 0;\n        svbool_t pg;\n        while (i < m) {\n            pg = svwhilelt_b32(i, m);\n            svuint32_t indices = svindex_u32(2 * i, 2);\n            svfloat32_t data = svld1_gather_index(pg, base_ptr, indices);\n            svst1(pg, evens_ptr + i, data);\n            i += svcntp_b32(pg, pg);\n        }\n    }\n\n    {\n        uint32_t i = 0;\n        svbool_t pg;\n        while (i < k) {\n            pg = svwhilelt_b32(i, k);\n            svuint32_t indices = svindex_u32(2 * i + 1, 2);\n            svfloat32_t data = svld1_gather_index(pg, base_ptr, indices);\n            svst1(pg, odds_ptr + i, data);\n            i += svcntp_b32(pg, pg);\n        }\n    }\n\n    for (int i = 1; i < m; i++) {\n        float key = evens[i];\n        int j = i - 1;\n        while (j >= 0 && evens[j] > key) {\n            evens[j + 1] = evens[j];\n            j--;\n        }\n        evens[j + 1] = key;\n    }\n\n    {\n        uint32_t i = 0;\n        svbool_t pg;\n        while (i < m) {\n            pg = svwhilelt_b32(i, m);\n            svuint32_t indices = svindex_u32(2 * i, 2);\n            svfloat32_t data = svld1(pg, evens_ptr + i);\n            svst1_scatter_index(pg, result_ptr, indices, data);\n            i += svcntp_b32(pg, pg);\n        }\n    }\n\n    {\n        uint32_t i = 0;\n        svbool_t pg;\n        while (i < k) {\n            pg = svwhilelt_b32(i, k);\n            svuint32_t indices = svindex_u32(2 * i + 1, 2);\n            svfloat32_t data = svld1(pg, odds_ptr + i);\n            svst1_scatter_index(pg, result_ptr, indices, data);\n            i += svcntp_b32(pg, pg);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_81_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even_simd(std::vector<float> l) {\n    size_t n = l.size();\n    size_t n_even = (n + 1) / 2;\n    size_t n_odd = n / 2;\n\n    std::vector<float> even_arr(n_even);\n    std::vector<float> odd_arr(n_odd);\n\n    for (size_t i = 0; i < n_even; i++) {\n        even_arr[i] = l[2 * i];\n    }\n    for (size_t i = 0; i < n_odd; i++) {\n        odd_arr[i] = l[2 * i + 1];\n    }\n\n    std::sort(even_arr.begin(), even_arr.end());\n\n    std::vector<float> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    float *even_ptr = even_arr.data();\n    float *odd_ptr = odd_arr.data();\n    float *result_ptr = result.data();\n\n    uint64_t vl = svcntw();\n    for (uint64_t i = 0; i < n_odd; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n_odd);\n        svfloat32_t even_vec = svld1(pg, even_ptr + i);\n        svfloat32_t odd_vec = svld1(pg, odd_ptr + i);\n        svfloat32x2_t tuple = svcreate2_f32(even_vec, odd_vec);\n        svst2(pg, result_ptr + 2 * i, tuple);\n    }\n\n    if (n % 2 == 1) {\n        result[n - 1] = even_arr[n_even - 1];\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) \n        return false;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = i + 1; j < n; j++) {\n            int target = -(l[i] + l[j]);\n            uint64_t k = 0;\n            svbool_t pg = svwhilelt_b32(k, n);\n            svbool_t found = svpfalse();\n\n            do {\n                svint32_t data = svld1_s32(pg, &l[k]);\n                svint32_t indices_vec = svindex_s32(k, 1);\n                svbool_t mask_i = svcmpne(pg, indices_vec, i);\n                svbool_t mask_j = svcmpne(pg, indices_vec, j);\n                svbool_t mask = svand_b_z(pg, mask_i, mask_j);\n                svbool_t cmp = svcmpeq(mask, data, target);\n                found = svorr_b(found, cmp);\n\n                k += svcntw();\n                pg = svwhilelt_b32(k, n);\n            } while (svptest_any(svptrue_b32(), pg));\n\n            if (svptest_any(svptrue_b32(), found)) \n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <arm_sve.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; ++i) {\n        for (int j = i + 1; j < n - 1; ++j) {\n            int target = -(l[i] + l[j]);\n            int start = j + 1;\n            int end = n - 1;\n            if (start > end) continue;\n            if (target < l[start] || target > l[end]) continue;\n\n            for (int k = start; k <= end; ) {\n                svbool_t pg = svwhilelt_b32(svptrue_b32(), k, end + 1);\n                uint64_t active_vl = svcntp_b32(svptrue_b32(), pg);\n                if (active_vl == 0) break;\n\n                svint32_t vec = svld1_s32(pg, &l[k]);\n                svint32_t target_vec = svdup_n_s32(target);\n                svbool_t match = svcmpeq(pg, vec, target_vec);\n\n                if (svptest_any(pg, match)) {\n                    return true;\n                }\n\n                if (l[k] > target) {\n                    break;\n                }\n                k += active_vl;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <algorithm>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n    \n    std::sort(l.begin(), l.end());\n    \n    for (int i = 0; i < n - 2; i++) {\n        int T = -l[i];\n        int j = i + 1;\n        int k = n - 1;\n        \n        while (j < k) {\n            int sum = l[j] + l[k];\n            if (sum < T) {\n                int base = j;\n                int vl = std::min(static_cast<int>(svcntw()), k - base);\n                if (vl <= 0) break;\n                \n                svint32_t j_vals = svld1(svptrue_b32(), &l[base]);\n                svint32_t sum_vec = svadd_z(svptrue_b32(), j_vals, svdup_n_s32(l[k]));\n                svbool_t p_ge = svcmpge(svptrue_b32(), sum_vec, svdup_n_s32(T));\n                \n                svint32_t indices = svindex_s32(0, 1);\n                svint32_t candidate_indices = svsel_s32(p_ge, indices, svdup_n_s32(vl));\n                int min_index = svminv_s32(svptrue_b32(), candidate_indices);\n                \n                if (min_index < vl) j = base + min_index;\n                else j = base + vl;\n            } else if (sum > T) {\n                int base = k;\n                int vl = std::min(static_cast<int>(svcntw()), base - j);\n                if (vl <= 0) break;\n                \n                svint32_t k_vals = svld1(svptrue_b32(), &l[base - vl + 1]);\n                svint32_t sum_vec = svadd_z(svptrue_b32(), k_vals, svdup_n_s32(l[j]));\n                svbool_t p_le = svcmple(svptrue_b32(), sum_vec, svdup_n_s32(T));\n                \n                svint32_t indices = svindex_s32(0, 1);\n                svint32_t candidate_indices = svsel_s32(p_le, indices, svdup_n_s32(-1));\n                int max_index = svmaxv_s32(svptrue_b32(), candidate_indices);\n                \n                if (max_index >= 0) k = (base - vl + 1) + max_index;\n                else k = base - vl;\n            } else {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) return false;\n\n    for (int i = 0; i < n - 2; i++) {\n        for (int j = i + 1; j < n - 1; j++) {\n            int target = - (l[i] + l[j]);\n            int base = j + 1;\n            svbool_t pg = svwhilelt_b32(base, n);\n            while (svptest_any(svptrue_b32(), pg)) {\n                svint32_t data = svld1_s32(pg, &l[base]);\n                svbool_t cmp = svcmpeq_s32(pg, data, svdup_n_s32(target));\n                if (svptest_any(pg, cmp)) {\n                    return true;\n                }\n                base += svcntw();\n                pg = svwhilelt_b32(base, n);\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <stdint.h>\n\nbool triples_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 3) \n        return false;\n\n    uint64_t vl = svcntw();\n    svbool_t all_true = svptrue_b32();\n\n    for (int k = 0; k < n; k++) {\n        int32_t target = -l[k];\n        for (int i = 0; i < n; i++) {\n            if (i == k) \n                continue;\n            \n            int32_t rem = target - l[i];\n            uint64_t j = 0;\n            svbool_t found = svpfalse_b();\n\n            while (j < n) {\n                svbool_t pg = svwhilelt_b32(j, n);\n                svint32_t data = svld1_s32(pg, &l[j]);\n                svuint32_t indices = svindex_u32(j, 1);\n                \n                svbool_t match = svcmpeq_s32(pg, data, rem);\n                svbool_t not_i = svcmpne_u32(pg, indices, (uint32_t)i);\n                svbool_t not_k = svcmpne_u32(pg, indices, (uint32_t)k);\n                svbool_t valid = svand_b_z(pg, not_i, not_k);\n                svbool_t result = svand_b_z(pg, match, valid);\n                \n                found = svorr_b_z(all_true, found, result);\n                if (svptest_any(all_true, found))\n                    break;\n                    \n                j += vl;\n            }\n            \n            if (svptest_any(all_true, found)) \n                return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> out(n);\n    int *in_ptr = l.data();\n    int *out_ptr = out.data();\n    size_t i = 0;\n    unsigned int vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, in_ptr + i);\n        svint32_t res = svadd_n_s32_z(pg, data, 1);\n        svst1_s32(pg, out_ptr + i, res);\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> output(n);\n    if (n == 0) {\n        return output;\n    }\n\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, static_cast<uint64_t>(n));\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t input_vec = svld1_s32(pg, l.data() + i);\n        svint32_t result_vec = svadd_n_s32_x(pg, input_vec, 1);\n        svst1_s32(pg, output.data() + i, result_vec);\n        i += vl;\n        pg = svwhilelt_b32(i, static_cast<uint64_t>(n));\n    }\n    \n    return output;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstddef>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    size_t n = l.size();\n    std::vector<int> result(n);\n    int *in = l.data();\n    int *out = result.data();\n    \n    svuint32_t ones = svdup_n_u32(1);\n    size_t i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t input = svld1_s32(pg, in + i);\n        svint32_t incremented = svadd_s32_x(pg, input, svreinterpret_s32_u32(ones));\n        svst1_s32(pg, out + i, incremented);\n        i += svcntw();\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    std::vector<int> out(l.size());\n    size_t n = l.size();\n    if (n == 0) {\n        return out;\n    }\n    int32_t *in_data = l.data();\n    int32_t *out_data = out.data();\n    uint64_t vl = svcntw();\n    size_t base = 0;\n\n    while (base < n) {\n        svbool_t pg = svwhilelt_b32(base, n);\n        svint32_t input_vec = svld1_s32(pg, in_data + base);\n        svint32_t result_vec = svadd_s32_z(pg, input_vec, svdup_n_s32(1));\n        svst1_s32(pg, out_data + base, result_vec);\n        base += vl;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_83_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> incr_list_simd(std::vector<int> l) {\n    if (l.empty()) \n        return std::vector<int>();\n\n    size_t n = l.size();\n    std::vector<int> out(n);\n    int32_t *in_ptr = l.data();\n    int32_t *out_ptr = out.data();\n    uint64_t vl = svcntw();\n\n    for (uint64_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, in_ptr + i);\n        svint32_t res = svadd_s32_x(pg, vec, svdup_n_s32(1));\n        svst1_s32(pg, out_ptr + i, res);\n        i += vl;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int32_t *data = l.data();\n    int n = l.size();\n    if (n < 2) return false;\n\n    uint64_t vl = svcntw();\n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg_outer = svwhilelt_b32(i, n);\n        svint32_t outer_vec = svld1_s32(pg_outer, data + i);\n        svint32_t neg_outer_vec = svneg_s32_z(pg_outer, outer_vec);\n\n        int32_t neg_outer_arr[svcntw()];\n        svst1_s32(pg_outer, neg_outer_arr, neg_outer_vec);\n        uint64_t active_outer = svcntp_b32(pg_outer, pg_outer);\n\n        for (int k = 0; k < active_outer; k++) {\n            int32_t neg_a = neg_outer_arr[k];\n            int outer_index = i + k;\n\n            for (int j = 0; j < n; j += vl) {\n                svbool_t pg_inner = svwhilelt_b32(j, n);\n                svint32_t inner_data = svld1_s32(pg_inner, data + j);\n                svbool_t cmp = svcmpeq_s32(pg_inner, inner_data, svdup_s32(neg_a));\n\n                if (j <= outer_index && outer_index < j + (int)vl) {\n                    svuint32_t indices = svindex_u32(j, 1);\n                    svbool_t not_self = svcmpne_s32(pg_inner, indices, outer_index);\n                    cmp = svand_b_z(pg_inner, cmp, not_self);\n                }\n\n                if (svptest_any(svptrue_b32(), cmp)) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    size_t n = l.size();\n    if (n < 2) {\n        return false;\n    }\n    \n    size_t vl = svcntw();\n    for (size_t i = 0; i < n; i++) {\n        int x = l[i];\n        int target_val = -x;\n        size_t base = 0;\n        bool found = false;\n        \n        while (base < n) {\n            svbool_t pg = svwhilelt_b32(base, n);\n            svint32_t data_vec = svld1_s32(pg, l.data() + base);\n            svint32_t indices_vec = svindex_s32(base, 1);\n            svbool_t mask = svcmpne_s32(pg, indices_vec, i);\n            svint32_t target_vec = svdup_n_s32(target_val);\n            svbool_t matches = svcmpeq_s32(pg, data_vec, target_vec);\n            svbool_t final_matches = svand_b_z(pg, matches, mask);\n            \n            if (svptest_any(pg, final_matches)) {\n                found = true;\n                break;\n            }\n            base += vl;\n        }\n        \n        if (found) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) {\n        return false;\n    }\n    uint64_t vl = svcntw();\n    for (int i = 0; i < n; i++) {\n        int a = l[i];\n        int neg_a = -a;\n        svint32_t neg_a_vec = svdup_n_s32(neg_a);\n        for (int j = 0; j < n; j += vl) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svint32_t chunk = svld1_s32(pg, &l[j]);\n            svbool_t match = svcmpeq_s32(pg, chunk, neg_a_vec);\n            if (j <= i && i < j + vl) {\n                svint32_t local_index = svindex_s32(0, 1);\n                svint32_t target = svdup_n_s32(i - j);\n                svbool_t mask_i = svcmpeq_s32(pg, local_index, target);\n                match = svbic_z(pg, match, mask_i);\n            }\n            if (svptest_any(svptrue_b32(), match)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) {\n        return false;\n    }\n\n    uint32_t vl = svcntw();\n\n    for (int i = 0; i < n; i++) {\n        int current = l[i];\n        int target = -current;\n\n        uint32_t base = i + 1;\n        while (base < n) {\n            svbool_t pg = svwhilelt_b32(base, n);\n            svint32_t data = svld1_s32(pg, &l[base]);\n            svint32_t target_vec = svdup_n_s32(target);\n            svbool_t match = svcmpeq_s32(pg, data, target_vec);\n\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n\n            base += vl;\n        }\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_84_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool pairs_sum_to_zero_simd(std::vector<int> l) {\n    int n = l.size();\n    if (n < 2) return false;\n\n    uint64_t vl = svcntw();\n    uint64_t count_zeros = 0;\n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &l[i]);\n        svint32_t zero_vec = svdup_n_s32(0);\n        svbool_t zero_mask = svcmpeq_s32(pg, data, zero_vec);\n        count_zeros += svcntp_b32(pg, zero_mask);\n    }\n    if (count_zeros >= 2) return true;\n\n    for (int i = 0; i < n; ++i) {\n        int x = l[i];\n        if (x == 0) continue;\n\n        int j = i + 1;\n        if (j >= n) break;\n\n        svint32_t neg_x = svdup_n_s32(-x);\n        while (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svint32_t data = svld1_s32(pg, &l[j]);\n            svbool_t match = svcmpeq_s32(pg, data, neg_x);\n            if (svptest_any(pg, match)) {\n                return true;\n            }\n            j += vl;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n#include <climits>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n\n    uint64_t ux = static_cast<uint64_t>(x);\n    int k = 0;\n    uint64_t base_k = 1;\n    while (base_k <= UINT64_MAX / static_cast<uint64_t>(base)) {\n        k++;\n        base_k *= base;\n    }\n\n    std::string res;\n    while (ux) {\n        uint64_t chunk = ux % base_k;\n        ux = ux / base_k;\n\n        if (ux) {\n            std::vector<uint64_t> powers_arr(k);\n            uint64_t p = 1;\n            for (int i = 0; i < k; i++) {\n                powers_arr[i] = p;\n                if (p <= UINT64_MAX / static_cast<uint64_t>(base)) {\n                    p *= base;\n                }\n            }\n\n            std::vector<uint64_t> rem_arr(k, 0);\n            size_t vl = svcntd();\n            for (int start = 0; start < k; start += vl) {\n                int segment_len = std::min(static_cast<int>(vl), k - start);\n                svbool_t pg = svwhilelt_b64(static_cast<uint64_t>(start), static_cast<uint64_t>(start + segment_len));\n                svuint64_t v_powers = svld1(pg, &powers_arr[start]);\n                svuint64_t v_chunk = svdup_u64(chunk);\n                svuint64_t v_quot = svdiv_u64_z(pg, v_chunk, v_powers);\n                svuint64_t v_base = svdup_u64(static_cast<uint64_t>(base));\n                svuint64_t v_quot_div = svdiv_u64_z(pg, v_quot, v_base);\n                svuint64_t v_rem = svmls_u64_z(pg, v_quot, v_quot_div, v_base);\n                svst1(pg, &rem_arr[start], v_rem);\n            }\n\n            for (int i = k - 1; i >= 0; i--) {\n                res = static_cast<char>('0' + rem_arr[i]) + res;\n            }\n        } else {\n            std::string s;\n            if (chunk == 0) {\n                s = \"0\";\n            } else {\n                while (chunk) {\n                    s = static_cast<char>('0' + (chunk % base)) + s;\n                    chunk /= base;\n                }\n            }\n            res = s + res;\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstdlib>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    if (x < 0) {\n        return \"\";\n    }\n\n    uint64_t ux = (uint64_t)x;\n    int k = 0;\n    uint64_t temp = ux;\n    while (temp) {\n        k++;\n        temp /= base;\n    }\n\n    uint64_t* divisors = (uint64_t*)malloc(k * sizeof(uint64_t));\n    uint64_t* digit_array = (uint64_t*)malloc(k * sizeof(uint64_t));\n    char* str = (char*)malloc(k + 1);\n    if (!divisors || !digit_array || !str) {\n        free(divisors);\n        free(digit_array);\n        free(str);\n        return \"\";\n    }\n\n    divisors[k - 1] = 1;\n    for (int i = k - 2; i >= 0; i--) {\n        divisors[i] = divisors[i + 1] * base;\n    }\n\n    uint32_t start = 0;\n    uint64_t vl = svcntd();\n    svuint64_t vbase = svdup_u64((uint64_t)base);\n\n    while (start < k) {\n        svbool_t pg = svwhilelt_b64_u32(start, (uint32_t)k);\n        svuint64_t vdiv = svld1_u64(pg, divisors + start);\n        svuint64_t vx = svdup_u64_x(pg, ux);\n        svuint64_t vquot = svdiv_u64_x(pg, vx, vdiv);\n        svuint64_t vquot_div_base = svdiv_u64_x(pg, vquot, vbase);\n        svuint64_t vmod = svmls_u64_x(pg, vquot, vquot_div_base, vbase);\n        svst1_u64(pg, digit_array + start, vmod);\n        start += vl;\n    }\n\n    for (int i = 0; i < k; i++) {\n        str[i] = '0' + (char)digit_array[i];\n    }\n    str[k] = '\\0';\n\n    std::string result(str);\n    free(divisors);\n    free(digit_array);\n    free(str);\n    return result;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n#include <climits>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    bool negative = false;\n    uint64_t ux;\n    if (x < 0) {\n        negative = true;\n        if (x == INT64_MIN) {\n            ux = 1ULL << 63;\n        } else {\n            ux = static_cast<uint64_t>(-x);\n        }\n    } else {\n        ux = static_cast<uint64_t>(x);\n    }\n\n    int d = 0;\n    uint64_t temp = ux;\n    while (temp) {\n        d++;\n        temp /= base;\n    }\n\n    std::vector<uint64_t> powers(d);\n    powers[0] = 1;\n    for (int i = 1; i < d; i++) {\n        powers[i] = powers[i-1] * base;\n    }\n\n    std::vector<uint64_t> digits_arr(d);\n    uint64_t vl = svcntd();\n    int i = 0;\n    while (i < d) {\n        svbool_t pg = svwhilelt_b64(i, d);\n        svuint64_t vec_power = svld1_u64(pg, &powers[i]);\n        svuint64_t vec_x = svdup_u64(ux);\n        svuint64_t vec_quot = svdiv_u64_z(pg, vec_x, vec_power);\n        svuint64_t vec_digit = svmod_u64_z(pg, vec_quot, svdup_u64(base));\n        svst1_u64(pg, &digits_arr[i], vec_digit);\n        i += vl;\n    }\n\n    std::string res;\n    if (negative) {\n        res.push_back('-');\n    }\n    for (int j = d-1; j >= 0; j--) {\n        res.push_back('0' + static_cast<char>(digits_arr[j]));\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n#include <climits>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string sign = \"\";\n    uint64_t ux;\n    if (x < 0) {\n        sign = \"-\";\n        if (x == INT64_MIN) {\n            ux = (1ULL << 63);\n        } else {\n            ux = static_cast<uint64_t>(-x);\n        }\n    } else {\n        ux = static_cast<uint64_t>(x);\n    }\n\n    int max_digits = 0;\n    uint64_t temp = ux;\n    while (temp) {\n        max_digits++;\n        temp /= base;\n    }\n\n    std::vector<uint64_t> power(max_digits);\n    if (max_digits > 0) {\n        power[0] = 1;\n        for (int i = 1; i < max_digits; i++) {\n            power[i] = power[i-1] * base;\n        }\n    }\n\n    std::vector<uint64_t> digits(max_digits);\n    uint64_t vl = svcntd();\n    svuint64_t vx = svdup_u64(ux);\n    svuint64_t vbase = svdup_u64(static_cast<uint64_t>(base));\n\n    for (int start = 0; start < max_digits; start += vl) {\n        svbool_t pg = svwhilelt_b64(start, max_digits);\n        svuint64_t vidx = svindex_u64(start, 1);\n        svuint64_t vpower = svld1_gather_u64index_u64(pg, power.data(), vidx);\n        svuint64_t vdiv = svdiv_u64_z(pg, vx, vpower);\n        svuint64_t vquot = svdiv_u64_z(pg, vdiv, vbase);\n        svuint64_t vdigit = svmls_u64_z(pg, vdiv, vquot, vbase);\n        svst1_u64(pg, digits.data() + start, vdigit);\n    }\n\n    std::string res;\n    for (int i = max_digits - 1; i >= 0; i--) {\n        res += '0' + static_cast<char>(digits[i]);\n    }\n    return sign + res;\n}\n```"}
{"task_id": "SimdBench_85_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string change_base_simd(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n\n    int num_digits = 0;\n    int64_t x_temp = x;\n    while (x_temp) {\n        num_digits++;\n        x_temp /= base;\n    }\n\n    int64_t powers_arr[64] = {0};\n    powers_arr[0] = 1;\n    for (int i = 1; i < num_digits; i++) {\n        powers_arr[i] = powers_arr[i-1] * base;\n    }\n\n    int64_t digit_arr[64] = {0};\n    svint64_t x_vec = svdup_s64(x);\n    svint64_t base_vec = svdup_s64(static_cast<int64_t>(base));\n\n    int start = 0;\n    while (start < num_digits) {\n        svbool_t pg = svwhilelt_b64(start, num_digits);\n        svint64_t pow_vec = svld1_s64(pg, &powers_arr[start]);\n        svint64_t quot_vec = svdiv_s64_z(pg, x_vec, pow_vec);\n        svint64_t mod_vec = svrem_s64_z(pg, quot_vec, base_vec);\n        svst1_s64(pg, &digit_arr[start], mod_vec);\n        start += svcntd();\n    }\n\n    std::string res;\n    for (int i = num_digits - 1; i >= 0; i--) {\n        res += '0' + static_cast<char>(digit_arr[i]);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) {\n        return true;\n    }\n    uint64_t left_index = 0;\n    uint64_t right_index = len - 1;\n    uint64_t max_vl = svcntb();\n\n    while (left_index < right_index) {\n        uint64_t nleft = right_index - left_index + 1;\n        uint64_t vl = nleft < max_vl ? nleft : max_vl;\n        svbool_t pg = svwhilelt_b8(0, vl);\n\n        svuint8_t left_vec = svld1_u8(pg, reinterpret_cast<uint8_t*>(text.data()) + left_index);\n        svuint64_t base_vec = svdup_u64(right_index);\n        svuint64_t offsets = svindex_u64(0, 1);\n        svuint64_t indices = svsub_u64_z(svptrue_b64(), base_vec, offsets);\n        svuint8_t reversed_right = svld1_gather_u64index_u8(pg, reinterpret_cast<uint8_t*>(text.data()), indices);\n\n        svbool_t mismatch = svcmpne(pg, left_vec, reversed_right);\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n\n        left_index += vl;\n        right_index -= vl;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) {\n        return true;\n    }\n    \n    uint8_t *lptr = reinterpret_cast<uint8_t*>(text.data());\n    uint8_t *rptr = reinterpret_cast<uint8_t*>(text.data()) + text.size() - 1;\n    \n    while (lptr < rptr) {\n        size_t vl = svcntb();\n        size_t remaining = rptr - lptr + 1;\n        size_t active = (remaining < vl) ? remaining : vl;\n        svbool_t pg = svwhilelt_b8(0, active);\n        \n        svuint8_t left_vec = svld1(pg, lptr);\n        svuint8_t right_vec = svld1(pg, rptr - active + 1);\n        svuint8_t right_reversed = svrev_u8(right_vec);\n        \n        svbool_t mismatch = svcmpne(pg, left_vec, right_reversed);\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n        \n        lptr += active;\n        rptr -= active;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n\nbool is_palindrome_simd(std::string text) {\n    size_t len = text.length();\n    if (len == 0) {\n        return true;\n    }\n\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(text.data());\n    const uint8_t *left = data;\n    const uint8_t *right = data + len - 1;\n    uint64_t half_len = len / 2;\n    uint64_t processed = 0;\n    uint64_t vl = svcntb();\n\n    while (processed < half_len) {\n        uint64_t remaining = half_len - processed;\n        uint64_t elts = (remaining < vl) ? remaining : vl;\n        svbool_t pred = svwhilelt_b8(0, elts);\n\n        svuint8_t left_vec = svld1_u8(pred, left + processed);\n        svuint8_t right_vec = svld1_u8(pred, right - processed - elts + 1);\n        svuint8_t rev_right = svrev_u8(right_vec);\n\n        svbool_t cmp = svcmpeq_u8(pred, left_vec, rev_right);\n        svbool_t not_cmp = svnot_b_z(pred, cmp);\n\n        if (svptest_any(pred, not_cmp)) {\n            return false;\n        }\n\n        processed += elts;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n#include <cstdint>\n\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) {\n        return true;\n    }\n    \n    const char* start = text.data();\n    const char* end = text.data() + text.size() - 1;\n    uint64_t vl = svcntb();\n    \n    while (start < end) {\n        uint64_t remaining = end - start + 1;\n        uint64_t k = (remaining / 2) < vl ? (remaining / 2) : vl;\n        \n        if (k == 0) {\n            break;\n        }\n        \n        svbool_t pg = svwhilelt_b8(0, k);\n        svuint8_t left_vec = svld1(pg, start);\n        svuint8_t right_vec = svld1(pg, end - k + 1);\n        svuint8_t right_rev = svrev(pg, right_vec);\n        \n        svbool_t mismatch = svcmpne(pg, left_vec, right_rev);\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n        \n        start += k;\n        end -= k;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_palindrome_simd(std::string text) {\n    if (text.empty()) {\n        return true;\n    }\n    uint64_t n = text.size();\n    uint64_t left_index = 0;\n    uint64_t right_index = n - 1;\n    uint64_t vl = svcntb();\n\n    while (left_index < right_index) {\n        uint64_t segment_length = right_index - left_index + 1;\n        uint64_t max_k = segment_length / 2;\n        uint64_t k = (vl < max_k) ? vl : max_k;\n\n        if (k == 0) {\n            break;\n        }\n\n        svbool_t pg = svwhilelt_b8(0, k);\n        const uint8_t* data = reinterpret_cast<const uint8_t*>(text.data());\n        svuint8_t left_vec = svld1(pg, data + left_index);\n        svuint8_t right_vec = svld1(pg, data + right_index - k + 1);\n        svuint8_t right_vec_reversed = svrev_s8(right_vec);\n        svbool_t cmp = svcmpeq_u8(pg, left_vec, right_vec_reversed);\n        svbool_t mismatch = svnot_b_z(pg, cmp);\n\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n\n        left_index += k;\n        right_index -= k;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    size_t len = s.length();\n    std::string out(len, '\\0');\n    if (len == 0) {\n        return out;\n    }\n\n    uint8_t *in_ptr = reinterpret_cast<uint8_t*>(&s[0]);\n    uint8_t *out_ptr = reinterpret_cast<uint8_t*>(&out[0]);\n    size_t i = 0;\n\n    svuint8_t base = svdup_n_u8('a');\n    svuint8_t add_val = svdup_n_u8(21);\n    svuint8_t twenty_six = svdup_n_u8(26);\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t in_vec = svld1_u8(pg, in_ptr + i);\n        svuint8_t offset = svsub_u8_z(pg, in_vec, base);\n        svuint8_t x = svadd_u8_z(pg, offset, add_val);\n        svbool_t mask = svcmpge_u8(pg, x, twenty_six);\n        svuint8_t adjusted = svsub_u8_m(mask, x, twenty_six);\n        svuint8_t decoded = svadd_u8_z(pg, adjusted, base);\n        svst1_u8(pg, out_ptr + i, decoded);\n        i += svcntp_b8(pg, pg);\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t n = s.size();\n    std::string out;\n    out.resize(n);\n    if (n == 0) {\n        return out;\n    }\n\n    uint8_t *in_ptr = reinterpret_cast<uint8_t*>(&s[0]);\n    uint8_t *out_ptr = reinterpret_cast<uint8_t*>(&out[0]);\n    size_t vl = svcntb();\n    size_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t vec = svld1_u8(pg, in_ptr + i);\n        svuint8_t shifted = svsub_n_u8_x(pg, vec, 5);\n        svbool_t mask = svcmplt_n_u8(pg, shifted, 'a');\n        shifted = svadd_n_u8_m(mask, shifted, 26);\n        svst1_u8(pg, out_ptr + i, shifted);\n        i += vl;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s){\n    std::string out(s.length(), '\\0');\n    size_t len = s.length();\n    size_t i = 0;\n    size_t vl = svcntb();\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input_vec = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t base = svdup_u8('a');\n        svuint8_t five = svdup_u8(5);\n        svuint8_t twenty_six = svdup_u8(26);\n\n        svuint8_t offset = svsub_u8_z(pg, input_vec, base);\n        offset = svsub_u8_z(pg, offset, five);\n        svint8_t signed_offset = svreinterpret_s8_u8(offset);\n        svbool_t negative = svcmplt_s8(pg, signed_offset, 0);\n        offset = svadd_u8_m(negative, offset, twenty_six);\n        svuint8_t decoded_vec = svadd_u8_z(pg, offset, base);\n        svst1_u8(pg, (uint8_t*)(out.data() + i), decoded_vec);\n        i += vl;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    if (s.empty()) \n        return \"\";\n\n    std::string out(s.length(), '\\0');\n    uint8_t *in_data = reinterpret_cast<uint8_t*>(&s[0]);\n    uint8_t *out_data = reinterpret_cast<uint8_t*>(&out[0]);\n    size_t len = s.length();\n    size_t i = 0;\n    size_t vl = svcntb();\n\n    svuint8_t vec_5 = svdup_n_u8(5);\n    svuint8_t vec_26 = svdup_n_u8(26);\n    svuint8_t vec_a = svdup_n_u8('a');\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t in_vec = svld1_u8(pg, in_data + i);\n        svuint8_t shifted = svsub_u8_x(pg, in_vec, vec_5);\n        svbool_t mask = svcmplt_u8(pg, shifted, vec_a);\n        shifted = svadd_u8_m(mask, shifted, vec_26);\n        svst1_u8(pg, out_data + i, shifted);\n        i += vl;\n    }\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_87_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string decode_shift_simd(std::string s) {\n    size_t len = s.length();\n    std::string out_str(len, '\\0');\n    char *out = &out_str[0];\n    const char *in = s.c_str();\n\n    size_t i = 0;\n    unsigned int vl = svcntb();\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t input_vec = svld1_u8(pg, (const uint8_t*)&in[i]);\n        svuint8_t base = svsub_u8_x(pg, input_vec, svdup_n_u8('a'));\n        svuint8_t base_plus = svadd_u8_x(pg, base, svdup_n_u8(21));\n        svbool_t mask = svcmpge_u8(pg, base_plus, svdup_n_u8(26));\n        svuint8_t modulo = svsub_u8_m(mask, base_plus, svdup_n_u8(26));\n        svuint8_t result = svadd_u8_x(pg, modulo, svdup_n_u8('a'));\n        svst1_u8(pg, (uint8_t*)&out[i], result);\n\n        i += vl;\n        pg = svwhilelt_b8(i, len);\n    }\n\n    return out_str;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    if (l.empty()) \n        return true;\n    \n    size_t n = l.size();\n    int* data = l.data();\n    uint64_t vl = svcntw();\n    svint32_t threshold_vec = svdup_n_s32(t);\n    \n    uint64_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t input_vec = svld1_s32(pg, data + i);\n        svbool_t cmp_ge = svcmpge(pg, input_vec, threshold_vec);\n        \n        if (svptest_any(pg, cmp_ge))\n            return false;\n            \n        i += vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    uint64_t n = l.size();\n    uint64_t i = 0;\n    svint32_t t_vec = svdup_n_s32(t);\n    svbool_t all_true = svptrue_b32();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        svint32_t data = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmpge_s32(pg, data, t_vec);\n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n        i += svcntp_b32(all_true, pg);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    size_t n = l.size();\n    size_t i = 0;\n    bool all_below = true;\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    svint32_t t_vec = svdup_n_s32(t);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmpge_s32(pg, data, t_vec);\n        \n        if (svptest_any(pg, cmp)) {\n            all_below = false;\n            break;\n        }\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    \n    return all_below;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool below_threshold_simd(std::vector<int> l, int t) {\n    int n = l.size();\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    svint32_t threshold_vec = svdup_n_s32(t);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &l[i]);\n        svbool_t cmp = svcmpge_s32(pg, data, threshold_vec);\n        if (svptest_any(svptrue_b32(), cmp)) \n            return false;\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88_SVE", "completion": "```c\n#include <arm_sve.h> \n\n/*\nReturn true if all numbers in the vector l are below threshold t.\n>>> below_threshold_simd({1, 2, 4, 10}, 100)\ntrue\n>>> below_threshold_simd({1, 20, 4, 10}, 5)\nfalse\n\nThe requirement is to implement the function using SVE (Arm C Language Extensions (ACLE) for the Arm Scalable Vector Extension (SVE)) intrinsics to achieve parallelism.\n*/\nbool below_threshold_simd(std::vector<int>l, int t){\n    uint64_t n = l.size();\n    if (n == 0) {\n        return true;\n    }\n    uint64_t i = 0;\n    svint32_t t_vec = svdup_n_s32(t);\n    uint64_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &l[i]);\n        svbool_t p_fail = svcmpge_s32(pg, vec, t_vec);\n        if (svptest_any(pg, p_fail)) {\n            return false;\n        }\n        i += vl;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t base = 0;\n    size_t len = brackets.length();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        uint64_t vl = svcntp_b8(pg, pg);\n        const uint8_t *data = reinterpret_cast<const uint8_t*>(brackets.data() + i);\n        svuint8_t chars = svld1_u8(pg, data);\n        \n        svbool_t mask_open = svcmpeq(pg, chars, '<');\n        svbool_t mask_close = svcmpeq(pg, chars, '>');\n        \n        svint8_t v8 = svsel_s8(mask_open, \n                              svdup_s8(1), \n                              svsel_s8(mask_close, \n                                      svdup_s8(-1), \n                                      svdup_s8(0)));\n        \n        int32_t total = svaddv_s8(pg, v8);\n        \n        int8_t buffer[vl];\n        svst1_s8(pg, buffer, v8);\n        \n        int32_t accum = 0;\n        int32_t min_in_chunk = 0;\n        for (uint64_t j = 0; j < vl; j++) {\n            accum += buffer[j];\n            if (accum < min_in_chunk) {\n                min_in_chunk = accum;\n            }\n        }\n        \n        if (base + min_in_chunk < 0) {\n            return false;\n        }\n        \n        base += total;\n        i += vl;\n    }\n    \n    return base == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool correct_bracketing_simd(std::string brackets) {\n    uint64_t n = brackets.size();\n    uint64_t index = 0;\n    int64_t base = 0;\n    \n    while (index < n) {\n        svbool_t pg = svwhilelt_b8(index, n);\n        uint64_t active_lanes = svcntp_b8(pg, pg);\n        \n        svuint8_t input = svld1_u8(pg, (const uint8_t*) (brackets.data() + index));\n        svbool_t cmp_lt = svcmpeq_u8(pg, input, '<');\n        svbool_t cmp_gt = svcmpeq_u8(pg, input, '>');\n        \n        uint64_t count_lt = svcntp_b8(pg, cmp_lt);\n        uint64_t count_gt = svcntp_b8(pg, cmp_gt);\n        int64_t net = count_lt - count_gt;\n        \n        int64_t min_in_chunk = 0;\n        int64_t current = 0;\n        for (uint64_t i = 0; i < active_lanes; i++) {\n            char c = brackets[index + i];\n            if (c == '<') {\n                current++;\n            } else if (c == '>') {\n                current--;\n            }\n            if (current < min_in_chunk) {\n                min_in_chunk = current;\n            }\n        }\n        \n        if (base + min_in_chunk < 0) {\n            return false;\n        }\n        \n        base += net;\n        index += active_lanes;\n    }\n    \n    return (base == 0);\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstdint>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int balance = 0;\n    int n = brackets.size();\n    const char *ptr = brackets.c_str();\n    uint64_t max_vl = svcntb();\n    uint64_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        uint64_t vl = svcntp_b8(pg, pg);\n\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(ptr + i));\n        svuint8_t open_char = svdup_u8('<');\n        svuint8_t close_char = svdup_u8('>');\n        svbool_t mask_open = svcmpeq_u8(pg, input, open_char);\n        svbool_t mask_close = svcmpeq_u8(pg, input, close_char);\n\n        svint8_t v_inc_open = svreinterpret_s8_u8(svand_u8_z(pg, mask_open, svdup_u8(1)));\n        svint8_t v_inc_close = svreinterpret_s8_u8(svand_u8_z(pg, mask_close, svdup_u8(1)));\n        svint8_t v_inc = svsub_s8_z(pg, v_inc_open, v_inc_close);\n\n        int8_t inc_arr[256];\n        svst1_s8(pg, inc_arr, v_inc);\n\n        int chunk_min = 0;\n        int chunk_sum = 0;\n        for (uint64_t j = 0; j < vl; j++) {\n            chunk_sum += inc_arr[j];\n            if (chunk_sum < chunk_min) {\n                chunk_min = chunk_sum;\n            }\n        }\n\n        if (balance + chunk_min < 0) {\n            return false;\n        }\n\n        balance += chunk_sum;\n        i += vl;\n    }\n\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool correct_bracketing_simd(std::string brackets){\n    uint64_t i = 0;\n    int64_t count = 0;\n    svbool_t pg = svptrue_b8();\n\n    while (i < brackets.size()) {\n        svbool_t active = svwhilelt_b8(i, brackets.size());\n        uint64_t num_active = svcntp_b8(active, active);\n        if (num_active == 0) break;\n\n        svuint8_t input = svldff1_u8(active, (const uint8_t*)(brackets.data() + i));\n        svint8_t ones = svdup_n_s8(1);\n        svint8_t neg_ones = svdup_n_s8(-1);\n        svbool_t cmp = svcmpeq(active, input, '<');\n        svint8_t v = svsel_s8(cmp, ones, neg_ones);\n\n        int8_t buffer[num_active];\n        svst1_s8(active, buffer, v);\n\n        int64_t s = 0;\n        int64_t min_in_chunk = 0;\n        for (uint64_t j = 0; j < num_active; j++) {\n            s += buffer[j];\n            if (s < min_in_chunk) {\n                min_in_chunk = s;\n            }\n        }\n\n        if (count + min_in_chunk < 0) {\n            return false;\n        }\n        count += s;\n        i += num_active;\n    }\n\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* ptr = brackets.c_str();\n    int len = brackets.size();\n    int base = 0;\n    int64_t i = 0;\n    uint64_t vl;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(ptr + i));\n        vl = svcntp_b8(pg, pg);\n\n        for (uint64_t j = 0; j < vl; j++) {\n            char c = (char)svdupb_u8(chars, j);\n            if (c == '<') {\n                base++;\n            } else if (c == '>') {\n                base--;\n            }\n            if (base < 0) {\n                return false;\n            }\n        }\n        i += vl;\n    }\n\n    return base == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    const char* ptr = brackets.data();\n    size_t len = brackets.length();\n    if (len == 0) {\n        return true;\n    }\n    size_t vl = svcntb();\n    int64_t global_counter = 0;\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)(ptr + i));\n        size_t num_active = svcntp_b8(pg, pg);\n\n        int64_t min_prefix = 0;\n        int64_t current_in_chunk = 0;\n\n        for (size_t j = 0; j < num_active; j++) {\n            char c = (char)svdupb_u8(pg, data, j);\n            if (c == '(') {\n                current_in_chunk++;\n            } else if (c == ')') {\n                current_in_chunk--;\n            }\n            if (current_in_chunk < min_prefix) {\n                min_prefix = current_in_chunk;\n            }\n        }\n\n        if (global_counter + min_prefix < 0) {\n            return false;\n        }\n\n        global_counter += current_in_chunk;\n        i += num_active;\n    }\n\n    return global_counter == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t global_counter = 0;\n    int64_t i = 0;\n    const int64_t n = brackets.length();\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        uint64_t vl = svcntp_b8(pg, pg);\n        \n        svuint8_t input = svld1_u8(pg, reinterpret_cast<const uint8_t*>(brackets.data() + i));\n        \n        svint8_t open_flag = svreinterpret_s8_u8(svcmpeq_u8(pg, input, '('));\n        open_flag = svneg_s8_z(pg, open_flag);\n        svint8_t close_flag = svreinterpret_s8_u8(svcmpeq_u8(pg, input, ')'));\n        close_flag = svneg_s8_z(pg, close_flag);\n        svint8_t delta = svsub_s8_z(pg, open_flag, close_flag);\n        \n        int8_t delta_arr[256];\n        svst1_s8(pg, delta_arr, delta);\n        \n        int64_t chunk_min = 0;\n        int64_t chunk_sum = 0;\n        for (uint64_t j = 0; j < vl; ++j) {\n            chunk_sum += delta_arr[j];\n            if (chunk_sum < chunk_min) {\n                chunk_min = chunk_sum;\n            }\n        }\n        \n        if (global_counter + chunk_min < 0) {\n            return false;\n        }\n        \n        global_counter += chunk_sum;\n        i += vl;\n    }\n    \n    return global_counter == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t carry = 0;\n    const char* ptr = brackets.data();\n    const char* end_ptr = ptr + brackets.size();\n    size_t max_vl = svcntb();\n    uint8_t buf[256]; // Maximum SVE vector length (256 bytes)\n\n    while (ptr < end_ptr) {\n        svbool_t pg = svwhilelt_b8(ptr, end_ptr);\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)ptr);\n        size_t vl = svcntp_b8(pg, pg);\n        svst1_u8(pg, buf, input);\n\n        int32_t chunk_min = 0;\n        int32_t current = 0;\n        for (size_t i = 0; i < vl; ++i) {\n            if (buf[i] == '(') {\n                current += 1;\n            } else if (buf[i] == ')') {\n                current -= 1;\n            }\n            if (current < chunk_min) {\n                chunk_min = current;\n            }\n        }\n\n        if (carry + chunk_min < 0) {\n            return false;\n        }\n        carry += current;\n        ptr += vl;\n    }\n\n    return carry == 0;\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int64_t depth = 0;\n    int64_t min_depth = 0;\n    const char *data = brackets.data();\n    size_t len = brackets.length();\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg8 = svwhilelt_b8(i, len);\n        uint64_t n8 = svcntp_b8(svptrue_b8(), pg8);\n        if (n8 == 0) break;\n\n        svbool_t pg32 = svwhilelt_b32(0, (int32_t)n8);\n        svint32_t char_vec = svld1sb_s32(pg32, (const int8_t*)(data + i));\n        svbool_t p_open = svcmpeq_n_s32(pg32, char_vec, '(');\n        svbool_t p_close = svcmpeq_n_s32(pg32, char_vec, ')');\n        svint32_t values = svdup_n_s32(0);\n        values = svsel_s32(p_open, svdup_n_s32(1), values);\n        values = svsel_s32(p_close, svdup_n_s32(-1), values);\n\n        int32_t total = svaddv_s32(pg32, values);\n        int32_t min_prefix = 0;\n\n        if (n8 > 0) {\n            svint32_t scan = values;\n            if (n8 > 1) {\n                for (int offset = 1; offset < n8; offset *= 2) {\n                    svint32_t indices = svindex_s32(0, 1);\n                    svint32_t shifted_indices = svsub_n_s32_z(svptrue_b32(), indices, offset);\n                    svint32_t shifted = svtbl_s32(scan, svreinterpret_u32_s32(shifted_indices));\n                    scan = svadd_m(pg32, scan, shifted);\n                }\n            }\n            svint32_t min_vec = svmin_s32_z(pg32, scan, svdup_n_s32(0));\n            int32_t min_scan = svminv_s32(pg32, min_vec);\n            min_prefix = min_scan;\n        }\n\n        min_depth = (min_depth < depth + min_prefix) ? min_depth : depth + min_prefix;\n        depth += total;\n\n        if (min_depth < 0) {\n            return false;\n        }\n\n        i += n8;\n    }\n\n    return (depth == 0) && (min_depth >= 0);\n}\n```"}
{"task_id": "SimdBench_90_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool correct_bracketing_simd(std::string brackets) {\n    int32_t base = 0;\n    size_t i = 0;\n    size_t n = brackets.size();\n    if (n == 0) {\n        return true;\n    }\n\n    while (i < n) {\n        svbool_t pg32 = svwhilelt_b32(i, n);\n        svint32_t chars = svld1sb_s32(pg32, (const int8_t*)(brackets.data() + i));\n        svint32_t ones = svdup_n_s32(1);\n        svint32_t neg_ones = svdup_n_s32(-1);\n        svbool_t open_mask = svcmpeq_n_s32(pg32, chars, '(');\n        svint32_t values = svsel_s32(open_mask, ones, neg_ones);\n\n        svint32_t scan_incl = svscanadd_s32(svdup_n_s32(0), pg32, values);\n        svint32_t min_vec = svmin_s32_z(pg32, scan_incl, svdup_n_s32(0));\n        int32_t min_prefix = svminv_s32(pg32, min_vec);\n        if (base + min_prefix < 0) {\n            return false;\n        }\n\n        int32_t total_in_vector = svaddv_s32(pg32, values);\n        base += total_in_vector;\n\n        i += svcntp_b32(pg32, pg32);\n    }\n\n    return base == 0;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    uint64_t n = xs.size() - 1;\n    std::vector<float> result(n);\n    float *in_ptr = xs.data() + 1;\n    float *out_ptr = result.data();\n    uint64_t vl = svcntw();\n    for (uint64_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t coeffs = svld1(pg, in_ptr + i);\n        svint32_t multipliers = svindex_s32(i + 1, 1);\n        svfloat32_t mults_float = svcvt_f32_x(pg, multipliers);\n        svfloat32_t res = svmul_x(pg, coeffs, mults_float);\n        svst1(pg, out_ptr + i, res);\n        i += vl;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    size_t n = xs.size() - 1;\n    std::vector<float> res(n);\n\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    do {\n        svint32_t indices = svindex_s32(static_cast<int32_t>(i+1), 1);\n        svfloat32_t indices_f = svcvt_f32_s32_z(pg, indices);\n        svfloat32_t data = svld1_f32(pg, &xs[1+i]);\n        svfloat32_t product = svmul_f32_z(pg, data, indices_f);\n        svst1_f32(pg, &res[i], product);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    size_t n = xs.size();\n    size_t n_out = (n == 0) ? 0 : n - 1;\n    std::vector<float> out(n_out);\n    \n    if (n_out == 0) \n        return out;\n\n    uint32_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n_out);\n    do {\n        svuint32_t indices = svindex_u32(0, 1);\n        svuint32_t base_vec = svdup_u32(i + 1);\n        svuint32_t multipliers_uint = svadd_u32_z(pg, base_vec, indices);\n        svfloat32_t multipliers = svcvt_f32_u32_z(pg, multipliers_uint);\n        svfloat32_t coeffs = svld1_f32(pg, &xs[i + 1]);\n        svfloat32_t res = svmul_f32_z(pg, multipliers, coeffs);\n        svst1_f32(pg, &out[i], res);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n_out);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return out;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    \n    size_t out_size = xs.size() - 1;\n    std::vector<float> res(out_size);\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, out_size);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t idx_vec = svindex_s32(i, 1);\n        svint32_t multiplier = svadd_s32_x(pg, idx_vec, svdup_s32(1));\n        svfloat32_t coeffs = svld1(pg, &xs[i+1]);\n        svfloat32_t conv_mult = svcvt_f32_x(pg, multiplier);\n        svfloat32_t result = svmul_x(pg, coeffs, conv_mult);\n        svst1(pg, &res[i], result);\n        \n        i += svcntp_b32(svptrue_b32(), pg);\n        pg = svwhilelt_b32(i, out_size);\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_91_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<float> derivative_simd(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    \n    std::vector<float> result(xs.size() - 1);\n    float* in_ptr = xs.data() + 1;\n    float* out_ptr = result.data();\n    uint64_t n = xs.size() - 1;\n    uint64_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t in_vec = svld1(pg, in_ptr + i);\n        svuint32_t indices = svindex_u32(i + 1, 1);\n        svfloat32_t idx_f32 = svcvt_f32_x(pg, indices);\n        svfloat32_t res_vec = svmul_x(pg, in_vec, idx_f32);\n        svst1(pg, out_ptr + i, res_vec);\n        i += svcntp_b32(pg, pg);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint vowels_count_simd(std::string s) {\n    int n = s.size();\n    if (n == 0) return 0;\n\n    const unsigned char *str = reinterpret_cast<const unsigned char*>(s.c_str());\n    uint64_t total = 0;\n    uint64_t i = 0;\n    svuint8_t offset = svdup_n_u8(32);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t input = svld1ub(pg, str + i);\n\n        svbool_t is_upper = svand_b_z(pg, \n                                    svcmpge(pg, input, 'A'),\n                                    svcmple(pg, input, 'Z'));\n        svuint8_t lower_data = svadd_m(is_upper, input, offset);\n\n        svbool_t vowel_mask = svcmpeq(pg, lower_data, 'a');\n        vowel_mask = svorr_b(vowel_mask, svcmpeq(pg, lower_data, 'e'));\n        vowel_mask = svorr_b(vowel_mask, svcmpeq(pg, lower_data, 'i'));\n        vowel_mask = svorr_b(vowel_mask, svcmpeq(pg, lower_data, 'o'));\n        vowel_mask = svorr_b(vowel_mask, svcmpeq(pg, lower_data, 'u'));\n\n        total += svcntp_b8(pg, vowel_mask);\n        i += svcntp_b8(svptrue_b8(), pg);\n    }\n\n    char last_char = s[n-1];\n    if (last_char == 'y' || last_char == 'Y') {\n        total++;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int n = s.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    uint64_t count = 0;\n    size_t vl = svcntb();\n\n    svuint8_t vowel_a = svdup_u8('a');\n    svuint8_t vowel_e = svdup_u8('e');\n    svuint8_t vowel_i = svdup_u8('i');\n    svuint8_t vowel_o = svdup_u8('o');\n    svuint8_t vowel_u = svdup_u8('u');\n    svuint8_t mask_0x20 = svdup_u8(0x20);\n\n    int i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t input = svld1(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t lower_input = svorr_x(pg, input, mask_0x20);\n\n        svbool_t cmp_a = svcmpeq(pg, lower_input, vowel_a);\n        svbool_t cmp_e = svcmpeq(pg, lower_input, vowel_e);\n        svbool_t cmp_i = svcmpeq(pg, lower_input, vowel_i);\n        svbool_t cmp_o = svcmpeq(pg, lower_input, vowel_o);\n        svbool_t cmp_u = svcmpeq(pg, lower_input, vowel_u);\n\n        svbool_t any_vowel = svorr_z(pg, cmp_a, cmp_e);\n        any_vowel = svorr_z(pg, any_vowel, cmp_i);\n        any_vowel = svorr_z(pg, any_vowel, cmp_o);\n        any_vowel = svorr_z(pg, any_vowel, cmp_u);\n\n        count += svcntp_b8(any_vowel, pg);\n        i += vl;\n    }\n\n    char last_char = s[n-1];\n    if (last_char == 'y' || last_char == 'Y') {\n        count++;\n    }\n\n    return (int)count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t n = s.length();\n    if (n == 0) return 0;\n\n    uint64_t vl = svcntb();\n    uint64_t total = 0;\n    uint64_t i = 0;\n    svuint8_t mask = svdup_u8(0x20);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t input = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t lower = svorr_u8_x(pg, input, mask);\n\n        svbool_t cmp_a = svcmpeq(pg, lower, 'a');\n        svbool_t cmp_e = svcmpeq(pg, lower, 'e');\n        svbool_t cmp_i = svcmpeq(pg, lower, 'i');\n        svbool_t cmp_o = svcmpeq(pg, lower, 'o');\n        svbool_t cmp_u = svcmpeq(pg, lower, 'u');\n\n        svbool_t cmp_any = svorr_z(pg, cmp_a, cmp_e);\n        cmp_any = svorr_m(pg, cmp_any, cmp_i);\n        cmp_any = svorr_m(pg, cmp_any, cmp_o);\n        cmp_any = svorr_m(pg, cmp_any, cmp_u);\n\n        total += svcntp_b8(pg, cmp_any);\n        i += vl;\n    }\n\n    char last_char = s[n-1];\n    if (last_char == 'y' || last_char == 'Y') {\n        total++;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    size_t len_total = s.length();\n    if (len_total == 0) {\n        return 0;\n    }\n\n    const char *str = s.c_str();\n    uint64_t count = 0;\n    size_t index = 0;\n\n    while (index < len_total) {\n        svbool_t pg = svwhilelt_b8(index, len_total);\n        uint64_t vl = svcntp_b8(svptrue_b8(), pg);\n        if (vl == 0) {\n            break;\n        }\n\n        svuint8_t data = svld1_u8(pg, (const uint8_t *)(str + index));\n\n        svbool_t mask = svcmpeq_n_u8(pg, data, 'a');\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'e'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'i'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'o'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'u'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'A'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'E'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'I'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'O'));\n        mask = svorr_b_z(pg, mask, svcmpeq_n_u8(pg, data, 'U'));\n\n        count += svcntp_b8(pg, mask);\n\n        index += vl;\n    }\n\n    char last_char = str[len_total - 1];\n    if (last_char == 'y' || last_char == 'Y') {\n        count++;\n    }\n\n    return (int)count;\n}\n```"}
{"task_id": "SimdBench_92_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint vowels_count_simd(std::string s) {\n    int count = 0;\n    size_t len = s.length();\n    if (len == 0) {\n        return 0;\n    }\n\n    uint64_t vl = svcntb();\n    uint64_t i = 0;\n\n    svuint8_t mask20 = svdup_u8(0x20);\n    svuint8_t vowel_a = svdup_u8('a');\n    svuint8_t vowel_e = svdup_u8('e');\n    svuint8_t vowel_i = svdup_u8('i');\n    svuint8_t vowel_o = svdup_u8('o');\n    svuint8_t vowel_u = svdup_u8('u');\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input = svld1_u8(pg, (uint8_t*)(s.data() + i));\n        svuint8_t low_input = svorr_u8_x(pg, input, mask20);\n\n        svbool_t cmp_a = svcmpeq_u8(pg, low_input, vowel_a);\n        svbool_t cmp_e = svcmpeq_u8(pg, low_input, vowel_e);\n        svbool_t cmp_i = svcmpeq_u8(pg, low_input, vowel_i);\n        svbool_t cmp_o = svcmpeq_u8(pg, low_input, vowel_o);\n        svbool_t cmp_u = svcmpeq_u8(pg, low_input, vowel_u);\n\n        svbool_t any = svorr_b_z(pg, cmp_a, cmp_e);\n        any = svorr_b_z(pg, any, cmp_i);\n        any = svorr_b_z(pg, any, cmp_o);\n        any = svorr_b_z(pg, any, cmp_u);\n\n        count += svcntp_b8(pg, any);\n        i += vl;\n    }\n\n    char last_char = s[len-1];\n    if (last_char == 'y' || last_char == 'Y') {\n        count++;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    const char* str = s.c_str();\n    size_t len = s.length();\n    size_t i = 0;\n    uint64_t sum = 0;\n\n    if (len == 0) \n        return 0;\n\n    svuint64_t sum_vec = svdupq_n_u64(0, 0, 0, 0);\n    svbool_t all_true = svptrue_b8();\n    uint64_t vl = svcntb();\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1(pg, (const uint8_t*)str + i);\n        \n        svbool_t uppercase = svand_z(pg, \n                            svcmpge(pg, chars, 'A'),\n                            svcmple(pg, chars, 'Z'));\n        \n        svuint8_t filtered = svsel(uppercase, chars, svdup_n_u8(0));\n        svuint64_t zero = svdup_n_u64(0);\n        svuint64_t partial = svdot_u64(zero, filtered, svdup_n_u8(1));\n        sum_vec = svaddq_u64(sum_vec, partial);\n        \n        i += vl;\n    }\n\n    uint64_t tmp[4];\n    svst1q_u64(all_true, tmp, sum_vec);\n    sum = tmp[0] + tmp[1] + tmp[2] + tmp[3];\n    \n    return (int)sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <string>\n\nint digitSum_simd(std::string s){\n    if (s.empty()) {\n        return 0;\n    }\n    \n    uint32_t total = 0;\n    size_t index = 0;\n    size_t len = s.length();\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    \n    while (index < len) {\n        svbool_t pg = svwhilelt_b8(index, len);\n        svuint8_t input = svld1_u8(pg, data + index);\n        \n        svbool_t mask_upper = svand_b_z(pg, \n                            svcmpge_u8(pg, input, (uint8_t)'A'),\n                            svcmple_u8(pg, input, (uint8_t)'Z'));\n        \n        svuint8_t chars_upper = svsel_u8(mask_upper, input, svdup_n_u8(0));\n        \n        svuint16_t low16 = svmovlb_u8(chars_upper);\n        svuint16_t high16 = svmovlt_u8(chars_upper);\n        \n        total += (uint32_t)svaddv_u16(svptrue_b16(), low16);\n        total += (uint32_t)svaddv_u16(svptrue_b16(), high16);\n        \n        index += svcntb();\n    }\n    \n    return (int)total;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "To solve this problem, we need to compute the sum of the ASCII values of all uppercase letters in a given string using SVE (Scalable Vector Extension) intrinsics for parallelism. The solution processes the string in chunks of SVE vector length, efficiently identifying uppercase letters and summing their ASCII values.\n\n### Approach\n1. **Initialization**: Check if the input string is empty and return 0 immediately.\n2. **Vector Processing**: \n   - Determine the vector length in bytes using `svcntb()`.\n   - Process the string in chunks of this vector length.\n3. **Predicate Creation**: For each chunk:\n   - Create a predicate to handle the active elements (remaining characters in the string).\n   - Load the current chunk of characters into a vector.\n4. **Uppercase Detection**:\n   - Create predicates to identify characters that are uppercase (i.e., between 'A' and 'Z' inclusive).\n   - Combine these predicates to form a mask for uppercase letters.\n5. **Masking and Summing**:\n   - Apply the mask to zero out non-uppercase characters.\n   - Sum the ASCII values of the uppercase characters in the current chunk using `svaddv_u8`.\n6. **Accumulation**: Add the sum of the current chunk to the total sum.\n7. **Result**: After processing all chunks, return the total sum as an integer.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    if (s.empty()) \n        return 0;\n\n    uint32_t total = 0;\n    size_t len = s.length();\n    size_t index = 0;\n    size_t vl = svcntb();\n\n    while (index < len) {\n        svbool_t pg = svwhilelt_b8(index, len);\n        svuint8_t data = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + index));\n\n        svbool_t cmp_ge_A = svcmpge_n_u8(pg, data, 'A');\n        svbool_t cmp_le_Z = svcmple_n_u8(pg, data, 'Z');\n        svbool_t pg_upper = svand_b_z(pg, cmp_ge_A, cmp_le_Z);\n\n        svuint8_t data_upper = svand_u8_z(pg_upper, data);\n\n        uint64_t chunk_sum = svaddv_u8(svptrue_b8(), data_upper);\n        total += static_cast<uint32_t>(chunk_sum);\n\n        index += vl;\n    }\n\n    return static_cast<int>(total);\n}\n```\n\n### Explanation\n1. **Initialization**: The function first checks if the input string is empty and returns 0 if true.\n2. **Vector Length**: The SVE vector length in bytes is obtained using `svcntb()`, which determines how many characters are processed in each iteration.\n3. **Loop Processing**: The loop processes the string in chunks of size `vl`:\n   - **Predicate Handling**: `svwhilelt_b8` creates a predicate for active elements in the current chunk.\n   - **Data Loading**: `svld1_u8` loads the current chunk of characters into a vector.\n4. **Uppercase Detection**:\n   - Two predicates (`cmp_ge_A` and `cmp_le_Z`) identify characters that are uppercase.\n   - These predicates are combined (`svand_b_z`) to form a mask (`pg_upper`) for uppercase letters.\n5. **Masking and Summing**:\n   - Non-uppercase characters are zeroed out using `svand_u8_z`.\n   - The sum of ASCII values in the current chunk is computed using `svaddv_u8`, which sums all elements in the vector.\n6. **Accumulation**: The chunk sum is added to the total sum.\n7. **Result Conversion**: After processing all chunks, the total sum is cast to an integer and returned.\n\nThis approach efficiently leverages SVE's parallel processing capabilities to handle large strings, ensuring optimal performance while correctly summing the ASCII values of uppercase letters."}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint digitSum_simd(std::string s) {\n    if (s.empty()) \n        return 0;\n\n    int len = s.length();\n    uint64_t global_sum = 0;\n    int i = 0;\n    uint64_t vl = svcntb();\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n\n        svbool_t cmp_ge = svcmpge(pg, chars, (uint8_t)'A');\n        svbool_t cmp_le = svcmple(pg, chars, (uint8_t)'Z');\n        svbool_t upper_pg = svand_b_z(pg, cmp_ge, cmp_le);\n\n        uint64_t part = svaddv_u8(upper_pg, chars);\n        global_sum += part;\n        i += vl;\n    }\n\n    return (int)global_sum;\n}\n```"}
{"task_id": "SimdBench_93_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint digitSum_simd(std::string s) {\n    uint64_t len = s.length();\n    uint64_t index = 0;\n    uint64_t total = 0;\n\n    while (index < len) {\n        svbool_t pg = svwhilelt_b8(index, len);\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(s.data() + index));\n        \n        svuint8_t upperA = svdup_n_u8('A');\n        svuint8_t upperZ = svdup_n_u8('Z');\n        \n        svbool_t cmp_ge = svcmpge(pg, input, upperA);\n        svbool_t cmp_le = svcmple(pg, input, upperZ);\n        svbool_t is_upper = svand_z(pg, cmp_ge, cmp_le);\n        \n        svuint8_t upper_chars = svsel(is_upper, input, svdup_n_u8(0));\n        \n        uint64_t partial_sum = svaddv_u8(pg, upper_chars);\n        total += partial_sum;\n        \n        index += svcntb();\n    }\n    \n    return (int)total;\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n#include <cstdint>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    int n = arr.size();\n    int global_min = INT_MAX;\n    int global_index = -1;\n    uint64_t vl = svcntw();\n    int i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svint32_t low_bits = svand_n_s32_z(pg, data, 1);\n        svbool_t even_pred = svcmpeq_n_s32(pg, low_bits, 0);\n        uint64_t count = svcntp_b32(pg, even_pred);\n\n        if (count > 0) {\n            int32_t min_val_in_vec = svminv_s32(even_pred, data);\n            svbool_t min_val_pred = svcmpeq_n_s32(even_pred, data, min_val_in_vec);\n            int first_in_vec = svpfirst_b(svptrue_b32(), min_val_pred);\n            int candidate_index = i + first_in_vec;\n\n            if (min_val_in_vec < global_min) {\n                global_min = min_val_in_vec;\n                global_index = candidate_index;\n            }\n        }\n        i += vl;\n    }\n\n    if (global_index == -1) {\n        return {};\n    } else {\n        return {global_min, global_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n#include <cstdint>\n#include <vector>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) {\n        return {};\n    }\n\n    uint64_t i = 0;\n    int32_t global_min_val = INT_MAX;\n    uint32_t global_min_index = UINT32_MAX;\n    svbool_t pg = svwhilelt_b32(i, n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, arr.data() + i);\n        svuint32_t index_vec = svindex_u32(i, 1);\n        svint32_t low_bits = svand_s32_x(pg, data, svdup_s32(1));\n        svbool_t pg_even = svcmpeq_s32(pg, low_bits, svdup_s32(0));\n\n        if (svptest_any(svptrue_b32(), pg_even)) {\n            int32_t min_val_seg = svminv_s32(pg_even, data);\n            svbool_t pg_min = svand_b_z(pg_even, svcmpeq_s32(pg_even, data, svdup_s32(min_val_seg)));\n            uint32_t min_index_seg = svminv_u32(pg_min, index_vec);\n\n            if (min_val_seg < global_min_val) {\n                global_min_val = min_val_seg;\n                global_min_index = min_index_seg;\n            } else if (min_val_seg == global_min_val) {\n                if (min_index_seg < global_min_index) {\n                    global_min_index = min_index_seg;\n                }\n            }\n        }\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    if (global_min_index == UINT32_MAX) {\n        return {};\n    } else {\n        return { global_min_val, static_cast<int>(global_min_index) };\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n#include <cstdint>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int32_t global_min_val = INT_MAX;\n    uint32_t global_min_index = UINT32_MAX;\n    uint64_t vl = svcntw();\n    int i = 0;\n    int n = arr.size();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svuint32_t indices = svadd_u32_x(pg, svdup_u32(i), svindex_u32(0, 1));\n        svint32_t mod = svand_s32_x(pg, data, svdup_s32(1));\n        svbool_t even_mask = svcmpeq(pg, mod, 0);\n\n        if (svptest_any(svptrue_b32(), even_mask)) {\n            svint32_t candidate_vals = svsel(even_mask, data, svdup_s32(INT_MAX));\n            int32_t min_val_in_chunk = svminv_s32(pg, candidate_vals);\n            svbool_t min_val_mask = svand_z(pg, svcmpeq(pg, data, min_val_in_chunk), even_mask);\n            uint32_t min_index_in_chunk = svminv_u32(min_val_mask, indices);\n\n            if (min_val_in_chunk < global_min_val || \n                (min_val_in_chunk == global_min_val && min_index_in_chunk < global_min_index)) {\n                global_min_val = min_val_in_chunk;\n                global_min_index = min_index_in_chunk;\n            }\n        }\n        i += vl;\n    }\n\n    if (global_min_index == UINT32_MAX) {\n        return {};\n    } else {\n        return { global_min_val, static_cast<int>(global_min_index) };\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int global_min = INT_MAX;\n    int global_index = -1;\n\n    size_t n = arr.size();\n    size_t i = 0;\n    unsigned int vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svint32_t indices = svindex_s32(i, 1);\n        \n        svint32_t one = svdup_s32(1);\n        svint32_t and_result = svand_s32_z(pg, data, one);\n        svbool_t p_even = svcmpeq(pg, and_result, 0);\n\n        if (svptest_any(svptrue_b32(), p_even)) {\n            int32_t min_seg_val = svminv_s32(p_even, data);\n            \n            svbool_t p_min = svand_z(p_even, svcmpeq(pg, data, min_seg_val));\n            int32_t min_seg_index = svminv_s32(p_min, indices);\n            \n            if (min_seg_val < global_min) {\n                global_min = min_seg_val;\n                global_index = min_seg_index;\n            }\n        }\n        \n        i += vl;\n    }\n\n    if (global_index == -1) {\n        return {};\n    } else {\n        return {global_min, global_index};\n    }\n}\n```"}
{"task_id": "SimdBench_94_SVE", "completion": "```cpp\n#include <vector>\n#include <climits>\n#include <arm_sve.h>\n\nstd::vector<int> pluck_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) {\n        return {};\n    }\n    \n    int32_t global_min_val = INT_MAX;\n    int32_t global_min_index = -1;\n    uint64_t vl = svcntw();\n    \n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t values = svld1_s32(pg, &arr[i]);\n        \n        svint32_t mod = svand_n_s32_z(pg, values, 1);\n        svbool_t p_even = svcmpeq_n_s32(pg, mod, 0);\n        svbool_t p_active_even = svand_b_z(pg, pg, p_even);\n        \n        if (svptest_any(svptrue_b8(), p_active_even)) {\n            int32_t candidate_val = svminv_s32(p_active_even, values);\n            svbool_t p_candidate = svand_b_z(svptrue_b8(), p_active_even, \n                                            svcmpeq_n_s32(svptrue_b8(), values, candidate_val));\n            uint32_t first_lane = svpfirst_b(svptrue_b8(), p_candidate);\n            int32_t candidate_index = i + first_lane;\n            \n            if (candidate_val < global_min_val) {\n                global_min_val = candidate_val;\n                global_min_index = candidate_index;\n            }\n        }\n    }\n    \n    if (global_min_index == -1) {\n        return {};\n    }\n    return {global_min_val, global_min_index};\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return -1;\n\n    int* freq = new int[n+1]();\n    uint64_t vl = svcntw();\n\n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vec = svld1_s32(pg, &lst[i]);\n        int num_lanes = svcntp_b32(pg, pg);\n\n        for (int j = 0; j < num_lanes; j++) {\n            int val = svget_s32(vec, j);\n            if (val <= n) {\n                freq[val]++;\n            }\n        }\n    }\n\n    int result = -1;\n    for (int x = n; x >= 1; x--) {\n        if (freq[x] >= x) {\n            result = x;\n            break;\n        }\n    }\n\n    delete[] freq;\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    std::vector<int> freq(n + 1, 0);\n\n    for (int x : lst) {\n        if (x <= n) {\n            freq[x]++;\n        }\n    }\n\n    int i = n;\n    int result = -1;\n\n    while (i >= 1) {\n        uint64_t vl = svcntw();\n        int base = (i - vl + 1) >= 1 ? (i - vl + 1) : 1;\n        int num_elements = i - base + 1;\n\n        svbool_t pg = svwhilelt_b32(0, num_elements);\n        svint32_t f_vec = svld1(pg, &freq[base]);\n        svint32_t idx_vec = svindex_s32(base, 1);\n        svbool_t cmp = svcmpge(pg, f_vec, idx_vec);\n\n        if (svptest_any(svptrue_b32(), cmp)) {\n            svint32_t candidate_vec = svsel_s32(cmp, idx_vec, svdup_s32(-1));\n            int max_candidate = svmaxv_s32(svptrue_b32(), candidate_vec);\n            result = max_candidate;\n            break;\n        }\n\n        i = base - 1;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) \n        return -1;\n\n    int n = lst.size();\n    int max_value = 0;\n    int vl = svcntw();\n    int i = 0;\n    svint32_t max_vec = svdup_s32(0);\n\n    for (; i <= n - vl; i += vl) {\n        svint32_t data = svld1_s32(svptrue_b32(), &lst[i]);\n        max_vec = svmax_s32_z(svptrue_b32(), data, max_vec);\n    }\n    svbool_t while_pg = svwhilelt_b32(i, n);\n    if (svptest_any(while_pg, while_pg)) {\n        svint32_t data = svld1_s32(while_pg, &lst[i]);\n        max_vec = svmax_s32_z(while_pg, data, max_vec);\n    }\n    max_value = svmaxv_s32(svptrue_b32(), max_vec);\n\n    if (max_value == 0) \n        return -1;\n\n    std::vector<int> freq(max_value + 1, 0);\n    for (int j = 0; j < n; j++) {\n        if (lst[j] <= max_value && lst[j] > 0) {\n            freq[lst[j]]++;\n        }\n    }\n\n    int start = max_value;\n    while (start >= 1) {\n        int end = std::max(1, start - vl + 1);\n        int num_in_chunk = start - end + 1;\n        svbool_t pg = svwhilelt_b32(0, num_in_chunk);\n        svint32_t freqs = svld1_s32(pg, &freq[end]);\n        svint32_t indices = svindex_s32(end, 1);\n        svbool_t cond = svcmpge_s32(pg, freqs, indices);\n        svint32_t candidates = svsel_s32(cond, indices, svdup_s32(-1));\n        int max_candidate = svmaxv_s32(pg, candidates);\n        if (max_candidate != -1) {\n            return max_candidate;\n        }\n        start = end - 1;\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint search_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return -1;\n    }\n\n    int max_val = lst[0];\n    int i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        int32_t block_max = svmaxv_s32(pg, data);\n        if (block_max > max_val) {\n            max_val = block_max;\n        }\n        i += svcntw();\n    }\n\n    int candidate_start = std::min(max_val, n);\n    for (int candidate = candidate_start; candidate >= 1; --candidate) {\n        uint64_t count = 0;\n        int j = 0;\n        while (j < n) {\n            svbool_t pg = svwhilelt_b32(j, n);\n            svint32_t data = svld1_s32(pg, &lst[j]);\n            svbool_t cmp = svcmpeq_s32(pg, data, svdup_n_s32(candidate));\n            count += svcntp_b32(pg, cmp);\n            j += svcntw();\n        }\n        if (count >= static_cast<uint64_t>(candidate)) {\n            return candidate;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_95_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\nint search_simd(std::vector<int> lst) {\n    if (lst.empty()) {\n        return -1;\n    }\n\n    // Step 1: Find maximum value using SVE\n    int32_t max_val = lst[0];\n    svint32_t max_vec = svdup_s32(max_val);\n    svbool_t p_all = svptrue_b32();\n    uint64_t n = lst.size();\n    uint64_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        max_vec = svmax_s32_z(pg, data, max_vec);\n        i += svcntp_b32(p_all, pg);\n    }\n    max_val = svmaxv_s32(p_all, max_vec);\n\n    if (max_val <= 0) {\n        return -1;\n    }\n\n    // Step 2: Create frequency array\n    std::vector<int> freq(max_val + 1, 0);\n    for (int num : lst) {\n        if (num >= 1 && num <= max_val) {\n            freq[num]++;\n        }\n    }\n\n    // Step 3: Search for the greatest integer satisfying freq[i] >= i\n    uint64_t vl = svcntw();\n    i = max_val;\n\n    while (i >= 1) {\n        uint64_t num_elements = (i >= vl) ? vl : i;\n        svbool_t pg = svptrue_b32();\n        if (num_elements < vl) {\n            pg = svwhilelt_b32(0, num_elements);\n        }\n\n        svint32_t indices = svindex_s32(i, -1);\n        svint32_t freq_vals = svld1_gather_s32index_s32(pg, freq.data(), indices);\n        svbool_t p_match = svcmpge_s32(pg, freq_vals, indices);\n\n        if (svptest_any(pg, p_match)) {\n            uint32_t first_active = svpfirst(p_all, p_match);\n            return i - first_active;\n        }\n\n        i -= num_elements;\n    }\n\n    return -1;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    size_t n = q.size();\n    if (n == 0) {\n        return false;\n    }\n    int *data = q.data();\n\n    size_t i = 0;\n    while (i < n / 2) {\n        svbool_t pg = svwhilelt_b32(i, n / 2);\n        size_t vl = svcntp_b32(svptrue_b32(), pg);\n        svint32_t left_vec = svld1_s32(pg, (const int32_t*)(data + i));\n        svint32_t right_vec = svld1_s32(pg, (const int32_t*)(data + n - i - vl));\n        svint32_t rev_right = svrev_s32(right_vec);\n        svbool_t cmp = svcmpeq_s32(pg, left_vec, rev_right);\n        if (svptest_any(pg, svnot_b_z(pg, cmp))) {\n            return false;\n        }\n        i += vl;\n    }\n\n    svint32_t sum_vec = svdup_s32(0);\n    i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t chunk = svld1_s32(pg, (const int32_t*)(data + i));\n        sum_vec = svadd_s32_x(pg, sum_vec, chunk);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n    int32_t total = svaddv_s32(svptrue_b32(), sum_vec);\n\n    return (total <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    uint64_t n = q.size();\n    uint64_t left_index = 0;\n    uint64_t right_index = n - 1;\n    svbool_t pg_all = svptrue_b32();\n\n    while (left_index < right_index) {\n        svbool_t pg = svwhilelt_b32_s64(left_index, right_index + 1);\n        uint64_t active_vl = svcntp_b32(pg_all, pg);\n        svint32_t left_vec = svld1(pg, &q[left_index]);\n        svint32_t right_vec = svld1(pg, &q[right_index - active_vl + 1]);\n        svint32_t reversed_right_vec = svrev_s32(right_vec);\n        svbool_t neq = svcmpne(pg, left_vec, reversed_right_vec);\n        if (svptest_any(pg_all, neq)) {\n            return false;\n        }\n        left_index += active_vl;\n        right_index -= active_vl;\n    }\n\n    uint64_t i = 0;\n    svint32_t sum_vec = svdup_s32(0);\n    svbool_t pg_loop = svwhilelt_b32_s64(i, n);\n    while (svptest_any(pg_all, pg_loop)) {\n        svint32_t data = svld1(pg_loop, &q[i]);\n        sum_vec = svadd_m(pg_loop, sum_vec, data);\n        i += svcntp_b32(pg_all, pg_loop);\n        pg_loop = svwhilelt_b32_s64(i, n);\n    }\n    int32_t total_sum = svaddv(pg_all, sum_vec);\n\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    uint64_t n = q.size();\n    int *data = q.data();\n    uint64_t vl = svcntw();\n\n    uint64_t i = 0, j = n - 1;\n    while (i < j) {\n        uint64_t remaining_pairs = (j - i + 1) / 2;\n        uint64_t k = (remaining_pairs < vl) ? remaining_pairs : vl;\n        if (k == 0) break;\n\n        svbool_t pg = svwhilelt_b32(0, k);\n        svint32_t front = svld1(pg, data + i);\n        svint32_t back = svld1(pg, data + j - k + 1);\n        svint32_t back_rev = svrev(pg, back);\n        svbool_t cmp = svcmpeq(pg, front, back_rev);\n\n        if (svptest_all(pg, cmp) == 0) {\n            return false;\n        }\n\n        i += k;\n        j -= k;\n    }\n\n    svint32_t sum_vec = svdup_n_s32(0);\n    uint64_t index = 0;\n    svbool_t pg_all = svptrue_b32();\n\n    while (index < n) {\n        svbool_t pg_load = svwhilelt_b32(index, n);\n        svint32_t data_vec = svld1(pg_load, data + index);\n        sum_vec = svadd_m(pg_all, sum_vec, data_vec);\n        index += vl;\n    }\n\n    int32_t total_sum = svaddv(svptrue_b32(), sum_vec);\n    return total_sum <= w;\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    int n = q.size();\n    int64_t i = 0;\n    int64_t j = n - 1;\n    uint64_t vl = svcntw();\n\n    while (i < j) {\n        uint64_t remaining_pairs = (j - i + 1) / 2;\n        if (remaining_pairs == 0) break;\n\n        uint64_t k = (remaining_pairs < vl) ? remaining_pairs : vl;\n        svbool_t pg = svwhilelt_b32(0, k);\n\n        svint32_t v_start = svld1(pg, q.data() + i);\n        svint32_t v_end = svld1(pg, q.data() + j - k + 1);\n        svint32_t v_end_rev = svrev_s32(v_end);\n\n        svbool_t mismatch = svcmpne_s32(pg, v_start, v_end_rev);\n        if (svptest_any(pg, mismatch)) {\n            return false;\n        }\n\n        i += k;\n        j -= k;\n    }\n\n    svint32_t sum_vec = svdup_s32(0);\n    int64_t index = 0;\n    svbool_t pg_all = svptrue_b32();\n    svbool_t pg_loop = svwhilelt_b32(index, n);\n    while (svptest_any(pg_all, pg_loop)) {\n        svint32_t data = svld1(pg_loop, q.data() + index);\n        sum_vec = svadd_m(pg_loop, sum_vec, data);\n        index += vl;\n        pg_loop = svwhilelt_b32(index, n);\n    }\n    int32_t total_sum = svaddv(pg_all, sum_vec);\n\n    return (total_sum <= w);\n}\n```"}
{"task_id": "SimdBench_96_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool will_it_fly_simd(std::vector<int> q, int w) {\n    uint64_t n = static_cast<uint64_t>(q.size());\n    svint32_t sum_vec = svdup_s32(0);\n    uint64_t i = 0;\n    const uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &q[i]);\n        sum_vec = svadd_m(pg, sum_vec, data);\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n    int32_t total = svaddv_s32(svptrue_b32(), sum_vec);\n    if (total > w) {\n        return false;\n    }\n\n    uint64_t left_index = 0;\n    uint64_t right_index = n - 1;\n    while (left_index < right_index) {\n        uint64_t remaining_pairs = (right_index - left_index + 1) / 2;\n        if (remaining_pairs == 0) {\n            break;\n        }\n        uint64_t chunk = (vl < remaining_pairs) ? vl : remaining_pairs;\n        svbool_t pg_chunk = svwhilelt_b32(0, chunk);\n        svint32_t left_data = svld1_s32(pg_chunk, &q[left_index]);\n        svint32_t right_data = svld1_s32(pg_chunk, &q[right_index - chunk + 1]);\n        svint32_t right_reversed = svrev_s32(right_data);\n        svbool_t cmp = svcmpeq_s32(pg_chunk, left_data, right_reversed);\n        if (!svptest_any(svptrue_b32(), svnot_b_z(svptrue_b32(), cmp))) {\n            left_index += chunk;\n            right_index -= chunk;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return 0;\n    }\n    uint64_t i = 0;\n    uint64_t changes = 0;\n    uint64_t half = static_cast<uint64_t>(n) / 2;\n    while (i < half) {\n        svbool_t pg = svwhilelt_b32(i, half);\n        svint32_t left_vec = svld1(pg, arr.data() + i);\n        uint64_t vl = svcntp_b32(pg, pg);\n        svint32_t right_vec = svld1(pg, arr.data() + n - i - vl);\n        right_vec = svrev_s32(right_vec);\n        svbool_t cmp = svcmpne(pg, left_vec, right_vec);\n        changes += svcntp_b32(pg, cmp);\n        i += vl;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    uint64_t n = arr.size();\n    if (n == 0) \n        return 0;\n    uint64_t total_mismatches = 0;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n/2);\n    while (svptest_any(svptrue_b32(), pg)) {\n        uint64_t vl = svcntp_b32(svptrue_b32(), pg);\n        svint32_t left_vec = svld1_s32(pg, arr.data() + i);\n        uint64_t base_right = n - i - vl;\n        svint32_t right_vec = svld1_s32(pg, arr.data() + base_right);\n        svint32_t right_vec_reversed = svrev_s32(right_vec);\n        svbool_t mismatch = svcmpne_s32(pg, left_vec, right_vec_reversed);\n        total_mismatches += svcntp_b32(pg, mismatch);\n        i += vl;\n        pg = svwhilelt_b32(i, n/2);\n    }\n    return total_mismatches;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    uint64_t n = arr.size();\n    uint64_t half = n / 2;\n    uint64_t i = 0;\n    uint64_t total_mismatches = 0;\n\n    while (i < half) {\n        svbool_t pg = svwhilelt_b32(i, half);\n        svint32_t left_vec = svld1_s32(pg, &arr[i]);\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t neg_indices = svneg_s32_z(pg, indices);\n        svint32_t right_vec = svld1_gather_s32index_s32(pg, &arr[n - 1 - i], neg_indices);\n        svbool_t neq = svcmpne_s32(pg, left_vec, right_vec);\n        total_mismatches += svcntp_b32(pg, neq);\n        i += svcntp_b32(pg, pg);\n    }\n\n    return total_mismatches;\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint smallest_change_simd(std::vector<int> arr) {\n    size_t n = arr.size();\n    if (n == 0) \n        return 0;\n    size_t half = n / 2;\n    uint64_t i = 0;\n    uint64_t count = 0;\n\n    while (i < half) {\n        svbool_t pg = svwhilelt_b32(i, half);\n        uint64_t vl = svcntp_b32(svptrue_b32(), pg);\n        if (vl == 0) \n            break;\n\n        int32_t* base1 = arr.data() + i;\n        svint32_t v1 = svld1(pg, base1);\n\n        int32_t* base2 = arr.data() + n - 1 - i;\n        svint32_t indices = svindex_s32(0, -1);\n        svint32_t v2 = svld1_gather_s32index_s32(pg, base2, indices);\n\n        svbool_t mismatch = svcmpne(pg, v1, v2);\n        count += svcntp_b32(mismatch, pg);\n\n        i += vl;\n    }\n\n    return static_cast<int>(count);\n}\n```"}
{"task_id": "SimdBench_97_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint smallest_change_simd(std::vector<int> arr) {\n    int64_t n = arr.size();\n    int64_t pairs = n / 2;\n    if (pairs == 0) {\n        return 0;\n    }\n\n    int64_t i = 0;\n    int64_t j = n - 1;\n    uint64_t mismatch_count = 0;\n\n    while (i < pairs) {\n        svbool_t pg = svwhilelt_b32(i, pairs);\n        svint32_t left = svld1_s32(pg, arr.data() + i);\n        svint32_t indices = svindex_s32(j, -1);\n        svint32_t right = svld1_gather_s32index(pg, arr.data(), indices);\n        svbool_t cmp = svcmpne_s32(pg, left, right);\n        uint64_t seg_mismatches = svcntp_b32(pg, cmp);\n        mismatch_count += seg_mismatches;\n        uint64_t k = svcntp_b32(pg, pg);\n        i += k;\n        j -= k;\n    }\n\n    return mismatch_count;\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    if (lst1.empty() && lst2.empty()) {\n        return {};\n    }\n    \n    size_t total1 = 0;\n    size_t n1 = lst1.size();\n    if (n1 > 0) {\n        std::vector<size_t> len1(n1);\n        for (size_t i = 0; i < n1; ++i) {\n            len1[i] = lst1[i].size();\n        }\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b64(i, n1);\n        do {\n            svuint64_t vec = svld1(pg, len1.data() + i);\n            total1 = svadda_u64(pg, total1, vec);\n            i += svcntd();\n            pg = svwhilelt_b64(i, n1);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n\n    size_t total2 = 0;\n    size_t n2 = lst2.size();\n    if (n2 > 0) {\n        std::vector<size_t> len2(n2);\n        for (size_t i = 0; i < n2; ++i) {\n            len2[i] = lst2[i].size();\n        }\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b64(i, n2);\n        do {\n            svuint64_t vec = svld1(pg, len2.data() + i);\n            total2 = svadda_u64(pg, total2, vec);\n            i += svcntd();\n            pg = svwhilelt_b64(i, n2);\n        } while (svptest_any(svptrue_b64(), pg));\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto compute_total_length = [](const std::vector<std::string>& vec) -> uint64_t {\n        size_t n = vec.size();\n        if (n == 0) {\n            return 0;\n        }\n        uint64_t max_vl = svcntd();\n        uint64_t temp_arr[32] = {0};\n        svuint64_t vsum = svdup_u64(0);\n        uint64_t i = 0;\n        while (i < n) {\n            uint64_t segment = std::min(n - i, max_vl);\n            for (uint64_t j = 0; j < segment; ++j) {\n                temp_arr[j] = vec[i+j].length();\n            }\n            svbool_t pg = svwhilelt_b64(0, segment);\n            svuint64_t v = svld1(pg, temp_arr);\n            vsum = svadd_m(pg, vsum, v);\n            i += segment;\n        }\n        return svaddv(svptrue_b64(), vsum);\n    };\n\n    uint64_t total1 = compute_total_length(lst1);\n    uint64_t total2 = compute_total_length(lst2);\n\n    if (total1 < total2) {\n        return lst1;\n    } else if (total2 < total1) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2){\n    auto sve_sum_u64 = [](const uint64_t* arr, size_t n) -> uint64_t {\n        if (n == 0) {\n            return 0;\n        }\n        size_t i = 0;\n        svuint64_t sum_vec = svdup_u64(0);\n        svbool_t pg = svwhilelt_b64(i, n);\n        do {\n            svuint64_t data = svld1_u64(pg, arr + i);\n            sum_vec = svadd_u64_z(pg, sum_vec, data);\n            i += svcntd();\n            pg = svwhilelt_b64(i, n);\n        } while (svptest_any(svptrue_b64(), pg));\n        return svaddv_u64(svptrue_b64(), sum_vec);\n    };\n\n    std::vector<uint64_t> len1;\n    len1.reserve(lst1.size());\n    for (const auto& s : lst1) {\n        len1.push_back(s.size());\n    }\n    uint64_t total1 = sve_sum_u64(len1.data(), len1.size());\n\n    std::vector<uint64_t> len2;\n    len2.reserve(lst2.size());\n    for (const auto& s : lst2) {\n        len2.push_back(s.size());\n    }\n    uint64_t total2 = sve_sum_u64(len2.data(), len2.size());\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    uint64_t total1 = 0;\n    uint64_t total2 = 0;\n\n    if (!lst1.empty()) {\n        std::vector<uint64_t> lengths1;\n        lengths1.reserve(lst1.size());\n        for (const auto& s : lst1) {\n            lengths1.push_back(s.length());\n        }\n        const uint64_t* data1 = lengths1.data();\n        size_t n1 = lengths1.size();\n        svuint64_t acc1 = svdup_u64(0);\n        size_t i = 0;\n        svbool_t pg1 = svwhilelt_b64(i, n1);\n        while (svptest_any(svptrue_b64(), pg1)) {\n            svuint64_t vec = svld1_u64(pg1, data1 + i);\n            acc1 = svadd_u64_z(pg1, acc1, vec);\n            i += svcntd();\n            pg1 = svwhilelt_b64(i, n1);\n        }\n        total1 = svaddv_u64(svptrue_b64(), acc1);\n    }\n\n    if (!lst2.empty()) {\n        std::vector<uint64_t> lengths2;\n        lengths2.reserve(lst2.size());\n        for (const auto& s : lst2) {\n            lengths2.push_back(s.length());\n        }\n        const uint64_t* data2 = lengths2.data();\n        size_t n2 = lengths2.size();\n        svuint64_t acc2 = svdup_u64(0);\n        size_t i = 0;\n        svbool_t pg2 = svwhilelt_b64(i, n2);\n        while (svptest_any(svptrue_b64(), pg2)) {\n            svuint64_t vec = svld1_u64(pg2, data2 + i);\n            acc2 = svadd_u64_z(pg2, acc2, vec);\n            i += svcntd();\n            pg2 = svwhilelt_b64(i, n2);\n        }\n        total2 = svaddv_u64(svptrue_b64(), acc2);\n    }\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match_simd(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    auto total_length = [](const std::vector<std::string>& vec) -> uint64_t {\n        const uint64_t n = vec.size();\n        if (n == 0) {\n            return 0;\n        }\n        std::vector<uint64_t> lengths;\n        lengths.reserve(n);\n        for (const auto& s : vec) {\n            lengths.push_back(static_cast<uint64_t>(s.length()));\n        }\n        uint64_t i = 0;\n        svuint64_t vsum = svdup_u64(0);\n        svbool_t pg = svwhilelt_b64(i, n);\n        const uint64_t vl = svcntd();\n        while (svptest_any(svptrue_b64(), pg)) {\n            svuint64_t v = svld1_u64(pg, &lengths[i]);\n            vsum = svadd_u64_m(pg, vsum, v);\n            i += vl;\n            pg = svwhilelt_b64(i, n);\n        }\n        return svaddv_u64(svptrue_b64(), vsum);\n    };\n\n    uint64_t total1 = total_length(lst1);\n    uint64_t total2 = total_length(lst2);\n\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return (x == 0);\n    }\n    if (n == 1) {\n        return (x == 1);\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t k_max = 0;\n    uint64_t temp = 1;\n    while (temp <= x / n) {\n        temp = temp * n;\n        k_max++;\n    }\n\n    if (k_max == 0) {\n        return false;\n    }\n\n    uint64_t vl = svcntd();\n    uint64_t base_exp = 1;\n    while (base_exp <= k_max) {\n        uint64_t num_in_chunk = k_max - base_exp + 1;\n        if (num_in_chunk > vl) {\n            num_in_chunk = vl;\n        }\n        svbool_t pg = svwhilelt_b64_u64(0, num_in_chunk);\n        svuint64_t exp_vec = svindex_u64(base_exp, 1);\n        uint64_t max_exp_in_chunk = svmaxv_u64(pg, exp_vec);\n        int bits_required = 0;\n        if (max_exp_in_chunk > 0) {\n            bits_required = 64 - __builtin_clzll(max_exp_in_chunk);\n        }\n        svuint64_t res = svdup_u64(1);\n        uint64_t base_current = n;\n\n        for (int bit = 0; bit < bits_required; bit++) {\n            uint64_t bit_mask_val = (1ULL << bit);\n            svuint64_t bit_mask = svdup_u64(bit_mask_val);\n            svuint64_t and_res = svand_u64_z(pg, exp_vec, bit_mask);\n            svbool_t cond = svcmpne_u64(pg, and_res, svdup_u64(0));\n            svuint64_t mul_res = svmul_u64_z(pg, res, svdup_u64(base_current));\n            res = svsel_u64(cond, mul_res, res);\n\n            if (base_current == 0) {\n                break;\n            }\n            if (base_current >= (1ULL << 32)) {\n                base_current = 0;\n            } else {\n                base_current = base_current * base_current;\n            }\n        }\n\n        svbool_t cmp = svcmpeq_u64(pg, res, svdup_u64(x));\n        if (svptest_any(pg, cmp)) {\n            return true;\n        }\n        base_exp += num_in_chunk;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t max_exp = 64;\n    uint64_t base_exp = 1;\n    uint64_t vl = svcntd();\n\n    while (base_exp <= max_exp) {\n        svbool_t pg = svwhilelt_b64_u64(base_exp, max_exp + 1);\n        svuint64_t exp_vec = svindex_u64(base_exp, 1);\n        svuint64_t res = svdup_u64(1);\n        svuint64_t base = svdup_u64(n);\n\n        for (int i = 0; i < 64; i++) {\n            uint64_t bit_mask = 1ULL << i;\n            svuint64_t mask = svdup_u64(bit_mask);\n            svuint64_t bit = svand_u64_z(pg, exp_vec, mask);\n            svbool_t bit_set = svcmpne_u64(pg, bit, svdup_u64(0));\n            res = svsel_u64(bit_set, svmul_u64_m(pg, res, base), res);\n            base = svmul_u64_z(pg, base, base);\n        }\n\n        svbool_t match = svcmpeq_u64(pg, res, svdup_u64(x));\n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n\n        base_exp += vl;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h> \n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n\n    uint64_t base = n;\n    uint64_t k = 1;\n\n    while (k < 65 && base <= x && base != 0) {\n        svbool_t pg = svwhilelt_b64_u64(k, 65);\n        uint64_t vl = svcntd();\n        uint64_t num_active = svcntp_b64(svptrue_b64(), pg);\n        if (num_active == 0) break;\n\n        uint64_t powers[num_active];\n        uint64_t current = base;\n        uint64_t actual_active = 0;\n\n        for (uint64_t i = 0; i < num_active; i++) {\n            powers[i] = current;\n            actual_active = i + 1;\n\n            if (i == num_active - 1) {\n                current = current * n;\n                break;\n            }\n\n            if (current > UINT64_MAX / n) {\n                current = current * n;\n                break;\n            }\n\n            uint64_t next = current * n;\n            if (next > x) {\n                current = next;\n                break;\n            }\n            current = next;\n        }\n\n        svbool_t pg_new = svwhilelt_b64_u64(0, actual_active);\n        svuint64_t v_power = svld1_u64(svptrue_b64(), powers);\n        svuint64_t v_x = svdup_u64(x);\n        svbool_t match = svcmpeq_u64(pg_new, v_power, v_x);\n\n        if (svptest_any(svptrue_b64(), match)) {\n            return true;\n        }\n\n        base = current;\n        k += actual_active;\n    }\n\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <limits.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (x == 0) {\n        return (n == 0);\n    }\n    if (x == 1) {\n        return (n != 0);\n    }\n    if (n == 0) {\n        return false;\n    }\n    if (n == 1) {\n        return false;\n    }\n\n    uint64_t vl = svcntd();\n    if (vl == 0) {\n        uint64_t power = 1;\n        while (power < x) {\n            if (power > UINT64_MAX / n) {\n                break;\n            }\n            power *= n;\n        }\n        return (power == x);\n    }\n\n    uint64_t multipliers[vl];\n    uint64_t actual_vl = 1;\n    multipliers[0] = 1;\n    for (uint64_t i = 1; i < vl; i++) {\n        if (n == 0 || multipliers[i-1] > UINT64_MAX / n) {\n            break;\n        }\n        multipliers[i] = multipliers[i-1] * n;\n        actual_vl++;\n    }\n\n    uint64_t chunk_factor;\n    if (actual_vl == 0) {\n        chunk_factor = 1;\n    } else {\n        if (n == 0 || multipliers[actual_vl-1] > UINT64_MAX / n) {\n            chunk_factor = UINT64_MAX;\n        } else {\n            chunk_factor = multipliers[actual_vl-1] * n;\n        }\n    }\n\n    uint64_t current_power = n;\n    while (current_power <= x) {\n        svbool_t pg = svwhilelt_b64(0, actual_vl);\n        svuint64_t v_mult = svld1_u64(pg, multipliers);\n        svuint64_t v_current = svdup_u64(current_power);\n        svuint64_t v_power = svmul_u64_z(pg, v_current, v_mult);\n        svuint64_t v_x = svdup_u64(x);\n        svbool_t pg_eq = svcmpeq_u64(pg, v_power, v_x);\n        if (svptest_any(pg, pg_eq)) {\n            return true;\n        }\n        if (chunk_factor == 0 || current_power > UINT64_MAX / chunk_factor) {\n            break;\n        }\n        current_power *= chunk_factor;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99_SVE", "completion": "To solve this problem, we need to determine if a given number `x` is a simple power of another number `n`. This means that there must exist a non-negative integer `k` such that `n^k = x`. The solution must leverage ARM's Scalable Vector Extension (SVE) intrinsics to achieve parallelism, efficiently checking multiple exponents simultaneously.\n\n### Approach\n1. **Special Case Handling**:\n   - **Case 1 (n = 0)**: Only `x = 0` is a valid power (since `0^k = 0` for `k >= 1`). Any other `x` (including `x = 1`) is invalid.\n   - **Case 2 (n = 1)**: Only `x = 1` is valid (since `1^k = 1` for any `k`).\n   - **Case 3 (x = 1)**: Always valid for any `n \u2260 0` (since `n^0 = 1`).\n   - **Case 4 (x = 0)**: Invalid for `n >= 2` (since `n^k` cannot be zero for any non-negative integer `k`).\n\n2. **General Case (n >= 2, x >= 2)**:\n   - **Vectorized Exponentiation**: Use SVE to compute multiple exponents in parallel. The exponents are processed in chunks, where each chunk size is determined by the SVE vector length.\n   - **Exponentiation by Squaring**: For each chunk, compute the powers of `n` for exponents `[0, VL-1]` (where `VL` is the vector length) using exponentiation by squaring. This method efficiently computes the powers in logarithmic time relative to the exponent.\n   - **Chunk Processing**: For each chunk, multiply the precomputed powers by a base value (`base_start`), which represents `n^k` for the start of the chunk. The resulting vector is compared with `x` to check for a match.\n   - **Base Update**: After processing each chunk, update `base_start` to `n^(k_start + VL)` for the next chunk, handling potential overflow to terminate early.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <stdint.h>\n#include <limits.h>\n\nbool is_simple_power_simd(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return (x == 0);\n    }\n    if (n == 1) {\n        return (x == 1);\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (x == 0) {\n        return false;\n    }\n    \n    uint64_t base_start = 1;\n    uint64_t vl = svcntd();\n    \n    while (1) {\n        if (base_start == 0) {\n            break;\n        }\n        if (base_start > x) {\n            break;\n        }\n        \n        svuint64_t exponents = svindex_u64(0, 1);\n        svuint64_t factors = svdup_u64(1);\n        svuint64_t vn = svdup_u64(n);\n        \n        for (int i = 0; i < 64; i++) {\n            uint64_t bit = (uint64_t)1 << i;\n            svuint64_t bit_mask = svdup_u64(bit);\n            svuint64_t and_result = svand_u64_z(svptrue_b64(), exponents, bit_mask);\n            svbool_t pg = svcmpne_u64(svptrue_b64(), and_result, svdup_u64(0));\n            factors = svmul_u64_m(pg, factors, vn);\n            vn = svmul_u64_z(svptrue_b64(), vn, vn);\n        }\n        \n        svuint64_t base_start_vec = svdup_u64(base_start);\n        svuint64_t vpow = svmul_u64_z(svptrue_b64(), factors, base_start_vec);\n        \n        svbool_t pg_eq = svcmpeq_n_u64(svptrue_b64(), vpow, x);\n        if (svptest_any(svptrue_b64(), pg_eq)) {\n            return true;\n        }\n        \n        uint64_t last_factor = svlasta_u64(svptrue_b64(), factors);\n        uint64_t n_vl;\n        if (last_factor > UINT64_MAX / n) {\n            base_start = 0;\n            continue;\n        } else {\n            n_vl = last_factor * n;\n        }\n        \n        if (n_vl == 0) {\n            base_start = 0;\n        } else if (base_start > UINT64_MAX / n_vl) {\n            base_start = 0;\n        } else {\n            base_start = base_start * n_vl;\n        }\n    }\n    \n    return false;\n}\n```\n\n### Explanation\n1. **Special Cases Handling**:\n   - **n = 0**: Only `x = 0` is valid.\n   - **n = 1**: Only `x = 1` is valid.\n   - **x = 1**: Valid for any `n \u2260 0`.\n   - **x = 0**: Invalid for `n >= 2`.\n\n2. **Vectorized Processing**:\n   - **Chunk Processing**: The exponents are divided into chunks of size `VL` (SVE vector length). For each chunk, the powers of `n` (from `n^0` to `n^(VL-1)`) are computed using vectorized exponentiation by squaring.\n   - **Comparison**: The computed powers are multiplied by `base_start` (the starting power of the chunk) to form the full powers. These are then compared in parallel with `x` to check for a match.\n   - **Base Update**: After processing each chunk, `base_start` is updated to the next chunk's starting power (`n^(k_start + VL)`). Overflow checks ensure early termination if the next power exceeds `UINT64_MAX`.\n\nThis approach efficiently leverages SVE's parallel processing capabilities to handle multiple exponents simultaneously, significantly speeding up the check for large exponent ranges while correctly handling edge cases and overflow conditions."}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint hex_key_simd(const std::string & num){\n    if (num.empty()) return 0;\n    \n    const char* str = num.c_str();\n    size_t len = num.length();\n    size_t i = 0;\n    int count = 0;\n    size_t vl = svcntb(); // Vector length in bytes\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        svbool_t prime_mask = svcmpeq_u8(pg, vec, '2');\n        prime_mask = svorr_b_z(pg, prime_mask, svcmpeq_u8(pg, vec, '3'));\n        prime_mask = svorr_b_z(pg, prime_mask, svcmpeq_u8(pg, vec, '5'));\n        prime_mask = svorr_b_z(pg, prime_mask, svcmpeq_u8(pg, vec, '7'));\n        prime_mask = svorr_b_z(pg, prime_mask, svcmpeq_u8(pg, vec, 'B'));\n        prime_mask = svorr_b_z(pg, prime_mask, svcmpeq_u8(pg, vec, 'D'));\n        \n        count += svcntp_b8(pg, prime_mask);\n        i += vl;\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num){\n    const char* str = num.c_str();\n    size_t len = num.size();\n    if (len == 0) return 0;\n\n    uint64_t count = 0;\n    uint64_t index = 0;\n    uint64_t vl = svcntb();\n\n    svbool_t pg = svwhilelt_b8(index, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(str + index));\n\n        svbool_t cmp2 = svcmpeq_u8(pg, input, svdup_n_u8('2'));\n        svbool_t cmp3 = svcmpeq_u8(pg, input, svdup_n_u8('3'));\n        svbool_t cmp5 = svcmpeq_u8(pg, input, svdup_n_u8('5'));\n        svbool_t cmp7 = svcmpeq_u8(pg, input, svdup_n_u8('7'));\n        svbool_t cmpB = svcmpeq_u8(pg, input, svdup_n_u8('B'));\n        svbool_t cmpD = svcmpeq_u8(pg, input, svdup_n_u8('D'));\n\n        svbool_t any = svorr_b_z(svptrue_b8(), cmp2, cmp3);\n        any = svorr_b_z(svptrue_b8(), any, cmp5);\n        any = svorr_b_z(svptrue_b8(), any, cmp7);\n        any = svorr_b_z(svptrue_b8(), any, cmpB);\n        any = svorr_b_z(svptrue_b8(), any, cmpD);\n\n        count += svcntp_b8(pg, any);\n\n        index += vl;\n        pg = svwhilelt_b8(index, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint hex_key_simd(const std::string & num){\n    const char* data = num.data();\n    size_t len = num.size();\n    if (len == 0) return 0;\n\n    size_t i = 0;\n    uint64_t total_count = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b(), pg)) {\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(data + i));\n        svbool_t mask = svpfalse_b();\n        mask = svorr_b_z(pg, mask, svcmpeq_u8(pg, input, '2'));\n        mask = svorr_b_z(pg, mask, svcmpeq_u8(pg, input, '3'));\n        mask = svorr_b_z(pg, mask, svcmpeq_u8(pg, input, '5'));\n        mask = svorr_b_z(pg, mask, svcmpeq_u8(pg, input, '7'));\n        mask = svorr_b_z(pg, mask, svcmpeq_u8(pg, input, 'B'));\n        mask = svorr_b_z(pg, mask, svcmpeq_u8(pg, input, 'D'));\n        total_count += svcntp_b8(pg, mask);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    return total_count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint hex_key_simd(const std::string & num) {\n    if (num.empty()) \n        return 0;\n\n    int count = 0;\n    size_t i = 0;\n    size_t len = num.length();\n    uint8_t primes[] = {'2', '3', '5', '7', 'B', 'D'};\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)&num[i]);\n        svbool_t is_prime = svcmpne(pg, input, input);\n\n        for (uint8_t prime : primes) {\n            svuint8_t prime_vec = svdup_n_u8(prime);\n            is_prime = svorr_b_z(pg, is_prime, svcmpeq(pg, input, prime_vec));\n        }\n\n        count += svcntp_b8(pg, is_prime);\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_100_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint hex_key_simd(const std::string & num){\n    const char* str = num.data();\n    size_t len = num.size();\n    size_t i = 0;\n    int count = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(str + i));\n        \n        svbool_t cmp2 = svcmpeq_n_u8(pg, input, '2');\n        svbool_t cmp3 = svcmpeq_n_u8(pg, input, '3');\n        svbool_t cmp5 = svcmpeq_n_u8(pg, input, '5');\n        svbool_t cmp7 = svcmpeq_n_u8(pg, input, '7');\n        svbool_t cmpB = svcmpeq_n_u8(pg, input, 'B');\n        svbool_t cmpD = svcmpeq_n_u8(pg, input, 'D');\n        \n        svbool_t any = svorr_b_z(pg, cmp2, cmp3);\n        any = svorr_b_z(pg, any, cmp5);\n        any = svorr_b_z(pg, any, cmp7);\n        any = svorr_b_z(pg, any, cmpB);\n        any = svorr_b_z(pg, any, cmpD);\n        \n        count += svcntp_b8(pg, any);\n        i += svcntb();\n    }\n    \n    return count;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool is_happy_simd(const std::string & s) {\n    if (s.length() < 3) {\n        return false;\n    }\n    const char *str = s.data();\n    size_t n = s.length();\n    size_t len = n - 2;\n\n    size_t index = 0;\n    svbool_t pg = svwhilelt_b8(index, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t v0 = svld1(pg, (const uint8_t*)(str + index));\n        svuint8_t v1 = svld1(pg, (const uint8_t*)(str + index + 1));\n        svuint8_t v2 = svld1(pg, (const uint8_t*)(str + index + 2));\n\n        svbool_t eq01 = svcmpeq(pg, v0, v1);\n        svbool_t eq02 = svcmpeq(pg, v0, v2);\n        svbool_t eq12 = svcmpeq(pg, v1, v2);\n\n        svbool_t any_eq = svorr_z(pg, eq01, eq02);\n        any_eq = svorr_z(pg, any_eq, eq12);\n\n        if (svptest_any(pg, any_eq)) {\n            return false;\n        }\n\n        index += svcntb();\n        pg = svwhilelt_b8(index, len);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    uint64_t n = s.length();\n    if (n < 3) {\n        return false;\n    }\n    uint64_t num_triplets = n - 2;\n    uint64_t i = 0;\n    while (i < num_triplets) {\n        svbool_t pg = svwhilelt_b8(i, num_triplets);\n        svuint8_t v0 = svld1(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t v1 = svld1(pg, (const uint8_t*)(s.data() + i + 1));\n        svuint8_t v2 = svld1(pg, (const uint8_t*)(s.data() + i + 2));\n\n        svbool_t cond1 = svcmpne(pg, v0, v1);\n        svbool_t cond2 = svcmpne(pg, v0, v2);\n        svbool_t cond3 = svcmpne(pg, v1, v2);\n\n        svbool_t cond = svand_z(pg, cond1, svand_z(pg, cond2, cond3));\n        if (svptest_any(pg, svnot_z(pg, cond))) {\n            return false;\n        }\n        i += svcntp_b8(pg, pg);\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) {\n        return false;\n    }\n\n    uint64_t start = 0;\n    uint64_t end = n - 2;\n\n    while (start < end) {\n        svbool_t pg = svwhilelt_b8(start, end);\n        if (svcntp_b8(pg, pg) == 0) break;\n\n        const uint8_t *base = reinterpret_cast<const uint8_t*>(s.data());\n        svuint8_t vec0 = svld1_u8(pg, base + start);\n        svuint8_t vec1 = svld1_u8(pg, base + start + 1);\n        svuint8_t vec2 = svld1_u8(pg, base + start + 2);\n\n        svbool_t cmp1 = svcmpeq_u8(pg, vec0, vec1);\n        svbool_t cmp2 = svcmpeq_u8(pg, vec0, vec2);\n        svbool_t cmp3 = svcmpeq_u8(pg, vec1, vec2);\n        svbool_t any_cmp = svorr_z(pg, cmp1, svorr_z(pg, cmp2, cmp3));\n\n        if (svptest_any(pg, any_cmp)) {\n            return false;\n        }\n\n        start += svcntp_b8(pg, pg);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) {\n        return false;\n    }\n\n    uint64_t total_triplets = n - 2;\n    uint64_t index = 0;\n\n    while (index < total_triplets) {\n        svbool_t pg = svwhilelt_b8(index, total_triplets);\n        svuint8_t v0 = svld1_u8(pg, (const uint8_t*)(s.data() + index));\n        svuint8_t v1 = svld1_u8(pg, (const uint8_t*)(s.data() + index + 1));\n        svuint8_t v2 = svld1_u8(pg, (const uint8_t*)(s.data() + index + 2));\n\n        svbool_t cmp1 = svcmpne(pg, v0, v1);\n        svbool_t cmp2 = svcmpne(pg, v0, v2);\n        svbool_t cmp3 = svcmpne(pg, v1, v2);\n\n        svbool_t triple_ok = svand_z(pg, cmp1, svand_z(pg, cmp2, cmp3));\n\n        if (!svptest_all(pg, triple_ok)) {\n            return false;\n        }\n\n        index += svcntb();\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_101_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool is_happy_simd(const std::string & s) {\n    size_t n = s.size();\n    if (n < 3) {\n        return false;\n    }\n\n    size_t end = n - 2;\n    size_t i = 0;\n\n    while (i < end) {\n        svbool_t pg = svwhilelt_b8(i, end);\n        svuint8_t v0 = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t v1 = svld1_u8(pg, (const uint8_t*)(s.data() + i + 1));\n        svuint8_t v2 = svld1_u8(pg, (const uint8_t*)(s.data() + i + 2));\n\n        svbool_t cmp1 = svcmpne(pg, v0, v1);\n        svbool_t cmp2 = svcmpne(pg, v0, v2);\n        svbool_t cmp3 = svcmpne(pg, v1, v2);\n        svbool_t cmp = svand_z(pg, cmp1, svand_z(pg, cmp2, cmp3));\n\n        uint64_t vl = svcntp_b8(pg, pg);\n        uint64_t cnt_cmp = svcntp_b8(pg, cmp);\n\n        if (cnt_cmp < vl) {\n            return false;\n        }\n\n        i += vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    uint64_t len = str.length();\n    \n    if (len <= 1) {\n        return false;\n    }\n    if (len == 2) {\n        return true;\n    }\n    if (len % 2 == 0) {\n        return false;\n    }\n    \n    uint64_t max_divisor = 1;\n    while (max_divisor <= len / max_divisor) {\n        max_divisor++;\n    }\n    max_divisor--;\n    \n    uint64_t vl = svcntd();\n    uint64_t base = 3;\n    while (base <= max_divisor) {\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t divisors = svadd_u64_x(svptrue_b64(), svmul_n_u64_x(svptrue_b64(), indices, 2), base);\n        \n        svbool_t pg = svcmple_n_u64(svptrue_b64(), divisors, max_divisor);\n        uint64_t count = svcntp_b64(pg, pg);\n        if (count == 0) {\n            break;\n        }\n        \n        uint64_t div_arr[svcntd()];\n        svst1_u64(pg, div_arr, divisors);\n        \n        for (uint64_t j = 0; j < count; j++) {\n            if (len % div_arr[j] == 0) {\n                return false;\n            }\n        }\n        base += 2 * vl;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    uint32_t n = str.length();\n    if (n <= 1) \n        return false;\n    if (n == 2) \n        return true;\n    if (n % 2 == 0) \n        return false;\n\n    uint32_t limit = static_cast<uint32_t>(std::sqrt(n)) + 1;\n    uint32_t base = 3;\n    bool is_prime = true;\n\n    uint32_t vl = svcntw();\n    uint32_t divisors[vl];\n\n    while (base <= limit) {\n        uint32_t count = (limit - base) / 2 + 1;\n        if (count == 0) \n            break;\n        if (count > vl) \n            count = vl;\n\n        svbool_t pg = svwhilelt_b32_u32(0, count);\n        svuint32_t indices = svindex_u32(0, 1);\n        svuint32_t divs = svadd_u32_z(pg, svdup_u32(base), svmul_u32_z(pg, indices, svdup_u32(2)));\n        svst1_u32(pg, divisors, divs);\n\n        for (uint32_t i = 0; i < count; ++i) {\n            if (n % divisors[i] == 0) {\n                is_prime = false;\n                break;\n            }\n        }\n        if (!is_prime) \n            break;\n        base += 2 * count;\n    }\n    return is_prime;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nbool prime_length_simd(const std::string & str) {\n    uint64_t n = str.length();\n    \n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    uint64_t d = 3;\n    uint64_t vl = svcntd();\n\n    while (d <= n / d) {\n        svuint64_t index_vec = svindex_u64(0, 1);\n        svuint64_t div_vec = svmad_u64_z(svptrue_b64(), index_vec, svdup_u64(2), svdup_u64(d));\n        \n        svuint64_t d_sq_vec = svmul_u64_z(svptrue_b64(), div_vec, div_vec);\n        svbool_t in_range = svcmple_u64(svptrue_b64(), d_sq_vec, svdup_u64(n));\n        \n        if (svptest_any(svptrue_b64(), in_range)) {\n            svuint64_t n_vec = svdup_u64(n);\n            svfloat64_t n_fvec = svcvt_f64_u64_z(in_range, n_vec);\n            svfloat64_t d_fvec = svcvt_f64_u64_z(in_range, div_vec);\n            svfloat64_t q_fvec = svdiv_f64_z(in_range, n_fvec, d_fvec);\n            svuint64_t q_uint = svcvt_u64_f64_z(in_range, q_fvec);\n            \n            svuint64_t product = svmul_u64_z(in_range, div_vec, q_uint);\n            svuint64_t rem = svsub_u64_z(in_range, n_vec, product);\n            \n            svbool_t zero_rem = svcmpeq_u64(in_range, rem, svdup_u64(0));\n            if (svptest_any(svptrue_b64(), zero_rem)) {\n                return false;\n            }\n        }\n        \n        d += 2 * vl;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str) {\n    size_t n = str.length();\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n\n    uint64_t num = n;\n    uint64_t limit = static_cast<uint64_t>(std::sqrt(static_cast<double>(num)));\n    if (limit < 3) {\n        return true;\n    }\n\n    uint64_t start = 3;\n    uint64_t vl = svcntd();\n\n    while (start <= limit) {\n        svint64_t divisors = svindex_s64(static_cast<int64_t>(start), 2);\n        svbool_t pg = svcmple_n_s64(svptrue_b64(), divisors, static_cast<int64_t>(limit));\n        uint64_t count = svcntp_b64(svptrue_b64(), pg);\n\n        if (count == 0) {\n            start += 2 * vl;\n            continue;\n        }\n\n        svint64_t compact_divisors = svcompact_s64(pg, divisors);\n        int64_t d_arr[vl];\n        svst1_s64(svptrue_b64(), d_arr, compact_divisors);\n\n        for (uint64_t i = 0; i < count; ++i) {\n            if (num % static_cast<uint64_t>(d_arr[i]) == 0) {\n                return false;\n            }\n        }\n\n        start += 2 * vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_102_SVE", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool prime_length_simd(const std::string & str){\n    size_t n = str.size();\n    if (n <= 1) \n        return false;\n    if (n == 2) \n        return true;\n    if (n % 2 == 0) \n        return false;\n\n    uint64_t sqrt_n = (uint64_t)std::sqrt(n);\n    if (sqrt_n < 3) \n        return true;\n\n    uint64_t vl = svcntd();\n    uint64_t base = 3;\n\n    while (base <= sqrt_n) {\n        svuint64_t indices = svindex_u64(0, 1);\n        svuint64_t step_vec = svmul_u64_z(svptrue_b64(), indices, svdup_u64(2));\n        svuint64_t div_vec = svadd_u64_z(svptrue_b64(), svdup_u64(base), step_vec);\n\n        svbool_t pg = svcmple_u64(svptrue_b64(), div_vec, svdup_u64(sqrt_n));\n        uint64_t active_count = svcntp_b64(svptrue_b64(), pg);\n        if (active_count == 0) \n            break;\n\n        uint64_t divisors[32];\n        svst1_u64(pg, divisors, div_vec);\n\n        for (uint64_t i = 0; i < active_count; i++) {\n            if (n % divisors[i] == 0) \n                return false;\n        }\n\n        base += 2 * vl;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    if (N == 0) {\n        return \"0\";\n    }\n\n    std::string num_str = std::to_string(N);\n    size_t len = num_str.size();\n    const char* p = num_str.c_str();\n    svuint64_t sum_vec = svdup_u64(0);\n    size_t i = 0;\n\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t chars = svld1_u8(pg, (const uint8_t*)(p + i));\n        svuint8_t digits = svsub_u8_z(pg, chars, svdup_u8('0'));\n        svuint64_t digits_wide = svcvt_u64_u8_z(pg, digits);\n        sum_vec = svadd_u64_z(pg, sum_vec, digits_wide);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n\n    uint64_t sum = svaddv_u64(svptrue_b64(), sum_vec);\n\n    if (sum == 0) {\n        return \"0\";\n    }\n\n    std::string binary_str;\n    while (sum) {\n        binary_str = char('0' + (sum & 1)) + binary_str;\n        sum >>= 1;\n    }\n    return binary_str;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n\nstd::string solve_simd(uint64_t N) {\n    std::string num_str = std::to_string(N);\n    uint64_t len = num_str.length();\n    uint8_t digits[20] = {0};\n    for (uint64_t i = 0; i < len; i++) {\n        digits[i] = num_str[i] - '0';\n    }\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t v = svld1_u8(pg, digits);\n    uint64_t sum = svaddv_u8(pg, v);\n    if (sum == 0) {\n        return \"0\";\n    }\n    std::string binary;\n    while (sum) {\n        binary = static_cast<char>('0' + (sum & 1)) + binary;\n        sum >>= 1;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    if (N == 0) {\n        return \"0\";\n    }\n    uint8_t digits[20];\n    int count = 0;\n    uint64_t num = N;\n    while (num > 0) {\n        digits[count++] = num % 10;\n        num /= 10;\n    }\n    svbool_t pg = svwhilelt_b8(0, count);\n    svuint8_t v = svld1_u8(pg, digits);\n    uint8_t total_digit_sum = svaddv_u8(pg, v);\n    char bin_chars[32];\n    int idx = 0;\n    uint64_t tmp = total_digit_sum;\n    while (tmp) {\n        bin_chars[idx++] = (tmp & 1) ? '1' : '0';\n        tmp >>= 1;\n    }\n    std::string res;\n    for (int i = idx - 1; i >= 0; --i) {\n        res += bin_chars[i];\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    uint64_t temp = N;\n    uint64_t S = 0;\n    while (temp != 0) {\n        S += temp % 10;\n        temp /= 10;\n    }\n\n    if (S == 0) {\n        return \"0\";\n    }\n\n    uint32_t x = static_cast<uint32_t>(S);\n    int len = 0;\n    uint32_t t = x;\n    while (t) {\n        len++;\n        t >>= 1;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, len);\n    svuint8_t indices = svindex_u8(0, 1);\n    svuint8_t shift_counts = svsub_u8_z(pg, svdup_u8(len-1), indices);\n    svuint8_t masks = svlsl_u8_z(pg, svdup_u8(1), shift_counts);\n    svuint8_t x_vec = svdup_u8(x);\n    svuint8_t bits = svand_u8_z(pg, x_vec, masks);\n    svbool_t nonzero = svcmpne_u8_z(pg, bits, svdup_u8(0));\n    svuint8_t char_vec = svsel(nonzero, svdup_u8('1'), svdup_u8('0'));\n\n    char buffer[9];\n    svst1_u8(pg, reinterpret_cast<uint8_t*>(buffer), char_vec);\n    buffer[len] = '\\0';\n\n    return std::string(buffer);\n}\n```"}
{"task_id": "SimdBench_103_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string solve_simd(uint64_t N) {\n    char buffer[21];\n    int i = 0;\n    if (N == 0) {\n        buffer[i++] = '0';\n    } else {\n        uint64_t num = N;\n        while (num) {\n            buffer[i++] = '0' + (num % 10);\n            num /= 10;\n        }\n    }\n\n    svbool_t pg = svwhilelt_b8(0, i);\n    svuint8_t v = svld1_u8(pg, (uint8_t*)buffer);\n    svuint8_t zeros = svdup_u8('0');\n    svuint8_t digits = svsub_u8_x(pg, v, zeros);\n    uint8_t sum8 = svaddv_u8(pg, digits);\n    uint64_t total = sum8;\n\n    if (total == 0) {\n        return \"0\";\n    }\n\n    uint64_t temp = total;\n    int bits = 0;\n    while (temp) {\n        bits++;\n        temp >>= 1;\n    }\n\n    std::string bin_str;\n    bin_str.reserve(bits);\n    for (int shift = bits - 1; shift >= 0; shift--) {\n        bin_str += ('0' + ((total >> shift) & 1));\n    }\n    return bin_str;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nint add_simd(std::vector<int> lst) {\n    int total = 0;\n    uint64_t n = lst.size();\n    if (n == 0) return 0;\n    uint64_t vl = svcntw();\n    for (uint64_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint32_t indices = svadd_u32_z(pg, svdup_u32(i), svindex_u32(0, 1));\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        svuint32_t mod_index = svand_u32_z(pg, indices, svdup_u32(1));\n        svbool_t p_odd = svcmpeq_u32(pg, mod_index, svdup_u32(1));\n        svint32_t mod_elem = svand_s32_z(pg, data, svdup_s32(1));\n        svbool_t p_even = svcmpeq_s32(pg, mod_elem, svdup_s32(0));\n        svbool_t p_comb = svand_b_z(pg, p_odd, p_even);\n        int32_t sum_segment = svaddv_s32(p_comb, data);\n        total += sum_segment;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    uint64_t n = lst.size();\n    if (n == 0) return 0;\n    \n    uint64_t i = 0;\n    int32_t total = 0;\n    svint32_t one_vec = svdup_n_s32(1);\n    \n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        svint32_t indices = svindex_s32(i, 1);\n        \n        svbool_t odd_idx = svtst(pg, indices, one_vec);\n        svint32_t lsb = svand_s32_z(pg, data, one_vec);\n        svbool_t even_data = svcmpeq(pg, lsb, 0);\n        \n        svbool_t cond = svand_b_z(pg, odd_idx, even_data);\n        total += svaddv_s32(cond, data);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n    \n    uint64_t vl = svcntw();\n    svint32_t sum_vec = svdup_s32(0);\n    \n    uint32_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    \n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data_vec = svld1_s32(pg, &lst[i]);\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t low_bit = svand_u32_z(pg, indices, 1);\n        svbool_t p_odd = svcmpeq_u32(pg, low_bit, 1);\n        svint32_t low_bit_data = svand_s32_z(pg, data_vec, svdup_s32(1));\n        svbool_t p_even = svcmpeq_s32(pg, low_bit_data, 0);\n        svbool_t p_comb = svand_b_z(pg, p_odd, p_even);\n        svint32_t selected = svsel_s32(p_comb, data_vec, svdup_s32(0));\n        sum_vec = svadd_s32_m(pg, sum_vec, selected);\n        \n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n    \n    return svaddv_s32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    int n = lst.size();\n    if (n == 0) return 0;\n    \n    uint64_t vl = svcntw();\n    svint32_t sum_vec = svdup_s32(0);\n    svbool_t pg_all = svptrue_b32();\n    int i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t mod_indices = svand_x(pg, indices, 1);\n        svbool_t pg_odd = svcmpne(pg, mod_indices, 0);\n        svint32_t data = svld1(pg, &lst[i]);\n        svint32_t mod_data = svand_x(pg, data, 1);\n        svbool_t pg_even = svcmpeq(pg, mod_data, 0);\n        svbool_t pg_cond = svand_b_z(pg, pg_odd, pg_even);\n        sum_vec = svadd_m(pg_cond, sum_vec, data);\n        i += vl;\n    }\n\n    return svaddv(pg_all, sum_vec);\n}\n```"}
{"task_id": "SimdBench_104_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_simd(std::vector<int> lst) {\n    size_t n = lst.size();\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    int total_sum = 0;\n    svint32_t one_vec = svdup_n_s32(1);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t index_mod = svand_s32_z(pg, indices, one_vec);\n        svbool_t pg_index = svcmpeq(pg, index_mod, one_vec);\n        svint32_t data_mod = svand_s32_z(pg, data, one_vec);\n        svbool_t pg_value = svcmpeq(pg, data_mod, 0);\n        svbool_t pg_comb = svand_z(pg, pg_index, pg_value);\n        total_sum += svaddv_s32(pg_comb, data);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    if (s.empty()) \n        return \"\";\n\n    size_t len = s.length();\n    std::string res(len, 0);\n    const uint8_t *in_ptr = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *out_ptr = reinterpret_cast<uint8_t*>(&res[0]);\n\n    uint64_t i = 0;\n    uint64_t vl = svcntb();\n    svuint8_t va = svdup_u8('a');\n    svuint8_t v4 = svdup_u8(4);\n    svuint8_t v26 = svdup_u8(26);\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input = svld1_u8(pg, in_ptr + i);\n        svuint8_t offset = svsub_u8_z(pg, input, va);\n        svuint8_t shifted = svadd_u8_z(pg, offset, v4);\n        svbool_t mask = svcmpge_u8(pg, shifted, v26);\n        svuint8_t adjusted = svsub_u8_z(pg, shifted, svsel_u8(mask, v26, svdup_u8(0)));\n        svuint8_t output = svadd_u8_z(pg, adjusted, va);\n        svst1_u8(pg, out_ptr + i, output);\n        i += vl;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    if (len == 0) {\n        return \"\";\n    }\n    std::string result(len, ' ');\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(s.data() + i));\n        svuint8_t base = svsub_u8_x(pg, vec, svdup_u8('a'));\n        svuint8_t shifted = svadd_u8_x(pg, base, svdup_u8(4));\n        svbool_t overflow = svcmpge_u8(pg, shifted, svdup_u8(26));\n        shifted = svsub_u8_m(shifted, overflow, shifted, svdup_u8(26));\n        svuint8_t encrypted = svadd_u8_x(pg, shifted, svdup_u8('a'));\n        svst1_u8(pg, (uint8_t*)(result.data() + i), encrypted);\n        i += svcntp_b8(svptrue_b8(), pg);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.length();\n    if (len == 0) {\n        return \"\";\n    }\n    std::string res(len, '\\0');\n    uint64_t i = 0;\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *out = reinterpret_cast<uint8_t*>(res.data());\n    uint64_t vl = svcntb();\n    svuint8_t base_vec = svdup_n_u8('a');\n    svuint8_t step_vec = svdup_n_u8(4);\n    svuint8_t modulus_vec = svdup_n_u8(26);\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input = svld1_u8(pg, data + i);\n        svuint8_t offset = svsub_u8_z(pg, input, base_vec);\n        svuint8_t shifted = svadd_u8_z(pg, offset, step_vec);\n        svbool_t pg_overflow = svcmpge_u8(pg, shifted, modulus_vec);\n        shifted = svsub_u8_m(pg_overflow, shifted, modulus_vec);\n        svuint8_t result_vec = svadd_u8_z(pg, shifted, base_vec);\n        svst1_u8(pg, out + i, result_vec);\n        i += vl;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstdint>\n\nstd::string encrypt_simd(const std::string & s) {\n    if (s.empty()) return s;\n    \n    std::string res(s);\n    size_t len = s.size();\n    size_t i = 0;\n    const uint64_t vl = svcntb();\n    const uint8_t four = 4;\n    const uint8_t twenty_six = 26;\n    const uint8_t a_val = 'a';\n    const uint8_t z_val = 'z';\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input_vec = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        \n        svbool_t mask_ge_a = svcmpge(pg, input_vec, svdup_u8(a_val));\n        svbool_t mask_le_z = svcmple(pg, input_vec, svdup_u8(z_val));\n        svbool_t mask_letter = svand_b_z(pg, mask_ge_a, mask_le_z);\n        \n        svuint8_t added = svadd_u8_m(mask_letter, input_vec, svdup_u8(four));\n        svbool_t mask_gt_z = svcmpgt(pg, added, svdup_u8(z_val));\n        svbool_t mask_wrap = svand_b_z(pg, mask_letter, mask_gt_z);\n        \n        svuint8_t output_vec = svsub_u8_m(mask_wrap, added, svdup_u8(twenty_six));\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(res.data() + i), output_vec);\n        \n        i += vl;\n    }\n    \n    return res;\n}\n```"}
{"task_id": "SimdBench_105_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encrypt_simd(const std::string & s) {\n    size_t len = s.size();\n    std::string res(len, '\\0');\n    if (len == 0) {\n        return res;\n    }\n\n    const uint8_t *src = reinterpret_cast<const uint8_t*>(s.data());\n    uint8_t *dst = reinterpret_cast<uint8_t*>(&res[0]);\n\n    uint64_t vl = svcntb();\n    svuint8_t fours = svdup_n_u8(4);\n    svuint8_t twenty_six = svdup_n_u8(26);\n    svuint8_t z_char = svdup_n_u8('z');\n\n    for (uint64_t i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, src + i);\n        vec = svadd_u8_z(pg, vec, fours);\n        svbool_t p_overflow = svcmpgt_u8(pg, vec, z_char);\n        vec = svsub_u8_m(p_overflow, vec, vec, twenty_six);\n        svst1_u8(pg, dst + i, vec);\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    const size_t len = message.length();\n    std::string result(len, '\\0');\n    const char *ptr = message.data();\n    char *out = result.data();\n    size_t i = 0;\n    const size_t vector_length = svcntb();\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t input = svld1_u8(pg, (const uint8_t*)(ptr + i));\n\n        svbool_t is_upper = svand_b_z(pg, \n                             svcmpge_u8(pg, input, svdup_u8('A')),\n                             svcmple_u8(pg, input, svdup_u8('Z')));\n        svbool_t is_lower = svand_b_z(pg, \n                             svcmpge_u8(pg, input, svdup_u8('a')),\n                             svcmple_u8(pg, input, svdup_u8('z')));\n        svbool_t is_letter = svorr_b_z(pg, is_upper, is_lower);\n        svuint8_t swapped = sveor_u8_z(pg, input, svdup_u8(32));\n        swapped = svsel_u8(is_letter, swapped, input);\n\n        svbool_t is_vowel = svcmpeq_u8(pg, swapped, svdup_u8('a'));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('e')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('i')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('o')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('u')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('A')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('E')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('I')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('O')));\n        is_vowel = svorr_b_z(pg, is_vowel, svcmpeq_u8(pg, swapped, svdup_u8('U')));\n\n        svuint8_t output_vec = svsel_u8(is_vowel, \n                                      svadd_u8_z(pg, swapped, svdup_u8(2)), \n                                      swapped);\n        svst1_u8(pg, (uint8_t*)(out + i), output_vec);\n\n        i += vector_length;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <cstring>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    char *output = new char[len + 1];\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t input_vec = svld1_u8(pg, (const uint8_t*)(message.data() + i));\n        svuint8_t swapped_vec = sveor_u8_z(pg, input_vec, svdup_n_u8(0x20));\n        svuint8_t low_vec = svorr_u8_z(pg, swapped_vec, svdup_n_u8(0x20));\n        \n        svbool_t vowel_mask = svcmpeq_u8(pg, low_vec, svdup_n_u8('a'));\n        vowel_mask = svorr_m(pg, vowel_mask, svcmpeq_u8(pg, low_vec, svdup_n_u8('e')));\n        vowel_mask = svorr_m(pg, vowel_mask, svcmpeq_u8(pg, low_vec, svdup_n_u8('i')));\n        vowel_mask = svorr_m(pg, vowel_mask, svcmpeq_u8(pg, low_vec, svdup_n_u8('o')));\n        vowel_mask = svorr_m(pg, vowel_mask, svcmpeq_u8(pg, low_vec, svdup_n_u8('u')));\n        \n        svuint8_t result_vec = svadd_u8_m(vowel_mask, swapped_vec, svdup_n_u8(2));\n        svst1_u8(pg, (uint8_t*)(output + i), result_vec);\n        \n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    output[len] = '\\0';\n    std::string result(output, len);\n    delete[] output;\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    size_t len = message.length();\n    std::string result(len, '\\0');\n    size_t i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t vec = svld1_u8(pg, (const uint8_t*)(message.data() + i));\n\n        svbool_t lower_mask = svand_b_z(pg, \n                           svcmpge(pg, vec, 'a'),\n                           svcmple(pg, vec, 'z'));\n        svbool_t upper_mask = svand_b_z(pg,\n                           svcmpge(pg, vec, 'A'),\n                           svcmple(pg, vec, 'Z'));\n\n        vec = svsub_u8_m(vec, lower_mask, vec, 32);\n        vec = svadd_u8_m(vec, upper_mask, vec, 32);\n\n        svbool_t vowel_mask = svcmpeq(pg, vec, 'a');\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'e'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'i'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'o'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'u'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'A'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'E'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'I'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'O'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq(pg, vec, 'U'));\n\n        vec = svadd_u8_m(vec, vowel_mask, vec, 2);\n\n        svst1_u8(pg, (uint8_t*)(result.data() + i), vec);\n        i += svcntb();\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_106_SVE", "completion": "To solve this problem, we need to create a function that processes a string by swapping the case of all letters and then replacing all vowels with the letter that appears two places ahead in the English alphabet. The solution should leverage SVE intrinsics for parallel processing to enhance performance.\n\n### Approach\n1. **Initialization**: Create an output string of the same size as the input string to store the processed result.\n2. **Vector Processing**: Process the input string in chunks using SVE vectors. The chunk size is determined by the SVE vector length.\n3. **Case Swapping**:\n   - **Identify Letters**: For each character in the vector, determine if it is an uppercase or lowercase letter using SVE comparison intrinsics.\n   - **Swap Case**: Flip the 5th bit (0x20) of each identified letter to swap its case.\n4. **Vowel Replacement**:\n   - **Identify Vowels**: Check each character in the swapped vector to see if it is a vowel (either uppercase or lowercase).\n   - **Replace Vowels**: For each identified vowel, replace it with the letter two positions ahead in the alphabet while maintaining its case.\n5. **Store Result**: Store the processed vector chunk into the output string.\n6. **Loop Handling**: Continue processing until all characters in the input string are processed.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message) {\n    std::string out;\n    size_t n = message.size();\n    out.resize(n);\n    size_t i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t input_vec = svld1_u8(pg, (const uint8_t*)&message[i]);\n\n        svbool_t mask_upper = svand_b_z(pg, \n                                svcmpge(pg, input_vec, (uint8_t)'A'),\n                                svcmple(pg, input_vec, (uint8_t)'Z'));\n        svbool_t mask_lower = svand_b_z(pg,\n                                svcmpge(pg, input_vec, (uint8_t)'a'),\n                                svcmple(pg, input_vec, (uint8_t)'z'));\n        svbool_t mask_letter = svorr_b_z(pg, mask_upper, mask_lower);\n\n        svuint8_t swapped_vec = sveor_u8_m(mask_letter, input_vec, svdup_u8(0x20));\n\n        svbool_t mask_vowel = svcmpeq(pg, swapped_vec, (uint8_t)'A');\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'E'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'I'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'O'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'U'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'a'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'e'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'i'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'o'));\n        mask_vowel = svorr_b_z(pg, mask_vowel, svcmpeq(pg, swapped_vec, (uint8_t)'u'));\n\n        svuint8_t result_vec = svadd_u8_m(mask_vowel, swapped_vec, svdup_u8(2));\n\n        svst1_u8(pg, (uint8_t*)&out[i], result_vec);\n\n        i += svcntb();\n    }\n\n    return out;\n}\n```\n\n### Explanation\n1. **Initialization**: The output string `out` is initialized to the same size as the input string `message`.\n2. **Vector Processing Loop**: The loop processes the input string in chunks, where each chunk's size is determined by the SVE vector length (`svcntb()`).\n3. **Case Swapping**:\n   - **Mask Creation**: Two masks (`mask_upper` and `mask_lower`) identify uppercase and lowercase letters, respectively. These masks are combined into `mask_letter`.\n   - **Bit Flipping**: The 5th bit of each letter in the vector is flipped using `sveor_u8_m`, effectively swapping the case.\n4. **Vowel Replacement**:\n   - **Vowel Mask**: A combined mask (`mask_vowel`) identifies all vowels (both uppercase and lowercase) in the swapped vector.\n   - **Vowel Shift**: Identified vowels are shifted two positions ahead in the alphabet by adding 2 to their ASCII values using `svadd_u8_m`.\n5. **Result Storage**: The processed vector chunk is stored into the output string using `svst1_u8`.\n6. **Loop Termination**: The loop continues until all characters in the input string are processed, incrementing the index `i` by the SVE vector length in each iteration.\n\nThis approach efficiently processes the string in parallel using SVE intrinsics, ensuring optimal performance while adhering to the problem requirements."}
{"task_id": "SimdBench_106_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string encode_simd(const std::string & message){\n    std::string result = message;\n    uint64_t len = message.size();\n    if (len == 0) {\n        return result;\n    }\n\n    const uint8_t *data = reinterpret_cast<const uint8_t*>(message.data());\n    uint8_t *out_data = reinterpret_cast<uint8_t*>(&result[0]);\n\n    uint64_t i = 0;\n    do {\n        svbool_t pg = svwhilelt_b8(i, len);\n        if (svptest_any(svptrue_b8(), pg) == 0) \n            break;\n\n        svuint8_t input_vec = svld1_u8(pg, data + i);\n        svuint8_t swapped_vec = sveor_u8_x(pg, input_vec, svdup_u8(32));\n\n        svbool_t vowel_mask = svcmpeq_u8(pg, swapped_vec, svdup_u8('a'));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('e')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('i')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('o')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('u')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('A')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('E')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('I')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('O')));\n        vowel_mask = svorr_b_z(pg, vowel_mask, svcmpeq_u8(pg, swapped_vec, svdup_u8('U')));\n\n        svuint8_t result_vec = svadd_u8_m(vowel_mask, swapped_vec, svdup_u8(2));\n        svst1_u8(pg, out_data + i, result_vec);\n\n        i += svcntb();\n    } while (i < len);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        if (key.empty()) {\n            all_lower = false;\n            all_upper = false;\n            break;\n        }\n\n        bool has_non_alpha = false;\n        bool has_upper_char = false;\n        bool has_lower_char = false;\n\n        const char* ptr = key.c_str();\n        size_t len = key.length();\n        svbool_t pg = svwhilelt_b8(0, len);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t in = svld1(pg, (const uint8_t*)ptr);\n            svuint8_t u8_in = svreinterpret_u8(in);\n            svbool_t is_upper = svand(svcmpge(u8_in, 'A'), svcmple(u8_in, 'Z'));\n            svbool_t is_lower = svand(svcmpge(u8_in, 'a'), svcmple(u8_in, 'z'));\n            svbool_t is_alpha = svorr_z(pg, is_upper, is_lower);\n            svbool_t non_alpha = svnot_z(pg, is_alpha);\n\n            if (svptest_any(pg, non_alpha)) {\n                has_non_alpha = true;\n                break;\n            }\n\n            if (!has_upper_char) {\n                has_upper_char = svptest_any(pg, is_upper);\n            }\n            if (!has_lower_char) {\n                has_lower_char = svptest_any(pg, is_lower);\n            }\n\n            ptr += svcntb();\n            len -= svcntb();\n            pg = svwhilelt_b8(0, len);\n        }\n\n        if (has_non_alpha) {\n            all_lower = false;\n            all_upper = false;\n            break;\n        }\n\n        if (has_upper_char) {\n            all_lower = false;\n        }\n        if (has_lower_char) {\n            all_upper = false;\n        }\n\n        if (!all_lower && !all_upper) {\n            break;\n        }\n    }\n\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict){\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool found_lower = false;\n    bool found_upper = false;\n    \n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        if (key.empty()) {\n            return false;\n        }\n        \n        bool has_lower = false;\n        bool has_upper = false;\n        bool broken = false;\n        size_t i = 0;\n        const char* s = key.c_str();\n        size_t len = key.length();\n        \n        while (i < len && !broken) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t data = svld1_u8(pg, s + i);\n            \n            svbool_t lower_mask = svand_b_z(pg,\n                svcmpge_u8(pg, data, 'a'),\n                svcmple_u8(pg, data, 'z')\n            );\n            svbool_t upper_mask = svand_b_z(pg,\n                svcmpge_u8(pg, data, 'A'),\n                svcmple_u8(pg, data, 'Z')\n            );\n            svbool_t non_alpha = svnot_b_z(pg, svorr_b_z(pg, lower_mask, upper_mask));\n            \n            if (svptest_any(pg, non_alpha)) {\n                broken = true;\n                break;\n            }\n            \n            if (svptest_any(pg, lower_mask)) {\n                has_lower = true;\n            }\n            if (svptest_any(pg, upper_mask)) {\n                has_upper = true;\n            }\n            \n            if (has_lower && has_upper) {\n                broken = true;\n                break;\n            }\n            \n            i += svcntp_b8(svptrue_b8(), pg);\n        }\n        \n        if (broken || (has_lower && has_upper)) {\n            return false;\n        }\n        \n        if (has_lower) {\n            if (found_upper) {\n                return false;\n            }\n            found_lower = true;\n        } else if (has_upper) {\n            if (found_lower) {\n                return false;\n            }\n            found_upper = true;\n        } else {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_letters = true;\n    bool has_lower = false;\n    bool has_upper = false;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        const char* str = key.c_str();\n        size_t len = key.length();\n        uint64_t i = 0;\n        svbool_t pg = svwhilelt_b8(i, len);\n\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)(str + i));\n\n            svuint8_t vecA = svdup_n_u8('A');\n            svuint8_t vecZ = svdup_n_u8('Z');\n            svuint8_t veca = svdup_n_u8('a');\n            svuint8_t vecz = svdup_n_u8('z');\n\n            svbool_t is_upper = svand_b_z(pg, \n                                         svcmpge_u8(pg, chars, vecA),\n                                         svcmple_u8(pg, chars, vecZ));\n            svbool_t is_lower = svand_b_z(pg,\n                                         svcmpge_u8(pg, chars, veca),\n                                         svcmple_u8(pg, chars, vecz));\n            svbool_t is_letter = svorr_b_z(pg, is_upper, is_lower);\n            svbool_t non_letter = svnot_b_z(pg, is_letter);\n\n            if (svptest_any(pg, non_letter)) {\n                all_letters = false;\n                break;\n            }\n\n            if (svptest_any(pg, is_lower)) {\n                has_lower = true;\n            }\n            if (svptest_any(pg, is_upper)) {\n                has_upper = true;\n            }\n\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n\n        if (!all_letters) {\n            break;\n        }\n        if (has_upper && has_lower) {\n            break;\n        }\n    }\n\n    if (!all_letters) {\n        return false;\n    }\n    if (has_upper && has_lower) {\n        return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) \n        return false;\n\n    enum Case { UPPER, LOWER, NONE };\n    Case global_case = NONE;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        size_t len = key.size();\n        if (len == 0) \n            return false;\n\n        bool key_has_upper = false;\n        bool key_has_lower = false;\n        size_t i = 0;\n\n        do {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t chars = svld1_u8(pg, (const uint8_t*)(key.data() + i));\n\n            svbool_t in_lower = svand_z(pg,\n                        svcmpge(pg, chars, svdup_n_u8('a')),\n                        svcmple(pg, chars, svdup_n_u8('z')));\n            svbool_t in_upper = svand_z(pg,\n                        svcmpge(pg, chars, svdup_n_u8('A')),\n                        svcmple(pg, chars, svdup_n_u8('Z')));\n            svbool_t is_alpha = svorr_z(pg, in_lower, in_upper);\n            svbool_t non_alpha = svnot_b_z(pg, is_alpha);\n\n            if (svptest_any(pg, non_alpha)) \n                return false;\n\n            key_has_upper = key_has_upper || svptest_any(pg, in_upper);\n            key_has_lower = key_has_lower || svptest_any(pg, in_lower);\n\n            i += svcntb();\n        } while (i < len);\n\n        if (key_has_upper && key_has_lower) \n            return false;\n\n        if (key_has_upper) {\n            if (global_case == NONE) \n                global_case = UPPER;\n            else if (global_case != UPPER) \n                return false;\n        } else if (key_has_lower) {\n            if (global_case == NONE) \n                global_case = LOWER;\n            else if (global_case != LOWER) \n                return false;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_107_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <map>\n#include <string>\n#include <cstdint>\n\nbool check_dict_case_simd(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool found_lower = false;\n    bool found_upper = false;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        if (key.empty()) {\n            return false;\n        }\n\n        size_t len = key.size();\n        uint64_t i = 0;\n        bool key_is_lower = true;\n        bool key_is_upper = true;\n\n        while (i < len && (key_is_lower || key_is_upper)) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t data = svld1_u8(pg, (const uint8_t*)key.data() + i);\n            i += svcntb();\n\n            svbool_t lower_bound = svcmpge(pg, data, (uint8_t)'a');\n            svbool_t lower_bound2 = svcmple(pg, data, (uint8_t)'z');\n            svbool_t is_lower_char = svand_b_z(pg, lower_bound, lower_bound2);\n            if (svptest_any(pg, svnot_b_z(pg, is_lower_char))) {\n                key_is_lower = false;\n            }\n\n            svbool_t upper_bound = svcmpge(pg, data, (uint8_t)'A');\n            svbool_t upper_bound2 = svcmple(pg, data, (uint8_t)'Z');\n            svbool_t is_upper_char = svand_b_z(pg, upper_bound, upper_bound2);\n            if (svptest_any(pg, svnot_b_z(pg, is_upper_char))) {\n                key_is_upper = false;\n            }\n        }\n\n        if (!key_is_lower && !key_is_upper) {\n            return false;\n        }\n\n        if (key_is_lower) {\n            if (found_upper) {\n                return false;\n            }\n            found_lower = true;\n        } else {\n            if (found_lower) {\n                return false;\n            }\n            found_upper = true;\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdlib>\n#include <cmath>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n < 2) {\n        return std::vector<int>();\n    }\n\n    uint8_t* is_prime = (uint8_t*)malloc(n * sizeof(uint8_t));\n    if (is_prime == nullptr) {\n        return std::vector<int>();\n    }\n\n    for (int i = 0; i < n; i++) {\n        is_prime[i] = 1;\n    }\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            int32_t start = i * i;\n            svbool_t pg = svwhilelt_b32(start, n);\n            while (svptest_any(svptrue_b32(), pg)) {\n                svint32_t indices = svindex_s32(start, i);\n                svst1_scatter_s32index_u8(pg, is_prime, indices, svdup_u8(0));\n                uint64_t cnt = svcntp_b32(svptrue_b32(), pg);\n                start += static_cast<int32_t>(cnt) * i;\n                pg = svwhilelt_b32(start, n);\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    free(is_prime);\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <cstdint>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return std::vector<int>();\n    }\n\n    uint8_t *is_prime = new uint8_t[n];\n    std::memset(is_prime, 1, n);\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    int sqrt_n = std::sqrt(n);\n    uint64_t vl = svcntd();\n\n    for (int i = 2; i <= sqrt_n; i++) {\n        if (is_prime[i]) {\n            uint64_t start = static_cast<uint64_t>(i) * static_cast<uint64_t>(i);\n            if (start >= static_cast<uint64_t>(n)) {\n                continue;\n            }\n            svuint64_t step_vec = svdup_u64(i);\n            uint64_t j = start;\n            while (j < static_cast<uint64_t>(n)) {\n                svuint64_t offsets = svindex_u64(0, 1);\n                svuint64_t step_offsets = svmul_u64_z(svptrue_b64(), offsets, step_vec);\n                svuint64_t indices = svadd_u64_z(svptrue_b64(), svdup_u64(j), step_offsets);\n                svbool_t pg = svcmplt_u64(svptrue_b64(), indices, svdup_u64(n));\n                svst1_scatter_u64index_u8(pg, is_prime, indices, svdup_u8(0));\n                j += vl * static_cast<uint64_t>(i);\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return std::vector<int>();\n    }\n    std::vector<uint8_t> is_prime(n, 1);\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n    uint64_t vl = svcntd();\n    for (int i = 2; static_cast<uint64_t>(i) * static_cast<uint64_t>(i) < static_cast<uint64_t>(n); i++) {\n        if (is_prime[i]) {\n            uint64_t start = static_cast<uint64_t>(i) * static_cast<uint64_t>(i);\n            uint64_t step = static_cast<uint64_t>(i);\n            svuint64_t index_pattern = svindex_u64(0, 1);\n            index_pattern = svmul_n_u64_z(svptrue_b64(), index_pattern, step);\n            uint64_t j = start;\n            while (j < n) {\n                svuint64_t j_vec = svadd_n_u64_z(svptrue_b64(), index_pattern, j);\n                svbool_t pg = svcmplt_n_u64(svptrue_b64(), j_vec, n);\n                if (svptest_any(svptrue_b64(), pg) == 0) {\n                    break;\n                }\n                svst1_scatter_u64index_u8(pg, &is_prime[0], j_vec, svdup_n_u8(0));\n                j += step * vl;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n#include <cstdint>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return std::vector<int>();\n    }\n\n    uint8_t* is_prime = new uint8_t[n];\n    for (int i = 0; i < n; i++) {\n        is_prime[i] = 1;\n    }\n    is_prime[0] = 0;\n    is_prime[1] = 0;\n\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            int j = i * i;\n            while (j < n) {\n                svbool_t pg = svwhilelt_b32(j, n);\n                svint32_t v_idx = svindex_s32(j, i);\n                svst1_scatter_s32index_u8(pg, is_prime, v_idx, svdup_u8(0));\n                j += i * svcntw();\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    uint64_t vl = svcntw();\n    int32_t tmp[64];\n\n    int i = 2;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svuint8_t v_data = svld1_u8(pg, is_prime + i);\n        svbool_t non_zero = svcmpne(pg, v_data, svdup_u8(0));\n        svint32_t v_indices = svindex_s32(i, 1);\n        svint32_t compacted = svcompact_s32(non_zero, v_indices);\n        uint32_t count = svcntp_b32(svptrue_b32(), non_zero);\n        if (count > 0) {\n            svst1_s32(svptrue_b32(), tmp, compacted);\n            primes.insert(primes.end(), tmp, tmp + count);\n        }\n        i += vl;\n    }\n\n    delete[] is_prime;\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> count_up_to_simd(int n) {\n    if (n <= 2) {\n        return {};\n    }\n\n    std::vector<uint8_t> sieve(n, 1);\n    sieve[0] = 0;\n    sieve[1] = 0;\n\n    for (int i = 2; i * i < n; i++) {\n        if (sieve[i]) {\n            int start = i * i;\n            int step = i;\n\n            svbool_t pg = svwhilelt_b32_s32(start, n);\n            while (svptest_any(svptrue_b32(), pg)) {\n                svint32_t v_indices = svindex_s32(start, step);\n                svst1_scatter_s32index_u8(pg, sieve.data(), v_indices, svdup_u8(0));\n\n                uint32_t num_active = svcntp_b32(svptrue_b32(), pg);\n                start += step * num_active;\n                pg = svwhilelt_b32_s32(start, n);\n            }\n        }\n    }\n\n    std::vector<int> primes;\n    for (int j = 2; j < n; j++) {\n        if (sieve[j]) {\n            primes.push_back(j);\n        }\n    }\n\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    int len = s.size();\n    if (len == 0) return 0;\n    \n    uint64_t i = 0;\n    uint64_t count = 0;\n    uint64_t vl = svcntb();\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        if (svptest_any(svptrue_b8(), pg) == 0) break;\n\n        uint8_t mod = i % 2;\n        svuint8_t j = svindex_u8(0, 1);\n        svuint8_t j_mod2 = svand_n_u8_x(pg, j, 1);\n        svuint8_t mod_vec = svdup_n_u8(mod);\n        svbool_t even_pred = svcmpeq_u8(pg, j_mod2, mod_vec);\n        svbool_t combined_pred = svand_b_z(pg, even_pred, pg);\n\n        svuint8_t data = svld1_u8(combined_pred, reinterpret_cast<const uint8_t*>(s.data() + i));\n\n        svuint8_t A = svdup_n_u8('A');\n        svuint8_t E = svdup_n_u8('E');\n        svuint8_t I = svdup_n_u8('I');\n        svuint8_t O = svdup_n_u8('O');\n        svuint8_t U = svdup_n_u8('U');\n\n        svbool_t isA = svcmpeq_u8(combined_pred, data, A);\n        svbool_t isE = svcmpeq_u8(combined_pred, data, E);\n        svbool_t isI = svcmpeq_u8(combined_pred, data, I);\n        svbool_t isO = svcmpeq_u8(combined_pred, data, O);\n        svbool_t isU = svcmpeq_u8(combined_pred, data, U);\n\n        svbool_t vowels = svorr_b_z(combined_pred, isA, \n                            svorr_b_z(combined_pred, isE, \n                            svorr_b_z(combined_pred, isI, \n                            svorr_b_z(combined_pred, isO, isU))));\n\n        count += svcntp_b8(combined_pred, vowels);\n        i += vl;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstddef>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    const char *ptr = s.data();\n    size_t len = s.size();\n    size_t i = 0;\n    uint64_t count = 0;\n    svbool_t pg = svwhilelt_b8(i, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t data = svld1_u8(pg, ptr + i);\n        svuint64_t offsets = svindex_u64(0, 1);\n        svuint64_t global_indices = svadd_u64_z(pg, offsets, svdup_u64(i));\n        svuint64_t and_res = svand_u64_z(pg, global_indices, svdup_u64(1));\n        svbool_t even_pred = svcmpeq_u64(pg, and_res, svdup_u64(0));\n        svbool_t isA = svcmpeq_u8(pg, data, 'A');\n        svbool_t isE = svcmpeq_u8(pg, data, 'E');\n        svbool_t isI = svcmpeq_u8(pg, data, 'I');\n        svbool_t isO = svcmpeq_u8(pg, data, 'O');\n        svbool_t isU = svcmpeq_u8(pg, data, 'U');\n        svbool_t vowel_match = svorr_b_z(pg, isA, isE);\n        vowel_match = svorr_b_z(pg, vowel_match, isI);\n        vowel_match = svorr_b_z(pg, vowel_match, isO);\n        vowel_match = svorr_b_z(pg, vowel_match, isU);\n        svbool_t final_match = svand_b_z(pg, vowel_match, even_pred);\n        count += svcntp_b8(pg, final_match);\n        i += svcntb();\n        pg = svwhilelt_b8(i, len);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    const char *ptr = s.data();\n    size_t len = s.size();\n    size_t i = 0;\n    uint64_t count = 0;\n    svbool_t while_pred = svwhilelt_b8(i, len);\n\n    while (svptest_any(svptrue_b8(), while_pred)) {\n        uint8_t base_mod = (ptr - s.data()) & 1;\n        svuint8_t vec = svld1_u8(while_pred, (const uint8_t*)ptr);\n        svuint8_t indices = svindex_u8(0, 1);\n        svuint8_t mod2 = svand_u8_x(while_pred, indices, 1);\n        svbool_t even_pred = svcmpeq_u8(while_pred, mod2, svdup_u8(base_mod));\n\n        svbool_t vowel_pred = svcmpeq_u8(while_pred, vec, 'A');\n        vowel_pred = svorr_b_z(while_pred, vowel_pred, svcmpeq_u8(while_pred, vec, 'E'));\n        vowel_pred = svorr_b_z(while_pred, vowel_pred, svcmpeq_u8(while_pred, vec, 'I'));\n        vowel_pred = svorr_b_z(while_pred, vowel_pred, svcmpeq_u8(while_pred, vec, 'O'));\n        vowel_pred = svorr_b_z(while_pred, vowel_pred, svcmpeq_u8(while_pred, vec, 'U'));\n\n        svbool_t final_pred = svand_b_z(while_pred, even_pred, vowel_pred);\n        count += svcntp_b8(while_pred, final_pred);\n\n        size_t processed = svcntb();\n        i += processed;\n        ptr += processed;\n        while_pred = svwhilelt_b8(i, len);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nint count_upper_simd(const std::string & s) {\n    const char *s_ptr = s.data();\n    size_t n = s.size();\n    uint64_t i = 0;\n    uint64_t count = 0;\n\n    if (n == 0) {\n        return 0;\n    }\n\n    svbool_t pattern_even = svptrue_pat_b8(SV_VL2);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t data = svld1_u8(pg, (const uint8_t*)(s_ptr + i));\n\n        svbool_t even_indices;\n        if (i & 1) {\n            even_indices = svnot_z(svptrue_b8(), pattern_even);\n        } else {\n            even_indices = pattern_even;\n        }\n        even_indices = svand_z(svptrue_b8(), even_indices, pg);\n\n        svuint8_t char_A = svdup_n_u8('A');\n        svuint8_t char_Z = svdup_n_u8('Z');\n        svbool_t is_upper = svand_z(pg, \n                              svcmpge(pg, data, char_A),\n                              svcmple(pg, data, char_Z));\n\n        svbool_t is_A = svcmpeq(pg, data, svdup_n_u8('A'));\n        svbool_t is_E = svcmpeq(pg, data, svdup_n_u8('E'));\n        svbool_t is_I = svcmpeq(pg, data, svdup_n_u8('I'));\n        svbool_t is_O = svcmpeq(pg, data, svdup_n_u8('O'));\n        svbool_t is_U = svcmpeq(pg, data, svdup_n_u8('U'));\n        svbool_t is_vowel = svorr_z(pg, is_A, \n                             svorr_z(pg, is_E, \n                             svorr_z(pg, is_I, \n                             svorr_z(pg, is_O, is_U))));\n\n        svbool_t cond = svand_z(pg, is_upper, is_vowel);\n        svbool_t final_pg = svand_z(pg, even_indices, cond);\n\n        count += svcntp_b8(svptrue_b8(), final_pg);\n\n        i += svcntb();\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_109_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint count_upper_simd(const std::string & s){\n    int64_t i = 0;\n    int64_t n = static_cast<int64_t>(s.length());\n    uint64_t count = 0;\n    svbool_t pg_all = svptrue_b8();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b8(i, n);\n        svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n        svuint8_t base_index = svindex_u8(0, 1);\n        svuint8_t base_parity = svand_n_u8_z(pg_all, base_index, 1);\n        uint8_t i_parity = static_cast<uint8_t>(i & 1);\n        svbool_t even_mask = svcmpeq_n_u8(pg_all, base_parity, i_parity);\n        svbool_t pg_even = svand_b_z(pg, even_mask);\n\n        svbool_t cmpA = svcmpeq_n_u8(pg_even, chars, 'A');\n        svbool_t cmpE = svcmpeq_n_u8(pg_even, chars, 'E');\n        svbool_t cmpI = svcmpeq_n_u8(pg_even, chars, 'I');\n        svbool_t cmpO = svcmpeq_n_u8(pg_even, chars, 'O');\n        svbool_t cmpU = svcmpeq_n_u8(pg_even, chars, 'U');\n\n        svbool_t cmp = svorr_b_z(pg_even, cmpA, \n                      svorr_b_z(pg_even, cmpE, \n                      svorr_b_z(pg_even, cmpI, \n                      svorr_b_z(pg_even, cmpO, cmpU))));\n\n        count += svcntp_b8(pg_even, cmp);\n        i += svcntp_b8(pg_all, pg);\n    }\n\n    return static_cast<int>(count);\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    if (n <= 0) {\n        return {};\n    }\n    std::vector<int> res(n);\n\n    svint32_t step_vec = svindex_s32(0, 2);\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, static_cast<uint64_t>(n));\n    while (svptest_any(svptrue_b32(), pg)) {\n        long long base_val_ll = static_cast<long long>(n) + 2 * static_cast<long long>(i);\n        int base_val = static_cast<int>(base_val_ll);\n        svint32_t base_vec = svdup_s32(base_val);\n        svint32_t values = svadd_s32_z(pg, base_vec, step_vec);\n        svst1_s32(pg, res.data() + i, values);\n        uint64_t num_active = svcntp_b32(svptrue_b32(), pg);\n        i += num_active;\n        pg = svwhilelt_b32(i, static_cast<uint64_t>(n));\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    if (n <= 0) {\n        return std::vector<int>();\n    }\n\n    std::vector<int> result(n);\n    int* output = result.data();\n    uint64_t i = 0;\n\n    while (i < static_cast<uint64_t>(n)) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t indices = svindex_s32(i, 1);\n        svint32_t values = svmla_n_s32_x(pg, svdup_n_s32(n), indices, 2);\n        svst1_s32(pg, output + i, values);\n        i += svcntp_b32(pg, pg);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    if (n <= 0) {\n        return std::vector<int>();\n    }\n    std::vector<int> result(n);\n    int i = 0;\n    const uint64_t vl = svcntw();\n    svint32_t base_vec = svdup_s32(n);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t idx_vec = svindex_s32(i, 1);\n        svint32_t value_vec = svmla_n_s32_z(pg, base_vec, idx_vec, 2);\n        svst1_s32(pg, &result[i], value_vec);\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    if (n <= 0) {\n        return std::vector<int>();\n    }\n    std::vector<int> res(n);\n    uint64_t i = 0;\n    while (svptest_any(svptrue_b32(), svwhilelt_b32(i, static_cast<uint64_t>(n)))) {\n        svbool_t pg = svwhilelt_b32(i, static_cast<uint64_t>(n));\n        svint32_t idx_vec = svindex_s32(static_cast<int32_t>(i), 1);\n        svint32_t val_vec = svmad_n_s32_z(pg, idx_vec, 2, n);\n        svst1_s32(pg, &res[i], val_vec);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_110_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> make_a_pile_simd(int n) {\n    if (n <= 0) {\n        return {};\n    }\n    \n    std::vector<int> res(n);\n    int *res_data = res.data();\n    uint32_t i = 0;\n    svint32_t base_vec = svdup_n_s32(n);\n    svint32_t step_vec = svdup_n_s32(2);\n    uint32_t vl = svcntw();\n\n    while (i < (uint32_t)n) {\n        svbool_t pg = svwhilelt_b32(i, (uint32_t)n);\n        svint32_t idx_vec = svindex_s32(i, 1);\n        svint32_t val_vec = svmla_s32_z(pg, base_vec, idx_vec, step_vec);\n        svst1_s32(pg, res_data + i, val_vec);\n        i += vl;\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "To solve this problem, we need to compute the average of integers from `n` to `m` inclusive, round it down to the nearest integer, and convert it to a binary string. If `n` is greater than `m`, we return \"-1\". The solution leverages ARM's Scalable Vector Extension (SVE) intrinsics for parallelism, even though the problem is inherently scalar, to meet the requirement of using SVE for computation.\n\n### Approach\n1. **Check Validity**: If `n` is greater than `m`, return \"-1\" immediately.\n2. **Handle Addition and Division**: Convert `n` and `m` to unsigned 64-bit integers to prevent overflow during addition. Use SVE intrinsics to perform the addition and right shift (division by 2) in parallel.\n3. **Extract Result**: Extract the resulting average value from the SVE vector.\n4. **Binary Conversion**: Convert the average value to a binary string by repeatedly dividing the value by 2 and appending the remainder to the result string.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    uint64_t un = static_cast<uint64_t>(n);\n    uint64_t um = static_cast<uint64_t>(m);\n    svuint64_t v_n = svdup_u64(un);\n    svuint64_t v_m = svdup_u64(um);\n    svuint64_t v_sum = svadd_u64_z(svptrue_b64(), v_n, v_m);\n    svuint64_t v_avg = svlsr_u64_z(svptrue_b64(), v_sum, 1);\n    uint64_t avg_val = svlastb_u64(svptrue_b64(), v_avg);\n    \n    if (avg_val == 0) {\n        return \"0\";\n    }\n    std::string binary;\n    while (avg_val != 0) {\n        binary = static_cast<char>('0' + (avg_val & 1)) + binary;\n        avg_val >>= 1;\n    }\n    return binary;\n}\n```\n\n### Explanation\n1. **Validity Check**: The function first checks if `n` is greater than `m`. If so, it returns \"-1\" as specified.\n2. **Unsigned Conversion**: To handle large values and avoid overflow during addition, `n` and `m` are converted to 64-bit unsigned integers.\n3. **SVE Operations**: \n   - `svdup_u64` duplicates the scalar values into SVE vectors.\n   - `svadd_u64_z` adds the two vectors element-wise.\n   - `svlsr_u64_z` performs a logical right shift by 1 on each element, effectively dividing by 2.\n   - `svlastb_u64` extracts the last element of the resulting vector, which is the average value.\n4. **Binary Conversion**: The average value is converted to a binary string by repeatedly checking the least significant bit and shifting the value right until it becomes zero. The resulting string is built by prepending each bit to the string.\n\nThis approach efficiently computes the required average using SVE intrinsics for parallel operations and handles the binary conversion in a straightforward manner. The solution adheres to the problem constraints and leverages SVE as required."}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t count = m - n + 1;\n    int64_t sum = 0;\n    uint64_t vl = svcntd();\n    int64_t i = n;\n\n    while (i <= m) {\n        svbool_t pg = svwhilelt_b64(i, m + 1);\n        svint64_t vec = svindex_s64(i, 1);\n        sum += svaddv_s64(pg, vec);\n        i += svcntp_b64(pg, pg);\n    }\n\n    int64_t avg = sum / count;\n    int64_t rem = sum % count;\n    if (rem > count / 2) {\n        avg++;\n    }\n\n    if (avg == 0) {\n        return \"0\";\n    }\n    std::string bin_str;\n    int64_t num = avg;\n    while (num) {\n        bin_str.insert(0, 1, (num & 1) ? '1' : '0');\n        num >>= 1;\n    }\n    return bin_str;\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    uint64_t total = (uint64_t)n + (uint64_t)m;\n    uint64_t avg = total >> 1;\n\n    uint64_t vl = svcntb();\n    char buffer[65] = {0};\n\n    for (uint64_t start = 0; start < 64; start += vl) {\n        svbool_t pg = svwhilelt_b8(start, 64);\n        svuint8_t idx8 = svindex_u8(start, 1);\n        svuint64_t idx64 = svreinterpret_u64(idx8);\n        svuint64_t shift_amt = svsub_u64_z(svptrue_b64(), svdup_u64(63), idx64);\n        svuint64_t shifted = svlsr_u64_z(svptrue_b64(), svdup_u64(avg), shift_amt);\n        svuint64_t low_bit = svand_n_u64_z(svptrue_b64(), shifted, 1);\n        svbool_t bit_set = svcmpne_n_u64(svptrue_b64(), low_bit, 0);\n        svuint8_t char_vec = svsel_u8(bit_set, svdup_u8('1'), svdup_u8('0'));\n        svst1_u8(pg, reinterpret_cast<uint8_t*>(buffer + start), char_vec);\n    }\n\n    int i = 0;\n    while (i < 64 && buffer[i] == '0') {\n        i++;\n    }\n    if (i == 64) {\n        return \"0\";\n    }\n    return std::string(buffer + i, 64 - i);\n}\n```"}
{"task_id": "SimdBench_111_SVE", "completion": "To solve this problem, we need to compute the average of integers from `n` to `m` (inclusive), round it to the nearest integer (with ties rounding down to the smaller integer), and convert the result to its binary representation. If `n` is greater than `m`, we return `\"-1\"`. The solution leverages Arm's Scalable Vector Extension (SVE) intrinsics for parallel processing, specifically for the binary conversion step.\n\n### Approach\n1. **Check Valid Range**: If `n` is greater than `m`, immediately return `\"-1\"`.\n2. **Compute Average**: Calculate the average using the formula `(n & m) + ((n ^ m) >> 1)`. This formula efficiently computes the floor of `(n + m) / 2` without causing overflow for large integers.\n3. **Handle Zero Case**: If the average is zero, return `\"0\"`.\n4. **Count Bits**: Determine the number of bits required to represent the average using `__builtin_clzll` (count leading zeros).\n5. **Binary Conversion with SVE**:\n   - **Vector Processing**: Use SVE to process bits in chunks. The vector length is determined by `svcntd()`, which returns the number of 64-bit elements in an SVE vector.\n   - **Bit Extraction**: For each chunk, generate the bit positions from the highest to the lowest. Extract each bit by right-shifting the average by the bit position and masking with 1.\n   - **Store Bits**: Store the extracted bits in a temporary array and append the corresponding '0' or '1' to the result string.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t avg = (n & m) + ((n ^ m) >> 1);\n    \n    if (avg == 0) {\n        return \"0\";\n    }\n    \n    int num_bits = 64 - __builtin_clzll(avg);\n    size_t vl = svcntd();\n    std::string res;\n    int remaining = num_bits;\n    int current_bit = num_bits - 1;\n\n    while (remaining > 0) {\n        size_t segment_length = (remaining < static_cast<int>(vl)) ? remaining : vl;\n        svbool_t pg = svwhilelt_b64(0, segment_length);\n        svint64_t bit_positions = svindex_s64(current_bit, -1);\n        svint64_t avg_vec = svdup_s64(avg);\n        svuint64_t shift_counts = svreinterpret_u64_s64(bit_positions);\n        svint64_t shifted = svlsr_s64_z(pg, avg_vec, shift_counts);\n        svint64_t bits = svand_s64_z(pg, shifted, svdup_s64(1));\n        uint64_t temp[100] = {0};\n        svst1_s64(pg, temp, bits);\n        for (size_t i = 0; i < segment_length; i++) {\n            res += (temp[i] ? '1' : '0');\n        }\n        current_bit -= segment_length;\n        remaining -= segment_length;\n    }\n    return res;\n}\n```\n\n### Explanation\n1. **Range Check**: The function first checks if `n` is greater than `m` and returns `\"-1\"` if true.\n2. **Average Calculation**: The average is computed using bitwise operations to avoid overflow. The formula `(n & m) + ((n ^ m) >> 1)` effectively calculates `(n + m) / 2` for non-negative integers.\n3. **Zero Handling**: If the average is zero, the binary representation is simply `\"0\"`.\n4. **Bit Counting**: The number of bits needed to represent the average is determined by subtracting the count of leading zeros from 64.\n5. **SVE Binary Conversion**:\n   - **Vector Processing**: The loop processes bits in chunks sized according to the SVE vector length.\n   - **Bit Extraction**: For each chunk, the bit positions are generated in descending order. The average is right-shifted by each bit position, and the least significant bit is isolated.\n   - **Result Construction**: The extracted bits are stored in a temporary array and converted to '0's or '1's, which are appended to the result string.\n6. **Result**: The binary string is built from the most significant bit to the least significant bit and returned.\n\nThis approach efficiently handles large integers by leveraging bitwise operations for average calculation and SVE for parallel bit extraction during binary conversion."}
{"task_id": "SimdBench_111_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n\nstd::string rounded_avg_simd(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    \n    uint64_t u_n = static_cast<uint64_t>(n);\n    uint64_t u_m = static_cast<uint64_t>(m);\n    uint64_t avg = (u_n & u_m) + ((u_n ^ u_m) >> 1);\n    \n    if (avg == 0) {\n        return \"0\";\n    }\n    \n    int num_bits = 64 - __builtin_clzll(avg);\n    svbool_t pg = svwhilelt_b64(0, num_bits);\n    svuint64_t indices = svindex_u64(0, 1);\n    svuint64_t shift_counts = svsub_n_u64_x(pg, svdup_u64(num_bits-1), indices);\n    svuint64_t avg_vec = svdup_u64(avg);\n    svuint64_t shifted = svlsr_u64_x(pg, avg_vec, shift_counts);\n    svuint64_t bits = svand_n_u64_x(pg, shifted, 1);\n    \n    uint64_t* bits_array = new uint64_t[num_bits];\n    svst1_u64(pg, bits_array, bits);\n    \n    std::string res;\n    for (int i = 0; i < num_bits; i++) {\n        res += (bits_array[i] ? '1' : '0');\n    }\n    \n    delete[] bits_array;\n    return res;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> res(n);\n    if (n <= 0) return res;\n\n    // Compute triangular numbers for all indices using SVE\n    int64_t i = 0;\n    uint64_t vl;\n    svbool_t pg;\n    do {\n        pg = svwhilelt_b32(i, n);\n        vl = svcntp_b32(svptrue_b32(), pg);\n        svint32_t vec_i = svadd_n_s32_x(pg, svindex_s32(0, 1), i+1);\n        svint32_t vec_i_plus_one = svadd_n_s32_x(pg, vec_i, 1);\n        svint32_t product = svmul_s32_x(pg, vec_i, vec_i_plus_one);\n        svint32_t triangular_vec = svasr_n_s32_x(pg, product, 1);\n        svst1_s32(pg, &res[i], triangular_vec);\n        i += vl;\n    } while (svptest_any(svptrue_b32(), pg));\n\n    // Update even indices (0-indexed odd positions) with factorial values\n    int fact = 1;\n    for (int i_int = 1; i_int <= n; i_int++) {\n        fact = (fact * i_int) % 10000;\n        if (i_int % 2 == 0) {\n            res[i_int-1] = fact;\n        }\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> func_simd(int n) {\n    if (n <= 0) {\n        return std::vector<int>();\n    }\n    std::vector<int> res(n);\n    int m_even = n / 2;\n    int m_odd = (n + 1) / 2;\n\n    if (m_even > 0) {\n        std::vector<int> A(m_even);\n        std::vector<int> F(m_even);\n        A[0] = 2;\n        if (m_even > 1) {\n            int j = 1;\n            svbool_t pg;\n            uint32_t vl = svcntw();\n            while (j < m_even) {\n                pg = svwhilelt_b32(j, m_even);\n                uint32_t active = svcntp_b32(svptrue_b32(), pg);\n                if (active == 0) break;\n                svint32_t j_vec = svadd_n_s32_x(pg, svindex_s32(0, 1), j);\n                svint32_t two_j = svlsl_n_s32_x(pg, j_vec, 1);\n                svint32_t two_j_plus1 = svadd_n_s32_x(pg, two_j, 1);\n                svint32_t two_j_plus2 = svadd_n_s32_x(pg, two_j, 2);\n                svint32_t a_val = svmul_s32_x(pg, two_j_plus1, two_j_plus2);\n                a_val = svmod_n_s32_x(pg, a_val, 10000);\n                svst1_s32(pg, &A[j], a_val);\n                j += active;\n            }\n        }\n\n        uint32_t vl = svcntw();\n        int num_chunks = (m_even + vl - 1) / vl;\n        std::vector<int> chunk_prod(num_chunks, 1);\n        std::vector<int> global_prefix(num_chunks + 1, 1);\n\n        for (int k = 0; k < num_chunks; ++k) {\n            int start = k * vl;\n            int len = std::min(static_cast<int>(vl), m_even - start);\n            int prod = 1;\n            for (int i = 0; i < len; ++i) {\n                prod = (prod * A[start + i]) % 10000;\n            }\n            chunk_prod[k] = prod;\n        }\n\n        for (int k = 0; k < num_chunks; ++k) {\n            global_prefix[k + 1] = (global_prefix[k] * chunk_prod[k]) % 10000;\n        }\n\n        for (int k = 0; k < num_chunks; ++k) {\n            int start = k * vl;\n            int len = std::min(static_cast<int>(vl), m_even - start);\n            if (len <= 0) continue;\n            int base = global_prefix[k];\n            F[start] = (base * A[start]) % 10000;\n            for (int i = 1; i < len; ++i) {\n                F[start + i] = (F[start + i - 1] * A[start + i]) % 10000;\n            }\n        }\n\n        for (int j = 0; j < m_even; ++j) {\n            res[2 * j + 1] = F[j];\n        }\n    }\n\n    if (m_odd > 0) {\n        int j = 0;\n        svbool_t pg;\n        uint32_t vl = svcntw();\n        while (j < m_odd) {\n            pg = svwhilelt_b32(j, m_odd);\n            uint32_t active = svcntp_b32(svptrue_b32(), pg);\n            if (active == 0) break;\n            svint32_t j_vec = svadd_n_s32_x(pg, svindex_s32(0, 1), j);\n            svint32_t i_vec = svadd_n_s32_x(pg, svmul_n_s32_x(pg, j_vec, 2), 1);\n            svint32_t i_plus1 = svadd_n_s32_x(pg, i_vec, 1);\n            svint32_t i_mod = svmod_n_s32_x(pg, i_vec, 20000);\n            svint32_t i_plus1_mod = svmod_n_s32_x(pg, i_plus1, 20000);\n            svint32_t P = svmul_s32_x(pg, i_mod, i_plus1_mod);\n            svint32_t T = svlsr_n_s32_x(pg, P, 1);\n            svint32_t val = svmod_n_s32_x(pg, T, 10000);\n            svst1_s32(pg, &res[2 * j], val);\n            j += active;\n        }\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> result(n, 0);\n    if (n == 0) return result;\n\n    uint32_t vl = svcntw();\n    uint32_t mod_mask_20000 = 0x4E1F; // 19999 (20000-1)\n    uint32_t mod_mask_10000 = 0x270F; // 9999 (10000-1)\n    svint32_t vmod_20000 = svdup_n_s32(mod_mask_20000);\n    svint32_t vmod_10000 = svdup_n_s32(mod_mask_10000);\n\n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t vidx_global = svindex_s32(i, 1);\n        svint32_t v_i = svadd_n_s32_x(pg, vidx_global, 1);\n\n        svint32_t v_i_odd = svand_n_s32_x(pg, v_i, 1);\n        svbool_t pg_odd = svcmpeq_n_s32(pg, v_i_odd, 1);\n\n        svint32_t v_i_mod = svand_s32_x(pg, v_i, vmod_20000);\n        svint32_t v_i1 = svadd_n_s32_x(pg, v_i, 1);\n        svint32_t v_i1_mod = svand_s32_x(pg, v_i1, vmod_20000);\n\n        svint32_t vprod = svmul_s32_x(pg, v_i_mod, v_i1_mod);\n        svint32_t vtri = svlsr_n_s32_x(pg, vprod, 1);\n        vtri = svand_s32_x(pg, vtri, vmod_10000);\n\n        svst1_s32(pg_odd, result.data() + i, vtri);\n    }\n\n    unsigned int fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = static_cast<unsigned int>((static_cast<unsigned long long>(fact) * i % 10000);\n        if (i % 2 == 0) {\n            result[i - 1] = static_cast<int>(fact);\n        }\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> res(n, 0);\n    if (n <= 0) return res;\n\n    uint64_t vl = svcntw();\n    int m_odd = (n + 1) / 2;\n\n    for (int j = 0; j < m_odd; j += vl) {\n        svbool_t pg = svwhilelt_b32(j, m_odd);\n        svint32_t j_vec = svindex_s32(j, 1);\n        svint32_t i_vec = svadd_n_s32_x(pg, svmul_n_s32_x(pg, j_vec, 2), 1);\n        svint32_t T_vec = svmul_s32_x(pg, i_vec, svasr_n_s32_x(pg, svadd_n_s32_x(pg, i_vec, 1), 1));\n        svint32_t out_index = svindex_s32(2 * j, 2);\n        svst1_scatter_index_s32(pg, &res[0], out_index, T_vec);\n    }\n\n    int m_even = n / 2;\n    if (m_even >= 1) {\n        if (n >= 2) res[1] = 2;\n        if (m_even >= 2) {\n            int len_mult = m_even - 1;\n            std::vector<int> mult(len_mult);\n            for (int k = 0; k < len_mult; k += vl) {\n                svbool_t pg = svwhilelt_b32(k, len_mult);\n                svint32_t k_vec = svindex_s32(k, 1);\n                svint32_t base1 = svadd_n_s32_x(pg, svmul_n_s32_x(pg, k_vec, 2), 3);\n                svint32_t base2 = svadd_n_s32_x(pg, base1, 1);\n                svint32_t mult_vec = svmul_s32_x(pg, base1, base2);\n                svst1_s32(pg, &mult[k], mult_vec);\n            }\n            int64_t current = 2;\n            for (int k = 0; k < len_mult; k++) {\n                current = (current * mult[k]) % 10000;\n                int output_index = 2 * (k + 1) + 1;\n                if (output_index < n) res[output_index] = (int)current;\n            }\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_112_SVE", "completion": "```cpp\n#include <vector>\n#include <arm_sve.h>\n\nstd::vector<int> func_simd(int n) {\n    std::vector<int> res(n);\n    if (n == 0) return res;\n\n    int max_fact = (n < 20) ? n : 19;\n    std::vector<int> fact(max_fact + 1);\n    if (max_fact >= 1) {\n        fact[1] = 1;\n        for (int i = 2; i <= max_fact; ++i) {\n            fact[i] = (fact[i - 1] * i) % 10000;\n        }\n    }\n\n    int num_odd = (n + 1) / 2;\n    if (num_odd > 0) {\n        int j = 0;\n        while (j < num_odd) {\n            svbool_t pg = svwhilelt_b32(j, num_odd);\n            svint32_t j_vec = svindex_s32(j, 1);\n            svint32_t t_vec = svmul_s32_x(pg, \n                svadd_s32_x(pg, svmul_n_s32_x(pg, j_vec, 2), svdup_s32(1)),\n                svadd_s32_x(pg, j_vec, svdup_s32(1)));\n            svint32_t store_index = svmul_n_s32_x(pg, j_vec, 2);\n            svst1_scatter_s32index_s32(pg, &res[0], store_index, t_vec);\n            j += svcntp_b32(pg, pg);\n        }\n    }\n\n    for (int i = 2; i <= max_fact; i += 2) {\n        res[i - 1] = fact[i];\n    }\n\n    if (n >= 20) {\n        int num_zeros = ((n - 20) / 2) + 1;\n        int j = 0;\n        while (j < num_zeros) {\n            svbool_t pg = svwhilelt_b32(j, num_zeros);\n            svint32_t indices = svindex_s32(19 + 2 * j, 2);\n            svst1_scatter_s32index_s32(pg, &res[0], indices, svdup_s32(0));\n            j += svcntp_b32(pg, pg);\n        }\n    }\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32_t even_count = 0;\n    uint32_t odd_count = 0;\n    uint32_t i = 1;\n    svbool_t pg = svwhilelt_b32_u32(i, n + 1);\n    svfloat32_t ten = svdup_f32(10.0f);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svuint32_t v_vec = svindex_u32(i, 1);\n        svuint32_t temp = v_vec;\n\n        svfloat32_t temp_f = svcvt_f32_u32_x(pg, temp);\n        svuint32_t quotient = svcvt_u32_f32_x(pg, svdiv_f32_x(pg, temp_f, ten));\n        svuint32_t d0 = svsub_u32_x(pg, temp, svmul_u32_x(pg, quotient, svdup_u32(10)));\n        temp = quotient;\n\n        temp_f = svcvt_f32_u32_x(pg, temp);\n        quotient = svcvt_u32_f32_x(pg, svdiv_f32_x(pg, temp_f, ten));\n        svuint32_t d1 = svsub_u32_x(pg, temp, svmul_u32_x(pg, quotient, svdup_u32(10)));\n        temp = quotient;\n\n        temp_f = svcvt_f32_u32_x(pg, temp);\n        quotient = svcvt_u32_f32_x(pg, svdiv_f32_x(pg, temp_f, ten));\n        svuint32_t d2 = svsub_u32_x(pg, temp, svmul_u32_x(pg, quotient, svdup_u32(10)));\n        temp = quotient;\n\n        temp_f = svcvt_f32_u32_x(pg, temp);\n        quotient = svcvt_u32_f32_x(pg, svdiv_f32_x(pg, temp_f, ten));\n        svuint32_t d3 = svsub_u32_x(pg, temp, svmul_u32_x(pg, quotient, svdup_u32(10)));\n\n        svuint32_t rev0 = d0;\n        svuint32_t rev1 = svmla_u32_x(pg, d0, svdup_u32(10), d1);\n        svuint32_t rev2 = svmla_u32_x(pg, svmla_u32_x(pg, d0, svdup_u32(100), d1), svdup_u32(10), d2);\n        svuint32_t rev3 = svmla_u32_x(pg, svmla_u32_x(pg, svmla_u32_x(pg, d0, svdup_u32(1000), d1), svdup_u32(100), d2), svdup_u32(10), d3);\n\n        svbool_t cond1 = svcmpge_u32(pg, v_vec, svdup_u32(10));\n        svbool_t cond2 = svcmpge_u32(pg, v_vec, svdup_u32(100));\n        svbool_t cond3 = svcmpge_u32(pg, v_vec, svdup_u32(1000));\n\n        svuint32_t num_digits = svadd_u32_x(pg, \n                               svadd_u32_x(pg, \n                                   svadd_u32_x(pg, svdup_u32(1), \n                                   svsel_u32(cond1, svdup_u32(1), svdup_u32(0))),\n                               svsel_u32(cond2, svdup_u32(1), svdup_u32(0)));\n        num_digits = svadd_u32_x(pg, num_digits, svsel_u32(cond3, svdup_u32(1), svdup_u32(0)));\n\n        svuint32_t rev = rev0;\n        rev = svsel_u32(svcmp_eq_u32(pg, num_digits, svdup_u32(2)), rev1, rev);\n        rev = svsel_u32(svcmp_eq_u32(pg, num_digits, svdup_u32(3)), rev2, rev);\n        rev = svsel_u32(svcmp_eq_u32(pg, num_digits, svdup_u32(4)), rev3, rev);\n\n        svbool_t is_pal = svcmpeq_u32(pg, rev, v_vec);\n        svbool_t is_even = svcmpeq_u32(pg, svand_u32_x(pg, v_vec, svdup_u32(1)), svdup_u32(0));\n        svbool_t is_odd = svcmpne_u32(pg, svand_u32_x(pg, v_vec, svdup_u32(1)), svdup_u32(0));\n\n        svbool_t even_pal = svand_b_z(pg, is_pal, is_even);\n        svbool_t odd_pal = svand_b_z(pg, is_pal, is_odd);\n\n        even_count += svcntp_b32(pg, even_pal);\n        odd_count += svcntp_b32(pg, odd_pal);\n\n        i += svcntw();\n        pg = svwhilelt_b32_u32(i, n + 1);\n    }\n\n    return {static_cast<int>(even_count), static_cast<int>(odd_count)};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "To solve this problem, we need to count the number of even and odd integer palindromes within the range [1, n]. A palindrome is a number that reads the same forwards and backwards. The solution leverages Arm's Scalable Vector Extension (SVE) intrinsics to parallelize the counting process efficiently.\n\n### Approach\n1. **Precompute Reversed Numbers**: For each number from 1 to 1024 (since n can be up to 1024), precompute its reversed form. For example, the reversed form of 12 is 21, and the reversed form of 10 is 1.\n2. **SVE Vector Processing**: Process numbers in parallel using SVE vectors. For each batch of numbers:\n   - **Gather Reversed Numbers**: Use SVE gather instructions to load the precomputed reversed numbers for the current batch of indices.\n   - **Check Palindromes**: Compare each number in the batch with its reversed form to determine if it is a palindrome.\n   - **Check Parity**: Determine if each palindrome is even or odd by checking the least significant bit.\n   - **Count Palindromes**: Use SVE predicate operations to count the number of even and odd palindromes in the active lanes of the vector.\n3. **Aggregate Results**: Sum the counts of even and odd palindromes across all batches to get the final result.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n#include <cstdlib>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint32_t rev_table[1025] = {0}; // 0-indexed, indices 1 to 1024 are used\n\n    for (int i = 1; i <= 1024; ++i) {\n        int t = i;\n        int r = 0;\n        while (t != 0) {\n            r = r * 10 + (t % 10);\n            t /= 10;\n        }\n        rev_table[i] = r;\n    }\n\n    uint32_t even_count = 0;\n    uint32_t odd_count = 0;\n\n    uint32_t vl = svcntw();\n    uint32_t i = 1;\n    svbool_t all_true = svptrue_b32();\n\n    while (i <= (uint32_t)n) {\n        svuint32_t indices = svindex_u32(i, 1);\n        svbool_t pg = svcmple_n_u32(all_true, indices, n);\n\n        svuint32_t rev_vec = svld1_gather_u32index_u32(pg, rev_table, indices);\n\n        svbool_t is_palindrome = svcmpeq_u32(pg, indices, rev_vec);\n        svbool_t is_even = svcmpeq_n_u32(pg, svand_n_u32_x(pg, indices, 1), 0);\n\n        svbool_t even_pal = svand_b_z(pg, is_even, is_palindrome);\n        svbool_t odd_pal = svand_b_z(pg, svnot_b_z(pg, is_even), is_palindrome);\n\n        even_count += svcntp_b32(pg, even_pal);\n        odd_count += svcntp_b32(pg, odd_pal);\n\n        i += vl;\n    }\n\n    std::vector<int> result;\n    result.push_back(static_cast<int>(even_count));\n    result.push_back(static_cast<int>(odd_count));\n    return result;\n}\n```\n\n### Explanation\n1. **Precomputation**: The `rev_table` array stores the reversed form of each number from 1 to 1024. For example, `rev_table[10]` is 1, as reversing 10 gives 01, which is 1.\n2. **Vector Processing**: The loop processes numbers in batches, where each batch size is determined by the SVE vector length (`svcntw()`). For each batch:\n   - **Indices**: Generate consecutive numbers starting from `i` using `svindex_u32`.\n   - **Active Lanes**: Create a predicate (`pg`) to mask lanes that exceed `n`.\n   - **Reversed Numbers**: Gather the precomputed reversed numbers for the current indices.\n   - **Palindrome Check**: Compare each number with its reversed form to identify palindromes.\n   - **Parity Check**: Determine if a palindrome is even or odd by checking the least significant bit.\n   - **Counting**: Use `svcntp_b32` to count the number of active lanes that meet the criteria (even palindrome or odd palindrome).\n3. **Result Aggregation**: The counts of even and odd palindromes are accumulated and returned as a vector.\n\nThis approach efficiently parallelizes the counting process using SVE intrinsics, leveraging vector operations to handle multiple numbers simultaneously, which is particularly beneficial for larger values of `n`."}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    const int MAX_N = 1025;\n    static uint32_t rev_table[MAX_N];\n    static bool initialized = false;\n    if (!initialized) {\n        for (int i = 1; i < MAX_N; i++) {\n            int rev = 0;\n            int temp = i;\n            while (temp) {\n                rev = rev * 10 + temp % 10;\n                temp /= 10;\n            }\n            rev_table[i] = rev;\n        }\n        initialized = true;\n    }\n\n    uint64_t even_count = 0;\n    uint64_t odd_count = 0;\n    int i = 1;\n    svbool_t all_true = svptrue_b32();\n\n    while (i <= n) {\n        svbool_t pg = svwhilelt_b32_s32(i, n + 1);\n        svuint32_t indices = svindex_u32(i, 1);\n        svuint32_t rev_vec = svld1_gather_u32index_u32(pg, rev_table, indices);\n        svbool_t pal_pred = svcmpeq_u32(pg, indices, rev_vec);\n        svuint32_t lsb = svand_u32_x(pal_pred, indices, 1);\n        svbool_t even_pred = svcmpeq_u32(pal_pred, lsb, 0);\n        svbool_t odd_pred = svcmpne_u32(pal_pred, lsb, 0);\n        even_count += svcntp_b32(all_true, even_pred);\n        odd_count += svcntp_b32(all_true, odd_pred);\n        uint64_t vl = svcntp_b32(pg, pg);\n        i += vl;\n    }\n\n    return {(int)even_count, (int)odd_count};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint64_t total_even = 0;\n    uint64_t total_odd = 0;\n    int i = 1;\n    svint32_t one = svdup_s32(1);\n    svint32_t ten = svdup_s32(10);\n    svint32_t hundred = svdup_s32(100);\n    svint32_t thousand = svdup_s32(1000);\n    svint32_t ten_thousand = svdup_s32(10000);\n\n    while (i <= n) {\n        svbool_t pg = svwhilelt_b32_s32(i, n + 1);\n        svint32_t vec = svindex_s32(i, 1);\n\n        svint32_t q1 = svdiv_s32_z(pg, vec, ten);\n        svint32_t d0 = svmls_s32_z(pg, vec, q1, ten);\n\n        svint32_t q2 = svdiv_s32_z(pg, q1, ten);\n        svint32_t d1 = svmls_s32_z(pg, q1, q2, ten);\n\n        svint32_t q3 = svdiv_s32_z(pg, q2, ten);\n        svint32_t d2 = svmls_s32_z(pg, q2, q3, ten);\n\n        svint32_t q4 = svdiv_s32_z(pg, q3, ten);\n        svint32_t d3 = svmls_s32_z(pg, q3, q4, ten);\n\n        svbool_t mask1 = svcmplt_s32(pg, vec, ten);\n        svbool_t mask2 = svand_b_z(pg, svcmpge_s32(pg, vec, ten), svcmplt_s32(pg, vec, hundred));\n        svbool_t mask3 = svand_b_z(pg, svcmpge_s32(pg, vec, hundred), svcmplt_s32(pg, vec, thousand));\n        svbool_t mask4 = svcmpge_s32(pg, vec, thousand);\n\n        svbool_t cond2 = svcmpeq_s32(pg, d0, d1);\n        svbool_t cond3 = svcmpeq_s32(pg, d0, d2);\n        svbool_t cond4a = svcmpeq_s32(pg, d0, d3);\n        svbool_t cond4b = svcmpeq_s32(pg, d1, d2);\n        svbool_t cond4 = svand_b_z(pg, cond4a, cond4b);\n\n        svbool_t pal_mask = mask1;\n        pal_mask = svorr_b_z(pg, pal_mask, svand_b_z(pg, mask2, cond2));\n        pal_mask = svorr_b_z(pg, pal_mask, svand_b_z(pg, mask3, cond3));\n        pal_mask = svorr_b_z(pg, pal_mask, svand_b_z(pg, mask4, cond4));\n\n        svint32_t last_bit = svand_s32_z(pg, vec, one);\n        svbool_t even_mask = svcmpeq_s32(pg, last_bit, svdup_s32(0));\n        svbool_t odd_mask = svcmpeq_s32(pg, last_bit, one);\n\n        svbool_t even_pal = svand_b_z(pg, pal_mask, even_mask);\n        svbool_t odd_pal = svand_b_z(pg, pal_mask, odd_mask);\n\n        total_even += svcntp_b32(pg, even_pal);\n        total_odd += svcntp_b32(pg, odd_pal);\n\n        i += svcntw();\n    }\n\n    return {static_cast<int>(total_even), static_cast<int>(total_odd)};\n}\n```"}
{"task_id": "SimdBench_113_SVE", "completion": "To solve this problem, we need to count the number of even and odd integer palindromes within the range [1, n] inclusive. The solution leverages the Scalable Vector Extension (SVE) for Arm to efficiently process the range in chunks determined by the hardware's vector length. Although the digit reversal is performed in scalar within each chunk, the loop control is vectorized using SVE intrinsics to step through the range in increments of the vector length.\n\n### Approach\n1. **Problem Analysis**: The task involves checking each number from 1 to n to determine if it is a palindrome. A number is a palindrome if it reads the same forwards and backwards. Additionally, we categorize palindromic numbers as even or odd based on their parity.\n2. **SVE Utilization**: The solution uses SVE to determine the active processing lanes for each iteration. The loop steps through the range [1, n] in chunks where each chunk's size is determined by the hardware's vector length. This allows the loop to adapt to different vector lengths dynamically.\n3. **Digit Reversal**: For each number in the current chunk, the solution reverses its digits using a scalar method. The reversed number is compared to the original to check for palindromic property.\n4. **Counting Palindromes**: For each identified palindrome, the solution checks its parity (even or odd) and increments the respective counter.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> even_odd_palindrome_simd(int n) {\n    uint64_t even_count = 0;\n    uint64_t odd_count = 0;\n    uint16_t i = 1;\n    svbool_t pg = svwhilelt_b16(i, static_cast<uint16_t>(n + 1));\n    while (svptest_any(svptrue_b16(), pg)) {\n        uint64_t vl = svcntp_b16(pg, pg);\n        for (uint16_t j = 0; j < vl; j++) {\n            uint16_t x = i + j;\n            uint16_t reversed = 0;\n            uint16_t temp = x;\n            while (temp != 0) {\n                reversed = reversed * 10 + temp % 10;\n                temp = temp / 10;\n            }\n            if (reversed == x) {\n                if (x % 2 == 0) {\n                    even_count++;\n                } else {\n                    odd_count++;\n                }\n            }\n        }\n        i += vl;\n        pg = svwhilelt_b16(i, static_cast<uint16_t>(n + 1));\n    }\n    return {static_cast<int>(even_count), static_cast<int>(odd_count)};\n}\n```\n\n### Explanation\n1. **Initialization**: The function initializes counters for even (`even_count`) and odd (`odd_count`) palindromic numbers.\n2. **Loop Control**: The loop starts with `i = 1` and uses the SVE intrinsic `svwhilelt_b16` to create a predicate (`pg`) that identifies active lanes (numbers from `i` to `n` inclusive). The loop continues as long as there are active lanes.\n3. **Vector Length Handling**: For each iteration, the number of active lanes (`vl`) is determined using `svcntp_b16`. This value dictates the chunk size processed in the current iteration.\n4. **Digit Reversal and Palindrome Check**: For each number in the current chunk, the digits are reversed using modulo and division operations. If the reversed number matches the original, it is a palindrome.\n5. **Parity Check**: Each identified palindrome is checked for even or odd parity, and the respective counter is incremented.\n6. **Update and Termination**: After processing a chunk, `i` is incremented by the vector length (`vl`), and the predicate `pg` is updated for the next chunk. The loop terminates when all numbers from 1 to `n` are processed.\n7. **Result Compilation**: The counts of even and odd palindromic numbers are returned as a vector.\n\nThis approach efficiently processes the range using SVE for loop control, ensuring adaptability to different vector lengths while performing the digit reversal and parity checks in scalar within each chunk."}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    if (n.empty()) {\n        return 0;\n    }\n    int count = 0;\n    int len = n.size();\n    int vl = svcntw();\n    const uint32_t magic = 3435973837;\n\n    for (int i = 0; i < len; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t v = svld1_s32(pg, &n[i]);\n        svint32_t abs_v = svabs_s32_z(pg, v);\n        svint32_t sum_digits = svdup_s32(0);\n        svint32_t msd = svdup_s32(0);\n        svint32_t temp = abs_v;\n        svbool_t pg_active = svcmpne(pg, temp, 0);\n\n        for (int j = 0; j < 10; j++) {\n            if (svcntp_b32(svptrue_b32(), pg_active) == 0) {\n                break;\n            }\n            svuint32_t u_temp = svreinterpret_u32_s32(temp);\n            svuint32_t hi = svmulh_u32_x(pg_active, u_temp, svdup_u32(magic));\n            svuint32_t quotient = svlsr_x(pg_active, hi, 3);\n            svuint32_t digit = svsub_x(pg_active, u_temp, svmul_x(pg_active, quotient, 10));\n            sum_digits = svadd_s32_m(pg_active, sum_digits, svreinterpret_s32_u32(digit));\n            svbool_t p_small = svcmplt(pg_active, temp, svdup_s32(10));\n            msd = svsel_s32(p_small, temp, msd);\n            temp = svreinterpret_s32_u32(quotient);\n            pg_active = svcmpne(pg_active, temp, 0);\n        }\n\n        svbool_t p_neg = svcmplt(pg, v, 0);\n        svint32_t adjusted = svsub_s32_x(pg, sum_digits, svmul_s32_x(pg, msd, 2));\n        svint32_t total = svsel_s32(p_neg, adjusted, sum_digits);\n        svbool_t p_gt0 = svcmpgt(pg, total, 0);\n        count += svcntp_b32(pg, p_gt0);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    size_t i = 0;\n    int vl = svcntw();\n    svuint32_t ten = svdup_u32(10);\n    while (i < n.size()) {\n        svbool_t pg = svwhilelt_b32(i, n.size());\n        svint32_t vec = svld1_s32(pg, &n[i]);\n        svint32_t abs_vec = svabs_s32_z(pg, vec);\n        svbool_t neg_mask = svcmplt_s32(pg, vec, 0);\n        svuint32_t remaining = svreinterpret_u32(abs_vec);\n        svuint32_t total_digits = svdup_u32(0);\n        svuint32_t msd = svdup_u32(0);\n        \n        for (int j = 0; j < 10; j++) {\n            svuint32_t next_remaining = svdiv_u32_z(pg, remaining, ten);\n            svuint32_t digit = svmls_u32_z(pg, remaining, next_remaining, ten);\n            total_digits = svadd_u32_z(pg, total_digits, digit);\n            svbool_t msd_update = svcmpeq_u32(pg, next_remaining, 0);\n            msd = svsel_u32(msd_update, digit, msd);\n            remaining = next_remaining;\n        }\n        \n        svint32_t total_signed = svreinterpret_s32(total_digits);\n        svint32_t msd_signed = svreinterpret_s32(msd);\n        svint32_t adjustment = svmul_s32_z(pg, msd_signed, 2);\n        total_signed = svsub_s32_m(neg_mask, total_signed, adjustment);\n        \n        svbool_t cond = svcmpgt_s32(pg, total_signed, 0);\n        count += svcntp_b32(pg, cond);\n        i += vl;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "To solve this problem, we need to count the number of elements in a vector of integers where the sum of their signed digits is greater than zero. The signed digits of a number are defined such that for negative numbers, the most significant digit is negative, while the rest are positive. For example, the number -123 has signed digits -1, 2, and 3, summing to 4.\n\n### Approach\n1. **Problem Analysis**: The task involves processing each integer in the vector to compute the sum of its signed digits. For positive numbers (non-zero), the sum of digits is always positive. For negative numbers, the sum is calculated by making the most significant digit negative and the rest positive. Zero is excluded since its digit sum is zero.\n2. **Handling Negative Numbers**: For negative numbers, we convert them to their absolute values and then compute the sum of their digits. The most significant digit is then subtracted twice from this sum (once to negate it and once to adjust for the initial addition in the absolute sum).\n3. **Vectorization with SVE**: To achieve parallelism, we use Arm's Scalable Vector Extension (SVE) intrinsics. The approach involves:\n   - **Processing Chunks**: The vector is processed in chunks that fit into SVE registers.\n   - **Positive Numbers**: Directly count positive non-zero numbers.\n   - **Negative Numbers**: Convert to 64-bit to avoid overflow, compute absolute values, and then use digit extraction via conditional subtraction for powers of 10 (from highest to lowest) to determine the most significant digit and total digit sum. The condition for counting is if `(sum - 2 * most_significant_digit) > 0`.\n4. **Efficiency**: The digit extraction for negative numbers is optimized by processing each digit place (units, tens, hundreds, etc.) in descending order, using vector operations to handle multiple numbers simultaneously.\n\n### Solution Code\n```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int len = n.size();\n    int i = 0;\n    const int64_t powers[] = {1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1};\n\n    svbool_t pg32 = svwhilelt_b32(i, len);\n    while (svptest_any(svptrue_b32(), pg32)) {\n        svint32_t vec = svld1_s32(pg32, &n[i]);\n\n        svbool_t pos_mask = svcmpgt_s32(pg32, vec, 0);\n        count += svcntp_b32(pg32, pos_mask);\n\n        svbool_t neg_mask = svcmplt_s32(pg32, vec, 0);\n        if (svptest_any(svptrue_b32(), neg_mask)) {\n            svint64_t vec64 = svsxtw_s64_z(neg_mask, vec);\n            svbool_t neg_mask64 = svunpack_b32(neg_mask);\n            svint64_t abs_neg = svabs_s64_z(neg_mask64, vec64);\n\n            svint64_t current_value = abs_neg;\n            svint64_t found = svdup_s64(0);\n            svint64_t msd = svdup_s64(0);\n            svint64_t absolute_sum = svdup_s64(0);\n\n            for (int idx = 0; idx < 10; idx++) {\n                int64_t p = powers[idx];\n                svint64_t digit = svdup_s64(0);\n                for (int j = 0; j < 9; j++) {\n                    svbool_t cond = svand_b_z(neg_mask64, svcmpge_s64(neg_mask64, current_value, p));\n                    digit = svadd_s64_z(cond, digit, 1);\n                    current_value = svsub_s64_z(cond, current_value, p);\n                }\n                svbool_t is_first = svand_b_z(neg_mask64, svcmpeq_s64(neg_mask64, found, 0));\n                svbool_t digit_non_zero = svcmpne_s64(neg_mask64, digit, 0);\n                svbool_t set_msd = svand_b_z(neg_mask64, is_first, digit_non_zero);\n                msd = svsel_s64(set_msd, digit, msd);\n                found = svsel_s64(set_msd, svdup_s64(1), found);\n                absolute_sum = svadd_s64_z(neg_mask64, absolute_sum, digit);\n            }\n\n            svint64_t condition_value = svsub_s64_z(neg_mask64, absolute_sum, svmul_s64_z(neg_mask64, msd, 2));\n            svbool_t cond_neg = svcmpgt_s64(neg_mask64, condition_value, 0);\n            count += svcntp_b64(cond_neg);\n        }\n\n        i += svcntw();\n        pg32 = svwhilelt_b32(i, len);\n    }\n    return count;\n}\n```\n\n### Explanation\n1. **Initialization**: The function initializes the count of valid numbers and processes the vector in chunks using SVE predicates to handle varying vector lengths.\n2. **Positive Numbers**: Positive non-zero numbers are directly counted using a mask that identifies them.\n3. **Negative Numbers**:\n   - **Conversion and Absolute Value**: Negative numbers are sign-extended to 64-bit to avoid overflow, and their absolute values are computed.\n   - **Digit Extraction**: For each negative number, digits are extracted by repeatedly subtracting the highest possible power of 10 (from 10^9 down to 1). This identifies each digit and updates the most significant digit encountered.\n   - **Sum Calculation**: The sum of all digits is computed. The condition `(sum - 2 * most_significant_digit) > 0` checks if the signed digit sum is positive.\n4. **Counting Valid Numbers**: The count of valid negative numbers meeting the condition is added to the total count.\n5. **Efficiency**: The use of SVE intrinsics ensures that multiple numbers are processed in parallel, leveraging vector operations for efficiency, especially in the digit extraction and condition checking steps. The solution efficiently handles edge cases, including the most negative integer, by using 64-bit arithmetic."}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nint count_nums_simd(std::vector<int> n) {\n    int64_t len = n.size();\n    if (len == 0) return 0;\n    int64_t total_count = 0;\n    int64_t i = 0;\n    const uint64_t vl = svcntw();\n    \n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t v = svld1_s32(pg, &n[i]);\n        \n        svbool_t is_int_min = svcmpeq(pg, v, svdup_n_s32(INT_MIN));\n        svint32_t v_abs = svabs_s32_z(pg, v);\n        v_abs = svsel(is_int_min, svdup_n_s32(0), v_abs);\n        svuint32_t abs_n = svreinterpret_u32_s32(v_abs);\n        abs_n = svsel(is_int_min, svdup_n_u32(2147483648u), abs_n);\n        \n        svuint32_t s = svdup_n_u32(0);\n        svuint32_t msd = svdup_n_u32(0);\n        svuint32_t current = abs_n;\n        \n        for (int j = 0; j < 10; j++) {\n            svbool_t pg_active = svcmpne(pg, current, 0);\n            if (svcntp(pg_active) == 0) break;\n            \n            svuint64_t current_wide = svcvt_u64_z(pg_active, current);\n            svuint64_t multiplier = svdup_n_u64(0xCCCCCCCD);\n            svuint64_t product = svmul_u64_z(pg_active, current_wide, multiplier);\n            svuint64_t shifted = svlsr_x(pg_active, product, 35);\n            svuint32_t new_current = svcvt_u32_z(pg_active, shifted);\n            svuint32_t digit = svsub_u32_z(pg_active, current, svmul_n_u32_z(pg_active, new_current, 10));\n            \n            s = svadd_m(pg_active, s, digit);\n            svbool_t pg_digit_nonzero = svcmpne(pg_active, digit, 0);\n            msd = svsel(pg_digit_nonzero, digit, msd);\n            current = new_current;\n        }\n        \n        svbool_t pg_pos = svcmpgt(pg, v, 0);\n        svbool_t pg_neg = svcmplt(pg, v, 0);\n        svuint32_t twice_msd = svmul_n_u32_z(pg, msd, 2);\n        svbool_t pg_neg_cond = svcmpgt(pg_neg, s, twice_msd);\n        \n        svuint32_t count_vec = svdup_n_u32(0);\n        count_vec = svsel(pg_pos, svdup_n_u32(1), count_vec);\n        count_vec = svsel(pg_neg_cond, svdup_n_u32(1), count_vec);\n        \n        total_count += svaddv_u32(pg, count_vec);\n        i += vl;\n    }\n    \n    return total_count;\n}\n```"}
{"task_id": "SimdBench_114_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint count_nums_simd(std::vector<int> n) {\n    int count = 0;\n    int len = n.size();\n    if (len == 0) return 0;\n\n    uint32_t bases[] = {1000000000, 100000000, 10000000, 1000000, 100000, 10000, 1000, 100, 10, 1};\n    uint32_t vl = svcntw();\n    int i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svint32_t input = svld1_s32(pg, &n[i]);\n\n        svbool_t neg = svcmplt_s32(pg, input, 0);\n        svuint32_t abs_val = svreinterpret_u32_s32(svabs_s32_z(pg, input));\n\n        svuint32_t digit_sum = svdup_u32_z(pg, 0);\n        svuint32_t first_digit = svdup_u32_z(pg, 0);\n        svbool_t found = svpfalse_b();\n\n        for (int j = 0; j < 10; j++) {\n            uint32_t base_val = bases[j];\n            svint32_t q_signed = svdiv_n_s32_z(pg, svreinterpret_s32_u32(abs_val), base_val);\n            svuint32_t q = svreinterpret_u32_s32(q_signed);\n            svuint32_t r = svmls_n_u32_z(pg, abs_val, q, base_val);\n\n            digit_sum = svadd_u32_z(pg, digit_sum, q);\n\n            svbool_t q_nonzero = svcmpne_n_u32(pg, q, 0);\n            svbool_t new_found = svand_b_z(pg, q_nonzero, svnot_b_z(pg, found));\n            first_digit = svsel(new_found, q, first_digit);\n            found = svorr_b_z(pg, found, new_found);\n\n            abs_val = r;\n        }\n\n        svint32_t adjusted_sum = svreinterpret_s32_u32(digit_sum);\n        svint32_t twice_first = svmul_n_s32_z(pg, svreinterpret_s32_u32(first_digit), 2);\n        adjusted_sum = svsub_s32_m(neg, adjusted_sum, twice_first);\n\n        svbool_t p_gt0 = svcmpgt_n_s32(pg, adjusted_sum, 0);\n        count += svcntp_b32(pg, p_gt0);\n\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) \n        return true;\n\n    int count = 0;\n    int *base = arr.data();\n\n    uint64_t i = 0;\n    svbool_t pg_all = svptrue_b32();\n    while (i < n - 1) {\n        svbool_t pg = svwhilelt_b32(i, n - 1);\n        svint32_t v1 = svld1(pg, base + i);\n        svint32_t v2 = svld1(pg, base + i + 1);\n        svbool_t cmp = svcmpgt(pg, v1, v2);\n        count += svcntp_b32(pg, cmp);\n        i += svcntp_b32(pg_all, pg);\n    }\n\n    if (base[n-1] > base[0])\n        count++;\n\n    return (count <= 1);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) {\n        return true;\n    }\n    std::vector<int> temp(n + 1);\n    for (int i = 0; i < n; i++) {\n        temp[i] = arr[i];\n    }\n    temp[n] = arr[0];\n    uint64_t i = 0;\n    int count = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg) && count < 2) {\n        svint32_t current = svld1(pg, &temp[i]);\n        svint32_t next = svld1(pg, &temp[i + 1]);\n        svbool_t pgt = svcmpgt(pg, current, next);\n        count += svcntp_b32(pg, pgt);\n        uint64_t num_processed = svcntp_b32(pg, pg);\n        i += num_processed;\n        pg = svwhilelt_b32(i, n);\n    }\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    uint64_t linear_limit = n - 1;\n    svbool_t pg_linear = svwhilelt_b32(0, linear_limit);\n    svint32_t v_curr = svld1_s32(pg_linear, &arr[0]);\n    svint32_t v_next = svld1_s32(pg_linear, &arr[1]);\n\n    svbool_t cmp_gt = svcmpgt_s32(pg_linear, v_curr, v_next);\n    uint64_t count = svcntp_b32(pg_linear, cmp_gt);\n\n    if (arr[n-1] > arr[0]) {\n        count++;\n    }\n\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool move_one_ball_simd(std::vector<int> arr) {\n    int n = arr.size();\n    if (n <= 1) \n        return true;\n\n    int* base = arr.data();\n    uint64_t i = 0;\n    uint64_t count = 0;\n    uint64_t limit = n - 1;\n\n    while (i < limit) {\n        svbool_t pg = svwhilelt_b32(i, limit);\n        svint32_t v1 = svld1(pg, base + i);\n        svint32_t v2 = svld1(pg, base + i + 1);\n        svbool_t cmp = svcmpgt(pg, v1, v2);\n        count += svcntp_b32(pg, cmp);\n        i += svcntw();\n    }\n\n    if (arr[n - 1] > arr[0]) \n        count++;\n\n    return (count <= 1);\n}\n```"}
{"task_id": "SimdBench_115_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool move_one_ball_simd(std::vector<int> arr) {\n    if (arr.empty()) \n        return true;\n    size_t n = arr.size();\n    if (n == 1)\n        return true;\n\n    uint64_t count = 0;\n    uint64_t i = 0;\n    svbool_t pg;\n    while (i < n - 1) {\n        pg = svwhilelt_b32(i, n - 1);\n        svint32_t v1 = svld1(pg, arr.data() + i);\n        svint32_t v2 = svld1(pg, arr.data() + i + 1);\n        svbool_t cmp = svcmpgt(pg, v1, v2);\n        count += svcntp_b32(pg, cmp);\n        i += svcntp_b32(pg, pg);\n    }\n\n    if (arr[n - 1] > arr[0])\n        count++;\n\n    return count <= 1;\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    auto count_evens = [](const std::vector<int>& v) -> uint64_t {\n        uint64_t cnt = 0;\n        uint64_t i = 0;\n        uint64_t n = v.size();\n        svbool_t pg = svwhilelt_b32(i, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t data = svld1_s32(pg, v.data() + i);\n            svint32_t low_bits = svand_s32_z(pg, data, svdup_n_s32(1));\n            svbool_t even_mask = svcmpeq_n_s32(pg, low_bits, 0);\n            cnt += svcntp_b32(pg, even_mask);\n            uint64_t num_in_segment = svcntp_b32(svptrue_b32(), pg);\n            i += num_in_segment;\n            pg = svwhilelt_b32(i, n);\n        }\n        return cnt;\n    };\n\n    uint64_t n1 = lst1.size();\n    uint64_t total_evens = count_evens(lst1) + count_evens(lst2);\n    if (total_evens >= n1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    uint64_t vl = svcntw();\n    uint64_t n1 = lst1.size();\n    uint64_t n2 = lst2.size();\n    uint64_t count_odd1 = 0;\n    uint64_t count_even2 = 0;\n\n    uint64_t i = 0;\n    while (i < n1) {\n        svbool_t pg = svwhilelt_b32(i, n1);\n        svint32_t data = svld1_s32(pg, &lst1[i]);\n        svint32_t low_bit = svand_s32_z(pg, data, svdup_s32(1));\n        svbool_t odd_flags = svcmpne(pg, low_bit, svdup_s32(0));\n        svuint32_t ones = svdup_u32_z(odd_flags, 1);\n        uint32_t partial = svaddv_u32(pg, ones);\n        count_odd1 += partial;\n        i += vl;\n    }\n\n    i = 0;\n    while (i < n2) {\n        svbool_t pg = svwhilelt_b32(i, n2);\n        svint32_t data = svld1_s32(pg, &lst2[i]);\n        svint32_t low_bit = svand_s32_z(pg, data, svdup_s32(1));\n        svbool_t even_flags = svcmpeq(pg, low_bit, svdup_s32(0));\n        svuint32_t ones = svdup_u32_z(even_flags, 1);\n        uint32_t partial = svaddv_u32(pg, ones);\n        count_even2 += partial;\n        i += vl;\n    }\n\n    if (count_even2 >= count_odd1) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    auto count_evens = [](const std::vector<int>& v) -> uint64_t {\n        uint64_t count = 0;\n        size_t i = 0;\n        size_t n = v.size();\n        uint64_t vl = svcntw();\n        svbool_t pg = svwhilelt_b32(i, n);\n        do {\n            svint32_t data = svld1_s32(pg, v.data() + i);\n            svint32_t low_bit = svand_s32_z(pg, data, svdup_n_s32(1));\n            svbool_t even_pred = svcmpeq_s32(pg, low_bit, svdup_n_s32(0));\n            count += svcntp_b32(pg, even_pred);\n            i += vl;\n            pg = svwhilelt_b32(i, n);\n        } while (svptest_any(svptrue_b32(), pg));\n        return count;\n    };\n\n    uint64_t total_evens = count_evens(lst1) + count_evens(lst2);\n    if (total_evens >= lst1.size()) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <string>\n#include <vector>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    auto count_evens = [](const std::vector<int>& vec) -> uint64_t {\n        uint64_t count = 0;\n        int64_t len = static_cast<int64_t>(vec.size());\n        const int32_t *data = vec.data();\n        int64_t i = 0;\n        uint64_t vl = svcntw();\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b32(i, len);\n            svint32_t input = svld1_s32(pg, data + i);\n            svint32_t mod = svand_s32_z(pg, input, svdup_n_s32(1));\n            svbool_t even_pred = svcmpeq_s32(pg, mod, 0);\n            count += svcntp_b32(pg, even_pred);\n            i += static_cast<int64_t>(vl);\n        }\n        return count;\n    };\n\n    uint64_t total_evens = count_evens(lst1) + count_evens(lst2);\n    if (total_evens >= lst1.size()) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::string myexchange_simd(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    size_t n1 = lst1.size();\n    size_t n2 = lst2.size();\n    uint64_t count_odd1 = 0;\n    uint64_t count_even2 = 0;\n    uint64_t vl = svcntw();\n    \n    uint64_t i = 0;\n    svbool_t pg;\n    for (i = 0; i < n1; ) {\n        pg = svwhilelt_b32(i, n1);\n        svint32_t data = svld1_s32(pg, &lst1[i]);\n        svint32_t low_bits = svand_s32_x(pg, data, svdup_s32(1));\n        svbool_t odd_mask = svcmpeq(pg, low_bits, svdup_s32(1));\n        count_odd1 += svcntp_b32(pg, odd_mask);\n        i += vl;\n    }\n    \n    i = 0;\n    for (i = 0; i < n2; ) {\n        pg = svwhilelt_b32(i, n2);\n        svint32_t data = svld1_s32(pg, &lst2[i]);\n        svint32_t low_bits = svand_s32_x(pg, data, svdup_s32(1));\n        svbool_t even_mask = svcmpeq(pg, low_bits, svdup_s32(0));\n        count_even2 += svcntp_b32(pg, even_mask);\n        i += vl;\n    }\n    \n    if (count_odd1 <= count_even2) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        const char* data = s.data();\n        size_t len = s.size();\n        uint64_t count = 0;\n        size_t i = 0;\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t ones = svdup_u8(1);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t input = svld1_u8(pg, (const uint8_t*)(data + i));\n            svuint8_t low_bits = svand_u8_z(pg, input, ones);\n            svbool_t odd_pred = svcmpne_n_u8(pg, low_bits, 0);\n            count += svcntp_b8(pg, odd_pred);\n            i += svcntb();\n            pg = svwhilelt_b8(i, len);\n        }\n        std::string count_str = std::to_string(count);\n        std::string base = \"the number of odd elements in the string i of the input.\";\n        std::string res_str;\n        for (char c : base) {\n            if (c == 'i') {\n                res_str += count_str;\n            } else {\n                res_str.push_back(c);\n            }\n        }\n        result.push_back(res_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        size_t len = s.length();\n        const uint8_t *ptr = reinterpret_cast<const uint8_t*>(s.data());\n        uint64_t odd_count = 0;\n        size_t i = 0;\n        const size_t vl = svcntb();\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t input = svld1_u8(pg, ptr + i);\n            svuint8_t low_bits = svand_u8_x(pg, input, svdup_u8(1));\n            svbool_t is_odd = svcmpne_u8(pg, low_bits, svdup_u8(0));\n            uint64_t n_odd = svcntp_b8(is_odd, is_odd);\n            odd_count += n_odd;\n            i += vl;\n        }\n\n        std::string count_str = std::to_string(odd_count);\n        std::string template_str = \"the number of odd elements in the string i of the input.\";\n        std::string output_str;\n        for (char c : template_str) {\n            if (c == 'i') {\n                output_str += count_str;\n            } else {\n                output_str += c;\n            }\n        }\n        result.push_back(output_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        size_t len = s.length();\n        size_t count = 0;\n        size_t i = 0;\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t chars = svldff1_u8(pg, (const uint8_t*)(s.data() + i));\n            svuint8_t last_bit = svand_u8_z(pg, chars, svdup_u8(1));\n            svbool_t odd_mask = svcmpne_n_u8(pg, last_bit, 0);\n            count += svcntp_b8(odd_mask, odd_mask);\n            i += svcntp_b8(pg, pg);\n        }\n        std::string count_str = std::to_string(count);\n        std::string base = \"the number of odd elements in the string i of the input.\";\n        std::string output;\n        for (char c : base) {\n            if (c == 'i') {\n                output += count_str;\n            } else {\n                output += c;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n#include <cstdint>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst){\n    std::vector<std::string> result_vec;\n    const std::string template_str = \"the number of odd elements in the string i of the input.\";\n\n    for (const std::string& s : lst) {\n        uint64_t count = 0;\n        size_t len = s.size();\n        size_t i = 0;\n\n        while (i < len) {\n            svbool_t pg = svwhilelt_b8(i, len);\n            svuint8_t chars = svld1_u8(pg, reinterpret_cast<const uint8_t*>(s.data() + i));\n            svuint8_t digits = svsub_u8_z(pg, chars, svdup_n_u8('0'));\n            svuint8_t mod = svand_u8_z(pg, digits, svdup_n_u8(1));\n            svbool_t odd_pred = svcmpne_n_u8(pg, mod, 0);\n            count += svcntp_b8(pg, odd_pred);\n            i += svcntb();\n        }\n\n        std::string count_str = std::to_string(count);\n        std::string new_str;\n        for (char c : template_str) {\n            if (c == 'i') {\n                new_str += count_str;\n            } else {\n                new_str.push_back(c);\n            }\n        }\n        result_vec.push_back(new_str);\n    }\n\n    return result_vec;\n}\n```"}
{"task_id": "SimdBench_117_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count_simd(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        uint64_t count = 0;\n        size_t len = s.length();\n        size_t index = 0;\n        svbool_t pg = svwhilelt_b8(index, len);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint8_t vec = svld1_u8(pg, (const uint8_t*)(s.data() + index));\n            svuint8_t low_bits = svand_x(pg, vec, 1);\n            svbool_t odd_pred = svcmpne(pg, low_bits, 0);\n            count += svcntp_b8(pg, odd_pred);\n            index += svcntb();\n            pg = svwhilelt_b8(index, len);\n        }\n        std::string base = \"the number of odd elements in the string i of the input.\";\n        std::string count_str = std::to_string(count);\n        std::string output;\n        for (char c : base) {\n            if (c == 'i') {\n                output += count_str;\n            } else {\n                output.push_back(c);\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    size_t n = nums.size();\n    if (n == 0) return 0;\n\n    std::vector<int64_t> p(n + 1);\n    p[0] = 0;\n\n    // Compute prefix sums using SVE for memory access\n    int64_t base = 0;\n    size_t i = 0;\n    svbool_t pg;\n    while (i < n) {\n        pg = svwhilelt_b64(i, n);\n        size_t active_count = svcntp_b64(pg, pg);\n        int64_t buffer[active_count];\n        svst1(pg, buffer, svld1(pg, &nums[i]));\n\n        for (size_t j = 0; j < active_count; ++j) {\n            base += buffer[j];\n            p[i + j + 1] = base;\n        }\n        i += active_count;\n    }\n\n    int64_t current_max = p[0];\n    int64_t overall_min = INT64_MAX;\n\n    // Process prefix array in chunks\n    i = 0;\n    while (i <= n) {\n        pg = svwhilelt_b64(i, n + 1);\n        size_t active_count = svcntp_b64(pg, pg);\n        int64_t buffer[active_count];\n        svst1(pg, buffer, svld1(pg, &p[i]));\n\n        for (size_t j = 0; j < active_count; ++j) {\n            if (i + j >= 1) {\n                int64_t candidate_val = buffer[j] - current_max;\n                if (candidate_val < overall_min) {\n                    overall_min = candidate_val;\n                }\n            }\n            if (buffer[j] > current_max) {\n                current_max = buffer[j];\n            }\n        }\n        i += active_count;\n    }\n\n    return overall_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t n = nums.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    std::vector<int64_t> prefix(n + 1);\n    prefix[0] = 0;\n\n    svint64_t carry = svdup_s64(0);\n    uint64_t vl = svcntd();\n    for (uint64_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svint64_t vec_nums = svld1(pg, &nums[i]);\n        svint64_t vec_scan = svscanadd(vec_nums, carry);\n        svst1(pg, &prefix[i + 1], vec_scan);\n        carry = svlasta(pg, vec_scan);\n        i += vl;\n    }\n\n    std::vector<int64_t> M(n + 1);\n    svint64_t current_max = svdup_s64(LLONG_MIN);\n    for (uint64_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svint64_t vec_prefix = svld1(pg, &prefix[i]);\n        svint64_t vec_inc = svscanmax(vec_prefix, current_max);\n        svst1(pg, &M[i + 1], vec_inc);\n        current_max = svlasta(pg, vec_inc);\n        i += vl;\n    }\n\n    int64_t global_min = LLONG_MAX;\n    for (uint64_t j = 1; j <= n; ) {\n        svbool_t pg = svwhilelt_b64(j, n + 1);\n        svint64_t vec_prefix_j = svld1(pg, &prefix[j]);\n        svint64_t vec_M_j = svld1(pg, &M[j]);\n        svint64_t vec_candidate = svsub_z(pg, vec_prefix_j, vec_M_j);\n        int64_t min_in_vec = svminv(pg, vec_candidate);\n        if (min_in_vec < global_min) {\n            global_min = min_in_vec;\n        }\n        j += vl;\n    }\n\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t n = nums.size();\n    if (n == 0) return 0;\n    std::vector<int64_t> prefix(n + 1);\n    prefix[0] = 0;\n    for (int64_t i = 0; i < n; i++) {\n        prefix[i + 1] = prefix[i] + nums[i];\n    }\n\n    int64_t global_max_prefix = prefix[0];\n    int64_t min_sum = INT64_MAX;\n    int64_t* p = prefix.data() + 1;\n    uint64_t n_remaining = n;\n\n    while (n_remaining > 0) {\n        svbool_t pg = svwhilelt_b64((uint64_t)0, n_remaining);\n        uint64_t active_count = svcntp_b64(pg, pg);\n        svint64_t vec = svld1(pg, p);\n        int64_t tmp[256];\n        svst1(pg, tmp, vec);\n\n        for (uint64_t i = 0; i < active_count; i++) {\n            int64_t cur = tmp[i];\n            int64_t candidate = cur - global_max_prefix;\n            if (candidate < min_sum) {\n                min_sum = candidate;\n            }\n            if (cur > global_max_prefix) {\n                global_max_prefix = cur;\n            }\n        }\n\n        p += active_count;\n        n_remaining -= active_count;\n    }\n\n    return min_sum;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    if (nums.empty()) {\n        return 0;\n    }\n    const int64_t min_val = -9223372036854775807LL - 1;\n    struct Segment {\n        int64_t total;\n        int64_t max_prefix;\n        int64_t max_suffix;\n        int64_t max_subarray;\n    };\n\n    auto combine = [](const Segment& left, const Segment& right) -> Segment {\n        Segment res;\n        res.total = left.total + right.total;\n        if (left.max_prefix > left.total + right.max_prefix) {\n            res.max_prefix = left.max_prefix;\n        } else {\n            res.max_prefix = left.total + right.max_prefix;\n        }\n        if (right.max_suffix > right.total + left.max_suffix) {\n            res.max_suffix = right.max_suffix;\n        } else {\n            res.max_suffix = right.total + left.max_suffix;\n        }\n        res.max_subarray = left.max_subarray;\n        if (right.max_subarray > res.max_subarray) {\n            res.max_subarray = right.max_subarray;\n        }\n        int64_t candidate = left.max_suffix + right.max_prefix;\n        if (candidate > res.max_subarray) {\n            res.max_subarray = candidate;\n        }\n        return res;\n    };\n\n    auto compute_segment = [min_val](const int64_t* base, uint64_t n) -> Segment {\n        Segment seg;\n        if (n == 0) {\n            seg.total = 0;\n            seg.max_prefix = min_val;\n            seg.max_suffix = min_val;\n            seg.max_subarray = min_val;\n            return seg;\n        }\n        int64_t current_prefix = 0;\n        int64_t min_prev = 0;\n        seg.max_prefix = min_val;\n        seg.max_subarray = min_val;\n\n        for (uint64_t i = 0; i < n; ++i) {\n            current_prefix += base[i];\n            if (current_prefix > seg.max_prefix) {\n                seg.max_prefix = current_prefix;\n            }\n            int64_t candidate = current_prefix - min_prev;\n            if (candidate > seg.max_subarray) {\n                seg.max_subarray = candidate;\n            }\n            if (current_prefix < min_prev) {\n                min_prev = current_prefix;\n            }\n        }\n        seg.total = current_prefix;\n\n        int64_t current_suffix = 0;\n        seg.max_suffix = min_val;\n        for (uint64_t i = n; i > 0; ) {\n            --i;\n            current_suffix += base[i];\n            if (current_suffix > seg.max_suffix) {\n                seg.max_suffix = current_suffix;\n            }\n        }\n\n        return seg;\n    };\n\n    uint64_t n_size = nums.size();\n    uint64_t i = 0;\n    Segment total_seg;\n    bool first = true;\n    uint64_t vl = svcntd();\n    int64_t temp[32];\n\n    while (i < n_size) {\n        svbool_t pg = svwhilelt_b64(i, n_size);\n        uint64_t vl_actual = svcntp_b64(svptrue_b64(), pg);\n\n        svint64_t vec = svld1_s64(pg, &nums[i]);\n        vec = svneg_s64_z(pg, vec);\n        svst1_s64(pg, temp, vec);\n\n        Segment seg = compute_segment(temp, vl_actual);\n\n        if (first) {\n            total_seg = seg;\n            first = false;\n        } else {\n            total_seg = combine(total_seg, seg);\n        }\n\n        i += vl_actual;\n    }\n\n    return -total_seg.max_subarray;\n}\n```"}
{"task_id": "SimdBench_118_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <algorithm>\n\nint64_t minSubArraySum_simd(const std::vector<int64_t>& nums) {\n    int64_t n = nums.size();\n    if (n == 0) return 0;\n    if (n == 1) return nums[0];\n\n    std::vector<int64_t> T_curr = nums;\n    std::vector<int64_t> P_curr = nums;\n    std::vector<int64_t> S_curr = nums;\n    std::vector<int64_t> M_curr = nums;\n\n    while (n > 1) {\n        int64_t n_next = (n + 1) >> 1;\n        std::vector<int64_t> T_next(n_next);\n        std::vector<int64_t> P_next(n_next);\n        std::vector<int64_t> S_next(n_next);\n        std::vector<int64_t> M_next(n_next);\n\n        int64_t i = 0;\n        while (i < n_next) {\n            svbool_t pg = svwhilelt_b64(i, n_next);\n            uint64_t vl = svcntd();\n            svuint64_t idx = svindex_u64(i, 1);\n            svuint64_t even_idx = svlsl_x(pg, idx, 1);\n            svuint64_t odd_idx = svadd_x(pg, even_idx, 1);\n            svbool_t pg_pair = svcmplt(pg, odd_idx, n);\n\n            svint64_t T_even = svld1_gather_index(pg, T_curr.data(), even_idx);\n            svint64_t T_odd = svld1_gather_index(pg_pair, T_curr.data(), odd_idx);\n            svint64_t T_sum = svadd_x(pg_pair, T_even, T_odd);\n            svint64_t T_new = svsel(pg_pair, T_sum, T_even);\n            svst1(pg, T_next.data() + i, T_new);\n\n            svint64_t P_even = svld1_gather_index(pg, P_curr.data(), even_idx);\n            svint64_t P_odd = svld1_gather_index(pg_pair, P_curr.data(), odd_idx);\n            svint64_t P_candidate = svadd_x(pg_pair, T_even, P_odd);\n            svint64_t P_min = svmin_x(pg_pair, P_even, P_candidate);\n            svint64_t P_new = svsel(pg_pair, P_min, P_even);\n            svst1(pg, P_next.data() + i, P_new);\n\n            svint64_t S_even = svld1_gather_index(pg, S_curr.data(), even_idx);\n            svint64_t S_odd = svld1_gather_index(pg_pair, S_curr.data(), odd_idx);\n            svint64_t S_candidate = svadd_x(pg_pair, T_odd, S_even);\n            svint64_t S_min = svmin_x(pg_pair, S_odd, S_candidate);\n            svint64_t S_new = svsel(pg_pair, S_min, S_even);\n            svst1(pg, S_next.data() + i, S_new);\n\n            svint64_t M_even = svld1_gather_index(pg, M_curr.data(), even_idx);\n            svint64_t M_odd = svld1_gather_index(pg_pair, M_curr.data(), odd_idx);\n            svint64_t cross = svadd_x(pg_pair, S_even, P_odd);\n            svint64_t M_min1 = svmin_x(pg_pair, M_even, M_odd);\n            svint64_t M_min2 = svmin_x(pg_pair, M_min1, cross);\n            svint64_t M_new = svsel(pg_pair, M_min2, M_even);\n            svst1(pg, M_next.data() + i, M_new);\n\n            i += vl;\n        }\n\n        T_curr = std::move(T_next);\n        P_curr = std::move(P_next);\n        S_curr = std::move(S_next);\n        M_curr = std::move(M_next);\n        n = n_next;\n    }\n\n    return M_curr[0];\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nusing namespace std;\n\nint max_fill_simd(const vector<vector<int> > & grid, int capacity) {\n    uint64_t vl = svcntw();\n    unsigned long long total_ops = 0;\n\n    for (const auto& row : grid) {\n        int n = row.size();\n        if (n == 0) continue;\n        const int32_t* ptr = row.data();\n        uint64_t row_count = 0;\n        int i = 0;\n\n        while (i < n) {\n            svbool_t pg = svwhilelt_b32(i, n);\n            svint32_t v = svld1_s32(pg, ptr + i);\n            svbool_t non_zero = svcmpne(pg, v, 0);\n            row_count += svcntp_b32(non_zero, non_zero);\n            i += vl;\n        }\n\n        if (row_count > 0) {\n            total_ops += (row_count + capacity - 1) / capacity;\n        }\n    }\n\n    return static_cast<int>(total_ops);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    int64_t total_ops = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        const std::vector<int>& row = grid[i];\n        int n = row.size();\n        if (n == 0) {\n            continue;\n        }\n        const int* row_data = row.data();\n        uint32_t row_sum = 0;\n        int base = 0;\n        unsigned int vl = svcntw();\n        svbool_t pg = svwhilelt_b32(base, n);\n        while (svptest_any(svptrue_b8(), pg)) {\n            svuint32_t data = svld1_u32(pg, (const uint32_t*)(row_data + base));\n            uint32_t sum_part = svaddv_u32(pg, data);\n            row_sum += sum_part;\n            base += vl;\n            pg = svwhilelt_b32(base, n);\n        }\n        if (row_sum > 0) {\n            total_ops += (row_sum + capacity - 1) / capacity;\n        }\n    }\n    return (int)total_ops;\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid,int capacity){\n    if (grid.empty()) \n        return 0;\n    int nrows = grid.size();\n    int ncols = grid[0].size();\n    long long total = 0;\n\n    uint32_t vl = svcntw();\n    for (int i = 0; i < nrows; i++) {\n        const int* row_ptr = grid[i].data();\n        uint32_t row_count = 0;\n        svbool_t all_true = svptrue_b32();\n\n        int j = 0;\n        for (; j + vl <= ncols; j += vl) {\n            svint32_t v = svld1_s32(all_true, row_ptr + j);\n            svbool_t p_nonzero = svcmpne(all_true, v, 0);\n            row_count += svcntp_b32(all_true, p_nonzero);\n        }\n        if (j < ncols) {\n            svbool_t pg = svwhilelt_b32(j, ncols);\n            svint32_t v = svld1_s32(pg, row_ptr + j);\n            svbool_t p_nonzero = svcmpne(pg, v, 0);\n            row_count += svcntp_b32(pg, p_nonzero);\n        }\n\n        if (row_count > 0) {\n            total += (row_count + capacity - 1) / capacity;\n        }\n    }\n\n    return static_cast<int>(total);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_lowerings = 0;\n    int num_rows = grid.size();\n    if (num_rows == 0) {\n        return 0;\n    }\n    int num_cols = grid[0].size();\n\n    for (int r = 0; r < num_rows; r++) {\n        const std::vector<int>& row = grid[r];\n        uint32_t len = row.size();\n        if (len == 0) {\n            continue;\n        }\n        const int* data_ptr = row.data();\n        svuint32_t accumulator = svdup_u32(0);\n        uint32_t i = 0;\n        svbool_t pg = svwhilelt_b32(i, len);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t data = svld1_s32(pg, data_ptr + i);\n            svuint32_t data_u32 = svreinterpret_u32_s32(data);\n            accumulator = svadd_u32_z(pg, accumulator, data_u32);\n            uint64_t n = svcntp_b32(pg, pg);\n            i += n;\n            pg = svwhilelt_b32(i, len);\n        }\n        uint32_t total_water = svaddv_u32(svptrue_b32(), accumulator);\n        if (total_water > 0) {\n            total_lowerings += (total_water + capacity - 1) / capacity;\n        }\n    }\n    return static_cast<int>(total_lowerings);\n}\n```"}
{"task_id": "SimdBench_119_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint max_fill_simd(const std::vector<std::vector<int> > & grid, int capacity) {\n    if (grid.empty()) {\n        return 0;\n    }\n\n    uint64_t vl = svcntw();\n    uint64_t total_lowering = 0;\n\n    for (const auto& row : grid) {\n        uint64_t n = row.size();\n        if (n == 0) {\n            continue;\n        }\n\n        const uint32_t* ptr = reinterpret_cast<const uint32_t*>(row.data());\n        uint64_t i = 0;\n        uint32_t row_sum = 0;\n\n        while (i < n) {\n            svbool_t active = svwhilelt_b32(i, n);\n            svuint32_t data = svld1_u32(active, ptr + i);\n            uint32_t seg_sum = svaddv_u32(active, data);\n            row_sum += seg_sum;\n            i += vl;\n        }\n\n        if (row_sum > 0) {\n            total_lowering += (row_sum + capacity - 1) / capacity;\n        }\n    }\n\n    return static_cast<int>(total_lowering);\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    int n = lst.size();\n    int i = 0;\n    const svint16_t ones = svdup_n_s16(1);\n    while (i < n) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t data = svld1_s16(pg, &lst[i]);\n        svuint16_t lane_index = svindex_u16(0, 1);\n        uint16_t base_parity = i % 2;\n        svuint16_t lane_parity = svand_n_u16_z(pg, lane_index, 1);\n        svbool_t mask_even = svcmpeq_n_u16(pg, lane_parity, base_parity);\n        svbool_t mask_odd = svcmpne_n_s16(pg, svand_n_s16_z(pg, data, 1), 0);\n        svbool_t mask = svand_b_z(pg, mask_even, mask_odd);\n        svint16_t filtered_data = svsel_s16(mask, data, svdup_n_s16(0));\n        svint64_t dot = svdot_s64(svdup_n_s64(0), filtered_data, ones);\n        total_sum += svaddv_s64(svptrue_b64(), dot);\n        i += svcnth();\n    }\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total = 0;\n    int i = 0;\n    int n = lst.size();\n    svbool_t pg = svwhilelt_b16(i, n);\n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &lst[i]);\n        svint16_t indices = svindex_s16(i, 1);\n        svint16_t ones = svdup_n_s16(1);\n        svint16_t indices_mod = svand_s16_z(pg, indices, ones);\n        svbool_t p_even = svcmpeq_n_s16(pg, indices_mod, 0);\n        svint16_t data_mod = svand_s16_z(pg, data, ones);\n        svbool_t p_odd = svcmpne_n_s16(pg, data_mod, 0);\n        svbool_t p_combine = svand_b_z(pg, p_even, p_odd);\n        svint16_t selected = svsel_s16(p_combine, data, svdup_n_s16(0));\n        svint32_t lo = svmovlb_s32(selected);\n        svint32_t hi = svmovlt_s32(selected);\n        int32_t sum_lo = svaddv_s32(svptrue_b32(), lo);\n        int32_t sum_hi = svaddv_s32(svptrue_b32(), hi);\n        total += (int64_t)sum_lo + (int64_t)sum_hi;\n        i += svcnth();\n        pg = svwhilelt_b16(i, n);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    size_t n = lst.size();\n    if (n == 0) return 0;\n    \n    int i = 0;\n    svbool_t pg = svwhilelt_b16(i, n);\n    int64_t total = 0;\n    \n    while (svptest_any(svptrue_b16(), pg)) {\n        svint16_t data = svld1_s16(pg, &lst[i]);\n        svint16_t local_index = svindex_s16(0, 1);\n        svuint16_t mod_local = svand_n_u16_z(pg, svreinterpret_u16_s16(local_index), 1);\n        \n        int base_parity = i % 2;\n        svbool_t pg_even;\n        if (base_parity == 0) {\n            pg_even = svcmpeq_n_u16(pg, mod_local, 0);\n        } else {\n            pg_even = svcmpeq_n_u16(pg, mod_local, 1);\n        }\n        \n        svuint16_t data_u = svreinterpret_u16_s16(data);\n        svuint16_t mod_data = svand_n_u16_z(pg, data_u, 1);\n        svbool_t pg_odd = svcmpne_n_u16(pg, mod_data, 0);\n        \n        svbool_t pg_combine = svand_b_z(pg, pg_even, pg_odd);\n        svint64_t data64 = svsxth_s64_z(pg_combine, data);\n        int64_t sum_part = svaddv_s64(pg_combine, data64);\n        total += sum_part;\n        \n        i += svcnth();\n        pg = svwhilelt_b16(i, n);\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    uint64_t i = 0;\n    uint64_t n = lst.size();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        uint64_t num_active = svcntp_b16(pg, pg);\n        if (num_active == 0) break;\n\n        if (num_active % 2 == 0) {\n            svint16x2_t data2 = svld2_s16(pg, &lst[i]);\n            svint16_t even_data = svget2_s16(data2, 0);\n            uint64_t even_len = num_active / 2;\n            svbool_t pg_even = svwhilelt_b16(0, even_len);\n            svbool_t odd_mask = svcmpne_n_s16(pg_even, svand_n_s16_z(pg_even, even_data, 1), 0);\n            svint64_t extended = svsxtw_s64_z(odd_mask, even_data);\n            svbool_t pg64 = svwhilelt_b64(0, even_len);\n            int64_t seg_sum = svaddv_s64(pg64, extended);\n            total_sum += seg_sum;\n            i += num_active;\n        } else {\n            if (num_active > 1) {\n                svbool_t pg_even_len = svwhilelt_b16(i, i + num_active - 1);\n                svint16x2_t data2 = svld2_s16(pg_even_len, &lst[i]);\n                svint16_t even_data = svget2_s16(data2, 0);\n                uint64_t even_len = (num_active - 1) / 2;\n                svbool_t pg_even = svwhilelt_b16(0, even_len);\n                svbool_t odd_mask = svcmpne_n_s16(pg_even, svand_n_s16_z(pg_even, even_data, 1), 0);\n                svint64_t extended = svsxtw_s64_z(odd_mask, even_data);\n                svbool_t pg64 = svwhilelt_b64(0, even_len);\n                int64_t seg_sum = svaddv_s64(pg64, extended);\n                total_sum += seg_sum;\n            }\n            uint64_t last_index = i + num_active - 1;\n            if (last_index % 2 == 0 && (lst[last_index] % 2 != 0)) {\n                total_sum += lst[last_index];\n            }\n            i += num_active;\n        }\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_120_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint64_t solution_simd(const std::vector<int16_t>& lst) {\n    int64_t total_sum = 0;\n    size_t i = 0;\n    size_t n = lst.size();\n    size_t vl = svcntb() / sizeof(int16_t);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b16(i, n);\n        svint16_t data = svld1_s16(pg, &lst[i]);\n        svint16_t indices = svindex_s16(i, 1);\n        svint16_t mod_indices = svand_s16_z(pg, indices, svdup_s16(1));\n        svbool_t pg_even = svcmpeq_s16(pg, mod_indices, svdup_s16(0));\n        svint16_t mod_data = svand_s16_z(pg, data, svdup_s16(1));\n        svbool_t pg_odd = svcmpne_s16(pg, mod_data, svdup_s16(0));\n        svbool_t pg_combine = svand_b_z(pg, pg_even, pg_odd);\n        total_sum += svaddv_s16(pg_combine, data);\n        i += vl;\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint add_elements_simd(std::vector<int> arr, int k){\n    uint64_t n = k;\n    uint64_t i = 0;\n    svint32_t sum_vec = svdup_n_s32(0);\n    uint64_t vl = svcntw();\n\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svint32_t abs_data = svabs_s32_z(pg, data);\n        svbool_t cond = svcmplt_s32(pg, abs_data, 100);\n        svint32_t selected = svsel_s32(cond, data, svdup_n_s32(0));\n        sum_vec = svadd_s32_m(pg, sum_vec, selected);\n\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n\n    int sum = svaddv_s32(svptrue_b32(), sum_vec);\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int total_sum = 0;\n    int64_t i = 0;\n    int64_t k64 = static_cast<int64_t>(k);\n    uint64_t vl = svcntw();\n\n    while (i < k64) {\n        svbool_t pg_index = svwhilelt_b32(i, k64);\n        svint32_t data = svld1_s32(pg_index, &arr[i]);\n\n        svbool_t pg_low = svcmpge_s32(pg_index, data, -99);\n        svbool_t pg_high = svcmple_s32(pg_index, data, 99);\n        svbool_t pg_comb = svand_b_z(pg_index, pg_low, pg_high);\n\n        int32_t sum_part = svaddv_s32(pg_comb, data);\n        total_sum += sum_part;\n\n        i += vl;\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\nusing std::vector;\n\nint add_elements_simd(vector<int> arr, int k) {\n    int64_t i = 0;\n    svint32_t sum_vec = svdup_n_s32(0);\n    svbool_t pg = svwhilelt_b32_s64(i, k);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svbool_t pg_ge = svcmpge_s32(pg, data, -99);\n        svbool_t pg_le = svcmple_s32(pg, data, 99);\n        svbool_t pg_cond = svand_b_z(pg, pg_ge, pg_le);\n        svint32_t selected = svsel_s32(pg_cond, data, svdup_n_s32(0));\n        sum_vec = svadd_s32_m(pg, sum_vec, selected);\n        i += (int64_t)svcntw();\n        pg = svwhilelt_b32_s64(i, k);\n    }\n    int result = svaddv(svptrue_b32(), sum_vec);\n    return result;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint add_elements_simd(std::vector<int> arr, int k) {\n    uint64_t i = 0;\n    int total = 0;\n    const uint64_t vl = svcntw();\n\n    while (i < (uint64_t)k) {\n        svbool_t pg = svwhilelt_b32(i, (uint64_t)k);\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svint32_t abs_data = svabs_s32_z(pg, data);\n        svbool_t pg_cond = svcmplt_s32(pg, abs_data, 100);\n        svbool_t pg_combine = svand_b_z(svptrue_b8(), pg, pg_cond);\n        int32_t seg_sum = svaddv_s32(pg_combine, data);\n        total += seg_sum;\n        i += vl;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_121_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint add_elements_simd(std::vector<int> arr, int k) {\n    int total = 0;\n    int i = 0;\n    unsigned int vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, k);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        svint32_t neg99 = svdup_n_s32(-99);\n        svint32_t pos99 = svdup_n_s32(99);\n        svbool_t cond_ge = svcmpge_s32(pg, data, neg99);\n        svbool_t cond_le = svcmple_s32(pg, data, pos99);\n        svbool_t mask_cond = svand_b_z(pg, cond_ge, cond_le);\n        int32_t sum_part = svaddv_s32(mask_cond, data);\n        total += sum_part;\n        i += vl;\n        pg = svwhilelt_b32(i, k);\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) \n        return true;\n    if (n == 2) \n        return lst[0] <= lst[1];\n\n    uint64_t i = 0;\n    svbool_t violation1 = svfalse_b();\n    svbool_t violation2 = svfalse_b();\n    uint64_t vl = svcntw();\n\n    while (i < n - 1) {\n        svbool_t pg = svwhilelt_b32(i, n - 1);\n        if (svptest_any(svptrue_b32(), pg)) {\n            svint32_t v0 = svld1_s32(pg, &lst[i]);\n            svint32_t v1 = svld1_s32(pg, &lst[i + 1]);\n            svbool_t cond1 = svcmplt_s32(pg, v1, v0);\n            violation1 = svorr_b(violation1, cond1);\n\n            svbool_t pg2 = svwhilelt_b32(i, n - 2);\n            if (svptest_any(svptrue_b32(), pg2)) {\n                svint32_t v2 = svld1_s32(pg2, &lst[i + 2]);\n                svbool_t eq_ab = svcmpeq_s32(pg2, v0, v1);\n                svbool_t eq_bc = svcmpeq_s32(pg2, v1, v2);\n                svbool_t cond2 = svand_b_z(pg2, eq_ab, eq_bc);\n                violation2 = svorr_b(violation2, cond2);\n            }\n        }\n        i += vl;\n    }\n\n    if (svptest_any(svptrue_b32(), violation1)) \n        return false;\n    if (svptest_any(svptrue_b32(), violation2)) \n        return false;\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst){\n    int n = lst.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    uint64_t vl = svcntw();\n    int i = 0;\n    while (i < n - 1) {\n        svbool_t active = svwhilelt_b32(i, n - 1);\n        svint32_t current = svld1(active, lst.data() + i);\n        svint32_t next = svld1(active, lst.data() + i + 1);\n        svbool_t cmp = svcmpgt(active, current, next);\n        if (svptest_any(active, cmp)) {\n            return false;\n        }\n        i += svcntp_b32(active, active);\n    }\n\n    if (n < 3) {\n        return true;\n    }\n\n    i = 0;\n    while (i < n - 2) {\n        svbool_t active = svwhilelt_b32(i, n - 2);\n        svint32_t current = svld1(active, lst.data() + i);\n        svint32_t next1 = svld1(active, lst.data() + i + 1);\n        svint32_t next2 = svld1(active, lst.data() + i + 2);\n        svbool_t eq1 = svcmpeq(active, current, next1);\n        svbool_t eq2 = svcmpeq(active, current, next2);\n        svbool_t both = svand_z(active, eq1, eq2);\n        if (svptest_any(active, both)) {\n            return false;\n        }\n        i += svcntp_b32(active, active);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) {\n        return true;\n    }\n    if (n == 2) {\n        return lst[0] <= lst[1];\n    }\n\n    uint64_t i = 0;\n    uint64_t n_minus1 = n - 1;\n    while (i < n_minus1) {\n        svbool_t pg = svwhilelt_b32(i, n_minus1);\n        svint32_t v1 = svld1(pg, &lst[i]);\n        svint32_t v2 = svld1(pg, &lst[i + 1]);\n        svbool_t cmp = svcmpgt(pg, v1, v2);\n        if (svptest_any(pg, cmp)) {\n            return false;\n        }\n        i += svcntw();\n    }\n\n    i = 0;\n    uint64_t n_minus2 = n - 2;\n    while (i < n_minus2) {\n        svbool_t pg = svwhilelt_b32(i, n_minus2);\n        svint32_t v1 = svld1(pg, &lst[i]);\n        svint32_t v2 = svld1(pg, &lst[i + 1]);\n        svint32_t v3 = svld1(pg, &lst[i + 2]);\n        svbool_t eq1 = svcmpeq(pg, v1, v2);\n        svbool_t eq2 = svcmpeq(pg, v2, v3);\n        svbool_t both_eq = svand_z(pg, eq1, eq2);\n        if (svptest_any(pg, both_eq)) {\n            return false;\n        }\n        i += svcntw();\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) {\n        return true;\n    }\n\n    size_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n - 1);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t current = svld1(pg, &lst[i]);\n        svint32_t next = svld1(pg, &lst[i + 1]);\n        svbool_t cmp = svcmple(pg, current, next);\n        if (svptest_any(pg, svnot_b_z(pg, cmp))) {\n            return false;\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 1);\n    }\n\n    if (n < 3) {\n        return true;\n    }\n\n    i = 0;\n    pg = svwhilelt_b32(i, n - 2);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t a = svld1(pg, &lst[i]);\n        svint32_t b = svld1(pg, &lst[i + 1]);\n        svint32_t c = svld1(pg, &lst[i + 2]);\n        svbool_t eq_ab = svcmpeq(pg, a, b);\n        svbool_t eq_bc = svcmpeq(pg, b, c);\n        svbool_t triple_eq = svand_b_z(pg, eq_ab, eq_bc);\n        if (svptest_any(pg, triple_eq)) {\n            return false;\n        }\n        i += svcntw();\n        pg = svwhilelt_b32(i, n - 2);\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nbool is_sorted_simd(const std::vector<int> & lst) {\n    size_t n = lst.size();\n    if (n <= 1) \n        return true;\n\n    const int32_t *data = lst.data();\n    size_t vl = svcntw();\n\n    size_t i = 0;\n    while (i < n - 1) {\n        svbool_t pg = svwhilelt_b32(i, n - 1);\n        svint32_t vc = svld1(pg, data + i);\n        svint32_t vn = svld1(pg, data + i + 1);\n        svbool_t cmp = svcmpgt(pg, vc, vn);\n        if (svptest_any(pg, cmp)) \n            return false;\n        i += vl;\n    }\n\n    if (n < 3) \n        return true;\n\n    i = 0;\n    while (i < n - 2) {\n        svbool_t pg = svwhilelt_b32(i, n - 2);\n        svint32_t v0 = svld1(pg, data + i);\n        svint32_t v2 = svld1(pg, data + i + 2);\n        svbool_t cmp = svcmpeq(pg, v0, v2);\n        if (svptest_any(pg, cmp)) \n            return false;\n        i += vl;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    uint64_t n = arr.size();\n    int64_t count_neg = 0;\n    int64_t sum_abs = 0;\n    bool has_zero = false;\n    uint64_t i = 0;\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        \n        svbool_t zero_mask = svcmpeq_n_s32(pg, data, 0);\n        if (svptest_any(pg, zero_mask)) {\n            has_zero = true;\n        }\n        \n        svbool_t neg_mask = svcmplt_s32(pg, data, 0);\n        count_neg += svcntp_b32(pg, neg_mask);\n        \n        svint32_t abs_data = svabs_s32_z(pg, data);\n        sum_abs += svaddv_s32(pg, abs_data);\n        \n        i += svcntw();\n    }\n    \n    if (has_zero) {\n        return 0;\n    }\n    \n    int sign = (count_neg % 2 == 0) ? 1 : -1;\n    return sign * static_cast<int>(sum_abs);\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    uint64_t n = arr.size();\n    uint64_t i = 0;\n    bool found_zero = false;\n    int parity = 0;\n    svint32_t v_abs_acc = svdup_s32(0);\n    \n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, &arr[i]);\n        \n        svbool_t zero_mask = svcmpeq_s32(pg, data, 0);\n        if (svptest_any(svptrue_b32(), zero_mask)) {\n            found_zero = true;\n        }\n        \n        svbool_t neg_mask = svcmplt_s32(pg, data, 0);\n        uint64_t neg_count_in_chunk = svcntp_b32(pg, neg_mask);\n        parity ^= (neg_count_in_chunk & 1);\n        \n        svint32_t abs_data = svabs_s32_z(pg, data);\n        v_abs_acc = svadd_s32_z(pg, v_abs_acc, abs_data);\n        \n        uint64_t elements_in_chunk = svcntp_b32(pg, pg);\n        i += elements_in_chunk;\n        pg = svwhilelt_b32(i, n);\n    }\n    \n    int32_t total_abs = svaddv_s32(svptrue_b32(), v_abs_acc);\n    \n    if (found_zero) {\n        return 0;\n    }\n    return (parity & 1) ? -total_abs : total_abs;\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    size_t i = 0;\n    size_t n = arr.size();\n    uint64_t vl = svcntw();\n    svint32_t v_abs_sum = svdup_s32(0);\n    uint64_t any_zero = 0;\n    uint64_t parity = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &arr[i]);\n\n        svbool_t zero_mask = svcmpeq(pg, data, 0);\n        if (svptest_any(pg, zero_mask)) {\n            any_zero = 1;\n        }\n\n        svbool_t neg_mask = svcmplt(pg, data, 0);\n        uint64_t count_neg = svcntp_b32(pg, neg_mask);\n        parity ^= (count_neg & 1);\n\n        svint32_t abs_data = svabs_s32_z(pg, data);\n        v_abs_sum = svadd_s32_m(pg, v_abs_sum, abs_data);\n\n        i += vl;\n    }\n\n    int abs_sum = svaddv_s32(svptrue_b32(), v_abs_sum);\n\n    if (any_zero) {\n        return 0;\n    } else {\n        int sign = (parity & 1) ? -1 : 1;\n        return sign * abs_sum;\n    }\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint prod_signs_simd(const std::vector<int> & arr){\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    unsigned long long total_neg_count = 0;\n    long long sum_abs = 0;\n    bool any_zero = false;\n    size_t n = arr.size();\n    unsigned long long vl = svcntw();\n    size_t i = 0;\n    svbool_t all_true = svptrue_b32();\n    \n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1(pg, &arr[i]);\n        \n        svbool_t zero_mask = svcmpeq(pg, data, 0);\n        if (svptest_any(all_true, zero_mask)) {\n            any_zero = true;\n        }\n        \n        svbool_t neg_mask = svcmplt(pg, data, 0);\n        total_neg_count += svcntp_b32(pg, neg_mask);\n        \n        svint32_t abs_data = svabs_x(pg, data);\n        int32_t seg_sum = svaddv(pg, abs_data);\n        sum_abs += seg_sum;\n        \n        i += vl;\n    }\n    \n    int sign_product;\n    if (any_zero) {\n        sign_product = 0;\n    } else {\n        sign_product = (total_neg_count % 2) ? -1 : 1;\n    }\n    \n    return sign_product * static_cast<int>(sum_abs);\n}\n```"}
{"task_id": "SimdBench_123_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint prod_signs_simd(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    \n    uint64_t total_abs = 0;\n    uint64_t total_neg = 0;\n    bool found_zero = false;\n    \n    uint64_t n = arr.size();\n    uint64_t i = 0;\n    uint64_t vl = svcntw();\n    \n    for (; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, &arr[i]);\n        \n        svbool_t zero_mask = svcmpeq(pg, v, 0);\n        if (svptest_any(svptrue_b32(), zero_mask)) {\n            found_zero = true;\n        }\n        \n        svbool_t neg_mask = svcmplt(pg, v, 0);\n        total_neg += svcntp_b32(pg, neg_mask);\n        \n        svint32_t v_abs = svabs_s32_z(pg, v);\n        int32_t sum_abs_part = svaddv_s32(pg, v_abs);\n        total_abs += static_cast<uint32_t>(sum_abs_part);\n    }\n    \n    if (found_zero) {\n        return 0;\n    }\n    \n    int sign_product = (total_neg % 2) ? -1 : 1;\n    int result = sign_product * static_cast<int>(total_abs);\n    return result;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int r0 = -1, c0 = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                r0 = i;\n                c0 = j;\n            }\n        }\n    }\n\n    std::vector<int> path;\n    path.push_back(1);\n    if (k == 1) {\n        return path;\n    }\n\n    int r = r0, c = c0;\n    const int dr[4] = {-1, 1, 0, 0};\n    const int dc[4] = {0, 0, -1, 1};\n\n    for (int step = 1; step < k; step++) {\n        int values[4];\n        values[0] = (r + dr[0] >= 0) ? grid[r+dr[0]][c+dc[0]] : INT_MAX;\n        values[1] = (r + dr[1] < n) ? grid[r+dr[1]][c+dc[1]] : INT_MAX;\n        values[2] = (c + dc[2] >= 0) ? grid[r+dr[2]][c+dc[2]] : INT_MAX;\n        values[3] = (c + dc[3] < n) ? grid[r+dr[3]][c+dc[3]] : INT_MAX;\n\n        svbool_t pg = svwhilelt_b32(0, 4);\n        svint32_t vec = svld1(pg, values);\n        int32_t minval = svminv(pg, vec);\n\n        svint32_t indices = svindex_s32(0, 1);\n        svbool_t p_match = svcmpeq(pg, vec, minval);\n        svbool_t p_first = svbrka_z(pg, p_match);\n        int32_t idx = svaddv(p_first, indices);\n\n        r += dr[idx];\n        c += dc[idx];\n        path.push_back(minval);\n    }\n\n    return path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```c++\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int i0 = -1, j0 = -1;\n    {\n        int32_t one = 1;\n        svint32_t v_one = svdup_s32(one);\n        for (int i = 0; i < n; i++) {\n            int len = grid[i].size();\n            int j = 0;\n            unsigned int vl = svcntw();\n            svbool_t pg = svwhilelt_b32(j, len);\n            while (svptest_any(svptrue_b32(), pg)) {\n                svint32_t v = svld1_s32(pg, &grid[i][j]);\n                svbool_t cmp = svcmpeq_s32(pg, v, v_one);\n                if (svptest_any(pg, cmp)) {\n                    svint32_t indices = svindex_s32(0, 1);\n                    int32_t min_offset = svminv_s32(cmp, indices);\n                    i0 = i;\n                    j0 = j + min_offset;\n                    goto found_start;\n                }\n                j += vl;\n                pg = svwhilelt_b32(j, len);\n            }\n        }\n    }\n    found_start:\n\n    std::vector<int> path;\n    path.push_back(1);\n    if (k == 1) {\n        return path;\n    }\n\n    int current_i = i0, current_j = j0;\n    int big = INT_MAX;\n\n    for (int step = 1; step < k; step++) {\n        int arr[4] = {big, big, big, big};\n        int idx = 0;\n        int next_i[4], next_j[4];\n\n        if (current_i-1 >= 0) {\n            arr[idx] = grid[current_i-1][current_j];\n            next_i[idx] = current_i-1;\n            next_j[idx] = current_j;\n            idx++;\n        }\n        if (current_i+1 < n) {\n            arr[idx] = grid[current_i+1][current_j];\n            next_i[idx] = current_i+1;\n            next_j[idx] = current_j;\n            idx++;\n        }\n        if (current_j-1 >= 0) {\n            arr[idx] = grid[current_i][current_j-1];\n            next_i[idx] = current_i;\n            next_j[idx] = current_j-1;\n            idx++;\n        }\n        if (current_j+1 < grid[current_i].size()) {\n            arr[idx] = grid[current_i][current_j+1];\n            next_i[idx] = current_i;\n            next_j[idx] = current_j+1;\n            idx++;\n        }\n\n        int min_val = big;\n        if (idx > 0) {\n            svbool_t pg = svwhilelt_b32_s32(0, idx);\n            svint32_t v = svld1_s32(pg, arr);\n            min_val = svminv_s32(pg, v);\n        }\n\n        for (int i = 0; i < idx; i++) {\n            if (arr[i] == min_val) {\n                current_i = next_i[i];\n                current_j = next_j[i];\n                path.push_back(min_val);\n                break;\n            }\n        }\n    }\n\n    return path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k){\n    int n = grid.size();\n    int r0 = -1, c0 = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                r0 = i;\n                c0 = j;\n                break;\n            }\n        }\n        if (r0 != -1) break;\n    }\n\n    std::vector<int> path;\n    path.push_back(1);\n\n    if (k == 1) {\n        return path;\n    }\n\n    int dr[4] = {-1, 1, 0, 0};\n    int dc[4] = {0, 0, -1, 1};\n    int current_r = r0;\n    int current_c = c0;\n\n    for (int step = 1; step < k; step++) {\n        int values[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n        for (int i = 0; i < 4; i++) {\n            int nr = current_r + dr[i];\n            int nc = current_c + dc[i];\n            if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                values[i] = grid[nr][nc];\n            }\n        }\n\n        svint32_t sve_vals = svld1_s32(svptrue_b32(), values);\n        int min_val = svminv_s32(svptrue_b32(), sve_vals);\n\n        int min_index = -1;\n        for (int i = 0; i < 4; i++) {\n            if (values[i] == min_val) {\n                min_index = i;\n                break;\n            }\n        }\n\n        current_r += dr[min_index];\n        current_c += dc[min_index];\n        path.push_back(min_val);\n    }\n\n    return path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    if (k == 0) {\n        return {};\n    }\n    int N = grid.size();\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (grid[i][j] == 1) {\n                start_i = i;\n                start_j = j;\n            }\n        }\n    }\n    std::vector<int> path;\n    path.push_back(1);\n    if (k == 1) {\n        return path;\n    }\n    int current_i = start_i, current_j = start_j;\n    const int di[4] = {-1, 1, 0, 0};\n    const int dj[4] = {0, 0, -1, 1};\n\n    for (int step = 1; step < k; step++) {\n        int neighbor_vals[4] = {INT_MAX, INT_MAX, INT_MAX, INT_MAX};\n        for (int d = 0; d < 4; d++) {\n            int ni = current_i + di[d];\n            int nj = current_j + dj[d];\n            if (ni >= 0 && ni < N && nj >= 0 && nj < N) {\n                neighbor_vals[d] = grid[ni][nj];\n            }\n        }\n\n        svbool_t pg = svwhilelt_b32(0, 4);\n        svint32_t vec = svld1(pg, neighbor_vals);\n        int min_val = svminv_s32(pg, vec);\n\n        svint32_t indices = svindex_s32(0, 1);\n        svbool_t match = svcmpeq(pg, vec, min_val);\n        svbool_t first_match = svbrka_z(match, match);\n        int direction_index = svlasta_s32(first_match, indices);\n\n        current_i += di[direction_index];\n        current_j += dj[direction_index];\n        path.push_back(min_val);\n    }\n    return path;\n}\n```"}
{"task_id": "SimdBench_124_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <climits>\n#include <vector>\n\nstd::vector<int> minPath_simd(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    if (n == 0 || k <= 0) {\n        return {};\n    }\n\n    int min_val = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        const int32_t* row_ptr = grid[i].data();\n        int j = 0;\n        svint32_t row_min_vec = svdup_s32(INT_MAX);\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg)) {\n            svint32_t vec = svld1(pg, row_ptr + j);\n            row_min_vec = svmin_m(pg, row_min_vec, vec);\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n        int row_min = svminv_s32(svptrue_b32(), row_min_vec);\n        if (row_min < min_val) {\n            min_val = row_min;\n        }\n    }\n\n    int r0 = -1, c0 = -1;\n    bool found = false;\n    for (int i = 0; i < n && !found; ++i) {\n        const int32_t* row_ptr = grid[i].data();\n        int j = 0;\n        svbool_t pg = svwhilelt_b32(j, n);\n        while (svptest_any(svptrue_b32(), pg) && !found) {\n            svint32_t vec = svld1(pg, row_ptr + j);\n            svbool_t match = svcmpeq(pg, vec, svdup_s32(min_val));\n            if (svptest_any(svptrue_b32(), match)) {\n                int first_index = svpfirst(svptrue_b32(), match);\n                if (first_index >= 0) {\n                    r0 = i;\n                    c0 = j + first_index;\n                    found = true;\n                }\n            }\n            j += svcntw();\n            pg = svwhilelt_b32(j, n);\n        }\n    }\n\n    std::vector<int> path;\n    path.push_back(min_val);\n    int r = r0, c = c0;\n\n    for (int step = 1; step < k; ++step) {\n        int next_val = INT_MAX;\n        int next_r = -1, next_c = -1;\n\n        if (r - 1 >= 0) {\n            int candidate = grid[r-1][c];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r - 1;\n                next_c = c;\n            }\n        }\n        if (r + 1 < n) {\n            int candidate = grid[r+1][c];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r + 1;\n                next_c = c;\n            }\n        }\n        if (c - 1 >= 0) {\n            int candidate = grid[r][c-1];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r;\n                next_c = c - 1;\n            }\n        }\n        if (c + 1 < n) {\n            int candidate = grid[r][c+1];\n            if (candidate < next_val) {\n                next_val = candidate;\n                next_r = r;\n                next_c = c + 1;\n            }\n        }\n\n        path.push_back(next_val);\n        r = next_r;\n        c = next_c;\n    }\n\n    return path;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) {\n        return 0;\n    }\n\n    uint8_t digits[20] = {0};\n    int count = 0;\n    while (n > 0) {\n        digits[count++] = n % 10;\n        n /= 10;\n    }\n\n    svbool_t pg = svwhilelt_b8(0, count);\n    svuint8_t v_digits = svld1_u8(pg, digits);\n    svuint8_t ones_u8 = svdup_u8(1);\n    svuint8_t v_and1 = svand_u8_z(pg, v_digits, ones_u8);\n    svbool_t odd_mask = svcmpne_u8(pg, v_and1, svdup_u8(0));\n    \n    if (svcntp_b8(pg, odd_mask) == 0) {\n        return 0;\n    }\n\n    svuint8_t v_sel = svsel_u8(odd_mask, v_digits, ones_u8);\n    svuint8_t v_all = svdup_u8(1);\n    v_all = svsel_u8(svand_b_z(svptrue_b8(), pg, odd_mask), v_digits, v_all);\n\n    uint64_t vl = svcntb();\n    uint8_t temp[svcntb()];\n    svst1_u8(svptrue_b8(), temp, v_all);\n    uint64_t temp64[svcntb()];\n    for (int i = 0; i < svcntb(); i++) {\n        temp64[i] = temp[i];\n    }\n\n    svuint64_t v64 = svld1_u64(svptrue_b64(), temp64);\n    uint64_t levels = 0;\n    uint64_t temp_vl = svcntd();\n    while (temp_vl > 1) {\n        levels++;\n        temp_vl = (temp_vl + 1) / 2;\n    }\n\n    for (uint64_t i = 0; i < levels; i++) {\n        svuint64_t part1 = svuzp1_u64(v64, v64);\n        svuint64_t part2 = svuzp2_u64(v64, v64);\n        v64 = svmul_u64_x(svptrue_b64(), part1, part2);\n    }\n\n    uint64_t product;\n    svbool_t pg_out = svwhilelt_b64(0, 1);\n    svst1_u64(pg_out, &product, v64);\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    uint8_t digits[20] = {0};\n    int len = 0;\n    uint64_t num = n;\n    while (num) {\n        digits[len++] = num % 10;\n        num /= 10;\n    }\n\n    uint64_t total_product = 1;\n    int found_odd = 0;\n    int start = 0;\n    svbool_t pg = svwhilelt_b8(start, len);\n    while (svptest_any(svptrue_b8(), pg)) {\n        svuint8_t v_digits = svld1(pg, digits + start);\n        svuint8_t v_low_bit = svand_z(pg, v_digits, svdup_n_u8(1));\n        svbool_t p_odd = svcmpne(pg, v_low_bit, svdup_n_u8(0));\n        svuint8_t v_trans = svsel(p_odd, v_digits, svdup_n_u8(1));\n        svuint64_t v_wide = svcvt_u64_z(pg, v_trans);\n        uint64_t seg_product = svmulv_u64(pg, v_wide);\n        total_product *= seg_product;\n\n        if (svptest_any(pg, p_odd)) {\n            found_odd = 1;\n        }\n\n        uint64_t nseg = svcntp_b8(pg, pg);\n        start += nseg;\n        pg = svwhilelt_b8(start, len);\n    }\n\n    if (found_odd) {\n        return total_product;\n    } else {\n        return 0;\n    }\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint64_t d[20];\n    int len = 0;\n    uint64_t num = n;\n    \n    while (num) {\n        d[len] = num % 10;\n        num /= 10;\n        len++;\n    }\n\n    if (len == 0) {\n        return 0;\n    }\n\n    uint64_t global_product = 1;\n    int found_odd = 0;\n    int i = 0;\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b64(i, len);\n        uint64_t vl = svcntp_b64(svptrue_b64(), pg);\n        svuint64_t v = svld1_u64(pg, &d[i]);\n        svuint64_t ones = svdup_u64(1);\n        svuint64_t mod = svand_u64_x(pg, v, ones);\n        svbool_t odd_mask = svcmpne_u64(pg, mod, svdup_u64(0));\n        \n        if (svptest_any(svptrue_b64(), odd_mask)) {\n            found_odd = 1;\n        }\n\n        svuint64_t factors = svsel_u64(odd_mask, v, ones);\n        uint64_t temp[vl];\n        svst1_u64(pg, temp, factors);\n        \n        for (int j = 0; j < vl; j++) {\n            global_product *= temp[j];\n        }\n        \n        i += vl;\n    }\n\n    if (!found_odd) {\n        return 0;\n    } else {\n        return global_product;\n    }\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t digits_simd(uint64_t n) {\n    uint8_t digits[20];\n    int len = 0;\n    uint64_t temp = n;\n    do {\n        digits[len++] = temp % 10;\n        temp /= 10;\n    } while (temp);\n\n    uint64_t product = 1;\n    int has_odd = 0;\n    int i = 0;\n    size_t vector_length = svcntb();\n    svuint8_t v_ones = svdup_u8(1);\n\n    while (i < len) {\n        svbool_t pg = svwhilelt_b8(i, len);\n        svuint8_t v_digits = svld1_u8(pg, digits + i);\n        svuint8_t v_low = svand_u8_z(pg, v_digits, v_ones);\n        svbool_t p_odd = svcmpne_u8(pg, v_low, 0);\n        if (svptest_any(pg, p_odd)) {\n            has_odd = 1;\n        }\n        svuint8_t v_mul = svsel_u8(p_odd, v_digits, v_ones);\n        svst1_u8(pg, digits + i, v_mul);\n        i += vector_length;\n    }\n\n    if (!has_odd) {\n        return 0;\n    }\n\n    for (int j = 0; j < len; j++) {\n        product *= digits[j];\n    }\n\n    return product;\n}\n```"}
{"task_id": "SimdBench_125_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t digits_simd(uint64_t n) {\n    if (n == 0) {\n        return 0;\n    }\n    uint8_t digits[20];\n    int len = 0;\n    uint64_t num = n;\n    while (num) {\n        digits[len++] = num % 10;\n        num /= 10;\n    }\n    svbool_t pg_len64 = svwhilelt_b64(0, (uint64_t)len);\n    svuint64_t v64 = svld1ub_u64(pg_len64, digits);\n    svbool_t pg_odd64 = svcmpne(pg_len64, svand_u64_z(pg_len64, v64, 1), 0);\n    uint64_t odd_count = svcntp_b64(pg_odd64);\n    if (odd_count == 0) {\n        return 0;\n    }\n    svuint64_t factors = svdup_n_u64(1);\n    factors = svsel_u64(pg_odd64, v64, factors);\n    size_t vl = svcntd();\n    uint64_t temp[vl];\n    svst1_u64(svptrue_b64(), temp, factors);\n    uint64_t product = 1;\n    for (size_t i = 0; i < vl; i++) {\n        product *= temp[i];\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t n = lst.size();\n    if (n == 0) return 0;\n    \n    double total = 0.0;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t input = svld1_f32(pg, &lst[i]);\n        svfloat32_t rounded = svrintp_f32_x(pg, input);\n        svfloat32_t squared = svmul_f32_x(pg, rounded, rounded);\n        squared = svsel_f32(pg, squared, svdup_n_f32(0.0f));\n        \n        svfloat32_t even = svuzp1_f32(squared, squared);\n        svfloat32_t odd = svuzp2_f32(squared, squared);\n        \n        svfloat64_t even_f64 = svcvt_f64_f32_x(svptrue_b64(), even);\n        svfloat64_t odd_f64 = svcvt_f64_f32_x(svptrue_b64(), odd);\n        \n        double even_sum = svaddv_f64(svptrue_b64(), even_f64);\n        double odd_sum = svaddv_f64(svptrue_b64(), odd_f64);\n        \n        total += even_sum + odd_sum;\n        i += svcntp_b32(svptrue_b32(), pg);\n        pg = svwhilelt_b32(i, n);\n    }\n    \n    return static_cast<uint64_t>(total);\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total = 0;\n    uint64_t i = 0;\n    uint64_t len = lst.size();\n    uint64_t vl = svcntw();\n    \n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svfloat32_t input_vec = svld1(pg, &lst[i]);\n        svfloat32_t rounded_float = svrintp_x(pg, input_vec);\n        svint32_t rounded_int32 = svcvt_s32_x(pg, rounded_float);\n        \n        uint64_t active_count = svcntp_b32(pg, pg);\n        uint64_t num_lo = (active_count + 1) / 2;\n        uint64_t num_hi = active_count / 2;\n        \n        svint64_t squares_lo = svmullb_s32(rounded_int32, rounded_int32);\n        svint64_t squares_hi = svmullt_s32(rounded_int32, rounded_int32);\n        \n        svbool_t pg_lo = svwhilelt_b64(0, num_lo);\n        svbool_t pg_hi = svwhilelt_b64(0, num_hi);\n        \n        int64_t sum_lo = svaddv(pg_lo, squares_lo);\n        int64_t sum_hi = svaddv(pg_hi, squares_hi);\n        \n        total += (uint64_t)(sum_lo + sum_hi);\n        i += vl;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <cstdint>\n#include <vector>\n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t total_sum = 0;\n    int n = lst.size();\n    int i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t input_vec = svld1_f32_z(pg, &lst[i]);\n        svfloat32_t rounded_float = svrintp_f32_x(pg, input_vec);\n        svint32_t rounded_int32 = svcvt_s32_f32_x(pg, rounded_float);\n        \n        svint64_t squared_low = svmullb_s32_x(pg, rounded_int32, rounded_int32);\n        svint64_t squared_high = svmullt_s32_x(pg, rounded_int32, rounded_int32);\n        \n        svbool_t pg64_low = svunpklo_b32(pg);\n        svbool_t pg64_high = svunpkhi_b32(pg);\n        \n        total_sum += svaddv_s64(pg64_low, squared_low);\n        total_sum += svaddv_s64(pg64_high, squared_high);\n        \n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t sum_squares_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    int len = lst.size();\n    int i = 0;\n    while (i < len) {\n        svbool_t pg = svwhilelt_b32(i, len);\n        svfloat32_t vec = svld1_f32(pg, &lst[i]);\n        svfloat32_t rounded = svrintp_f32_x(pg, vec);\n        svfloat32_t sq = svmul_f32_x(pg, rounded, rounded);\n        float part_sum = svaddv_f32(pg, sq);\n        sum += static_cast<uint64_t>(part_sum);\n        i += svcntp_b32(svptrue_b8(), pg);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t sum_squares_simd(const std::vector<float> & lst){\n    uint64_t n = lst.size();\n    if (n == 0) return 0;\n\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    svint64_t sum_vec = svdup_n_s64(0);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t input = svld1_f32(pg, &lst[i]);\n        svfloat32_t rounded_float = svrintp_f32_x(pg, input);\n        svint32_t rounded_int32 = svcvt_s32_f32_x(pg, rounded_float);\n        svint64_t extended = svcvt_s64_s32_x(pg, rounded_int32);\n        svint64_t squared = svmul_s64_x(pg, extended, extended);\n        sum_vec = svadd_s64_x(pg, sum_vec, squared);\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    int64_t sum = svaddv_s64(svptrue_b64(), sum_vec);\n    return (uint64_t)sum;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n < 2) {\n        return -1;\n    }\n\n    int last_index = -1;\n    int i = 1;\n    svbool_t pg_loop = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg_loop)) {\n        svint32_t current = svld1_s32(pg_loop, &arr[i]);\n        svint32_t prev = svld1_s32(pg_loop, &arr[i-1]);\n        svbool_t pg_cond = svcmplt_s32(pg_loop, current, prev);\n        \n        if (svptest_any(svptrue_b32(), pg_cond)) {\n            svint32_t indices = svindex_s32(i, 1);\n            int32_t max_index = svmaxv_s32(pg_cond, indices);\n            if (max_index > last_index) {\n                last_index = max_index;\n            }\n        }\n        \n        i += svcntw();\n        pg_loop = svwhilelt_b32(i, n);\n    }\n    \n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n    size_t n = arr.size();\n    int last_found_index = -1;\n    size_t i = 1;\n    uint64_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current_vec = svld1(pg, &arr[i]);\n        svint32_t prev_vec = svld1(pg, &arr[i-1]);\n\n        svbool_t drop_pred = svcmplt(pg, current_vec, prev_vec);\n\n        if (svptest_any(svptrue_b32(), drop_pred)) {\n            svint32_t offsets = svindex_s32(0, 1);\n            svint32_t active_offsets = svsel(drop_pred, offsets, svdup_n_s32(-1));\n            int32_t max_offset = svmaxv_s32(drop_pred, active_offsets);\n            int candidate = static_cast<int>(i) + static_cast<int>(max_offset);\n            if (candidate > last_found_index) {\n                last_found_index = candidate;\n            }\n        }\n        i += vl;\n    }\n    return last_found_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr){\n    int n = arr.size();\n    if (n < 2) {\n        return -1;\n    }\n\n    int last_index = -1;\n    int i = 1;\n    size_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t prev = svld1_s32(pg, &arr[i-1]);\n        svint32_t curr = svld1_s32(pg, &arr[i]);\n        svbool_t p_cond = svcmplt_s32(pg, curr, prev);\n        \n        if (svptest_any(svptrue_b32(), p_cond)) {\n            svint32_t indices = svindex_s32(i, 1);\n            int max_index_in_chunk = svmaxv_s32(p_cond, indices);\n            if (max_index_in_chunk > last_index) {\n                last_index = max_index_in_chunk;\n            }\n        }\n        i += vl;\n    }\n    \n    return last_index;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    int n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    int last_violation = -1;\n    int i = 1;\n    unsigned int vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t current = svld1_s32(pg, &arr[i]);\n        svint32_t prev = svld1_s32(pg, &arr[i-1]);\n        svbool_t violation = svcmple_s32(pg, current, prev);\n\n        if (svptest_any(svptrue_b32(), violation)) {\n            svint32_t indices = svadd_n_s32_z(pg, svindex_s32(0, 1), i);\n            int last_in_segment = svlasta_s32(violation, indices);\n            last_violation = last_in_segment;\n        }\n\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return last_violation;\n}\n```"}
{"task_id": "SimdBench_127_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nint can_arrange_simd(const std::vector<int> & arr) {\n    uint64_t n = arr.size();\n    if (n <= 1) {\n        return -1;\n    }\n\n    uint64_t vl = svcntw();\n    uint64_t i = 1;\n    int last_index = -1;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t current = svld1(pg, &arr[i]);\n        svint32_t previous = svld1(pg, &arr[i-1]);\n        svbool_t cond = svcmplt(pg, current, previous);\n\n        if (svptest_any(pg, cond)) {\n            svint32_t index_vec = svadd_n_s32_x(pg, svindex_s32(0, 1), i);\n            last_index = svlasta_s32(cond, index_vec);\n        }\n\n        i += vl;\n    }\n\n    return last_index;\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int64_t n = lst.size();\n    if (n == 0) {\n        return {0, 0};\n    }\n    const int32_t* data = lst.data();\n    int32_t max_neg_acc = INT_MIN;\n    int32_t min_pos_acc = INT_MAX;\n    unsigned int vl = svcntw();\n    int64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t input = svld1_s32(pg, data + i);\n        svbool_t neg_pred = svcmplt_s32(pg, input, 0);\n        svint32_t candidate_neg = svsel_s32(neg_pred, input, svdup_n_s32(INT_MIN));\n        int32_t max_neg_seg = svmaxv_s32(pg, candidate_neg);\n        if (max_neg_seg > max_neg_acc) {\n            max_neg_acc = max_neg_seg;\n        }\n        svbool_t pos_pred = svcmpgt_s32(pg, input, 0);\n        svint32_t candidate_pos = svsel_s32(pos_pred, input, svdup_n_s32(INT_MAX));\n        int32_t min_pos_seg = svminv_s32(pg, candidate_pos);\n        if (min_pos_seg < min_pos_acc) {\n            min_pos_acc = min_pos_seg;\n        }\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n    if (max_neg_acc == INT_MIN) {\n        max_neg_acc = 0;\n    }\n    if (min_pos_acc == INT_MAX) {\n        min_pos_acc = 0;\n    }\n    return {max_neg_acc, min_pos_acc};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    int32_t global_max_neg = INT_MIN;\n    int32_t global_min_pos = INT_MAX;\n    bool found_neg = false;\n    bool found_pos = false;\n\n    uint32_t vl = svcntw();\n    const int32_t* data = lst.data();\n    size_t n = lst.size();\n\n    for (size_t i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, data + i);\n        svint32_t zero = svdup_s32(0);\n\n        svbool_t neg_mask = svcmplt_s32(pg, v, zero);\n        svbool_t pos_mask = svcmpgt_s32(pg, v, zero);\n\n        if (svptest_any(pg, neg_mask)) {\n            found_neg = true;\n        }\n        if (svptest_any(pg, pos_mask)) {\n            found_pos = true;\n        }\n\n        svint32_t neg_vec = svsel_s32(neg_mask, v, svdup_s32(INT_MIN));\n        int32_t chunk_neg_max = svmaxv_s32(pg, neg_vec);\n        if (chunk_neg_max > global_max_neg) {\n            global_max_neg = chunk_neg_max;\n        }\n\n        svint32_t pos_vec = svsel_s32(pos_mask, v, svdup_s32(INT_MAX));\n        int32_t chunk_pos_min = svminv_s32(pg, pos_vec);\n        if (chunk_pos_min < global_min_pos) {\n            global_min_pos = chunk_pos_min;\n        }\n    }\n\n    if (!found_neg) global_max_neg = 0;\n    if (!found_pos) global_min_pos = 0;\n\n    return {global_max_neg, global_min_pos};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    if (lst.empty()) {\n        return {0, 0};\n    }\n\n    svint32_t max_neg_acc = svdup_s32(INT_MIN);\n    svint32_t min_pos_acc = svdup_s32(INT_MAX);\n    bool found_neg = false;\n    bool found_pos = false;\n\n    int n = lst.size();\n    int i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, &lst[i]);\n\n        svbool_t p_neg = svcmplt_s32(pg, v, 0);\n        svbool_t p_pos = svcmpgt_s32(pg, v, 0);\n\n        max_neg_acc = svsel(p_neg, svmax_s32_z(p_neg, max_neg_acc, v), max_neg_acc);\n        min_pos_acc = svsel(p_pos, svmin_s32_z(p_pos, min_pos_acc, v), min_pos_acc);\n\n        if (svptest_any(svptrue_b32(), p_neg)) found_neg = true;\n        if (svptest_any(svptrue_b32(), p_pos)) found_pos = true;\n\n        i += svcntp_b32(pg, pg);\n    }\n\n    int max_neg_val = found_neg ? svmaxv_s32(svptrue_b32(), max_neg_acc) : 0;\n    int min_pos_val = found_pos ? svminv_s32(svptrue_b32(), min_pos_acc) : 0;\n\n    return {max_neg_val, min_pos_val};\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    bool found_neg = false;\n    bool found_pos = false;\n    int32_t max_neg = 0;\n    int32_t min_pos = 0;\n    uint64_t n = lst.size();\n    const int32_t* data = lst.data();\n    uint64_t i = 0;\n    uint64_t vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t vec = svld1_s32(pg, data + i);\n        svbool_t mask_neg = svcmplt_s32(pg, vec, 0);\n        svbool_t mask_pos = svcmpgt_s32(pg, vec, 0);\n\n        if (svptest_any(svptrue_b32(), mask_neg)) {\n            int32_t local_max_neg = svmaxv_s32(mask_neg, vec);\n            if (!found_neg) {\n                max_neg = local_max_neg;\n                found_neg = true;\n            } else {\n                if (local_max_neg > max_neg) {\n                    max_neg = local_max_neg;\n                }\n            }\n        }\n\n        if (svptest_any(svptrue_b32(), mask_pos)) {\n            int32_t local_min_pos = svminv_s32(mask_pos, vec);\n            if (!found_pos) {\n                min_pos = local_min_pos;\n                found_pos = true;\n            } else {\n                if (local_min_pos < min_pos) {\n                    min_pos = local_min_pos;\n                }\n            }\n        }\n\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return std::vector<int>({max_neg, min_pos});\n}\n```"}
{"task_id": "SimdBench_128_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> largest_smallest_integers_simd(const std::vector<int>& lst) {\n    int max_neg = 0;\n    int min_pos = 0;\n    bool found_neg = false;\n    bool found_pos = false;\n    uint64_t n = lst.size();\n    if (n == 0) {\n        return {0, 0};\n    }\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        \n        svbool_t neg_mask = svcmplt_s32(pg, data, 0);\n        if (svptest_any(pg, neg_mask)) {\n            int32_t temp_neg = svmaxv_s32(neg_mask, data);\n            if (!found_neg) {\n                max_neg = temp_neg;\n                found_neg = true;\n            } else {\n                if (temp_neg > max_neg) {\n                    max_neg = temp_neg;\n                }\n            }\n        }\n        \n        svbool_t pos_mask = svcmpgt_s32(pg, data, 0);\n        if (svptest_any(pg, pos_mask)) {\n            int32_t temp_pos = svminv_s32(pos_mask, data);\n            if (!found_pos) {\n                min_pos = temp_pos;\n                found_pos = true;\n            } else {\n                if (temp_pos < min_pos) {\n                    min_pos = temp_pos;\n                }\n            }\n        }\n        i += vl;\n    }\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nstatic inline uint64_t vector_reduce_product(svuint64_t v) {\n    uint64_t vl = svcntd();\n    int levels = 0;\n    uint64_t temp = vl;\n    while (temp > 1) {\n        levels++;\n        temp >>= 1;\n    }\n    svuint64_t ones = svdup_u64(1);\n    for (int l = 0; l < levels; l++) {\n        uint64_t step = 1 << l;\n        svuint64_t index_base = svindex_u64(0, 1);\n        svuint64_t index2 = svadd_u64_x(svptrue_b64(), index_base, svdup_u64(step));\n        svbool_t pg = svcmplt_u64(svptrue_b64(), index2, svdup_u64(vl));\n        svuint64_t part1 = svtbl(v, index_base);\n        svuint64_t part2 = svtbl(v, index2);\n        part2 = svsel_u64(svnot_b_z(svptrue_b64(), pg), ones, part2);\n        v = svmul_u64_x(svptrue_b64(), part1, part2);\n    }\n    uint64_t result;\n    svbool_t p = svwhilelt_b64(0, 1);\n    svst1(p, &result, v);\n    return result;\n}\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    }\n    uint64_t fact[n];\n    fact[0] = 1;\n    for (uint64_t k = 1; k < n; k++) {\n        fact[k] = fact[k-1] * (k+1);\n    }\n    uint64_t vl = svcntd();\n    svuint64_t ones = svdup_u64(1);\n    uint64_t i = 0;\n    uint64_t prod = 1;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t chunk = svld1(pg, &fact[i]);\n        chunk = svsel_u64(svnot_b_z(svptrue_b64(), pg), ones, chunk);\n        uint64_t chunk_prod = vector_reduce_product(chunk);\n        prod *= chunk_prod;\n        i += vl;\n    }\n    return prod;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    }\n    uint64_t factorials[n];\n    factorials[0] = 1;\n    for (uint64_t k = 2; k <= n; k++) {\n        factorials[k-1] = factorials[k-2] * k;\n    }\n\n    uint64_t result = 1;\n    uint64_t vl = svcntd();\n    for (uint64_t i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t vec = svld1(pg, &factorials[i]);\n        uint64_t chunk_product = svmulv_u64(pg, vec);\n        result *= chunk_product;\n        i += vl;\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t special_factorial_simd(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    }\n    uint64_t total = 1;\n    uint64_t i = 0;\n    uint64_t vl = svcntd();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t j_vec = svindex_u64(i + 1, 1);\n        svuint64_t exp_vec = svsub_u64_z(pg, svdup_u64(n + 1), j_vec);\n        svuint64_t term_vec = svdup_u64(1);\n\n        for (uint64_t k = 0; k < n; k++) {\n            svuint64_t k_vec = svdup_u64(k);\n            svbool_t mask = svcmplt_u64(pg, k_vec, exp_vec);\n            term_vec = svmul_u64_m(mask, term_vec, j_vec);\n        }\n\n        uint64_t block_product = svmulv_u64(pg, term_vec);\n        total *= block_product;\n        i += vl;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n) {\n    uint64_t total = 1;\n    uint64_t vl = svcntd();\n    uint64_t i = 1;\n    while (i <= n) {\n        uint64_t block_size = n - i + 1;\n        if (block_size > vl) block_size = vl;\n        svbool_t pg = svwhilelt_b64(0, block_size);\n        svuint64_t base = svindex_u64(i, 1);\n        svuint64_t exp_vec = svsub_u64_x(pg, svdup_u64(n + 1), base);\n        svuint64_t res = svdup_u64(1);\n        svuint64_t current_base = base;\n        for (int bit = 0; bit < 64; bit++) {\n            svuint64_t lsb = svand_u64_x(pg, exp_vec, svdup_u64(1));\n            svbool_t mask = svcmpne_u64(pg, lsb, svdup_u64(0));\n            res = svsel_u64(mask, svmul_u64_x(pg, res, current_base), res);\n            current_base = svmul_u64_x(pg, current_base, current_base);\n            exp_vec = svlsr_u64_x(pg, exp_vec, 1);\n            svbool_t exp_nonzero = svcmpne_u64(pg, exp_vec, svdup_u64(0));\n            if (svcntp_b64(pg, exp_nonzero) == 0) {\n                break;\n            }\n        }\n        uint64_t chunk_product = svreduce_mul_u64(pg, res);\n        total *= chunk_product;\n        i += block_size;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_129_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t special_factorial_simd(uint64_t n){\n    if (n == 0) {\n        return 1;\n    }\n    uint64_t terms[n];\n    for (uint64_t k = 1; k <= n; k++) {\n        uint64_t exp = n - k + 1;\n        uint64_t term = 1;\n        for (uint64_t j = 0; j < exp; j++) {\n            term *= k;\n        }\n        terms[k-1] = term;\n    }\n\n    uint64_t total = 1;\n    uint64_t i = 0;\n    uint64_t vl = svcntd();\n    while (i < n) {\n        svbool_t pg = svwhilelt_b64(i, n);\n        svuint64_t vec = svld1_u64(pg, &terms[i]);\n        uint64_t seg_prod = svreduce_mul_u64(pg, vec);\n        total *= seg_prod;\n        i += vl;\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint sum_squares_simd(const std::vector<int> & lst){\n    uint64_t n = static_cast<uint64_t>(lst.size());\n    if (n == 0) {\n        return 0;\n    }\n    const int* data_ptr = lst.data();\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    int total = 0;\n\n    for (i = 0; i < n; ) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, data_ptr + i);\n        svint32_t indices = svindex_s32(i, 1);\n        \n        svint32_t mod3 = svmod_s32_x(pg, indices, 3);\n        svbool_t p3 = svcmpeq_n_s32(pg, mod3, 0);\n        \n        svint32_t mod4 = svmod_s32_x(pg, indices, 4);\n        svbool_t p4 = svcmpeq_n_s32(pg, mod4, 0);\n        p4 = svbic_b_z(pg, p4, p3);\n        \n        svint32_t result = data;\n        svint32_t square = svmul_s32_z(p3, data, data);\n        result = svsel_s32(p3, square, result);\n        \n        svint32_t temp_square = svmul_s32_z(p4, data, data);\n        svint32_t cube = svmul_s32_z(p4, temp_square, data);\n        result = svsel_s32(p4, cube, result);\n        \n        int32_t chunk_sum = svaddv_s32(pg, result);\n        total += chunk_sum;\n        i += vl;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) \n        return 0;\n\n    uint64_t i = 0;\n    int total = 0;\n    const uint32_t p3_array[12] = {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0};\n    const uint32_t p4_array[12] = {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0};\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        svuint32_t base_index = svindex_u32(i, 1);\n\n        svuint32_t mod16 = svand_u32_x(pg, base_index, 15);\n        svbool_t p_ge12 = svcmpge_u32(pg, mod16, 12);\n        svuint32_t mod12 = svsub_u32_m(p_ge12, mod16, 12);\n\n        svuint32_t p3_flag = svld1_gather_u32index_u32(pg, p3_array, mod12);\n        svuint32_t p4_flag = svld1_gather_u32index_u32(pg, p4_array, mod12);\n\n        svbool_t p3_pred = svcmpne_n_u32(pg, p3_flag, 0);\n        svbool_t p4_pred = svcmpne_n_u32(pg, p4_flag, 0);\n\n        svint32_t square = svmul_s32_x(pg, data, data);\n        svint32_t cube = svmul_s32_x(pg, square, data);\n\n        svint32_t res = svsel_s32(p3_pred, square, data);\n        res = svsel_s32(p4_pred, cube, res);\n\n        int32_t sum_part = svaddv_s32(pg, res);\n        total += sum_part;\n\n        i += svcntw();\n    }\n\n    return total;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    uint64_t n = lst.size();\n    uint64_t i = 0;\n    int total = 0;\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &lst[i]);\n        svint32_t indices = svindex_s32(i, 1);\n        \n        svfloat32_t f_idx = svcvt_f32_s32_z(pg, indices);\n        svfloat32_t div3 = svdiv_f32_z(pg, f_idx, svdup_f32(3.0f));\n        svint32_t quotient = svcvt_s32_f32_z(pg, div3);\n        svint32_t mod3 = svsub_s32_z(pg, indices, svmul_s32_z(pg, quotient, 3));\n        \n        svint32_t mod4 = svand_s32_x(pg, indices, 3);\n        \n        svbool_t mask3 = svcmpeq_s32(pg, mod3, 0);\n        svbool_t mask4 = svcmpeq_s32(pg, mod4, 0);\n        svbool_t not_mask3 = svcmpne_s32(pg, mod3, 0);\n        svbool_t mask_cube = svand_b_z(pg, mask4, not_mask3);\n        \n        svint32_t squared = svmul_s32_z(pg, data, data);\n        svint32_t cubed = svmul_s32_z(pg, squared, data);\n        \n        svint32_t result = svsel_s32(mask3, squared, data);\n        result = svsel_s32(mask_cube, cubed, result);\n        \n        total += svaddv_s32(pg, result);\n        i += svcntp_b32(svptrue_b32(), pg);\n    }\n    \n    return total;\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n\n    const int* data_ptr = lst.data();\n    svint32_t sum_vec = svdup_n_s32(0);\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t data = svld1_s32(pg, data_ptr + i);\n        svint32_t indices = svindex_s32(i, 1);\n\n        svint32_t quot3 = svdiv_n_s32_z(pg, indices, 3);\n        svint32_t rem3 = svsub_s32_z(pg, indices, svmul_n_s32_z(pg, quot3, 3));\n        svbool_t p3 = svcmpeq_n_s32(pg, rem3, 0);\n\n        svint32_t quot4 = svdiv_n_s32_z(pg, indices, 4);\n        svint32_t rem4 = svsub_s32_z(pg, indices, svmul_n_s32_z(pg, quot4, 4));\n        svbool_t p4 = svcmpeq_n_s32(pg, rem4, 0);\n        p4 = svand_b_z(pg, p4, svnot_b_z(pg, p3));\n\n        svint32_t square = svmul_s32_z(pg, data, data);\n        svint32_t cube = svmul_s32_z(pg, data, square);\n\n        svint32_t res = svsel_s32(p3, square, data);\n        res = svsel_s32(p4, cube, res);\n\n        sum_vec = svadd_s32_z(pg, sum_vec, res);\n\n        uint64_t vl = svcntp_b32(pg, pg);\n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return svaddv_s32(svptrue_b32(), sum_vec);\n}\n```"}
{"task_id": "SimdBench_130_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint sum_squares_simd(const std::vector<int> & lst) {\n    int32_t sum = 0;\n    size_t n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    const int32_t *data = lst.data();\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    int32_t table3[12] = {1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0};\n    int32_t table4[12] = {0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0};\n\n    do {\n        svint32_t va = svld1_s32(pg, data + i);\n        svint32_t indices = svindex_s32(i, 1);\n        svfloat32_t f_idx = svcvt_f32_s32_x(pg, indices);\n        svfloat32_t div = svmul_f32_x(pg, f_idx, svdup_f32(1.0f / 12.0f));\n        svint32_t quot = svcvt_s32_f32_x(pg, div);\n        svint32_t quot_times_12 = svmul_s32_x(pg, quot, svdup_s32(12));\n        svint32_t mod12 = svsub_s32_x(pg, indices, quot_times_12);\n\n        svint32_t cond3_vec = svld1_gather_s32index_s32(pg, table3, mod12);\n        svint32_t cond4_vec = svld1_gather_s32index_s32(pg, table4, mod12);\n        svbool_t pred3 = svcmpne(pg, cond3_vec, 0);\n        svbool_t pred4 = svcmpne(pg, cond4_vec, 0);\n\n        svint32_t squared = svmul_s32_x(pg, va, va);\n        svint32_t cubed = svmul_s32_x(pg, squared, va);\n        svint32_t res = svsel_s32(pred3, squared, va);\n        res = svsel_s32(pred4, cubed, res);\n\n        sum += svaddv_s32(svptrue_b32(), svcompact_s32(pg, res));\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    } while (svptest_any(svptrue_b32(), pg));\n\n    return sum;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <climits>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int n = nums.size();\n    int i = 0;\n    const int32_t powers[] = {10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t n_vec = svld1_s32(pg, &nums[i]);\n        svbool_t cond_gt10 = svcmpgt_n_s32(pg, n_vec, 10);\n\n        if (svptest_any(svptrue_b32(), cond_gt10)) {\n            svuint32_t n_u = svreinterpret_u32_s32(n_vec);\n            svuint32_t high = svmulh_u32_z(cond_gt10, n_u, svdup_n_u32(0xCCCCCCCD));\n            svuint32_t quotient = svlsr_n_u32_z(cond_gt10, high, 3);\n            svuint32_t last_digit = svsub_u32_z(cond_gt10, n_u, svmul_n_u32_z(cond_gt10, quotient, 10));\n\n            svbool_t last_odd = svorr_b_z(cond_gt10,\n                svorr_b_z(cond_gt10,\n                    svcmpeq_n_u32(cond_gt10, last_digit, 1),\n                    svcmpeq_n_u32(cond_gt10, last_digit, 3)),\n                svorr_b_z(cond_gt10,\n                    svorr_b_z(cond_gt10,\n                        svcmpeq_n_u32(cond_gt10, last_digit, 5),\n                        svcmpeq_n_u32(cond_gt10, last_digit, 7)),\n                    svcmpeq_n_u32(cond_gt10, last_digit, 9)));\n\n            svbool_t first_odd = svdup_n_b32(false);\n            for (int k = 0; k < 9; k++) {\n                int32_t p = powers[k];\n                for (int d = 1; d <= 9; d += 2) {\n                    int64_t lower64 = (int64_t)d * p;\n                    if (lower64 > INT_MAX) break;\n                    int64_t upper64 = (int64_t)(d+1) * p;\n\n                    if (upper64 > INT_MAX) {\n                        svbool_t in_range = svcmpge_s32(cond_gt10, n_vec, svdup_n_s32((int32_t)lower64));\n                        first_odd = svorr_b_z(cond_gt10, first_odd, in_range);\n                    } else {\n                        svbool_t in_range = svand_b_z(cond_gt10,\n                            svcmpge_s32(cond_gt10, n_vec, svdup_n_s32((int32_t)lower64)),\n                            svcmplt_s32(cond_gt10, n_vec, svdup_n_s32((int32_t)upper64)));\n                        first_odd = svorr_b_z(cond_gt10, first_odd, in_range);\n                    }\n                }\n            }\n\n            svbool_t cond_final = svand_b_z(cond_gt10, last_odd, first_odd);\n            count += svcntp_b32(cond_gt10, cond_final);\n        }\n        i += svcntp_b32(pg, pg);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int n = nums.size();\n    if (n == 0) return 0;\n    int count = 0;\n    int i = 0;\n    unsigned int vl = svcntw();\n    svbool_t ptrue = svptrue_b32();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &nums[i]);\n        svbool_t mask_gt10 = svcmpgt(pg, data, 10);\n\n        if (svptest_any(ptrue, mask_gt10)) {\n            svint32_t quotient = svdiv_s32_x(mask_gt10, data, 10);\n            svint32_t last_digit = svmls_s32_x(mask_gt10, data, quotient, 10);\n            svbool_t last_odd = svcmpne(mask_gt10, svand_s32_x(mask_gt10, last_digit, 1), 0);\n            svuint32_t u_data = svreinterpret_u32_s32(data);\n            svuint32_t temp = u_data;\n\n            for (int j = 0; j < 9; j++) {\n                svbool_t pg_loop = svcmpge(mask_gt10, temp, 10);\n                temp = svsel(pg_loop, svdiv_u32_x(pg_loop, temp, 10), temp);\n            }\n\n            svint32_t first_digit = svreinterpret_s32_u32(temp);\n            svbool_t first_odd = svcmpne(mask_gt10, svand_s32_x(mask_gt10, first_digit, 1), 0);\n            svbool_t final_cond = svand_z(mask_gt10, last_odd, first_odd);\n            count += svcntp_b32(pg, final_cond);\n        }\n\n        i += vl;\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    if (nums.empty()) \n        return 0;\n\n    int n = nums.size();\n    int i = 0;\n    int count = 0;\n    svint32_t vec10 = svdup_n_s32(10);\n    svint32_t vec1 = svdup_n_s32(1);\n    svint32_t vec0 = svdup_n_s32(0);\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t data = svld1_s32(pg, &nums[i]);\n\n        svbool_t mask_cond_a = svcmpgt(pg, data, vec10);\n        if (svptest_any(svptrue_b32(), mask_cond_a)) {\n            svint32_t first_digit = data;\n            svbool_t pg_reduce = mask_cond_a;\n            for (int j = 0; j < 10; j++) {\n                if (svcntp_b32(svptrue_b32(), pg_reduce) == 0)\n                    break;\n                first_digit = svsel_s32(pg_reduce, svdiv_s32_z(pg_reduce, first_digit, vec10), first_digit);\n                pg_reduce = svand_b_z(svptrue_b32(), pg_reduce, svcmpge(pg_reduce, first_digit, vec10));\n            }\n\n            svbool_t last_odd = svcmpne(svptrue_b32(), svand_s32_z(svptrue_b32(), data, vec1), vec0);\n            svbool_t first_odd = svcmpne(svptrue_b32(), svand_s32_z(svptrue_b32(), first_digit, vec1), vec0);\n            svbool_t final_mask = svand_b_z(svptrue_b32(), mask_cond_a, svand_b_z(svptrue_b32(), last_odd, first_odd));\n            count += svcntp_b32(svptrue_b32(), final_mask);\n        }\n        i += svcntp_b32(pg, pg);\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nint specialFilter_simd(const std::vector<int> & nums) {\n    int count = 0;\n    int n = nums.size();\n    if (n == 0) return 0;\n\n    uint64_t vl = svcntw();\n    svint32_t v10 = svdup_s32(10);\n    svuint32_t ten = svdup_u32(10);\n    static const uint32_t powers[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000};\n\n    for (int i = 0; i < n; i += vl) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t x_vec = svld1(pg, &nums[i]);\n\n        svbool_t p_cond1 = svcmpgt(pg, x_vec, v10);\n        svint32_t abs_x_int = svqabs(p_cond1, x_vec);\n        svuint32_t n_val = svreinterpret_u32(abs_x_int);\n\n        svuint32_t quotient1 = svdiv_u32_x(p_cond1, n_val, ten);\n        svuint32_t product1 = svmul_u32_x(p_cond1, quotient1, ten);\n        svuint32_t last_digit = svsub_u32_x(p_cond1, n_val, product1);\n\n        svuint32_t divisor = svdup_u32(1);\n        for (int exp = 1; exp <= 9; exp++) {\n            svuint32_t power_vec = svdup_u32(powers[exp]);\n            svbool_t p_ge = svcmpge(p_cond1, n_val, power_vec);\n            divisor = svsel_u32(p_ge, power_vec, divisor);\n        }\n\n        svuint32_t first_digit = svdiv_u32_x(p_cond1, n_val, divisor);\n        svuint32_t last_odd = svand_u32_x(p_cond1, last_digit, svdup_u32(1));\n        svuint32_t first_odd = svand_u32_x(p_cond1, first_digit, svdup_u32(1));\n        svbool_t p_last_odd = svcmpeq(p_cond1, last_odd, svdup_u32(1));\n        svbool_t p_first_odd = svcmpeq(p_cond1, first_odd, svdup_u32(1));\n        svbool_t p_cond2 = svand_b_z(p_cond1, p_last_odd, p_first_odd);\n\n        count += svcntp_b32(pg, p_cond2);\n    }\n\n    return count;\n}\n```"}
{"task_id": "SimdBench_131_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <cstdlib>\n\nint specialFilter_simd(const std::vector<int> & nums){\n    int count = 0;\n    uint64_t n = nums.size();\n    uint64_t i = 0;\n    uint64_t vl = svcntw();\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t v = svld1_s32(pg, &nums[i]);\n        svbool_t p_gt10 = svcmpgt_s32(pg, v, svdup_s32(10));\n        \n        int32_t buffer[vl];\n        svst1_s32(p_gt10, buffer, v);\n        \n        uint64_t active_count = svcntp_b32(pg, p_gt10);\n        for (uint64_t j = 0; j < active_count; j++) {\n            int num_val = buffer[j];\n            int abs_val = std::abs(num_val);\n            int last_digit = abs_val % 10;\n            if (last_digit % 2 != 1) {\n                continue;\n            }\n            while (abs_val >= 10) {\n                abs_val /= 10;\n            }\n            if (abs_val % 2 == 1) {\n                count++;\n            }\n        }\n        i += vl;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    uint64_t r0 = (n + 1) / 3; // Count of indices i where i mod 3 == 2 (a[i] mod 3 = 0)\n    uint64_t r1 = n - r0;      // Count of indices i where a[i] mod 3 = 1\n    uint64_t total = 0;\n    if (r0 >= 3) {\n        total += r0 * (r0 - 1) * (r0 - 2) / 6;\n    }\n    if (r1 >= 3) {\n        total += r1 * (r1 - 1) * (r1 - 2) / 6;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n    uint64_t count0 = 0, count1 = 0, count2 = 0;\n    uint64_t i = 1;\n    svuint64_t magic = svdup_n_u64(0x5555555555555556ULL);\n    while (i <= n) {\n        svbool_t pg = svwhilelt_b64(i, n + 1);\n        svuint64_t vindex = svadd_n_u64_x(pg, svindex_u64(0, 1), i);\n        svuint64_t q = svmulh_u64_x(pg, vindex, magic);\n        svuint64_t vrem = svmls_n_u64_x(pg, vindex, q, 3);\n\n        svbool_t pg0 = svcmpeq_n_u64(pg, vrem, 0);\n        svbool_t pg1 = svcmpeq_n_u64(pg, vrem, 1);\n        svbool_t pg2 = svcmpeq_n_u64(pg, vrem, 2);\n\n        count0 += svcntp_b64(svptrue_b64(), pg0);\n        count1 += svcntp_b64(svptrue_b64(), pg1);\n        count2 += svcntp_b64(svptrue_b64(), pg2);\n\n        uint64_t vl = svcntp_b64(svptrue_b64(), pg);\n        i += vl;\n    }\n    uint64_t set0 = count0 + count1;\n    uint64_t set1 = count2;\n    uint64_t triples0 = 0;\n    uint64_t triples1 = 0;\n    if (set0 >= 3) {\n        triples0 = set0;\n        triples0 = triples0 * (set0 - 1) / 2;\n        triples0 = triples0 * (set0 - 2) / 3;\n    }\n    if (set1 >= 3) {\n        triples1 = set1;\n        triples1 = triples1 * (set1 - 1) / 2;\n        triples1 = triples1 * (set1 - 2) / 3;\n    }\n    return triples0 + triples1;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n){\n    uint64_t count0 = 0;\n    uint64_t count1 = 0;\n    uint64_t i = 1;\n    const uint64_t M = 0x5555555555555556ULL;\n\n    svbool_t pg = svwhilelt_b64(i, n+1);\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        uint64_t vl = svcntp_b64(pg, pg);\n        svuint64_t v_i = svindex_u64(i, 1);\n        svuint64_t v_q = svmulh_u64_z(pg, v_i, svdup_n_u64(M));\n        svuint64_t v_rem = svsub_u64_z(pg, v_i, svmul_n_u64_z(pg, v_q, 3));\n        svbool_t p_count0 = svcmpeq_n_u64(pg, v_rem, 2);\n        uint64_t cnt0_here = svcntp_b64(pg, p_count0);\n        count0 += cnt0_here;\n        count1 += (vl - cnt0_here);\n        i += vl;\n        pg = svwhilelt_b64(i, n+1);\n    }\n\n    uint64_t triples0 = 0;\n    if (count0 >= 3) {\n        uint64_t a = count0;\n        triples0 = a * (a - 1) / 2;\n        triples0 = triples0 * (a - 2) / 3;\n    }\n\n    uint64_t triples1 = 0;\n    if (count1 >= 3) {\n        uint64_t a = count1;\n        triples1 = a * (a - 1) / 2;\n        triples1 = triples1 * (a - 2) / 3;\n    }\n\n    return triples0 + triples1;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n    uint64_t i = 1;\n    uint64_t base_res = 1;\n    uint64_t count0 = 0;\n    uint64_t count1 = 0;\n    svbool_t pg = svwhilelt_b64(i, n+1);\n    \n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t v_res = svindex_u64(base_res, 1);\n        svbool_t p_high = svcmpge_n_u64(pg, v_res, 3);\n        v_res = svsub_u64_m(p_high, v_res, 3);\n        svbool_t p0 = svcmpeq_n_u64(pg, v_res, 2);\n        uint64_t inc0 = svcntp_b64(pg, p0);\n        count0 += inc0;\n        uint64_t vl = svcntp_b64(pg, pg);\n        count1 += vl - inc0;\n        i += vl;\n        base_res = (base_res + vl) % 3;\n        pg = svwhilelt_b64(i, n+1);\n    }\n\n    uint64_t ans = 0;\n    if (count0 >= 3) {\n        ans += (count0 * (count0 - 1) * (count0 - 2)) / 6;\n    }\n    if (count1 >= 3) {\n        ans += (count1 * (count1 - 1) * (count1 - 2)) / 6;\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_132_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <stdint.h>\n\nuint64_t get_max_triples_simd(uint64_t n) {\n    if (n < 3) {\n        return 0;\n    }\n\n    uint64_t r0 = 0, r1 = 0, r2 = 0;\n    uint64_t i = 1;\n    svbool_t pg = svwhilelt_b64(i, n + 1);\n    const uint64_t mod_inv_3 = 0xAAAAAAAAAAAAAAAB;\n\n    while (svptest_any(svptrue_b64(), pg)) {\n        svuint64_t indices = svindex_u64(i, 1);\n        svuint64_t div = svmulh_u64_x(pg, indices, svdup_u64(mod_inv_3));\n        svuint64_t residues = svmls_u64_x(pg, indices, div, svdup_u64(3));\n\n        r0 += svcntp_b64(svptrue_b64(), svcmpeq_u64(pg, residues, 0));\n        r1 += svcntp_b64(svptrue_b64(), svcmpeq_u64(pg, residues, 1));\n        r2 += svcntp_b64(svptrue_b64(), svcmpeq_u64(pg, residues, 2));\n\n        uint64_t vl = svcntp_b64(svptrue_b64(), pg);\n        i += vl;\n        pg = svwhilelt_b64(i, n + 1);\n    }\n\n    uint64_t group0 = r2;\n    uint64_t group1 = r0 + r1;\n\n    uint64_t ans = 0;\n    if (group0 >= 3) {\n        __uint128_t t = (__uint128_t)group0 * (group0 - 1);\n        t = t * (group0 - 2);\n        t /= 6;\n        ans += (uint64_t)t;\n    }\n    if (group1 >= 3) {\n        __uint128_t t = (__uint128_t)group1 * (group1 - 1);\n        t = t * (group1 - 2);\n        t /= 6;\n        ans += (uint64_t)t;\n    }\n\n    return ans;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n#include <stdint.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n    \n    int max_divisor = sqrt(n);\n    if (max_divisor < 3) {\n        return x;\n    }\n    \n    uint64_t vl = svcntw();\n    int start = 3;\n    while (start <= max_divisor) {\n        int num_left = (max_divisor - start) / 2 + 1;\n        int num_in_this_loop = num_left > (int)vl ? (int)vl : num_left;\n        \n        svbool_t pg = svwhilelt_b32(0, num_in_this_loop);\n        svint32_t index_vec = svindex_s32(0, 1);\n        svint32_t divisor_vec = svadd_s32_z(pg, svdup_s32(start), svmul_n_s32_z(pg, index_vec, 2));\n        \n        svfloat64_t d_dvec = svcvt_f64_s32_z(pg, divisor_vec);\n        svfloat64_t n_dvec = svdup_f64((double)n);\n        svfloat64_t quot_d = svdiv_f64_z(pg, n_dvec, d_dvec);\n        svint32_t quot_i = svcvt_s32_f64_z(pg, quot_d);\n        \n        svint32_t product = svmul_s32_z(pg, divisor_vec, quot_i);\n        svint32_t rem_vec = svsub_s32_z(pg, svdup_s32(n), product);\n        \n        svbool_t is_zero = svcmpeq_s32(pg, rem_vec, 0);\n        if (svptest_any(svptrue_b32(), is_zero)) {\n            return y;\n        }\n        \n        start += 2 * num_in_this_loop;\n    }\n    \n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) \n        return y;\n    if (n == 2) \n        return x;\n    if (n % 2 == 0) \n        return y;\n\n    int limit = (int)sqrt(n) + 1;\n    int base = 3;\n    uint32_t vl = svcntw();\n    svbool_t pg = svptrue_b32();\n\n    while (base <= limit) {\n        svint32_t index = svindex_s32(0, 1);\n        svint32_t step = svmul_s32_x(pg, index, svdup_s32(2));\n        svint32_t div_vec = svadd_s32_x(pg, svdup_s32(base), step);\n        svbool_t in_bound = svcmple_s32(pg, div_vec, svdup_s32(limit));\n\n        if (svptest_any(pg, in_bound) == 0) \n            break;\n\n        int32_t divisors[vl];\n        for (uint32_t i = 0; i < vl; i++) \n            divisors[i] = limit + 1;\n        \n        svst1_s32(in_bound, divisors, div_vec);\n\n        for (uint32_t i = 0; i < vl; i++) {\n            if (divisors[i] > limit) \n                break;\n            if (n % divisors[i] == 0) \n                return y;\n        }\n        base += 2 * vl;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h> \n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) \n        return y;\n    if (n == 2) \n        return x;\n    if (n % 2 == 0) \n        return y;\n\n    uint32_t un = (uint32_t)n;\n    uint32_t sqrt_n_val = 0;\n    if (un > 0) {\n        uint32_t lo = 1, hi = un;\n        while (lo <= hi) {\n            uint32_t mid = lo + (hi - lo) / 2;\n            if (mid <= un / mid) {\n                lo = mid + 1;\n                sqrt_n_val = mid;\n            } else {\n                hi = mid - 1;\n            }\n        }\n    }\n\n    uint32_t vl = svcntw();\n    uint32_t base = 3;\n\n    while (base <= sqrt_n_val) {\n        svuint32_t index = svindex_u32(0, 1);\n        svuint32_t divs = svadd_u32_z(svptrue_b32(), svdup_u32(base), svmul_u32_z(svptrue_b32(), index, svdup_u32(2)));\n        uint32_t divisors[vl];\n        svst1_u32(svptrue_b32(), divisors, divs);\n\n        for (uint32_t i = 0; i < vl; i++) {\n            uint32_t d = divisors[i];\n            if (d > sqrt_n_val) \n                break;\n            if (un % d == 0) \n                return y;\n        }\n        base += 2 * vl;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n#include <math.h>\n#include <stdint.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) {\n        return y;\n    }\n    if (n == 2) {\n        return x;\n    }\n    if (n % 2 == 0) {\n        return y;\n    }\n    int limit = (int)sqrt((double)n) + 1;\n    uint64_t vl = svcntw();\n    int base = 3;\n    while (base < limit) {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t divs = svmla_s32_z(svptrue_b32(), svdup_s32(base), indices, svdup_s32(2));\n        svbool_t pg = svcmple_s32(svptrue_b32(), divs, svdup_s32(limit));\n        uint64_t num_active = svcntp_b32(svptrue_b32(), pg);\n        if (num_active == 0) {\n            base += 2 * vl;\n            continue;\n        }\n        int32_t divisors[vl];\n        svst1_s32(pg, divisors, divs);\n        for (uint64_t i = 0; i < num_active; i++) {\n            if (n % divisors[i] == 0) {\n                return y;\n            }\n        }\n        base += 2 * vl;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133_SVE", "completion": "```c\n#include <arm_sve.h>\n\nint x_or_y_simd(int n, int x, int y) {\n    if (n <= 1) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n\n    long long lo = 1;\n    long long hi = n;\n    while (lo <= hi) {\n        long long mid = (lo + hi) / 2;\n        if (mid * mid <= (long long)n) {\n            lo = mid + 1;\n        } else {\n            hi = mid - 1;\n        }\n    }\n    int limit = (int)(lo - 1);\n\n    uint32_t base = 3;\n    uint32_t vl = svcntw();\n    uint32_t step = 2 * vl;\n\n    while (base <= limit) {\n        svint32_t indices = svindex_s32(0, 1);\n        svint32_t divs = svadd_s32_z(svptrue_b32(), svdup_s32(base), svmul_s32_z(svptrue_b32(), indices, svdup_s32(2)));\n        svbool_t pg = svcmple_s32(svptrue_b32(), divs, svdup_s32(limit));\n\n        if (svptest_any(svptrue_b32(), pg)) {\n            svint32_t n_vec = svdup_s32(n);\n            svint32_t quot = svdiv_s32_z(pg, n_vec, divs);\n            svint32_t rem = svsub_s32_z(pg, n_vec, svmul_s32_z(pg, quot, divs));\n            svbool_t zero_rem = svcmpeq_s32(pg, rem, svdup_s32(0));\n            if (svptest_any(svptrue_b32(), zero_rem)) {\n                return y;\n            }\n        }\n        base += step;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    size_t n = lst.size();\n    if (n == 0) {\n        return 0;\n    }\n    uint64_t total = 0;\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t x = svld1_f32(pg, &lst[i]);\n        svbool_t mask1 = svcmpge(pg, x, svdup_f32(0.0f));\n        svfloat32_t truncated = svrintm_f32_x(pg, x);\n        svbool_t mask2 = svcmpeq(pg, x, truncated);\n        svbool_t pg_valid = svand_b_z(pg, mask1, mask2);\n        svint64_t int64_vec = svcvt_s64_f32_x(pg_valid, x);\n        svuint64_t u64_vec = svreinterpret_u64_s64(int64_vec);\n        svuint64_t sq_vec = svmul_u64_x(pg_valid, u64_vec, u64_vec);\n        svuint64_t lsb = svand_u64_x(pg_valid, u64_vec, svdup_u64(1));\n        svbool_t pg_odd = svcmpeq(pg_valid, lsb, svdup_u64(1));\n        svuint64_t result_vec = svdup_u64(0);\n        result_vec = svsel_u64(pg_odd, sq_vec, result_vec);\n        total += svaddv_u64(pg, result_vec);\n        i += svcntw();\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n    unsigned int vl = svcntw();\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t vec = svld1(pg, &lst[i]);\n        i += vl;\n\n        svbool_t p_pos = svcmpgt(pg, vec, 0.0f);\n        svint32_t int_vec = svcvt_s32_z(pg, vec);\n        svfloat32_t int_vec_f = svcvt_f32_z(pg, int_vec);\n        svbool_t p_int = svcmpeq(pg, vec, int_vec_f);\n        svbool_t p_valid = svand_z(pg, p_pos, p_int);\n\n        svint32_t mod2 = svand_s32_z(p_valid, int_vec, 1);\n        svbool_t p_odd = svcmpne(pg, mod2, 0);\n        svbool_t p_include = svand_z(pg, p_valid, p_odd);\n\n        svuint64_t wide = svcvt_u64_z(p_include, svreinterpret_u32_s32(int_vec));\n        svuint64_t squares = svmul_u64_z(p_include, wide, wide);\n        uint64_t sum_part = svaddv_u64(svptrue_b64(), squares);\n\n        sum += sum_part;\n        pg = svwhilelt_b32(i, n);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    uint64_t n = lst.size();\n    if (n == 0) \n        return 0;\n\n    uint64_t total_sum = 0;\n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t input = svld1_f32(pg, &lst[i]);\n        svbool_t p_positive = svcmpge(pg, input, svdup_n_f32(0.0f));\n        svint32_t int_x = svcvt_s32_z(p_positive, input);\n        svfloat32_t int_x_float = svcvt_f32_s32_x(pg, int_x);\n        svbool_t p_int = svcmpeq(pg, input, int_x_float);\n        svbool_t p_valid = svand_b_z(pg, p_positive, p_int);\n        svint32_t mod2 = svand_s32_x(pg, int_x, svdup_s32(1));\n        svbool_t p_odd = svcmpne(pg, mod2, svdup_s32(0));\n        svbool_t p_valid_and_odd = svand_b_z(pg, p_valid, p_odd);\n        svuint64_t wide_x = svcvt_u64_s32_x(p_valid_and_odd, int_x);\n        svuint64_t square = svmul_u64_x(p_valid_and_odd, wide_x, wide_x);\n        uint64_t segment_sum = svaddv_u64(p_valid_and_odd, square);\n        total_sum += segment_sum;\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return total_sum;\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n\nuint64_t double_the_difference_simd(const std::vector<float> & lst){\n    if (lst.empty()) \n        return 0;\n\n    double total = 0.0;\n    uint64_t i = 0;\n    uint64_t size = lst.size();\n    svbool_t pg = svwhilelt_b32(i, size);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svfloat32_t input = svld1_f32(pg, &lst[i]);\n\n        svbool_t pos_mask = svcmpgt(pg, input, 0.0f);\n        svfloat32_t int_part = svrintz_f32_x(pg, input);\n        svbool_t int_mask = svcmpeq(pg, input, int_part);\n        svint32_t int_val = svcvt_s32_x(pg, int_part);\n        svuint32_t and_val = svand_x(pg, svreinterpret_u32(int_val), 1);\n        svbool_t odd_mask = svcmpne(pg, and_val, svdup_n_u32(0));\n\n        svbool_t combined_mask = svand_b_z(pg, pos_mask, svand_b_z(pg, int_mask, odd_mask));\n        svfloat32_t squares = svmul_f32_x(pg, input, input);\n        float segment_sum = svaddv_f32(combined_mask, squares);\n        total += (double)segment_sum;\n\n        i += svcntw();\n        pg = svwhilelt_b32(i, size);\n    }\n    return (uint64_t)(total + 0.5);\n}\n```"}
{"task_id": "SimdBench_134_SVE", "completion": "```cpp\n#include <arm_sve.h> \n#include <vector>\n#include <cstdint>\n#include <climits>\n\nuint64_t double_the_difference_simd(const std::vector<float> & lst) {\n    if (lst.empty()) {\n        return 0;\n    }\n    \n    uint64_t sum = 0;\n    size_t n = lst.size();\n    size_t i = 0;\n    const size_t max_vl = svcntw();\n    int32_t arr[64]; // Maximum possible SVE vector length (2048 bits) / 32 = 64 elements\n\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svfloat32_t v = svld1_f32(pg, &lst[i]);\n        i += svcntp_b32(pg, pg);\n\n        svbool_t non_negative = svcmpge(pg, v, svdup_n_f32(0.0f));\n        svfloat32_t truncated = svrintz_f32_x(pg, v);\n        svbool_t is_integer = svcmpeq(pg, v, truncated);\n        svbool_t valid = svand_b_z(pg, non_negative, is_integer);\n        \n        svint32_t vi = svcvt_s32_f32_x(valid, v);\n        svint32_t vi_lsb = svand_s32_x(valid, vi, svdup_n_s32(1));\n        svbool_t is_odd = svcmpne(valid, vi_lsb, svdup_n_s32(0));\n        svbool_t valid_and_odd = is_odd;\n        \n        uint32_t count = svcntp_b32(valid_and_odd, valid_and_odd);\n        if (count > 0) {\n            svst1_s32(valid_and_odd, arr, vi);\n            for (uint32_t j = 0; j < count; j++) {\n                int32_t val = arr[j];\n                uint64_t square = static_cast<uint64_t>(val) * static_cast<uint64_t>(val);\n                sum += square;\n            }\n        }\n    }\n    \n    return sum;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> result(n);\n    if (n == 0) {\n        return result;\n    }\n\n    const int* game_data = game.data();\n    const int* guess_data = guess.data();\n    int* res_data = result.data();\n\n    uint64_t vl = svcntw();\n    int64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t game_vec = svld1_s32(pg, game_data + i);\n        svint32_t guess_vec = svld1_s32(pg, guess_data + i);\n        svint32_t diff_vec = svabd_s32_z(pg, game_vec, guess_vec);\n        svst1_s32(pg, res_data + i, diff_vec);\n        \n        i += vl;\n        pg = svwhilelt_b32(i, n);\n    }\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> result(n);\n    if (n == 0) return result;\n\n    uint64_t vl = svcntw();\n    uint64_t i = 0;\n    do {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        svint32_t diff = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_s32_z(pg, diff);\n        svst1_s32(pg, &result[i], abs_diff);\n        i += vl;\n    } while (i < n);\n\n    return result;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cstdint>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    int n = game.size();\n    std::vector<int> res(n);\n    if (n == 0) {\n        return res;\n    }\n\n    uint64_t vl = svcntw();\n    int i = 0;\n    do {\n        svbool_t pg = svwhilelt_b32(i, n);\n        svint32_t va = svld1_s32(pg, &game[i]);\n        svint32_t vb = svld1_s32(pg, &guess[i]);\n        svint32_t vdiff = svabs_s32_x(pg, svsub_s32_x(pg, va, vb));\n        svst1_s32(pg, &res[i], vdiff);\n        i += vl;\n    } while (i < n);\n\n    return res;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n#include <cmath>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> res(n);\n    \n    uint64_t i = 0;\n    svbool_t pg = svwhilelt_b32(i, n);\n    while (svptest_any(svptrue_b32(), pg)) {\n        svint32_t game_vec = svld1(pg, &game[i]);\n        svint32_t guess_vec = svld1(pg, &guess[i]);\n        svint32_t diff = svsub_z(pg, game_vec, guess_vec);\n        svint32_t abs_diff = svabs_z(pg, diff);\n        svst1(pg, &res[i], abs_diff);\n        i += svcntw();\n        pg = svwhilelt_b32(i, n);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_135_SVE", "completion": "```cpp\n#include <arm_sve.h>\n#include <vector>\n\nstd::vector<int> compare_simd(const std::vector<int>& game, const std::vector<int>& guess) {\n    size_t n = game.size();\n    std::vector<int> res(n);\n    size_t i = 0;\n    while (i < n) {\n        svbool_t pg = svwhilelt_b32_u64(i, n);\n        svint32_t game_vec = svld1_s32(pg, &game[i]);\n        svint32_t guess_vec = svld1_s32(pg, &guess[i]);\n        svint32_t diff_vec = svsub_s32_z(pg, game_vec, guess_vec);\n        svint32_t abs_vec = svabs_s32_z(pg, diff_vec);\n        svst1_s32(pg, &res[i], abs_vec);\n        i += svcntp_b32(pg, pg);\n    }\n    return res;\n}\n```"}

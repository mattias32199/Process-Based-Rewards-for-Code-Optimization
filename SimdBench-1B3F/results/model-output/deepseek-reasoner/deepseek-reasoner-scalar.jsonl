{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_0", "completion": "```c\nvoid conditional_move(const int64_t *src, int64_t *dst, const bool *mask, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (mask[i]) {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int x = src[i] * scale;\n        int tmp1 = x >> 3;\n        int tmp2 = x * 8;\n        int total = x + tmp1 * tmp2;\n        dst[i] = total / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t base = (int64_t)src[i] * (int64_t)scale;\n        int64_t tmp1 = base >> 3;\n        int64_t tmp2 = base << 3;\n        int64_t total = base + tmp1 * tmp2;\n        dst[i] = (int32_t)(total / 7);\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int x = src[i] * scale;\n        int tmp1 = x >> 3;\n        int tmp2 = x << 3;\n        int numerator = x + tmp1 * tmp2;\n        dst[i] = numerator / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int M = src[i] * scale;\n        int tmp1 = M >> 3;\n        int tmp2 = M * 8;\n        int product = tmp1 * tmp2;\n        int total = M + product;\n        dst[i] = total / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_1", "completion": "```c\nvoid load_modify_store(const int *src, int *dst, int scale, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int base = src[i] * scale;\n        int tmp1 = base >> 3;\n        int tmp2 = base * 8;\n        int numerator = base + tmp1 * tmp2;\n        dst[i] = numerator / 7;\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_2", "completion": "```c\nvoid strided_load_store(const double *src, double *dst, size_t rows, size_t cols, size_t stride) {\n    for (size_t r = 0; r < rows; r++) {\n        dst[r] = src[r * cols + stride];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_3", "completion": "```c\nvoid indexed_access(const float *src, const int *indices, float *dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[indices[i]];\n    }\n    for (size_t i = 0; i < length; i++) {\n        dst[indices[i]] = src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_4", "completion": "```c\nvoid range_reverse(int16_t *arr, uint64_t start, uint64_t end) {\n    while (start < end) {\n        int16_t temp = arr[start];\n        arr[start] = arr[end];\n        arr[end] = temp;\n        start++;\n        end--;\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            size_t src_idx = i * dim2 * dim3 + j * dim3 + slice_idx;\n            size_t dst_idx = i * dim2 + j;\n            slice[dst_idx] = tensor[src_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    uint8_t *dest = slice;\n    for (size_t i = 0; i < dim1; i++) {\n        const uint8_t *src = tensor + i * dim2 * dim3 + slice_idx;\n        for (size_t j = 0; j < dim2; j++) {\n            *dest++ = *src;\n            src += dim3;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    const uint8_t *src = tensor + slice_idx;\n    for (size_t i = 0; i < dim1; i++) {\n        for (size_t j = 0; j < dim2; j++) {\n            *slice++ = *src;\n            src += dim3;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    size_t slice_size = dim1 * dim2;\n    size_t layer_size = dim2 * dim3;\n    for (size_t i = 0; i < dim1; i++) {\n        size_t tensor_offset = i * layer_size;\n        size_t slice_offset = i * dim2;\n        for (size_t j = 0; j < dim2; j++) {\n            slice[slice_offset + j] = tensor[tensor_offset + j * dim3 + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_5", "completion": "```c\nvoid extract_tensor_slice(const uint8_t *tensor, uint8_t *slice, size_t dim1, size_t dim2, size_t dim3, size_t slice_idx) {\n    for (size_t i = 0; i < dim1; i++) {\n        size_t base_tensor = i * dim2 * dim3;\n        size_t base_slice = i * dim2;\n        for (size_t j = 0; j < dim2; j++) {\n            slice[base_slice + j] = tensor[base_tensor + j * dim3 + slice_idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t end_i = i + block_size < rows ? i + block_size : rows;\n            size_t end_j = j + block_size < cols ? j + block_size : cols;\n            for (size_t ii = i; ii < end_i; ii++) {\n                for (size_t jj = j; jj < end_j; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_end = i + block_size;\n        if (i_end > rows) {\n            i_end = rows;\n        }\n        size_t block_cols = i_end - i;\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_end = j + block_size;\n            if (j_end > cols) {\n                j_end = cols;\n            }\n            size_t block_rows = j_end - j;\n            if (block_rows == 0 || block_cols == 0) {\n                continue;\n            }\n            int16_t temp[block_cols * block_rows];\n            for (size_t r = i, r_idx = 0; r < i_end; r++, r_idx++) {\n                for (size_t c = j, c_idx = 0; c < j_end; c++, c_idx++) {\n                    temp[r_idx * block_rows + c_idx] = src[r * cols + c];\n                }\n            }\n            for (size_t dr = 0; dr < block_rows; dr++) {\n                for (size_t dc = 0; dc < block_cols; dc++) {\n                    dst[(j + dr) * rows + (i + dc)] = temp[dc * block_rows + dr];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t block_height = (i + block_size <= rows) ? block_size : rows - i;\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t block_width = (j + block_size <= cols) ? block_size : cols - j;\n            for (size_t c = j; c < j + block_width; c++) {\n                for (size_t r = i; r < i + block_height; r++) {\n                    dst[c * rows + r] = src[r * cols + c];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t end_i = (i + block_size) < rows ? (i + block_size) : rows;\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t end_j = (j + block_size) < cols ? (j + block_size) : cols;\n            for (size_t ii = i; ii < end_i; ii++) {\n                for (size_t jj = j; jj < end_j; jj++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_6", "completion": "```c\nvoid blocked_matrix_transpose(const int16_t *src, int16_t *dst, size_t rows, size_t cols, size_t block_size) {\n    for (size_t i = 0; i < rows; i += block_size) {\n        size_t i_block_end = (i + block_size) < rows ? (i + block_size) : rows;\n        for (size_t j = 0; j < cols; j += block_size) {\n            size_t j_block_end = (j + block_size) < cols ? (j + block_size) : cols;\n            for (size_t jj = j; jj < j_block_end; jj++) {\n                for (size_t ii = i; ii < i_block_end; ii++) {\n                    dst[jj * rows + ii] = src[ii * cols + jj];\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    const size_t step = dim * dim + dim + 1;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * step];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t step = dim * dim + dim + 1;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * step];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    const size_t step = dim * dim + dim + 1;\n    for (size_t i = 0, idx = 0; i < dim; i++, idx += step) {\n        sum += array[idx];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t step = dim * dim + dim + 1;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * step];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_7", "completion": "```c\nfloat diagonal_sum_3d(const float *array, size_t dim) {\n    float sum = 0.0f;\n    size_t step = dim * dim + dim + 1;\n    for (size_t i = 0; i < dim; i++) {\n        sum += array[i * step];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```cpp\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = (src[i] > threshold) ? (src[i] * scale) : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = src[i] > threshold ? src[i] * scale : src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; ++i) {\n        if (src[i] > threshold) {\n            dst[i] = src[i] * scale;\n        } else {\n            dst[i] = src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_8", "completion": "```c\nvoid conditional_scale(const double *src, double *dst, size_t rows, size_t cols, double threshold, double scale) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; i++) {\n        double value = src[i];\n        dst[i] = (value > threshold) ? value * scale : value;\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        const double *src_row = src + indices[i] * cols;\n        double *dst_row = dst + i * cols;\n        for (size_t j = 0; j < cols; j++) {\n            dst_row[j] = src_row[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    size_t total = rows * cols;\n    double *temp = (double *)malloc(total * sizeof(double));\n    if (temp == NULL) {\n        for (size_t i = 0; i < rows; i++) {\n            size_t src_row = indices[i];\n            for (size_t j = 0; j < cols; j++) {\n                dst[i * cols + j] = src[src_row * cols + j];\n            }\n        }\n        return;\n    }\n    memcpy(temp, src, total * sizeof(double));\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        memcpy(dst + i * cols, temp + src_row * cols, cols * sizeof(double));\n    }\n    free(temp);\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        for (size_t j = 0; j < cols; j++) {\n            dst[i * cols + j] = src[src_row * cols + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i] * cols;\n        size_t dst_row = i * cols;\n        for (size_t j = 0; j < cols; j++) {\n            dst[dst_row + j] = src[src_row + j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_9", "completion": "```c\nvoid reorder_matrix_rows(const double *src, double *dst, size_t rows, size_t cols, const size_t *indices) {\n    for (size_t i = 0; i < rows; i++) {\n        size_t src_row = indices[i];\n        const double *src_start = src + src_row * cols;\n        double *dst_start = dst + i * cols;\n        for (size_t j = 0; j < cols; j++) {\n            dst_start[j] = src_start[j];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_10", "completion": "```c\nvoid vector_vector_add(const int64_t *src1, const int64_t *src2, int64_t *dst, int64_t scalar, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (src1[i] + src2[i] + scalar) / 2;\n    }\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    int min_val = src[0];\n    for (size_t i = 2; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    int min = src[0];\n    for (size_t i = 2; i < length; i += 2) {\n        if (src[i] < min) {\n            min = src[i];\n        }\n    }\n    return min;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    int min_val = src[0];\n    for (size_t i = 2; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length){\n    if (length == 0) return -1;\n    int min_val = src[0];\n    for (size_t i = 2; i < length; i += 2) {\n        if (src[i] < min_val) {\n            min_val = src[i];\n        }\n    }\n    return min_val;\n}\n```"}
{"task_id": "SimdBench_11", "completion": "```c\nint vector_even_min(const int *src, size_t length) {\n    if (length == 0) {\n        return -1;\n    }\n    int min = src[0];\n    for (size_t i = 2; i < length; i += 2) {\n        if (src[i] < min) {\n            min = src[i];\n        }\n    }\n    return min;\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int32_t val = src[i];\n        int32_t arith_shift = val >> shift;\n        uint32_t u_val = (uint32_t)val;\n        int32_t logical_shift = (int32_t)(u_val >> shift);\n        dst[i] = arith_shift + logical_shift;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    if (shift > 31) {\n        shift = 31;\n    }\n    for (size_t i = 0; i < length; i++) {\n        int val = src[i];\n        int arith = val >> shift;\n        unsigned int u_val = (unsigned int)val;\n        int logical = (int)(u_val >> shift);\n        dst[i] = arith + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    if (shift >= 32) {\n        for (size_t i = 0; i < length; i++) {\n            dst[i] = (src[i] < 0) ? -1 : 0;\n        }\n    } else {\n        for (size_t i = 0; i < length; i++) {\n            int arith = src[i] >> shift;\n            unsigned int u = (unsigned int)src[i];\n            int logic = (int)(u >> shift);\n            dst[i] = arith + logic;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    if (shift >= 32) {\n        for (size_t i = 0; i < length; i++) {\n            dst[i] = (src[i] < 0) ? -1 : 0;\n        }\n    } else {\n        for (size_t i = 0; i < length; i++) {\n            int val = src[i];\n            int a = val >> shift;\n            unsigned int u = (unsigned int)val;\n            int b = (int)(u >> shift);\n            dst[i] = a + b;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_12", "completion": "```c\n#include <stdint.h>\n\nvoid mixed_right_shift(const int *src, int *dst, uint8_t shift, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int arith;\n        if (shift >= 32) {\n            arith = (src[i] < 0) ? -1 : 0;\n        } else {\n            arith = src[i] >> shift;\n        }\n        \n        uint32_t temp = (uint32_t)src[i];\n        if (shift >= 32) {\n            temp = 0;\n        } else {\n            temp = temp >> shift;\n        }\n        int logical = (int)temp;\n        \n        dst[i] = arith + logical;\n    }\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        total += matrix[i];\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t size = rows * cols;\n    for (size_t i = 0; i < size; i++) {\n        total += matrix[i];\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t total = 0;\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; i++) {\n        total += matrix[i];\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; i++) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_13", "completion": "```c\n#include <stdint.h>\n\nint64_t matrix_sum(const int *matrix, size_t rows, size_t cols) {\n    int64_t sum = 0;\n    size_t total_elements = rows * cols;\n    for (size_t i = 0; i < total_elements; ++i) {\n        sum += matrix[i];\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    int8_t max_val = src[0];\n    size_t max_idx = 0;\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) return 0;\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    size_t max_index = 0;\n    int8_t max_value = src[0];\n    for (size_t i = 1; i < length; i++) {\n        if (src[i] > max_value) {\n            max_value = src[i];\n            max_index = i;\n        }\n    }\n    return max_index;\n}\n```"}
{"task_id": "SimdBench_14", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t argmax(const int8_t *src, size_t length) {\n    if (length == 0) {\n        return 0;\n    }\n    int8_t max_val = src[0];\n    size_t max_idx = 0;\n    for (size_t i = 1; i < length; ++i) {\n        if (src[i] > max_val) {\n            max_val = src[i];\n            max_idx = i;\n        }\n    }\n    return max_idx;\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if ((i & mask) != 0) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = ((uint32_t)i & mask) ? src1[i] : src2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_15", "completion": "```c\nvoid vector_blend(const uint16_t* src1, const uint16_t* src2, uint32_t mask, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i & (size_t)mask) {\n            dst[i] = src1[i];\n        } else {\n            dst[i] = src2[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    static const uint8_t table[256] = {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n    \n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        dst[i] = table[x & 0xFF] +\n                 table[(x >> 8) & 0xFF] +\n                 table[(x >> 16) & 0xFF] +\n                 table[(x >> 24) & 0xFF];\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    static const uint8_t lookup[256] = {\n        0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,\n        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n        1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,\n        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n        2,3,3,4,3,4,4,5,3,4,4,5,4,5,5,6,3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,\n        3,4,4,5,4,5,5,6,4,5,5,6,5,6,6,7,4,5,5,6,5,6,6,7,5,6,6,7,6,7,7,8\n    };\n    \n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        dst[i] = lookup[value & 0xFF] +\n                 lookup[(value >> 8) & 0xFF] +\n                 lookup[(value >> 16) & 0xFF] +\n                 lookup[value >> 24];\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    static const uint8_t table[256] = {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        dst[i] = table[x & 0xFF] + \n                 table[(x >> 8) & 0xFF] + \n                 table[(x >> 16) & 0xFF] + \n                 table[(x >> 24) & 0xFF];\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    static const uint8_t table[256] = {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n    \n    for (size_t i = 0; i < length; i++) {\n        dst[i] = table[(src[i] >>  0) & 0xFF] +\n                 table[(src[i] >>  8) & 0xFF] +\n                 table[(src[i] >> 16) & 0xFF] +\n                 table[(src[i] >> 24) & 0xFF];\n    }\n}\n```"}
{"task_id": "SimdBench_16", "completion": "```c\nvoid population_count(const uint32_t* src, uint32_t* dst, size_t length) {\n    static const uint8_t lookup[256] = {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n    \n    for (size_t i = 0; i < length; i++) {\n        uint32_t value = src[i];\n        dst[i] = lookup[value & 0xFF] +\n                 lookup[(value >> 8) & 0xFF] +\n                 lookup[(value >> 16) & 0xFF] +\n                 lookup[(value >> 24) & 0xFF];\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : (uint16_t)sum;\n    }\n}\n```"}
{"task_id": "SimdBench_17", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid saturating_add(const uint16_t* src1, const uint16_t* src2, uint16_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        uint32_t sum = (uint32_t)src1[i] + (uint32_t)src2[i];\n        dst[i] = sum > UINT16_MAX ? UINT16_MAX : sum;\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; ++i) {\n        for (size_t j = 0; j < p; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; ++k) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_18", "completion": "```c\nvoid range_matrix_mul(const double* A, const double* B, double* C, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                double a_val = A[i * n + k];\n                double b_val = B[k * p + j];\n                if (a_val >= -100.0 && a_val <= 100.0 && b_val >= -100.0 && b_val <= 100.0) {\n                    sum += a_val * b_val;\n                }\n            }\n            C[i * p + j] = sum;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total; ++idx) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; ++i) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total; ++idx) {\n        C[idx] = A[idx] + B[idx];\n    }\n}\n```"}
{"task_id": "SimdBench_19", "completion": "```c\nvoid tensor_add_3d(const int64_t* A, const int64_t* B, int64_t* C, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; i++) {\n        C[i] = A[i] + B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (float)(int)(src1[i] + src2[i] + (src1[i] + src2[i] >= 0 ? 0.5f : -0.5f));\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```cpp\n#include <cmath>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = roundf(src1[i] + src2[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_20", "completion": "```c\n#include <math.h>\n\nvoid vector_add_round_nearest(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        float sum = src1[i] + src2[i];\n        dst[i] = roundf(sum);\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n#include <cstddef>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            float product = src1[i] * src2[i];\n            dst[i] = std::ceil(product);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```cpp\n#include <cmath>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (i % 2 == 0 && std::fabs(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = std::ceil(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_21", "completion": "```c\n#include <math.h>\n\nvoid vector_mul_round_up(const float* src1, const float* src2, float* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (i % 2 == 0 && fabsf(src1[i] - src2[i]) <= 50.0f) {\n            dst[i] = ceilf(src1[i] * src2[i]);\n        } else {\n            dst[i] = -1.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; i++) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_22", "completion": "```c\nvoid matrix_scalar_mul(const double* mat, double scalar, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat[i] * scalar;\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sq_sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sq_sum += val * val;\n        }\n        float norm = sqrtf(sq_sum);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float sq_sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = row[j];\n            sq_sum += val * val;\n        }\n        float norm = sqrtf(sq_sum);\n        if (norm > 1e-8f) {\n            for (size_t j = 0; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_sq = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[i * n + j];\n            sum_sq += val * val;\n        }\n        float norm = sqrtf(sum_sq);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[i * n + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float* row = mat + i * n;\n        float sum_sq = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum_sq += row[j] * row[j];\n        }\n        float norm = sqrtf(sum_sq);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                row[j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_23", "completion": "```c\nvoid matrix_normalize_rows(float* mat, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum_sq = 0.0f;\n        size_t row_start = i * n;\n        for (size_t j = 0; j < n; j++) {\n            float val = mat[row_start + j];\n            sum_sq += val * val;\n        }\n        float norm = sqrtf(sum_sq);\n        if (norm != 0.0f) {\n            for (size_t j = 0; j < n; j++) {\n                mat[row_start + j] /= norm;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t k = 0; k < p; k++) {\n            double sum = 0.0;\n            for (size_t j = 0; j < n; j++) {\n                sum += mat1[i * n + j] * mat2[j * p + k];\n            }\n            dst[i * p + k] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\n#include <math.h>\n\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = round(sum);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = (double)((long long)(sum + (sum >= 0 ? 0.5 : -0.5)));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_24", "completion": "```c\nvoid matrix_mul_round_int(const double* mat1, const double* mat2, double* dst, size_t m, size_t n, size_t p) {\n    for (size_t i = 0; i < m; i++) {\n        for (size_t j = 0; j < p; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < n; k++) {\n                sum += mat1[i * n + k] * mat2[k * p + j];\n            }\n            dst[i * p + j] = (double)((long long)(sum + (sum >= 0 ? 0.5 : -0.5)));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            dst[j * rows + i] = roundf(val * 4.0f) / 4.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float value = src[i * cols + j];\n            float rounded = roundf(value * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            dst[j * rows + i] = roundf(src[i * cols + j] * 4.0f) * 0.25f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_25", "completion": "```c\n#include <math.h>\n\nvoid matrix_transpose_round_quarter(const float* src, float* dst, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols; ++j) {\n            float val = src[i * cols + j];\n            float rounded = roundf(val * 4.0f) / 4.0f;\n            dst[j * rows + i] = rounded;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\n#include <cmath>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = std::trunc(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        union {\n            float f;\n            unsigned int i;\n        } u;\n        u.f = diff;\n        unsigned int i_val = u.i;\n        unsigned int sign = i_val & 0x80000000;\n        unsigned int abs_val = i_val & 0x7FFFFFFF;\n        unsigned int exponent_field = (abs_val >> 23) & 0xFF;\n        \n        if (exponent_field == 0xFF) {\n            dst[i] = diff;\n        } else {\n            int exponent = exponent_field - 127;\n            if (exponent >= 23) {\n                dst[i] = diff;\n            } else if (exponent < 0) {\n                u.i = sign;\n                dst[i] = u.f;\n            } else {\n                unsigned int mask = (0x007FFFFF) >> exponent;\n                if ((abs_val & mask) == 0) {\n                    dst[i] = diff;\n                } else {\n                    abs_val &= ~mask;\n                    u.i = sign | abs_val;\n                    dst[i] = u.f;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\n#include <cmath>\n\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; ++i) {\n        float diff = tensor1[i] - tensor2[i];\n        dst[i] = std::truncf(diff);\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```cpp\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; ++i) {\n        float x = tensor1[i] - tensor2[i];\n        if (x > -16777216.0f && x < 16777216.0f) {\n            dst[i] = static_cast<float>(static_cast<long long>(x));\n        } else {\n            dst[i] = x;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_26", "completion": "```c\nvoid tensor3d_sub_round_zero(const float* tensor1, const float* tensor2, float* dst, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    const float trunc_limit_positive = 16777216.0f;\n    const float trunc_limit_negative = -16777216.0f;\n    \n    for (size_t i = 0; i < total; i++) {\n        float diff = tensor1[i] - tensor2[i];\n        if (diff != diff) {\n            dst[i] = diff;\n        } else if (diff >= trunc_limit_positive || diff <= trunc_limit_negative) {\n            dst[i] = diff;\n        } else {\n            dst[i] = (float)((long long)(diff));\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t idx = 0; idx < total; idx++) {\n        dst[idx] = mat1[idx] * mat2[idx];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        dst[i] = mat1[i] * mat2[i];\n    }\n}\n```"}
{"task_id": "SimdBench_27", "completion": "```c\nvoid matrix_hadamard_product(const double* mat1, const double* mat2, double* dst, size_t m, size_t n) {\n    size_t total_elements = m * n;\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        dst[idx] = mat1[idx] * mat2[idx];\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        const float* row_ptr = mat + i * n;\n        const float* vec_ptr = vec;\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += *row_ptr++ * *vec_ptr++;\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; i++) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; j++) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_28", "completion": "```c\nvoid matrix_vector_mul(const float* mat, const float* vec, float* dst, size_t m, size_t n) {\n    for (size_t i = 0; i < m; ++i) {\n        float sum = 0.0f;\n        for (size_t j = 0; j < n; ++j) {\n            sum += mat[i * n + j] * vec[j];\n        }\n        dst[i] = sum;\n    }\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    size_t total = m * n;\n    double sum = 0.0;\n    for (size_t i = 0; i < total; i++) {\n        sum += mat[i];\n    }\n    return sum / total;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total = m * n;\n    for (size_t i = 0; i < total; ++i) {\n        sum += mat[i];\n    }\n    return sum / total;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total = m * n;\n    for (size_t i = 0; i < total; i++) {\n        sum += mat[i];\n    }\n    return sum / total;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total = m * n;\n    for (size_t i = 0; i < total; i++) {\n        sum += mat[i];\n    }\n    return sum / (double)total;\n}\n```"}
{"task_id": "SimdBench_29", "completion": "```c\ndouble matrix_average(const double* mat, size_t m, size_t n) {\n    double sum = 0.0;\n    size_t total = m * n;\n    for (size_t i = 0; i < total; i++) {\n        sum += mat[i];\n    }\n    return sum / total;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        bool asc = directions[i];\n        for (size_t j = 0; j < cols - 1; j++) {\n            size_t idx1 = i * cols + j;\n            size_t idx2 = i * cols + j + 1;\n            if (asc) {\n                if (matrix[idx1] > matrix[idx2]) {\n                    return false;\n                }\n            } else {\n                if (matrix[idx1] < matrix[idx2]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row_start = matrix + i * cols;\n        if (directions[i]) {\n            for (size_t j = 0; j < cols - 1; ++j) {\n                if (row_start[j] > row_start[j + 1]) {\n                    return false;\n                }\n            }\n        } else {\n            for (size_t j = 0; j < cols - 1; ++j) {\n                if (row_start[j] < row_start[j + 1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        bool asc = directions[i];\n        for (size_t j = 0; j < cols - 1; ++j) {\n            if (asc) {\n                if (row[j] > row[j+1]) \n                    return false;\n            } else {\n                if (row[j] < row[j+1]) \n                    return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const int* row = matrix + i * cols;\n        if (directions[i]) {\n            for (size_t j = 0; j < cols - 1; j++) {\n                if (row[j] > row[j+1]) {\n                    return false;\n                }\n            }\n        } else {\n            for (size_t j = 0; j < cols - 1; j++) {\n                if (row[j] < row[j+1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_30", "completion": "```cpp\nbool matrix_rows_sorted_verify(const int* matrix, const bool* directions, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const int* row = matrix + i * cols;\n        if (directions[i]) {\n            for (size_t j = 0; j < cols - 1; ++j) {\n                if (row[j] > row[j+1]) {\n                    return false;\n                }\n            }\n        } else {\n            for (size_t j = 0; j < cols - 1; ++j) {\n                if (row[j] < row[j+1]) {\n                    return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int32_t base32 = (int32_t)base;\n    for (size_t i = 0; i < length; i++) {\n        int32_t x = (int32_t)src[i];\n        int32_t r = x % base32;\n        if (r < 0) {\n            r += base32;\n        }\n        dst[i] = (int16_t)(x - r);\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int16_t x = src[i];\n        int16_t q = x / base;\n        int16_t r = x % base;\n        if (x < 0 && r != 0) {\n            q--;\n        }\n        dst[i] = q * base;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16_t base16 = (int16_t)base;\n    for (size_t i = 0; i < length; i++) {\n        int16_t x = src[i];\n        int16_t candidate = (x / base16) * base16;\n        if (candidate > x) {\n            if (candidate < -32768 + base16) {\n                candidate = -32768;\n            } else {\n                candidate -= base16;\n            }\n        }\n        dst[i] = candidate;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\n#include <stdint.h>\n#include <limits.h>\n\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        int32_t x = src[i];\n        int32_t base32 = base;\n        int32_t candidate;\n        \n        if (x >= 0) {\n            candidate = (x / base32) * base32;\n        } else {\n            candidate = (x / base32) * base32;\n            if (candidate > x) {\n                candidate -= base32;\n            }\n        }\n        \n        if (candidate < INT16_MIN) {\n            candidate = INT16_MIN;\n        }\n        \n        dst[i] = (int16_t)candidate;\n    }\n}\n```"}
{"task_id": "SimdBench_31", "completion": "```c\nvoid nearest_multiple(const int16_t* src, int16_t* dst, uint8_t base, size_t length) {\n    int16_t b = (int16_t)base;\n    for (size_t i = 0; i < length; i++) {\n        int16_t val = src[i];\n        int16_t r = val % b;\n        if (r < 0) {\n            dst[i] = val - r - b;\n        } else {\n            dst[i] = val - r;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <string.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    const double* row_ptr = matrix;\n    for (size_t i = 0; i < rows; i++) {\n        if (memcmp(row_ptr, vector, cols * sizeof(double)) == 0) {\n            return true;\n        }\n        row_ptr += cols;\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (matrix[i * cols + j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```c\n#include <stdbool.h>\n#include <string.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        if (memcmp(matrix + i * cols, vector, cols * sizeof(double)) == 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <cstddef>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; ++i) {\n        const double* row_start = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; ++j) {\n            if (row_start[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_32", "completion": "```cpp\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_has_row(const double* matrix, const double* vector, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        const double* row = matrix + i * cols;\n        bool match = true;\n        for (size_t j = 0; j < cols; j++) {\n            if (row[j] != vector[j]) {\n                match = false;\n                break;\n            }\n        }\n        if (match) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total_elements; ++i) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total_elements = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total_elements; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_33", "completion": "```c\nsize_t tensor_4d_equal_count(const uint8_t* A, const uint8_t* B, const size_t dims[4]) {\n    size_t total = dims[0] * dims[1] * dims[2] * dims[3];\n    size_t count = 0;\n    for (size_t i = 0; i < total; i++) {\n        if (A[i] == B[i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t product = a * x[i];\n        int64_t abs_val = y[i];\n        if (abs_val < 0) {\n            abs_val = -abs_val;\n        }\n        y[i] = product - abs_val;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t abs_val = y[i];\n        if (abs_val < 0) {\n            abs_val = -abs_val;\n        }\n        y[i] = a * x[i] - abs_val;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t orig_y = y[i];\n        int64_t abs_y = orig_y < 0 ? -orig_y : orig_y;\n        y[i] = a * x[i] - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t orig_y = y[i];\n        int64_t abs_y = orig_y < 0 ? -orig_y : orig_y;\n        y[i] = a * x[i] - abs_y;\n    }\n}\n```"}
{"task_id": "SimdBench_34", "completion": "```c\n#include <stdlib.h>\n\nvoid axm_abs(size_t length, const int64_t a, const int64_t *x, int64_t *y) {\n    for (size_t i = 0; i < length; i++) {\n        int64_t abs_val = llabs(y[i]);\n        y[i] = a * x[i] - abs_val;\n    }\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < min_val) {\n            min_val = vec[i];\n        }\n        if (vec[i] > max_val) {\n            max_val = vec[i];\n        }\n    }\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    MinMaxPair result;\n    result.min_num = vec[0];\n    result.max_num = vec[0];\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < result.min_num) {\n            result.min_num = vec[i];\n        }\n        if (vec[i] > result.max_num) {\n            result.max_num = vec[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    int16_t min = vec[0];\n    int16_t max = vec[0];\n    for (size_t i = 1; i < length; ++i) {\n        if (vec[i] < min) {\n            min = vec[i];\n        }\n        if (vec[i] > max) {\n            max = vec[i];\n        }\n    }\n    MinMaxPair result = {min, max};\n    return result;\n}\n```"}
{"task_id": "SimdBench_35", "completion": "```c\ntypedef struct {\n    int16_t min_num;\n    int16_t max_num;\n} MinMaxPair;\n\nMinMaxPair min_max_pair(const int16_t* vec, size_t length) {\n    int16_t min_val = vec[0];\n    int16_t max_val = vec[0];\n    for (size_t i = 1; i < length; i++) {\n        if (vec[i] < min_val) min_val = vec[i];\n        if (vec[i] > max_val) max_val = vec[i];\n    }\n    MinMaxPair result = {min_val, max_val};\n    return result;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; ++j) {\n            if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 1; j < cols; j++) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 1; j < cols; ++j) {\n            if (matrix[i * cols + j] <= matrix[i * cols + j - 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```cpp\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) {\n        return false;\n    }\n    for (size_t i = 0; i < rows; ++i) {\n        for (size_t j = 0; j < cols - 1; ++j) {\n            size_t index = i * cols + j;\n            if (matrix[index] >= matrix[index + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_36", "completion": "```c\nbool matrix_rows_strictly_increasing(const int* matrix, size_t rows, size_t cols) {\n    if (rows == 0 || cols == 0) return false;\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols - 1; j++) {\n            if (matrix[i * cols + j] >= matrix[i * cols + j + 1]) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0 || rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n\n    size_t num_blocks_vert = rows / block_size;\n    size_t num_blocks_horiz = cols / block_size;\n\n    for (size_t block_i = 0; block_i < num_blocks_vert; block_i++) {\n        for (size_t block_j = 0; block_j < num_blocks_horiz; block_j++) {\n            size_t start_row = block_i * block_size;\n            size_t start_col = block_j * block_size;\n            \n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t current_row = start_row + i;\n                    size_t current_col = start_col + j;\n                    size_t ref_row = i;\n                    size_t ref_col = j;\n                    \n                    if (matrix[current_row * cols + current_col] != matrix[ref_row * cols + ref_col]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```c\n#include <stdbool.h>\n#include <stddef.h>\n\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0) return false;\n    if (rows % block_size != 0 || cols % block_size != 0) return false;\n    \n    for (size_t i_block = 0; i_block < rows / block_size; i_block++) {\n        for (size_t j_block = 0; j_block < cols / block_size; j_block++) {\n            for (size_t i = 0; i < block_size; i++) {\n                for (size_t j = 0; j < block_size; j++) {\n                    size_t current_idx = (i_block * block_size + i) * cols + (j_block * block_size + j);\n                    size_t ref_idx = i * cols + j;\n                    if (matrix[current_idx] != matrix[ref_idx]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0) \n        return false;\n    if (rows % block_size != 0 || cols % block_size != 0) \n        return false;\n    \n    size_t blocks_in_row = rows / block_size;\n    size_t blocks_in_col = cols / block_size;\n    \n    for (size_t bi = 0; bi < blocks_in_row; ++bi) {\n        for (size_t bj = 0; bj < blocks_in_col; ++bj) {\n            if (bi == 0 && bj == 0) \n                continue;\n                \n            for (size_t i = 0; i < block_size; ++i) {\n                for (size_t j = 0; j < block_size; ++j) {\n                    size_t ref_index = i * cols + j;\n                    size_t current_index = (bi * block_size + i) * cols + (bj * block_size + j);\n                    if (matrix[ref_index] != matrix[current_index]) \n                        return false;\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0) \n        return false;\n    \n    if (rows % block_size != 0 || cols % block_size != 0)\n        return false;\n    \n    size_t num_block_rows = rows / block_size;\n    size_t num_block_cols = cols / block_size;\n    \n    for (size_t block_i = 0; block_i < num_block_rows; ++block_i) {\n        for (size_t block_j = 0; block_j < num_block_cols; ++block_j) {\n            if (block_i == 0 && block_j == 0) \n                continue;\n                \n            for (size_t r = 0; r < block_size; ++r) {\n                for (size_t c = 0; c < block_size; ++c) {\n                    size_t current_index = (block_i * block_size + r) * cols + (block_j * block_size + c);\n                    size_t first_index = r * cols + c;\n                    if (matrix[current_index] != matrix[first_index]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_37", "completion": "```cpp\nbool matrix_blocks_equal(const int* matrix, size_t block_size, size_t rows, size_t cols) {\n    if (block_size == 0) {\n        return false;\n    }\n    if (rows % block_size != 0 || cols % block_size != 0) {\n        return false;\n    }\n    size_t block_rows = rows / block_size;\n    size_t block_cols = cols / block_size;\n    for (size_t i = 0; i < block_rows; i++) {\n        for (size_t j = 0; j < block_cols; j++) {\n            if (i == 0 && j == 0) {\n                continue;\n            }\n            for (size_t r = 0; r < block_size; r++) {\n                for (size_t c = 0; c < block_size; c++) {\n                    size_t current_index = (i * block_size + r) * cols + (j * block_size + c);\n                    size_t ref_index = r * cols + c;\n                    if (matrix[current_index] != matrix[ref_index]) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n    if (std::isnan(tolerance) {\n        return false;\n    }\n    if (tolerance < 0.0) {\n        return false;\n    }\n\n    const double MY_DOUBLE_MAX = 1.7976931348623157e308;\n    size_t num_blocks = length / block_size;\n\n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            double a = vec[j];\n            double b = vec[i * block_size + j];\n\n            if (a == b) {\n                continue;\n            }\n            if (std::isnan(a) || std::isnan(b)) {\n                return false;\n            }\n            if (std::isinf(a) || std::isinf(b)) {\n                return false;\n            }\n            if (std::fabs(a - b) > tolerance) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (block_size == 0 || tolerance != tolerance) {\n        return false;\n    }\n    if (length < block_size) {\n        return false;\n    }\n    if (vec == nullptr) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    for (size_t i = 1; i < num_blocks; i++) {\n        for (size_t j = 0; j < block_size; j++) {\n            double a = vec[i * block_size + j];\n            double b = vec[j];\n            if (a != a || b != b) {\n                return false;\n            }\n            if (a == b) {\n                continue;\n            }\n            if (a * 0.5 == a || b * 0.5 == b) {\n                return false;\n            }\n            double diff = a - b;\n            if (diff < 0) {\n                diff = -diff;\n            }\n            if (diff > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size || tolerance < 0.0 || tolerance != tolerance) {\n        return false;\n    }\n    \n    const size_t num_blocks = length / block_size;\n    \n    for (size_t i = 1; i < num_blocks; ++i) {\n        for (size_t j = 0; j < block_size; ++j) {\n            const double a = vec[j];\n            const double b = vec[i * block_size + j];\n            if (a != a || b != b) {\n                return false;\n            }\n            if (std::fabs(a - b) > tolerance) {\n                return false;\n            }\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```cpp\n#include <cmath>\n#include <cstdlib>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == nullptr || block_size == 0 || length < block_size) {\n        return false;\n    }\n    \n    size_t num_blocks = length / block_size;\n    \n    for (size_t block = 1; block < num_blocks; ++block) {\n        for (size_t i = 0; i < block_size; ++i) {\n            size_t base_index = i;\n            size_t current_index = block * block_size + i;\n            if (std::abs(vec[base_index] - vec[current_index]) > tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_38", "completion": "```c\n#include <stddef.h>\n\nbool vector_block_equal(const double* vec, double tolerance, size_t length, size_t block_size) {\n    if (vec == NULL || block_size == 0 || tolerance < 0.0 || tolerance != tolerance || length < block_size) {\n        return false;\n    }\n    size_t num_blocks = length / block_size;\n    for (size_t i = 1; i < num_blocks; i++) {\n        for (size_t j = 0; j < block_size; j++) {\n            double a = vec[j];\n            double b = vec[i * block_size + j];\n            if (a == b) {\n                continue;\n            }\n            double diff = a - b;\n            if (diff != diff) {\n                return false;\n            }\n            if (diff > tolerance || diff < -tolerance) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```cpp\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum_sq = 0.0;\n        const double* row_start = matrix + i * cols;\n        for (size_t j = 0; j < cols; ++j) {\n            double val = row_start[j];\n            sum_sq += val * val;\n        }\n        result[i] = (sqrt(sum_sq) > thresholds[i]);\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        if (thresholds[i] < 0.0) {\n            result[i] = true;\n        } else {\n            double sq_sum = 0.0;\n            for (size_t j = 0; j < cols; j++) {\n                double val = matrix[i * cols + j];\n                sq_sum += val * val;\n            }\n            double threshold_sq = thresholds[i] * thresholds[i];\n            result[i] = sq_sum > threshold_sq;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\n#include <cmath>\n\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        double sum_squares = 0.0;\n        for (size_t j = 0; j < cols; ++j) {\n            double element = matrix[i * cols + j];\n            sum_squares += element * element;\n        }\n        result[i] = std::sqrt(sum_squares) > thresholds[i];\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; ++i) {\n        if (thresholds[i] < 0.0) {\n            result[i] = true;\n        } else {\n            double sq_sum = 0.0;\n            for (size_t j = 0; j < cols; ++j) {\n                double val = matrix[i * cols + j];\n                sq_sum += val * val;\n            }\n            result[i] = (sq_sum > thresholds[i] * thresholds[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_39", "completion": "```c\nvoid matrix_row_norm_compare(const double* matrix, const double* thresholds, size_t rows, size_t cols, bool* result) {\n    for (size_t i = 0; i < rows; i++) {\n        double thresh = thresholds[i];\n        if (thresh < 0.0) {\n            result[i] = true;\n        } else {\n            double sq_sum = 0.0;\n            for (size_t j = 0; j < cols; j++) {\n                double val = matrix[i * cols + j];\n                sq_sum += val * val;\n            }\n            result[i] = (sq_sum > thresh * thresh);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_40", "completion": "```c\nvoid tensor_bitwise_or(const uint32_t* A, const uint32_t* B, uint32_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] | B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t sum_sq = 0;\n    int64_t sum_prod = 0;\n    for (size_t i = 0; i < length; i++) {\n        int64_t a = A[i];\n        int64_t b = B[i];\n        sum_sq += a * a + b * b;\n        sum_prod += a * b;\n    }\n    return sum_sq - sum_prod;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\n#include <stdint.h>\n\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total = 0;\n    for (size_t i = 0; i < length; i++) {\n        int32_t diff = (int32_t)A[i] - (int32_t)B[i];\n        total += (int64_t)diff * diff;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t result = 0;\n    for (size_t i = 0; i < length; i++) {\n        result += A[i] * A[i] + B[i] * B[i] - A[i] * B[i];\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total = 0;\n    for (size_t i = 0; i < length; i++) {\n        int64_t a = A[i];\n        int64_t b = B[i];\n        total += a*a + b*b - a*b;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_41", "completion": "```c\nint64_t squarediff(const int8_t * A, const int8_t * B, size_t length) {\n    int64_t total = 0;\n    for (size_t i = 0; i < length; i++) {\n        int diff = A[i] - B[i];\n        total += (int64_t)diff * diff;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```cpp\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_42", "completion": "```c\nvoid tensor_bit_clear(const uint64_t* A, const uint64_t* B, uint64_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        C[i] = A[i] & ~B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        int8_t a = A[i];\n        int8_t b = B[i];\n        if (a > 0 && b > 0) {\n            C[i] = 1;\n        } else if (a < 0 && b < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_43", "completion": "```c\nvoid tensor_three_valued_logic(const int8_t* A, const int8_t* B, int8_t* C, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        if (A[i] > 0 && B[i] > 0) {\n            C[i] = 1;\n        } else if (A[i] < 0 && B[i] < 0) {\n            C[i] = -1;\n        } else {\n            C[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    if (length % 2 == 1) {\n        C[mid] = A[mid];\n    }\n    size_t start_after = (length % 2 == 1) ? mid + 1 : mid;\n    for (size_t i = start_after; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    if (length % 2 == 1) {\n        size_t mid = length / 2;\n        for (size_t i = 0; i < mid; i++) {\n            C[i] = A[i] ^ B[i];\n        }\n        C[mid] = A[mid];\n        for (size_t i = mid + 1; i < length; i++) {\n            C[i] = A[i] & B[i];\n        }\n    } else {\n        size_t mid = length / 2;\n        for (size_t i = 0; i < mid; i++) {\n            C[i] = A[i] ^ B[i];\n        }\n        for (size_t i = mid; i < length; i++) {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    \n    for (size_t i = 0; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    \n    C[mid] = A[mid];\n    \n    for (size_t i = mid + 1; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    for (size_t i = 0; i < mid; i++) {\n        C[i] = A[i] ^ B[i];\n    }\n    if (length % 2 == 1) {\n        C[mid] = A[mid];\n    }\n    size_t start_after = (length % 2 == 1) ? mid + 1 : mid;\n    for (size_t i = start_after; i < length; i++) {\n        C[i] = A[i] & B[i];\n    }\n}\n```"}
{"task_id": "SimdBench_44", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_op(const uint16_t* A, const uint16_t* B, uint16_t* C, size_t length) {\n    size_t mid = length / 2;\n    int is_odd = (length % 2 != 0);\n    \n    for (size_t i = 0; i < length; i++) {\n        if (is_odd && i == mid) {\n            C[i] = A[i];\n        } else if (i < mid) {\n            C[i] = A[i] ^ B[i];\n        } else {\n            C[i] = A[i] & B[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; ++i) {\n        if (cond1[i]) {\n            if (cond2[i]) {\n                out[i] = A[i];\n            } else {\n                out[i] = B[i];\n            }\n        } else {\n            if (cond2[i]) {\n                out[i] = C[i];\n            } else {\n                out[i] = D[i];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total_elements; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total; ++idx) {\n        if (cond1[idx] && cond2[idx]) {\n            out[idx] = A[idx];\n        } else if (cond1[idx] && !cond2[idx]) {\n            out[idx] = B[idx];\n        } else if (!cond1[idx] && cond2[idx]) {\n            out[idx] = C[idx];\n        } else {\n            out[idx] = D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_45", "completion": "```cpp\nvoid tensor_multi_select(const float* A, const float* B, const float* C, const float* D, const bool* cond1, const bool* cond2, float* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t idx = 0; idx < total; ++idx) {\n        if (cond1[idx]) {\n            out[idx] = cond2[idx] ? A[idx] : B[idx];\n        } else {\n            out[idx] = cond2[idx] ? C[idx] : D[idx];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; i++) {\n        uint32_t v = A[i];\n        v = v - ((v >> 1) & 0x55555555);\n        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n        v = (v + (v >> 4)) & 0x0F0F0F0F;\n        out[i] = (uint8_t)((v * 0x01010101) >> 24);\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```cpp\n#include <cstdint>\n#include <cstdlib>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    static uint8_t table[256];\n    static bool initialized = false;\n    if (!initialized) {\n        table[0] = 0;\n        for (int i = 1; i < 256; ++i) {\n            table[i] = table[i >> 1] + (i & 1);\n        }\n        initialized = true;\n    }\n    for (size_t i = 0; i < total; ++i) {\n        uint32_t elem = A[i];\n        out[i] = table[elem & 0xFF] + \n                 table[(elem >> 8) & 0xFF] + \n                 table[(elem >> 16) & 0xFF] + \n                 table[(elem >> 24) & 0xFF];\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; i++) {\n        uint32_t v = A[i];\n        v = v - ((v >> 1) & 0x55555555);\n        v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n        v = (v + (v >> 4)) & 0x0F0F0F0F;\n        out[i] = (v * 0x01010101) >> 24;\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    static const uint8_t lookup[256] = {\n        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,\n        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8\n    };\n    size_t total_elements = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total_elements; i++) {\n        uint32_t a = A[i];\n        out[i] = lookup[a & 0xFF] +\n                 lookup[(a >> 8) & 0xFF] +\n                 lookup[(a >> 16) & 0xFF] +\n                 lookup[(a >> 24) & 0xFF];\n    }\n}\n```"}
{"task_id": "SimdBench_46", "completion": "```c\nvoid tensor_bit_count(const uint32_t* A, uint8_t* out, size_t dim1, size_t dim2, size_t dim3) {\n    size_t total = dim1 * dim2 * dim3;\n    for (size_t i = 0; i < total; i++) {\n        uint32_t x = A[i];\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        x = (x + (x >> 4)) & 0x0F0F0F0F;\n        out[i] = (x * 0x01010101) >> 24;\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; ++i) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; i++) {\n        if (A[i] % 3 == 0) {\n            B[i] = abs(A[i]);\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    for (size_t idx = 0; idx < total; idx++) {\n        int val = A[idx];\n        if (val % 3 == 0) {\n            if (val < 0) {\n                B[idx] = -val;\n            } else {\n                B[idx] = val;\n            }\n        } else {\n            B[idx] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\n#include <stdlib.h>\n\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    for (size_t i = 0; i < rows; i++) {\n        for (size_t j = 0; j < cols; j++) {\n            size_t index = i * cols + j;\n            int val = A[index];\n            if (val % 3 == 0) {\n                B[index] = abs(val);\n            } else {\n                B[index] = val;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_47", "completion": "```c\nvoid matrix_conditional_abs(const int* A, int* B, size_t rows, size_t cols) {\n    size_t total = rows * cols;\n    for (size_t i = 0; i < total; i++) {\n        int val = A[i];\n        if (val % 3 == 0) {\n            B[i] = val < 0 ? -val : val;\n        } else {\n            B[i] = val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint8_t mod_bits = rotate_bits % 32;\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> mod_bits) | (src[i] << (32 - mod_bits));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint8_t r = rotate_bits & 0x1F;\n    for (size_t i = 0; i < length; ++i) {\n        uint32_t elem = src[i];\n        if ((elem & 0xF) == 0xF) {\n            dst[i] = (elem >> r) | (elem << ((32 - r) & 0x1F));\n        } else {\n            dst[i] = ~elem;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32_t n = rotate_bits & 31;\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> n) | (src[i] << (32 - n));\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\n#include <stdint.h>\n\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32_t r = rotate_bits & 0x1F;\n    for (size_t i = 0; i < length; i++) {\n        uint32_t x = src[i];\n        if ((x & 0xF) == 0xF) {\n            dst[i] = (x >> r) | (x << ((32 - r) & 0x1F));\n        } else {\n            dst[i] = ~x;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_48", "completion": "```c\nvoid matrix_conditional_bit_rotate(const uint32_t* src, uint32_t* dst, uint8_t rotate_bits, size_t length) {\n    uint32_t rot = rotate_bits & 0x1F;\n    uint32_t shift2 = (32 - rot) & 0x1F;\n    for (size_t i = 0; i < length; i++) {\n        if ((src[i] & 0xF) == 0xF) {\n            dst[i] = (src[i] >> rot) | (src[i] << shift2);\n        } else {\n            dst[i] = ~src[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n#include <stddef.h>\n#include <stdint.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = (epsilon < 0) ? -epsilon : epsilon;\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_49", "completion": "```c\n#include <math.h>\n\nvoid tensor_ternary_compare(const float* A, const float* B, int8_t* out, float epsilon, size_t length) {\n    float abs_epsilon = fabsf(epsilon);\n    for (size_t i = 0; i < length; ++i) {\n        float diff = A[i] - B[i];\n        if (diff > abs_epsilon) {\n            out[i] = 1;\n        } else if (diff < -abs_epsilon) {\n            out[i] = -1;\n        } else {\n            out[i] = 0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```cpp\n#include <cstdint>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const float fmax = static_cast<float>(INT32_MAX);\n    const float fmin = static_cast<float>(INT32_MIN);\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] >= fmax) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < fmin) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = static_cast<int32_t>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n#include <limits.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const double upper_bound = (double)INT32_MAX;\n    const double lower_bound = (double)INT32_MIN;\n    \n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val > upper_bound) {\n            B[i] = INT32_MAX;\n        } else if (val < lower_bound) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] >= 2147483648.0f) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < -2147483648.0f) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <cstdint>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        float val = A[i];\n        if (val >= 2147483648.0f) {\n            B[i] = INT32_MAX;\n        } else if (val < -2147483648.0f) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)val;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_50", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_to_int_saturate(const float* A, int32_t* B, size_t size) {\n    const float int32_max_float = 2147483648.0f;\n    const float int32_min_float = -2147483648.0f;\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] >= int32_max_float) {\n            B[i] = INT32_MAX;\n        } else if (A[i] < int32_min_float) {\n            B[i] = INT32_MIN;\n        } else {\n            B[i] = (int32_t)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * scale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float fscale = (float)scale;\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * fscale;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float factor = 1.0f;\n    int exp = -scale;\n    if (exp > 0) {\n        while (exp > 0) {\n            factor *= 10.0f;\n            exp--;\n        }\n    } else if (exp < 0) {\n        while (exp < 0) {\n            factor /= 10.0f;\n            exp++;\n        }\n    }\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float) A[i] * factor;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    float scale_f = (float)scale;\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (float)A[i] * scale_f;\n    }\n}\n```"}
{"task_id": "SimdBench_51", "completion": "```c\nvoid int_to_float_scaled(const int32_t* A, int8_t scale, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (float)A[i] * (float)scale;\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        double a_val = (double)A[i];\n        double b_val = (double)B[i];\n        double quotient = a_val / b_val;\n\n        if (isnan(quotient)) {\n            C[i] = 0;\n        } else if (isinf(quotient)) {\n            C[i] = (quotient > 0) ? INT32_MAX : INT32_MIN;\n        } else {\n            double rounded = round(quotient);\n            if (rounded > INT32_MAX) {\n                C[i] = INT32_MAX;\n            } else if (rounded < INT32_MIN) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = (int32_t)rounded;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n#include <stddef.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    const float float_max_bound = 2147483648.0f;\n    const float float_min_bound = -2147483648.0f;\n    \n    for (size_t i = 0; i < size; i++) {\n        if (B[i] == 0.0f) {\n            if (A[i] == 0.0f) {\n                C[i] = 0;\n            } else if (A[i] > 0.0f) {\n                C[i] = INT32_MAX;\n            } else {\n                C[i] = INT32_MIN;\n            }\n        } else {\n            float quotient = A[i] / B[i];\n            if (isnan(quotient)) {\n                C[i] = 0;\n            } else if (isinf(quotient)) {\n                if (quotient > 0.0f) {\n                    C[i] = INT32_MAX;\n                } else {\n                    C[i] = INT32_MIN;\n                }\n            } else {\n                float rounded_val = roundf(quotient);\n                if (rounded_val >= float_max_bound) {\n                    C[i] = INT32_MAX;\n                } else if (rounded_val <= float_min_bound) {\n                    C[i] = INT32_MIN;\n                } else {\n                    C[i] = (int32_t)rounded_val;\n                }\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```cpp\n#include <cmath>\n#include <cstdint>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    const double int32_max_plus1 = 2147483648.0;\n    const double int32_min = -2147483648.0;\n    \n    for (size_t i = 0; i < size; i++) {\n        double d = static_cast<double>(A[i]) / static_cast<double>(B[i]);\n        if (std::isnan(d)) {\n            C[i] = 0;\n        } else if (std::isinf(d)) {\n            C[i] = (d > 0) ? INT32_MAX : INT32_MIN;\n        } else {\n            double rounded = std::round(d);\n            if (rounded >= int32_max_plus1) {\n                C[i] = INT32_MAX;\n            } else if (rounded < int32_min) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = static_cast<int32_t>(rounded);\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```cpp\n#include <cmath>\n#include <cstdint>\n#include <climits>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        double num = static_cast<double>(A[i]);\n        double den = static_cast<double>(B[i]);\n        double quotient = num / den;\n        double rounded = std::round(quotient);\n\n        if (std::isnan(rounded)) {\n            C[i] = 0;\n        } else if (std::isinf(rounded)) {\n            C[i] = (rounded > 0) ? INT32_MAX : INT32_MIN;\n        } else if (rounded > INT32_MAX) {\n            C[i] = INT32_MAX;\n        } else if (rounded < INT32_MIN) {\n            C[i] = INT32_MIN;\n        } else {\n            C[i] = static_cast<int32_t>(rounded);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_52", "completion": "```c\n#include <math.h>\n#include <stdint.h>\n\nvoid float_div_round(const float* A, const float* B, int32_t* C, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        double quotient = (double)A[i] / (double)B[i];\n        if (isnan(quotient)) {\n            C[i] = 0;\n        } else if (isinf(quotient)) {\n            C[i] = (quotient > 0) ? INT32_MAX : INT32_MIN;\n        } else {\n            double rounded = round(quotient);\n            if (rounded > (double)INT32_MAX) {\n                C[i] = INT32_MAX;\n            } else if (rounded < (double)INT32_MIN) {\n                C[i] = INT32_MIN;\n            } else {\n                C[i] = (int32_t)rounded;\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <cfloat>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\n#include <float.h>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```c\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    const double flt_max_d = FLT_MAX;\n    const double neg_flt_max_d = -flt_max_d;\n\n    for (size_t i = 0; i < size; i++) {\n        if (A[i] > flt_max_d) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < neg_flt_max_d) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = (float)(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_53", "completion": "```cpp\n#include <cfloat>\n\nvoid double_to_float_saturate(const double* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        if (A[i] > FLT_MAX) {\n            B[i] = FLT_MAX;\n        } else if (A[i] < -FLT_MAX) {\n            B[i] = -FLT_MAX;\n        } else {\n            B[i] = static_cast<float>(A[i]);\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_54", "completion": "```c\nvoid int16_to_int32(const int16_t* A, int32_t* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        B[i] = (int32_t)A[i];\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    const float range = max_val - min_val;\n    const int range_zero = (range == 0.0f);\n\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            const float diff = A[i] - min_val;\n            if (range_zero) {\n                B[i] = (diff > 0.0f) ? 1.0f : 0.0f;\n            } else {\n                float normalized_val = diff / range;\n                if (normalized_val < 0.0f) {\n                    normalized_val = 0.0f;\n                }\n                if (normalized_val > 1.0f) {\n                    normalized_val = 1.0f;\n                }\n                B[i] = normalized_val;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            if (max_val > min_val) {\n                float normalized = (A[i] - min_val) / (max_val - min_val);\n                if (normalized < 0.0f) {\n                    B[i] = 0.0f;\n                } else if (normalized > 1.0f) {\n                    B[i] = 1.0f;\n                } else {\n                    B[i] = normalized;\n                }\n            } else {\n                B[i] = 0.5f;\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float denom = max_val - min_val;\n            if (denom == 0.0f) {\n                if (A[i] < min_val) {\n                    B[i] = 0.0f;\n                } else if (A[i] > min_val) {\n                    B[i] = 1.0f;\n                } else {\n                    B[i] = 0.5f;\n                }\n            } else {\n                float val = (A[i] - min_val) / denom;\n                if (val < 0.0f) {\n                    B[i] = 0.0f;\n                } else if (val > 1.0f) {\n                    B[i] = 1.0f;\n                } else {\n                    B[i] = val;\n                }\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    if (max_val == min_val) {\n        for (size_t i = 0; i < size; i++) {\n            if (control[i] > 0) {\n                B[i] = 0.5f;\n            } else {\n                B[i] = A[i];\n            }\n        }\n    } else {\n        float denom = max_val - min_val;\n        for (size_t i = 0; i < size; i++) {\n            if (control[i] > 0) {\n                float val = (A[i] - min_val) / denom;\n                if (val < 0.0f) {\n                    val = 0.0f;\n                } else if (val > 1.0f) {\n                    val = 1.0f;\n                }\n                B[i] = val;\n            } else {\n                B[i] = A[i];\n            }\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_55", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid conditional_normalize(const float* A, const int32_t* control, float* B, size_t size, float min_val, float max_val) {\n    for (size_t i = 0; i < size; i++) {\n        if (control[i] > 0) {\n            float denom = max_val - min_val;\n            if (denom == 0.0f) {\n                B[i] = (A[i] > min_val) ? 1.0f : 0.0f;\n            } else {\n                float normalized_val = (A[i] - min_val) / denom;\n                if (normalized_val < 0.0f) {\n                    B[i] = 0.0f;\n                } else if (normalized_val > 1.0f) {\n                    B[i] = 1.0f;\n                } else {\n                    B[i] = normalized_val;\n                }\n            }\n        } else {\n            B[i] = A[i];\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float converted = (float)high_bits;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high16 = A[i] >> 16;\n        float converted = (float)high16;\n        B[i] = sqrtf(converted);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        uint32_t high_bits = A[i] >> 16;\n        float temp = (float)high_bits;\n        B[i] = sqrtf(temp);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        float val = (float)high_bits;\n        B[i] = sqrtf(val);\n    }\n}\n```"}
{"task_id": "SimdBench_56", "completion": "```c\n#include <stdint.h>\n#include <math.h>\n\nvoid int_to_float_sqrt(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        uint32_t high_bits = A[i] >> 16;\n        B[i] = sqrtf((float)high_bits);\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } converter;\n        converter.u = A[i];\n        B[i] = converter.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    union { uint32_t u; float f; } converter;\n    for (size_t i = 0; i < size; i++) {\n        converter.u = A[i];\n        B[i] = converter.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    union {\n        uint32_t u;\n        float f;\n    } converter;\n    for (size_t i = 0; i < size; i++) {\n        converter.u = A[i];\n        B[i] = converter.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stddef.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        union {\n            uint32_t u;\n            float f;\n        } converter;\n        converter.u = A[i];\n        B[i] = converter.f;\n    }\n}\n```"}
{"task_id": "SimdBench_57", "completion": "```c\n#include <stdint.h>\n#include <string.h>\n\nvoid int_bits_to_float(const uint32_t* A, float* B, size_t size) {\n    for (size_t i = 0; i < size; ++i) {\n        memcpy(&B[i], &A[i], sizeof(float));\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    \n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; ++i) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_58", "completion": "```c\nvoid conditional_diff(const int32_t* A, const bool* cond, float* diff, size_t size) {\n    if (size == 0) return;\n    diff[0] = 0.0f;\n    for (size_t i = 1; i < size; i++) {\n        if (cond[i]) {\n            diff[i] = (float)(A[i] - A[i-1]);\n        } else {\n            diff[i] = 0.0f;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | (UINT64_C(0xFFFFFFFF) << 32);\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; ++i) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n#include <stddef.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (0xFFFFFFFFULL << 32) | src[i];\n    }\n}\n```"}
{"task_id": "SimdBench_59", "completion": "```c\n#include <stdint.h>\n\nvoid widening_uint(const uint32_t* src, uint64_t* dst, size_t length) {\n    for (size_t i = 0; i < length; i++) {\n        dst[i] = (uint64_t)src[i] | 0xFFFFFFFF00000000ULL;\n    }\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[(size_t)idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double total = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            total += vec[idx];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double result = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx < 0) continue;\n        if ((size_t)idx >= length) continue;\n        result += vec[idx];\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; ++i) {\n        int16_t idx = index[i];\n        if (idx >= 0 && idx < (int16_t)length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_60", "completion": "```c\ndouble indexed_sum(const double* vec, const int16_t* index, size_t length) {\n    double sum = 0.0;\n    for (size_t i = 0; i < length; i++) {\n        int16_t idx = index[i];\n        if (idx >= 0 && (size_t)idx < length) {\n            sum += vec[idx];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t out_dim = input_size - kernel_size + 1;\n    for (size_t i = 0; i < out_dim; i++) {\n        for (size_t j = 0; j < out_dim; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    size_t input_index = (i + k) * input_size + (j + l);\n                    size_t kernel_index = k * kernel_size + l;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            output[i * out_dim + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ki++) {\n                for (size_t kj = 0; kj < kernel_size; kj++) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            output[i * output_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; i++) {\n        for (size_t j = 0; j < output_size; j++) {\n            double sum = 0.0;\n            for (size_t k = 0; k < kernel_size; k++) {\n                for (size_t l = 0; l < kernel_size; l++) {\n                    sum += input[(i + k) * input_size + (j + l)] * kernel[k * kernel_size + l];\n                }\n            }\n            output[i * output_size + j] = sum > 0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\nvoid simple_conv2d(const double* input, const double* kernel, double * output, size_t input_size, size_t kernel_size) {\n    size_t output_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < output_size; ++i) {\n        for (size_t j = 0; j < output_size; ++j) {\n            double sum = 0.0;\n            for (size_t k = 0; k < kernel_size; ++k) {\n                for (size_t l = 0; l < kernel_size; ++l) {\n                    sum += input[(i + k) * input_size + j + l] * kernel[k * kernel_size + l];\n                }\n            }\n            output[i * output_size + j] = sum > 0.0 ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_61", "completion": "```c\n#include <stddef.h>\n\nvoid simple_conv2d(const double* input, const double* kernel, double* output, size_t input_size, size_t kernel_size) {\n    size_t out_size = input_size - kernel_size + 1;\n    for (size_t i = 0; i < out_size; ++i) {\n        for (size_t j = 0; j < out_size; ++j) {\n            double sum = 0.0;\n            for (size_t ki = 0; ki < kernel_size; ++ki) {\n                for (size_t kj = 0; kj < kernel_size; ++kj) {\n                    size_t input_index = (i + ki) * input_size + (j + kj);\n                    size_t kernel_index = ki * kernel_size + kj;\n                    sum += input[input_index] * kernel[kernel_index];\n                }\n            }\n            output[i * out_size + j] = (sum > 0.0) ? sum : 0.0;\n        }\n    }\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2 || threshold <= 0.0) {\n        return false;\n    }\n    std::vector<double> sorted = numbers;\n    std::sort(sorted.begin(), sorted.end());\n    for (size_t i = 0; i < sorted.size() - 1; ++i) {\n        if (sorted[i + 1] - sorted[i] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::fabs(sorted_numbers[i] - sorted_numbers[i+1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (sorted_numbers[i + 1] - sorted_numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cmath>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    if (numbers.size() < 2) {\n        return false;\n    }\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (std::abs(sorted_numbers[i] - sorted_numbers[i + 1]) < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_62", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool has_close_elements(const std::vector<double> & numbers, double threshold) {\n    if (threshold <= 0.0 || numbers.size() < 2) {\n        return false;\n    }\n    std::vector<double> sorted_numbers = numbers;\n    std::sort(sorted_numbers.begin(), sorted_numbers.end());\n    for (size_t i = 0; i < sorted_numbers.size() - 1; ++i) {\n        if (sorted_numbers[i+1] - sorted_numbers[i] < threshold) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_63", "completion": "```cpp\n#include <vector>\n\nbool below_zero(std::vector<int> operations) {\n    int balance = 0;\n    for (int op : operations) {\n        balance += op;\n        if (balance < 0) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    double abs_sum = 0.0;\n    for (double num : numbers) {\n        abs_sum += std::abs(num - mean);\n    }\n    return abs_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n#include <numeric>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    double sum = std::accumulate(numbers.begin(), numbers.end(), 0.0);\n    double mean = sum / numbers.size();\n    double absolute_sum = 0.0;\n    for (double num : numbers) {\n        absolute_sum += std::abs(num - mean);\n    }\n    return absolute_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    double abs_sum = 0.0;\n    for (double num : numbers) {\n        abs_sum += std::abs(num - mean);\n    }\n    return abs_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    double abs_diff_sum = 0.0;\n    for (double num : numbers) {\n        abs_diff_sum += std::abs(num - mean);\n    }\n    return abs_diff_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_64", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\ndouble mean_absolute_deviation(std::vector<double> numbers) {\n    if (numbers.empty()) return 0.0;\n    double sum = 0.0;\n    for (double num : numbers) {\n        sum += num;\n    }\n    double mean = sum / numbers.size();\n    double abs_sum = 0.0;\n    for (double num : numbers) {\n        abs_sum += std::abs(num - mean);\n    }\n    return abs_sum / numbers.size();\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) {\n        return result;\n    }\n    result.reserve(2 * numbers.size() - 1);\n    result.push_back(numbers[0]);\n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) {\n        return {};\n    }\n    std::vector<int> result;\n    result.reserve(2 * numbers.size() - 1);\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    if (numbers.empty()) return {};\n    std::vector<int> result;\n    for (size_t i = 0; i < numbers.size(); ++i) {\n        result.push_back(numbers[i]);\n        if (i < numbers.size() - 1) {\n            result.push_back(delimeter);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_65", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> intersperse(std::vector<int> numbers, int delimeter) {\n    std::vector<int> result;\n    if (numbers.empty()) \n        return result;\n    \n    result.reserve(2 * numbers.size() - 1);\n    result.push_back(numbers[0]);\n    \n    for (size_t i = 1; i < numbers.size(); ++i) {\n        result.push_back(delimeter);\n        result.push_back(numbers[i]);\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t sum = 0;\n    int64_t product = 1;\n    for (int16_t num : numbers) {\n        sum += num;\n        product *= num;\n    }\n    return {sum, product};\n}\n```"}
{"task_id": "SimdBench_66", "completion": "```cpp\n#include <vector>\n\nstd::vector<int64_t> sum_product(std::vector<int16_t> numbers) {\n    int64_t total = 0;\n    int64_t prod = 1;\n    for (int16_t num : numbers) {\n        total += num;\n        prod *= num;\n    }\n    return {total, prod};\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    if (numbers.empty()) \n        return {};\n    \n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    if (numbers.empty()) return {};\n    std::vector<int> result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers) {\n    std::vector<int> result;\n    if (numbers.empty()) return result;\n    int current_max = numbers[0];\n    for (int num : numbers) {\n        current_max = std::max(current_max, num);\n        result.push_back(current_max);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    if (numbers.empty()) return {};\n    std::vector<int> result(numbers.size());\n    result[0] = numbers[0];\n    for (int i = 1; i < numbers.size(); ++i) {\n        result[i] = std::max(result[i-1], numbers[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_67", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> rolling_max(std::vector<int> numbers){\n    if (numbers.empty()) return {};\n    std::vector<int> result;\n    result.reserve(numbers.size());\n    result.push_back(numbers[0]);\n    for (int i = 1; i < numbers.size(); ++i) {\n        result.push_back(std::max(result.back(), numbers[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string string_xor(std::string a, std::string b) {\n    size_t n = std::max(a.size(), b.size());\n    if (a.size() < n) {\n        a = std::string(n - a.size(), '0') + a;\n    }\n    if (b.size() < n) {\n        b = std::string(n - b.size(), '0') + b;\n    }\n    std::string result;\n    for (size_t i = 0; i < n; ++i) {\n        if (a[i] == b[i]) {\n            result += '0';\n        } else {\n            result += '1';\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    int n = a.size() > b.size() ? a.size() : b.size();\n    std::string result(n, '0');\n    int i = a.size() - 1;\n    int j = b.size() - 1;\n    int k = n - 1;\n    while (k >= 0) {\n        char c1 = (i >= 0) ? a[i] : '0';\n        char c2 = (j >= 0) ? b[j] : '0';\n        if (c1 != c2) {\n            result[k] = '1';\n        }\n        i--;\n        j--;\n        k--;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    int i = a.length() - 1;\n    int j = b.length() - 1;\n    std::string temp = \"\";\n    while (i >= 0 || j >= 0) {\n        char bit_a = (i >= 0) ? a[i] : '0';\n        char bit_b = (j >= 0) ? b[j] : '0';\n        char bit = (bit_a == bit_b) ? '0' : '1';\n        temp += bit;\n        i--;\n        j--;\n    }\n    while (temp.size() > 1 && temp.back() == '0') {\n        temp.pop_back();\n    }\n    if (temp.empty()) {\n        return \"0\";\n    }\n    std::string result = \"\";\n    for (int k = temp.size() - 1; k >= 0; k--) {\n        result += temp[k];\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    size_t len_a = a.size();\n    size_t len_b = b.size();\n    size_t n = (len_a > len_b) ? len_a : len_b;\n    std::string result(n, '0');\n    \n    int i = (int)len_a - 1;\n    int j = (int)len_b - 1;\n    int index = (int)n - 1;\n    \n    while (index >= 0) {\n        char c1 = (i >= 0) ? a[i] : '0';\n        char c2 = (j >= 0) ? b[j] : '0';\n        \n        if (c1 == c2) {\n            result[index] = '0';\n        } else {\n            result[index] = '1';\n        }\n        \n        i--;\n        j--;\n        index--;\n    }\n    \n    return result;\n}\n```"}
{"task_id": "SimdBench_68", "completion": "```cpp\n#include <algorithm>\n#include <string>\n\nstd::string string_xor(std::string a, std::string b) {\n    int len_a = a.length();\n    int len_b = b.length();\n    int n = std::max(len_a, len_b);\n    std::string result(n, '0');\n    int i = len_a - 1, j = len_b - 1;\n    for (int k = n - 1; k >= 0; k--) {\n        char c_a = (i >= 0) ? a[i--] : '0';\n        char c_b = (j >= 0) ? b[j--] : '0';\n        if (c_a != c_b) {\n            result[k] = '1';\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings) {\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string longest_str = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].size() > longest_str.size()) {\n            longest_str = strings[i];\n        }\n    }\n    return longest_str;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string result = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].size() > result.size()) {\n            result = strings[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return \"\";\n    }\n    std::string result = strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > result.length()) {\n            result = strings[i];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <string>\n#include <vector>\n\nstd::string longest(const std::vector<std::string> & strings){\n    std::string result;\n    for (const auto& s : strings) {\n        if (s.length() > result.length()) {\n            result = s;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_69", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string longest(const std::vector<std::string> & strings){\n    if (strings.empty()) {\n        return std::string();\n    }\n    const std::string* max_str = &strings[0];\n    for (size_t i = 1; i < strings.size(); ++i) {\n        if (strings[i].length() > max_str->length()) {\n            max_str = &strings[i];\n        }\n    }\n    return *max_str;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_70", "completion": "```c\n#include <stdint.h>\n\nuint64_t greatest_common_divisor(uint64_t a, uint64_t b) {\n    while (b != 0) {\n        uint64_t temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers){\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = numbers[1] - numbers[0];\n    float num1 = numbers[0], num2 = numbers[1];\n    for (int i = 1; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            num1 = numbers[i];\n            num2 = numbers[i+1];\n        }\n    }\n    return {num1, num2};\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = numbers[1] - numbers[0];\n    std::vector<float> result = {numbers[0], numbers[1]};\n    for (int i = 1; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i+1]};\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> closest_pair(2);\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            closest_pair[0] = numbers[i];\n            closest_pair[1] = numbers[i+1];\n        }\n    }\n    return closest_pair;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n#include <limits>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = std::numeric_limits<float>::max();\n    std::vector<float> result(2);\n    for (size_t i = 0; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result[0] = numbers[i];\n            result[1] = numbers[i+1];\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_71", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> find_closest_elements(std::vector<float> numbers) {\n    std::sort(numbers.begin(), numbers.end());\n    float min_diff = numbers[1] - numbers[0];\n    std::vector<float> result = {numbers[0], numbers[1]};\n    for (size_t i = 1; i < numbers.size() - 1; ++i) {\n        float diff = numbers[i+1] - numbers[i];\n        if (diff < min_diff) {\n            min_diff = diff;\n            result = {numbers[i], numbers[i+1]};\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.empty()) return numbers;\n    auto [min_it, max_it] = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *min_it;\n    float max_val = *max_it;\n    if (min_val == max_val) {\n        for (float& x : numbers) x = 0.5f;\n    } else {\n        float range = max_val - min_val;\n        for (float& x : numbers) x = (x - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    auto minmax = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *minmax.first;\n    float max_val = *minmax.second;\n    float range = max_val - min_val;\n\n    for (float& num : numbers) {\n        num = (num - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    float min_val = *std::min_element(numbers.begin(), numbers.end());\n    float max_val = *std::max_element(numbers.begin(), numbers.end());\n    std::vector<float> result;\n    result.reserve(numbers.size());\n    if (max_val == min_val) {\n        for (size_t i = 0; i < numbers.size(); ++i) {\n            result.push_back(0.5f);\n        }\n    } else {\n        float range = max_val - min_val;\n        for (float x : numbers) {\n            result.push_back((x - min_val) / range);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    auto [min_it, max_it] = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *min_it;\n    float max_val = *max_it;\n    float range = max_val - min_val;\n    if (range == 0.0f) {\n        std::transform(numbers.begin(), numbers.end(), numbers.begin(), [](float) { return 0.5f; });\n    } else {\n        std::transform(numbers.begin(), numbers.end(), numbers.begin(), [min_val, range](float x) { return (x - min_val) / range; });\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_72", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> rescale_to_unit(std::vector<float> numbers) {\n    if (numbers.empty()) return numbers;\n    auto min_max = std::minmax_element(numbers.begin(), numbers.end());\n    float min_val = *min_max.first;\n    float max_val = *min_max.second;\n    float range = max_val - min_val;\n\n    if (range == 0.0f) {\n        for (auto& x : numbers) x = 0.5f;\n    } else {\n        for (auto& x : numbers) x = (x - min_val) / range;\n    }\n    return numbers;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    for (uint64_t i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            return n / i;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <cstdint>\n\nuint64_t largest_divisor(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    for (uint64_t d = 2; d <= n / d; ++d) {\n        if (n % d == 0) {\n            return n / d;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n    for (uint64_t d = 3; d * d <= n; d += 2) {\n        if (n % d == 0) {\n            return n / d;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    if (n % 2 == 0) {\n        return n / 2;\n    }\n    if (n % 3 == 0) {\n        return n / 3;\n    }\n    for (uint64_t i = 5; i <= n / i; i += 6) {\n        if (n % i == 0) {\n            return n / i;\n        }\n        if (n % (i + 2) == 0) {\n            return n / (i + 2);\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_73", "completion": "```c\n#include <stdint.h>\n\nuint64_t largest_divisor(uint64_t n) {\n    if (n == 1) {\n        return 0;\n    }\n    for (uint64_t d = 2; d * d <= n; ++d) {\n        if (n % d == 0) {\n            return n / d;\n        }\n    }\n    return 1;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) factors.push_back(n);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) factors.push_back(n);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) factors.push_back(n);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n <= 1) return factors;\n    while (n % 2 == 0) {\n        factors.push_back(2);\n        n /= 2;\n    }\n    for (int i = 3; i * i <= n; i += 2) {\n        while (n % i == 0) {\n            factors.push_back(i);\n            n /= i;\n        }\n    }\n    if (n > 1) factors.push_back(n);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_74", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> factorize(int n) {\n    std::vector<int> factors;\n    if (n < 2) return factors;\n    int d = 2;\n    while (d * d <= n) {\n        while (n % d == 0) {\n            factors.push_back(d);\n            n /= d;\n        }\n        ++d;\n    }\n    if (n > 1) factors.push_back(n);\n    return factors;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l){\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_75", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> get_positive(const std::vector<float> & l) {\n    std::vector<float> result;\n    for (float num : l) {\n        if (num > 0) {\n            result.push_back(num);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    int64_t sqrt_n = static_cast<int64_t>(std::sqrt(n)) + 1;\n    for (int64_t i = 3; i < sqrt_n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cstdint>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) {\n        return false;\n    }\n    if (n == 2) {\n        return true;\n    }\n    if (n % 2 == 0) {\n        return false;\n    }\n    for (int64_t i = 3; i <= n / i; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cmath>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    int64_t root = sqrt(n);\n    for (int64_t i = 3; i <= root; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cstdint>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) \n        return false;\n    if (n <= 3) \n        return true;\n    if (n % 2 == 0 || n % 3 == 0)\n        return false;\n    for (int64_t i = 5; i <= n / i; i += 6) {\n        if (n % i == 0 || n % (i + 2) == 0)\n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_76", "completion": "```cpp\n#include <cstdint>\n\nbool is_prime(int64_t n) {\n    if (n <= 1) return false;\n    if (n == 2) return true;\n    if (n % 2 == 0) return false;\n    for (int64_t i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            has_letter = true;\n            break;\n        }\n    }\n    if (has_letter) {\n        std::string result = s;\n        for (char& ch : result) {\n            if (std::isalpha(static_cast<unsigned char>(ch))) {\n                if (std::islower(static_cast<unsigned char>(ch))) {\n                    ch = static_cast<char>(std::toupper(static_cast<unsigned char>(ch)));\n                } else {\n                    ch = static_cast<char>(std::tolower(static_cast<unsigned char>(ch)));\n                }\n            }\n        }\n        return result;\n    } else {\n        return std::string(s.rbegin(), s.rend());\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string solve(const std::string & s) {\n    bool has_letter = false;\n    for (char c : s) {\n        if (std::isalpha(static_cast<unsigned char>(c))) {\n            has_letter = true;\n            break;\n        }\n    }\n    \n    if (has_letter) {\n        std::string result;\n        for (char c : s) {\n            unsigned char uc = static_cast<unsigned char>(c);\n            if (std::isalpha(uc)) {\n                if (std::islower(uc)) {\n                    result += static_cast<char>(std::toupper(uc));\n                } else {\n                    result += static_cast<char>(std::tolower(uc));\n                }\n            } else {\n                result += c;\n            }\n        }\n        return result;\n    } else {\n        return std::string(s.rbegin(), s.rend());\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <algorithm>\n#include <cctype>\n#include <string>\n\nstd::string solve(const std::string & s) {\n    if (std::any_of(s.begin(), s.end(), [](char c) { return std::isalpha(c); })) {\n        std::string result = s;\n        for (char & c : result) {\n            if (std::isalpha(c)) {\n                c = std::islower(c) ? std::toupper(c) : std::tolower(c);\n            }\n        }\n        return result;\n    } else {\n        return std::string(s.rbegin(), s.rend());\n    }\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n#include <string>\n\nstd::string solve(const std::string & s) {\n    std::string result = s;\n    bool has_letter = false;\n    for (char & c : result) {\n        unsigned char uc = static_cast<unsigned char>(c);\n        if (std::isalpha(uc)) {\n            has_letter = true;\n            if (std::islower(uc)) {\n                c = static_cast<char>(std::toupper(uc));\n            } else {\n                c = static_cast<char>(std::tolower(uc));\n            }\n        }\n    }\n    if (!has_letter) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_77", "completion": "```cpp\n#include <cctype>\n#include <algorithm>\n#include <string>\n\nstd::string solve(const std::string & s){\n    bool has_alpha = false;\n    std::string result = s;\n    for (char & c : result) {\n        if (std::isalpha(c)) {\n            has_alpha = true;\n            if (std::islower(c)) {\n                c = std::toupper(c);\n            } else {\n                c = std::tolower(c);\n            }\n        }\n    }\n    if (!has_alpha) {\n        std::reverse(result.begin(), result.end());\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (int i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (int i = 0; i < temp.size(); i++) {\n        l[i * 3] = temp[i];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (int i = 0; i < l.size(); i += 3) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (int i = 0; i < temp.size(); ++i) {\n        int idx = i * 3;\n        if (idx < l.size()) {\n            l[idx] = temp[i];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> indices;\n    for (int i = 0; i < l.size(); i += 3) {\n        indices.push_back(i);\n    }\n    std::vector<int> values;\n    for (int index : indices) {\n        if (index < l.size()) {\n            values.push_back(l[index]);\n        }\n    }\n    std::sort(values.begin(), values.end());\n    for (int i = 0; i < indices.size(); ++i) {\n        if (indices[i] < l.size()) {\n            l[indices[i]] = values[i];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> temp;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            temp.push_back(l[i]);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    int j = 0;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            l[i] = temp[j++];\n        }\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_78", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<int> sort_third(std::vector<int> l) {\n    std::vector<int> res = l;\n    std::vector<int> temp;\n    for (int i = 0; i < l.size(); i++) {\n        if (i % 3 == 0) {\n            temp.push_back(l[i]);\n        }\n    }\n    std::sort(temp.begin(), temp.end());\n    int j = 0;\n    for (int i = 0; i < res.size(); i++) {\n        if (i % 3 == 0) {\n            res[i] = temp[j++];\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n\nfloat max_element(std::vector<float> l) {\n    float max = l[0];\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n\nfloat max_element(std::vector<float> l) {\n    float max = l[0];\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n\nfloat max_element(std::vector<float> l){\n    float max_val = l[0];\n    for (int i = 1; i < l.size(); i++) {\n        if (l[i] > max_val) {\n            max_val = l[i];\n        }\n    }\n    return max_val;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n\nfloat max_element(std::vector<float> l) {\n    float max = l[0];\n    for (size_t i = 1; i < l.size(); ++i) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_79", "completion": "```cpp\n#include <vector>\n\nfloat max_element(std::vector<float> l) {\n    float max = l[0];\n    for (int i = 1; i < l.size(); ++i) {\n        if (l[i] > max) {\n            max = l[i];\n        }\n    }\n    return max;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (i % 11 == 0 || i % 13 == 0) {\n            int num = i;\n            do {\n                if (num % 10 == 7) {\n                    count++;\n                }\n                num /= 10;\n            } while (num != 0);\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint count_digit_7(int num) {\n    if (num == 0)\n        return 0;\n    int count = 0;\n    while (num != 0) {\n        if (num % 10 == 7)\n            count++;\n        num /= 10;\n    }\n    return count;\n}\n\nint count_digit_7_in_multiples(int k, int n) {\n    int count = 0;\n    for (int m = 0; m < n; m += k) {\n        count += count_digit_7(m);\n    }\n    return count;\n}\n\nint fizz_buzz(int n) {\n    if (n <= 0)\n        return 0;\n    int count11 = count_digit_7_in_multiples(11, n);\n    int count13 = count_digit_7_in_multiples(13, n);\n    int count143 = count_digit_7_in_multiples(143, n);\n    return count11 + count13 - count143;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint count_digit(int num, int d) {\n    int cnt = 0;\n    do {\n        if (num % 10 == d)\n            cnt++;\n        num /= 10;\n    } while (num != 0);\n    return cnt;\n}\n\nint fizz_buzz(int n) {\n    if (n <= 0) \n        return 0;\n    long long total = 0;\n    for (int i = 0; i < n; i += 11) \n        total += count_digit(i, 7);\n    for (int i = 0; i < n; i += 13) \n        total += count_digit(i, 7);\n    for (int i = 0; i < n; i += 143) \n        total -= count_digit(i, 7);\n    return (int)total;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nstatic int count_digit(int num, int d) {\n    int cnt = 0;\n    do {\n        if (num % 10 == d) {\n            cnt++;\n        }\n        num /= 10;\n    } while (num != 0);\n    return cnt;\n}\n\nint fizz_buzz(int n) {\n    int total = 0;\n    for (long long i = 0; i < n; i += 11) {\n        total += count_digit((int)i, 7);\n    }\n    for (long long i = 0; i < n; i += 13) {\n        total += count_digit((int)i, 7);\n    }\n    for (long long i = 0; i < n; i += 143) {\n        total -= count_digit((int)i, 7);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_80", "completion": "```c\nint fizz_buzz(int n) {\n    int total = 0;\n    for (int i = 0; i < n; i += 11) {\n        int num = i;\n        do {\n            if (num % 10 == 7) {\n                total++;\n            }\n            num /= 10;\n        } while (num != 0);\n    }\n    for (int i = 0; i < n; i += 13) {\n        int num = i;\n        do {\n            if (num % 10 == 7) {\n                total++;\n            }\n            num /= 10;\n        } while (num != 0);\n    }\n    for (int i = 0; i < n; i += 143) {\n        int num = i;\n        do {\n            if (num % 10 == 7) {\n                total--;\n            }\n            num /= 10;\n        } while (num != 0);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> temp;\n    for (int i = 0; i < l.size(); i += 2) {\n        temp.push_back(l[i]);\n    }\n    std::sort(temp.begin(), temp.end());\n    for (int i = 0, j = 0; i < l.size(); i += 2) {\n        l[i] = temp[j++];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even_vals;\n    for (int i = 0; i < l.size(); i += 2) {\n        even_vals.push_back(l[i]);\n    }\n    std::sort(even_vals.begin(), even_vals.end());\n    for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n        l[i] = even_vals[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l) {\n    std::vector<float> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n        l[i] = even[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even;\n    for (size_t i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    for (size_t i = 0, j = 0; i < l.size(); i += 2, ++j) {\n        l[i] = even[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_81", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nstd::vector<float> sort_even(std::vector<float> l){\n    std::vector<float> even;\n    for (int i = 0; i < l.size(); i += 2) {\n        even.push_back(l[i]);\n    }\n    std::sort(even.begin(), even.end());\n    for (int i = 0, j = 0; i < l.size(); i += 2, j++) {\n        l[i] = even[j];\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; i++) {\n        if (i > 0 && l[i] == l[i - 1])\n            continue;\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l){\n    if (l.size() < 3) \n        return false;\n    \n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    \n    for (int i = 0; i < n - 2; i++) {\n        if (i > 0 && l[i] == l[i-1])\n            continue;\n            \n        int left = i + 1;\n        int right = n - 1;\n        \n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <algorithm>\n#include <vector>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) \n        return false;\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; i++) {\n        if (i > 0 && l[i] == l[i-1])\n            continue;\n        int left = i + 1;\n        int right = n - 1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    std::sort(l.begin(), l.end());\n    int n = l.size();\n    for (int i = 0; i < n - 2; i++) {\n        if (i > 0 && l[i] == l[i - 1]) \n            continue;\n        int target = -l[i];\n        int j = i + 1;\n        int k = n - 1;\n        while (j < k) {\n            int sum = l[j] + l[k];\n            if (sum == target) {\n                return true;\n            } else if (sum < target) {\n                j++;\n            } else {\n                k--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_82", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nbool triples_sum_to_zero(std::vector<int> l) {\n    if (l.size() < 3) \n        return false;\n    std::sort(l.begin(), l.end());\n    for (int i = 0; i < l.size()-2; i++) {\n        if (i > 0 && l[i] == l[i-1])\n            continue;\n        int left = i+1;\n        int right = l.size()-1;\n        while (left < right) {\n            int total = l[i] + l[left] + l[right];\n            if (total == 0) {\n                return true;\n            } else if (total < 0) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l){\n    for (int i = 0; i < l.size(); i++) {\n        l[i] += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\nstd::vector<int> incr_list(std::vector<int> l){\n    for (auto& n : l) {\n        n++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto &elem : l) {\n        elem++;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_83", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> incr_list(std::vector<int> l) {\n    for (auto& num : l) {\n        num += 1;\n    }\n    return l;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int num : l) {\n        if (seen.find(-num) != seen.end()) {\n            return true;\n        }\n        seen.insert(num);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <unordered_set>\n#include <vector>\n#include <climits>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::unordered_set<int> seen;\n    for (int x : l) {\n        if (x != INT_MIN) {\n            if (seen.find(-x) != seen.end()) {\n                return true;\n            }\n        }\n        seen.insert(x);\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_84", "completion": "```cpp\n#include <set>\n#include <vector>\n\nbool pairs_sum_to_zero(std::vector<int> l) {\n    std::set<long long> seen;\n    for (int num : l) {\n        long long target = -(static_cast<long long>(num));\n        if (seen.find(target) != seen.end()) {\n            return true;\n        }\n        seen.insert(static_cast<long long>(num));\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n#include <cstdint>\n#include <limits>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    \n    bool is_negative = false;\n    uint64_t n;\n    \n    if (x < 0) {\n        is_negative = true;\n        if (x == std::numeric_limits<int64_t>::min()) {\n            n = static_cast<uint64_t>(std::numeric_limits<int64_t>::max()) + 1;\n        } else {\n            n = static_cast<uint64_t>(-x);\n        }\n    } else {\n        n = static_cast<uint64_t>(x);\n    }\n    \n    std::string res;\n    while (n > 0) {\n        char digit = '0' + static_cast<char>(n % base);\n        res.push_back(digit);\n        n /= base;\n    }\n    \n    if (is_negative) {\n        res.push_back('-');\n    }\n    \n    std::reverse(res.begin(), res.end());\n    return res;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <cstdint>\n#include <algorithm>\n#include <climits>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    bool is_negative = (x < 0);\n    uint64_t num;\n    if (is_negative) {\n        if (x == INT64_MIN) {\n            num = static_cast<uint64_t>(INT64_MAX) + 1;\n        } else {\n            num = static_cast<uint64_t>(-x);\n        }\n    } else {\n        num = static_cast<uint64_t>(x);\n    }\n    std::string digits;\n    while (num != 0) {\n        uint8_t digit = num % base;\n        num = num / base;\n        digits.push_back('0' + digit);\n    }\n    std::reverse(digits.begin(), digits.end());\n    if (is_negative) {\n        digits.insert(0, 1, '-');\n    }\n    return digits;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <cstdint>\n#include <string>\n#include <algorithm>\n#include <climits>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 1 || base > 9) {\n        return \"\";\n    }\n    if (x < 0) {\n        if (x == INT64_MIN) {\n            if (base == 1) {\n                return \"\";\n            }\n            uint64_t abs_x = static_cast<uint64_t>(INT64_MAX) + 1;\n            std::string digits;\n            while (abs_x) {\n                digits += '0' + (abs_x % base);\n                abs_x = abs_x / base;\n            }\n            std::reverse(digits.begin(), digits.end());\n            return \"-\" + digits;\n        }\n        return \"-\" + change_base(-x, base);\n    }\n    if (base == 1) {\n        if (x == 0) {\n            return \"0\";\n        }\n        return std::string(x, '1');\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string digits;\n    uint64_t n = x;\n    while (n) {\n        digits += '0' + (n % base);\n        n = n / base;\n    }\n    std::reverse(digits.begin(), digits.end());\n    return digits;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string digits;\n    while (x > 0) {\n        digits.push_back('0' + (x % base));\n        x /= base;\n    }\n    std::reverse(digits.begin(), digits.end());\n    return digits;\n}\n```"}
{"task_id": "SimdBench_85", "completion": "```cpp\n#include <string>\n#include <algorithm>\n\nstd::string change_base(int64_t x, int8_t base) {\n    if (base < 2 || base > 9) {\n        return \"\";\n    }\n    if (x < 0) {\n        return \"\";\n    }\n    if (x == 0) {\n        return \"0\";\n    }\n    std::string res;\n    while (x > 0) {\n        res += ('0' + (x % base));\n        x /= base;\n    }\n    std::reverse(res.begin(), res.end());\n    return res;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.length() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    if (text.empty()) \n        return true;\n        \n    int left = 0;\n    int right = text.size() - 1;\n    \n    while (left < right) {\n        if (text[left] != text[right])\n            return false;\n        left++;\n        right--;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_86", "completion": "```cpp\n#include <string>\n\nbool is_palindrome(std::string text) {\n    int left = 0;\n    int right = text.size() - 1;\n    while (left < right) {\n        if (text[left] != text[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s) {\n    std::string out;\n    for (int i = 0; i < s.length(); i++) {\n        char c = s[i];\n        c = c - 5;\n        if (c < 'a') {\n            c += 26;\n        }\n        out += c;\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    for (int i = 0; i < s.length(); i++) {\n        int offset = (s[i] - 'a' + 21) % 26;\n        out += ('a' + offset);\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s) {\n    std::string out;\n    for (int i = 0; i < s.length(); i++) {\n        int n = s[i] - 'a';\n        int shifted_n = (n - 5 + 26) % 26;\n        out += (char)(shifted_n + 'a');\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    for (int i=0; i < s.length(); i++) {\n        int n = s[i] - 'a';\n        int original = (n - 5 + 26) % 26;\n        out += (char)(original + 'a');\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_87", "completion": "```cpp\n#include <string>\n\nstd::string decode_shift(std::string s){\n    std::string out;\n    for (int i = 0; i < s.length(); i++) {\n        int x = s[i] - 'a';\n        int decoded_index = (x + 21) % 26;\n        out += (char)(decoded_index + 'a');\n    }\n    return out;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\n#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\n#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\n#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\n#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_88", "completion": "```cpp\n#include <vector>\n\nbool below_threshold(std::vector<int> l, int t) {\n    for (int num : l) {\n        if (num >= t) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n            if (count < 0) {\n                return false;\n            }\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int counter = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            counter++;\n        } else if (c == '>') {\n            counter--;\n        }\n        if (counter < 0) {\n            return false;\n        }\n    }\n    return counter == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            count++;\n        } else if (c == '>') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_89", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '<') {\n            balance++;\n        } else if (c == '>') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int count = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            count++;\n        } else if (c == ')') {\n            count--;\n        }\n        if (count < 0) {\n            return false;\n        }\n    }\n    return count == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_90", "completion": "```cpp\n#include <string>\n\nbool correct_bracketing(std::string brackets) {\n    int balance = 0;\n    for (char c : brackets) {\n        if (c == '(') {\n            balance++;\n        } else if (c == ')') {\n            balance--;\n        }\n        if (balance < 0) {\n            return false;\n        }\n    }\n    return balance == 0;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    if (xs.empty()) {\n        return {};\n    }\n    std::vector<float> result;\n    for (int i = 1; i < xs.size(); ++i) {\n        result.push_back(i * xs[i]);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return {};\n    }\n    std::vector<float> res(xs.size() - 1);\n    for (int i = 1; i < xs.size(); i++) {\n        res[i - 1] = xs[i] * static_cast<float>(i);\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    if (xs.empty()) {\n        return {};\n    }\n    std::vector<float> res;\n    for (int i = 1; i < xs.size(); i++) {\n        res.push_back(xs[i] * i);\n    }\n    while (!res.empty() && res.back() == 0.0f) {\n        res.pop_back();\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    if (xs.size() <= 1) {\n        return std::vector<float>();\n    }\n    std::vector<float> res;\n    for (int i = 1; i < xs.size(); i++) {\n        res.push_back(i * xs[i]);\n    }\n    while (!res.empty() && res.back() == 0.0f) {\n        res.pop_back();\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_91", "completion": "```cpp\n#include <vector>\n\nstd::vector<float> derivative(std::vector<float> xs) {\n    if (xs.empty()) {\n        return {};\n    }\n    if (xs.size() == 1) {\n        return {0};\n    }\n    std::vector<float> res(xs.size() - 1);\n    for (int i = 1; i < xs.size(); i++) {\n        res[i - 1] = i * xs[i];\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    for (char &c : s) {\n        c = std::tolower(static_cast<unsigned char>(c));\n    }\n    int n = s.length();\n    for (int i = 0; i < n; i++) {\n        if (s[i] == 'a' || s[i] == 'e' || s[i] == 'i' || s[i] == 'o' || s[i] == 'u') {\n            count++;\n        }\n    }\n    if (n > 0 && s[n-1] == 'y') {\n        count++;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s) {\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        }\n        if (i == n - 1 && c == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint vowels_count(std::string s) {\n    int count = 0;\n    int n = s.length();\n    for (int i = 0; i < n; ++i) {\n        char c = std::tolower(s[i]);\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            count++;\n        } else if (i == n - 1 && c == 'y') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\nint vowels_count(std::string s){\n    int count = 0;\n    int n = s.size();\n    for (int i = 0; i < n; i++) {\n        char c = s[i];\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    if (n > 0) {\n        char last = s[n-1];\n        if (last == 'y' || last == 'Y') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_92", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint vowels_count(std::string s) {\n    if (s.empty()) \n        return 0;\n    int count = 0;\n    int n = s.size();\n    for (int i = 0; i < n; ++i) {\n        char lower_c = std::tolower(s[i]);\n        if (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u') {\n            ++count;\n        } else if (i == n - 1 && lower_c == 'y') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (std::isupper(c)) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (std::isupper(static_cast<unsigned char>(c))) {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\n#include <string>\n\nint digitSum(std::string s) {\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += c;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_93", "completion": "```cpp\nint digitSum(std::string s){\n    int sum = 0;\n    for (char c : s) {\n        if (c >= 'A' && c <= 'Z') {\n            sum += static_cast<int>(c);\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n#include <climits>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n\n    int min_even = INT_MAX;\n    int min_index = -1;\n\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n\n    if (min_index == -1) {\n        return {};\n    }\n\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    int minValue = -1;\n    int minIndex = -1;\n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (minIndex == -1 || arr[i] < minValue) {\n                minValue = arr[i];\n                minIndex = i;\n            }\n        }\n    }\n    if (minIndex == -1) {\n        return {};\n    }\n    return {minValue, minIndex};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    std::vector<int> result;\n    if (arr.empty()) {\n        return result;\n    }\n    int min_even;\n    int min_index = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (min_index == -1 || arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if (min_index == -1) {\n        return result;\n    }\n    result.push_back(min_even);\n    result.push_back(min_index);\n    return result;\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr){\n    if (arr.empty()) {\n        return {};\n    }\n    int min_even = -1;\n    int min_index = -1;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (min_index == -1) {\n                min_even = arr[i];\n                min_index = i;\n            } else if (arr[i] < min_even) {\n                min_even = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    if (min_index == -1) {\n        return {};\n    }\n    return {min_even, min_index};\n}\n```"}
{"task_id": "SimdBench_94", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> pluck(std::vector<int> arr) {\n    if (arr.empty()) {\n        return {};\n    }\n    \n    int min_value = -1;\n    int min_index = -1;\n    \n    for (int i = 0; i < arr.size(); ++i) {\n        if (arr[i] % 2 == 0) {\n            if (min_index == -1 || arr[i] < min_value) {\n                min_value = arr[i];\n                min_index = i;\n            }\n        }\n    }\n    \n    if (min_index == -1) {\n        return {};\n    }\n    \n    return {min_value, min_index};\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <vector>\n#include <unordered_map>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int max_valid = -1;\n    for (const auto& pair : freq) {\n        int num = pair.first;\n        int count = pair.second;\n        if (num <= count && num > max_valid) {\n            max_valid = num;\n        }\n    }\n    return max_valid;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <unordered_map>\n#include <vector>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> counts;\n    for (int num : lst) {\n        counts[num]++;\n    }\n    int result = -1;\n    for (const auto& pair : counts) {\n        if (pair.second >= pair.first && pair.first > result) {\n            result = pair.first;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <unordered_map>\n#include <vector>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int ans = -1;\n    for (const auto& kv : freq) {\n        if (kv.second >= kv.first && kv.first > ans) {\n            ans = kv.first;\n        }\n    }\n    return ans;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <unordered_map>\n#include <vector>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    int candidate = -1;\n    for (const auto& pair : freq) {\n        if (pair.second >= pair.first && pair.first > candidate) {\n            candidate = pair.first;\n        }\n    }\n    return candidate;\n}\n```"}
{"task_id": "SimdBench_95", "completion": "```cpp\n#include <unordered_map>\n#include <vector>\n\nint search(std::vector<int> lst) {\n    std::unordered_map<int, int> freq;\n    for (int num : lst) {\n        freq[num]++;\n    }\n    \n    int candidate = -1;\n    for (const auto& kv : freq) {\n        if (kv.second >= kv.first) {\n            if (kv.first > candidate) {\n                candidate = kv.first;\n            }\n        }\n    }\n    \n    return candidate;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int n = q.size();\n    for (int i = 0; i < n / 2; ++i) {\n        if (q[i] != q[n - 1 - i]) {\n            return false;\n        }\n    }\n    int sum = accumulate(q.begin(), q.end(), 0);\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <numeric>\n#include <algorithm>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int sum = std::accumulate(q.begin(), q.end(), 0);\n    if (sum > w) {\n        return false;\n    }\n    return std::equal(q.begin(), q.begin() + q.size() / 2, q.rbegin());\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int left = 0;\n    int right = q.size() - 1;\n    int total = 0;\n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        total += q[left] + q[right];\n        left++;\n        right--;\n    }\n    if (left == right) {\n        total += q[left];\n    }\n    return total <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <numeric>\nusing namespace std;\n\nbool will_it_fly(vector<int> q, int w) {\n    int left = 0, right = q.size() - 1;\n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    int total = accumulate(q.begin(), q.end(), 0);\n    return total <= w;\n}\n```"}
{"task_id": "SimdBench_96", "completion": "```cpp\n#include <vector>\n\nbool will_it_fly(std::vector<int> q, int w) {\n    int left = 0, right = q.size() - 1;\n    while (left < right) {\n        if (q[left] != q[right]) {\n            return false;\n        }\n        left++;\n        right--;\n    }\n    int sum = 0;\n    for (int num : q) {\n        sum += num;\n    }\n    return sum <= w;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            changes++;\n        }\n        left++;\n        right--;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int changes = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            changes++;\n        }\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int left = 0;\n    int right = arr.size() - 1;\n    int count = 0;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            count++;\n        }\n        left++;\n        right--;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int n = arr.size();\n    int count = 0;\n    for (int i = 0; i < n / 2; i++) {\n        if (arr[i] != arr[n - 1 - i]) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_97", "completion": "```cpp\n#include <vector>\n\nint smallest_change(std::vector<int> arr) {\n    int changes = 0;\n    int left = 0;\n    int right = arr.size() - 1;\n    while (left < right) {\n        if (arr[left] != arr[right]) {\n            ++changes;\n        }\n        ++left;\n        --right;\n    }\n    return changes;\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int sum1 = 0;\n    for (const auto& s : lst1) {\n        sum1 += s.length();\n    }\n    int sum2 = 0;\n    for (const auto& s : lst2) {\n        sum2 += s.length();\n    }\n    if (sum1 <= sum2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0;\n    for (const auto& s : lst1) {\n        total1 += s.size();\n    }\n    int total2 = 0;\n    for (const auto& s : lst2) {\n        total2 += s.size();\n    }\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    size_t total1 = 0;\n    for (const auto& s : lst1) {\n        total1 += s.length();\n    }\n    size_t total2 = 0;\n    for (const auto& s : lst2) {\n        total2 += s.length();\n    }\n    if (total1 > total2) {\n        return lst2;\n    } else {\n        return lst1;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <cctype>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n    for (const auto &s : lst1) {\n        total1 += s.length();\n    }\n    for (const auto &s : lst2) {\n        total2 += s.length();\n    }\n    if (total1 <= total2) {\n        return lst1;\n    } else {\n        return lst2;\n    }\n}\n```"}
{"task_id": "SimdBench_98", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> total_match(const std::vector<std::string> & lst1, const std::vector<std::string> & lst2) {\n    int total1 = 0, total2 = 0;\n    for (const auto& s : lst1) total1 += s.length();\n    for (const auto& s : lst2) total2 += s.length();\n    return (total1 <= total2) ? lst1 : lst2;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cstdint>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 0) {\n        return n == 0;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 0) {\n        return false;\n    }\n    if (n == 1) {\n        return false;\n    }\n    while (x % n == 0) {\n        x /= n;\n    }\n    return x == 1;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cstdint>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return (x == 0 || x == 1);\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    if (n == 1) {\n        return false;\n    }\n    uint64_t current = 1;\n    while (current <= x / n) {\n        current *= n;\n        if (current == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdint.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return x == 0;\n    }\n    if (n == 1) {\n        return x == 1;\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    uint64_t current = 1;\n    while (current <= x / n) {\n        current *= n;\n        if (current == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```cpp\n#include <cstdint>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (x == 0) {\n        return n == 0;\n    }\n    if (x == 1) {\n        return n != 0;\n    }\n    if (n == 0) {\n        return false;\n    }\n    if (n == 1) {\n        return false;\n    }\n    uint64_t power = 1;\n    while (power < x) {\n        if (power > x / n) {\n            break;\n        }\n        power = power * n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_99", "completion": "```c\n#include <stdbool.h>\n#include <stdint.h>\n\nbool is_simple_power(uint64_t x, uint64_t n) {\n    if (n == 0) {\n        return (x == 0);\n    }\n    if (n == 1) {\n        return (x == 1);\n    }\n    if (x == 0) {\n        return false;\n    }\n    if (x == 1) {\n        return true;\n    }\n    uint64_t power = 1;\n    while (power <= x / n) {\n        power *= n;\n        if (power == x) {\n            return true;\n        }\n    }\n    return false;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n\nint hex_key(const std::string &num) {\n    int count = 0;\n    for (char c : num) {\n        int value;\n        if (c >= '0' && c <= '9') {\n            value = c - '0';\n        } else {\n            value = c - 'A' + 10;\n        }\n        if (value == 2 || value == 3 || value == 5 || value == 7 || value == 11 || value == 13) {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n\nint hex_key(const std::string & num){\n    static const bool isPrime[16] = {\n        false, // 0\n        false, // 1\n        true,  // 2\n        true,  // 3\n        false, // 4\n        true,  // 5\n        false, // 6\n        true,  // 7\n        false, // 8\n        false, // 9\n        false, // A (10)\n        true,  // B (11)\n        false, // C (12)\n        true,  // D (13)\n        false, // E (14)\n        false  // F (15)\n    };\n    \n    int count = 0;\n    for (char c : num) {\n        int digit = (c >= '0' && c <= '9') ? (c - '0') : (10 + (c - 'A'));\n        if (isPrime[digit]) \n            ++count;\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\nint hex_key(const std::string & num){\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_100", "completion": "```cpp\n#include <string>\n\nint hex_key(const std::string & num) {\n    int count = 0;\n    for (char c : num) {\n        if (c == '2' || c == '3' || c == '5' || c == '7' || c == 'B' || c == 'D') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.size() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.size() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s){\n    if (s.size() < 3) {\n        return false;\n    }\n    for (size_t i = 0; i <= s.size() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s){\n    if (s.length() < 3) \n        return false;\n    for (size_t i = 0; i < s.length() - 2; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.size() < 3)\n        return false;\n    for (size_t i = 0; i <= s.size() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2])\n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_101", "completion": "```cpp\n#include <string>\n\nbool is_happy(const std::string & s) {\n    if (s.length() < 3) \n        return false;\n    for (size_t i = 0; i <= s.length() - 3; ++i) {\n        if (s[i] == s[i+1] || s[i] == s[i+2] || s[i+1] == s[i+2]) \n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n\nbool prime_length(const std::string & str) {\n    size_t n = str.length();\n    if (n <= 1) {\n        return false;\n    }\n    for (size_t i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool prime_length(const std::string & str) {\n    int n = str.length();\n    if (n < 2) return false;\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n\nbool prime_length(const std::string & str) {\n    int n = str.length();\n    if (n < 2) \n        return false;\n    if (n == 2) \n        return true;\n    if (n % 2 == 0) \n        return false;\n    int limit = sqrt(n) + 1;\n    for (int i = 3; i <= limit; i += 2) {\n        if (n % i == 0) \n            return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <string>\n#include <cmath>\n\nbool prime_length(const std::string & str) {\n    size_t len = str.length();\n    if (len < 2) {\n        return false;\n    }\n    for (size_t i = 2; i <= std::sqrt(len); ++i) {\n        if (len % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_102", "completion": "```cpp\n#include <cmath>\n#include <string>\n\nbool prime_length(const std::string & str) {\n    int n = str.length();\n    if (n < 2) {\n        return false;\n    }\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    if (sum == 0) {\n        return \"0\";\n    }\n    std::string binary;\n    while (sum > 0) {\n        binary = char('0' + (sum & 1)) + binary;\n        sum >>= 1;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <cstdint>\nusing namespace std;\n\nstring solve(uint64_t N) {\n    uint64_t sum = 0;\n    while (N > 0) {\n        sum += N % 10;\n        N /= 10;\n    }\n    if (sum == 0) {\n        return \"0\";\n    }\n    string binary;\n    while (sum > 0) {\n        binary.push_back((sum % 2) + '0');\n        sum /= 2;\n    }\n    reverse(binary.begin(), binary.end());\n    return binary;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N){\n    uint64_t temp = 0;\n    uint64_t num = N;\n    while (num) {\n        temp += num % 10;\n        num /= 10;\n    }\n    \n    std::string bin = \"\";\n    while (temp) {\n        bin = char('0' + (temp % 2)) + bin;\n        temp /= 2;\n    }\n    return bin;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string solve(uint64_t N) {\n    if (N == 0) {\n        return \"0\";\n    }\n    uint64_t temp = N;\n    uint64_t sum = 0;\n    while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n    std::string bin;\n    while (sum != 0) {\n        bin = char((sum % 2) + '0') + bin;\n        sum /= 2;\n    }\n    return bin;\n}\n```"}
{"task_id": "SimdBench_103", "completion": "```cpp\n#include <string>\n\nstd::string solve(uint64_t N) {\n    uint64_t temp = N;\n    uint64_t sum = 0;\n    while (temp != 0) {\n        sum += temp % 10;\n        temp /= 10;\n    }\n\n    std::string result = \"\";\n    while (sum != 0) {\n        result = char('0' + (sum % 2)) + result;\n        sum /= 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 2 != 0 && lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_104", "completion": "```cpp\n#include <vector>\n\nint add(std::vector<int> lst) {\n    int sum = 0;\n    for (int i = 1; i < lst.size(); i += 2) {\n        if (lst[i] % 2 == 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            result += 'A' + (c - 'A' + 4) % 26;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += (c - 'a' + 4) % 26 + 'a';\n        } else if (c >= 'A' && c <= 'Z') {\n            result += (c - 'A' + 4) % 26 + 'A';\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += 'a' + (c - 'a' + 4) % 26;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s) {\n    std::string result = \"\";\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += 'a' + (c - 'a' + 4) % 26;\n        } else if (c >= 'A' && c <= 'Z') {\n            result += 'A' + (c - 'A' + 4) % 26;\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_105", "completion": "```cpp\n#include <string>\n\nstd::string encrypt(const std::string & s){\n    std::string result;\n    for (char c : s) {\n        if (c >= 'a' && c <= 'z') {\n            result += (c - 'a' + 4) % 26 + 'a';\n        } else {\n            result += c;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message){\n    std::string result;\n    for (char c : message) {\n        if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n            c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            c = c + 2;\n        }\n        if (c >= 'a' && c <= 'z') {\n            c = c - 'a' + 'A';\n        } else if (c >= 'A' && c <= 'Z') {\n            c = c - 'A' + 'a';\n        }\n        result.push_back(c);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result = message;\n    for (char & c : result) {\n        if (c >= 'A' && c <= 'Z') {\n            c += 32;\n        } else if (c >= 'a' && c <= 'z') {\n            c -= 32;\n        }\n    }\n    for (char & c : result) {\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' || \n            c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u') {\n            c += 2;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result;\n    for (char c : message) {\n        if (!std::isalpha(c)) {\n            result += c;\n            continue;\n        }\n        char swapped = std::islower(c) ? std::toupper(c) : std::tolower(c);\n        char upper_swapped = std::toupper(swapped);\n        if (upper_swapped == 'A' || upper_swapped == 'E' || upper_swapped == 'I' || upper_swapped == 'O' || upper_swapped == 'U') {\n            int index = upper_swapped - 'A';\n            char new_char = 'A' + index + 2;\n            if (std::islower(swapped)) {\n                new_char = std::tolower(new_char);\n            }\n            result += new_char;\n        } else {\n            result += swapped;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result = message;\n    for (char & c : result) {\n        if (std::isupper(c)) {\n            c = std::tolower(c);\n        } else {\n            c = std::toupper(c);\n        }\n    }\n    for (char & c : result) {\n        char lower_c = std::tolower(c);\n        if (lower_c == 'a' || lower_c == 'e' || lower_c == 'i' || lower_c == 'o' || lower_c == 'u') {\n            if (std::islower(c)) {\n                c = 'a' + (c - 'a' + 2);\n            } else {\n                c = 'A' + (c - 'A' + 2);\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_106", "completion": "```cpp\n#include <cctype>\n#include <string>\n\nstd::string encode(const std::string & message) {\n    std::string result = message;\n    for (char & c : result) {\n        if (std::isalpha(c)) {\n            if (std::islower(c)) {\n                c = std::toupper(c);\n            } else {\n                c = std::tolower(c);\n            }\n        }\n    }\n    for (char & c : result) {\n        if (std::isalpha(c)) {\n            if (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n                c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                c += 2;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_upper = true;\n    bool all_lower = true;\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        if (key.empty()) {\n            all_upper = false;\n            all_lower = false;\n        } else {\n            bool this_upper = true;\n            bool this_lower = true;\n            for (char c : key) {\n                unsigned char uc = static_cast<unsigned char>(c);\n                if (std::isalpha(uc)) {\n                    if (!std::isupper(uc)) {\n                        this_upper = false;\n                    }\n                    if (!std::islower(uc)) {\n                        this_lower = false;\n                    }\n                } else {\n                    this_upper = false;\n                    this_lower = false;\n                    break;\n                }\n            }\n            all_upper = all_upper && this_upper;\n            all_lower = all_lower && this_lower;\n        }\n    }\n    return all_upper || all_lower;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool condition1 = true;\n    bool condition2 = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        bool is_lower = !key.empty();\n        bool is_upper = !key.empty();\n\n        if (!key.empty()) {\n            for (char c : key) {\n                if (is_lower && !std::islower(static_cast<unsigned char>(c))) {\n                    is_lower = false;\n                }\n                if (is_upper && !std::isupper(static_cast<unsigned char>(c))) {\n                    is_upper = false;\n                }\n                if (!is_lower && !is_upper) {\n                    break;\n                }\n            }\n        }\n\n        if (!is_lower) {\n            condition1 = false;\n        }\n        if (!is_upper) {\n            condition2 = false;\n        }\n\n        if (!condition1 && !condition2) {\n            break;\n        }\n    }\n\n    return condition1 || condition2;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    bool all_lower = true;\n    bool all_upper = true;\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        bool has_alpha = false;\n        for (char c : key) {\n            unsigned char uc = static_cast<unsigned char>(c);\n            if (std::isalpha(uc)) {\n                has_alpha = true;\n                if (!std::islower(uc)) {\n                    all_lower = false;\n                }\n                if (!std::isupper(uc)) {\n                    all_upper = false;\n                }\n            }\n        }\n        if (!has_alpha) {\n            all_lower = false;\n            all_upper = false;\n        }\n        if (!all_lower && !all_upper) {\n            break;\n        }\n    }\n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n\n    bool all_lower = true;\n    bool all_upper = true;\n\n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        bool has_alpha = false;\n        bool this_lower = true;\n        bool this_upper = true;\n\n        for (char c : key) {\n            if (std::isalpha(static_cast<unsigned char>(c))) {\n                has_alpha = true;\n                if (std::isupper(static_cast<unsigned char>(c))) {\n                    this_lower = false;\n                }\n                if (std::islower(static_cast<unsigned char>(c))) {\n                    this_upper = false;\n                }\n            }\n        }\n\n        if (!has_alpha) {\n            this_lower = false;\n            this_upper = false;\n        }\n\n        all_lower = all_lower && this_lower;\n        all_upper = all_upper && this_upper;\n\n        if (!all_lower && !all_upper) {\n            break;\n        }\n    }\n\n    return (all_lower || all_upper);\n}\n```"}
{"task_id": "SimdBench_107", "completion": "```cpp\n#include <cctype>\n#include <map>\n#include <string>\n\nbool check_dict_case(std::map<std::string, std::string> dict) {\n    if (dict.empty()) {\n        return false;\n    }\n    \n    bool all_lower = true;\n    bool all_upper = true;\n    \n    for (const auto& kv : dict) {\n        const std::string& key = kv.first;\n        bool has_alpha = false;\n        bool key_lower = true;\n        bool key_upper = true;\n        \n        for (char c : key) {\n            if (std::isalpha(static_cast<unsigned char>(c))) {\n                has_alpha = true;\n                if (std::isupper(static_cast<unsigned char>(c))) {\n                    key_lower = false;\n                }\n                if (std::islower(static_cast<unsigned char>(c))) {\n                    key_upper = false;\n                }\n            }\n        }\n        \n        if (!has_alpha) {\n            return false;\n        }\n        \n        if (!key_lower) {\n            all_lower = false;\n        }\n        if (!key_upper) {\n            all_upper = false;\n        }\n        \n        if (!all_lower && !all_upper) {\n            break;\n        }\n    }\n    \n    return all_lower || all_upper;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i < n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i <= std::sqrt(n); ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int p = 2; p <= std::sqrt(n); ++p) {\n        if (is_prime[p]) {\n            for (int i = p * p; i < n; i += p) {\n                is_prime[i] = false;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> count_up_to(int n) {\n    if (n < 2) {\n        return std::vector<int>();\n    }\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    for (int i = 2; i * i < n; i++) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < n; i++) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_108", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nstd::vector<int> count_up_to(int n) {\n    if (n <= 2) {\n        return {};\n    }\n    std::vector<bool> is_prime(n, true);\n    is_prime[0] = false;\n    is_prime[1] = false;\n    int sqrt_n = static_cast<int>(std::sqrt(n)) + 1;\n    for (int i = 2; i < sqrt_n; ++i) {\n        if (is_prime[i]) {\n            for (int j = i * i; j < n; j += i) {\n                is_prime[j] = false;\n            }\n        }\n    }\n    std::vector<int> primes;\n    for (int i = 2; i < n; ++i) {\n        if (is_prime[i]) {\n            primes.push_back(i);\n        }\n    }\n    return primes;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        if (s[i] == 'A' || s[i] == 'E' || s[i] == 'I' || s[i] == 'O' || s[i] == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (int i = 0; i < s.size(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n#include <cctype>\n\nint count_upper(const std::string & s){\n    int count = 0;\n    for (int i = 0; i < s.length(); i += 2) {\n        char c = s[i];\n        if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n            ++count;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_109", "completion": "```cpp\n#include <string>\n\nint count_upper(const std::string & s) {\n    int count = 0;\n    for (int i = 0; i < s.length(); ++i) {\n        if (i % 2 == 0) {\n            char c = s[i];\n            if (c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {\n                ++count;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(n + 2 * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> res(n);\n    for (int i = 0; i < n; ++i) {\n        res[i] = n + 2 * i;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n) {\n    std::vector<int> result;\n    int current = n;\n    for (int i = 0; i < n; i++) {\n        result.push_back(current);\n        current += 2;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> result(n);\n    for (int i = 0; i < n; ++i) {\n        result[i] = n + 2 * i;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_110", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> make_a_pile(int n){\n    std::vector<int> result;\n    for (int i = 0; i < n; ++i) {\n        result.push_back(n + 2 * i);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t diff = m - n;\n    int64_t avg_val = n + diff / 2;\n    \n    if (avg_val == 0) {\n        return \"0\";\n    }\n    \n    std::string binary = \"\";\n    int64_t num = avg_val;\n    while (num != 0) {\n        binary = (num % 2 ? '1' : '0') + binary;\n        num /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t num = n + (m - n) / 2;\n    std::string bin;\n    do {\n        bin = char('0' + (num % 2)) + bin;\n        num = num / 2;\n    } while (num != 0);\n    return bin;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n#include <cstdint>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t num = n + (m - n) / 2;\n    if (num == 0) {\n        return \"0\";\n    }\n    std::string binary;\n    while (num != 0) {\n        binary = char('0' + (num % 2)) + binary;\n        num /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t total = n + m;\n    int64_t rounded = total / 2;\n    if (rounded == 0) {\n        return \"0\";\n    }\n    std::string binary;\n    while (rounded != 0) {\n        binary = char('0' + (rounded % 2)) + binary;\n        rounded /= 2;\n    }\n    return binary;\n}\n```"}
{"task_id": "SimdBench_111", "completion": "```cpp\n#include <string>\n\nstd::string rounded_avg(int64_t n, int64_t m) {\n    if (n > m) {\n        return \"-1\";\n    }\n    int64_t x = (n + m) / 2;\n    std::string bin = \"\";\n    do {\n        bin = char('0' + (x % 2)) + bin;\n        x = x / 2;\n    } while (x != 0);\n    return bin;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> res;\n    if (n <= 0) return res;\n    res.reserve(n);\n    int fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = (fact * i) % 10000;\n        if (i % 2 == 0) {\n            res.push_back(fact);\n        } else {\n            long long product = static_cast<long long>(i) * (i + 1);\n            int sum = static_cast<int>(product / 2);\n            res.push_back(sum);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> res(n);\n    int fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = (fact * (i % 10000)) % 10000;\n        if (i % 2 == 0) {\n            res[i-1] = fact;\n        } else {\n            res[i-1] = static_cast<long long>(i) * (i+1) / 2;\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> res(n);\n    long long fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = (fact * i) % 10000;\n        if (i % 2 == 1) {\n            res[i-1] = static_cast<int>(static_cast<long long>(i) * (i+1) / 2);\n        } else {\n            res[i-1] = static_cast<int>(fact);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    if (n <= 0) {\n        return std::vector<int>();\n    }\n    std::vector<int> result(n);\n    long long fact = 1;\n    for (int i = 1; i <= n; ++i) {\n        fact = (fact * i) % 10000;\n        if (i % 2 == 1) {\n            result[i-1] = static_cast<long long>(i) * (i+1) / 2;\n        } else {\n            result[i-1] = static_cast<int>(fact);\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_112", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> func(int n) {\n    std::vector<int> res(n);\n    long long fact = 1;\n    for (int i = 1; i <= n; i++) {\n        fact = (fact * i) % 10000;\n        if (i % 2 == 0) {\n            res[i-1] = static_cast<int>(fact);\n        } else {\n            long long tri = (static_cast<long long>(i) * (i+1)) / 2;\n            res[i-1] = static_cast<int>(tri);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int even = 0, odd = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev = s;\n        std::reverse(rev.begin(), rev.end());\n        if (s == rev) {\n            if (i % 2 == 0) {\n                even++;\n            } else {\n                odd++;\n            }\n        }\n    }\n    return {even, odd};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nbool is_palindrome(int num) {\n    std::string s = std::to_string(num);\n    std::string rev = s;\n    std::reverse(rev.begin(), rev.end());\n    return s == rev;\n}\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        if (is_palindrome(i)) {\n            if (i % 2 == 0) \n                ++evenCount;\n            else \n                ++oddCount;\n        }\n    }\n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> result(2, 0);\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev = s;\n        std::reverse(rev.begin(), rev.end());\n        if (s == rev) {\n            if (i % 2 == 0) {\n                result[0]++;\n            } else {\n                result[1]++;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    std::vector<int> res(2, 0);\n    for (int num = 1; num <= n; num++) {\n        int reversed = 0;\n        int temp = num;\n        while (temp != 0) {\n            reversed = reversed * 10 + (temp % 10);\n            temp /= 10;\n        }\n        if (reversed == num) {\n            if (num % 2 == 0) {\n                res[0]++;\n            } else {\n                res[1]++;\n            }\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_113", "completion": "```cpp\n#include <vector>\n#include <string>\n#include <algorithm>\n\nstd::vector<int> even_odd_palindrome(int n) {\n    int evenCount = 0, oddCount = 0;\n    for (int i = 1; i <= n; ++i) {\n        std::string s = std::to_string(i);\n        std::string rev = s;\n        std::reverse(rev.begin(), rev.end());\n        if (s == rev) {\n            if (i % 2 == 0) \n                evenCount++;\n            else \n                oddCount++;\n        }\n    }\n    return {evenCount, oddCount};\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        std::string s = std::to_string(num);\n        int digit_sum = 0;\n        if (s[0] == '-') {\n            if (s.length() > 1) {\n                digit_sum = -(s[1] - '0');\n                for (int i = 2; i < s.length(); i++) {\n                    digit_sum += (s[i] - '0');\n                }\n            }\n        } else {\n            for (int i = 0; i < s.length(); i++) {\n                digit_sum += (s[i] - '0');\n            }\n        }\n        if (digit_sum > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <string>\n#include <vector>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        std::string s;\n        if (num < 0) {\n            s = std::to_string(num).substr(1);\n        } else {\n            s = std::to_string(num);\n        }\n        int total = 0;\n        for (int i = 0; i < s.size(); i++) {\n            int digit = s[i] - '0';\n            if (num < 0 && i == 0) {\n                total -= digit;\n            } else {\n                total += digit;\n            }\n        }\n        if (total > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    int count = 0;\n    for (int num : n) {\n        std::string s = std::to_string(num);\n        int total = 0;\n        int i = 0;\n        if (s[0] == '-') {\n            total = -(s[1] - '0');\n            i = 2;\n        } else {\n            total = s[0] - '0';\n            i = 1;\n        }\n        for (; i < s.size(); i++) {\n            total += (s[i] - '0');\n        }\n        if (total > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <string>\n#include <vector>\n\nint count_nums(std::vector<int> n){\n    int count = 0;\n    for (int num : n) {\n        std::string s = std::to_string(num);\n        int total = 0;\n        if (s[0] == '-') {\n            total = -(s[1] - '0');\n            for (int i = 2; i < s.size(); i++) {\n                total += (s[i] - '0');\n            }\n        } else {\n            for (int i = 0; i < s.size(); i++) {\n                total += (s[i] - '0');\n            }\n        }\n        if (total > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_114", "completion": "```cpp\n#include <vector>\n#include <string>\n\nint count_nums(std::vector<int> n) {\n    auto digit_sum = [](int num) -> int {\n        std::string s = std::to_string(num);\n        int total = 0;\n        if (s[0] == '-') {\n            total = -(s[1] - '0');\n            for (int i = 2; i < s.size(); i++) {\n                total += (s[i] - '0');\n            }\n        } else {\n            for (int i = 0; i < s.size(); i++) {\n                total += (s[i] - '0');\n            }\n        }\n        return total;\n    };\n\n    int count = 0;\n    for (int num : n) {\n        if (digit_sum(num) > 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n    if (arr.empty()) \n        return true;\n    int n = arr.size();\n    int drops = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i+1) % n])\n            drops++;\n    }\n    return drops <= 1;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) \n        return true;\n    \n    int min_index = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n    \n    for (int i = 0; i < n - 1; i++) {\n        int current = arr[(min_index + i) % n];\n        int next = arr[(min_index + i + 1) % n];\n        if (current > next) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) return true;\n    int count = 0;\n    for (int i = 0; i < n; i++) {\n        if (arr[i] > arr[(i+1) % n]) {\n            count++;\n            if (count > 1) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\n\nbool move_one_ball(std::vector<int> arr) {\n    int n = arr.size();\n    if (n == 0) \n        return true;\n    \n    int min_index = 0;\n    for (int i = 1; i < n; ++i) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n    \n    for (int j = 0; j < n - 1; ++j) {\n        int current = (min_index + j) % n;\n        int next = (min_index + j + 1) % n;\n        if (arr[current] > arr[next]) {\n            return false;\n        }\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_115", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nbool move_one_ball(vector<int> arr) {\n    if (arr.empty()) {\n        return true;\n    }\n    int n = arr.size();\n    int min_index = 0;\n    for (int i = 1; i < n; i++) {\n        if (arr[i] < arr[min_index]) {\n            min_index = i;\n        }\n    }\n\n    for (int i = 0; i < n - 1; i++) {\n        int current = (min_index + i) % n;\n        int next = (min_index + i + 1) % n;\n        if (arr[current] > arr[next]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int total_evens = 0;\n    for (int num : lst1) {\n        if (num % 2 == 0) \n            total_evens++;\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) \n            total_evens++;\n    }\n    if (total_evens >= lst1.size()) \n        return \"YES\";\n    else \n        return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int count = 0;\n    for (int num : lst1) {\n        if (num % 2 == 0) {\n            count++;\n        }\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            count++;\n        }\n    }\n    return count >= lst1.size() ? \"YES\" : \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2) {\n    int odd1 = 0;\n    for (int num : lst1) {\n        if (num % 2 != 0) {\n            odd1++;\n        }\n    }\n    int even2 = 0;\n    for (int num : lst2) {\n        if (num % 2 == 0) {\n            even2++;\n        }\n    }\n    if (even2 >= odd1) {\n        return \"YES\";\n    }\n    return \"NO\";\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int totalEvens = 0;\n    for (int num : lst1) {\n        if (num % 2 == 0) totalEvens++;\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) totalEvens++;\n    }\n    if (totalEvens >= lst1.size()) {\n        return \"YES\";\n    } else {\n        return \"NO\";\n    }\n}\n```"}
{"task_id": "SimdBench_116", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::string myexchange(const std::vector<int>& lst1, const std::vector<int>& lst2){\n    int total_evens = 0;\n    for (int num : lst1) {\n        if (num % 2 == 0) \n            total_evens++;\n    }\n    for (int num : lst2) {\n        if (num % 2 == 0) \n            total_evens++;\n    }\n    if (total_evens >= lst1.size()) \n        return \"YES\";\n    else \n        return \"NO\";\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                count++;\n            }\n        }\n        std::string countStr = std::to_string(count);\n        std::string base = \"the number of odd elements in the string i of the input.\";\n        std::string newStr;\n        for (char c : base) {\n            if (c == 'i') {\n                newStr += countStr;\n            } else {\n                newStr += c;\n            }\n        }\n        result.push_back(newStr);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst) {\n    std::vector<std::string> result;\n    std::string base = \"the number of odd elements in the string i of the input.\";\n    for (const std::string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                count++;\n            }\n        }\n        std::string count_str = std::to_string(count);\n        std::string output;\n        for (char c : base) {\n            if (c == 'i') {\n                output += count_str;\n            } else {\n                output += c;\n            }\n        }\n        result.push_back(output);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const std::string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            int digit = c - '0';\n            if (digit % 2 != 0) {\n                ++count;\n            }\n        }\n        std::string count_str = std::to_string(count);\n        std::string output_str;\n        for (char t : \"the number of odd elements in the string i of the input.\") {\n            if (t == 'i') {\n                output_str += count_str;\n            } else if (t != '\\0') {\n                output_str += t;\n            }\n        }\n        result.push_back(output_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    std::string template_str = \"the number of odd elements in the string i of the input.\";\n    for (const std::string& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            int digit = c - '0';\n            if (digit % 2 != 0) {\n                count++;\n            }\n        }\n        std::string count_str = std::to_string(count);\n        std::string new_str;\n        for (char t : template_str) {\n            if (t == 'i') {\n                new_str += count_str;\n            } else {\n                new_str += t;\n            }\n        }\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_117", "completion": "```cpp\n#include <vector>\n#include <string>\n\nstd::vector<std::string> odd_count(const std::vector<std::string> & lst){\n    std::vector<std::string> result;\n    for (const auto& s : lst) {\n        int count = 0;\n        for (char c : s) {\n            if (c == '1' || c == '3' || c == '5' || c == '7' || c == '9') {\n                count++;\n            }\n        }\n        std::string count_str = std::to_string(count);\n        std::string base = \"the number of odd elements in the string i of the input.\";\n        std::string new_str;\n        for (char base_char : base) {\n            if (base_char == 'i') {\n                new_str += count_str;\n            } else {\n                new_str += base_char;\n            }\n        }\n        result.push_back(new_str);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    if (nums.empty()) return 0;\n    int64_t current = nums[0];\n    int64_t global_min = nums[0];\n    for (auto it = nums.begin() + 1; it != nums.end(); ++it) {\n        current = std::min(*it, current + *it);\n        global_min = std::min(global_min, current);\n    }\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) return 0;\n    int64_t min_ending_here = nums[0];\n    int64_t min_so_far = nums[0];\n    for (int i = 1; i < nums.size(); ++i) {\n        min_ending_here = std::min(nums[i], min_ending_here + nums[i]);\n        min_so_far = std::min(min_so_far, min_ending_here);\n    }\n    return min_so_far;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <climits>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    int64_t current_min = 0;\n    int64_t global_min = LLONG_MAX;\n    int64_t total_sum = 0;\n    for (size_t i = 0; i < nums.size(); ++i) {\n        if (current_min > 0) {\n            current_min = nums[i];\n        } else {\n            current_min += nums[i];\n        }\n        if (current_min < global_min) {\n            global_min = current_min;\n        }\n    }\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n#include <cstdint>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums){\n    if (nums.empty()) {\n        return 0;\n    }\n    int64_t current = nums[0];\n    int64_t best = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current = std::min(nums[i], current + nums[i]);\n        best = std::min(best, current);\n    }\n    return best;\n}\n```"}
{"task_id": "SimdBench_118", "completion": "```cpp\n#include <vector>\n#include <algorithm>\n\nint64_t minSubArraySum(const std::vector<int64_t>& nums) {\n    if (nums.empty()) {\n        return 0;\n    }\n    int64_t current_min = nums[0];\n    int64_t global_min = nums[0];\n    for (size_t i = 1; i < nums.size(); ++i) {\n        current_min = std::min(nums[i], current_min + nums[i]);\n        global_min = std::min(global_min, current_min);\n    }\n    return global_min;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\nusing namespace std;\n\nint max_fill(const vector<vector<int> > & grid, int capacity) {\n    long long total_times = 0;\n    for (const auto& row : grid) {\n        int count = 0;\n        for (int val : row) {\n            count += val;\n        }\n        total_times += (count + capacity - 1) / capacity;\n    }\n    return static_cast<int>(total_times);\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_ops = 0;\n    for (const auto& row : grid) {\n        int count = 0;\n        for (int val : row) {\n            count += val;\n        }\n        total_ops += (count + capacity - 1) / capacity;\n    }\n    return total_ops;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n\nint max_fill(const std::vector<std::vector<int> > &grid, int capacity) {\n    long long total = 0;\n    for (const auto& row : grid) {\n        int count = 0;\n        for (int val : row) {\n            count += val;\n        }\n        if (count > 0) {\n            total += (count + capacity - 1) / capacity;\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n\nint max_fill(const std::vector<std::vector<int> > & grid, int capacity) {\n    long long total_lowerings = 0;\n    for (const auto& row : grid) {\n        int sum = 0;\n        for (int val : row) {\n            sum += val;\n        }\n        if (sum > 0) {\n            total_lowerings += (sum + (long long)capacity - 1) / capacity;\n        }\n    }\n    return total_lowerings;\n}\n```"}
{"task_id": "SimdBench_119", "completion": "```cpp\n#include <vector>\n\nint max_fill(const std::vector<std::vector<int> > & grid,int capacity){\n    int total_trips = 0;\n    for (const auto& row : grid) {\n        int count = 0;\n        for (int x : row) {\n            count += x;\n        }\n        total_trips += (count + capacity - 1) / capacity;\n    }\n    return total_trips;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] & 1) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_120", "completion": "```cpp\n#include <vector>\n#include <cstdint>\n\nint64_t solution(const std::vector<int16_t>& lst) {\n    int64_t sum = 0;\n    for (size_t i = 0; i < lst.size(); i += 2) {\n        if (lst[i] % 2 != 0) {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; ++i) {\n        int num = arr[i];\n        if (std::abs(num) <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint add_elements(const std::vector<int>& arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (std::abs(arr[i]) <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        int num = arr[i];\n        if (num >= -99 && num <= 99) {\n            sum += num;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_121", "completion": "```cpp\n#include <vector>\n\nint add_elements(std::vector<int> arr, int k) {\n    int sum = 0;\n    for (int i = 0; i < k; i++) {\n        if (arr[i] >= -99 && arr[i] <= 99) {\n            sum += arr[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty()) \n        return true;\n\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] < lst[i-1]) {\n            return false;\n        }\n    }\n\n    int count = 1;\n    for (int i = 1; i < lst.size(); i++) {\n        if (lst[i] == lst[i-1]) {\n            count++;\n        } else {\n            if (count > 2) {\n                return false;\n            }\n            count = 1;\n        }\n    }\n    if (count > 2) {\n        return false;\n    }\n\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.size() <= 1) {\n        return true;\n    }\n    int count = 1;\n    for (size_t i = 0; i < lst.size() - 1; ++i) {\n        if (lst[i] > lst[i + 1]) {\n            return false;\n        }\n        if (lst[i] == lst[i + 1]) {\n            count++;\n        } else {\n            count = 1;\n        }\n        if (count > 2) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n\nbool is_sorted(const std::vector<int> & lst) {\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i > 0 && lst[i] < lst[i-1]) {\n            return false;\n        }\n        if (i >= 2 && lst[i] == lst[i-1] && lst[i] == lst[i-2]) {\n            return false;\n        }\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n\nbool is_sorted(const std::vector<int> & lst) {\n    if (lst.empty())\n        return true;\n    \n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] < lst[i-1])\n            return false;\n    }\n    \n    int count = 1;\n    for (int i = 1; i < lst.size(); ++i) {\n        if (lst[i] == lst[i-1]) \n            ++count;\n        else \n            count = 1;\n        \n        if (count > 2) \n            return false;\n    }\n    \n    return true;\n}\n```"}
{"task_id": "SimdBench_122", "completion": "```cpp\n#include <vector>\n\nbool is_sorted(const std::vector<int> & lst) {\n    int n = lst.size();\n    if (n <= 1) {\n        return true;\n    }\n    int count = 1;\n    for (int i = 0; i < n - 1; ++i) {\n        if (lst[i] > lst[i+1]) {\n            return false;\n        }\n        if (lst[i] == lst[i+1]) {\n            ++count;\n        } else {\n            if (count > 2) {\n                return false;\n            }\n            count = 1;\n        }\n    }\n    if (count > 2) {\n        return false;\n    }\n    return true;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sum_abs = 0;\n    int sign_product = 1;\n    for (int num : arr) {\n        sum_abs += std::abs(num);\n        if (sign_product != 0) {\n            if (num < 0) {\n                sign_product *= -1;\n            } else if (num == 0) {\n                sign_product = 0;\n            }\n        }\n    }\n    return sign_product * sum_abs;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sign_product = 1;\n    int sum_abs = 0;\n    for (int num : arr) {\n        if (sign_product != 0) {\n            if (num == 0) {\n                sign_product = 0;\n            } else if (num < 0) {\n                sign_product *= -1;\n            }\n        }\n        sum_abs += std::abs(num);\n    }\n    return sign_product * sum_abs;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sign_product = 1;\n    int abs_sum = 0;\n    for (int num : arr) {\n        abs_sum += std::abs(num);\n        if (num == 0) {\n            sign_product = 0;\n        } else if (num < 0) {\n            sign_product *= -1;\n        }\n    }\n    return sign_product * abs_sum;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint prod_signs(const std::vector<int> & arr) {\n    if (arr.empty()) {\n        return -32768;\n    }\n    int sign_prod = 1;\n    int sum_abs = 0;\n    for (int num : arr) {\n        sum_abs += std::abs(num);\n        if (num == 0) {\n            sign_prod = 0;\n        } else if (num < 0) {\n            sign_prod *= -1;\n        }\n    }\n    return sign_prod * sum_abs;\n}\n```"}
{"task_id": "SimdBench_123", "completion": "```cpp\nint prod_signs(const std::vector<int> & arr){\n    if (arr.empty()) \n        return -32768;\n    int sum_abs = 0;\n    int sign_prod = 1;\n    for (int num : arr) {\n        if (num < 0) {\n            sum_abs += -num;\n        } else {\n            sum_abs += num;\n        }\n        if (sign_prod != 0) {\n            if (num == 0) {\n                sign_prod = 0;\n            } else if (num < 0) {\n                sign_prod *= -1;\n            }\n        }\n    }\n    return sign_prod * sum_abs;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<int> minPath(const vector<vector<int>>& grid, int k) {\n    int n = grid.size();\n    int start_i = -1, start_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                start_i = i;\n                start_j = j;\n            }\n        }\n    }\n    if (k == 1) {\n        return {1};\n    }\n    vector<int> dx = {0, 0, 1, -1};\n    vector<int> dy = {1, -1, 0, 0};\n    vector<vector<vector<int>>> dp_prev(n, vector<vector<int>>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp_prev[i][j] = { grid[i][j] };\n        }\n    }\n    for (int r = 1; r < k; r++) {\n        vector<vector<vector<int>>> dp_curr(n, vector<vector<int>>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int best_ni = -1, best_nj = -1;\n                for (int d = 0; d < 4; d++) {\n                    int ni = i + dx[d];\n                    int nj = j + dy[d];\n                    if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n                        if (best_ni == -1) {\n                            best_ni = ni;\n                            best_nj = nj;\n                        } else {\n                            if (dp_prev[ni][nj] < dp_prev[best_ni][best_nj]) {\n                                best_ni = ni;\n                                best_nj = nj;\n                            }\n                        }\n                    }\n                }\n                if (best_ni == -1) {\n                    dp_curr[i][j] = { grid[i][j] };\n                } else {\n                    vector<int> candidate;\n                    candidate.push_back(grid[i][j]);\n                    candidate.insert(candidate.end(), dp_prev[best_ni][best_nj].begin(), dp_prev[best_ni][best_nj].end());\n                    dp_curr[i][j] = candidate;\n                }\n            }\n        }\n        dp_prev = move(dp_curr);\n    }\n    return dp_prev[start_i][start_j];\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int r0 = -1, c0 = -1;\n    bool found = false;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                r0 = i;\n                c0 = j;\n                found = true;\n                break;\n            }\n        }\n        if (found) break;\n    }\n    std::vector<int> res;\n    res.push_back(1);\n    if (k == 1) {\n        return res;\n    }\n    \n    int min_neighbor = n * n + 1;\n    int dr[] = {0, 0, 1, -1};\n    int dc[] = {1, -1, 0, 0};\n    for (int d = 0; d < 4; d++) {\n        int nr = r0 + dr[d];\n        int nc = c0 + dc[d];\n        if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n            if (grid[nr][nc] < min_neighbor) {\n                min_neighbor = grid[nr][nc];\n            }\n        }\n    }\n    \n    for (int i = 1; i < k; i++) {\n        if (i % 2 == 1) {\n            res.push_back(min_neighbor);\n        } else {\n            res.push_back(1);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <climits>\nusing namespace std;\n\nvector<int> minPath(const vector<vector<int> > & grid, int k) {\n    int n = grid.size();\n    int r0 = -1, c0 = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                r0 = i;\n                c0 = j;\n                break;\n            }\n        }\n    }\n    vector<int> res = {1};\n    int r = r0, c = c0;\n    vector<int> dirs = {0, 1, 0, -1, 0};\n    for (int step = 1; step < k; step++) {\n        int min_val = INT_MAX;\n        int next_r = -1, next_c = -1;\n        for (int d = 0; d < 4; d++) {\n            int nr = r + dirs[d];\n            int nc = c + dirs[d+1];\n            if (nr >= 0 && nr < n && nc >= 0 && nc < n) {\n                if (grid[nr][nc] < min_val) {\n                    min_val = grid[nr][nc];\n                    next_r = nr;\n                    next_c = nc;\n                }\n            }\n        }\n        res.push_back(min_val);\n        r = next_r;\n        c = next_c;\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int r0 = -1, c0 = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                r0 = i;\n                c0 = j;\n                break;\n            }\n        }\n        if (r0 != -1) break;\n    }\n    \n    if (k == 1) {\n        return {1};\n    }\n    \n    int dr[4] = {0, 0, 1, -1};\n    int dc[4] = {1, -1, 0, 0};\n    int m1 = 1000000000;\n    for (int d = 0; d < 4; d++) {\n        int r = r0 + dr[d];\n        int c = c0 + dc[d];\n        if (r >= 0 && r < n && c >= 0 && c < n) {\n            if (grid[r][c] < m1) {\n                m1 = grid[r][c];\n            }\n        }\n    }\n    \n    std::vector<int> res;\n    for (int i = 0; i < k; i++) {\n        if (i % 2 == 0) {\n            res.push_back(1);\n        } else {\n            res.push_back(m1);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_124", "completion": "```cpp\n#include <vector>\n#include <climits>\n#include <algorithm>\n\nstd::vector<int> minPath(const std::vector<std::vector<int> > & grid, int k) {\n    int n = grid.size();\n    int i0 = -1, j0 = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (grid[i][j] == 1) {\n                i0 = i;\n                j0 = j;\n            }\n        }\n    }\n    if (k == 1) {\n        return {1};\n    }\n    int a = INT_MAX;\n    if (i0 - 1 >= 0) {\n        a = std::min(a, grid[i0-1][j0]);\n    }\n    if (i0 + 1 < n) {\n        a = std::min(a, grid[i0+1][j0]);\n    }\n    if (j0 - 1 >= 0) {\n        a = std::min(a, grid[i0][j0-1]);\n    }\n    if (j0 + 1 < n) {\n        a = std::min(a, grid[i0][j0+1]);\n    }\n    std::vector<int> res;\n    res.push_back(1);\n    for (int i = 1; i < k; i++) {\n        if (i % 2 == 1) {\n            res.push_back(a);\n        } else {\n            res.push_back(1);\n        }\n    }\n    return res;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\nuint64_t digits(uint64_t n){\n    uint64_t product = 1;\n    int found_odd = 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found_odd = 1;\n        }\n    }\n    if (found_odd) {\n        return product;\n    } else {\n        return 0;\n    }\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\n#include <cstdint>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool found_odd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found_odd = true;\n        }\n    }\n    if (found_odd) {\n        return product;\n    } else {\n        return 0;\n    }\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```cpp\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    bool foundOdd = false;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            foundOdd = true;\n        }\n        n /= 10;\n    }\n    return foundOdd ? product : 0;\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int found_odd = 0;\n    while (n > 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n        if (digit % 2 == 1) {\n            product *= digit;\n            found_odd = 1;\n        }\n    }\n    if (found_odd) {\n        return product;\n    } else {\n        return 0;\n    }\n}\n```"}
{"task_id": "SimdBench_125", "completion": "```c\n#include <stdint.h>\n\nuint64_t digits(uint64_t n) {\n    uint64_t product = 1;\n    int found_odd = 0;\n    while (n != 0) {\n        uint64_t digit = n % 10;\n        n /= 10;\n        if (digit % 2 == 1) {\n            found_odd = 1;\n            product *= digit;\n        }\n    }\n    if (!found_odd) {\n        return 0;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t total = 0;\n    for (float x : lst) {\n        double c = std::ceil(static_cast<double>(x));\n        total += static_cast<uint64_t>(c * c);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float x : lst) {\n        double ceiled = std::ceil(static_cast<double>(x));\n        sum += static_cast<uint64_t>(ceiled * ceiled);\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t total = 0;\n    for (float num : lst) {\n        float ceiled = std::ceil(num);\n        total += static_cast<uint64_t>(ceiled * ceiled);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n\nuint64_t sum_squares(const std::vector<float> & lst){\n    uint64_t total = 0;\n    for (float x : lst) {\n        double dx = static_cast<double>(x);\n        double ceiled = std::ceil(dx);\n        ceiled = std::fabs(ceiled);\n        uint64_t n = static_cast<uint64_t>(ceiled);\n        total += n * n;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_126", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t sum_squares(const std::vector<float> & lst) {\n    uint64_t total = 0;\n    for (float num : lst) {\n        float ceiling = std::ceil(num);\n        total += static_cast<uint64_t>(ceiling * ceiling);\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr){\n    int result = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] <= arr[i-1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr){\n    for (int i = arr.size() - 1; i >= 1; --i) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    for (int i = arr.size() - 1; i >= 1; --i) {\n        if (arr[i] < arr[i-1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    int result = -1;\n    for (int i = 1; i < arr.size(); ++i) {\n        if (arr[i] <= arr[i-1]) {\n            result = i;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_127", "completion": "```cpp\n#include <vector>\n\nint can_arrange(const std::vector<int> & arr) {\n    if (arr.size() < 2) {\n        return -1;\n    }\n    for (int i = arr.size() - 1; i >= 1; --i) {\n        if (arr[i] <= arr[i - 1]) {\n            return i;\n        }\n    }\n    return -1;\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int max_neg = 0;\n    int min_pos = 0;\n    for (int num : lst) {\n        if (num < 0) {\n            if (max_neg == 0 || num > max_neg) {\n                max_neg = num;\n            }\n        }\n        if (num > 0) {\n            if (min_pos == 0 || num < min_pos) {\n                min_pos = num;\n            }\n        }\n    }\n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int neg_max = 0;\n    int pos_min = 0;\n    for (int num : lst) {\n        if (num < 0) {\n            if (neg_max == 0 || num > neg_max) {\n                neg_max = num;\n            }\n        } else if (num > 0) {\n            if (pos_min == 0 || num < pos_min) {\n                pos_min = num;\n            }\n        }\n    }\n    return {neg_max, pos_min};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int a = 0;\n    int b = 0;\n    for (int x : lst) {\n        if (x < 0) {\n            if (a == 0 || x > a) {\n                a = x;\n            }\n        } else if (x > 0) {\n            if (b == 0 || x < b) {\n                b = x;\n            }\n        }\n    }\n    return {a, b};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int max_neg = 0;\n    int min_pos = 0;\n    \n    for (int x : lst) {\n        if (x < 0) {\n            if (max_neg == 0 || x > max_neg) {\n                max_neg = x;\n            }\n        } else if (x > 0) {\n            if (min_pos == 0 || x < min_pos) {\n                min_pos = x;\n            }\n        }\n    }\n    \n    return {max_neg, min_pos};\n}\n```"}
{"task_id": "SimdBench_128", "completion": "To solve this problem, we need to find the largest negative integer (closest to zero) and the smallest positive integer in a given vector. If there are no negative integers, the first element of the result should be 0. Similarly, if there are no positive integers, the second element should be 0.\n\n### Approach\n1. **Initialization**: Initialize two variables, `largest_negative` and `smallest_positive`, to 0. These will hold the largest negative and smallest positive integers found in the vector, respectively.\n2. **Iterate through the vector**: For each number in the vector:\n   - If the number is negative, check if it is the first negative encountered or if it is larger (closer to zero) than the current `largest_negative`. If so, update `largest_negative`.\n   - If the number is positive, check if it is the first positive encountered or if it is smaller than the current `smallest_positive`. If so, update `smallest_positive`.\n3. **Return the result**: After processing all elements, return a vector containing `largest_negative` and `smallest_positive`.\n\n### Solution Code\n```cpp\n#include <vector>\n\nstd::vector<int> largest_smallest_integers(const std::vector<int>& lst) {\n    int largest_negative = 0;\n    int smallest_positive = 0;\n\n    for (int num : lst) {\n        if (num < 0) {\n            if (largest_negative == 0 || num > largest_negative) {\n                largest_negative = num;\n            }\n        } else if (num > 0) {\n            if (smallest_positive == 0 || num < smallest_positive) {\n                smallest_positive = num;\n            }\n        }\n    }\n\n    return {largest_negative, smallest_positive};\n}\n```\n\n### Explanation\n1. **Initialization**: The variables `largest_negative` and `smallest_positive` are initialized to 0. These values will be returned if no negative or positive integers are found, respectively.\n2. **Processing Elements**: For each element in the input vector:\n   - **Negative Numbers**: If a number is negative, it is compared with `largest_negative`. If `largest_negative` is 0 (indicating no negative number has been processed yet) or the current number is larger (closer to zero) than `largest_negative`, `largest_negative` is updated to this number.\n   - **Positive Numbers**: If a number is positive, it is compared with `smallest_positive`. If `smallest_positive` is 0 (indicating no positive number has been processed yet) or the current number is smaller than `smallest_positive`, `smallest_positive` is updated to this number.\n3. **Result Construction**: The function returns a vector containing `largest_negative` and `smallest_positive`. If no negatives or positives were found, these values remain 0 as initialized.\n\nThis approach efficiently processes each element in the vector exactly once, making the solution both optimal and straightforward with a time complexity of O(n), where n is the number of elements in the input vector."}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_fact = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        current_fact *= i;\n        result *= current_fact;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t product = 1;\n    uint64_t current_fact = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        current_fact *= i;\n        product *= current_fact;\n    }\n    return product;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t result = 1;\n    uint64_t current_fact = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        current_fact *= i;\n        result *= current_fact;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    if (n == 0) {\n        return 1;\n    }\n    uint64_t result = 1;\n    uint64_t current_fact = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        current_fact *= i;\n        result *= current_fact;\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_129", "completion": "```c\n#include <stdint.h>\n\nuint64_t special_factorial(uint64_t n) {\n    uint64_t total = 1;\n    uint64_t fact = 1;\n    for (uint64_t i = 1; i <= n; i++) {\n        fact *= i;\n        total *= fact;\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int total = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int total = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (size_t i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst) {\n    int sum = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            sum += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            sum += lst[i] * lst[i] * lst[i];\n        } else {\n            sum += lst[i];\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_130", "completion": "```cpp\n#include <vector>\n\nint sum_squares(const std::vector<int> & lst){\n    int total = 0;\n    for (int i = 0; i < lst.size(); ++i) {\n        if (i % 3 == 0) {\n            total += lst[i] * lst[i];\n        } else if (i % 4 == 0) {\n            total += lst[i] * lst[i] * lst[i];\n        } else {\n            total += lst[i];\n        }\n    }\n    return total;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) \n            continue;\n        \n        int last_digit = num % 10;\n        int temp = num;\n        while (temp >= 10) {\n            temp /= 10;\n        }\n        int first_digit = temp;\n        \n        if (first_digit % 2 != 0 && last_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums){\n    int count = 0;\n    for (int n : nums) {\n        if (n <= 10) \n            continue;\n        \n        int last_digit = n % 10;\n        int temp = n;\n        while (temp >= 10) {\n            temp /= 10;\n        }\n        int first_digit = temp;\n        \n        if (last_digit % 2 != 0 && first_digit % 2 != 0) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int last = num % 10;\n            int first = num;\n            while (first >= 10) {\n                first /= 10;\n            }\n            if (first % 2 != 0 && last % 2 != 0) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num <= 10) {\n            continue;\n        }\n        int last_digit = num % 10;\n        int temp = num;\n        while (temp >= 10) {\n            temp /= 10;\n        }\n        int first_digit = temp;\n        if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n            count++;\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_131", "completion": "```cpp\n#include <vector>\n#include <cmath>\n\nint specialFilter(const std::vector<int> & nums) {\n    int count = 0;\n    for (int num : nums) {\n        if (num > 10) {\n            int n_abs = std::abs(num);\n            int last_digit = n_abs % 10;\n            int temp = n_abs;\n            while (temp >= 10) {\n                temp /= 10;\n            }\n            int first_digit = temp;\n            if (first_digit % 2 == 1 && last_digit % 2 == 1) {\n                count++;\n            }\n        }\n    }\n    return count;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    uint64_t r0 = n / 3;\n    uint64_t r1 = (n + 2) / 3;\n    uint64_t r2 = (n + 1) / 3;\n    uint64_t r01 = r0 + r1;\n\n    auto nC3 = [](uint64_t x) -> uint64_t {\n        if (x < 3) return 0;\n        if (x < 1000000) {\n            return x * (x - 1) * (x - 2) / 6;\n        }\n        __uint128_t product = (__uint128_t)x * (x - 1) * (x - 2);\n        return static_cast<uint64_t>(product / 6);\n    };\n\n    return nC3(r2) + nC3(r01);\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <cstdint>\n\nuint64_t choose3(uint64_t x) {\n    if (x < 3) return 0;\n    return x * (x-1) / 2 * (x-2) / 3;\n}\n\nuint64_t get_max_triples(uint64_t n) {\n    uint64_t count0 = (n + 1) / 3;\n    uint64_t count1 = n - count0;\n    return choose3(count0) + choose3(count1);\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    uint64_t base = n / 3;\n    uint64_t rem = n % 3;\n    uint64_t r0 = base;\n    uint64_t r1 = base + (rem >= 1);\n    uint64_t r2 = base + (rem >= 2);\n    uint64_t count0 = r2;\n    uint64_t count1 = r0 + r1;\n    uint64_t comb0 = (count0 >= 3) ? (count0 * (count0 - 1) * (count0 - 2) / 6 : 0;\n    uint64_t comb1 = (count1 >= 3) ? (count1 * (count1 - 1) * (count1 - 2) / 6 : 0;\n    return comb0 + comb1;\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    uint64_t r0 = n / 3;\n    uint64_t r1 = (n + 2) / 3;\n    uint64_t r2 = (n + 1) / 3;\n    uint64_t count1 = r0 + r1;\n    uint64_t count2 = r2;\n\n    auto nC3 = [](uint64_t x) -> uint64_t {\n        if (x < 3) return 0;\n        return x * (x - 1) * (x - 2) / 6;\n    };\n\n    return nC3(count1) + nC3(count2);\n}\n```"}
{"task_id": "SimdBench_132", "completion": "```cpp\n#include <cstdint>\n\nuint64_t get_max_triples(uint64_t n) {\n    uint64_t count2 = (n + 1) / 3;\n    uint64_t rest = n - count2;\n    \n    auto comb3 = [](uint64_t x) -> uint64_t {\n        if (x < 3) return 0;\n        __uint128_t product = static_cast<__uint128_t>(x) * (x - 1);\n        product = product * (x - 2);\n        product /= 6;\n        return static_cast<uint64_t>(product);\n    };\n    \n    return comb3(count2) + comb3(rest);\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n    for (int i = 3; i * i <= n; i += 2)\n        if (n % i == 0)\n            return y;\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n < 2) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n    for (int i = 3; i * i <= n; i += 2)\n        if (n % i == 0) return y;\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n < 2) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y){\n    if (n < 2) return y;\n    if (n == 2) return x;\n    if (n % 2 == 0) return y;\n    for (int i = 3; i * i <= n; i += 2) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_133", "completion": "```c\nint x_or_y(int n, int x, int y) {\n    if (n < 2) return y;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) return y;\n    }\n    return x;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float x : lst) {\n        if (x <= 0.0f || !std::isfinite(x)) {\n            continue;\n        }\n        float int_part;\n        float frac = std::modf(x, &int_part);\n        if (frac == 0.0f) {\n            uint64_t n = static_cast<uint64_t>(int_part);\n            if (n % 2 == 1) {\n                sum += n * n;\n            }\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    for (float num : lst) {\n        if (num <= 0.0f || !std::isfinite(num)) {\n            continue;\n        }\n        float int_part;\n        float fractional = std::modf(num, &int_part);\n        if (fractional != 0.0f) {\n            continue;\n        }\n        uint64_t n = static_cast<uint64_t>(num);\n        if (n % 2 == 1) {\n            sum += n * n;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    for (float x : lst) {\n        if (x < 0.0f || !std::isfinite(x)) {\n            continue;\n        }\n        float int_part;\n        float frac = std::modf(x, &int_part);\n        if (frac == 0.0f) {\n            uint64_t n = static_cast<uint64_t>(int_part);\n            if (n % 2 == 1) {\n                result += n * n;\n            }\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <limits>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t sum = 0;\n    const float max_uint64_as_float = static_cast<float>(std::numeric_limits<uint64_t>::max());\n    for (float num : lst) {\n        if (num < 0 || !std::isfinite(num)) {\n            continue;\n        }\n        float int_part;\n        float frac = std::modf(num, &int_part);\n        if (frac != 0.0f) {\n            continue;\n        }\n        if (int_part >= max_uint64_as_float) {\n            continue;\n        }\n        uint64_t n = static_cast<uint64_t>(int_part);\n        if (n % 2 == 1) {\n            sum += n * n;\n        }\n    }\n    return sum;\n}\n```"}
{"task_id": "SimdBench_134", "completion": "```cpp\n#include <cmath>\n#include <vector>\n#include <cstdint>\n\nuint64_t double_the_difference(const std::vector<float> & lst) {\n    uint64_t result = 0;\n    const float max_val = 4294967296.0f;\n\n    for (float x : lst) {\n        if (x <= 0.0f) {\n            continue;\n        }\n        float intpart;\n        float frac = std::modf(x, &intpart);\n        if (frac != 0.0f) {\n            continue;\n        }\n        if (intpart >= max_val) {\n            continue;\n        }\n        uint64_t n = static_cast<uint64_t>(intpart);\n        if (n % 2 == 1) {\n            result += n * n;\n        }\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        result.push_back(std::abs(game[i] - guess[i]));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = game[i] - guess[i];\n        result.push_back(std::abs(diff));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        long long diff = static_cast<long long>(game[i]) - static_cast<long long>(guess[i]);\n        long long abs_diff = llabs(diff);\n        result.push_back(static_cast<int>(abs_diff));\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n#include <cstdlib>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess) {\n    std::vector<int> result(game.size());\n    for (int i = 0; i < (int)game.size(); i++) {\n        int diff = game[i] - guess[i];\n        result[i] = std::abs(diff);\n    }\n    return result;\n}\n```"}
{"task_id": "SimdBench_135", "completion": "```cpp\n#include <vector>\n\nstd::vector<int> compare(const std::vector<int>& game, const std::vector<int>& guess){\n    std::vector<int> result;\n    for (size_t i = 0; i < game.size(); ++i) {\n        int diff = game[i] - guess[i];\n        if (diff < 0) \n            diff = -diff;\n        result.push_back(diff);\n    }\n    return result;\n}\n```"}
